                     VER_PRODUCTVERSION };
#endif

#pragma data_seg(pop)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ScreenTest\screentest.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ScreenTest.cpp

Abstract:

    Screens XBOX units entering Repair & Refurbish.  Prints basic unit info
	 and validates the basic operation of the Duke, Audio, HDD

Author:

    Dennis Krueger (a-denkru) July 2001

Comments:
	This is intended as a high-level general purpose screening tool, not as a diagnostic.  Tests are
	intended to demonstrate only superficial functionality:
	The hard disk test tests only whether free space can be acquired.
	The Gamepad test tests only whether or not the game pad is accessable


Modified: 

--*/

#include "ScreenTest.h"


#define WHITECOLOR 0xffffffff
#define CRIMSONCOLOR 0xffDC143C
#define TITLECOLOR	0xffffd700


NTSTATUS
ResetEEPROMUserSettings(
    VOID
    )
/*++

Routine Description:

    Reset user settings in EEPROM to their defaults

Arguments:

    None

Return Value:

    Status of the operation

--*/
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS Status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*)buf;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(userSettings, sizeof(*userSettings));

        if (XGetGameRegion() == XC_GAME_REGION_JAPAN) {
            userSettings->Language = XC_LANGUAGE_JAPANESE;
            userSettings->TimeZoneBias = -540;
            strcpy(userSettings->TimeZoneStdName, "TST");
            strcpy(userSettings->TimeZoneDltName, "TST");
        }

        userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
        Status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));
    }

    return Status;
}


// support methods for TextScreenLine and TextScreenArray 
CTextScreenLine::CTextScreenLine()
{
	m_sx = 0;
	m_sy = 0;
	m_dwColor = 0;
	m_strText = NULL;
	m_dwFlags = 0;
}

CTextScreenLine::CTextScreenLine(float sx, float sy, DWORD Color, WCHAR * pTextStr, DWORD dwFlags)
{
	m_sx = sx;
	m_sy = sy;
	m_dwColor = Color;
	m_strText = pTextStr;
	m_dwFlags = dwFlags;
};



CTextScreenArray::CTextScreenArray()
{
	m_LineCount = 0;
}


CTextScreenArray::~CTextScreenArray()
{
	;
}



int CTextScreenArray::Add(CTextScreenLine * pThisLine)
{
	if(m_LineCount >= MAX_LINES) return -1;
	m_TextLines[m_LineCount] = pThisLine;
	m_LineCount++;
	return m_LineCount-1;  // return index
}

int CTextScreenArray::Replace(CTextScreenLine * pThisLine, int Index)
{
	if(Index >= MAX_LINES) return -1;
	m_TextLines[Index] = pThisLine;
	return Index;  // return index
}

int CTextScreenArray::GetLineCount()
{
	return m_LineCount;
}

CTextScreenLine *
CTextScreenArray::GetLine(int Index)
{
	if(Index >= m_LineCount) return NULL; // out of range
	return m_TextLines[Index];
}

CXBoxUtility::CXBoxUtility()	
		:CXBApplication()
{
	m_fAudioOK = TRUE;
	m_fPlaying = FALSE;
	m_iPlayIndex = 0;
	m_pAudioLine = NULL;
	m_GamePadLineIndex = 0;
}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
//_asm Int 3
    CXBoxUtility xbUtility;
    if( FAILED( xbUtility.Create() ) )
        return;
    xbUtility.Run();
}



HRESULT CXBoxUtility::Initialize()
{
	NTSTATUS ntStatus;

//_asm Int 3
    // Create font
    if( FAILED( m_Font16.Create( g_pd3dDevice, "Font16.xpr" ) ) )
        return E_FAIL;

	// Title Line
	CTextScreenLine * pTitleLine = new CTextScreenLine(210,60,TITLECOLOR,L"OOBA Screen Test",0);
	m_ThisScreen.Add(pTitleLine);


	// build text array for screen

	// read Disk Power On date and Power Cycle Count from eeprom
	ntStatus = ExReadWriteRefurbInfo( &m_RefurbInfo, sizeof(XBOX_REFURB_INFO),FALSE);
	if(NT_SUCCESS(ntStatus))
	{
		// Display power on date
		SYSTEMTIME SystemTime;
		FileTimeToSystemTime((FILETIME *)&m_RefurbInfo.FirstSetTime,&SystemTime);
		PWCHAR pPowerOnBuff = new WCHAR[60];
		wsprintf(pPowerOnBuff,L"PowerOn Date:  %02d.%02d.%04d",SystemTime.wMonth,SystemTime.wDay,SystemTime.wYear);
		CTextScreenLine * pPowerOnLine = new CTextScreenLine(160,140,WHITECOLOR,pPowerOnBuff,0);
		m_ThisScreen.Add(pPowerOnLine);

		// Display Number of Power Cycles since Power On Date
		PWCHAR pPowerCyclesBuff = new WCHAR[60];
		wsprintf(pPowerCyclesBuff,L"Power Cycles: %d", m_RefurbInfo.PowerCycleCount);
		CTextScreenLine * pPowerCycles = new CTextScreenLine(160,160,WHITECOLOR,pPowerCyclesBuff,0);
		m_ThisScreen.Add(pPowerCycles);
	} else
	{
		CTextScreenLine * pEEPROMFailLine = new CTextScreenLine(160,140,CRIMSONCOLOR,L"Hard disk access error");
		m_ThisScreen.Add(pEEPROMFailLine);
	}
	// Duke functions will be tested in the framemove loop in order to detect removals and inserts
	

	// check Hard Drive function
	// going to get the disk free space, if the query succeeds the hd is at least accessable
	BOOL bResult;
	OBJECT_STRING c_cDrive = CONSTANT_OBJECT_STRING("\\??\\C:");
	OBJECT_STRING c_cPath  = CONSTANT_OBJECT_STRING("\\Device\\Harddisk0\\partition1");
	ULONG ulAvail, ulTotal, ulFree;
	ULARGE_INTEGER AvailableBytes,TotalBytes,FreeBytes;
	IoCreateSymbolicLink(&c_cDrive, &c_cPath);
	bResult = GetDiskFreeSpaceEx("C:\\",&AvailableBytes,&TotalBytes,&FreeBytes);
	CTextScreenLine * pHDLine;
	if(bResult == FALSE)
	{
		pHDLine = new CTextScreenLine(160,200,CRIMSONCOLOR,L"Hard Disk Failure!!",0);
	} else
	{
		pHDLine = new CTextScreenLine(160,200,WHITECOLOR,L"Hard Disk Detected OK",0);
	}
	m_ThisScreen.Add(pHDLine);


	// setup Audio test
	HRESULT hResult;
	hResult = m_LeftSound.Create("Left.wav");
	if(!FAILED(hResult))
	{
		DSMIXBINVOLUMEPAIR dsmbvp = { DSMIXBIN_FRONT_LEFT, DSBVOLUME_MAX };
		DSMIXBINS dsmb = { 1, &dsmbvp };

		m_LeftSound.SetMixBins(&dsmb);
		hResult = m_RightSound.Create("Right.wav");
	}

	if(!FAILED(hResult))
	{
		DSMIXBINVOLUMEPAIR dsmbvp = { DSMIXBIN_FRONT_RIGHT, DSBVOLUME_MAX };
		DSMIXBINS dsmb = { 1, &dsmbvp };

		m_RightSound.SetMixBins(&dsmb);
		hResult = m_StereoSound.Create("Stereo.wav");
	}
	if(FAILED(hResult))
	{
		m_fAudioOK = FALSE;
		m_pAudioLine = new CTextScreenLine(160,220,CRIMSONCOLOR,L"Did not find Wave Files for Audio Test",0);
		m_ThisScreen.Add(m_pAudioLine);
		return S_OK;
	}

	return S_OK;
}


HRESULT CXBoxUtility::FrameMove()
{
	DWORD dwElapsedSecs;
	SYSTEMTIME CurrTime;
	WCHAR DebugBuffer[80];
	NTSTATUS EEPROMResetStatus;

// check Duke functionality
	CTextScreenLine * pGamePadLine;
	bool bGamepadFound = FALSE;
	for (int i = 0; i<4; i++)
	{
		if(g_Gamepads[i].hDevice) bGamepadFound = TRUE;

	}

	if(bGamepadFound== TRUE)
	{
		PWCHAR pPadBuffer = new WCHAR[60];
		swprintf(pPadBuffer,L"Game Pad detected on port ");
		for(int i = 0; i< 4; i++)
		{
			WCHAR cPort[4];
			if(g_Gamepads[i].hDevice)
			{
				swprintf(cPort,L"%d ",i+1);
				lstrcat(pPadBuffer,cPort);
			}
		}
		pGamePadLine = new CTextScreenLine(160,180,WHITECOLOR,pPadBuffer);
	} else
	{
		pGamePadLine = new CTextScreenLine(160,180,CRIMSONCOLOR,L"No Game Pads Found");
	}

	if(m_GamePadLineIndex == 0)
	{

		m_GamePadLineIndex = m_ThisScreen.Add(pGamePadLine);
	} else
	{
		m_ThisScreen.Replace(pGamePadLine,m_GamePadLineIndex);
	}

	if(m_fAudioOK == FALSE) return S_OK;  // failed audio file load

	if(m_fPlaying == FALSE )
	{
		// start audio - increment through left,right,stereo & stop
		switch (m_iPlayIndex)
		{
		case 0:
			m_LeftSound.Play(DSBPLAY_LOOPING);
			m_pAudioLine = new CTextScreenLine(160,220,WHITECOLOR,L"Audio Test Left Output ...");
			m_AudioLineIndex = m_ThisScreen.Add(m_pAudioLine); // add first
			m_fPlaying = TRUE;
			m_iPlayIndex++;

			break;
		case 1:
			m_LeftSound.Stop();
			m_RightSound.Play(DSBPLAY_LOOPING);
			m_pAudioLine = new CTextScreenLine(160,220,WHITECOLOR,L"Audio Test Right Output ...");
			m_ThisScreen.Replace(m_pAudioLine,m_AudioLineIndex);
			m_fPlaying = TRUE;
			m_iPlayIndex++;
			break;
		
		case 2:	
			m_RightSound.Stop();
			m_StereoSound.Play(DSBPLAY_LOOPING); // play for 5 secs
			m_pAudioLine = new CTextScreenLine(160,220,WHITECOLOR,L"Audio Stereo Output ...");
			m_ThisScreen.Replace(m_pAudioLine,m_AudioLineIndex);
			m_fPlaying = TRUE;
			m_iPlayIndex++;
			break;
		case 3:
			m_StereoSound.Stop();
			EEPROMResetStatus = ResetEEPROMUserSettings();
			m_pAudioLine = new CTextScreenLine(160,220,WHITECOLOR,L"Audio Test Concluded");
			m_ThisScreen.Replace(m_pAudioLine,m_AudioLineIndex);
			if (NT_SUCCESS(EEPROMResetStatus))
			{
				m_ThisScreen.Add(new CTextScreenLine(230,270,0xff7cfc00,L"Test Finished"));
			}
			else
			{
				m_ThisScreen.Add(new CTextScreenLine(230,270,CRIMSONCOLOR,L"Test Aborted - User EEPROM Reset Failed"));
			}
			m_iPlayIndex++;
			
		}
		m_AudioStartTicks = GetTickCount();
	}
    
	
	// get elapsed time for this audio loop
	GetSystemTime(&CurrTime);
	DWORD CurrTicks = GetTickCount();
	dwElapsedSecs = (CurrTicks - m_AudioStartTicks)/1000;
	if(dwElapsedSecs >= 6 && m_fPlaying == TRUE)
	{
		m_fPlaying = FALSE;
	}	
	return S_OK;
}


HRESULT CXBoxUtility::Render()
{
	CTextScreenLine * pThisLine;
	// Draw a gradient filled background
    RenderGradientBackground(0xff00000f, 0xff000fff );
	// draw text on the screen
	int ScreenLines = m_ThisScreen.GetLineCount();
	m_Font16.Begin();

	for(int i = 0; i<ScreenLines;i++)
	{
		// get current line
		pThisLine = m_ThisScreen.GetLine(i);
		if(pThisLine)
		{
			m_Font16.DrawText(pThisLine->m_sx,
				pThisLine->m_sy,
				pThisLine->m_dwColor,
				pThisLine->m_strText,
				pThisLine->m_dwFlags
				);
		}
	}
	m_Font16.End();

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\unlock\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include "pch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color )
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1;
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2;
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }

    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\WriteTest\WriteTest.cpp ===
#include <xtl.h>
//#include <xboxp.h>
#include <xdbg.h>
#include "PerBoxData.h"

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

//======================== The main function
void __cdecl main()
{
    BYTE buffer[8000];
    HANDLE hf = INVALID_HANDLE_VALUE;
    HRESULT hr;
    DWORD dwDataLen;
    BOOL bResult;
    
#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    // Open Key File
    hf = CreateFile("T:\\perBoxImage.dat",
                  GENERIC_READ,
                  0,
                  NULL,
                  OPEN_EXISTING,
                  FILE_ATTRIBUTE_NORMAL,
                  NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        goto ErrorExit;
    }

    // Get file length
    dwDataLen = GetFileSize(hf, NULL);
    if (dwDataLen == 0xFFFFFFFF)
    {
        hr = GetLastError();
        goto ErrorExit;
    }

    ASSERT( dwDataLen <= sizeof(buffer) );
    
    // Read encoded key data
    bResult = ReadFile(hf,
                (LPVOID)buffer,
                dwDataLen,
                &dwDataLen,
                NULL);
    if (!bResult)
    {
        hr = GetLastError();
        goto ErrorExit;
    }

    hr = WritePerBoxData( buffer, dwDataLen );
    if ( FAILED( hr ) )
    {
        XDBGTRC("factory", "WritePerBoxData returned %x",hr);
        goto ErrorExit;        
    }

    hr = VerifyPerBoxData();
    if ( FAILED( hr ) )
    {
        XDBGTRC("factory", "VerifyPerBoxData returned %x",hr);
        goto ErrorExit;        
    }

ErrorExit:

    if ( hf != INVALID_HANDLE_VALUE )
    {
        CloseHandle(hf);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\WritePerBoxData\writeperboxdata.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <ntos.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#include "PerBoxData.h"
#include "cryptkeys.h"
#include <smcdef.h>
#include <wpbdver.h>

// #define WRITE_EEPROM_IMAGE_TO_FILE 1

// #define DOUBLE_CHECK_EEPROM_KEY 1

// #define TEMP_CODE_FOR_TESTING 1

#define EEPROM_TAIL_PRESERVE_BYTES 2

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}


VOID WriteFileFromMemory(
    LPCSTR lpFileName,
    LPVOID pvFileContents,
    DWORD dwFileSize
    )
{
    HANDLE hFile;
    DWORD dwBytesWrote;

    hFile = CreateFile(lpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "WritePerBoxData: unable to open %s\n", lpFileName);
        return;
    }

    if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) ||
        (dwBytesWrote != dwFileSize)) {
        fprintf(stderr, "WritePerBoxData: cannot write to %s\n", lpFileName);
        return;
    }

    CloseHandle(hFile);
}


VOID ReadFileFromMemory(
    LPCSTR lpFileName,
    LPVOID pvFileContents,
    DWORD* pdwBytesRead
    )
{
    HANDLE hFile;

    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "WritePerBoxData: unable to open %s\n", lpFileName);
        return;
    }

    if (!ReadFile(hFile, pvFileContents, *pdwBytesRead, pdwBytesRead, NULL))
    {
        fprintf(stderr, "WritePerBoxData: cannot read to %s\n", lpFileName);
        return;
    }

    CloseHandle(hFile);
}

HRESULT VerifyEEPROMData();

HRESULT WritePerBoxData(
    IN LPBYTE pbInputBuffer,
    IN DWORD dwInputBufferSize
    )
{
    BOOL bResult;
    HRESULT hr;
    PXBOX_ENCRYPTED_PER_BOX_DATA pData;
    char RecoveryKey[8];
    BYTE inputBuffer[sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) + sizeof(RC4_SHA1_HEADER)];

    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    BYTE buf2[XBOX_KEY_LENGTH];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    int i;

    if ( dwInputBufferSize != sizeof(inputBuffer) )
    {
        return NTE_BAD_LEN;
    }

    //
    // Copy input data into new buffer
    //
    RtlCopyMemory( inputBuffer, pbInputBuffer, sizeof(inputBuffer) );

    bResult = rc4HmacDecrypt(
                    (LPBYTE)FACTORY_RAND_KEY, FACTORY_RAND_KEY_LEN,
                    inputBuffer + sizeof(RC4_SHA1_HEADER), sizeof(XBOX_ENCRYPTED_PER_BOX_DATA),
                    inputBuffer );
    if ( !bResult )
    {
        return NTE_BAD_DATA;
    }

    //
    // Setup pointer to decrypted data
    //
    pData = (PXBOX_ENCRYPTED_PER_BOX_DATA)(inputBuffer + sizeof(RC4_SHA1_HEADER));

#if DBG
    XDBGTRC("factory", "OnlineKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
        pData->OnlineKey[0], pData->OnlineKey[1],
        pData->OnlineKey[2], pData->OnlineKey[3],
        pData->OnlineKey[4], pData->OnlineKey[5],
        pData->OnlineKey[6], pData->OnlineKey[7],
        pData->OnlineKey[8], pData->OnlineKey[9],
        pData->OnlineKey[10], pData->OnlineKey[11],
        pData->OnlineKey[12], pData->OnlineKey[13],
        pData->OnlineKey[14], pData->OnlineKey[15]
        );

    XDBGTRC("factory", "HardDriveKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
        pData->HardDriveKey[0], pData->HardDriveKey[1],
        pData->HardDriveKey[2], pData->HardDriveKey[3],
        pData->HardDriveKey[4], pData->HardDriveKey[5],
        pData->HardDriveKey[6], pData->HardDriveKey[7],
        pData->HardDriveKey[8], pData->HardDriveKey[9],
        pData->HardDriveKey[10], pData->HardDriveKey[11],
        pData->HardDriveKey[12], pData->HardDriveKey[13],
        pData->HardDriveKey[14], pData->HardDriveKey[15]
        );

    ComputeRecoveryKey( pData->HardDriveKey, RecoveryKey );
    XDBGTRC("factory", "RecoveryKey: %.8s", RecoveryKey);

    XDBGTRC("factory", "MACAddress: %.6s", pData->MACAddress);

    XDBGTRC("factory", "XboxSerialNumber: %.12s", pData->XboxSerialNumber);

    XDBGTRC("factory", "GameRegion: %X", pData->GameRegion);

    XDBGTRC("factory", "AVRegion: %X", pData->AVRegion);
#endif

    //
    // All devkits have 16 bytes of zero for HD key
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        RtlZeroMemory( pData->HardDriveKey, sizeof(pData->HardDriveKey) );
    }

    //
    // Check some basic assumptions
    //
    ASSERT( sizeof(RC4_SHA1_HEADER) == sizeof(pEncryptedEEPROMData->EncHeader) );
    ASSERT( EEPROM_ENCRYPTED_SECTION_SIZE == sizeof(*pEncryptedEEPROMData) );

    //
    // read EEPROM Data, some tail bytes need to be preserved.
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Zero out the EEPROM buffer
    //
    RtlZeroMemory( buf, EEPROM_TOTAL_MEMORY_SIZE - EEPROM_TAIL_PRESERVE_BYTES );

    //
    // Get some pointers ready
    //
    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // Get encrypted EEPROM contents ready
    //
    pEncryptedEEPROMData->GameRegion = pData->GameRegion;
    pEncryptedEEPROMData->GameRegion |= XC_GAME_REGION_MANUFACTURING;
    RtlCopyMemory( pEncryptedEEPROMData->HardDriveKey, pData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) );

    //
    // Place in ROM slot for future use
    //
    ASSERT( XBOX_KEY_LENGTH == sizeof(pEncryptedEEPROMData->HardDriveKey) );
    RtlCopyMemory( (LPBYTE)(*XboxHDKey), pData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) );

#ifdef DOUBLE_CHECK_EEPROM_KEY
    //
    // Double check that a random EEPROM key has really been generated
    //
    ASSERT( XBOX_KEY_LENGTH == TEMP_RAND_KEY_LEN );
    if (RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ) ||
        RtlEqualMemory( TEMP_RAND_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"The EEPROM Key has not been randomly generated");
        return NTE_NO_KEY;
    }
#endif

    //
    // Encrypt the encrypted part and copy it into the EEPROM buffer
    //
    rc4HmacEncrypt(
        inputBuffer, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

#ifdef TEMP_CODE_FOR_TESTING

    rc4HmacEncrypt(
        inputBuffer, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

    for (i=0; i<sizeof(*pEncryptedEEPROMData) / 16; ++i)
    {
        BYTE* p = (BYTE*)pEncryptedEEPROMData;
        p += i * 16;
        XDBGWRN("factory", ",0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x",
            p[0], p[1],
            p[2], p[3],
            p[4], p[5],
            p[6], p[7],
            p[8], p[9],
            p[10], p[11],
            p[12], p[13],
            p[14], p[15]
            );
    }

    bResult = rc4HmacDecrypt(
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

    ASSERT(bResult);
#endif

    //
    // Get factory settings ready
    //
    RtlCopyMemory( factorySettings->SerialNumber, pData->XboxSerialNumber, sizeof(factorySettings->SerialNumber) );
    ASSERT( sizeof(factorySettings->SerialNumber) == sizeof(pData->XboxSerialNumber) );
    RtlCopyMemory( factorySettings->EthernetAddr, pData->MACAddress, sizeof(factorySettings->EthernetAddr) );
    ASSERT( sizeof(factorySettings->EthernetAddr) == sizeof(pData->MACAddress) );
    RtlCopyMemory( factorySettings->OnlineKey, pData->OnlineKey, sizeof(factorySettings->OnlineKey) );
    ASSERT( sizeof(factorySettings->OnlineKey) == sizeof(pData->OnlineKey) );

#if DBG
    ASSERT( XBOX_KEY_LENGTH == sizeof(factorySettings->OnlineKey) );
    RtlCopyMemory( buf2, factorySettings->OnlineKey, XBOX_KEY_LENGTH );
    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    ASSERT(RtlEqualMemory( buf2, factorySettings->OnlineKey, XBOX_KEY_LENGTH ));
    RtlZeroMemory( buf2, XBOX_KEY_LENGTH );
#endif

    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    factorySettings->AVRegion = pData->AVRegion;
    factorySettings->Checksum = ~XConfigChecksum(factorySettings, sizeof(*factorySettings));

    //
    // Get user Settings ready
    //
    if ( pData->GameRegion & XC_GAME_REGION_JAPAN )
    {
        userSettings->Language = XC_LANGUAGE_JAPANESE;
        userSettings->TimeZoneBias = -540;
        strcpy(userSettings->TimeZoneStdName, "TST");
        strcpy(userSettings->TimeZoneDltName, "TST");
    }
    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));

    //
    // Copy EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    //
    // Write a copy of the EEPROM to file for debugging
    //
#ifdef WRITE_EEPROM_IMAGE_TO_FILE
    WriteFileFromMemory( "T:\\EEPROMImage.dat", buf, EEPROM_TOTAL_MEMORY_SIZE );
#endif

    //
    // Zero out the memory
    //
    RtlZeroMemory( inputBuffer, sizeof(inputBuffer) );
    RtlZeroMemory( buf, sizeof(buf) );

    //
    // Verify the written data to double check
    //
    hr = VerifyEEPROMData();
    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}


HRESULT VerifyEEPROMData()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // check checksums
    //
    if (XConfigChecksum(factorySettings, sizeof(*factorySettings)) != 0xffffffff ||
        XConfigChecksum(userSettings, sizeof(*userSettings)) != 0xffffffff)
    {
        return NTE_BAD_DATA;
    }

#ifdef DOUBLE_CHECK_EEPROM_KEY
    //
    // Double check that a random EEPROM key has really been generated
    //
    ASSERT( XBOX_KEY_LENGTH == TEMP_RAND_KEY_LEN );
    if (RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ) ||
        RtlEqualMemory( TEMP_RAND_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"The EEPROM Key has not been randomly generated");
        return NTE_NO_KEY;
    }
#endif

    //
    // Use the EEPROM-KEY to decrypt the EEPROM and verify the checksum
    //
    bResult = rc4HmacDecrypt(
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    if ( !bResult )
    {
        return NTE_BAD_DATA;
    }

    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}


BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
            SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}


HRESULT VerifyPerBoxData(void)
{
    return VerifyPerBoxDataEx(TRUE);
}

HRESULT VerifyPerBoxDataEx(BOOL fResetRegionBits)
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    //
    // Verify the EEPROM data first
    //
    hr = VerifyEEPROMData();
    if (FAILED(hr))
    {
        return hr;
    }

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

#ifdef DOUBLE_CHECK_EEPROM_KEY
    //
    // Double check that a random EEPROM key has really been generated
    //
    ASSERT( XBOX_KEY_LENGTH == TEMP_RAND_KEY_LEN );
    if (RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ) ||
        RtlEqualMemory( TEMP_RAND_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"The EEPROM Key has not been randomly generated");
        return NTE_NO_KEY;
    }
#endif

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    bResult = rc4HmacDecrypt(
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    if ( !bResult )
    {
        return NTE_BAD_DATA;
    }

    if(fResetRegionBits) {
        //
        // Clear the manufacturing region flag
        //
        pEncryptedEEPROMData->GameRegion &= ~XC_GAME_REGION_MANUFACTURING;
    }

    //
    // Double check the hard drive key
    //
    ASSERT( HARD_DRIVE_KEY_LEN == XBOX_KEY_LENGTH );
    if (!RtlEqualMemory( pEncryptedEEPROMData->HardDriveKey, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"HardDriveKey does not match");
        return NTE_BAD_KEY;
    }

    //
    // Encrypt the encrypted part back again
    //
    rc4HmacEncrypt(
        (LPBYTE)(&(pEncryptedEEPROMData->EncHeader) + XC_SERVICE_DIGEST_SIZE), // Use original confounder
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

    //
    // Save EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    //
    // Check that devkits have zero key
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        if(!RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) )
			return E_FAIL;
    }

    //
    // Compute Key to use to lock hard drive and lock it
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );

    HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );

    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}


BOOL HDDisablePassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_DISABLE_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
            SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDDisablePassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDDisablePassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}

HRESULT UnlockXboxHardDrive (
    IN LPBYTE pbHardDriveKey,
    IN DWORD dwHardDriveKeySize
    )
{
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    if ( pbHardDriveKey == NULL )
    {
        //
        // Use the key the ROM read from the EEPROM
        //
        pbHardDriveKey = (LPBYTE)(*XboxHDKey);
        dwHardDriveKeySize = XBOX_KEY_LENGTH;
    }
    else
    {
        ASSERT( XBOX_KEY_LENGTH == dwHardDriveKeySize );
        if ( dwHardDriveKeySize != XBOX_KEY_LENGTH )
        {
            return NTE_BAD_LEN;
        }
    }

    //
    // Compute Key to use and unlock hard drive
    //
    XcHMAC( pbHardDriveKey, dwHardDriveKeySize,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );

    HDDisablePassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );

    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );

    return S_OK;
}

#if 0

//
// DecryptDevKitEEPROM should never be used anymore -- a devkit functions just
// like a retail box
//

HRESULT DecryptDevKitEEPROM()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        return S_OK;
    }

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // if encrypted then decrypt the EEPROM
    //
    if ( !RtlEqualMemory( ZERO_KEY, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH ) )
    {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return NTE_BAD_DATA;
        }

        //
        // Check that Hard drive key is the zero key
        //
        ASSERT( RtlEqualMemory( ZERO_KEY, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH ) );
        ASSERT( RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) );
        RtlZeroMemory( pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH );
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );

        //
        // Save EEPROM Data into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }

    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}

#endif // 0

HRESULT QueryFatalErrorLastCode(
    OUT LPDWORD pdwFatalErrorCode
    )
{
    NTSTATUS Status;

    //
    // Read the last error code from the SMC error register
    //

    Status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_READ_ERROR_CODE, 
        pdwFatalErrorCode);

    if (!NT_SUCCESS(Status)) {
        *pdwFatalErrorCode = 0;
        return E_FAIL;
    }

    return S_OK;
}


HRESULT QueryFatalErrorHistory(
    OUT LPDWORD pdwFatalErrorHistory
    )
{
    EEPROM_LAYOUT EepromData;
    ULONG Size;
    ULONG Type;
    NTSTATUS Status;
    XBOX_UEM_INFO* UEMInfo = (XBOX_UEM_INFO*)&(EepromData.UEMInfo[0]);
    ULONG History = 0;

    //
    // Read all of the eeprom
    //

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &Type, &EepromData, sizeof(EepromData), &Size);
    
    if (!NT_SUCCESS(Status)) {
        *pdwFatalErrorHistory = 0;
        return E_FAIL;
    }

    History = (ULONG)UEMInfo->History;

    //
    // Shift the value so that bits match up with the error codes (starting at 1).  Kernel 
    // does not store the codes 0 through 5 in the history field in EEPROM
    //

    History <<= 5;
    
    *pdwFatalErrorHistory = History;
    
    return S_OK;
}



HRESULT ClearFatalErrorHistory(
    VOID
    )
{
    EEPROM_LAYOUT EepromData;
    ULONG Size;
    ULONG Type;
    NTSTATUS Status;
    XBOX_UEM_INFO* UEMInfo = (XBOX_UEM_INFO*)&(EepromData.UEMInfo[0]);
    ULONG History = 0;

    //
    // Read all of the eeprom
    //

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &Type, &EepromData, sizeof(EepromData), &Size);
    
    if (!NT_SUCCESS(Status)) {
        return E_FAIL;
    }

    //
    // Clear the history
    //

    UEMInfo->History = 0;

    //
    // Write the EEPROM back out
    //

    Status = ExSaveNonVolatileSetting(XC_MAX_ALL, Type, &EepromData, Size);
    
    if (!NT_SUCCESS(Status)) {
        return E_FAIL;
    }
    
    return S_OK;
}



HRESULT WINAPI SetFatalErrorRetryFlag(
    IN BOOL Retry
    )
{
    EEPROM_LAYOUT EepromData;
    ULONG Size;
    ULONG Type;
    NTSTATUS Status;
    XBOX_UEM_INFO* UEMInfo = (XBOX_UEM_INFO*)&(EepromData.UEMInfo[0]);
    ULONG History = 0;

    //
    // Read all of the eeprom
    //

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &Type, &EepromData, sizeof(EepromData), &Size);
    
    if (!NT_SUCCESS(Status)) {
        return E_FAIL;
    }

    //
    // Set the last error code which will determine if we need to retry or not
    //

    if (Retry) {
        UEMInfo->LastCode = FATAL_ERROR_NONE;
    } else {
        UEMInfo->LastCode = FATAL_ERROR_RESERVED;
    }

    //
    // Write the EEPROM back out
    //

    Status = ExSaveNonVolatileSetting(XC_MAX_ALL, Type, &EepromData, Size);
    
    if (!NT_SUCCESS(Status)) {
        return E_FAIL;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\command.cpp ===
// command.cpp

#include "stdafx.h"

static LPCTSTR CommandNames[6] = 
{	
	_T("invalid"),
	_T("start"),
	_T("run"),
	_T("end"),
	_T("exit"),
	NULL
};

/*
static CArray <LPCTSTR, 12> ControlNames (7, 
	_T("maxthreadcount"),
	_T("maxtimeout"),
	_T("pollingperiod"),
	_T("looplimit"),
	_T("timelimit"),
	_T("haltonerror"),
	_T("debugmask"));
*/

XCMD_TYPE CCommandItem::LookupCommand (LPCTSTR typeName)
{
	for (int ii = 0; CommandNames [ii] != NULL; ii++)
	{
		if (_tcsicmp (CommandNames [ii], typeName) == 0)
			return (XCMD_TYPE) ii;
	}
	return XCMD_INVALID;
}

CCommandItem::CCommandItem (LPCTSTR name, XCMD_TYPE type):
	CTreeItem(name), m_type(type)
{
	CParameterTable *table = new CParameterTable;
	m_parameters.set (table);
}
 
CCommandItem::~CCommandItem () 
{
}

CCommandItem *CCommandItem::AddCommand 
	(LPCTSTR module, LPCTSTR test, XCMD_TYPE type)
{
	_TCHAR name [128] = {0};
	if (module != NULL)
		_tcscpy (name, module);
	if (test != NULL)
	{
		_tcscat (name, _T("."));
		_tcscat (name, test);
	}

	CCommandItem *item = new CCommandItem (name, type);
	AddChild (item);

	return item;
}

bool CCommandList::ParseLine (LPTSTR line)
{
//	_tprintf (L"line: %s\n", line);
	_TCHAR terminal; // stores the terminal returned by GetToken
	CParseSymbol comma (_T(','));
	CParseSymbol equals (_T('='));

	// Parse the command name from the line
	//
	CParseWord command (_T(", "));
	terminal = command.GetToken (&line);
	XCMD_TYPE type = m_list.LookupCommand (command);
	if (type == XCMD_EXIT)
	{
		m_parsingList->AddCommand (NULL, NULL, type);
	}
	else
	if (type == XCMD_ENDLOOP)
	{
		CParseWord loop (_T(""));
		terminal = loop.GetToken (&line);
		if (_tcslen (loop) == 0)
			g_error.ThrowExpectingName ();

		// This statement pops the context up to the parent loop.
		//
		m_parsingList = (CCommandItem*) m_parsingList->GetParent ();
		if (m_parsingList == NULL)
			g_error.ThrowUnexpectedEndStatement ();
		
		if (_tcslen (line) > 0)
			g_error.ThrowUnknownTextFollowingCommand ();
	}
	else
	if (type != XCMD_INVALID)
	{
		CCommandItem *cmd = NULL;

		CParseWord module (_T("., "));
		terminal = module.GetToken (&line);
		if (_tcslen (module) == 0)
			g_error.ThrowExpectingName ();

		// Now we know we are parsing a START or RUN command
		// If the command takes no arguement, then it is a loop.
		//
		if ((terminal != _T('.')) && (_tcsicmp (module, _T("LOOP")) == 0))
		{
			type = (type == XCMD_RUNTEST)? XCMD_RUNLOOP:XCMD_STARTLOOP;
						
			cmd = m_parsingList->AddCommand (module, NULL, type);
			m_parsingList = (CCommandItem*) m_parsingList->GetLastChild ();
		}
		else // This must be a start or run TEST command
		{
			// In the case of a test we need to find module.name syntax
			// 
			if (terminal != _T('.'))
				g_error.ThrowExpectingDot ();

			CParseWord test (_T(", "));
			terminal = test.GetToken (&line);

			// This is a good time to verify that the name 
			// corresponds to a registered test.
			//
			if (!CTestObj::LookupTest (module, test))
				g_error.ThrowTestNotFound (test);
			
			cmd = m_parsingList->AddCommand (module, test, type);
		}

		// Now parse optional comma separated local parameters
		//
		ASSERT (cmd);
		CParameterTable *table = cmd->GetParameters ();
		while ((terminal == _T(',')) || comma.GetToken(&line))
			terminal = table->ParseParameter (&line, module);
	}
	else // flow control parameter
	if ((terminal == _T('=')) || equals.GetToken(&line))
	{
		CParameterTable *table = m_parsingList->GetParameters ();
		CParseWord value (_T("\n"));
		value.GetToken (&line);
		table->AddParameter (_T("testflow"), command, value);
	}
	else
		g_error.ThrowInvalidCommand (command);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\error.cpp ===
// error.cpp

#include "stdafx.h"

WORD CError::Report (WORD code, LPCTSTR format, ...)
{
	m_lastXmtaError = code;

	va_list argptr;
	va_start (argptr, format);

	_TCHAR message [2048];
	_vsntprintf (message, 2048, format, argptr);

	g_dispatch.ErrorMessage (NULL, code, message);

	return code;
}

CGetLastError::CGetLastError ()
{
#if defined (_XBOX)
	m_lpMsgBuf = LocalAlloc (LMEM_FIXED, 32);
	_stprintf ((unsigned short *)m_lpMsgBuf, _T("GetLastError returned 0x%x"), GetLastError());
#else
	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &m_lpMsgBuf,
		0,
		NULL 
	);
#endif
}

CGetLastError::~CGetLastError () 
{
	LocalFree (m_lpMsgBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\dispatch.h ===
// dispatcher.h

#pragma once

class CDispatcher
{
private:
	void SendMsg (CUutMsg* msg);

public:
	CDispatcher ();
	virtual ~CDispatcher ();

	void TestingStarted (void);
	void TestingActive (void);
	void TestingEnded ();
	void TestStarted (CTestObj *test);
	void TestEnded (CTestObj *test);
	void WarningMessage (CTestObj *test, LPCTSTR message);
	void DebugMessage (CTestObj *test, LPCTSTR message);
	void StatisticsMessage (CTestObj *test, LPCTSTR key, LPCTSTR message);
	void ErrorMessage (CTestObj *test, WORD errorCode, LPCTSTR message);
	void ErrorMessage (CXmtaException &x) 
		{ErrorMessage (NULL, x.GetErrorCode(), x.GetMessage ());}
	void ErrorMessage (	LPCTSTR fullName,
						LPCTSTR message,
						int moduleNumber,
						int testNumber,
						int errorCode);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\command.h ===
// command.h 

#pragma once

#include "tree.h"
#include "parser.h"

class CParameterTable;
class CTestFlowManager;

enum XCMD_TYPE {XCMD_INVALID, XCMD_STARTTEST, XCMD_RUNTEST, XCMD_ENDLOOP, XCMD_EXIT,
					XCMD_STARTLOOP, XCMD_RUNLOOP};

class CCommandItem : public CTreeItem
{
	XCMD_TYPE m_type;
	CAutoDelete <CParameterTable> m_parameters;

public:
//	static LPCTSTR *CommandNames [7]; 

public:
	CCommandItem (LPCTSTR name, XCMD_TYPE type);
	~CCommandItem ();

	XCMD_TYPE LookupCommand (LPCTSTR typeName);
	XCMD_TYPE GetCommandType () {return m_type;}
	CParameterTable *GetParameters () {return m_parameters.get ();}
	CCommandItem *AddCommand (LPCTSTR module, LPCTSTR test, XCMD_TYPE type);
};

class CCommandList : public CParseLine
{
	CCommandItem m_list;
	CCommandItem *m_parsingList;

public:
	CCommandList ():m_list(CCommandItem (_T("commands"), XCMD_INVALID))
		{m_parsingList = &m_list;}
	~CCommandList () {m_list.DeleteChildren();}

	bool ParseLine (LPTSTR line);
	CCommandItem *GetList () {return &m_list;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\error.h ===
// error.h

#pragma once

typedef unsigned short XMTA_ERROR;
#define NO_XMTA_ERROR 0

// This class allow us to create a string inside a function call arguement list
// The following code "(LPCTSTR) CGetLastError()" will create an unnamed
// object and pass it to the called function.  When the function returns
// the destructor will be called, allowing us to perform a LocalFree.
//
class CGetLastError
{
	LPVOID m_lpMsgBuf;
	
public:
	CGetLastError ();
	~CGetLastError ();
	operator LPCTSTR () {return (LPCTSTR) m_lpMsgBuf;}
};

//CGetLastError::operator LPCTSTR () 
//CGetLastError::~CGetLastError () 

// This class contains all the error codes that are used by XMTA
// All but a couple of these error codes cause an exception to 
// be thrown.  The reason not all the error codes are throw as
// exceptions is because some error conditions are discovered
// as caught exceptions.
//

class CError
{
private:
	XMTA_ERROR m_lastXmtaError;

public:
	CError ():m_lastXmtaError(0) {}
	~CError () {}

	WORD GetLastXmtaError () {return m_lastXmtaError;} 
	void GetLastWin32Error ();
	WORD Report (WORD code, LPCTSTR format, ...);

public:
	// 0x00 reserved - It means no error

	//------- Codes shared with the tests 0x001 - 0x00f ----------------

	void ReportStructuredExecption (LPCTSTR exp, DWORD code, LPVOID addr)
	{
		Report (0x001, _T("%s (0x%08lX) at 0x%08lX.\n"), exp, code, addr);
	}
	void ReportUnknownException ()
	{
		Report (0x002, _T("Unknown Exception encountered\n")); 
	}
	void ReportTestTimeout (LPCTSTR name, bool isRunning, int maxtimeout, int loadfactor, LPCTSTR footprint)
	{
		Report (0x003, _T("%s is %s, timeout (%d seconds, load factor %d), expired.\nLast CheckAbort called from: %s.\n"), name, isRunning? _T("running"):_T("hung"), maxtimeout, loadfactor, footprint);
	}
	void ThrowConversionFailed (LPCTSTR param, LPCTSTR type)
	{
		throw CXmtaException (0x004, _T("Failed to convert parameter \"%s\" to %s.\n"), param, type); 
	}
	void ThrowParameterValueOutOfRange (LPCTSTR param)
	{
		throw CXmtaException (0x005, _T("Parameter \"%s\" value is out of range.\n"), param); 
	}
	void ThrowNullTerminatorMissing (LPCTSTR name) 
	{
		throw CXmtaException (0x006, _T("Was the NULL terminator omitted in GetChoice(%s)\n"), name);
	}
	void ReportTestThreadWontDie ()
	{
		Report (0x007, _T("Test thread won't die: name unknown.\n"));
	}



	//------- Parsing errors --------------------------------------

	void ThrowInvalidCommand (void)
	{
		throw CXmtaException (0x010, _T("Invalid command"));
	}
	void ThrowUnknownTestName (void)
	{
		throw CXmtaException (0x011, _T("Unknown test name"));
	}
	void ThrowLineTooLong (int limit)
	{
		throw CXmtaException (0x012, _T("Line exceeds length limit of %d\n"), limit);
	}
	void ThrowTokenTooLong (int limit)
	{
		throw CXmtaException (0x013, _T("Token exceeds length limit of %d\n"), limit);
	}
	void ThrowExpectingTestParameter (void)
	{
		throw CXmtaException (0x014, _T("Expecting: <name> = <value>\n"));
	}
	void ThrowExpectingParameter (void)
	{
		throw CXmtaException (0x015, _T("Expecting: <module>.<name> = <value>\n"));
	}
	void ThrowDuplicateParameterFound (LPCTSTR name)
	{
		throw CXmtaException (0x016, _T("Duplicate parameter found: %s\n"), name);
	}
	void ThrowExpectingDot (void)
	{
		throw CXmtaException (0x017, _T("Expecting a dot, as in \"x.y\"\n"));
	}
	void ThrowCommandTakesNoParameters (void)
	{
		throw CXmtaException (0x018, _T("This command does not accept parameters\n"));
	}
	void ThrowUnknownTextFollowingCommand (void)
	{
		throw CXmtaException (0x019, _T("Unexpected text following command\n"));
	}
	void ThrowExpectingName (void)
	{
		throw CXmtaException (0x01a, _T("Expecting name following command\n"));
	}
	void ThrowExpectingParameterValue (LPCTSTR name)
	{
		throw CXmtaException (0x01b, _T("Parameter (%s) missing value after \"=\"\n"), name);
	}
	void ThrowExpectingParameterEnd (LPCTSTR name)
	{
		throw CXmtaException (0x01c, _T("Unexpected text following parameter (%s)\n"), name);
	}
	void ThrowExpectingParameterModule ()
	{
		throw CXmtaException (0x01d, _T("Parameter requires a module qualifier, as in <module>.<name>\n"));
	}
	void ThrowUnexpectedEndStatement ()
	{
		throw CXmtaException (0x01e, _T("Unexpected END, not matched with START/RUN LOOP\n"));
	}

	//------- Others ------------- --------------------------------------

	void ReportFileOpenFailed (LPCTSTR name, LPCTSTR last)
	{
		Report (0x020, _T("CreateFile failed (%s):\n%s"), name, last);
	}
	void ReportReadFileFailed (LPCTSTR name, LPCTSTR last)
	{
		Report (0x021, _T("ReadFile failed: %s\n"), name, last);
	}
	void ReportUnicodeConversionFailed (LPCTSTR name, LPCTSTR last)
	{
		Report (0x022, _T("MultiByteToWideChar failed: %s\n%s\n"), name, last);
	}
	void ThrowTestNotFound (LPCTSTR name) 
	{
		throw CXmtaException (0x023, _T("Test not found: %s\n"), name);
	}
	void ThrowSectionNotFound (LPCTSTR name) 
	{
		throw CXmtaException (0x024, _T("Section \"%s\" not found in INI file\n"), name);
	}
	void ThrowInvalidCommand (LPCTSTR cmd) 
	{
		throw CXmtaException (0x025, _T("Invalid command: %s\n"), cmd);
	}
	void ThrowThreadAppearsHung (LPCTSTR name) 
	{
		throw CXmtaException (0x026, _T("Test appears hung: %s.%s\n"), name);
	}
	void ThrowFailedToStartTestThread (LPCTSTR module, LPCTSTR test) 
	{
		throw CXmtaException (0x027, _T("Failed to start test thread: %s.%s\n"), module, test);
	}
	void ThrowHandleLimitExceeded () 
	{
		throw CXmtaException (0x028, _T("Attempt to run more than 64 tests ignored\n"));
	}
	void ThrowFailedToStartThread (LPCTSTR name, LPCTSTR last) 
	{
		throw CXmtaException (0x029, _T("%s Create thread failed: %s\n"), name, last);
	}
	void err_HostCommunicationError (int i1)
	{
		Report (0x02A, _T("iSendHost communication routine returned an error code of 0x%x"), i1);
	}
	void err_INIBufferIsEmpty ()
	{
		Report (0x02B, _T("The INI file buffer from the host is empty"));
	}
	void err_D3dCreateObjectFailed ()
	{
		Report (0x02C, _T("Failed to create the D3D8 object"));
	}
	void err_D3dCreateDeviceFailed ()
	{
		Report (0x02D, _T("Failed to create the D3D device"));
	}
	void err_SocketDropped ()
	{
		Report (0x02E, _T("Socket was dropped"));
	}
	void err_HostResponseError (DWORD dwErrorCodeFromHost, LPCTSTR s1)
	{
		Report ((unsigned short)dwErrorCodeFromHost, _T("The host responded with the following error message:\n%s"), s1);
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\dispatch.cpp ===
// dispatch.cpp

#include "stdafx.h"

CDispatcher::CDispatcher ()
{
}

CDispatcher::~CDispatcher ()
{
}

void CDispatcher::SendMsg (CUutMsg* msg)
{
	BYTE buffer [2048];
	CStore st (buffer, 2048);
	msg->Store (st);

	g_host.iSendHost (msg->Type, st.GetBuffer (), st.GetLength ());
}

void CDispatcher::TestingStarted (void)
{
	CMsg::TestingStarted msg;
	SendMsg (&msg);
}

void CDispatcher::TestingActive (void)
{
	CMsg::TestingActive msg;
	SendMsg (&msg);
}

void CDispatcher::TestingEnded ()
{
	CMsg::TestingEnded msg;
	SendMsg (&msg);
}

void CDispatcher::TestStarted (CTestObj *test)
{
	CMsg::TestStarted msg (test->GetFullName());
	SendMsg (&msg);
}

void CDispatcher::TestEnded (CTestObj *test)
{
	CMsg::TestEnded msg (test->GetFullName(), 
		test->GetElapsedTime(), test->GetTestPassed());
	SendMsg (&msg);
}

void CDispatcher::WarningMessage (CTestObj *test, LPCTSTR message)
{
	CMsg::Warning msg (test->GetFullName(), message);
	SendMsg (&msg);
}

void CDispatcher::DebugMessage (CTestObj *test, LPCTSTR message)
{
	CMsg::Debug msg (test->GetFullName(), message);
	SendMsg (&msg);
}

void CDispatcher::StatisticsMessage (CTestObj *test, LPCTSTR key, LPCTSTR message)
{
	CMsg::Statistic msg (test->GetFullName(), key, message);
	SendMsg (&msg);
}

void CDispatcher::ErrorMessage (LPCTSTR name,
						 LPCTSTR message,
						 int moduleNumber,
						 int testNumber,
						 int errorCode)
{
	ASSERT(moduleNumber < 0x1000);
	ASSERT(testNumber < 0x100);
	ASSERT(errorCode < 0x1000u);
	DWORD sec = (moduleNumber << 20) + (testNumber << 12) + errorCode;

//	CAutoString msg (_T("*** Error %s.%s\n%sStandard Error Code = %8.8x\n"),
//							moduleName, testName, message, sec);

	CMsg::Error msg (name, sec, message);
	SendMsg (&msg);
}

void CDispatcher::ErrorMessage (CTestObj *test, WORD errorCode, LPCTSTR message)
{
	// Try to get the test object from the thread manager
	if (test == NULL)
		test = (CTestObj *) TlsGetValue (g_tlsTestObj);

	// If the thread manager can't find it, it must be the executive
	if (test == NULL)
		ErrorMessage (_T("XMTA.TestExecutive"), 
						message, 
						MODNUM_XMTA, 
						0, 
						errorCode);
	else
		ErrorMessage (test->GetFullName (), 
						message, 
						test->GetModuleNumber (), 
						test->GetTestNumber (), 
						errorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\dynamic.h ===
// dynamic.h


// TFactoryMap
//
// This is the most minimal class possible to support
// to object factory for associating a key with a
// pointer to the appropriate create object function.
//
template <class K, class F>
class TFactoryMap
{
	TFactoryMap<K,F> *m_next;
	K m_k;
	F m_f;
public:
	TFactoryMap (K k = 0, F f = NULL):m_k(k),m_f(f),m_next(NULL) {}
	~TFactoryMap () {if (m_next) delete m_next;}
	TFactoryMap<K,F>* Lookup (K, F*);
	TFactoryMap<K,F>* Add (K, F);
};

template <class K, class F>
TFactoryMap<K,F>*
TFactoryMap<K,F> :: Add (K k, F f)
{
	TFactoryMap<K,F>* next = this;
	while (next->m_next)
		next = m_next;
	return next->m_next = new TFactoryMap<K,F> (k, f);
}

template <class K, class F>
TFactoryMap<K,F>*
TFactoryMap<K,F> :: Lookup (K k, F* f)
{
	TFactoryMap<K,F>* next = this;
	while (next->m_next)
	{
		if (next->m_k == k))
		{
			*f = m_f;
			return next;
		}
		next = m_next;
	}
	return NULL;
}

// TObjectFactory
//
// This class stores the list of all available classes and 
// supports the ability to create an object when given a key.
//
template <class T, class K, class F>
class TObjectFactory
{
	TFactoryMap <K,F> m_map;

public:
	TObjectFactory ():m_map() {} 
	~TObjectFactory () {}

	void RegisterObject (K k, F f) {m_map.Add (k, f);}
	T *CreateObject (K k) {F f; m_map.Lookup (k, &f); return (*f)();}
};

// TDynamicObj
//
// This absolute class must be the base
// of any object that is serialized.
//
template <class T, class K, class F>
class TDynamicObj
{
	static TObjectFactory<T,K,F> m_factory;

public:
	static void RegisterObject (K k, F f)
		{m_factory.RegisterObject (k, f);}

	static T* CreateObject (K k) 
		{return m_factory.CreateObject (k);}
};

// CObjectRegistrar
//
// This class exists only for the purpose of auto registration
// Instances of this class are declared statically in each test
// The constructor is run at start-up and register the object
// in with the object factory.  The object factory is a static member
// of the CDynamicObj class.
//
template <class T, class K, class F>
struct TRegistrar
{
	TRegistrar (K k, F f) {T::RegisterObject (k, f);}
};


// CLoadable
//
class CLoadable
{
	int Type;
public:
	virtual CSerial& Store (CSerial& s) {return s << Type;}
	virtual CSerial& Load (CSerial& s) {return s;} // Type already read
};


template <class T, class K>
class TDispatcher 
{
	T* MainDispatch (LPBYTE buffer, int length);
};

template <class T, class K>
T* TDispatcher <T, K> ::
MainDispatch (LPBYTE buffer, int length)
{
	CSerial next (buffer, length);	// Convert buffer in to store
	K key;							// Declare a key
	next >> key;					// Remove the key from the store
	T* obj = T::CreateObject (key); // Use the key to create an object
	if (!obj) throw key;			// throw - return ?? punt
	obj->Load (next);				// Load the object from the store
	T* resp = obj->Dispatch (this);	// Dispatch the appropriate command
	delete obj;
	return resp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\event.h ===
// uutmsg.h

class CStore; // declared in store.h

class CUutMsg
{
public:
	int Type;
	CUutMsg (int t):Type(t) {}
	virtual CStore& Store (CStore& s) {return s;} // << Type;}
	virtual CStore& Load (CStore& s) {return s;} // Type already read
};

struct CMsg
{
	struct TestingStarted: public CUutMsg
	{
		TestingStarted ():CUutMsg(MID_UUT_STARTING) {}
		TestingStarted (CStore &s):CUutMsg(MID_UUT_STARTING) {Load (s);}
	};

	struct TestingEnded: public CUutMsg
	{
		TestingEnded ():CUutMsg(MID_UUT_ENDING) {}
		TestingEnded (CStore &s):CUutMsg(MID_UUT_ENDING) {Load (s);}
	};

	struct TestingActive: public CUutMsg
	{
		TestingActive ():CUutMsg(MID_UUT_ACTIVE) {}
		TestingActive (CStore &s):CUutMsg(MID_UUT_ACTIVE) {Load (s);}
	};

	struct TestStarted: public CUutMsg
	{
		LPCTSTR Name;

		TestStarted ():CUutMsg(MID_UUT_TESTSTART) {}
		TestStarted (CStore &s):CUutMsg(MID_UUT_TESTSTART) {Load (s);}
		TestStarted (LPCTSTR n):CUutMsg(MID_UUT_TESTSTART),Name(n) {}
		CStore& Store (CStore& s) {return CUutMsg::Store(s) << Name;}
		CStore& Load  (CStore& s) {return CUutMsg::Load(s) >> &Name;}
	};

	struct TestEnded: public CUutMsg
	{
		LPCWSTR Name;
		DWORD Elapsed;
		BOOL Result;

		TestEnded ():CUutMsg(MID_UUT_TESTEND) {}
		TestEnded (CStore &s):CUutMsg(MID_UUT_TESTEND) {Load (s);}
		TestEnded (LPCWSTR n, DWORD e, BOOL r):CUutMsg(MID_UUT_TESTEND),
			Name(n), Elapsed(e), Result(r) {}
		CStore& Store (CStore& s) {return CUutMsg::Store(s) << Name << Elapsed << Result;}
		CStore& Load  (CStore& s) {return CUutMsg::Load(s) >> &Name >> Elapsed >> Result;}
	};

	struct Error: public CUutMsg
	{
		LPCWSTR Name;
		DWORD ErrorCode;
		LPCWSTR Message;

		Error ():CUutMsg(MID_UUT_ERROR) {}
		Error (CStore &s):CUutMsg(MID_UUT_ERROR) {Load (s);}
		Error (LPCWSTR n, DWORD e, LPCWSTR m):CUutMsg(MID_UUT_ERROR),
			Name(n), ErrorCode(e), Message(m) {}
		CStore& Store (CStore& s) {return CUutMsg::Store(s) << Name << ErrorCode << Message;}
		CStore& Load  (CStore& s) {return CUutMsg::Load(s) >> &Name >> ErrorCode >> &Message;}
	};

	struct Warning: public CUutMsg
	{
		LPCWSTR Name;
		LPCWSTR Message;

		Warning ():CUutMsg(MID_UUT_WARNING)  {}
		Warning (CStore &s):CUutMsg(MID_UUT_WARNING) {Load (s);}
		Warning (LPCWSTR n, LPCWSTR m):CUutMsg(MID_UUT_WARNING),
			Name(n), Message(m) {}
		CStore& Store (CStore& s) {return CUutMsg::Store(s) << Name << Message;}
		CStore& Load  (CStore& s) {return CUutMsg::Load(s) >> &Name >> &Message;}
	};

	struct Debug: public CUutMsg
	{
		LPCWSTR Name;
		LPCWSTR Message;

		Debug ():CUutMsg(MID_UUT_DEBUG) {}
		Debug (CStore &s):CUutMsg(MID_UUT_DEBUG) {Load (s);}
		Debug (LPCWSTR n, LPCWSTR m):CUutMsg(MID_UUT_DEBUG),
			Name(n), Message(m) {}
		CStore& Store (CStore& s) {return CUutMsg::Store(s) << Name << Message;}
		CStore& Load  (CStore& s) {return CUutMsg::Load(s) >> &Name >> &Message;}
	};

	struct Statistic: public CUutMsg
	{
		LPCWSTR Name;
		LPCWSTR Key;
		LPCWSTR Message;

		Statistic ():CUutMsg(MID_UUT_STAT) {}
		Statistic (CStore &s):CUutMsg(MID_UUT_STAT) {Load (s);}
		Statistic (LPCWSTR n, LPCWSTR k, LPCWSTR m):CUutMsg(MID_UUT_STAT),
			Name(n), Key(k), Message(m) {}
		CStore& Store (CStore& s) {return CUutMsg::Store(s) << Name << Key << Message;}
		CStore& Load  (CStore& s) {return CUutMsg::Load(s) >> &Name >> &Key >> &Message;}
	};

	static CUutMsg *CreateMsg (DWORD mid, CStore &store)
	{
		switch (mid)
		{
		case MID_UUT_STARTING:	return new TestingStarted (store);
		case MID_UUT_ACTIVE:	return new TestingActive (store);
		case MID_UUT_ENDING:		return new TestingEnded (store);
		case MID_UUT_TESTSTART:		return new TestStarted (store);
		case MID_UUT_TESTEND:		return new TestEnded (store);
		case MID_UUT_ERROR:			return new Error (store);
		case MID_UUT_WARNING:			return new Warning (store);
		case MID_UUT_DEBUG:				return new Debug (store);
		case MID_UUT_STAT:				return new Statistic (store);
		}

		return NULL;
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\except.cpp ===
// except.cpp

#include "stdafx.h"

CXmtaException::CXmtaException ()
{
	m_error = 0;
	m_message = NULL;
}

CXmtaException::CXmtaException (WORD error, LPCTSTR format, ...)
{
	m_error = error;

	va_list argptr;
	va_start (argptr, format);

	if (format) {
		_vsntprintf (m_buffer, 1024, format, argptr);
		m_message = m_buffer;
	}
	else {
		m_message = NULL;
	}
}

CXmtaException::CXmtaException (const CXmtaException &x)
{
	m_error = x.m_error;
	m_message = x.m_message;
	_tcscpy (m_buffer, x.m_buffer);
}



// Custom translation function, set by calling "_set_se_translator"
//
void CustomExceptionTranslator (WIN32_EXCEPTION n, _EXCEPTION_POINTERS* p)
{
	throw CStructuredException (n, p);
}

INSTRUCTION_ADDRESS CStructuredException::GetExceptionAddress ()
{
	return m_pEP->ExceptionRecord->ExceptionAddress;
}

LPCTSTR CStructuredException::GetExceptionString ()
{
#define EXCEPTION( x ) case EXCEPTION_##x: return _T(#x);
	
	switch (m_exceptionCode)
	{
		EXCEPTION( DATATYPE_MISALIGNMENT )
		EXCEPTION( BREAKPOINT )
		EXCEPTION( SINGLE_STEP )
		EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
		EXCEPTION( FLT_DENORMAL_OPERAND )
		EXCEPTION( FLT_DIVIDE_BY_ZERO )
		EXCEPTION( FLT_INEXACT_RESULT )
		EXCEPTION( FLT_INVALID_OPERATION )
		EXCEPTION( FLT_OVERFLOW )
		EXCEPTION( FLT_STACK_CHECK )
		EXCEPTION( FLT_UNDERFLOW )
		EXCEPTION( INT_DIVIDE_BY_ZERO )
		EXCEPTION( INT_OVERFLOW )
		EXCEPTION( PRIV_INSTRUCTION )
		EXCEPTION( IN_PAGE_ERROR )
		EXCEPTION( ILLEGAL_INSTRUCTION )
		EXCEPTION( NONCONTINUABLE_EXCEPTION )
		EXCEPTION( STACK_OVERFLOW )
		EXCEPTION( INVALID_DISPOSITION )
		EXCEPTION( GUARD_PAGE )
		EXCEPTION( INVALID_HANDLE )
	}

	static _TCHAR szBuffer[512] = _T("Unknown Structured Exception");
	
	// ACCESS_VIOLATION is the only exception with additional information
	//
	if (m_exceptionCode == EXCEPTION_ACCESS_VIOLATION)
	{
		_stprintf (szBuffer,
			_T("ACCESS_VIOLATION %sing virtual address 0x%08lX"),
			m_pEP->ExceptionRecord->ExceptionInformation[0]? _T("read"):_T("writ"),
			m_pEP->ExceptionRecord->ExceptionInformation[1]);
	}
		
	return szBuffer;
}

/*  Test carefully before useing ...
void CStructuredException::GetCallStack (PCONTEXT pContext, LPTSTR buffer)
{
	_tcscat (buffer, _T("\nCall stack:"));
	
	DWORD pc = pContext->Eip;
	PDWORD pFrame, pPrevFrame;
	pFrame = (PDWORD) pContext->Ebp;
	
	buffer = _tcschr (buffer, 0);
	int done = FALSE;
	do
	{
		_stprintf (buffer, _T(" %08X"), pc);
		buffer = _tcschr (buffer, 0);
		
		pc = pFrame[1];
		
		pPrevFrame = pFrame;
		
		pFrame = (PDWORD)pFrame[0]; // precede to next higher frame on stack
		
		if ((DWORD)pFrame & 3)    // Frame pointer must be aligned on a
			break;                  // DWORD boundary.  Bail if not so.
		
		if (pFrame <= pPrevFrame)
			break;
		
		// Can two DWORDs be read from the supposed frame address?          
		if (IsBadWritePtr(pFrame, sizeof(PVOID)*2))
			break;
		
	} while (!done);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\factory.h ===
// factory.h

#pragma once

class CTestObj;

typedef CTestObj* (*CreateFunction) ();

class CTestItem : public CTreeItem
{
	CreateFunction m_func;

public:
	CTestItem (LPCTSTR name, CreateFunction func = NULL)
		:CTreeItem(name), m_func(func) {}
	~CTestItem () {}

	CreateFunction GetFunction () {return m_func;}
};

// CTestFactory
//
// This object contains the list of all available tests.
//
class CTestFactory
{
	CTestItem m_list;

public:
	CTestFactory ():m_list(_T("factory")) {} 
	~CTestFactory () {m_list.DeleteChildren ();}

	void RegisterTest (LPCTSTR name, CreateFunction func); 
	CTestObj *CreateTest (LPCTSTR name);
	CTestItem *LookupTest (LPCTSTR module, LPCTSTR test = NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\host.cpp ===
// host.cpp

#include "stdafx.h"

void CHost::SetUhcHwnd (LPCTSTR str)
{
	LPTSTR end;
	m_uhcHwnd = (HWND) _tcstoul (str, &end, 0);
	if (str == end)
		m_uhcHwnd = NULL;
}

void CHost::CloseIniFile ()
{
	if (m_start)
	{
		delete [] m_start;
		m_start = 0;
	}
}

#ifdef STAND_ALONE_MODE  // Only include this in stand-alone mode

static LPCTSTR XmsgTypes [] = {	
							_T("invalid command"),
							_T("starting"),
							_T("ending"),
							_T("active"),
							_T("started"),
							_T("ended"),
							_T("stat"),
							_T("warning"),
							_T("debug"),
							_T("error"),
							NULL
						};

int CHost::iSendHost (
						DWORD dwMID,
						char *pcBufferToHost,
						DWORD dwBufferToHostLength,
						CHostResponse& CHR,
						DWORD *pdwBytesReceivedFromHost,
						DWORD *pdwErrorCodeFromHost,
						DWORD dwTimeout)
/*
int CHost::iSendHost (
						char *pcBufferToHost, 
						int iBufferToHostLength, 
						char *pcBufferFromHost, 
						int iBufferFromHostLength, 
						int *piActualBytesReceived, 
						int *piBufferFromHostOverflow, 
						int iTimeout)
*/
{
	UNREFERENCED_PARAMETER (CHR);
	UNREFERENCED_PARAMETER (pdwBytesReceivedFromHost);
	UNREFERENCED_PARAMETER (pdwErrorCodeFromHost);
	UNREFERENCED_PARAMETER (dwTimeout);

	CAutoLeave lock (&m_section);

/*
// This was used for UHC debugging but is no longer needed
	if (GetUhcHwnd ())
	{
		int length = iBufferToHostLength;
		void *heap = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, length);
		memcpy (heap, pcBufferToHost, length);

		COPYDATASTRUCT cds;
		cds.dwData = *(DWORD *) &pcBufferToHost; // peel off the type value
		cds.cbData = length;
		cds.lpData = heap;

		::SendMessage (GetUhcHwnd(), WM_COPYDATA, (WPARAM) hWnd, (LPARAM) &cds);
			
		HeapFree (GetProcessHeap (), 0, heap);
		return 0;
	}
*/
	CStore blob ((LPBYTE) pcBufferToHost, dwBufferToHostLength);

//	int type;
//	blob >> type;

	ASSERT (pF != NULL);
	if (dwMID < 12)
		_ftprintf (pF, _T("<%s>"), XmsgTypes [dwMID]);
	else
		_ftprintf (pF, _T("<MID=0x%x>"), dwMID);

// Warning: Do not access time(NULL) in any message that could be sent from a test
// thread.  XSS hangs when time(NULL) is called from a test thread for some reason.

	switch (dwMID)
	{
		case MID_UUT_STARTING:
			{
				CMsg::TestingStarted msg;
				msg.Load (blob);
				_ftprintf (pF, _T("\n"));
			}
			break;
		case MID_UUT_ACTIVE:
			{
				CMsg::TestingActive msg;
				msg.Load (blob);
				_ftprintf (pF, _T("\n"));
			}
			break;
		case MID_UUT_ENDING:
			{
				CMsg::TestingEnded msg;
				msg.Load (blob);
				_ftprintf (pF, _T("\n"));
			}
			break;
		case MID_UUT_TESTSTART:
			{
				CMsg::TestStarted msg;
				msg.Load (blob);
				_ftprintf (pF, _T("<%s>\n"), msg.Name);
			}
			break;
		case MID_UUT_TESTEND:
			{
				CMsg::TestEnded msg;
				msg.Load (blob);
				_ftprintf (pF, _T("<%s><%d><%s>\n"), msg.Name, msg.Elapsed, 
					msg.Result? _T("passed"):_T("failed"));
			}
			break;
		case MID_UUT_WARNING:
			{
				CMsg::Warning msg;
				msg.Load (blob);
				_ftprintf (pF, _T("<%s><%s>\n"), msg.Name, msg.Message);
			}
			break;
		case MID_UUT_DEBUG:
			{
				CMsg::Debug msg;
				msg.Load (blob);
				_ftprintf (pF, _T("<%s><%s>\n"), msg.Name, msg.Message);
			}
			break;
		case MID_UUT_STAT:
			{
				CMsg::Statistic msg;
				msg.Load (blob);
				_ftprintf (pF, _T("<%s><%s><%s>\n"), msg.Name, msg.Key, msg.Message);
			}
			break;
		case MID_UUT_ERROR:
			{
				CMsg::Error msg;
				msg.Load (blob);
				_ftprintf (pF, _T("<%s><0x%08X><%s>\n"), msg.Name, msg.ErrorCode, msg.Message);
			}
			break;
	}

	return 0;
}

LPTSTR CHost::OpenIniFile (LPCTSTR filename)
{
	char szFName[256];

	// Try to open the file
	//

	sprintf(szFName, "%S", filename);	
	CAutoClose hFile = CreateFileA (szFName,
		GENERIC_READ, //|GENERIC_WRITE,
		0, NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (!hFile.IsValid())
	{
		g_error.ReportFileOpenFailed (filename, (LPCTSTR) CGetLastError());
		return NULL;
	}

	// We are reading an ASCII file and converting it to UNICODE.
	// The following algorithm is designed to use a single buffer
	// for reading and conversion.  To do this we create a buffer large
	// enough to hold the converted file, then write the original
	// data to the upper half of the file.
	//
	DWORD fileSize = GetFileSize (hFile, NULL);
	m_start = new _TCHAR [fileSize + 2];
	char *middle = (char *) &m_start [(fileSize + 2)/2];

	DWORD bytesRead;
	if (!ReadFile (hFile, middle, fileSize, &bytesRead, NULL))
	{
		g_error.ReportReadFileFailed (filename, (LPCTSTR) CGetLastError());
		return NULL;
	}
    
	int len = MultiByteToWideChar (CP_ACP, 0, middle, bytesRead, m_start, fileSize + 1);
	if (len == 0)
	{
		g_error.ReportUnicodeConversionFailed (filename, (LPCTSTR) CGetLastError());
		return NULL;
	}

	m_start [fileSize] = _T('\0');
	LPTSTR current = m_start;

	// Skip over initial unicode designator character
	//
	if (0xfffe == (int) *current)
		return NULL; // This code represents little endian format
	if (0xfeff == (int) *current)
		current++;

	return current;
}

DWORD CHost::GetHostDword (DWORD /* mid */, DWORD alternate)
{
	return alternate;
}

#endif // ifdef STAND_ALONE_MODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\host.h ===
// Header file for XMTA Host communication routines via TCP/IP

#if !defined(SENDHOSTH_INCLUDED)
#define SENDHOSTH_INCLUDED

#define HOST_COMMUNICATION_INITIALIZATION_TIMEOUT 200000.0 // In seconds. Set this really large (like 1000000.0) to effectively make this infinite

// This is the name of the machine that is acting as the host.  This will probably change to
// an IP address in a real test environment.
#define TEST_HOST_ADDRESS "142.142.1.1"
//
// ERROR MESSAGE DEFINITIONS
//
#define EVERYTHINGS_OK                           0x00
#define COULD_NOT_ALLOCATE_SEND_BUFFER           0x10 // Communication send errors
#define COULD_NOT_SEND_DATA_TO_PORT              0x11
#define BUFFER_TO_SEND_IS_BAD                    0x12
#define SEND_TIMEOUT                             0x13
#define COULD_NOT_ALLOCATE_RESPONSE_LIST_ENTRY   0x14
#define COULD_NOT_RECEIVE_DATA_FROM_PORT         0x20 // Communication reception errors
#define CONNECTION_CLOSED                        0x21
#define RECEIVE_BUFFER_OVERRUN                   0x22
#define COULD_NOT_ALLOCATE_RECEIVE_BUFFER        0x23
#define RECEIVE_TIMEOUT                          0x24
#define COULD_NOT_CREATE_RESPONSE_EVENT          0x25
#define SOCKET_VERSION_NOT_SUPPORTED             0x30 // Communication initialization errors
#define COULD_NOT_GET_SOCKET_HANDLE              0x31
#define COULD_NOT_GET_HOST_IP_ADDRESS            0x32
#define COULD_NOT_CONNECT_TO_SOCKET              0x33
#define COULD_NOT_RECEIVE_CONNECT_HANDSHAKE      0x34
#define COULD_NOT_SEND_CONNECT_HANDSHAKE         0x35
#define COULD_NOT_START_RECEIVE_THREAD           0x36
#define COULD_NOT_LOAD_SOCKET_LIBRARY            0x37
#define COULD_NOT_CREATE_SOCKET_EVENT            0x38
#define COULD_NOT_RESET_SOCKET_EVENT             0x39
#define HOST_ERROR_RETURNED                      0x3A
#define ABORT_RECEIVED                           0x3B
#define COULD_NOT_CREATE_ACK_EVENT               0x3C
#define ACK_TIMEOUT                              0x3D

#ifndef STAND_ALONE_MODE
#ifndef _XBOX

#pragma comment (lib, "ws2_32.lib") // Make sure the Winsock2 library is included
#include <winsock2.h>
#else
#include <winsockx.h>
// loading libraries this way doesn't seem to work in the XBOX game project environment right now
//#pragma comment (lib, "xnetd.lib") // Make sure the Winsock2 library is included
#endif
#endif

#include <stdlib.h>
#include <process.h>

#ifdef _XBOX
extern "C"
{
DWORD
NTAPI
XQueryValue(
    IN ULONG ulValueIndex,
    OUT PULONG pulType,
    OUT PVOID pValue,
    IN ULONG cbValueLength,
    IN OUT PULONG pcbResultLength
    );
}
#endif

typedef struct _HOST_RESPONSE_ENTRY {
	struct _HOST_RESPONSE_ENTRY *pNextEntry;  // in:  Next entry in the linked list of pending responses
	char *pcBufferFromHost;        // out: Pointer to the buffer that contains response data from the host
	DWORD dwID;                    // in:  Unique identifier for the list entry
	DWORD dwActualBytesReceived;   // out: The actual number of bytes being returned in the buffer
	DWORD dwReturnedErrorCode;     // out: The error code returned by the host
	int iStatus;                   // out: Status returned from the routine that receives the host response data
	HANDLE hEvent;                 // in:  Event to signal when the response is completely copied
} HOST_RESPONSE_ENTRY, *PHOST_RESPONSE_ENTRY;

class CHostResponse
{
	public:
	CHostResponse ()
	{
		pvBufferFromHost = NULL;
	};
	virtual ~CHostResponse ()
	{
		if (pvBufferFromHost != NULL)
		{
			delete [] pvBufferFromHost;
			pvBufferFromHost = NULL;
		}
	};

	// Function definitions

	// Variable definitions
	void *pvBufferFromHost;
};


// CConfigParam : A class to contain all local values newed during configuration parameter routines
class CHost
{
	public:
	CHost ()
	{
		m_uhcHwnd = NULL;
		pF = stdout;
		hWnd = NULL;
		pHostResponsesPendingList = NULL;
		gdwLocalID = 1;
		g_dwLocalIDToAck = 0;
		InitializeCriticalSection (&m_section);
		bSocketRestarting = false;
		m_strHostName = NULL;
		m_strSerialNumber = NULL;
#ifdef _XBOX
		Init ();
#endif
	}


	virtual ~CHost ()
	{
#ifndef STAND_ALONE_MODE
		DisconnectFromHost ();
#endif
		DeleteCriticalSection (&m_section);
		CloseIniFile();
		if ((pF != NULL) && (pF != stdout)) fclose(pF);
	};

#ifndef STAND_ALONE_MODE
	// Function definitions
	void Init (char *strHostName = NULL, LPCTSTR strSerialNumber = NULL);
	int iSendToHost(SOCKET sock, char *pcAppDataToSend, int iAppDataToSendLength);
	int iReceive(SOCKET sock, char *pcReceiveBuffer, DWORD dwSizeOfReceiveBuffer, DWORD *pdwActualSize, double local_timeout_value, LARGE_INTEGER *pliLocalTimeout);
	int iInitHostCommunication(char *strHostName, LPCTSTR strSerialNumber, double dblTimeout, SOCKET *psock);
	void DisconnectFromHost();
#endif

	int iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength, CHostResponse& CHR, DWORD *pdwBytesReceivedFromHost, DWORD *pdwErrorCodeFromHost, DWORD dwTimeout);
	int iSendHost (DWORD dwMID, void *pcBufferToHost, DWORD dwBufferToHostLength)
	{
		CHostResponse CHRTemp;
		return iSendHost (dwMID, (char *)pcBufferToHost, dwBufferToHostLength, CHRTemp, NULL, NULL, 600); // Wait for up to 10 minutes on any send
	}
	void vDeleteHostResponseListEntry(DWORD dwID);
	static void vReceiveFromHostThreadEntry(void *pthis);
	void vReceiveFromHostThread(void);
	static void vAlivePrintThreadEntry(void *pthis);
	void vAlivePrintThread(void);
	void MicroSecondDelay(DWORD dwDelayTime);
	void StartTimer(LARGE_INTEGER *StartCount);
	int TimedOut(double dblDelayTime, LARGE_INTEGER *StartCount);
	void SeedRand(int iSeed);
	DWORD GetHostDword (DWORD mid, DWORD alternate);

	// Variable definitions
#ifndef STAND_ALONE_MODE
	SOCKET sock;  // This needs to be global because more than one thread uses it
#endif
	PHOST_RESPONSE_ENTRY pHostResponsesPendingList; // This is the starting point of a linked list of pending responses from the host computer
	CRITICAL_SECTION HostResponseEntryListCriticalSection, SendToHostCriticalSection, SocketAccessCriticalSection;
	DWORD gdwLocalID;
	HANDLE hAckReceivedEvent;
	DWORD g_dwLocalIDToAck;
	unsigned long ulHost;
	bool bSocketRestarting;
	char *m_strHostName;
	LPTSTR m_strSerialNumber;

	CRITICAL_SECTION m_section;

	LPTSTR OpenIniFile (LPCTSTR filename);
	void CloseIniFile ();
	LPTSTR m_start;
	FILE *pF;
	HINSTANCE hWnd;

	HWND m_uhcHwnd;
	void SetUhcHwnd (LPCTSTR str);
	HWND GetUhcHwnd () {return m_uhcHwnd;}
};

#ifdef _XBOX
//
// gethostbyname and gethostbyaddr are not publicly exposed.
// They're declared as private here for us by internal system libraries.
// Notice that their names are obscured.
//

#ifndef _WINSOCKP_H
#define _WINSOCKP_H

#define gethostbyname _wspapi001
#define gethostbyaddr _wspapi002

#ifdef __cplusplus
extern "C" {
#endif

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
struct hostent FAR *
WSAAPI
gethostbyaddr(
    IN const char FAR * addr,
    IN int len,
    IN int type
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct hostent FAR *
(WSAAPI * LPFN_GETHOSTBYADDR)(
    IN const char FAR * addr,
    IN int len,
    IN int type
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
struct hostent FAR *
WSAAPI
gethostbyname(
    IN const char FAR * name
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
struct hostent FAR *
(WSAAPI * LPFN_GETHOSTBYNAME)(
    IN const char FAR * name
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#ifdef __cplusplus
}
#endif
#endif // !_WINSOCKP_H

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\factory.cpp ===
// factory.cpp
//

#include "stdafx.h"

#define SPLIT(original, first, second) \
		int _len_ = _tcslen (original) + 1; \
		LPTSTR _buffer_ = (LPTSTR) alloca (_len_*2); \
		_tcscpy (_buffer_, original); \
		first = _buffer_; \
		_buffer_ = _tcschr (_buffer_, _T('.')); \
		if (_buffer_) *_buffer_++ = 0; \
		second = _buffer_

void CTestFactory::RegisterTest (LPCTSTR name, CreateFunction func)
{
	LPCTSTR module,  test;
	SPLIT (name, module, test);

	// If this is the first parameter from a module,
	// we will need to create the module node first
	//
	CTestItem *moduleItem = (CTestItem *) m_list.FindChild (module);
	if (!moduleItem)
	{
		moduleItem = new CTestItem (module);
		m_list.AddChild (moduleItem);
	}

	// Check for duplicates
	ASSERT (!moduleItem->FindChild (test));

	CTestItem *paramItem = new CTestItem (test, func);
	moduleItem->AddChild (paramItem);
}

CTestObj *CTestFactory::CreateTest (LPCTSTR name)
{
	CTestItem *testItem = LookupTest (name);
	return (*testItem->GetFunction())();
}

CTestItem *CTestFactory::LookupTest (LPCTSTR module, LPCTSTR test)
{
	if (test == NULL)
	{
		SPLIT (module, module, test);
	}

	CTestItem *moduleItem = (CTestItem *) m_list.FindChild (module);
	if (!moduleItem)
		return NULL;

	return (CTestItem *) moduleItem->FindChild (test);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\except.h ===
// except.h

#pragma once

typedef unsigned int WIN32_EXCEPTION;
typedef void * INSTRUCTION_ADDRESS;

class CStructuredException
{
private:
	CStructuredException () {}
	WIN32_EXCEPTION m_exceptionCode;
	_EXCEPTION_POINTERS* m_pEP;

public:
	CStructuredException (WIN32_EXCEPTION ecode):m_exceptionCode(ecode) {}
	CStructuredException (WIN32_EXCEPTION ecode, _EXCEPTION_POINTERS* pEP)
		:m_exceptionCode(ecode), m_pEP(pEP) {}
	~CStructuredException () {}

	WIN32_EXCEPTION GetExceptionCode () {return m_exceptionCode;}
	LPCTSTR GetExceptionString ();
	INSTRUCTION_ADDRESS GetExceptionAddress ();
	LPCTSTR GetExceptionStack ();
};

void CustomExceptionTranslator (WIN32_EXCEPTION, _EXCEPTION_POINTERS*);

class CXmtaException
{
private:
	WORD m_error;
	LPCTSTR m_message;
	_TCHAR m_buffer [1024];
public:
	CXmtaException (WORD error, LPCTSTR fomat, ...);
	CXmtaException (const CXmtaException &x);
	CXmtaException ();
	~CXmtaException () {}

	WORD GetErrorCode () {return m_error;}
	LPCTSTR GetMessage () {return m_message;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\loops.cpp ===
// loops.cpp 

#include "stdafx.h"

void CHandleArray::CloseAll (void)
{
	for (int ii = 0; ii < GetCount(); ii++)
	{
		CloseHandle ((*this)[ii]);
	}
}

DWORD CHandleArray::Wait (bool all, DWORD millisec)
{
	return WaitForMultipleObjects (GetCount(), GetArray(), all, millisec);
}

// StartThread - used to start a test
//
// By using _beginthreadex and _endthreadex, the thread handle
// is not automatically closed on exit.  This is important
// because we are using the handle to monitor thread activity
// so we don't want the handle value to be reused by the OS
// until we have purged it from our tables.
//
HANDLE CThreadable::StartThread (LPCTSTR name)
{
	ASSERT (m_hThread == NULL);
	
	UINT ignore; // threadID
	DWORD result;
	result = _beginthreadex (NULL, 0, &ThreadEntry, this, 0, &ignore);

	if (result == 0)
	{
		LPCTSTR pTemp = CGetLastError();
		g_error.ThrowFailedToStartThread (name, pTemp);
	}

	return m_hThread = (HANDLE) result;
}

// ThreadEntry 
//
// This is the first code that is executed in the thread context
//
unsigned __stdcall CThreadable::ThreadEntry (LPVOID pParam)
{
	CThreadable *obj = (CThreadable *) pParam;


	bool result = obj->ThreadMain ();

	// And return the result 
	//
	_endthreadex (result); 
	return result;
}

bool CLoopable::ThreadMain ()
{
	bool failed = true; // assume the worst

	// Setup a custom exception handler so that win32 structured
	// exceptions can be converted into C++ exceptions
	//
	_set_se_translator (CustomExceptionTranslator);

	try
	{
		CTimer timer (this, m_timelimit * 1000);

		if (LoopStart () && !m_abortFlag)
		{
			int count = 0; 
			while (((count < m_looplimit)||(m_looplimit == 0)) && !m_abortFlag)
			{
				LoopMain ();
				count++;
			}

			failed = false;
		}
	}
	catch (CXmtaException &x) 
	{
		if (x.GetErrorCode())
			g_dispatch.ErrorMessage (x);
	}
//#ifndef _DEBUG
	catch (CStructuredException &e)
	{
		g_main.StopThreads ();
		g_error.ReportStructuredExecption (
			e.GetExceptionString (),
			e.GetExceptionCode (),
			e.GetExceptionAddress ());
	}
	catch (...)
	{
		g_main.StopThreads ();
		g_error.ReportStructuredExecption (_T("Unidentified exception"), 0, 0);
	}
//#endif

	LoopExit ();
	return failed;
}

void CLoopable::InitLoopControl (CParameterTable *local, CLoopable *parent)
{
	if (parent && parent->m_objHaltOnError)
		m_objHaltOnError = parent->m_objHaltOnError;

	if (local == NULL)
		return;

	m_localParameters = local;

	// Not inherited 
	//
	m_looplimit = local->GetCfgInt (NULL, _T("looplimit"), 1);
	m_debugmask = local->GetCfgUint (NULL, _T("debugmask"), 0);
	m_timelimit = local->GetCfgInt (NULL, _T("timelimit"), 0);

	// Query the host for elapsed time if required.
	//
	int elapsedlimit = local->GetCfgInt (NULL, _T("elapsedlimit"), 0);
	if (elapsedlimit)
	{
		int elapsed = (int) g_host.GetHostDword (MID_UUT_GET_ELAPSED_TIME, 0);
		if (elapsed >= elapsedlimit)
			OnSignalAbort();
		else
			m_timelimit = (elapsedlimit - elapsed);
	}

	// Set the halt on error object ...
	// when an error occurs and this value is not NULL,
	// the objects OnSignalAbort() is called which will cascade the 
	// abort signalls to all its children
	//
	m_haltonerror = local->GetCfgBoolean (NULL, _T("haltonerror"), false);
	if (!m_objHaltOnError)
	{
		if (m_haltonerror)
			m_objHaltOnError = this;
		else
			m_objHaltOnError = NULL;
	}

	// Inherited
	//
	if (parent)
	{
		m_maxthreads = parent->m_maxthreads;
		m_maxtimeout = parent->m_maxtimeout;
		m_reportwarnings = parent->m_reportwarnings;
		m_reportstatistics = parent->m_reportstatistics;
	}
	m_maxthreads = local->GetCfgInt (NULL, _T("maxthreads"), m_maxthreads);
	m_maxtimeout = local->GetCfgInt (NULL, _T("maxtimeout"), m_maxtimeout);

	m_reportwarnings = local->GetCfgBoolean (NULL, _T("reportwarnings"), m_reportwarnings ? true : false);
	m_reportstatistics = local->GetCfgBoolean (NULL, _T("reportstatistics"), m_reportstatistics ? true : false);
}


CLoopManager::CLoopManager ():
	m_loop(NULL), m_parent(NULL)
{
	m_pollingPeriod = 100;
}

CLoopManager::CLoopManager (CCommandItem *loop, CLoopable *parent):
	m_loop(loop), m_parent(parent)
{
	m_pollingPeriod = 100;
}

CLoopManager::~CLoopManager ()
{
}

void CLoopManager::StartTesting (CCommandItem *loop)
{
	m_loop = loop;

	CParameterTable *pPT = m_loop->GetParameters ();
	InitLoopControl (pPT, m_parent);

	m_senduutstarting = pPT->GetCfgBoolean (NULL, _T("senduutstarting"), m_senduutstarting ? true : false);

	if (m_senduutstarting)
		g_dispatch.TestingStarted ();
	LoopMain ();
	g_dispatch.TestingEnded ();
}

void CLoopManager::AddThread (CLoopable *test, HANDLE thread)
{
	ASSERT (!m_objectArray.IsFull ());

	m_objectArray.Append (test);
	m_threadArray.Append (thread);
}

void CLoopManager::RemoveThread (int arrayIndex)
{
	ASSERT (!m_threadArray.IsEmpty ());

	HANDLE thread = m_threadArray.RemoveAt (arrayIndex);
	CLoopable *obj = m_objectArray.RemoveAt (arrayIndex);

	CloseHandle (thread);
	delete obj;
}

void CLoopManager::StopThreads ()
{
	InterlockedIncrement (&m_abortFlag);

	for (int ii = 0; ii < m_objectArray.GetCount (); ii++)
	{
		CLoopable *obj = m_objectArray[ii];
		obj->OnSignalAbort ();
	}
}

void CLoopManager::StartTest (LPCTSTR name, CParameterTable *local)
{
	if (m_objectArray.IsFull ())
		return;

	CTestObj *test = NULL;
	HANDLE thread = NULL;

	try
	{
		test = CTestObj::CreateTest (name);
		test->InitLoopControl (local, this);
		thread = test->StartThread (test->GetFullName ());
	}
	catch (...) // catches any constructor exceptions 
	{
		delete test;
		g_main.StopThreads ();
	}

	AddThread (test, thread);
}

void CLoopManager::StartLoop (CCommandItem *cmd)
{
	if (m_objectArray.IsFull ())
		return;

	CLoopManager *loop = new CLoopManager (cmd, this);
	loop->InitLoopControl (cmd->GetParameters (), this);
	HANDLE thread = loop->StartThread (cmd->GetName ());

	AddThread (loop, thread);
}

void CLoopManager::RunTest (LPCTSTR name, CParameterTable *local)
{
	StartTest (name, local);
	WaitLoop ();
}

void CLoopManager::RunLoop (CCommandItem *cmd)
{
	StartLoop (cmd);
	WaitLoop ();
}

bool CLoopManager::LoopMain ()
{
	TlsSetValue (g_tlsTestObj, NULL);

	CCommandItem *cmd = (CCommandItem *) m_loop->GetFirstChild ();

	while (cmd && !m_abortFlag)
	{
		switch (cmd->GetCommandType())
		{
		case XCMD_STARTTEST:
			StartTest (cmd->GetName(), cmd->GetParameters());
			break;
		case XCMD_RUNTEST:
			RunTest (cmd->GetName(), cmd->GetParameters());
			break;
		case XCMD_STARTLOOP:
			StartLoop (cmd);
			break;
		case XCMD_RUNLOOP:
			RunLoop (cmd);
			break;
		case XCMD_EXIT:
			g_host.iSendHost (MID_UUT_RESTARTING, NULL, 0);
#ifndef STAND_ALONE_MODE
			g_host.DisconnectFromHost ();
#endif
#ifdef _XBOX
			// do xbox exit here
#endif
			_exit(0);
			break;
		default:
			ASSERT_HERE;
			g_error.ThrowInvalidCommand (_T("Unknown"));
		}

		cmd = (CCommandItem *) cmd->GetNextSibling ();
	}

	WaitLoop ();
	return true;
}

void CLoopManager::WaitLoop ()
{
	while (!m_threadArray.IsEmpty ())
	{
		DWORD result = m_threadArray.WaitForAny (m_pollingPeriod);
		ASSERT (result != WAIT_FAILED);
		if (result == WAIT_TIMEOUT)
			CheckThreads ();
		else
			RemoveThread (result - WAIT_OBJECT_0);
	}
}

void CLoopManager::CheckThreads ()
{
	ASSERT (!m_objectArray.IsEmpty());

	for (int ii = 0; ii < m_objectArray.GetCount (); ii++)
	{
		CLoopable *obj = m_objectArray[ii];
		if (obj->CheckTimeout (m_maxtimeout, m_objectArray.GetCount()))
		{
			// Test has timed out.
			// It could either be waiting on an object
			// or burning cycles in an infinite loop
			// but for now we will just punt
			//
			// g_error.ThrowThreadAppearsHung (obj->GetName ());
			SuspendThread (m_threadArray[ii]);
			RemoveThread (ii);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\loops.h ===
// loops.h 
	 
class CHandleArray : public CArray <HANDLE, MAX_WAIT_HANDLES>
{
	DWORD Wait (bool all, DWORD millisec);
	
public:
	CHandleArray () {}
	~CHandleArray () {}

	void CloseAll (void);
	DWORD WaitForAny (DWORD millisec) {return Wait (false, millisec);}
	DWORD WaitForAll (DWORD millisec) {return Wait (true, millisec);}
};

class CThreadable
{
	HANDLE m_hThread;
	static unsigned __stdcall ThreadEntry (LPVOID pParam);

protected:
	virtual bool ThreadMain () = 0;

public:
	CThreadable ():m_hThread(NULL) {}
	HANDLE StartThread (LPCTSTR name);
};

//class CParameterItem;

class CLoopable : public CTimeable, public CThreadable
{
protected:
	CParameterTable *m_localParameters;
	CLoopable *m_objHaltOnError;

	int m_looplimit;
	int m_timelimit;
	int m_haltonerror;

	int m_debugmask;
	int m_maxthreads;
	int m_maxtimeout;
	int m_reportwarnings;
	int m_reportstatistics;
	int m_senduutstarting;

	long m_abortFlag;

public:
	CLoopable ():m_looplimit(1), m_timelimit(0), m_haltonerror(0),
		m_debugmask(0), m_maxthreads(64), m_maxtimeout(MAX_TIMEOUT),
		m_reportwarnings(1), m_reportstatistics(1), m_objHaltOnError(NULL),
		m_senduutstarting(1), m_localParameters(NULL), m_abortFlag (false) {}
	virtual ~CLoopable () {}

	void OnTimer () {OnSignalAbort ();}
	void InitLoopControl (CParameterTable *params, CLoopable *parent);

	virtual void OnSignalAbort () {InterlockedIncrement (&m_abortFlag);}
	virtual bool CheckTimeout (DWORD, DWORD) {return false;}

	virtual bool ThreadMain ();
	virtual bool LoopStart () {return true;}
	virtual bool LoopMain () = 0;
	virtual void LoopExit () {}
	virtual LPCTSTR GetName () = 0;

};

class CTestObj;

class CLoopManager : public CLoopable
{
	CHandleArray m_threadArray;
	CArray <CLoopable*, MAX_WAIT_HANDLES> m_objectArray;

	CCommandItem *m_loop;
	CLoopable *m_parent;

	long m_pollingPeriod;

	void AddThread (CLoopable *test, HANDLE thread);
	void RemoveThread (int arrayIndex);
	void CheckThreads ();

public:
	CLoopManager ();
	CLoopManager (CCommandItem *loop, CLoopable *parent = NULL);
	~CLoopManager ();

	void StartTesting (CCommandItem *loop);
	virtual bool LoopMain ();
	virtual LPCTSTR GetName () {return m_loop->GetName ();}

	void StartLoop (CCommandItem *loop);
	void RunLoop (CCommandItem *loop);
	void WaitLoop ();

	void StartTest (LPCTSTR name, CParameterTable *local);
	void RunTest (LPCTSTR name, CParameterTable *local);
	void StopThreads ();

	void OnSignalAbort () {StopThreads();}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\message.cpp ===
// message.cpp

#include "stdafx.h"
/*
TObjectFactory <CMessageObj, int, pfuncCreateMsg> CMessageObj::m_factory;

IMPLEMENT_MSGHANDLER (XMSG_TESTING_STARTED, CMsgTestingStarted, cmd)
{
	cmd->Type;
	printf ("testing started\n");
	return NULL;
}
	
IMPLEMENT_MSGHANDLER (XMSG_TESTING_ENDED, CMsgTestingEnded, cmd)
{
	cmd->Type;
	printf ("testing ended\n");
	return NULL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\parameter.h ===
// parameter.h

#pragma once

class CLineParser;

class CParameterItem : public CTreeItem
{
	CAutoDelete<_TCHAR> m_value;

public:
	CParameterItem (LPCTSTR name, LPCTSTR value = NULL);

	bool GetBoolean ();
	int GetInt ();
	UINT GetUint ();
	LPCTSTR GetValue () {return m_value.get();}
	int GetChoice (va_list argptr);
	CParameterItem *FindParameter (LPCTSTR name) 
		{return (CParameterItem *) ((name)? FindChild(name):GetFirstChild());}
};

class CParameterTable : public CParseLine
{
	CParameterItem m_list;

public:
	CParameterTable ():m_list(_T("parameters")) {}
	~CParameterTable () {m_list.DeleteChildren();}

	CParameterItem *FindParameter (LPCTSTR module, LPCTSTR name);
	void AddParameter (LPCTSTR module, LPCTSTR name, LPCTSTR value);
	_TCHAR ParseParameter (LPTSTR *line, LPCTSTR module = NULL);
	bool ParseLine (LPTSTR line);

	bool GetCfgBoolean (LPCTSTR module, LPCTSTR name, bool defaultbool);
	int GetCfgInt (LPCTSTR module, LPCTSTR name, int defaultInt);
	UINT GetCfgUint (LPCTSTR module, LPCTSTR name, UINT defaultUint);
	LPCTSTR GetCfgString (LPCTSTR module, LPCTSTR name, LPCTSTR defaultStr);
	int GetCfgChoice (LPCTSTR module, LPCTSTR name, int defaultChoice, ...);
	int GetCfgChoice (LPCTSTR module, LPCTSTR name, int defaultChoice, va_list argptr);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\numbers.h ===
// numbers.h

// Module number list
// 
// If you are adding a new module, check this file out
// add your module to the end of list giving it a
// numeric value of 1 + lastone in the list
//
#define MODNUM_XMTA 0
#define MODNUM_EVAL 1
#define MODNUM_AUDIO 2
#define MODNUM_CPU 3
#define MODNUM_USB 4
#define MODNUM_RTC 5
#define MODNUM_SMC 6
#define MODNUM_NV2A 7
#define MODNUM_EVAL2 8
#define MODNUM_GRAFX 9
#define MODNUM_MEMORY 10
#define MODNUM_HOST_COMMUNICATION_EXAMPLE 11
#define MODNUM_TV 12
#define MODNUM_TOOL 13
#define MODNUM_HARD_DISK 14
#define MODNUM_BOOT_LOADER 15
#define MODNUM_LAN 16
#define MODNUM_DVD 17
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\parameter.cpp ===
// parameter.cpp

#include "stdafx.h"

CParameterItem::CParameterItem (LPCTSTR name, LPCTSTR value):CTreeItem (name)  
{
	m_value.set (value? NewTSTR(value):NULL);
}

bool CParameterItem::GetBoolean ()
{
	if (!_tcsicmp (GetValue(), _T("true")))
		return true;
	else
	if (_tcsicmp (GetValue(), _T("false")))
		g_error.ThrowConversionFailed (GetName(), _T("true/false") );

	return false;
}

int CParameterItem::GetInt ()
{
	errno = 0;
	_TCHAR *end;
	int x = (int) _tcstol (GetValue(), &end, 0);

	if ((*end != 0) || (errno == ERANGE))
		g_error.ThrowConversionFailed (GetName(), _T("int"));
		
	return x;
}

UINT CParameterItem::GetUint ()
{
	errno = 0;
	LPTSTR end;
	LPCTSTR value = GetValue();

	UINT x = (UINT) _tcstoul (value, &end, 0);

	if ((*end != 0)  || (errno == ERANGE))
		g_error.ThrowConversionFailed (GetName (), _T("UINT"));

	return x;
}

int CParameterItem::GetChoice (va_list argptr)
{
	LPCTSTR option, last = NULL; 
	int choice = -1;
	do {
		choice++;
		option = va_arg (argptr, LPCTSTR);
		if (option == NULL) // end of the list, no matches
		{
			g_error.ThrowParameterValueOutOfRange (GetName ());
		}

		// This is an attempt at early detection of an
		// ommitted NULL terminator
		if ((choice > 0) && ((((const int)last)^((const int)option)) > 0xffff))
			g_error.ThrowNullTerminatorMissing (GetName ());
		last = option;

	} while (_tcsicmp (GetValue(), option) != 0);


	return choice;
}

CParameterItem *CParameterTable::FindParameter (LPCTSTR module, LPCTSTR name)
{
	CParameterItem *moduleItem = m_list.FindParameter (module);
	return (moduleItem == NULL)? NULL:moduleItem->FindParameter (name);
}

void CParameterTable::AddParameter (LPCTSTR module, LPCTSTR name, LPCTSTR value)
{
	// If this is the first parameter from a module,
	// we will need to create the module node first
	//
	CParameterItem *moduleItem = m_list.FindParameter (module);
	if (!moduleItem)
	{
		moduleItem = new CParameterItem (module);
		m_list.AddChild (moduleItem);
	}

	// Check for duplicates
	if (moduleItem->FindParameter (name))
		g_error.ThrowDuplicateParameterFound (name);

	// Now add the parameter
	//
	CParameterItem *paramItem = new CParameterItem (name, value);
	moduleItem->AddChild (paramItem);
}

_TCHAR CParameterTable::ParseParameter (LPTSTR *line, LPCTSTR module)
{
	// Now we get the parameter name.  There are two possible forms
	//		1) <name> "=" <value>
	// or	2) <name>
	// The second form is simply shorthand for <name> "= true"
	//
	CParseWord param (_T(",= "));
	CParseSymbol equals (_T('='));
	_TCHAR next = param.GetToken (line);
	if ((next == _T('=')) || equals.GetToken (line))
	{
		// Get the parameter value and add to the table
		//
		CParseWord value (_T(","));
		next = value.GetToken (line);
		if (_tcslen (value) > 0)
			AddParameter (module, param, value);
		else
			g_error.ThrowExpectingParameterValue (param);
	}
	else
	// If this is just a parameter name, then we
	// assume its a boolean and set its value to true.
	//
	if ((next == _T(',')) || (next == _T('\0'))) 
		AddParameter (module, param, _T("true"));
	else
		g_error.ThrowExpectingParameterEnd (param);

	// We return the terminal for the case where
	// we are parsing a local parameter line
	//
	return next;
}

#ifdef PARAM_LIST_SYNTAX
	CParameterItem *CParameterTable::GetLastParameter (LPCTSTR module)
	{
		CParameterItem *moduleItem = m_list.FindParameter (module);
		return (CParameterItem *) moduleItem->GetLastChild (name);
	}
#endif

bool CParameterTable::ParseLine (LPTSTR line)
{
	CParseWord module (_T(". ,="));
	if (module.GetToken (&line) != _T('.'))
		g_error.ThrowExpectingParameterModule ();

	_TCHAR terminal = ParseParameter (&line, module);

	if (terminal == _T(','))

#ifndef PARAM_LIST_SYNTAX
		g_error.ThrowExpectingParameterEnd (_T(","));
#else
		CParameterItem *parentItem = GetLastParameter (module);

	// This loop parses a list of parameter values ...
	int count = 1;
	while (terminal == _T(','))
	{
		_TCHAR number [8];
		_stprintf (number, "%d", count);
		terminal = value.GetToken (&line);
		CParameterItem *newItem = new CParameterItem (number, value);
		parentItem->AddChild (newItem);
		count++;
	}
#endif
	return true;
}

int CParameterTable::GetCfgInt (LPCTSTR module, LPCTSTR name, int defaultInt)
{
	CParameterItem *param = FindParameter (module, name);
	return param? param->GetInt():defaultInt;
}

UINT CParameterTable::GetCfgUint (LPCTSTR module, LPCTSTR name, UINT defaultUint)
{
	CParameterItem *param = FindParameter (module, name);
	return param? param->GetUint():defaultUint;
}

LPCTSTR CParameterTable::GetCfgString (LPCTSTR module, LPCTSTR name, LPCTSTR defaultStr)
{
	CParameterItem *param = FindParameter (module, name);
	return param? param->GetValue():defaultStr;
}

int CParameterTable::GetCfgChoice (LPCTSTR module, LPCTSTR name, int defaultChoice, ...)
{
	va_list arglist;
	va_start (arglist, defaultChoice);

	return GetCfgChoice (module, name, defaultChoice, arglist);
}

int CParameterTable::GetCfgChoice (LPCTSTR module, LPCTSTR name, int defaultChoice, va_list argptr)
{
	CParameterItem *param = FindParameter (module, name);
	return param? param->GetChoice(argptr):defaultChoice;
}

bool CParameterTable::GetCfgBoolean (LPCTSTR module, LPCTSTR name, bool defaultbool)
{
	CParameterItem *param = FindParameter (module, name);
	return param? param->GetBoolean():defaultbool;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\mid.h ===
// mid.h
#pragma once

// Message ID header file
//

// Reserved response codes
//
// Note: The data of a negative response must be a string describing the failure
//       Whether the string is ascii or unicode depends on the type of the 
//       original message.
//
#define MSG_OK				0x00000000
#define MSG_ACK				0xFFFFFFFF
#define MSG_NOSUBSCRIBER	0xFFFFFFFE

// Message ID fields
//
//	bits  0 to 15:	TYPE: unique to category
//	bits 16 to 23:	CATEGORY:
//							0 - Core test message TestingStarted, etc
//							1 - Non-UHC message, sent to a utility or control
//							2 - For UUT connection to host
//							4 - UHC message, but not a core message.
//
//	bits 24 to 31:	BITFIELD: ignored for routing purposes, but passed to
//					the destination.
//					Bit 31:	0 = message strings are UNICODE
//							1 = message strings are ASCII
//					Bit 30:	0 = no response from host expected
//							1 = response from host expected
//					Bit 29: 0 = ACK response expected
//							1 = no ACK response expected
//				
//
// NOTE: All STRINGs are zero terminated and must be unicode,
//       unless noted otherwise  (as in STRING (A/U))
//
// NOTE: When adding a new MID, always add to the end
//       of the list and always add 1 to the previous number

///////////////////////////////////////////////////////////////////////////



#define MID_BITFIELD_MASK			0xFF000000
#define MID_CATEGORY_MASK			0x00FF0000
#define MID_TYPE_MASK				0x0000FFFF

//
// BITFIELD
//
#define MID_STRING_BITFIELD			0x80000000

#define MID_RESPONSE_BITFIELD		0x40000000
#define MID_NO_RESPONSE_EXPECTED	0x00000000
#define MID_RESPONSE_EXPECTED		0x40000000

//
// CATEGORY
//
#define MID_CORE_CATEGORY			0x00000000
#define MID_TEST_CATEGORY			0x00010000
#define MID_CONNECT_CATEGORY		0x00020000
#define MID_SCAN_CATEGORY			0x00030000
#define MID_HOST_CATEGORY			0x00040000
#define MID_FACTORY_CATEGORY		0x00050000
#define MID_DEBUG_CATEGORY			0x00060000

#define MID_NO_DATA					""

enum enumMID {
#define X(a,b,c) a = b,
#include "mid.x"
#undef X
};

// These defines are placed after the enum definition above
// to discourage the setting of these bits in an MID

#define MID_UNICODE_STRINGS			0x00000000
#define MID_ASCII_STRINGS			0x80000000

#define MID_ACK_BITFIELD			0x20000000
#define MID_ACK_EXPECTED			0x00000000
#define MID_NO_ACK_EXPECTED			0x20000000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\message.h ===
// message.h

// Message Dispatcher
//
//-- Generic classes ----------------------------------------------------------
// TDynamicObj        - Base class for dynamically created objects.
//                      This class holds a class factory that can
//                      create objects of the derived type.
// TDispatcher        - Base class of a dispatcher which implements
//                      just one function: the MainDispatcher.
//                      this is the function that reads the incoming
//                      buffer, converts it to a class and calls
//						the appropriate routine to dispatch it.
// CStore             - Class that "wraps" a message buffer
//                      provides the functions that allow for insertion
//                      and extraction of data in a serial buffer.
// CLoadable          - Base class of the events serialized in a buffer
//                      This class is an absolute base class which
//                      declares the Load and Store functions, implemented
//                      by the derived classes
// -- specializaions ----------------------------------------------------------
//
// pfuncCreateMsg     - Function that creates a CMessageObj 
//
// CMsgDispatcher     - Derived from CDispatcher, this class implements
//                      one dispatch routine for each incoming message.
// CMessageObj        - Class derived from CDynamicObj
//                    - This class is the base class for all classes
//                    - instantiated from incoming messages

class CMsgDispatcher;
class CMessageObj;

typedef CMessageObj* (*pfuncCreateMsg) ();
class CMessageObj : public TDynamicObj <CMessageObj, int, pfuncCreateMsg>
	{public: virtual CMessageObj* Dispatch (CMsgDispatcher*) {return NULL;}};

struct CMsgRegistrar
{
	CMsgRegistrar (int k, pfuncCreateMsg f) 
		{CMessageObj::RegisterObject (k, f);}
};

// DERIVE_CLASS macro
//
// D - derived class
// E - event class, externally declared
// 
#define DECLARE_MSGHANDLER(D,E) class D : public E, public CMessageObj \
{\
	CMessageObj* Dispatch (CMsgDispatcher *d); \
	static CMsgRegistrar m_registrar; \
	static CMessageObj* CreateObject () {return new D ();} \
}

#define IMPLEMENT_MSGHANDLER(id,D,var) \
	CMsgRegistrar D::m_registrar (id, &D::CreateObject); \
	CMessageObj* D::Dispatch (CMsgDispatcher *d) {return d->Dispatch ((D*) this);} \
	CMessageObj* CMsgDispatcher::Dispatch (D* var)

// Here we derive a class from each incoming message type.
// Then define a member function of the Dispatcher for each
// derived class.

DECLARE_MSGHANDLER (CMsgTestingStarted, CMsg::TestingStarted);
DECLARE_MSGHANDLER (CMsgTestingEnded, CMsg::TestingEnded);
	
class CMsgDispatcher:public TDispatcher <CMessageObj, int>
{
public:
	CMessageObj* Dispatch (CMsgTestingStarted* cmd);
	CMessageObj* Dispatch (CMsgTestingEnded* cmd);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\parser.cpp ===
// parser.cpp 
//

#include "stdafx.h"

_TCHAR CParseWord::GetToken (LPTSTR *cp)
{
//	_tprintf (L"GetWord (%s) %s\n", m_terminals, *cp);

	// Skip leading whitespace
	//
	size_t length = _tcsspn (*cp, _T(" \t"));
	if (length > 0)
		*cp += length;

	// Record the first character before moving the 
	// char pointer forward.
	//
	m_token = *cp;
	if (_tcslen (m_token) == 0) // check for end of line
		return _T('\0');

	// Find the next terminal and move the line pointer
	// to the character after it, but if this is the
	// end of the line, move the pointer to the zero terminator
	//
	length = _tcscspn (m_token, m_terminals);
	*cp += length + ((length < _tcslen (*cp))? 1:0);

	// Record the terminal, zero terminate the token
	// and return the recorded terminal
	//
	_TCHAR terminal = m_token [length];
	m_token [length] = 0;
	return terminal;
}

bool CParseSymbol::GetToken (LPTSTR *cp)
{
	while (**cp == _T(' ')) // skip white space
		(*cp)++;

	if (**cp == m_symbol)
		(*cp)++;
	else
		return false;

	return true;
}

CParseINI::CParseINI (LPTSTR pStringBuffer)
{
	m_lineNumber = 0;
	m_current = pStringBuffer;
}

CParseINI::~CParseINI ()
{
}

LPTSTR CParseINI::GetLine ()
{
	int length, next;

	// Skip leading whitespace
	//
	length = _tcsspn (m_current, _T(" \t"));
	if (length > 0)
		m_current = &m_current [length];
	
	// Return if end of buffer found
	//
	if (*m_current == 0)
		return NULL;

	// The following loop concatenates lines joined by a backslash
	//
	for (;;)
	{
		// First take the length of the line and use the terminator
		// to determine the position of the next line in the buffer.
		//
		length = next = _tcscspn (m_current, _T("\n\r"));
		_TCHAR lineEnding = m_current [length];
		m_current [length] = 0; // terminate the line
		switch (lineEnding)
		{
			case _T('\r'): next++; // cr-lf pair
			case _T('\n'): next++; // line feed only
		}

		// Remove comments by readjusting the length
		//
		length = _tcscspn (m_current, _T(";#"));
		m_current [length] = 0; // terminate again
break;
// The rest of this loop was to concatenate lines.  This has been removed so that
// a backslash can be used in path names.
/*
		int backslash = _tcscspn (m_current, _T("\\"));
		if (backslash >= length)
			break;

		// Join the two lines by shifting the buffer, and removing 
		// everything between the slash and the next new line.
		//
		_tcscpy (&m_current [backslash], &m_current [next]);
		m_lineNumber++;
*/
	}

	// Remove trailing whitespace
	//
	while ((length > 0) && ((m_current [length - 1] == _T(' ')) 
							|| (m_current [length - 1] == _T('\t'))))
	{
		m_current [--length] = 0;
	}

	// Increment line number and return original position
	//
	LPTSTR lp = m_current;
	m_current = &m_current [next];
	m_lineNumber++;
	return lp;
}

bool CParseINI::SeekSection (LPCTSTR section)
{
	CAutoString name (_T("[%s]"), section);

	LPTSTR lp = GetLine ();
	while (lp)
	{
		if (_tcsicmp (lp, name) == 0)
			return true;
		lp = GetLine ();
	}

	return false;
}

#define BLANK_LINE(lp) (*lp == 0)
#define SECTION_END(cp) (*cp == 0 || *cp == _T('['))

// GetNextLine
//
// This function skips blank lines and stops at the
// end of a section.
//
LPTSTR CParseINI::GetNextLine ()
{
	while (!SECTION_END (m_current))
	{
		LPTSTR lp = GetLine ();
		if (!BLANK_LINE(lp))
			return lp;
	}

	return NULL;
}

void CParseINI::ParseSection (LPCTSTR sectionName, CParseLine *parser)
{
	LPTSTR lp = NULL;

	try 
	{
		if (!SeekSection (sectionName))
			g_error.ThrowSectionNotFound (sectionName);
		
		for (lp = GetNextLine (); lp != NULL; lp = GetNextLine ())
			parser->ParseLine (lp);
	}
	catch (CXmtaException x) 
	{
		throw CXmtaException (x.GetErrorCode(), 
			_T("%sOn line %d of the INI file:\n\"%s\"\n"),
			x.GetMessage(), m_lineNumber, lp);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\parser.h ===
// ini_file.h

#pragma once

class CParseLine
{
public:
	virtual bool ParseLine (LPTSTR line) = 0;
};

class CParseINI
{
	int m_lineNumber;
	LPTSTR m_current;

	LPTSTR GetLine ();

public:
	CParseINI (LPTSTR pStringBuffer);
	~CParseINI ();

	bool Open (LPCTSTR filename);
	bool SeekSection (LPCTSTR sectionname);
	LPTSTR GetNextLine ();
	void ParseSection (LPCTSTR sectionName, CParseLine *parser);
	void Close ();
};

class CParseWord
{
	LPTSTR m_token;
	LPCTSTR m_terminals;

public:
	CParseWord (LPCTSTR terminals):
		m_terminals(terminals), m_token(NULL) {}
	_TCHAR GetToken (LPTSTR *cp);
	LPCTSTR GetText () {return m_token;}
	operator LPCTSTR () {return GetText ();}
};

class CParseSymbol
{
	_TCHAR m_symbol;

public:
	CParseSymbol (_TCHAR symbol):m_symbol(symbol) {}
	bool GetToken (LPTSTR *cp);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\sources.inc ===
TARGETPATH=..\lib
TARGETTYPE=LIBRARY

386_STDCALL=0
USE_NATIVE_EH=1
USE_LIBCMT=1

XDK_LIB_PATH=$(BASEDIR)\public\xdk\lib-aug01
XDK_INC_PATH=$(BASEDIR)\public\xdk\inc-aug01

INCLUDES=$(XDK_INC_PATH);$(INCLUDES);..
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xmta.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\statkeys.h ===
// xmtakeys.h

#pragma once

#ifndef _XMTA_KEYS_
#define _XMTA_KEYS_

//Key values for ReportStatistic() functions.

//***************************
//Some XGRAFX HDTV key values
//
//pixelcount test stats
#define HDTV_480P_G_PIXELCOUNT _T("HDTV_480P_G_PIXELCOUNT")
#define HDTV_480P_R_PIXELCOUNT _T("HDTV_480P_R_PIXELCOUNT")
#define HDTV_480P_B_PIXELCOUNT _T("HDTV_480P_B_PIXELCOUNT")
#define HDTV_720P_G_PIXELCOUNT _T("HDTV_720P_G_PIXELCOUNT")
#define HDTV_720P_R_PIXELCOUNT _T("HDTV_720P_R_PIXELCOUNT")
#define HDTV_720P_B_PIXELCOUNT _T("HDTV_720P_B_PIXELCOUNT")
#define HDTV_1080I_G_PIXELCOUNT _T("HDTV_1080I_G_PIXELCOUNT")
#define HDTV_1080I_R_PIXELCOUNT _T("HDTV_1080I_R_PIXELCOUNT")
#define HDTV_1080I_B_PIXELCOUNT _T("HDTV_1080I_B_PIXELCOUNT")
#define HDTV_480P_PIXEL_THRESHOLD _T("HDTV_480P_PIXEL_THRESHOLD")
#define HDTV_720P_PIXEL_THRESHOLD _T("HDTV_720P_PIXEL_THRESHOLD")
#define HDTV_1080I_PIXEL_THRESHOLD _T("HDTV_1080I_PIXEL_THRESHOLD")


//dac linearity test stats
#define HDTV_480P_Y_DAC_FULLSCALE _T("HDTV_480P_Y_DAC_FULLSCALE")
#define HDTV_480P_PR_DAC_FULLSCALE _T("HDTV_480P_PR_DAC_FULLSCALE")
#define HDTV_480P_PB_DAC_FULLSCALE _T("HDTV_480P_PB_DAC_FULLSCALE")
#define HDTV_720P_Y_DAC_FULLSCALE _T("HDTV_720P_Y_DAC_FULLSCALE")
#define HDTV_720P_PR_DAC_FULLSCALE _T("HDTV_720P_PR_DAC_FULLSCALE")
#define HDTV_720P_PB_DAC_FULLSCALE _T("HDTV_720P_PB_DAC_FULLSCALE")
#define HDTV_1080I_Y_DAC_FULLSCALE _T("HDTV_1080I_Y_DAC_FULLSCALE")
#define HDTV_1080I_PR_DAC_FULLSCALE _T("HDTV_1080I_PR_DAC_FULLSCALE")
#define HDTV_1080I_PB_DAC_FULLSCALE _T("HDTV_1080I_PB_DAC_FULLSCALE")

//timings test stats
#define HDTV_480P_TIMINGS_HSYNC_HIGH _T("HDTV_480P_TIMINGS_HSYNC_HIGH")
#define HDTV_480P_TIMINGS_HSYNC_LOW _T("HDTV_480P_TIMINGS_HSYNC_LOW")
#define HDTV_480P_TIMINGS_HFPORCH _T("HDTV_480P_TIMINGS_HFPORCH")
#define HDTV_480P_TIMINGS_HBPORCH _T("HDTV_480P_TIMINGS_HBPORCH")
#define HDTV_480P_TIMINGS_VSYNC_HIGH _T("HDTV_480P_TIMINGS_VSYNC_HIGH")
#define HDTV_480P_TIMINGS_VSYNC_LOW _T("HDTV_480P_TIMINGS_VSYNC_LOW")
#define HDTV_480P_TIMINGS_VFPORCH _T("HDTV_480P_TIMINGS_VFPORCH")
#define HDTV_480P_TIMINGS_VBPORCH _T("HDTV_480P_TIMINGS_VBPORCH")
#define HDTV_720P_TIMINGS_HSYNC_HIGH _T("HDTV_720P_TIMINGS_HSYNC_HIGH")
#define HDTV_720P_TIMINGS_HSYNC_LOW _T("HDTV_720P_TIMINGS_HSYNC_LOW")
#define HDTV_720P_TIMINGS_HFPORCH _T("HDTV_720P_TIMINGS_HFPORCH")
#define HDTV_720P_TIMINGS_HBPORCH _T("HDTV_720P_TIMINGS_HBPORCH")
#define HDTV_720P_TIMINGS_VSYNC_HIGH _T("HDTV_720P_TIMINGS_VSYNC_HIGH")
#define HDTV_720P_TIMINGS_VSYNC_LOW _T("HDTV_720P_TIMINGS_VSYNC_LOW")
#define HDTV_720P_TIMINGS_VFPORCH _T("HDTV_720P_TIMINGS_VFPORCH")
#define HDTV_720P_TIMINGS_VBPORCH _T("HDTV_720P_TIMINGS_VBPORCH")
#define HDTV_1080I_TIMINGS_HSYNC_HIGH _T("HDTV_1080I_TIMINGS_HSYNC_HIGH")
#define HDTV_1080I_TIMINGS_HSYNC_LOW _T("HDTV_1080I_TIMINGS_HSYNC_LOW")
#define HDTV_1080I_TIMINGS_HFPORCH _T("HDTV_1080I_TIMINGS_HFPORCH")
#define HDTV_1080I_TIMINGS_HBPORCH _T("HDTV_1080I_TIMINGS_HBPORCH")
#define HDTV_1080I_TIMINGS_VSYNC_HIGH _T("HDTV_1080I_TIMINGS_VSYNC_HIGH")
#define HDTV_1080I_TIMINGS_VSYNC_LOW _T("HDTV_1080I_TIMINGS_VSYNC_LOW")
#define HDTV_1080I_TIMINGS_VFPORCH _T("HDTV_1080I_TIMINGS_VFPORCH")
#define HDTV_1080I_TIMINGS_VBPORCH _T("HDTV_1080I_TIMINGS_VBPORCH")

//tri-level sync test stats
#define HDTV_480P_TRILEVEL_SYNC_MODE2_LEADING _T("HDTV_480P_TRILEVEL_SYNC_MODE2_LEADING")
#define HDTV_480P_TRILEVEL_SYNC_MODE2_TRAILING _T("HDTV_480P_TRILEVEL_SYNC_MODE2_TRAILING")
#define HDTV_720P_TRILEVEL_SYNC_MODE3_LEADING _T("HDTV_720P_TRILEVEL_SYNC_MODE3_LEADING")
#define HDTV_720P_TRILEVEL_SYNC_MODE2_LEADING _T("HDTV_720P_TRILEVEL_SYNC_MODE2_LEADING")
#define HDTV_720P_TRILEVEL_SYNC_MODE2_TRAILING _T("HDTV_720P_TRILEVEL_SYNC_MODE2_TRAILING")
#define HDTV_1080I_TRILEVEL_SYNC_MODE3_LEADING _T("HDTV_1080I_TRILEVEL_SYNC_MODE3_LEADING")
#define HDTV_1080I_TRILEVEL_SYNC_MODE2_LEADING _T("HDTV_1080I_TRILEVEL_SYNC_MODE2_LEADING")
#define HDTV_1080I_TRILEVEL_SYNC_MODE2_TRAILING _T("HDTV_1080I_TRILEVEL_SYNC_MODE2_TRAILING")

//end of XGRAFX HDTV keys
//***********************




#define XAUDIO_ANALOG_DC_OFFSET_PERCENT_LEFT_CHANNEL _T("XAudio Analog DC Offset Percent Left Channel (dB)")
#define XAUDIO_ANALOG_DC_OFFSET_PERCENT_RIGHT_CHANNEL _T("XAudio Analog DC Offset Percent Right Channel (dB)")
#define XAUDIO_SILENCE_DC_OFFSET_PERCENT_LEFT_CHANNEL _T("XAudio Silence DC Offset Percent Left Channel (dB)")
#define XAUDIO_SILENCE_DC_OFFSET_PERCENT_RIGHT_CHANNEL _T("XAudio Silence DC Offset Percent Right Channel (dB)")
#define XAUDIO_DIGITAL_DC_OFFSET_PERCENT_LEFT_CHANNEL _T("XAudio Digital DC Offset Percent Left Channel (dB)")
#define XAUDIO_DIGITAL_DC_OFFSET_PERCENT_RIGHT_CHANNEL _T("XAudio Digital DC Offset Percent Right Channel (dB)")

#define XAUDIO_ANALOG_MAX_FREQUENCY_AMPLITUDE_LEFT_CHANNEL _T("XAudio Analog Maximum Frequency Amplitude Left Channel (dB,Hz)")
#define XAUDIO_ANALOG_MAX_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL _T("XAudio Analog Maximum Frequency Amplitude Right Channel (dB,Hz)")
#define XAUDIO_SILENCE_MAX_FREQUENCY_AMPLITUDE_LEFT_CHANNEL _T("XAudio Silence Maximum Frequency Amplitude Left Channel (dB,Hz)")
#define XAUDIO_SILENCE_MAX_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL _T("XAudio Silence Maximum Frequency Amplitude Right Channel (dB,Hz)")
#define XAUDIO_DIGITAL_MAX_FREQUENCY_AMPLITUDE_LEFT_CHANNEL _T("XAudio Digital Maximum Frequency Amplitude Left Channel (dB,Hz)")
#define XAUDIO_DIGITAL_MAX_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL _T("XAudio Digital Maximum Frequency Amplitude Right Channel (dB,Hz)")

#define XAUDIO_ANALOG_MIN_FREQUENCY_AMPLITUDE_LEFT_CHANNEL _T("XAudio Analog Minimum Frequency Amplitude Left Channel (dB,Hz)")
#define XAUDIO_ANALOG_MIN_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL _T("XAudio Analog Minimum Frequency Amplitude Right Channel (dB,Hz)")
#define XAUDIO_SILENCE_MIN_FREQUENCY_AMPLITUDE_LEFT_CHANNEL _T("XAudio Silence Minimum Frequency Amplitude Left Channel (dB,Hz)")
#define XAUDIO_SILENCE_MIN_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL _T("XAudio Silence Minimum Frequency Amplitude Right Channel (dB,Hz)")
#define XAUDIO_DIGITAL_MIN_FREQUENCY_AMPLITUDE_LEFT_CHANNEL _T("XAudio Digital Minimum Frequency Amplitude Left Channel (dB,Hz)")
#define XAUDIO_DIGITAL_MIN_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL _T("XAudio Digital Minimum Frequency Amplitude Right Channel (dB,Hz)")

#define XAUDIO_ANALOG_MAX_NOISE_LEVEL_LEFT_CHANNEL _T("XAudio Analog Maximum Noise Level Left Channel (dB,Hz)")
#define XAUDIO_ANALOG_MAX_NOISE_LEVEL_RIGHT_CHANNEL _T("XAudio Analog Maximum Noise Level Right Channel (dB,Hz)")
#define XAUDIO_SILENCE_MAX_NOISE_LEVEL_LEFT_CHANNEL _T("XAudio Silence Maximum Noise Level Left Channel (dB,Hz)")
#define XAUDIO_SILENCE_MAX_NOISE_LEVEL_RIGHT_CHANNEL _T("XAudio Silence Maximum Noise Level Right Channel (dB,Hz)")
#define XAUDIO_DIGITAL_MAX_NOISE_LEVEL_LEFT_CHANNEL _T("XAudio Digital Maximum Noise Level Left Channel (dB,Hz)")
#define XAUDIO_DIGITAL_MAX_NOISE_LEVEL_RIGHT_CHANNEL _T("XAudio Digital Maximum Noise Level Right Channel (dB,Hz)")

#define XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_LEFT_CHANNEL _T("XAudio Analog Signal To Noise Ratio Left Channel (dB)")
#define XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_RIGHT_CHANNEL _T("XAudio Analog Signal To Noise Ratio Right Channel (dB)")
#define XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_LEFT_CHANNEL _T("XAudio Silence Signal To Noise Ratio Left Channel (dB)")
#define XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_RIGHT_CHANNEL _T("XAudio Silence Signal To Noise Ratio Right Channel (dB)")
#define XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_LEFT_CHANNEL _T("XAudio Digital Signal To Noise Ratio Left Channel (dB)")
#define XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_RIGHT_CHANNEL _T("XAudio Digital Signal To Noise Ratio Right Channel (dB)")

#define XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_LEFT_CHANNEL _T("XAudio Analog Signal To Noise Ratio Ignoring Crosstalk Left Channel (dB)")
#define XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_RIGHT_CHANNEL _T("XAudio Analog Signal To Noise Ratio Ignoring Crosstalk Right Channel (dB)")
#define XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_LEFT_CHANNEL _T("XAudio Silence Signal To Noise Ratio Ignoring Crosstalk Left Channel (dB)")
#define XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_RIGHT_CHANNEL _T("XAudio Silence Signal To Noise Ratio Ignoring Crosstalk Right Channel (dB)")
#define XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_LEFT_CHANNEL _T("XAudio Digital Signal To Noise Ratio Ignoring Crosstalk Left Channel (dB)")
#define XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_RIGHT_CHANNEL _T("XAudio Digital Signal To Noise Ratio Ignoring Crosstalk Right Channel (dB)")

#define XAUDIO_ANALOG_CHANNEL_SEPERATION_LEFT_CHANNEL _T("XAudio Analog Channel Seperation Left Channel (dB)")
#define XAUDIO_ANALOG_CHANNEL_SEPERATION_RIGHT_CHANNEL _T("XAudio Analog Channel Seperation Right Channel (dB)")
#define XAUDIO_SILENCE_CHANNEL_SEPERATION_LEFT_CHANNEL _T("XAudio Silence Channel Seperation Left Channel (dB)")
#define XAUDIO_SILENCE_CHANNEL_SEPERATION_RIGHT_CHANNEL _T("XAudio Silence Channel Seperation Right Channel (dB)")
#define XAUDIO_DIGITAL_CHANNEL_SEPERATION_LEFT_CHANNEL _T("XAudio Digital Channel Seperation Left Channel (dB)")
#define XAUDIO_DIGITAL_CHANNEL_SEPERATION_RIGHT_CHANNEL _T("XAudio Digital Channel Seperation Right Channel (dB)")

#define XAUDIO_ANALOG_FREQUENCY_RESPONSE_LEFT_CHANNEL _T("XAudio Analog Frequency Response Left Channel (dB)")
#define XAUDIO_ANALOG_FREQUENCY_RESPONSE_RIGHT_CHANNEL _T("XAudio Analog Frequency Response Right Channel (dB)")
#define XAUDIO_SILENCE_FREQUENCY_RESPONSE_LEFT_CHANNEL _T("XAudio Silence Frequency Response Left Channel (dB)")
#define XAUDIO_SILENCE_FREQUENCY_RESPONSE_RIGHT_CHANNEL _T("XAudio Silence Frequency Response Right Channel (dB)")
#define XAUDIO_DIGITAL_FREQUENCY_RESPONSE_LEFT_CHANNEL _T("XAudio Digital Frequency Response Left Channel (dB)")
#define XAUDIO_DIGITAL_FREQUENCY_RESPONSE_RIGHT_CHANNEL _T("XAudio Digital Frequency Response Right Channel (dB)")

//XTV 
//Linearity Tests
#define NTSCM_COMPOSITE_HORIZONTAL_LINEARITY_MAX_RED _T("NTSC-M Composite Horizontal Linearity Max RED")
#define NTSCM_COMPOSITE_HORIZONTAL_LINEARITY_MAX_GREEN _T("NTSC-M Composite Horizontal Linearity Max GREEN")
#define NTSCM_COMPOSITE_HORIZONTAL_LINEARITY_MAX_BLUE _T("NTSC-M Composite Horizontal Linearity Max BLUE")

#define NTSCM_COMPOSITE_VERTICAL_LINEARITY_MAX_RED _T("NTSC-M Composite Vertical Linearity Max RED")
#define NTSCM_COMPOSITE_VERTICAL_LINEARITY_MAX_GREEN _T("NTSC-M Composite Vertical Linearity Max GREEN")
#define NTSCM_COMPOSITE_VERTICAL_LINEARITY_MAX_BLUE _T("NTSC-M Composite Vertical Linearity Max BLUE")


//NTSC-M Composite Color Bar:
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE _T("Ntsc-m Composite CB Luma IRE White Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW _T("Ntsc-m Composite CB Luma IRE Yellow Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN _T("Ntsc-m Composite CB Luma IRE Cyan Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN _T("Ntsc-m Composite CB Luma IRE Green Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA _T("Ntsc-m Composite CB Luma IRE Magenta Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_RED _T("Ntsc-m Composite CB Luma IRE Red Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE _T("Ntsc-m Composite CB Luma IRE Blue Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK _T("Ntsc-m Composite CB Luma IRE Black Bar")

#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE _T("Ntsc-m Composite CB Chroma IRE White Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW _T("Ntsc-m Composite CB Chroma IRE Yellow Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN _T("Ntsc-m Composite CB Chroma IRE Cyan Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN _T("Ntsc-m Composite CB Chroma IRE Green Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Ntsc-m Composite CB Chroma IRE Magenta Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED _T("Ntsc-m Composite CB Chroma IRE Red Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE _T("Ntsc-m Composite CB Chroma IRE Blue Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK _T("Ntsc-m Composite CB Chroma IRE Black Bar")


//#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_WHITE _T("Ntsc-m Composite CB Chroma Phase White Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Ntsc-m Composite CB Chroma Phase Yellow Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN _T("Ntsc-m Composite CB Chroma Phase Cyan Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN _T("Ntsc-m Composite CB Chroma Phase Green Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Ntsc-m Composite CB Chroma Phase Magenta Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED _T("Ntsc-m Composite CB Chroma Phase Red Bar")
#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE _T("Ntsc-m Composite CB Chroma Phase Blue Bar")
//#define NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLACK _T("Ntsc-m Composite CB Chroma Phase Black Bar")


//NTSC-M Svideo Color Bar:

#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE _T("Ntsc-m Svideo CB Luma IRE White Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW _T("Ntsc-m Svideo CB Luma IRE Yellow Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN _T("Ntsc-m Svideo CB Luma IRE Cyan Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN _T("Ntsc-m Svideo CB Luma IRE Green Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA _T("Ntsc-m Svideo CB Luma IRE Magenta Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_RED _T("Ntsc-m Svideo CB Luma IRE Red Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE _T("Ntsc-m Svideo CB Luma IRE Blue Bar")
#define NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK _T("Ntsc-m Svideo CB Luma IRE Black Bar")

#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE _T("Ntsc-m Svideo CB Chroma IRE White Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW _T("Ntsc-m Svideo CB Chroma IRE Yellow Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN _T("Ntsc-m  Svideo CB Chroma IRE Cyan Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN _T("Ntsc-m Svideo CB Chroma IRE Green Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Ntsc-m Svideo CB Chroma IRE Magenta Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_RED _T("Ntsc-m Svideo CB Chroma IRE Red Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE _T("Ntsc-m Svideo CB Chroma IRE Blue Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK _T("Ntsc-m Svideo CB Chroma IRE Black Bar")


//#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_WHITE _T("Ntsc-m Svideo CB Chroma Phase White Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Ntsc-m Svideo CB Chroma Phase Yellow Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN _T("Ntsc-m Svideo CB Chroma Phase Cyan Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN _T("Ntsc-m Svideo CB Chroma Phase Green Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Ntsc-m Svideo CB Chroma Phase Magenta Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED _T("Ntsc-m Svideo CB Chroma Phase Red Bar")
#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE _T("Ntsc-m Svideo CB Chroma Phase Blue Bar")
//#define NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLACK _T("Ntsc-m  Svideo CB Chroma Phase Black Bar")


//NTSC-M Composite Multiburst
#define NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET1 _T("Ntsc-m Composite Multiburst Frequency Packet #1")
#define NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET2 _T("Ntsc-m Composite Multiburst Frequency Packet #2")
#define NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET3 _T("Ntsc-m Composite Multiburst Frequency Packet #3")
#define NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET4 _T("Ntsc-m Composite Multiburst Frequency Packet #4")
#define NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET5 _T("Ntsc-m Composite Multiburst Frequency Packet #5")
#define NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET6 _T("Ntsc-m Composite Multiburst Frequency Packet #6")


//NTSC-M Svideo Multiburst
#define NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET1 _T("Ntsc-m Svideo Multiburst Frequency Packet #1")
#define NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET2 _T("Ntsc-m Svideo Multiburst Frequency Packet #2")
#define NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET3 _T("Ntsc-m Svideo Multiburst Frequency Packet #3")
#define NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET4 _T("Ntsc-m Svideo Multiburst Frequency Packet #4")
#define NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET5 _T("Ntsc-m Svideo Multiburst Frequency Packet #5")
#define NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET6 _T("Ntsc-m Svideo Multiburst Frequency Packet #6")




//NTSC-Japan Composite Color Bar:
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE _T("Ntsc-Japan Composite CB Luma IRE White Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW _T("Ntsc-Japan Composite CB Luma IRE Yellow Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN _T("Ntsc-Japan Composite CB Luma IRE Cyan Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN _T("Ntsc-Japan Composite CB Luma IRE Green Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA _T("Ntsc-Japan Composite CB Luma IRE Magenta Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_RED _T("Ntsc-Japan Composite CB Luma IRE Red Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE _T("Ntsc-Japan Composite CB Luma IRE Blue Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK _T("Ntsc-Japan Composite CB Luma IRE Black Bar")

#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE _T("Ntsc-Japan Composite CB Chroma IRE White Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW _T("Ntsc-Japan Composite CB Chroma IRE Yellow Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN _T("Ntsc-Japan Composite CB Chroma IRE Cyan Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN _T("Ntsc-Japan Composite CB Chroma IRE Green Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Ntsc-Japan Composite CB Chroma IRE Magenta Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED _T("Ntsc-Japan Composite CB Chroma IRE Red Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE _T("Ntsc-Japan Composite CB Chroma IRE Blue Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK _T("Ntsc-Japan Composite CB Chroma IRE Black Bar")


//#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_WHITE _T("Ntsc-m Composite CB Chroma Phase White Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Ntsc-Japan Composite CB Chroma Phase Yellow Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN _T("Ntsc-Japan Composite CB Chroma Phase Cyan Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN _T("Ntsc-Japan Composite CB Chroma Phase Green Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Ntsc-Japan Composite CB Chroma Phase Magenta Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED _T("Ntsc-Japan Composite CB Chroma Phase Red Bar")
#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE _T("Ntsc-Japan Composite CB Chroma Phase Blue Bar")
//#define NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLACK _T("Ntsc-m Composite CB Chroma Phase Black Bar")

//NTSC-Japan Svideo Color Bar:

#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE _T("Ntsc-Japan Svideo CB Luma IRE White Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW _T("Ntsc-Japan Svideo CB Luma IRE Yellow Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN _T("Ntsc-Japan Svideo CB Luma IRE Cyan Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN _T("Ntsc-Japan Svideo CB Luma IRE Green Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA _T("Ntsc-Japan Svideo CB Luma IRE Magenta Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_RED _T("Ntsc-Japan Svideo CB Luma IRE Red Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE _T("Ntsc-Japan Svideo CB Luma IRE Blue Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK _T("Ntsc-Japan Svideo CB Luma IRE Black Bar")

#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE _T("Ntsc-Japan Svideo CB Chroma IRE White Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW _T("Ntsc-Japan Svideo CB Chroma IRE Yellow Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN _T("Ntsc-Japan  Svideo CB Chroma IRE Cyan Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN _T("Ntsc-Japan Svideo CB Chroma IRE Green Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Ntsc-Japan Svideo CB Chroma IRE Magenta Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_RED _T("Ntsc-Japan Svideo CB Chroma IRE Red Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE _T("Ntsc-Japan Svideo CB Chroma IRE Blue Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK _T("Ntsc-Japan Svideo CB Chroma IRE Black Bar")


//#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_WHITE _T("Ntsc-m Svideo CB Chroma Phase White Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Ntsc-Japan Svideo CB Chroma Phase Yellow Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN _T("Ntsc-Japan Svideo CB Chroma Phase Cyan Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN _T("Ntsc-Japan Svideo CB Chroma Phase Green Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Ntsc-Japan Svideo CB Chroma Phase Magenta Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED _T("Ntsc-Japan Svideo CB Chroma Phase Red Bar")
#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE _T("Ntsc-Japan Svideo CB Chroma Phase Blue Bar")
//#define NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLACK _T("Ntsc-m  Svideo CB Chroma Phase Black Bar")

//NTSC-Japan Composite Multiburst
#define NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET1 _T("Ntsc-Japan Composite Multiburst Frequency Packet #1")
#define NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET2 _T("Ntsc-Japan Composite Multiburst Frequency Packet #2")
#define NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET3 _T("Ntsc-Japan Composite Multiburst Frequency Packet #3")
#define NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET4 _T("Ntsc-Japan Composite Multiburst Frequency Packet #4")
#define NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET5 _T("Ntsc-Japan Composite Multiburst Frequency Packet #5")
#define NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET6 _T("Ntsc-Japan Composite Multiburst Frequency Packet #6")


//NTSC-Japan Svideo Multiburst
#define NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET1 _T("Ntsc-Japan Svideo Multiburst Frequency Packet #1")
#define NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET2 _T("Ntsc-Japan Svideo Multiburst Frequency Packet #2")
#define NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET3 _T("Ntsc-Japan Svideo Multiburst Frequency Packet #3")
#define NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET4 _T("Ntsc-Japan Svideo Multiburst Frequency Packet #4")
#define NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET5 _T("Ntsc-Japan Svideo Multiburst Frequency Packet #5")
#define NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET6 _T("Ntsc-Japan Svideo Multiburst Frequency Packet #6")





//PAL-BDGHI Composite Color Bar for Luma IRE:
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE _T("Pal-bdghi Composite CB Luma IRE White Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW _T("Pal-bdghi Composite CB Luma IRE Yellow Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN _T("Pal-bdghi Composite CB Luma IRE Cyan Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN _T("Pal-bdghi Composite CB Luma IRE Green Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA _T("Pal-bdghi Composite CB Luma IRE Magenta Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_RED _T("Pal-bdghi Composite CB Luma IRE Red Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE _T("Pal-bdghi Composite CB Luma IRE Blue Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK _T("Pal-bdghi Composite CB Luma IRE Balck Bar")
// PAL-BDGHI Composite Color Bar for Chroma IRE:
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE _T("Pal-bdghi Composite CB Chroma IRE White Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW _T("Pal-bdghi Composite CB Chroma IRE Yellow Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN _T("Pal-bdghi Composite CB Chroma IRE Cyan Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN _T("Pal-bdghi Composite CB Chroma IRE Green Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Pal-bdghi Composite CB Chroma IRE Magenta Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED _T("Pal-bdghi Composite CB Chroma IRE Red Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE _T("Pal-bdghi Composite CB Chroma IRE Blue Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK _T("Pal-bdghi Composite CB Chroma IRE Balck Bar")
// PAL-BDGHI Composite Color Bar for Chroma Phase
//#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_WHITE _T("Pal-bdghi Composite CB Chroma Phase White Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Pal-bdghi Composite CB Chroma Phase Yellow Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN _T("Pal-bdghi Composite CB Chroma Phase Cyan Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN _T("Pal-bdghi Composite CB Chroma Phase Green Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Pal-bdghi Composite CB Chroma Phase Magenta Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED _T("Pal-bdghi Composite CB Chroma Phase Red Bar")
#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE _T("Pal-bdghi Composite CB Chroma Phase Blue Bar")
//#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLACK _T("Pal-bdghi Composite CB Chroma Phase Balck Bar")


//PAL-BDGHI Svideo Color Bar for Luma IRE:
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE _T("Pal-bdghi Svideo CB Luma IRE White Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW _T("Pal-bdghi Svideo CB Luma IRE Yellow Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN _T("Pal-bdghi Svideo CB Luma IRE Cyan Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN _T("Pal-bdghi Svideo CB Luma IRE Green Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA _T("Pal-bdghi Svideo CB Luma IRE Magenta Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_RED _T("Pal-bdghi Svideo CB Luma IRE Red Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE _T("Pal-bdghi Svideo CB Luma IRE Blue Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK _T("Pal-bdghi Svideo CB Luma IRE Balck Bar")
// PAL-BDGHI Svideo Color Bar for Chroma IRE:
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE _T("Pal-bdghi Svideo CB Chroma IRE White Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW _T("Pal-bdghi Svideo CB Chroma IRE Yellow Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN _T("Pal-bdghi Svideo CB Chroma IRE Cyan Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN _T("Pal-bdghi Svideo CB Chroma IRE Green Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Pal-bdghi Svideo CB Chroma IRE Magenta Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_RED _T("Pal-bdghi Svideo CB Chroma IRE Red Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE _T("Pal-bdghi Svideo CB Chroma IRE Blue Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK _T("Pal-bdghi Svideo CB Chroma IRE Balck Bar")
// PAL-BDGHI Svideo Color Bar for Chroma Phase
//#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_WHITE _T("Pal-bdghi Composite CB Chroma Phase White Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Pal-bdghi Svideo CB Chroma Phase Yellow Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN _T("Pal-bdghi Svideo CB Chroma Phase Cyan Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN _T("Pal-bdghi Svideo CB Chroma Phase Green Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Pal-bdghi Svideo CB Chroma Phase Magenta Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED _T("Pal-bdghi Svideo CB Chroma Phase Red Bar")
#define PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE _T("Pal-bdghi Svideo CB Chroma Phase Blue Bar")
//#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLACK _T("Pal-bdghi Composite CB Chroma Phase Balck Bar")


//PAL-BDGHI Composite Multiburst
#define PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1 _T("pal-bdghi Composite Multiburst Frequency Packet #1")
#define PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2 _T("pal-bdghi Composite Multiburst Frequency Packet #2")
#define PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3 _T("pal-bdghi Composite Multiburst Frequency Packet #3")
#define PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4 _T("pal-bdghi Composite Multiburst Frequency Packet #4")
#define PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5 _T("pal-bdghi Composite Multiburst Frequency Packet #5")
#define PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6 _T("pal-bdghi Composite Multiburst Frequency Packet #6")


//PAL-BDGHI Svideo Multiburst
#define PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET1 _T("pal-bdghi Svideo Multiburst Frequency Packet #1")
#define PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET2 _T("pal-bdghi Svideo Multiburst Frequency Packet #2")
#define PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET3 _T("pal-bdghi Svideo Multiburst Frequency Packet #3")
#define PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET4 _T("pal-bdghi Svideo Multiburst Frequency Packet #4")
#define PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET5 _T("pal-bdghi Svideo Multiburst Frequency Packet #5")
#define PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET6 _T("pal-bdghi Svideo Multiburst Frequency Packet #6")





//PAL-M Composite Color Bar for Luma IRE:
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE _T("Pal-m Composite CB Luma IRE White Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW _T("Pal-m Composite CB Luma IRE Yellow Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN _T("Pal-m Composite CB Luma IRE Cyan Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN _T("Pal-m Composite CB Luma IRE Green Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA _T("Pal-m Composite CB Luma IRE Magenta Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_RED _T("Pal-m Composite CB Luma IRE Red Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE _T("Pal-m Composite CB Luma IRE Blue Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK _T("Pal-m Composite CB Luma IRE Balck Bar")
// PAL-M Composite Color Bar for Chroma IRE:
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE _T("Pal-m Composite CB Chroma IRE White Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW _T("Pal-m Composite CB Chroma IRE Yellow Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN _T("Pal-m Composite CB Chroma IRE Cyan Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN _T("Pal-m Composite CB Chroma IRE Green Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Pal-m Composite CB Chroma IRE Magenta Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED _T("Pal-m Composite CB Chroma IRE Red Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE _T("Pal-m Composite CB Chroma IRE Blue Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK _T("Pal-m Composite CB Chroma IRE Balck Bar")
// PAL-M Composite Color Bar for Chroma Phase
//#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_WHITE _T("Pal-bdghi Composite CB Chroma Phase White Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Pal-m Composite CB Chroma Phase Yellow Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN _T("Pal-m Composite CB Chroma Phase Cyan Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN _T("Pal-m Composite CB Chroma Phase Green Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Pal-m Composite CB Chroma Phase Magenta Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED _T("Pal-m Composite CB Chroma Phase Red Bar")
#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE _T("Pal-m Composite CB Chroma Phase Blue Bar")
//#define PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLACK _T("Pal-bdghi Composite CB Chroma Phase Balck Bar")


//PAL-M Svideo Color Bar for Luma IRE:
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE _T("Pal-m Svideo CB Luma IRE White Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW _T("Pal-m Svideo CB Luma IRE Yellow Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN _T("Pal-m Svideo CB Luma IRE Cyan Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN _T("Pal-m Svideo CB Luma IRE Green Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA _T("Pal-m Svideo CB Luma IRE Magenta Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_RED _T("Pal-m Svideo CB Luma IRE Red Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE _T("Pal-m Svideo CB Luma IRE Blue Bar")
#define PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK _T("Pal-m Svideo CB Luma IRE Balck Bar")
// PAL-M Svideo Color Bar for Chroma IRE:
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE _T("Pal-m Svideo CB Chroma IRE White Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW _T("Pal-m Svideo CB Chroma IRE Yellow Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN _T("Pal-m Svideo CB Chroma IRE Cyan Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN _T("Pal-m Svideo CB Chroma IRE Green Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA _T("Pal-m Svideo CB Chroma IRE Magenta Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_RED _T("Pal-m Svideo CB Chroma IRE Red Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE _T("Pal-m Svideo CB Chroma IRE Blue Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK _T("Pal-m Svideo CB Chroma IRE Balck Bar")
// PAL-M Svideo Color Bar for Chroma Phase
//#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_WHITE _T("Pal-bdghi Composite CB Chroma Phase White Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW _T("Pal-m Svideo CB Chroma Phase Yellow Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN _T("Pal-m Svideo CB Chroma Phase Cyan Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN _T("Pal-m Svideo CB Chroma Phase Green Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA _T("Pal-m Svideo CB Chroma Phase Magenta Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED _T("Pal-m Svideo CB Chroma Phase Red Bar")
#define PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE _T("Pal-m Svideo CB Chroma Phase Blue Bar")
//#define PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLACK _T("Pal-bdghi Composite CB Chroma Phase Balck Bar")


//PAL-M Composite Multiburst
#define PAL_M_COMPOSITE_MULTIBURST_FREQUEN_PACKET1 _T("pal-m Composite Multiburst Frequency Packet #1")
#define PAL_M_COMPOSITE_MULTIBURST_FREQUEN_PACKET2 _T("pal-m Composite Multiburst Frequency Packet #2")
#define PAL_M_COMPOSITE_MULTIBURST_FREQUEN_PACKET3 _T("pal-m Composite Multiburst Frequency Packet #3")
#define PAL_M_COMPOSITE_MULTIBURST_FREQUEN_PACKET4 _T("pal-m Composite Multiburst Frequency Packet #4")
#define PAL_M_COMPOSITE_MULTIBURST_FREQUEN_PACKET5 _T("pal-m Composite Multiburst Frequency Packet #5")
#define PAL_M_COMPOSITE_MULTIBURST_FREQUEN_PACKET6 _T("pal-m Composite Multiburst Frequency Packet #6")


//PAL-M Svideo Multiburst
#define PAL_M_SVIDEO_MULTIBURST_FREQUEN_PACKET1 _T("pal-m Svideo Multiburst Frequency Packet #1")
#define PAL_M_SVIDEO_MULTIBURST_FREQUEN_PACKET2 _T("pal-m Svideo Multiburst Frequency Packet #2")
#define PAL_M_SVIDEO_MULTIBURST_FREQUEN_PACKET3 _T("pal-m Svideo Multiburst Frequency Packet #3")
#define PAL_M_SVIDEO_MULTIBURST_FREQUEN_PACKET4 _T("pal-m Svideo Multiburst Frequency Packet #4")
#define PAL_M_SVIDEO_MULTIBURST_FREQUEN_PACKET5 _T("pal-m Svideo Multiburst Frequency Packet #5")
#define PAL_M_SVIDEO_MULTIBURST_FREQUEN_PACKET6 _T("pal-m Svideo Multiburst Frequency Packet #6")


// SMC temperature stats
#define CPU_JUNCTION_TEMP _T("CPU Junction Temp")
#define INTERNAL_AIR_TEMP _T("Internal Air Temp")

// Chipset revision stats
#define GPU_REVISION _T("GPU Revision")
#define MCP_REVISION _T("MCP Revision")

#define DVD_FIRMWARE_REVISION _T("DVD Firmware Revision")
#define HD_TEST_TIME _T("Hard Drive test time (seconds)")
#define BOOT_COUNT _T("Boot Count")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B21EBCD4_880D_11D4_A058_00A0C9170060__INCLUDED_)
#define AFX_STDAFX_H__B21EBCD4_880D_11D4_A058_00A0C9170060__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// The following line is needed to include winsock2.h
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0401
#endif

#ifndef wcsicmp
#define wcsicmp _wcsicmp
#endif

#ifndef stricmp
#define stricmp _stricmp
#endif

#if defined( _XBOX )
#include <xtl.h>
#else
#define _WINSOCKAPI_  // prevent default of linking with winsock (we need winsock 2)
#include <windows.h>
#endif
#include <new.h>
#include <tchar.h>
#include <stdio.h>
#include <errno.h>
#include <process.h>
#include <eh.h>
#include <time.h>
#include <malloc.h>

#ifdef _DEBUG
#define ASSERT(f) {if (!(f)) _asm { int 3 }}
#define ASSERT_HERE {_asm { int 3 }}
#define VERIFY(f) ASSERT(f)
#else
#define ASSERT(f) ((void)0)
#define ASSERT_HERE ((void)0)
#define VERIFY(f) ((void)f)
#endif

//#define INVALID_HANDLE ((HANDLE) 0xffffffff)
#define INVALID_HANDLE INVALID_HANDLE_VALUE

#pragma warning (disable:4710) // We don't care if inline suceeds

#include "timer.h"
#include "numbers.h"
#include "mid.h"
#include "xmta.h"
#include "store.h"
#include "host.h"
#include "tree.h"
#include "factory.h"
#include "except.h"
#include "error.h"
#include "event.h"
#include "dispatch.h"
#include "parser.h"
#include "command.h"
#include "loops.h"
#include "parameter.h"
#include "testobj.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B21EBCD4_880D_11D4_A058_00A0C9170060__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\store.cpp ===
// store.cpp

#include "stdafx.h"

CStore::CStore (int size)
{
	m_next = m_buffer = new BYTE [size];
	m_size = size;
	m_delete = true;
}

CStore::CStore (LPCBYTE buffer, int size)
{
	m_next = m_buffer = const_cast<LPBYTE> (buffer);
	m_size = size;
	m_delete = false;
}
	
void CStore::Put (const void* bp, int ln) 
{
	if ((m_buffer + m_size) < (m_next + ln))
		throw m_size;

//	ASSERT (!m_delete);
	memcpy (m_next, bp, ln);
	m_next += ln;
}

void CStore::Get (void *bp, int ln)
{
	if ((m_buffer + m_size) < (m_next + ln))
		throw m_size;

	memcpy (bp, m_next, ln);
	m_next += ln;
}

LPCTSTR CStore::GetStringPtr (void)
{
	LPCTSTR str = (LPCTSTR) m_next;
	while (m_next < (m_buffer + m_size))
	{
		_TCHAR current = *(_TCHAR*)m_next;
		m_next += sizeof (_TCHAR);
		if (current == 0)
			return str;
	}
	throw m_size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\store.h ===
// store.h

typedef const unsigned char * LPCBYTE;

class CStore
{
	LPBYTE m_buffer;
	LPBYTE m_next;
	int m_size;
	bool m_delete;

	void Put (const void* bp, int ln); 
	void Get (void *bp, int ln);
	LPCTSTR GetStringPtr (void);

public:
	CStore (int size); // create buffer of size
	CStore (LPCBYTE buffer, int size); // marshall existing buffer
	virtual ~CStore () {if (m_delete) delete m_buffer;}

	LPBYTE GetBuffer () {return m_buffer;}
	int GetLength () {return m_next - m_buffer;}

	// insertion
	CStore& operator<<(BYTE by) {Put (&by, sizeof(BYTE)); return *this;}
	CStore& operator<<(WORD w) {Put (&w, sizeof(WORD)); return *this;}
	CStore& operator<<(LONG l) {Put (&l, sizeof(LONG)); return *this;}
	CStore& operator<<(DWORD dw) {Put (&dw, sizeof(DWORD)); return *this;}
	CStore& operator<<(float f) {Put (&f, sizeof(float)); return *this;}
	CStore& operator<<(double d) {Put (&d, sizeof(double)); return *this;}
	CStore& operator<<(int i) {Put (&i, sizeof(int)); return *this;}
	CStore& operator<<(short w) {Put (&w, sizeof(short)); return *this;}
	CStore& operator<<(char ch) {Put (&ch, sizeof(char)); return *this;}
	CStore& operator<<(unsigned u) {Put (&u, sizeof(unsigned)); return *this;}
	CStore& operator<<(LPCTSTR& s) 
		{Put (s, (_tcslen(s) + 1)*sizeof(_TCHAR)); return *this;}

	// extraction
	CStore& operator>>(BYTE& by) {Get (&by, sizeof(BYTE)); return *this;}
	CStore& operator>>(WORD& w) {Get (&w, sizeof(WORD)); return *this;}
	CStore& operator>>(DWORD& dw) {Get (&dw, sizeof(DWORD)); return *this;}
	CStore& operator>>(LONG& l) {Get (&l, sizeof(LONG)); return *this;}
	CStore& operator>>(float& f) {Get (&f, sizeof(float)); return *this;}
	CStore& operator>>(double& d) {Get (&d, sizeof(double)); return *this;}
	CStore& operator>>(int& i) {Get (&i, sizeof(int)); return *this;}
	CStore& operator>>(short& w) {Get (&w, sizeof(short)); return *this;}
	CStore& operator>>(char& ch) {Get (&ch, sizeof(char)); return *this;}
	CStore& operator>>(unsigned& u) {Get (&u, sizeof(unsigned)); return *this;}

	// Use this version if you want the data copied to your own buffer
	// this actually shouldn't be allowed because there is no way 
	// to detect or prevent buffer overruns.
	CStore& operator>>(LPTSTR& s) 
		{Get ((void*)s, (_tcslen(s) + 1)*sizeof(_TCHAR)); return *this;}

	// Use this version if you just want a pointer to the data
	CStore& operator>>(LPCTSTR* s) {*s = GetStringPtr (); return *this;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\sendhost.cpp ===
// File that contains XMTA Host communication routines via TCP/IP

/*

OVERVIEW
--------
All communications between the UUT and the host are initiated by the UUT.  Some messages
from the UUT to the host do not require a response (ex., status messages).  Other messages
from the UUT to the host do require a response (ex. a message that requests that the
host capture an audio buffer from an audio card installed in the host and return the results
to the UUT).  This application demonstrates a simple protocol that allows communication
between the UUT and the host.  This implementation uses TCP/IP through Windows sockets.  A
UUT opens a single socket connection with the host when the test suite first initializes, and
uses the single socket for communication until the test suite completes.  The UUT can not
re-open a socket to the host once it is closed: if a socket closes in the middle of the test
suite (typically only happens if the host crashes, the network crashes, or the UUT crashes)
then the test suite must be restarted with a new socket.  In some situations, a host
may communicate with more than one UUT at a time (like in a run-in systems test envirnment);
in this situation, each socket connection represents a different UUT.

FUNCTION IMPLEMENTATION
-----------------------
For XBox test applications, a single socket is opened by the main() routine before any test
routines are executed.  Communication with the host is accomplished through a single function
call:

int iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength, CHostResponse& CHR, DWORD *pdwBytesReceivedFromHost, DWORD *pdwErrorCodeFromHost, DWORD dwTimeout)

(in)  DWORD dwMID - the Message ID of the message being sent to the host
(in)  char *pcBufferToHost - pointer to a buffer containing the data/message to send to the host
(in)  DWORD dwBufferToHostLength - the number of bytes in the pcBufferToHost to send to the host
(in/out) CHostResponse& CHR - reference to a CHostResponse structure that contains the pointer to the host response buffer
(out) DWORD *pdwBytesReceivedFromHost - the number of bytes actually returned in the buffer from the host
(out) DWORD *pdwErrorCodeFromHost - the partial error code returned from the host (0 is there was no error)
(in)  DWORD dwTimeout - the maximum number of seconds that the calling routine is willing to wait for a response from the host

returns: EVERYTHINGS_OK if the communication was successful
         some other error if communication was not successful

The iSendHost routine allocates a response buffer for messages that need a response from
the host.  In order to prevent memory leaks, the CHostResponse class is used to manage the
pointer to the response buffer.  A test that calls iSendHost and expects a response simply
needs to create a local instance of CHostResponse and pass it to iSendHost.  When the local
CHostResponse instance passes out of scope, the response buffer associated with it will be
deleted automatically.  If you decide to assign the response buffer pointer to another local
pointer to analyze the response data form the host
(for example, pMyStruct = (PMY_STRUCT)CHR.pvBufferFromHost), be sure to only make the
assignment AFTER the call to iSendHost, and be sure to only access the response buffer
when the CHostResponse instance is in scope.  Declaring the CHostResponse instance at
the top of the test can eliminate scope worries (it won't go out of scope until the test
exits).  The following code is an example of good usage of iSendHost.

An example of how a test can implement a call to iSendHost that requires a response
IMPLEMENT_TESTUNLOCKED (AUDIO, external_analog_loopback, 5)
{
	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD dwMID, dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost;
	DWORD dwTimeout = 3000; // 5 minute timeout
	int iError;

	.
	.
	.
	// Set up the send buffer (send_buf) here as well as dwMID and dwBufferToHostLength

	
	if ((iError = g_host.iSendHost(dwMID, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, dwTimeout)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
		}
		else
		{
			// Process a communication error
		}
	}

	else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
	{
		// The response buffer is NULL, so take appropriate action (like an error message)
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		// Analyze the response data from the host
	}

	.
	.
	.
}

For messages where no response is needed, such as general Status messages or keep-alive
messages, etc.  The following version of iSendHost can be used instead:

int iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength)

The parameters are the same as those in the long version of the iSendHost function.

Other functions can be written to wrap this function and make it easier to use for specific
message types.  For example, a routine could wrap up a Status message type so that tests
can send status messages using a much simpler function interface.

TCP/IP DATA PACKET FORMAT
-------------------------
The actual format that the socket communication routines use for data transmissions is rather
simple.  For UUT-to-host messages, the format is as follows:

Offset  0:  4 bytes - Total Length of Message
Offset  4:  4 bytes - Unique message number for this socket
Offset  8:  4 bytes - Message ID (MID) that indicates what type of message this is
Offset 12:  4 bytes - DWORD checksum of the above 3 DWORDs; this helps ensure the integrity of the header
Offset 16:  X bytes - Data (the actual message contents)

Total Length of Message is the length of the entire message, including itself.
This item is needed to inform the host exactly how big the message is.  Because TCP/IP is a
stream-based protocol instead of a message-based protocol, this length parameter is vital to
inform the host how big each message is (which then allows the host to determine where each message
starts and stops).

Unique message number for this socket is an identifier that is created by the sending
routines on the UUT that is unique for that message on that socket connection.  This
identifier is passed back from the host in the response message so that the UUT knows
which message to the host pairs up with which response from the host.

Message ID is the unique ID assigned to this message type.  Each message type whithin a
test architecture has a unique message ID, so that the host can determine what DLL,
service, or utility on the host can process the message.  Currently, message IDs are registered
in the MID.H file in the UHC 2000 project in SourceSafe. 

Data is the actual message that is sent to the host.  The Data blob will itself have a format that
tells the DLL, service, or utility on the host that processes the message what to do.
The format of the data blob, though, is of no significance to the communication routines
on the UUT and host; only the supporting routines and utilities that actually process
the contents of the data blob need to know its structure.

For Host-to-UUT messages, the format is as follows:

Offset  0:  4 bytes - Total Length of Message
Offset  4:  4 bytes - Unique message number for this socket
Offset  8:  4 bytes - Returned Error Code from Host
Offset 12:  X bytes - Data (the actual message contents)

Total Length of Message is the length of the entire message, including itself.
This item is needed to inform the UUT exactly how big the message is.  Because TCP/IP is a
stream-based protocol instead of a message-based protocol, this length parameter is vital to
inform the UUT how big each message is (which then allows the UUT to determine where each message
starts and stops).

Unique message number for this socket is an identifier that is created by the sending
routines on the UUT that is unique for that message on that socket connection.  This
identifier is passed back from the host in the response message so that the UUT knows
which message to the host pairs up with which response from the host.

Returned Error Code from Host is a partial error code (only values 0, and 0xF00 through 0xFFF
are allowed to be returned) that indicates what error happened on the host.  If this value
is zero, then no error happened and the Data buffer contains valid returned data.  If this
value is non-zero, then this value can be combined with the module number and test number
by the test that receives this response to form a complete error code; the data buffer
contains a unicode error message that describes the nature of the error (which can be
displayed in an error reporting routine by the calling test, if desired).  Please note
that the returned error codes are not unique across a test architecture.  For example, many
host utilities may use the error code 0xF30 to represent different errors, but the error
code is unique within a single utility.

Data is the actual response message that is sent to the UUT.  The Data blob will itself
have a format that provides the UUT with useful response information.  The format of the
data blob, though, is of no significance to the communication routines on the UUT and
host; only the supporting routines that actually process the contents of the data blob
need to know its structure.

*/

#include "stdafx.h"
#include "host.h"

// NTSTATUS
typedef LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#define NTHALAPI     DECLSPEC_IMPORT

// SMBus functions.
extern "C"
{
NTHALAPI
NTSTATUS
NTAPI
HalReadSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN ReadWordValue,
	OUT ULONG *DataValue
	);

NTHALAPI
NTSTATUS 
NTAPI
HalWriteSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN WriteWordValue,
	IN ULONG DataValue
	);
}
#if !defined( STAND_ALONE_MODE )
int CHost::iSendToHost(SOCKET sock, char *pcAppDataToSend, int iAppDataToSendLength)
{
	int iNumLeft = 0, iSendIndex = 0, iNumSent;

	iNumLeft = iAppDataToSendLength;
	iSendIndex = 0;
	while (iNumLeft > 0)
	{
		iNumSent = send(sock, &pcAppDataToSend[iSendIndex], iNumLeft, 0);

		if (iNumSent == SOCKET_ERROR)
		{
//			printf("Could not send data to the port\n");
			return (COULD_NOT_SEND_DATA_TO_PORT);
		}
		iNumLeft = iNumLeft - iNumSent;
		iSendIndex = iSendIndex + iNumSent;
	}

	return (EVERYTHINGS_OK);
}

// This routine spin-waits for a reception of data.  If the data is not received by the specified time, then
// the routine will return with a TIMEOUT failure.  Because this spin-waits, it should only be used
// for initialization, not for regular communication.
int CHost::iReceive(SOCKET sock, char *pcReceiveBuffer, DWORD dwSizeOfReceiveBuffer, DWORD *pdwActualSize, double local_timeout_value, LARGE_INTEGER *pliLocalTimeout)
{
	DWORD dwNumSentToHere = 4;
	int iNumLeft, iReceiveIndex;
	DWORD dwNumReceivedThisTime, dwFlags;
	int iStatus = EVERYTHINGS_OK;
	WSABUF DataBuf;
	WSAOVERLAPPED wsaRecvOverlapped;
	int iReceiveResult;
	int iError, iWTemp = 0;
	WSAEVENT WSAEvent = WSA_INVALID_EVENT;

	iNumLeft = sizeof(DWORD);
	iReceiveIndex = 0;
	if ((WSAEvent = WSACreateEvent()) == WSA_INVALID_EVENT)
		return (COULD_NOT_CREATE_SOCKET_EVENT);
	while ((iNumLeft > 0) && (!TimedOut(local_timeout_value, pliLocalTimeout))) // Receive the DWORD message length indicator
	{
		DataBuf.len = iNumLeft;
		DataBuf.buf = ((char *)&dwNumSentToHere) + iReceiveIndex;
		dwFlags = 0;
		wsaRecvOverlapped.hEvent = WSAEvent;
		if (!WSAResetEvent(WSAEvent))
		{
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RESET_SOCKET_EVENT);
		}
		iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
//		iNumReceivedThisTime = recv(sock, ((char *)&dwNumSentToHere) + iReceiveIndex, iNumLeft, 0);
		if (iReceiveResult == 0)
		{
			if (dwNumReceivedThisTime == 0)
			{
//				printf("Connection closed by client\n");
				WSACloseEvent(WSAEvent);
				return (CONNECTION_CLOSED);
			}
		}
		else if (iReceiveResult == SOCKET_ERROR)
		{
			if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
			{
				while ((!WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags)) && (!TimedOut(local_timeout_value, pliLocalTimeout)))
				{
					iError = WSAGetLastError();
					if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
					{
/*
						switch (iError)
						{
							case WSANOTINITIALISED:
								printf("The socket wan't initialized\n");
								break;
							case WSAENETDOWN:
								printf("The network is down!\n");
								break;
							case WSAENOTSOCK:
								printf("This is not a valid socket\n");
								break;
							case WSA_INVALID_HANDLE:
								printf("The event handle is bad\n");
								break;
							case WSA_INVALID_PARAMETER:
								printf("One or more of the parameters is bad\n");
								break;
							case WSA_IO_INCOMPLETE:
								printf("This isn't a real failure, the transfer just isn't complete yet\n");
								break;
							case WSAEFAULT:
								printf("A parameter fault has happened\n");
								break;
							case WSA_IO_PENDING:
								printf("I/O operation is in progress\n");
								break;
							default:
								printf("Unknown error, %8.8lx\n", (DWORD)iError);
						}
*/
//						printf("Could not receive data from the client inside overlapped result routine size\n");
						WSACloseEvent(WSAEvent);
						return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
					}
				}
			}
			else
			{
//				printf("Could not receive data from the client\n");
				WSACloseEvent(WSAEvent);
				return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
			}
		}
		else // Some other bad error happened, so abort
		{
//			printf("Could not receive data from the client\n");
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
		}
		iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
		iReceiveIndex = iReceiveIndex + dwNumReceivedThisTime;
	}
	// Don't need an extra timeout check here because it will happen below the next while() loop
	if (dwNumSentToHere - 4 > dwSizeOfReceiveBuffer)
	{
		dwNumSentToHere = dwSizeOfReceiveBuffer + 4; // Do this so we don't overflow the receive buffer
//		printf("Receive buffer overrun\n");
		iStatus = RECEIVE_BUFFER_OVERRUN; // Don't return yet; actually try to receive the data
	}

	
	
	// Now receive the actual message
	iNumLeft = (int)(dwNumSentToHere-4);
	*pdwActualSize = 0; // Indicate that 0 bytes have been received so far
	while ((iNumLeft > 0) && (!TimedOut(local_timeout_value, pliLocalTimeout))) // Receive the DWORD message length indicator
	{
		DataBuf.len = iNumLeft;
		DataBuf.buf = &pcReceiveBuffer[*pdwActualSize];
		dwFlags = 0;
		wsaRecvOverlapped.hEvent = WSAEvent;
		if (!WSAResetEvent(WSAEvent))
		{
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RESET_SOCKET_EVENT);
		}
		iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
//		iNumReceivedThisTime = recv(sock, &pcReceiveBuffer[*pdwActualSize], iNumLeft, 0);
		if (iReceiveResult == 0)
		{
			if (dwNumReceivedThisTime == 0)
			{
//				printf("Connection closed by client\n");
				WSACloseEvent(WSAEvent);
				return (CONNECTION_CLOSED);
			}
		}
		else if (iReceiveResult == SOCKET_ERROR)
		{
			if (WSAGetLastError() == WSA_IO_PENDING) // The reception is pending, so wait for it
			{
				while ((!WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags)) && (!TimedOut(local_timeout_value, pliLocalTimeout)))
				{
					iError = WSAGetLastError();
					if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
					{
//						printf("Could not receive data from the client inside overlapped result routine data\n");
						WSACloseEvent(WSAEvent);
						return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
					}
				}
			}
			else
			{
//				printf("Could not receive data from the client\n");
				WSACloseEvent(WSAEvent);
				return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
			}
		}
		else // Some other bad error happened, so abort
		{
//			printf("Could not receive data from the client\n");
			WSACloseEvent(WSAEvent);
			return (COULD_NOT_RECEIVE_DATA_FROM_PORT);
		}

		iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
		*pdwActualSize = *pdwActualSize + dwNumReceivedThisTime;
	}
	if (TimedOut(local_timeout_value, pliLocalTimeout))
	{
//		printf("Timed out waiting to receive data from the host\n");
		WSACloseEvent(WSAEvent);
		return (RECEIVE_TIMEOUT);
	}

	WSACloseEvent(WSAEvent);
	return (iStatus);
}



// Try to establish a connection with the host for up to dblTimeout seconds.  The
// returned socket is to be used for all future communication with the host.
int CHost::iInitHostCommunication(char *strHostName, LPCTSTR strSerialNumber, double dblTimeout, SOCKET *psock)
{
	UNREFERENCED_PARAMETER(dblTimeout);
	#define SOCKET_VERSION_TO_USE                0x0202
#ifdef RNR_MODE
	#define FIRST_SOCKET_PORT_TO_TRY             2001
#else
	#define FIRST_SOCKET_PORT_TO_TRY             2000
#endif
	#define LOCAL_TIMEOUT_VALUE                  50.0 // This is the max number of seconds the send/receive handshake should take
	#define MAX_RANDOM_RETRY_DELAY               3 // This is the max number of seconds to delay between socket connection retries
	#define DEFAULT_HOST_ADDRESS                 0x01018e8e 

	WSADATA wsaData;
//	HOSTENT *phent = NULL;
	struct sockaddr_in tcpaddr;
	int port = FIRST_SOCKET_PORT_TO_TRY;
	DWORD dwReceivedBufferSize;
	const DWORD MSG_HEADER_SIZE = 16;
	DWORD dwConnectSendBuffer[30], dwConnectReceiveBuffer[3];
//	LARGE_INTEGER liGlobalTimeout;
	LARGE_INTEGER liLocalTimeout;
//	int iTimedOut;
	int iStatus = EVERYTHINGS_OK;
	DWORD dwSleepTime;
	unsigned long ulReceiveFromHostThread;
	int iRT1 = 0, iS1 = 0;
//	char cHostName[100];
//	unsigned long ulMyAddr;
	DWORD dwMaxRetryDelay = MAX_RANDOM_RETRY_DELAY;
#if defined(_XBOX)
UNREFERENCED_PARAMETER(strHostName);

	// DWORD dwProtocolBufferSize;
	// LPWSAPROTOCOL_INFO pWSAProtocolInfoBuffer = NULL;
	// int iNumProtocolBuffers = 0;
	
	int XNetStartupError;

	XNetStartupParams xnsp;
	XNADDR xnaddr;

	memset(&xnsp, 0, sizeof(xnsp));
	xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
	xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	if ((XNetStartupError = XNetStartup(&xnsp)) != NO_ERROR)
	{
		return (COULD_NOT_LOAD_SOCKET_LIBRARY);
	}
	memset(&xnaddr, 0, sizeof(xnaddr));
	xnaddr.bSizeOfStruct = sizeof(XNADDR);
	// Wait for the IP address to be assigned
	while ((XNetGetTitleXnAddr(&xnaddr) & (XNET_GET_XNADDR_DHCP | XNET_GET_XNADDR_GATEWAY)) == 0)
		Sleep(50);
/*
	int iSocketInit;
	if ((iSocketInit = XnetInitialize(NULL, TRUE)) != NO_ERROR)
	{
		return (COULD_NOT_LOAD_SOCKET_LIBRARY);
	}
*/
#endif

 	if (WSAStartup(SOCKET_VERSION_TO_USE, &wsaData) != 0)
	{
		// Could not find a usable WinSock DLL.
//		printf("Could not use at least socket version %x\n", SOCKET_VERSION_TO_USE);
		return (SOCKET_VERSION_NOT_SUPPORTED);
	}
 
	// Confirm that the WinSock DLL supports 2.2.  Note that if the DLL supports
	// versions greater than 2.2 in addition to 2.2, it will still return
	// 2.2 in wVersion since that is the version we requested
 	if ( wsaData.wVersion != SOCKET_VERSION_TO_USE)
	{
		// Tell the user that we could not find a usable WinSock DLL.
//		printf("Could not use at least socket version %x\n", SOCKET_VERSION_TO_USE);
		return (SOCKET_VERSION_NOT_SUPPORTED);
	}
#if defined(_XBOX)
	// The routine below will find the server address and restrict it to one of the following values:
	// unsigned long ulHostAddresses[] = {0x01018e8e, 0x01108e8e, 0x01208e8e, 0x01308e8e, 0x01408e8e, 0x01508e8e};
	DWORD dwMyAddress = (DWORD)xnaddr.ina.S_un.S_addr;
	if ((dwMyAddress & 0x0000FFFF) != 0x00008e8e) // Make sure it is 142.142.x.x
		ulHost = DEFAULT_HOST_ADDRESS;
	else
	{
		if ((dwMyAddress & 0x00F00000) > 0x00500000) // 142.142.80 through 95.x is the highest address allowed
			ulHost = DEFAULT_HOST_ADDRESS;
		else
		{
			ulHost = (dwMyAddress & 0x00F0FFFF) | 0x01000000; // Form the address of the host
			if ((dwMyAddress & 0x00F00000) == 0x00000000) // 142.142.1 through 15.x has a host address of 142.142.1.0 (not 142.142.0.0)
				ulHost = ulHost | 0x00010000;
		}
	}
#else
	// Lets try looking up the host IP address using the host name
	//
	HOSTENT *phent = gethostbyname(strHostName);
	if (phent)
	{
		ulHost = *(unsigned long *)(phent->h_addr_list[0]);
	}
#endif 
	// The WinSock DLL is acceptable. Proceed.

	SeedRand(0);  // Seed the random number function here because we may need it to generate a random delay below

	// Now we know what the host IP address is, and we are connected
	// Try to handshake with the host
	for (;;)
	{
		for (;;) // Connect a socket again
		{
			if ((*psock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) != INVALID_SOCKET)
			{
				tcpaddr.sin_family = AF_INET;
				tcpaddr.sin_port = htons((unsigned short)port);
				tcpaddr.sin_addr.s_addr = ulHost;
				// Connect to the destination port.  This could timeout for around 50 seconds if the host
				// is not on the network.  This is a long time, but not too problematic because the UUT won't
				// have much to do if it can't communicate with the host anyway.  If the host is on the network
				// but not listening, then this will timeout in just a couple of seconds.
				if (connect(*psock, (SOCKADDR *)&tcpaddr, sizeof(tcpaddr)) == 0)
				{
					break; // We connected, so we know that this is the host
				}
				else
				{
					iStatus = COULD_NOT_CONNECT_TO_SOCKET;
				}
				closesocket(*psock);
			}
			else
			{
				iStatus =  COULD_NOT_GET_SOCKET_HANDLE;
			}
		}

		// Build the connection request message
		// 
		if (strSerialNumber)
		{
			DWORD length = (_tcslen (strSerialNumber) + 1) * sizeof (_TCHAR);

			dwConnectSendBuffer[0] = MSG_HEADER_SIZE + length;
			dwConnectSendBuffer[1] = (DWORD)rand();
			dwConnectSendBuffer[2] = MID_CONNECT_BY_UNIQUE_ID;

			memcpy (&dwConnectSendBuffer[4], strSerialNumber, length);
		}
		else
		{
#ifdef RNR_MODE
			BYTE SerialNumber[13];
			ULONG Size, Type, Error;
			TCHAR tSerialNumber[13];

			Error = XQueryValue(0x100, &Type, SerialNumber, sizeof SerialNumber, &Size);
			if(Error != NO_ERROR)  // Set the serial number to all 9s
			{
				memset(SerialNumber, '9', sizeof SerialNumber);
			}
			SerialNumber[12] = 0;
			if (sizeof(TCHAR) == sizeof(wchar_t))
				_stprintf(tSerialNumber, _T("%S"), SerialNumber);
			else
				_stprintf(tSerialNumber, _T("%s"), SerialNumber);

			dwConnectSendBuffer[0] = MSG_HEADER_SIZE + ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR));
			dwConnectSendBuffer[1] = (DWORD)rand();
			dwConnectSendBuffer[2] = MID_CONNECT_BY_UNIQUE_ID;

			memcpy (&dwConnectSendBuffer[4], tSerialNumber, ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR)));
#else
			dwConnectSendBuffer[0] = MSG_HEADER_SIZE;
			dwConnectSendBuffer[1] = (DWORD)rand();
			dwConnectSendBuffer[2] = MID_CONNECT_BY_MAC_ADDRESS;
#endif
		}
		dwConnectSendBuffer[3] = dwConnectSendBuffer[0] + dwConnectSendBuffer[1] + dwConnectSendBuffer[2];

		iStatus = EVERYTHINGS_OK;
		StartTimer(&liLocalTimeout); // Get the starting time for the loop
		if ((iS1 = iSendToHost(*psock, (char *)dwConnectSendBuffer, dwConnectSendBuffer[0])) == EVERYTHINGS_OK)
		{
			dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
			if ((iRT1 = iReceive(*psock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
			{
				if (dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) // Received the ACK
				{
					dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
					if ((iRT1 = iReceive(*psock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
					{
						if ((dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) && (dwConnectReceiveBuffer[1] == 0)) // Received proper response
							break;
					}
					else
					{
						iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
					}
				}
				else
				{
					iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
				}
			}
			else
			{
				iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
			}
		}
		else
		{
			iStatus = COULD_NOT_SEND_CONNECT_HANDSHAKE;
		}
		// We did not get the correct handshake, so tear down the socket and start over
		closesocket(*psock);
		dwSleepTime = (DWORD)((((double)((unsigned int)rand()))/(double)RAND_MAX) * (double)(dwMaxRetryDelay-1) * (double)1000);
		dwSleepTime = dwSleepTime + 1000;
		Sleep(dwSleepTime); // Sleep a random amount of time
		if (dwMaxRetryDelay < 20)
			dwMaxRetryDelay += 2;
	}

	// We must have had a successful handshake.

	if (iStatus == EVERYTHINGS_OK)
	{
		// Do whatever global initialization required by vReceiveFromHostThread here
		InitializeCriticalSection(&HostResponseEntryListCriticalSection); // Initialize the critical section before it is used
		InitializeCriticalSection(&SendToHostCriticalSection);
		InitializeCriticalSection(&SocketAccessCriticalSection);
		// Create a manual-reset event.  Non-signaled to start with
		if ((hAckReceivedEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
			iStatus =  COULD_NOT_CREATE_ACK_EVENT;
		else
		{
			pHostResponsesPendingList = NULL;
			gdwLocalID = 1;
			g_dwLocalIDToAck = 0; // Zero is a reserved value indicating that no ACK is expected
			// Start the thread that receives results from the host
			ulReceiveFromHostThread = _beginthread(&vReceiveFromHostThreadEntry, 0, this);  // Start the thread; no parameters need to be passed here
			if (ulReceiveFromHostThread == -1) // Couldn't start the thread
				iStatus = COULD_NOT_START_RECEIVE_THREAD;
/*
// Starts a thread that blinks the LED green or orange once every second
			unsigned long ulAlivePrintThread = _beginthread(&vAlivePrintThreadEntry, 0, this);  // Start the thread; no parameters need to be passed here
			if (ulAlivePrintThread == -1) // Couldn't start the thread
				iStatus = COULD_NOT_START_RECEIVE_THREAD;
*/
		}
	}
	return (iStatus);
}


// This routine will perform communication with the host computer.  Any function can use this routine to
// pass a command to the host computer and receive a response.
int CHost::iSendHost(DWORD dwMID, char *pcBufferToHost, DWORD dwBufferToHostLength, CHostResponse& CHR, DWORD *pdwBytesReceivedFromHost, DWORD *pdwErrorCodeFromHost, DWORD dwTimeout)
{
	int iStatus = EVERYTHINGS_OK;
	DWORD dwNumToSend = 0, dwNumLeft = 0, dwSendIndex = 0, dwNumSent;
	char *pcSendBuffer = NULL;
	double dblTimeout = (double)dwTimeout;
	LARGE_INTEGER liTimeout;
	PHOST_RESPONSE_ENTRY pListTemp = NULL;
	DWORD dwLocalID;
	bool bExpectResponse;
	CTestObj *test = GET_TESTOBJ_PTR;


	while(bSocketRestarting)
		Sleep(1000);
	// Set up returned variables to a "no response" status initially
	if (CHR.pvBufferFromHost != NULL) // Make sure the response buffer is deleted if it had contained something
	{
		delete [] CHR.pvBufferFromHost;
		CHR.pvBufferFromHost = NULL;
	}
	if (pdwBytesReceivedFromHost != NULL)
		*pdwBytesReceivedFromHost = 0;
	if (pdwErrorCodeFromHost != NULL)
		*pdwErrorCodeFromHost = 0;

	// Determine whether a response is expected/possible to return to the caller or not.
	if ((pdwBytesReceivedFromHost == NULL) || (pdwErrorCodeFromHost == NULL) || ((dwMID & 0x40000000) == 0))
		bExpectResponse = false;
	else
		bExpectResponse = true;

	StartTimer(&liTimeout); // Start the timeout timer right away

	// This should be the only code that ever accesses gdwLocalID so that we can guarantee its uniqueness across multiple
	// threads.  Using HostResponseEntryListCriticalSection is cheating; this really should have its own critical section,
	// but it seems silly to create another global critical section just for this.
	// Copy gdwLocalID to a stack-based variable so that future accesses to the value from the stack-based variable
	// will return the correct value, even if other threads have incremented the global variable in the mean time
	EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list
	gdwLocalID ++; // Increment the message ID to make sure it is a new value
	dwLocalID = gdwLocalID;
	LeaveCriticalSection(&HostResponseEntryListCriticalSection);

	// Create the full message to send (total length, ID, message ID, data)
	if ((pcSendBuffer = new char[dwBufferToHostLength + 16]) == NULL) // Allocate a buffer to send the data
	{
//		printf("Send: Could not allocate memory for a send buffer\n");
		return (COULD_NOT_ALLOCATE_SEND_BUFFER);
	}
	dwNumToSend = dwBufferToHostLength + 16; // Add space to contain message size, ID, MID, and header checksum
	if (dwBufferToHostLength > 0)
		memcpy(pcSendBuffer + 16, pcBufferToHost, dwBufferToHostLength); // Copy the data into the send buffer
//	dwMID = dwMID | MID_NO_ACK_EXPECTED; // Disabling QQQACKs
	*((DWORD *)(&pcSendBuffer[0])) = dwNumToSend; // The length field includes the length of everything that is sent
	*((DWORD *)(&pcSendBuffer[4])) = dwLocalID; // The ID for this specific message to the host
	*((DWORD *)(&pcSendBuffer[8])) = dwMID; // The message ID of this message to the host
	*((DWORD *)(&pcSendBuffer[12])) = dwNumToSend + dwLocalID + dwMID; // Checksum of the header

	if (bExpectResponse) // There should be a response from the host, so add an entry into the HostResponsesPendingList
	{
		// Allocate a new list entry here
		if ((pListTemp = new HOST_RESPONSE_ENTRY) == NULL)
		{
			if (pcSendBuffer != NULL)
			{
				delete [] pcSendBuffer;
				pcSendBuffer = NULL;
			}
//			printf("Send: Could not allocate memory for a pending host response list entry\n");
			return (COULD_NOT_ALLOCATE_RESPONSE_LIST_ENTRY);
		}
		pListTemp->pcBufferFromHost = NULL;
		pListTemp->dwID = dwLocalID;
		pListTemp->dwActualBytesReceived = 0;
		pListTemp->iStatus = EVERYTHINGS_OK;
		pListTemp->dwReturnedErrorCode = 0;
		// Create an event and report an error if creation fails
		// Create an event for signaling when the response from the host has been captured
		// This handle cannot be inherited by a child process; Auto-reset the state to non-signaled Initial state is non-signaled
		if ((pListTemp->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
		{
			if (pcSendBuffer != NULL)
			{
				delete [] pcSendBuffer;
				pcSendBuffer = NULL;
			}
			if (pListTemp != NULL)
			{
				delete pListTemp;
				pListTemp = NULL;
			}
//			printf("Send: Could not create an event for signalling response reception from the host\n");
			return (COULD_NOT_CREATE_RESPONSE_EVENT);
		}
		
		EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list

		// Add the new list entry to the front of the list
		pListTemp->pNextEntry = pHostResponsesPendingList;
		pHostResponsesPendingList = pListTemp;

		LeaveCriticalSection(&HostResponseEntryListCriticalSection);
	}

	// Now that the response entry has been made, if applicable, send the message to the host
	dwNumLeft = dwNumToSend;
	dwSendIndex = 0;
	EnterCriticalSection(&SendToHostCriticalSection); // Make sure we send the whole message to the host without being interrupted by other threads' sends.
	g_dwLocalIDToAck = dwLocalID; // This is the Local ID to wait for an ACK
	ResetEvent(hAckReceivedEvent);
	while (dwNumLeft > 0) // Send the data
	{
		// Only allow a timeout if we haven't sent any data successfully yet.
		// Once we have started sending the message, we cannot stop until complete or
		// the communication with the host will go out of sync because TCP is a stream
		// protocol, not a message protocol.

//		do not check the timeout before sending
//		if (dwNumLeft == dwNumToSend)
//		{
//			if (TimedOut(dblTimeout, &liTimeout))
//				break;
			// Probably don't want to check for timeouts here because if a test aborts, we want
			// to be able to send any abort or error messages associated with the abort to the host
//			if (test != NULL)
//			{
//				if (test->CheckAbort(HERE))
//					break;
//			}
//		}
		// Since send() is blocking, we may be stuck here much longer than the specified timout
		// but that shouldn't matter too much because if we timeout due to a network problem
		// then we have nothing better to do then wait around because we can't communicate
		// our problem to the world anyway.
		EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
		dwNumSent = (DWORD)send(sock, &pcSendBuffer[dwSendIndex], (int)dwNumLeft, 0);
		LeaveCriticalSection(&SocketAccessCriticalSection);
		if (dwNumSent == SOCKET_ERROR)
		{
			int iE = WSAGetLastError();
			if (pcSendBuffer != NULL)
			{
				delete [] pcSendBuffer;
				pcSendBuffer = NULL;
			}
			LeaveCriticalSection(&SendToHostCriticalSection);
			vDeleteHostResponseListEntry(dwLocalID);
			g_dwLocalIDToAck = 0;
			if ((iE != WSAEINPROGRESS) && (iE != WSAENOBUFS))
			{
				SOCKET lsock = INVALID_SOCKET;
				struct sockaddr_in tcpaddr;
				int port = FIRST_SOCKET_PORT_TO_TRY;
				DWORD dwConnectSendBuffer[16], dwConnectReceiveBuffer[3];
				LARGE_INTEGER liLocalTimeout;
				int iRT1 = 0, iS1 = 0;
				DWORD MSG_HEADER_SIZE = 16;
				DWORD dwReceivedBufferSize;
				DWORD dwSleepTime;
				DWORD dwLocalMaxRetryDelay = MAX_RANDOM_RETRY_DELAY;

				bSocketRestarting = true;  // Block all other threads from accessing this routine
				Sleep(2000);  // Wait awhile for any threads to exit that might be in here
				// The socket is gone.  Reconnect and send an error at least
				shutdown (sock, SD_BOTH);
				closesocket(sock);
				sock = INVALID_SOCKET;

				// This is a bad socket error, so open a new socket to the host and complain
				for(;;) // Try to talk to the host again forever
				{
					WSADATA wsaData;

					dwSleepTime = (DWORD)((((double)((unsigned int)rand()))/(double)RAND_MAX) * (double)(dwLocalMaxRetryDelay-1) * (double)1000);
					dwSleepTime = dwSleepTime + 1000;
					Sleep(dwSleepTime); // Sleep a random amount of time
					if (dwLocalMaxRetryDelay < 10)
						dwLocalMaxRetryDelay += 2;
					if (lsock != INVALID_SOCKET)
						closesocket(lsock);
					lsock = INVALID_SOCKET;
					WSACleanup();
#ifdef _XBOX
					int XNetStartupError;
					XNetStartupParams xnsp;
					XNADDR xnaddr;
					DWORD dwWaitForIP;

					XNetCleanup();
					memset(&xnsp, 0, sizeof(xnsp));
					xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
					xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
					while ((XNetStartupError = XNetStartup(&xnsp)) != NO_ERROR)
					{
						Sleep(3000);
					}
					memset(&xnaddr, 0, sizeof(xnaddr));
					xnaddr.bSizeOfStruct = sizeof(XNADDR);
					// Wait for the IP address to be assigned
					dwWaitForIP = 80;
					while ((XNetGetTitleXnAddr(&xnaddr) & (XNET_GET_XNADDR_DHCP | XNET_GET_XNADDR_GATEWAY)) == 0)
					{
						dwWaitForIP--;
						if (dwWaitForIP == 0)
							break;
						Sleep(50);
					}
					if (dwWaitForIP == 0) // No address was issued
						continue;
#endif
					if (WSAStartup(SOCKET_VERSION_TO_USE, &wsaData) != 0)
					{
						// Could not find a usable WinSock DLL.
						continue;
					}
#ifdef _XBOX
					// The routine below will find the server address and restrict it to one of the following values:
					// unsigned long ulHostAddresses[] = {0x01018e8e, 0x01108e8e, 0x01208e8e, 0x01308e8e, 0x01408e8e, 0x01508e8e};
					DWORD dwMyAddress = (DWORD)xnaddr.ina.S_un.S_addr;
					if ((dwMyAddress & 0x0000FFFF) != 0x00008e8e) // Make sure it is 142.142.x.x
						ulHost = DEFAULT_HOST_ADDRESS;
					else
					{
						if ((dwMyAddress & 0x00F00000) > 0x00500000) // 142.142.80 through 95.x is the highest address allowed
							ulHost = DEFAULT_HOST_ADDRESS;
						else
						{
							ulHost = (dwMyAddress & 0x00F0FFFF) | 0x01000000; // Form the address of the host
							if ((dwMyAddress & 0x00F00000) == 0x00000000) // 142.142.1 through 15.x has a host address of 142.142.1.0 (not 142.142.0.0)
								ulHost = ulHost | 0x00010000;
						}
					}
#else
					// Lets try looking up the host IP address using the host name
					//
					HOSTENT *phent = gethostbyname(m_strHostName);
					if (phent)
					{
						ulHost = *(unsigned long *)(phent->h_addr_list[0]);
					}
#endif
					if ((lsock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) != INVALID_SOCKET)
					{
						tcpaddr.sin_family = AF_INET;
						tcpaddr.sin_port = htons((unsigned short)port);
						tcpaddr.sin_addr.s_addr = ulHost;
						// Connect to the destination port.  This could timeout for around 50 seconds if the host
						// is not on the network.  This is a long time, but not too problematic because the UUT won't
						// have much to do if it can't communicate with the host anyway.  If the host is on the network
						// but not listening, then this will timeout in just a couple of seconds.
						if (connect(lsock, (SOCKADDR *)&tcpaddr, sizeof(tcpaddr)) == 0)
						{
							// Build the connection request message
							// 
#ifdef RNR_MODE
							BYTE SerialNumber[13];
							ULONG Size, Type, Error;
							TCHAR tSerialNumber[13];

							Error = XQueryValue(0x100, &Type, SerialNumber, sizeof SerialNumber, &Size);
							if(Error != NO_ERROR)  // Set the serial number to all 9s
							{
								memset(SerialNumber, '9', sizeof SerialNumber);
							}
							SerialNumber[12] = 0;
							if (sizeof(TCHAR) == sizeof(wchar_t))
								_stprintf(tSerialNumber, _T("%S"), SerialNumber);
							else
								_stprintf(tSerialNumber, _T("%s"), SerialNumber);

							dwConnectSendBuffer[0] = MSG_HEADER_SIZE + ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR));
							dwConnectSendBuffer[1] = (DWORD)rand();
							dwConnectSendBuffer[2] = MID_CONNECT_BY_UNIQUE_ID;

							memcpy (&dwConnectSendBuffer[4], tSerialNumber, ((_tcslen(tSerialNumber) + 1) * sizeof(TCHAR)));
#else
							dwConnectSendBuffer[0] = MSG_HEADER_SIZE;
							dwConnectSendBuffer[1] = (DWORD)rand();
							dwConnectSendBuffer[2] = MID_CONNECT_BY_MAC_ADDRESS;
#endif
							dwConnectSendBuffer[3] = dwConnectSendBuffer[0] + dwConnectSendBuffer[1] + dwConnectSendBuffer[2];

							iStatus = EVERYTHINGS_OK;
							StartTimer(&liLocalTimeout); // Get the starting time for the loop
							if ((iS1 = iSendToHost(lsock, (char *)dwConnectSendBuffer, dwConnectSendBuffer[0])) == EVERYTHINGS_OK)
							{
								dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
								if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
								{
									if (dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) // Received the ACK
									{
										dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
										if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
										{
											if ((dwConnectReceiveBuffer[0] == dwConnectSendBuffer[1]) && (dwConnectReceiveBuffer[1] == 0)) // Received proper response
											{
												// We have connected and had a handshake.  Now send an error message
												TCHAR SendPrivateError[100];
												int iCurrent;
												CHostResponse CHRTemp;
												DWORD *pdwSendPrivateError = (DWORD *)SendPrivateError;
												
												pdwSendPrivateError[1] = (DWORD)rand();
												pdwSendPrivateError[2] = MID_UUT_ERROR;

												iCurrent = 16/sizeof(TCHAR);
												_stprintf(&SendPrivateError[iCurrent], _T("%s"), _T("SendHost.Main"));
												iCurrent += _tcslen(&SendPrivateError[iCurrent]) + 1;
												*((DWORD *)&SendPrivateError[iCurrent]) = 0x2E; // Socket dropped error code
												iCurrent += (4/sizeof(TCHAR));
												_stprintf(&SendPrivateError[iCurrent], _T("%s"), _T("The socket connection to the host was dropped"));
												iCurrent += _tcslen(&SendPrivateError[iCurrent]) + 1;

												pdwSendPrivateError[0] = iCurrent*sizeof(TCHAR);
												pdwSendPrivateError[3] = pdwSendPrivateError[0] + pdwSendPrivateError[1] + pdwSendPrivateError[2];

												iStatus = EVERYTHINGS_OK;
												StartTimer(&liLocalTimeout); // Get the starting time for the loop
												if ((iS1 = iSendToHost(lsock, (char *)pdwSendPrivateError, pdwSendPrivateError[0])) == EVERYTHINGS_OK)
												{
													dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
													if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
													{
														if (dwConnectReceiveBuffer[0] == pdwSendPrivateError[1]) // Received the ACK
														{
															// Error message sent correctly, now send a testing ended message
															pdwSendPrivateError[0] = 16;
															pdwSendPrivateError[1] = (DWORD)rand();
															pdwSendPrivateError[2] = MID_UUT_ENDING;
															pdwSendPrivateError[3] = pdwSendPrivateError[0] + pdwSendPrivateError[1] + pdwSendPrivateError[2];
															if ((iS1 = iSendToHost(lsock, (char *)pdwSendPrivateError, pdwSendPrivateError[0])) == EVERYTHINGS_OK)
															{
																dwConnectReceiveBuffer[0] = dwConnectReceiveBuffer[1] = 0xFF; // Just set the buffer to non-zero values so we know if it is completely filled by the response
																if ((iRT1 = iReceive(lsock, (char *)dwConnectReceiveBuffer, sizeof(dwConnectReceiveBuffer), &dwReceivedBufferSize, LOCAL_TIMEOUT_VALUE, &liLocalTimeout)) == EVERYTHINGS_OK)
																{
																	if (dwConnectReceiveBuffer[0] == pdwSendPrivateError[1]) // Received the ACK
																	{
																		// Testing Ended message sent correctly
																		break;
																	}
																	else
																	{
																		iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
																	}
																}
																else
																{
																	iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
																}
															}
														}
														else
														{
															iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
														}
													}
													else
													{
														iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
													}
												}
											}
										}
										else
										{
											iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
										}
									}
									else
									{
										iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
									}
								}
								else
								{
									iStatus = COULD_NOT_RECEIVE_CONNECT_HANDSHAKE;
								}
							}
							// We did not get the correct handshake, so tear down the socket and start over
						}
						else
						{
							iStatus = COULD_NOT_CONNECT_TO_SOCKET;
						}
					}
				} // end for(;;)
				// We only get here if we successfully sent the error and ended messages
				for (;;){}
			}
			return (COULD_NOT_SEND_DATA_TO_PORT);
		}
		dwNumLeft = dwNumLeft - dwNumSent;
		dwSendIndex = dwSendIndex + dwNumSent;
	}
// QQQAKC
///*
	while (!(TimedOut(dblTimeout, &liTimeout)))
	{
		if (WaitForSingleObject(hAckReceivedEvent, 1000) == WAIT_OBJECT_0)
			break;
		if (test != NULL)
		{
			if (test->CheckAbort(HERE))
				break;
		}
	}
//*/
	if (TimedOut(dblTimeout, &liTimeout))
	{
		g_dwLocalIDToAck = 0;

		vDeleteHostResponseListEntry(dwLocalID);
		LeaveCriticalSection(&SendToHostCriticalSection);
		return (ACK_TIMEOUT);
	}

	LeaveCriticalSection(&SendToHostCriticalSection);
	delete [] pcSendBuffer;
	pcSendBuffer = NULL;
	if (TimedOut(dblTimeout, &liTimeout))
	{
		vDeleteHostResponseListEntry(dwLocalID);
//		printf("Send: Timeout out trying to send data to the host\n");
		return (SEND_TIMEOUT);
	}
	if (test != NULL)
	{
		if (test->CheckAbort(HERE))
		{
			vDeleteHostResponseListEntry(dwLocalID);
			return (ABORT_RECEIVED);
		}
	}

	// Wait for a reply from the host only if applicable
	if (bExpectResponse)
	{
		// Wait for a response or a timeout condition
		// It is possible that this whole routine may take 2x iTimeOut if we wait almost
		// iTimeout seconds above and then iTimeout seconds here too.  That is not too big a deal
		// though and avoids having to do the time math here.
		while (!(TimedOut(dblTimeout, &liTimeout)))
		{
			if (WaitForSingleObject(pListTemp->hEvent, 1000) == WAIT_OBJECT_0)
				break;
			if (test != NULL)
			{
				if (test->CheckAbort(HERE))
					break;
			}
		}
		if (TimedOut(dblTimeout, &liTimeout))
		{
			vDeleteHostResponseListEntry(dwLocalID);
			return (RECEIVE_TIMEOUT);
		}
		if (test != NULL)
		{
			if (test->CheckAbort(HERE))
			{
				vDeleteHostResponseListEntry(dwLocalID);
				return (ABORT_RECEIVED);
			}
		}

		// The data is back, so let's parse it
		// pListTemp should still be a valid pointer to our list entry (even though its position in the list may have moved around)
		// Use the critical section just in case the receive routine gets another response that matches this ID (shouldn't happen)
		// and starts to muck with our data while we are parsing it out
		EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list

		CHR.pvBufferFromHost = pListTemp->pcBufferFromHost;
		*pdwBytesReceivedFromHost = pListTemp->dwActualBytesReceived;
		*pdwErrorCodeFromHost = pListTemp->dwReturnedErrorCode;
		iStatus = pListTemp->iStatus;

		LeaveCriticalSection(&HostResponseEntryListCriticalSection);

		vDeleteHostResponseListEntry(dwLocalID); // Close the event and remove this entry from the list
	}

	return (iStatus);
}

// Delete an entry from the Host Response List, if it exists
// WARNING: Do not access this routine from within the HostResponseEntryListCriticalSection.  Deadlock will result
void CHost::vDeleteHostResponseListEntry(DWORD dwID)
{
	PHOST_RESPONSE_ENTRY pListTemp = NULL, pPreviousListEntryTemp = NULL;

	EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list
	pPreviousListEntryTemp = pHostResponsesPendingList;
	pListTemp = pHostResponsesPendingList;
	if (pListTemp != NULL) // There is at least one entry in the list
	{
		while (pListTemp != NULL)
		{
			if (pListTemp->dwID == dwID)
			{
				if (pListTemp == pHostResponsesPendingList) // This is the first entry in the list
				{
					pHostResponsesPendingList = pHostResponsesPendingList->pNextEntry;
				}
				else // This is not the first entry in the list
				{
					pPreviousListEntryTemp->pNextEntry = pListTemp->pNextEntry;
				}
				pListTemp->pNextEntry = NULL;
				// This is how to close out an Event (whether or not it was set)
				CloseHandle(pListTemp->hEvent);
				delete pListTemp;
				break;
			}
			pPreviousListEntryTemp = pListTemp;
			pListTemp = pListTemp->pNextEntry;
		}
	}
	LeaveCriticalSection(&HostResponseEntryListCriticalSection);
	return;
}


// The entry point to the new thread that will allow access to the real vReceiveFromHostThread routine
void CHost::vReceiveFromHostThreadEntry(void *pthis)
{
	CHost *pHost = (CHost *)pthis;

	pHost->vReceiveFromHostThread();
}
// This thread receives all communication from the host after initial communication has
// been established.  Whenever a function sends a command to the host, this thread will
// capture and pass back the respose.
void CHost::vReceiveFromHostThread(void)
{
	DWORD dwNumSentToHere = 4;
	int iForever = 1;
	int iNumLeft, iReceiveIndex;
	DWORD dwNumReceivedThisTime;
	char *pcLocalBuffer;
	char *pcCopyBuffer;
	int iStatus;
	PHOST_RESPONSE_ENTRY pListTemp = NULL;
	int iActualBytesReceived; // Used to hold information about the received data
	DWORD dwID;                // Used to hold the message ID of the received data
	DWORD dwReturnedErrorCode;
	WSAEVENT WSAEvent = WSA_INVALID_EVENT;
	WSABUF DataBuf;
	WSAOVERLAPPED wsaRecvOverlapped;
	int iReceiveResult, iWTemp, iError;
	DWORD dwFlags;
	BOOL bResult;
	char pcDefaultBuffer[100]; // This buffer is use to receive useful data if the buffer allocation fails
	char pcScratchBuffer[100]; // This buffer is use to receive scratch data if the buffer allocation fails


	if ((WSAEvent = WSACreateEvent()) == WSA_INVALID_EVENT)
		return;
	while (iForever == 1) // This will be in a forever while() loop	
	{
		pcLocalBuffer = NULL;
		iStatus = EVERYTHINGS_OK;
		iNumLeft = sizeof(DWORD);
		iReceiveIndex = 0;
		while (iNumLeft > 0) // Receive the DWORD message length indicator
		{
			DataBuf.len = iNumLeft;
			DataBuf.buf = ((char *)&dwNumSentToHere) + iReceiveIndex;
			dwFlags = 0;
			wsaRecvOverlapped.hEvent = WSAEvent;
			WSAResetEvent(WSAEvent);

			EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
			iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
			LeaveCriticalSection(&SocketAccessCriticalSection);
			if (iReceiveResult == 0)
			{
				if (dwNumReceivedThisTime == 0) // The socket closed, so we can't do anything
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else if (iReceiveResult == SOCKET_ERROR)
			{
				if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
				{
					WSAWaitForMultipleEvents(1, &WSAEvent, FALSE, WSA_INFINITE, FALSE); // Wait for the data to be received
					for(;;)
					{
						EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
						bResult = WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags);
						LeaveCriticalSection(&SocketAccessCriticalSection);
						if (bResult)
							break;
						iError = WSAGetLastError();
						if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
						{
							WSACloseEvent(WSAEvent);
							return;
						}
						Sleep(5); // Don't hog all of the CPU time
					}
				}
				else // Could not receive data from the client for some reason, so exit
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else // Some other bad error happened, so abort
			{
				WSACloseEvent(WSAEvent);
				return;
			}
			iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
			iReceiveIndex = iReceiveIndex + (int)dwNumReceivedThisTime;
		}

		if ((pcLocalBuffer = new char[dwNumSentToHere - 4]) == NULL) // Allocate a buffer to receive the data
		{
			pcCopyBuffer = pcDefaultBuffer;
			if ((int)(dwNumSentToHere-4) > sizeof(pcDefaultBuffer)) // Ensure we bring in the right amount of data
				iNumLeft = sizeof(pcDefaultBuffer);
			else
				iNumLeft = (int)(dwNumSentToHere-4);
			iStatus = COULD_NOT_ALLOCATE_RECEIVE_BUFFER;
		}
		else
		{
			pcCopyBuffer = pcLocalBuffer;
			iNumLeft = (int)(dwNumSentToHere-4);
		}

		iActualBytesReceived = iNumLeft; // This is the actual number of bytes that will be received
		// Now receive the actual message
		iReceiveIndex = 0; // Indicate that 0 bytes have been received so far
		while (iNumLeft > 0) // Receive the full message
		{
			DataBuf.len = iNumLeft;
			DataBuf.buf = &pcCopyBuffer[iReceiveIndex];
			dwFlags = 0;
			wsaRecvOverlapped.hEvent = WSAEvent;
			WSAResetEvent(WSAEvent);
			EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
			iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
			LeaveCriticalSection(&SocketAccessCriticalSection);
			if (iReceiveResult == 0)
			{
				if (dwNumReceivedThisTime == 0) // The socket closed, so we can't do anything
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else if (iReceiveResult == SOCKET_ERROR)
			{
				if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
				{
					WSAWaitForMultipleEvents(1, &WSAEvent, FALSE, WSA_INFINITE, FALSE); // Wait for the data to be received
					for(;;)
					{
						EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
						bResult = WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags);
						LeaveCriticalSection(&SocketAccessCriticalSection);
						if (bResult)
							break;
						iError = WSAGetLastError();
						if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
						{
							WSACloseEvent(WSAEvent);
							return;
						}
						Sleep(5); // Don't hog all of the CPU time
					}
				}
				else // Could not receive data from the client for some reason, so exit
				{
					WSACloseEvent(WSAEvent);
					return;
				}
			}
			else // Some other bad error happened, so abort
			{
				WSACloseEvent(WSAEvent);
				return;
			}

			iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
			iReceiveIndex = iReceiveIndex + (int)dwNumReceivedThisTime;
		}

		// If the buffer allocation failed above, read in the rest of the data and throw it away (we have the important stuff already)
		if ((iStatus == COULD_NOT_ALLOCATE_RECEIVE_BUFFER) && ((int)(dwNumSentToHere-4) > sizeof(pcDefaultBuffer)))
		{
			// There is still some data to read, so let's get to it.
			iNumLeft = (int)(dwNumSentToHere - 4) - sizeof(pcDefaultBuffer);
			while (iNumLeft > 0)
			{
				DataBuf.len = (iNumLeft < sizeof(pcScratchBuffer)) ? iNumLeft : sizeof(pcScratchBuffer);
				DataBuf.buf = &pcScratchBuffer[0];
				dwFlags = 0;
				wsaRecvOverlapped.hEvent = WSAEvent;
				WSAResetEvent(WSAEvent);
				EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
				iReceiveResult = WSARecv(sock, &DataBuf, 1, &dwNumReceivedThisTime, &dwFlags, &wsaRecvOverlapped, NULL);
				LeaveCriticalSection(&SocketAccessCriticalSection);
				if (iReceiveResult == 0)
				{
					if (dwNumReceivedThisTime == 0) // The socket closed, so we can't do anything
					{
						WSACloseEvent(WSAEvent);
						return;
					}
				}
				else if (iReceiveResult == SOCKET_ERROR)
				{
					if ((iWTemp = WSAGetLastError()) == WSA_IO_PENDING) // The reception is pending, so wait for it
					{
						WSAWaitForMultipleEvents(1, &WSAEvent, FALSE, WSA_INFINITE, FALSE); // Wait for the data to be received
						for(;;)
						{
							EnterCriticalSection(&SocketAccessCriticalSection); // Make sure we don't use the socket at the same time as the receive thread
							bResult = WSAGetOverlappedResult(sock, &wsaRecvOverlapped, &dwNumReceivedThisTime, FALSE, &dwFlags);
							LeaveCriticalSection(&SocketAccessCriticalSection);
							if (bResult)
								break;
							iError = WSAGetLastError();
							if ((iError != WSA_IO_INCOMPLETE) && (iError != WSA_IO_PENDING))// The reception is complete but there was an error
							{
								WSACloseEvent(WSAEvent);
								return;
							}
							Sleep(5); // Don't hog all of the CPU time
						}
					}
					else // Could not receive data from the client for some reason, so exit
					{
						WSACloseEvent(WSAEvent);
						return;
					}
				}
				else // Some other bad error happened, so abort
				{
					WSACloseEvent(WSAEvent);
					return;
				}

				iNumLeft = iNumLeft - (int)dwNumReceivedThisTime;
			}
		}

		// At this point, all of the data for this command has been received
		// iStatus should indicate EVERYTHINGS_OK, or COULD_NOT_ALLOCATE_RECEIVE_BUFFER
		// From here below is the only code that knows the format of the returned data (ID, Host error code, and data)
		dwID = *(DWORD *)&pcCopyBuffer[0];  // ID value returned from host
		dwReturnedErrorCode = (*(DWORD *)&pcCopyBuffer[4]);  // Error Code value from the host
		iActualBytesReceived = iActualBytesReceived - 12; // Subtract the space used by the error code and the ID to get the number of data bytes

		pListTemp = NULL; // Do this so that the buffer delete below will happen if the response is an ACK or not in the list at all
		if (dwID == g_dwLocalIDToAck) // If this was just a command ACK, process it here
//		if (dwID == dwID+10)  // Always false, just to disable QQQACKs
		{
			g_dwLocalIDToAck = 0;
			SetEvent(hAckReceivedEvent);
		}
		else // This wasn't an ACK, so maybe it was a real response
		{
			EnterCriticalSection(&HostResponseEntryListCriticalSection); // Prevent other threads from accessing the list
			pListTemp = pHostResponsesPendingList;
			while (pListTemp != NULL)
			{
				if (pListTemp->dwID == dwID)
					break;
				pListTemp = pListTemp->pNextEntry;
			}
			if (pListTemp != NULL) // We found a match!
			{
				// Point the destination buffer pointer to the one we allocated
				pListTemp->iStatus = iStatus;  // Relay the status back to the thread that is waiting for this response
				pListTemp->pcBufferFromHost = pcLocalBuffer; // The pointer to the local buffer, or NULL
				if (pcLocalBuffer == NULL)
					pListTemp->dwActualBytesReceived = 0;
				else
				{
					pListTemp->dwActualBytesReceived = (DWORD)iActualBytesReceived;
					memcpy(&pcCopyBuffer[0], &pcCopyBuffer[12], pListTemp->dwActualBytesReceived); // Shift the reponse data to the start of the buffer
					pListTemp->dwReturnedErrorCode = dwReturnedErrorCode;
					if ((pListTemp->iStatus == EVERYTHINGS_OK) && (dwReturnedErrorCode != 0)) // If the host returned an error, but iStatus is still OK, change iStatus to indicate that there is a host error
						pListTemp->iStatus = HOST_ERROR_RETURNED;
				}
				SetEvent(pListTemp->hEvent); // Trigger the event to wake up the thread that is waiting for this response
			}
			LeaveCriticalSection(&HostResponseEntryListCriticalSection); // Relinquish access to the list
		}
		// If there is no match, discard the data and do nothing
		if ((pListTemp == NULL) && (pcLocalBuffer != NULL)) // If a buffer was allocated, but not sent back to a calling thread, delete the allocated buffer
		{
			delete [] pcLocalBuffer;
			pcLocalBuffer = NULL;
		}
	}
	return;
}

void CHost::vAlivePrintThreadEntry(void *pthis)
{
	CHost *pHost = (CHost *)pthis;

	pHost->vAlivePrintThread();
}
void CHost::vAlivePrintThread(void)
{
#ifdef _XBOX
	DWORD dwValueToWrite = 0;

	// Set LED Override to use the requested LED Behavior
	HalWriteSMBusValue(0x20, 0x07, FALSE, 0x01);
	for (;;)
	{
		if (dwValueToWrite == 0)
		{
			// Set LED Off
			// Orange
			HalWriteSMBusValue(0x20, 0x08, FALSE, 0xFF);
			dwValueToWrite = 1;
		}
		else
		{
			// Green
			HalWriteSMBusValue(0x20, 0x08, FALSE, 0x0F);
			dwValueToWrite = 0;
		}
		Sleep(1000);
	}
#endif
}


// StartTimer is really just a reuse of QueryPerformanceCounter
void CHost::StartTimer(LARGE_INTEGER *StartCount)
{
	QueryPerformanceCounter(StartCount);
	return;
}

// Returns TRUE if the specified amount of time has elapsed, FALSE otherwise.  This should only
// be use to perform periodic checks on a timer for a timeout condition
int CHost::TimedOut(double dblDelayTime, LARGE_INTEGER *StartCount)
{
// Assume that a high-perfmance counter is supported (it is on all Pentiums and higher)
	LARGE_INTEGER PerformanceFrequency, CurrentCount;
	double dblFrequency;

	QueryPerformanceFrequency(&PerformanceFrequency);
	dblFrequency = (double)(PerformanceFrequency.QuadPart);
	QueryPerformanceCounter(&CurrentCount);

	if ((((double)(CurrentCount.QuadPart - StartCount->QuadPart))/dblFrequency) < dblDelayTime)
		return (FALSE);
	return (TRUE);
}

// Delay for a specified number of Microseconds.  This should only be used for very small
// delays because it uses lots of CPU time.  Use Sleep() when the delay is in the millisecond
// or longer range and can be a bit longer than specified.
void CHost::MicroSecondDelay(DWORD dwDelayTime)
{
// Assume that a high-perfmance counter is supported (it is on all Pentiums and higher)
	LARGE_INTEGER PerformanceFrequency, StartCount, CurrentCount;
	double dblFrequency;

	QueryPerformanceFrequency(&PerformanceFrequency);
	dblFrequency = (double)(PerformanceFrequency.QuadPart) / 1000000; // Microsecond resolution
	QueryPerformanceCounter(&StartCount);
	CurrentCount.QuadPart = StartCount.QuadPart;

	while ((((double)(CurrentCount.QuadPart - StartCount.QuadPart))/dblFrequency) < (double)dwDelayTime)
		QueryPerformanceCounter(&CurrentCount);
	return;
}

// This function will seed the random number generator rand() with either the value passed in
// or the current time (if the value passed in is 0)
void CHost::SeedRand(int iSeed)
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	if (iSeed == 0)
	{
		GetSystemTime(&systimeSeed);
		SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
		iSeed = (int)filetimeSeed.dwLowDateTime;
	}
	srand(iSeed);
	return;
}

LPTSTR CHost::OpenIniFile (LPCTSTR filename)
{
	#define INI_HOST_TIMEOUT 15*60 // 15 minutes timeout

	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	int iError;
// The file name may have path information that we don't want.  Clean up XMTA.CPP

	if ((iError = g_host.iSendHost(MID_GET_FILE, (char *)filename, (wcslen(filename) + 1) * sizeof(WCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, INI_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			g_error.err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			return(NULL);
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			g_error.err_HostCommunicationError(iError);
			return(NULL);
		}
	}
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		g_error.err_INIBufferIsEmpty();
		return(NULL);
	}
	// The response is not NULL, and is not an error message, so process it

	// We are reading an ASCII file and converting it to UNICODE.
	// The following algorithm is designed to use a single buffer
	// for reading and conversion.  To do this we create a buffer large
	// enough to hold the converted file, then write the original
	// data to the upper half of the file.
	//
	DWORD fileSize = dwActualBytesReceived;
	m_start = new _TCHAR [fileSize + 2];
	BYTE *m_startBYTE = (BYTE *)m_start;
	char *middle = (char *) &m_start [(fileSize + 2)/2];

	// Copy the file contents to the allocated buffer
	memcpy(middle, CHR.pvBufferFromHost, dwActualBytesReceived);  // Copy the ini file contents
	
	for (DWORD q = 0; q < dwActualBytesReceived; q++)
	{
		m_startBYTE[q+q] = middle[q];
		m_startBYTE[q+q+1] = 0;
	}
/*
	int len = MultiByteToWideChar (CP_ACP, 0, middle, dwActualBytesReceived, m_start, fileSize + 1);
	if (len == 0)
	{
		g_error.ReportUnicodeConversionFailed (filename, (LPCTSTR) CGetLastError());
		return NULL;
	}
*/
	m_start [fileSize] = _T('\0');
	LPTSTR current = m_start;

	// Skip over initial unicode designator character
	//
	if (0xfffe == (int) *current)
		return NULL; // This code represents little endian format
	if (0xfeff == (int) *current)
		current++;

	return current;
}

DWORD CHost::GetHostDword (DWORD mid, DWORD alternate)
{
	CHostResponse CHR;

	const DWORD FIVEMINUTES = 30000;
	DWORD result, bytes, status;
	iSendHost (mid, NULL, 0, CHR, &bytes, &status, FIVEMINUTES);
	if ((CHR.pvBufferFromHost == NULL) || (bytes < 4) || (status != 0)) // Don't access the response buffer if it does not at least contain a DWORD
		result = alternate;
	else
		result = *((DWORD *)(CHR.pvBufferFromHost));
	return result;
}

void CHost::Init (char *strHostName, LPCTSTR strSerialNumber)
{
	// Only in remote mode
	sock = INVALID_SOCKET;
	if (iInitHostCommunication(strHostName, strSerialNumber,
		HOST_COMMUNICATION_INITIALIZATION_TIMEOUT, &sock) != EVERYTHINGS_OK)
	{
		DisconnectFromHost ();
	}
}

void CHost::DisconnectFromHost()
{
	if ((sock != NULL) && (sock != INVALID_SOCKET))
	{
		shutdown (sock, SD_BOTH);
		closesocket(sock);
		WSACleanup();
		sock = INVALID_SOCKET;
	}			
}

#endif // STAND_ALONE_MODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\timer.h ===
// timer.h - generic timing algorithm

class CTimeable
{
public:
	virtual void OnTimer () = 0;
};

class CTimer
{
	CTimeable *m_targetObj;
	HANDLE m_timerAbort;
	HANDLE m_timerThread;
	int m_milliseconds;
	__int64 m_i64ExpireTSCValue;

	static unsigned __stdcall TimerEntry (LPVOID pParam);
	void TimerMain ();

public:
	CTimer (CTimeable *obj, size_t seconds);
	~CTimer ();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\testlist.cpp ===
#include "stdafx.h"

#define MODULE_REGISTRAR(m, t) "CXModule" #m "Test" #t
#define LINKER_INCLUDE_MODULE(m, t) \
    "/include:?m_registrar@" MODULE_REGISTRAR(m, t) "@@2VCTestRegistrar@@A"

//
// Tell linker to include the follow test modules
//

#pragma comment(linker, LINKER_INCLUDE_MODULE(CPU, feature_check))
#pragma comment(linker, LINKER_INCLUDE_MODULE(CPU, fpu_stress))
#pragma comment(linker, LINKER_INCLUDE_MODULE(CPU, cpu_internal_speed))
#pragma comment(linker, LINKER_INCLUDE_MODULE(CPU, multimedia_extensions))
#pragma comment(linker, LINKER_INCLUDE_MODULE(CPU, simd_new_instructions))

#pragma comment(linker, LINKER_INCLUDE_MODULE(RTC, datetimedumputility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(RTC, datetimeaccuracytest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(RTC, ramtest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(RTC, interrupttest))

#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, report_xmta_versions_and_checksums))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, set_display_mode))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, find_free_memory))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, compare_dvd_firmware_revision))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, mount_utility_drive))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, unlock_xbox_hard_drive))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, compare_scart_status_voltage))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, check_for_uem_error))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, compare_kernel_revision))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, get_random_number))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, set_uem_state))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, check_chipset_revisions))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, clear_uem_error_history))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, mount_dashboard_partition))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, image_hard_drive))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, verify_per_box_information))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, delete_file))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Tool, write_per_box_information))

#pragma comment(linker, LINKER_INCLUDE_MODULE(Audio, analog_silence))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Audio, digital_playback))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Audio, digital_accuracy))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Audio, analog_playback))

#pragma comment(linker, LINKER_INCLUDE_MODULE(DVD, file_system_checksum))
#pragma comment(linker, LINKER_INCLUDE_MODULE(DVD, file_sequential_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(DVD, dvd_random_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(DVD, physical_device_sequential_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(DVD, dvd_file_sequential_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(DVD, free_space_random_wrc))

#pragma comment(linker, LINKER_INCLUDE_MODULE(HardDisk, dvd_random_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(HardDisk, physical_device_sequential_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(HardDisk, free_space_random_wrc))
#pragma comment(linker, LINKER_INCLUDE_MODULE(HardDisk, file_sequential_read))
#pragma comment(linker, LINKER_INCLUDE_MODULE(HardDisk, file_system_checksum))
#pragma comment(linker, LINKER_INCLUDE_MODULE(HardDisk, dvd_file_sequential_read))

#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemorySizeCheck))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, CacheRandomDwordOps))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, WindowedCacheRandomDwordOps))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemoryTransfer))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, WindowedCacheMixedOps))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, DisplayMemoryStatus))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, CacheRandomData))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemoryRandomData))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, CacheMixedOps))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, DDRBusNoise))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemoryPerformance))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, WindowedCacheUniqueness))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemorySlidingOnesAndZeros))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, DDRBusPowersof2))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, DDRMemoryBanks))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, DDR32KStride))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, CacheSlidingOnesAndZeros))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, WindowedCacheRandomData))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, CacheAddressPatterns))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, DDRDeviceStride))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemoryAddressPatterns))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemoryMixedOps))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, CachePerformance))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, QBusNoise))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Memory, MemoryRandomDwordOps))

#pragma comment(linker, LINKER_INCLUDE_MODULE(Grafx, 3DSurface))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Grafx, HDTV))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Grafx, Shapes))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Grafx, Vidmemory))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Grafx, Vidmemory_patterns))
#pragma comment(linker, LINKER_INCLUDE_MODULE(Grafx, Ani))

#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscmsvcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscjcompcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscmcompcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscjsvcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscjcompmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscmcompmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscjsvmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, ntscmsvmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, secamcompcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palnsvpcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, secamsvcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palbsvcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palmcompcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palbcompcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palmsvcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palncompcb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palnsvpmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palbcompmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, secamsvmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palmcompmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, secamcompmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palmsvmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palbsvmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, palncompmb))
#pragma comment(linker, LINKER_INCLUDE_MODULE(TV, tv_linearity))

#pragma comment(linker, LINKER_INCLUDE_MODULE(USB, enumerationtest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(USB, memoryunitstresstest))

#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, AudioClampUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, DVDTrayStatesandEmptyTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, LEDSystemTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, AbortRegulateTemperatureUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, RevisionCheckTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, SystemPowerCycleUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, LEDBoardTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, ReadTempUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, SystemResetUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, DVDSpinDownUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, RegulateTemperatureUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, VModeTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, DVDOpenCloseMediaDetectTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, AirSensorCalibrationUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, FanSpeedBoardTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, SystemShutdownUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, BootCountGateUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, ThermalOverloadUtility))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, ThermalTest))
#pragma comment(linker, LINKER_INCLUDE_MODULE(SMC, FanSpeedSystemTest))

#pragma comment(linker, LINKER_INCLUDE_MODULE(LAN, UDPResponder))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\timer.cpp ===
#include "stdafx.h"

CTimer::CTimer (CTimeable *obj, size_t milliseconds)
	:m_targetObj(obj), m_milliseconds(milliseconds), 
	 m_timerAbort(NULL), m_timerThread(NULL), m_i64ExpireTSCValue(0)
{
	if (milliseconds <= 0)
		return;

	// Moved this above the beginthreadex to eliminate a potential race condition
	m_timerAbort = CreateEvent (NULL, false, false, NULL);
	if (m_timerAbort == NULL)
		throw _T("Failed to create timer event");

	DWORD result = _beginthreadex (NULL, 0, &TimerEntry, this, 0, (UINT*)&result);
	if (result == 0)
		throw _T("Failed to create timer thread");

	m_timerThread = (HANDLE) result;
}

CTimer::~CTimer ()
{
	if (m_milliseconds && m_timerAbort && m_timerThread)
	{
		SetEvent (m_timerAbort);
		WaitForSingleObject (m_timerThread, INFINITE);
	}
	CloseHandle (m_timerAbort);
	CloseHandle (m_timerThread);
}

unsigned __stdcall CTimer::TimerEntry (LPVOID pParam)
{
	CTimer *timer = (CTimer *) pParam;
	timer->TimerMain ();
	_endthreadex (0); 
	return 0;
}

void CTimer::TimerMain ()
{
	DWORD result;

#if defined( _XBOX ) // An XBOX-specific routine that uses the Time Stamp Counter for accuracy
	LARGE_INTEGER liLocalTSC;

	_asm
	{
		rdtsc
		mov liLocalTSC.LowPart, eax       ; Preserve the Least Significant 32 bits
		mov liLocalTSC.HighPart, edx      ; Preserve the Most Significant 32 bits
	}

	m_i64ExpireTSCValue = liLocalTSC.QuadPart + gi64CPUSpeed*(__int64)(m_milliseconds/1000);
	// Now wait for either an abort, or a period of time to elapse
	for (;;)
	{
		result = WaitForSingleObject (m_timerAbort, 2000);
		if (result == WAIT_TIMEOUT)
		{
			_asm
			{
				rdtsc
				mov liLocalTSC.LowPart, eax       ; Preserve the Least Significant 32 bits
				mov liLocalTSC.HighPart, edx      ; Preserve the Most Significant 32 bits
			}
			if (liLocalTSC.QuadPart >= m_i64ExpireTSCValue) // The proper number of seconds has elapsed, so fire off the timer event
			{
				m_targetObj->OnTimer ();
				break;
			}
		}
		else // Must be an abort
			break;
	}

#else // Regular Win32 
	result = WaitForSingleObject (m_timerAbort, m_milliseconds);

	if (result == WAIT_TIMEOUT)
		m_targetObj->OnTimer ();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\testobj.h ===
// testobj.h - this include is required to build a module

#pragma once

class CTestFactory;

// CTestObj
//
// All Test objects must ultimately derive from this class.
// This object encapsulates the Test Thead.
// The XMTA API used by the tests is a subset of the 
// protected members of this class.
//
class CTestObj : public CLoopable
{
	HANDLE m_hThread;

	int m_errorCount;
	DWORD m_startTime;
	DWORD m_elapsedTime;
	DWORD m_settimeout;
	DWORD m_lastCheckAbort;
	_TCHAR m_lastCheckAbortHere [128];

	bool m_handlesExceptions;
	bool m_handlesLooping;

	ULONGLONG m_lastThreadTime;
	bool IsThreadRunning ();

	HANDLE m_semaphore;
	HANDLE m_mutexTest;

protected: // Implementation of CLoopable virtuals
	virtual bool LoopMain ();
	virtual bool LoopStart ();
	virtual void LoopExit ();
	virtual LPCTSTR GetName () {return GetFullName ();}


private: // Test Factory can create an instance of any registered test

	static CTestFactory m_factory;

public: // Access to the Test Factory

	static void RegisterTest (LPCTSTR name, CreateFunction func);
	static bool LookupTest (LPCTSTR module, LPCTSTR test); 
	static CTestObj *CreateTest (LPCTSTR name); 

protected: // XMTA API functions ...

	bool GetCfgPresent (LPCTSTR name) {return (GetCfgString (name, NULL) != NULL);}
	bool GetCfgBoolean (LPCTSTR name);
	int GetCfgInt (LPCTSTR name, int defaultInt);
	UINT GetCfgUint (LPCTSTR name, UINT defaultUint);
	LPCTSTR GetCfgString (LPCTSTR name, LPCTSTR defaultStr);
	int GetCfgChoice (LPCTSTR name, int defaultChoice, ...);

	bool ReportError (WORD errorCode, LPCTSTR format, ...);
	bool ReportError (CXmtaException &x) {return ReportError (x.GetErrorCode(), x.GetMessage ());}
	bool vReportError (WORD errorCode, LPCTSTR format, va_list argptr);

	void ReportWarning (LPCTSTR format, ...);
	void ReportDebug (DWORD debugFilter, LPCTSTR format, ...);
	void ReportStatistic (LPCTSTR key, LPCTSTR format, ...);

	void SetTimeoutLimit (int limit);

public: 
	bool CheckAbort (LPCTSTR here); // CheckAbort() needs to be accessible.
	DWORD GetElapsedTime () {return m_elapsedTime;}
	DWORD GetTestPassed () {return m_errorCount == 0;}

protected: // helper functions

	CParameterItem *FindParameter (LPCTSTR name);
	bool AbortSensitiveWait (HANDLE h, LPCTSTR footprint);

	bool LockModule (void);
	void UnlockModule (void);
	bool LockTest (void);
	void UnlockTest (void);

protected: // virtual functions implemented in derived classes

	virtual bool InitializeParameters ();
	virtual void TestMain () = 0;

public: // These virtuals are implemented by the DECLARE macros

	virtual LPCTSTR GetFullName () = 0;
	virtual LPCTSTR GetModuleName () = 0;
	virtual LPCTSTR GetTestName () = 0;
	virtual WORD GetModuleNumber () = 0;
	virtual WORD GetTestNumber () = 0;
	virtual bool WantModuleLocked () = 0;
	virtual bool WantTestLocked () = 0;

public: // These functions are used by the executive to control the test

	CTestObj ();
	virtual ~CTestObj (void);

	HANDLE StartTest ();
	void StopTest ();
	virtual bool CheckTimeout (DWORD maxTimeOut, DWORD loadFactor);

	void OnSignalAbort () {StopTest ();}

};


// CTestRegistrar
//
// This class exists only for the purpose of auto registration
// Instances of this class are declared statically in each test
// The constructor is run at start-up and register the test
// in with the test factory.  The test factory is a static member
// of the CTestObj class.
//
class CTestRegistrar
{
public:
	CTestRegistrar (LPCTSTR name, CreateFunction func) 
	{
		CTestObj::RegisterTest (name, func);
	}
};


// These are the macros simplify the constrution of tests and modules
//
#define DECLARE_XMTAMODULE(mclass, mname, mnumber) \
	virtual WORD GetModuleNumber () {return mnumber;} \
	virtual LPCTSTR GetModuleName () {return _T(mname);} \
	virtual bool WantModuleLocked ();

#define IMPLEMENT_MODULELOCKED(mclass) \
	bool mclass::WantModuleLocked () {return true;}
#define IMPLEMENT_MODULEUNLOCKED(mclass) \
	bool mclass::WantModuleLocked () {return false;}


#define REGISTER_TEST(tclass, mname, tname) \
	CTestRegistrar tclass::m_registrar \
		(mname _T(".") tname, &tclass::CreateTest)

//
#define DECLARE_XMTATEST(mclass,tclass,mname,tname,tnumber,tlocked) \
	virtual WORD GetTestNumber () {return tnumber;} \
	virtual LPCTSTR GetTestName () {return tname;} \
	virtual LPCTSTR GetFullName () {return mname _T(".") tname;} \
	virtual bool WantTestLocked () {return tlocked;} \
	static CTestRegistrar m_registrar; \
	static CTestObj *CreateTest () {return new tclass;} \
	virtual void TestMain (); 

#define IMPLEMENT_XMTATEST(mclass,tclass,mname,tname,tnumber,locked) \
	class tclass : public mclass \
	{public: DECLARE_XMTATEST (mclass,tclass,mname,tname,tnumber,locked);};\
	REGISTER_TEST (tclass, mname, tname); \
	void tclass::TestMain ()
	
#define IMPLEMENT_TESTLOCKED(m,t,n) IMPLEMENT_XMTATEST \
			(CXModule##m, CXModule##m##Test##t, _T(#m), _T(#t), n, true)

#define IMPLEMENT_TESTUNLOCKED(m,t,n) IMPLEMENT_XMTATEST \
			(CXModule##m, CXModule##m##Test##t, _T(#m), _T(#t), n, false)

#define GET_TESTOBJ_PTR ((CTestObj *) TlsGetValue (g_tlsTestObj))
	
// Use these #defines to specify the selection bits for debug messages.
//
#define BIT0  0x00000001
#define BIT1  0x00000002
#define BIT2  0x00000004
#define BIT3  0x00000008
#define BIT4  0x00000010
#define BIT5  0x00000020
#define BIT6  0x00000040
#define BIT7  0x00000080
#define BIT8  0x00000100
#define BIT9  0x00000200
#define BIT10 0x00000400
#define BIT11 0x00000800
#define BIT12 0x00001000
#define BIT13 0x00002000
#define BIT14 0x00004000
#define BIT15 0x00008000
#define BIT16 0x00010000
#define BIT17 0x00020000
#define BIT18 0x00040000
#define BIT19 0x00080000
#define BIT20 0x00100000
#define BIT21 0x00200000
#define BIT22 0x00400000
#define BIT23 0x00800000
#define BIT24 0x01000000
#define BIT25 0x02000000
#define BIT26 0x04000000
#define BIT27 0x08000000
#define BIT28 0x10000000
#define BIT29 0x20000000
#define BIT30 0x40000000
#define BIT31 0x80000000


// This macro creates a constant wide char string
// that identifies line number and file.
//
#define _QUOTE(x) L#x
#define QUOTE(x) _QUOTE(x)
#define HERE _T(__FILE__) _T("(") QUOTE(__LINE__) _T(")")
//#define HERE NULL
//#define HERE __FILE__ "(" QUOTE(__LINE__) ")"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\XboxKeys.h ===
// XboxKeys.h
#pragma once

#ifndef INCLUDED_XBOXKEYS
#define INCLUDED_XBOXKEYS

// 30 TCHAR (decimal version[:hex checksum])
#define XMTA_SOFTWARE_REV _T("XMTA_SOFTWARE_REV")
// 30 TCHAR (decimal version[:hex checksum])
#define XMTA_SOFTWARE_CFG _T("XMTA_SOFTWARE_CFG")
// 30 TCHAR (decimal version[:hex checksum])
#define UHC_SOFTWARE_REV _T("UHC_SOFTWARE_REV")
// 30 TCHAR (decimal version[:hex checksum])
#define UHC_SOFTWARE_CFG _T("UHC_SOFTWARE_CFG")

// 8 TCHAR HEX (4 BYTES BINARY)
#define XBOX_GAME_REGION_CODE _T("XBOX_GAME_REGION_CODE")
// 8 TCHAR HEX (4 BYTES BINARY)
#define XBOX_TV_REGION_CODE _T("XBOX_TV_REGION_CODE")

// 172 TCHAR BASE64 (128 BYTES BINARY)
enum { XBOX_ONLINE_KEY_LENGTH = 172 };
#define XBOX_ONLINE_KEY _T("XBOX_ONLINE_KEY")

// 4 TCHAR HEX (2 BYTES BINARY)
enum { XBOX_ONLINE_KEY_VERSION_LENGTH = 4 };
#define XBOX_ONLINE_KEY_VERSION _T("XBOX_ONLINE_KEY_VERSION")

// 8 TCHAR
enum { XBOX_RECOVERY_KEY_LENGTH = 8 };
#define XBOX_RECOVERY_KEY _T("XBOX_RECOVERY_KEY")

// 24 TCHAR BASE64 (16 BYTES BINARY)
enum { XBOX_HARD_DRIVE_KEY_LENGTH = 24 };
#define XBOX_HARD_DRIVE_KEY _T("XBOX_HARD_DRIVE_KEY")

// 20 TCHAR
enum { XBOX_ROM_VERSION_LENGTH = 20 };
#define XBOX_ROM_VERSION _T("XBOX_ROM_VERSION")

// 3 TCHAR
enum { XBOX_SMC_VERSION_LENGTH = 3 };
#define XBOX_SMC_VERSION _T("XBOX_SMC_VERSION")

#endif // #ifndef INCLUDED_XBOXKEYS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\tree.h ===
// tree.h

#pragma once

/*
 *
 * CTreeItem handles a node in a tree list. 
 * The node maintains pointers to its parent node, 
 * to its adjacent siblings, and to its first 
 * and last children.
 *
 */
class CTreeItem
{
    CTreeItem* m_pPrev;         // points to previous sibling
    CTreeItem* m_pNext;         // points to next sibling
    CTreeItem* m_pParent;       // points to parent
    CTreeItem* m_pFirst;        // points to first child
    CTreeItem* m_pLast;         // points to last child

//    LPTSTR m_name;              // item text
	CAutoDelete<_TCHAR> m_name;

public:     // constructor and destructor
    CTreeItem (LPCTSTR s = NULL);
    virtual ~CTreeItem();

public:     // class functions
    void AddChild (CTreeItem* pChild, BOOL bFirst = FALSE);
    void AddChildAfter (CTreeItem* pChild,CTreeItem* pPrev);
    void AddChildBefore (CTreeItem* pChild,CTreeItem* pNext);
    CTreeItem* CreateChild (LPCTSTR s = NULL);
    CTreeItem* CreateSibing (LPCTSTR s = NULL);
    void DeleteChildren ();
	CTreeItem *FindChild (LPCTSTR name) const;
	int GetChildCount () const;
    CTreeItem* GetFirstChild() const
        {
        return m_pFirst;
        }
    CTreeItem* GetLastChild() const
        {
        return m_pLast;
        }
//    GetLevel() const;
//    GetNChildren() const;
    CTreeItem* GetNextSibling() const
        {
        return m_pNext;
        }
    CTreeItem* GetParent() const
        {
        return m_pParent;
        }
    CTreeItem* GetPrevSib() const
        {
        return m_pPrev;
        }
    CTreeItem* GetRoot();
    BOOL HasChildren() const
        {
        return(m_pFirst? TRUE:FALSE);
        }
    LPCTSTR GetName ()
		{
			return m_name.get();
		}
    BOOL HasParent() const
        {
        return(m_pParent ? TRUE : FALSE);
        }
    BOOL IsAncestor (const CTreeItem* pTest) const;
    BOOL IsDescendant (const CTreeItem* pTest) const;
    BOOL IsLinked () const
        {
        return((m_pNext || m_pPrev)? TRUE:FALSE);
        }
    BOOL IsParent (const CTreeItem* pTest) const
        {
        return((pTest->m_pParent == this) ? TRUE : FALSE);
        }
    void LinkAfter (CTreeItem* pPrev);
    void LinkBefore (CTreeItem* pNext);
	LPTSTR NewTSTR (LPCTSTR str);
    void RemoveChild (CTreeItem* pChild);
    void SetName (LPCTSTR s);
    void Unlink ();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\testobj.cpp ===
// testobj.cpp 
//

#include "stdafx.h"

//
// Test Factory stuff
//

bool CTestObj::LookupTest (LPCTSTR module, LPCTSTR test) 
{
	return (m_factory.LookupTest (module, test) != NULL);
}

CTestObj *CTestObj::CreateTest (LPCTSTR name) 
{
	return m_factory.CreateTest (name);
}

void CTestObj::RegisterTest (LPCTSTR name, CreateFunction func)
{
	m_factory.RegisterTest (name, func);
}

bool CTestObj::LoopMain ()
{
	if (!CheckAbort (NULL))
	{
		m_startTime = GetTickCount ();
		g_dispatch.TestStarted (this);
		TestMain ();
		m_elapsedTime = GetTickCount() - m_startTime;
		g_dispatch.TestEnded (this);
	}

	return true;
}

bool CTestObj::LoopStart ()
{
	// Store a pointer to the test in thread local storage at
	// a known index.  This allows functions in other classes
	// to identify the test without passing the test object ptr
	// through function arguments.
	//
	TlsSetValue (g_tlsTestObj, this);

	LockModule ();
	LockTest ();

	return InitializeParameters ();
}

void CTestObj::LoopExit ()
{
	UnlockTest ();
	UnlockModule ();
}


// 
// Public interface to the test object
//

// StopTest - used to stop a test
//
void CTestObj::StopTest ()
{
	InterlockedIncrement (&m_abortFlag);
}

// Constructor
//
CTestObj::CTestObj ()
{
	m_hThread = NULL;
	m_abortFlag = 0;
	m_settimeout = 0;
	m_startTime = 0;
	m_elapsedTime = 0;

	m_lastCheckAbort = GetTickCount ();
	m_lastCheckAbortHere [0] = 0;
	m_handlesExceptions = false;

	m_semaphore = NULL;
	m_mutexTest = NULL;

	m_lastThreadTime = 0;
	m_errorCount = 0;
}

bool CTestObj::InitializeParameters ()
{
	return true;
}

// Destructor
//
CTestObj::~CTestObj (void)
{
	// We expect that the thread has been long dead at this point
	// 
	if (m_hThread != NULL)
	{
		DWORD result = WaitForSingleObject (m_hThread, 0);
		ASSERT (result != WAIT_TIMEOUT);
		if (result == WAIT_TIMEOUT)
			g_error.ReportTestThreadWontDie ();
	}
}

bool CTestObj::IsThreadRunning ()
{
//	const ULONGLONG ONE_SECOND = 10000000i64;
//	const ULONGLONG ONE_MILSEC = 10000i64;

	ULONGLONG creation, exit, kernal, user;

	GetThreadTimes (m_hThread, 
		(FILETIME *) &creation, 
		(FILETIME *) &exit, 
		(FILETIME *) &kernal, 
		(FILETIME *) &user);

	ULONGLONG thisThreadTime = (kernal + user);
	bool running = (thisThreadTime > m_lastThreadTime);
	m_lastThreadTime = thisThreadTime;
	return running;
}

bool CTestObj::CheckTimeout (DWORD /*maxtimeout*/, DWORD loadfactor)
{
	DWORD now;
	DWORD settimeout =  (m_settimeout)? m_settimeout:m_maxtimeout;
	DWORD dwLocalCheckAbort;

	dwLocalCheckAbort = m_lastCheckAbort;
	now = GetTickCount ();
	
	// First check to see if we have exceeded the limit set by the test
	//
	if ((now - dwLocalCheckAbort) > (settimeout * 1000 * loadfactor))
	{
		ReportWarning (_T("B Timelimit %lu current %lu load %lu"), 
			settimeout, now-dwLocalCheckAbort, loadfactor);
		g_error.ReportTestTimeout (GetFullName (), IsThreadRunning (), 
			settimeout, loadfactor, m_lastCheckAbortHere);
		return true;
	}

	// Second check to see if the test has raised the timeout value
	// higher than the INI file value.
	//
	if ((now - dwLocalCheckAbort) > (m_maxtimeout * 1000 * loadfactor))
	{
		ReportWarning (_T("%s set timeout limit higher than default (ie, %d > %d)"), 
			GetFullName (), m_settimeout, m_maxtimeout);
	}

	return false;
}

//
// XMTA Test API
// 

CParameterItem *CTestObj::FindParameter (LPCTSTR name)
{
	CParameterItem *param = m_localParameters?
		m_localParameters->FindParameter (NULL, name):NULL;
	return param? param:g_parameters.FindParameter (GetModuleName(), name);
}

bool CTestObj::GetCfgBoolean (LPCTSTR name)
{
	CParameterItem *param = FindParameter (name);
	return (param != NULL)? param->GetBoolean ():false;
}

int CTestObj::GetCfgInt (LPCTSTR name, int defaultInt)
{
	CParameterItem *param = FindParameter (name);
	return (param != NULL)? param->GetInt ():defaultInt;
}

UINT CTestObj::GetCfgUint (LPCTSTR name, UINT defaultUint)
{
	CParameterItem *param = FindParameter (name);
	return (param != NULL)? param->GetUint ():defaultUint;
}

LPCTSTR CTestObj::GetCfgString (LPCTSTR name, LPCTSTR defaultStr)
{
	CParameterItem *param = FindParameter (name);
	return (param != NULL)? param->GetValue ():defaultStr;
}

int CTestObj::GetCfgChoice (LPCTSTR name, int defaultChoice, ...)
{
	va_list arglist;
	va_start (arglist, defaultChoice);

	CParameterItem *param = FindParameter (name);
	return (param != NULL)? param->GetChoice (arglist):defaultChoice;
}

bool CTestObj::vReportError (WORD errorCode, LPCTSTR format, va_list argptr)
{
	_TCHAR message [2048];
	_vsntprintf (message, 2048, format, argptr);

	int last = _tcslen(message) - 1;
	if (message [last] == _T('\n'))
		message [last] = _T('\0');

	ASSERT (GetModuleNumber() < 0x1000);
	ASSERT (GetTestNumber() < 0x100);
	ASSERT (errorCode < 0x1000u);

	g_dispatch.ErrorMessage (this, errorCode, message);

	m_errorCount++;

	if (m_objHaltOnError)
		m_objHaltOnError->OnSignalAbort (); // this just sets the abort flag

	if (m_handlesExceptions && m_abortFlag)
		throw CXmtaException (0, NULL);

	return (m_abortFlag != 0); // if abort return true
}

bool CTestObj::ReportError (WORD errorCode, LPCTSTR format, ...)
{
	va_list argptr;
	va_start (argptr, format);

	return vReportError (errorCode, format, argptr);
}

void CTestObj::ReportWarning (LPCTSTR format, ...)
{
	if (!m_reportwarnings)
		return;

	va_list argptr;
	va_start (argptr, format);

	_TCHAR message [2048];
	_vsntprintf (message, 2048, format, argptr);

	int last = _tcslen(message) - 1;
	if (message [last] == _T('\n'))
		message [last] = _T('\0');

	g_dispatch.WarningMessage (this, message);
}

void CTestObj::ReportDebug (DWORD debugFilter, LPCTSTR format, ...)
{
	if ((debugFilter & m_debugmask) == 0)
		return;

	va_list argptr;
	va_start (argptr, format);

	_TCHAR message [2048];
	_vsntprintf (message, 2048, format, argptr);

	int last = _tcslen(message) - 1;
	if (message [last] == _T('\n'))
		message [last] = _T('\0');

	g_dispatch.DebugMessage (this, message);
}

void CTestObj::ReportStatistic (LPCTSTR key, LPCTSTR format, ...)
{
	if (!m_reportstatistics)
		return;

	va_list argptr;
	va_start (argptr, format);

	_TCHAR message [2048];
	_vsntprintf (message, 2048, format, argptr);

	int last = _tcslen(message) - 1;
	if (message [last] == _T('\n'))
		message [last] = _T('\0');

	g_dispatch.StatisticsMessage (this, key, message);
}

void CTestObj::SetTimeoutLimit (int limit)
{
	InterlockedExchange ((long*) &m_settimeout, limit);
}

bool CTestObj::AbortSensitiveWait (HANDLE h, LPCTSTR footprint)
{
	DWORD result = WAIT_TIMEOUT;
	while (result == WAIT_TIMEOUT)
	{
		if (CheckAbort (footprint))
			return false;

		result = WaitForSingleObject (h, 1000);
	}
	return true;
}

bool CTestObj::LockTest () 
{
	char szFName[256];

	if (!WantTestLocked ())
	{
		m_mutexTest = INVALID_HANDLE_VALUE;
		return false;
	}

	if (m_mutexTest != NULL)
	{
		ReportError (0x04, _T("LockTest can not be called from a test"));
		return false;
	}
	sprintf(szFName, "%S", GetFullName());	
	m_mutexTest = CreateMutexA (NULL, true, szFName);
	return AbortSensitiveWait (m_mutexTest, _T("waiting on test lock"));
}

void CTestObj::UnlockTest () 
{
	if (!WantTestLocked ())
		return;

	ReleaseMutex (m_mutexTest); 
	CloseHandle (m_mutexTest);
}

#define XMTA_THREAD_LIMIT 10

bool CTestObj::LockModule () 
{
	char szFName[256];

	int threadLimit = XMTA_THREAD_LIMIT;

	int needed = WantTestLocked()? threadLimit:1;
	if (!WantModuleLocked ())
	{
		m_semaphore = INVALID_HANDLE_VALUE;
		return false;
	}

	ASSERT (m_semaphore == NULL);
	if (m_semaphore != NULL)
	{
		ReportError (0x04, _T("LockModule can not be called from a test"));
		return false;
	}

	sprintf(szFName, "%S", GetModuleName());	
	m_semaphore = CreateSemaphoreA (NULL, threadLimit, threadLimit, szFName);

	while (needed > 0)
	{
		if (!AbortSensitiveWait (m_semaphore, _T("Waiting on module semaphore")))
			return false;
		needed--;
	}
	
	return true;
}

void CTestObj::UnlockModule () 
{
	int needed = WantTestLocked()? XMTA_THREAD_LIMIT:1;
	if (!WantModuleLocked ())
		return;

	ASSERT (m_semaphore != NULL);
	if (m_semaphore == NULL)
		return;

	ReleaseSemaphore (m_semaphore, needed, NULL); 
	CloseHandle (m_semaphore);
	m_semaphore = NULL;
}


// CheckAbort
//
// This is a multipurpose function.
// It check the abort flag to see if its time to exit,
// it sets a string for footprinting
// and it updates the timestamp.
//
bool CTestObj::CheckAbort (LPCTSTR here)
{
	if (here) // foot printing
	{
		// skip the slashes
		LPCTSTR lastslash = _tcsrchr (here, _T('\\'));
		if (lastslash)
			here = _tcsinc (lastslash);

		_tcscpy (m_lastCheckAbortHere, here); 
	}

	InterlockedExchange ((long*) &m_lastCheckAbort, GetTickCount ());
	return (m_abortFlag != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\tree.cpp ===
// tree.cpp


#include "stdafx.h"


/*
 * CTreeItem
 */

/*
 * This class handles a node in a tree. Each node is linked to
 * its adjacent siblings, its parent, and its first and last
 * child.
 */
CTreeItem::CTreeItem (LPCTSTR s)
{
	m_pPrev = m_pNext = 0;
	m_pFirst = m_pLast = 0;
	m_pParent = 0;
	if (s) 
		SetName (s);
}

/*
 * The destructor unlinks the node from its sibling list and its parent if 
 * those operations have not already been done.  It also deletes all child
 * nodes.
 */ 
CTreeItem::~CTreeItem()
{
	Unlink();
	DeleteChildren();
//	if (m_name) 
//		delete m_name;
}

/*
 * Create a new string
 */
LPTSTR CTreeItem::NewTSTR (LPCTSTR str)
{
	if (str == NULL)
		return NULL;

	LPTSTR copy = new _TCHAR [_tcslen (str) + 1];
	_tcscpy (copy, str);
	return copy;
}

void CTreeItem::SetName (LPCTSTR s)
{
	m_name.set (NewTSTR (s));
}

/*
 * This function unlinks the node from its sibling list and its parent.  It 
 * does not disturb the children.
 */
void CTreeItem::Unlink()
{    
	if(m_pParent)
	{
		if (m_pParent->m_pFirst == this) 
			m_pParent->m_pFirst = m_pNext;
		if (m_pParent->m_pLast == this) 
			m_pParent->m_pLast = m_pPrev;
	}

	if(m_pPrev) 
		m_pPrev->m_pNext = m_pNext;
	if(m_pNext) 
		m_pNext->m_pPrev = m_pPrev;

	m_pPrev = m_pNext = m_pParent = 0;
}

/*
 * These functions link a node to a previous or next sibling.
 */
void CTreeItem::LinkAfter(CTreeItem* pPrev)
{
	ASSERT(!IsLinked());
	ASSERT(pPrev != NULL);
	m_pNext = pPrev->m_pNext;
	m_pPrev = pPrev;
	pPrev->m_pNext = this;
	if (m_pNext) 
		m_pNext->m_pPrev = this;
	m_pParent = pPrev->GetParent();
	if (m_pParent && (m_pNext == 0)) 
		m_pParent->m_pLast = this;
}

void CTreeItem::LinkBefore(CTreeItem* pNext)
{
	ASSERT(!IsLinked());
	ASSERT(pNext != NULL);
	m_pPrev = pNext->m_pPrev;
	m_pNext = pNext;
	pNext->m_pPrev = this;
	if (m_pPrev) 
		m_pPrev->m_pNext = this;
	m_pParent = pNext->GetParent();
	if (m_pParent && (m_pPrev == 0)) 
		m_pParent->m_pFirst = this;
}

/*
 * These functions add a child.
 */

void CTreeItem::AddChild (CTreeItem* pChild, BOOL bFirst)
{
	ASSERT(pChild != NULL);
	ASSERT(!pChild->IsLinked());

	pChild->m_pParent = this;
	if (bFirst)
	{
		pChild->m_pNext = m_pFirst;
		pChild->m_pPrev = 0;
		if (m_pFirst) 
			m_pFirst->m_pPrev = pChild;
		m_pFirst = pChild;
		if(m_pLast == 0) 
			m_pLast = pChild; 
	}
	else
	{
		pChild->m_pPrev = m_pLast;
		pChild->m_pNext = 0;
		if (m_pLast) 
			m_pLast->m_pNext = pChild;
		m_pLast = pChild;
		if (m_pFirst == 0) 
			m_pFirst = pChild;
	}
}        

void CTreeItem::AddChildAfter (CTreeItem* pChild, CTreeItem* pPrev)
{
	ASSERT(pChild != NULL);
	ASSERT(!pChild->IsLinked());
	if (pPrev) 
		ASSERT(IsParent(pPrev));

	pChild->m_pParent = this;
	if (pPrev == NULL) 
		AddChild (pChild, FALSE);
	pChild->LinkAfter(pPrev);
}

void CTreeItem::AddChildBefore (CTreeItem* pChild, CTreeItem* pNext)
{
	ASSERT(pChild != NULL);
	ASSERT(!pChild->IsLinked());
	if (pNext) 
		ASSERT(IsParent(pNext));

	pChild->m_pParent = this;
	if (pNext == NULL) 
		AddChild(pChild,TRUE);
	pChild->LinkBefore(pNext);
}

CTreeItem* CTreeItem::CreateChild (LPCTSTR s)
{
	CTreeItem* pItem = new CTreeItem(s);
	if (pItem) 
		AddChild (pItem);
	return pItem;
}

/*
 * Remove a node from the child list;
 */
void CTreeItem::RemoveChild(CTreeItem* pChild)
{
	if (IsParent (pChild)) 
		pChild->Unlink();
}

/*
 * This function deletes all children.
 */
void CTreeItem::DeleteChildren()
{
	while (m_pFirst) 
		delete m_pFirst;
}

/*
 * Test if this object is a descendant of a specified object.
 */ 
BOOL CTreeItem::IsDescendant (const CTreeItem* pTest) const
{
	CTreeItem* p;
	BOOL ret = FALSE;
	ASSERT(pTest);

	for (p = m_pParent; p; p = p->m_pParent) 
		if (p == pTest)
		{
			ret = TRUE;
			break; 
		}

	return(ret);
}

/*
 * Test if this object is an ancestor of a specified object.
 */
BOOL CTreeItem::IsAncestor (const CTreeItem* pTest) const
{
	ASSERT(pTest);
	return pTest->IsDescendant (this);
}

/*
 * Find the root of the tree.
 */
CTreeItem* CTreeItem::GetRoot()
{
	CTreeItem* pItem = this;
	for (pItem = this; pItem->GetParent(); pItem = pItem->GetParent())
		{}
	return pItem;
}    

/*
 * Count the number of children in this branch.
 */
int CTreeItem::GetChildCount () const
{
	CTreeItem* p;
	int count = 0;
	for (p = GetFirstChild(); p; p = p->GetNextSibling())
		count += 1 + p->GetChildCount();

	return count;
}

/*
 * Find a child with a name that matches the arguement.
 */
CTreeItem *CTreeItem::FindChild (LPCTSTR name) const
{
	if (name != NULL)
	{
		CTreeItem* p;
		for (p = GetFirstChild(); p; p = p->GetNextSibling())
		{
			if (_tcsicmp (p->GetName(), name) == 0)
				return p;
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmta.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// xmta.cpp : Defines the entry point for the console application.
//

// (The disabled warning is informational only.)
#pragma warning (disable:4073)

// pragma init_seg(lib) forces global objects declared
// in this file to be initialized before any other objects
// in the application.  This is important because the
// test factory is declared in this file.
// 
#pragma init_seg(lib)

#include "stdafx.h"

#define XMTA_VERSION _T("2.18.1.1481")
LPCTSTR version = _T("version number ") XMTA_VERSION;
TCHAR g_tcXMTAVersionNumber[] = XMTA_VERSION;


__int64 gi64CPUSpeed = 733000000;

// The test factory must be initialize before any test
// object classes, because the classes register with the
// test factory in their constructors.
//
CTestFactory CTestObj::m_factory;

CHost g_host;
CError g_error;
CParameterTable g_parameters;
CDispatcher g_dispatch;
DWORD g_tlsTestObj;
CLoopManager g_main;

#if defined( _XBOX ) 
LPDIRECT3D8				g_pD3D = NULL;		// The D3D enumerator object
LPDIRECT3DDEVICE8		g_pd3dDevice = NULL;// The D3D rendering device
D3DPRESENT_PARAMETERS	g_d3dpp;			// Present parameters used for device description.
#endif

int CustomNewHandler (size_t)
{
	throw CXmtaException (0x01, _T("Memory allocation (new) Failed"));
}

#define LENGTH(x) (sizeof(x)/sizeof(x[0]))

//int XboxMain()
#if defined( _XBOX ) 
int main (HINSTANCE hWnd, HINSTANCE, LPWSTR lpCmdLine, INT)
{
	UNREFERENCED_PARAMETER(lpCmdLine);
	UNREFERENCED_PARAMETER(hWnd);
#else // Win32
int WINAPI wWinMain (HINSTANCE, HINSTANCE, LPWSTR lpCmdLine, INT)
{
#endif
	// _set_se_translator is used to create a wrapper
	// for "structured exceptions" and allows them
	// to be caught and recognized by C++ try/catch blocks
	//
	_set_se_translator (CustomExceptionTranslator);
    _set_new_handler (CustomNewHandler);

	g_tlsTestObj = TlsAlloc ();
	TlsSetValue (g_tlsTestObj, NULL);

	TCHAR szCommandLine[128];
	memset (szCommandLine, 0, sizeof(szCommandLine));

	TCHAR inifile[128];
	memset (inifile, 0, sizeof(inifile));

#ifndef _XBOX 
	// Copy the command line into a buffer, for XOS we can make
	// no assumptions about "lpCmdLine" and therefor avoid it completely.
	//
	if ((lpCmdLine != NULL) && (lpCmdLine[0] != NULL))
		_tcsncpy(szCommandLine, lpCmdLine, LENGTH(szCommandLine) - 1);
	else
#endif
		_tcsncpy(szCommandLine, _T("xmta.ini"), LENGTH(szCommandLine) - 1);

	// Read the ini file name from the command line buffer
	// into the inifile buffer
	//
	_tcscpy (inifile, _tcstok (szCommandLine, _T(" ")));

	// Now check for the host name host name and serial number
	//

	LPTSTR hostName = _tcstok (NULL, _T(" "));
	if (hostName)
	{
		static char asciiHostName[128];
		sprintf (asciiHostName, "%S", hostName);
		g_host.m_strHostName = asciiHostName;

		// Check for a serial number too
		g_host.m_strSerialNumber = _tcstok (NULL, _T(" "));
	}

#ifdef _XBOX
	XDEVICE_PREALLOC_TYPE deviceTypes[] =
	{
//		{XDEVICE_TYPE_VOICE_HEADPHONE, 1},
		{XDEVICE_TYPE_GAMEPAD, 4},
		{XDEVICE_TYPE_MEMORY_UNIT, 8}
	};

	// This function must be called before any peripherals (game controllers, 
	// memory cards, voice units, and so on) are used or enumerated
	XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);
	
	//*****This section is used to create the global DirectX graphics devices.*****
	// Set up the structure used to create the D3DDevice.  Each subtest will override these
	//settings with a struct of their own and reset the device.
	HRESULT hr;
	ZeroMemory( &g_d3dpp, sizeof(g_d3dpp) );

	// Set fullscreen 640x480x32 mode
	g_d3dpp.BackBufferWidth        = 640;
	g_d3dpp.BackBufferHeight       = 480;
	g_d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;

	// Create one backbuffer and a zbuffer
	g_d3dpp.BackBufferCount        = 1;
	g_d3dpp.EnableAutoDepthStencil = TRUE;
	g_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

	// Set up how the backbuffer is "presented" to the frontbuffer each frame
	g_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	
	// Create the Direct3D object
	g_pD3D = Direct3DCreate8( D3D_SDK_VERSION );
	if( g_pD3D == NULL )
	{	//This is a fatal error for any graphics related test.
		g_error.err_D3dCreateObjectFailed ();
	}	
	// Create the device
	if( FAILED( hr = g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
											D3DCREATE_HARDWARE_VERTEXPROCESSING,
											&g_d3dpp, &g_pd3dDevice ) ) )
	{	//This is a fatal error for any graphics related tests.
		g_error.err_D3dCreateDeviceFailed ();
		g_pd3dDevice = NULL;
	}
	//*****End of DirectX graphics device init*****

	GetCPUSpeed(); // Compute the speed of the CPU
//	TCHAR speedstring[80];
//	_stprintf(speedstring, L"XMTA XPU speed %lu\n", (DWORD)gi64CPUSpeed);
//	OutputDebugString(speedstring);
#if defined( STAND_ALONE_MODE ) // Output to a file in XBOX STAND_ALONE_MODE
//	g_host.pF = _tfopen(_T("T:\\MEDIA\\INTEL\\INFO.OUT"), _T("wb"));
	g_host.pF = _tfopen(_T("D:\\INFO.OUT"), _T("wb"));
	if (g_host.pF == NULL)
		g_host.pF = stdout;
	_ftprintf (g_host.pF, _T("\xfeff")); // Identify output file as unicode text
#endif
#endif

#ifndef STAND_ALONE_MODE
#ifndef _XBOX
	// Okay, now that we have the server name and serial number
	// we can initialize the host communications
	g_host.Init (g_host.m_strHostName, g_host.m_strSerialNumber);
#endif

/*  Add this back in to require XMTA2.INI file on all but the first boot.
    This was removed due to the fact that sometimes a box can miss the first
	boot altogether (if restarted at just the right time by an operator) and the
	fact that UEM errors could render this count inaccurate.

	// And now that we have communications initialized we can
	// ask the host how many times we have booted to select
	// the appropriate INI file
	int boot_count = g_host.GetHostDword (MID_UUT_GET_BOOT_COUNT, 0);

	LPTSTR dot = _tcsstr (inifile, _T(".ini"));
	if ((dot != NULL) && (boot_count >= 2)) 
		_tcscpy (dot, _T("2.ini"));
*/
#endif

	LPTSTR str = g_host.OpenIniFile (inifile);
	if (!str)
		return 1;

	CCommandList commandList;

	try
	{
		CParseINI ini (str);
		ini.ParseSection (_T("parameters"), &g_parameters);
		ini.ParseSection (_T("testflow"), &commandList);

		g_host.CloseIniFile ();

		g_main.StartTesting (commandList.GetList());
	}
	catch (CXmtaException x) // this is a handled error 
	{
		if (x.GetMessage())
			g_dispatch.ErrorMessage (x);
	}
//#ifndef _DEBUG
	catch (CStructuredException e)
	{
		g_error.ReportStructuredExecption (
			e.GetExceptionString (),
			e.GetExceptionCode (),
			e.GetExceptionAddress ());
	}
	catch (...)
	{
		g_error.ReportUnknownException ();
	}
//#endif

	TlsFree (g_tlsTestObj);

	if (g_host.pF != NULL)
	{
		fclose(g_host.pF);
		g_host.pF = NULL;
	}

#if defined( _XBOX ) 
	g_host.DisconnectFromHost ();
	Sleep(INFINITE);
#endif
	Sleep(15000);

	return 0;
}

/* 
// LookupString - not needed yet
// 
// This is usefull algorithm for obtaining the index
// of a string in a list.
//
int LookupString (LPCTSTR target, LPCTSTR *list);
int LookupString (LPCTSTR target, LPCTSTR *list)
{
	for (int ii = 0; list [ii] != NULL; ii++)
	{
		if (_tcsicmp (list [ii], target) == 0)
			return ii;
	}

	return -1;
}
*/

CAutoString::CAutoString (LPCTSTR format, ...)
{
	va_list argptr;
	va_start (argptr, format);

	_TCHAR buffer [1024];
	int length = _vsntprintf (buffer, 1024, format, argptr);
	
	m_str = new _TCHAR [length + 1];

	_tcscpy (m_str, buffer);
}

void GetCPUSpeed()
{
#define RTC_PIT_TIMER_2 0x042
#define RTC_PIT_TIMER_CTRL 0x43
#define RTC_PIT_PORT_B_CTRL 0x61
	unsigned char nmi_temp_reg;
	DWORD pit_rolls = 0;
	DWORD tsc_ticks = 0;
	DWORD pit_start = 0;
	DWORD pit_end = 0;
	DWORD dwPitTime;
	LARGE_INTEGER liCPUSpeed, liPitTime, litsc_ticks;

	__asm
	{
		push eax
		push ebx
		push ecx
		push edx
		push edi
		push esi
		pushf

		cli                 ;  stop interrupts
		// Disable NMIs
		in al, 70h
		mov nmi_temp_reg, al
		or al, 80h
		out 70h, al
		// NMIs are now disabled

		in  al, RTC_PIT_PORT_B_CTRL ; Get Port B control register byte
		and al, 0FCh        ;  mask for Speaker and Timer 2 gate bits
		out RTC_PIT_PORT_B_CTRL, al ;  disable Speaker and Timer 2 gate
		mov al, 0B4h        ; Initialize Timer 2
		out RTC_PIT_TIMER_CTRL, al  ;
		mov al, 0           ; Clear Timer 2 count
		out RTC_PIT_TIMER_2, al     ;
		nop
		out RTC_PIT_TIMER_2, al     ;
		in  al, RTC_PIT_PORT_B_CTRL ; Get Port B control register byte
		or  al, 1           ;  mask for Timer 2 gate enable bit

	 	out RTC_PIT_PORT_B_CTRL, al ;  enable Timer 2 gate (start counting)
		; The timer is now running
		; Do the loop below to ensure we don't read 0000 as our first value
get_tsc_loop0:
		mov AL, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		cmp ax, 8000h
		jbe get_tsc_loop0   ; if the new value is below or equal to 0x8000, continue
		; Now we know the timer has at least rolled over from 0000 to FFFF.
		mov al, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		rdtsc
		mov edi, eax        ; Preserve the Least Significant 32 bits
		mov esi, edx        ; Preserve the Most Significant 32 bits
		mov eax, 0
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		mov pit_start, eax  ; Record the initial PIT value
		; Now wait around for the counter to roll over several times
		mov cl, 3
get_tsc_loop1:
		mov bx, ax
		mov al, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		cmp ax, bx
		jbe get_tsc_loop1   ; if the new value is below or equal to the old value, continue
		inc DWORD PTR pit_rolls  ; Continue doing this until the timer rolls over the correct number of times
		dec cl
		jne get_tsc_loop1
		; Now read the final PIT and TSC values
		mov al, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		rdtsc
		sub edx, esi        ; Calculate the change in high DWORD
		sub eax, edi        ; Calculate the change in low DWORD
		jnc GTD1
		dec edx
GTD1:
		mov tsc_ticks, eax        ; Preserve the low DWORD of CPU counts
		mov eax, 0
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		mov pit_end, eax ; Record the final PIT value

		// restore NMIs
		mov al, nmi_temp_reg
		out 70h, al
		// NMIs are now restored
		sti                 ; Start Interrupts
		in al, RTC_PIT_PORT_B_CTRL
		and al, 0feh
		out RTC_PIT_PORT_B_CTRL, al ;  disable Timer 2 gate (stop counting)

		popf
		pop esi
		pop edi
		pop edx
		pop ecx
		pop ebx
		pop eax
	}
	dwPitTime = (DWORD)(pit_rolls-1) * (DWORD)65536;
	dwPitTime = dwPitTime + (DWORD)pit_start + 1;
	dwPitTime = dwPitTime + (DWORD)(65536-pit_end);
	dwPitTime = dwPitTime - 1;
	liPitTime.QuadPart = dwPitTime;
	litsc_ticks.QuadPart = tsc_ticks;
	liCPUSpeed.QuadPart = litsc_ticks.QuadPart * 1125000;
	liCPUSpeed.QuadPart = liCPUSpeed.QuadPart/liPitTime.QuadPart;
	gi64CPUSpeed = liCPUSpeed.QuadPart;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xaudio\xaudio.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// Title: xAudio
//
// History:
//
// 10/XX/00 V1.00 BLI Release V1.00.

#include "..\stdafx.h"
#include "..\testobj.h"
#include "..\statkeys.h"
#include "xaudio.h"
#include <float.h>
#include <math.h>

IMPLEMENT_MODULEUNLOCKED (CXModuleAudio);

// Define the initial value to be passed into the CRC calculation routine.
#define INITIAL_CRC    0x55555555UL

// Audio test number definitions
#define ANALOG_PLAYBACK_TEST  1
#define DIGITAL_PLAYBACK_TEST 2
#define ANALOG_SILENCE_TEST 3
#define DIGITAL_ACCURACY_TEST 4

// Configuration parameter default values
#define DEFAULT_MUTEX_TIMEOUT                       180000      // The number of ms to wait for a mutex
#define DEFAULT_AUDIO_MUX_COM_PORT                  0
#define DEFAULT_AUDIO_MUX_LOW_DWORD                 0x88888888  // Disable all channels
#define DEFAULT_AUDIO_MUX_HIGH_DWORD                0x88888888  // Disable all channels

#define	DEFAULT_FREQUENCY_SHIFT_PERCENT_ALLOWED 3
#define	DEFAULT_DELAY_BETWEEN_PLAYBACK_START_AND_RECORD_START  700 // ms

#define DEFAULT_PLAYBACK_TEST_CONFIGURATION     1  // The first non-custom entry in gPlaybackTestConfigurations[] is the default
#define DEFAULT_RECORD_TEST_CONFIGURATION       1  // The first non-custom entry in gRecordTestConfigurations[] is the default

// Some more general constants
#define TWO_PI         (6.28318530718)
#define PI_OVER_TWO    (1.570796326795)
#define PIT_FFT_BITS    9         /* Make FFT_SIZE 512 values */
#define PIT_FFT_SIZE   (1 << PIT_FFT_BITS)
#define FFT_BITS       12         /* Make FFT_SIZE 4096 values */
#define FFT_SIZE       (1 << FFT_BITS)
#define WAVE_OUT_NUMBER_OF_SAMPLES  FFT_SIZE  // The number of samples in a single buffer; we will probably use multiple buffers of this size; this must be a multiple of FFT_SIZE
#define WAVE_IN_NUMBER_OF_SAMPLES   FFT_SIZE*2
#define IGNORE_BIN_VALUE  DBL_MAX
#define AVERAGE_FREQUENCY_RESPONSE_LEVEL  -1000000

#define NO_WINDOW          0    /* Represents no window function being applied to FFT data */
#define COS_SQUARED_WINDOW 1    /* Represents a cosine squared window function being applied to FFT data */

const wchar_t * CXModuleAudio::pwchFFTWindowFunctionNames[] = {
	L"NONE",
	L"COS_SQUARED",
	NULL
};

const wchar_t * CXModuleAudio::gpchMonoLabel[] = {L"(mono)"};
const wchar_t * CXModuleAudio::gpchStereoLabel[] = {L"(stereo left)", L"(stereo right)"};

const double CXModuleAudio::gdblStereoTwelveFrequencyQuicktestFreqCh0[] = {43, 75, 129, 215, 366, 624, 1055, 1809, 3079, 5243, 8947, 15256};
const double CXModuleAudio::gdblStereoTwelveFrequencyQuicktestFreqCh1[] = {54, 97, 161, 280, 474, 807, 1378, 2358, 4016, 6848, 11682, 19918}; 
const double CXModuleAudio::gdblStereoTwelveFrequencyQuicktestAmp[] = {-21.58, -21.58, -21.58, -21.58, -21.58, -21.58, -21.58, -21.58, -21.58, -21.58, -21.58, -21.58};  // Full amplitude for a 12 frequency signal

const WAVE_PLAYBACK_CHANNEL_FREQ_DATA CXModuleAudio::gwpcfdStereoTwelveFrequencyQuicktest[2] = {
	{sizeof(gdblStereoTwelveFrequencyQuicktestFreqCh0)/sizeof(double), (double *)gdblStereoTwelveFrequencyQuicktestFreqCh0},
	{sizeof(gdblStereoTwelveFrequencyQuicktestFreqCh1)/sizeof(double), (double *)gdblStereoTwelveFrequencyQuicktestFreqCh1}
};

const WAVE_RECORD_CHANNEL_FREQ_DATA CXModuleAudio::gwrcfdStereoTwelveFrequencyQuicktest[2] = {
	{sizeof(gdblStereoTwelveFrequencyQuicktestFreqCh0)/sizeof(double), (double *)gdblStereoTwelveFrequencyQuicktestFreqCh0, (double *)gdblStereoTwelveFrequencyQuicktestAmp},
	{sizeof(gdblStereoTwelveFrequencyQuicktestFreqCh1)/sizeof(double), (double *)gdblStereoTwelveFrequencyQuicktestFreqCh1, (double *)gdblStereoTwelveFrequencyQuicktestAmp}
};

const WAVE_RECORD_NOISE_LIMIT CXModuleAudio::gwrnlStereoTwelveFrequencyQuicktest[] = {
	{20, 20000, -50, -50}
};

const WAVE_PLAYBACK_CONFIGURATION_DATA CXModuleAudio::gwpcdStereoTwelveFrequencyQuicktest = {
	NULL, 0, NULL, 2, 16, 48000, 0, (WAVE_PLAYBACK_CHANNEL_FREQ_DATA *)gwpcfdStereoTwelveFrequencyQuicktest
};

const WAVE_RECORD_CONFIGURATION_DATA CXModuleAudio::gwrcdStereoTwelveFrequencyQuicktest = {
	0, 0, 2, (wchar_t **)gpchStereoLabel, 16, 44100, 0, NO_WINDOW, 40, 15, 0, 0, 0, 0, AVERAGE_FREQUENCY_RESPONSE_LEVEL, 3, 1, sizeof(gwrnlStereoTwelveFrequencyQuicktest)/sizeof(WAVE_RECORD_NOISE_LIMIT), (WAVE_RECORD_NOISE_LIMIT *)gwrnlStereoTwelveFrequencyQuicktest, (WAVE_RECORD_CHANNEL_FREQ_DATA *)gwrcfdStereoTwelveFrequencyQuicktest
};

const PLAYBACK_TEST_CONFIGURATIONS CXModuleAudio::gPlaybackTestConfigurations[] = {
	{"CUSTOM", (WAVE_PLAYBACK_CONFIGURATION_DATA *)&gwpcdStereoTwelveFrequencyQuicktest},
	{"STEREO 12 FREQUENCY QUICKTEST", (WAVE_PLAYBACK_CONFIGURATION_DATA *)&gwpcdStereoTwelveFrequencyQuicktest},
	{"", NULL}
};

const RECORD_TEST_CONFIGURATIONS CXModuleAudio::gRecordTestConfigurations[] = {
	{"CUSTOM", (WAVE_RECORD_CONFIGURATION_DATA *)&gwrcdStereoTwelveFrequencyQuicktest},
	{"STEREO 12 FREQUENCY QUICKTEST", (WAVE_RECORD_CONFIGURATION_DATA *)&gwrcdStereoTwelveFrequencyQuicktest},
	{"", NULL}
};

// CRC look-up table
static const unsigned long crctab[256] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

/*
Parameters fetched by this routine

testname.max_test_retries - The number of times to retry tests that fail
testname.delay_between_playback_start_and_record_start - The amount of time, in ms, to delay before recording audio after playback has started
testname.mutex_timeout - The amount of time, in ms, to wait for the audio resources to become free for use before aborting
testname.audio_mux_com_port - the serial port to which the audio mux is attached, if applicable
testname.playback.wave_output_device_name - the wave output device name assigned by the driver
testname.playback.number_of_channels - number of channels to play for a specific test
testname.playback.sample_rate - the playback rate for the test in KHz
testname.playback.bits_per_sample - the resolution of the playback for the test (8 and 16 are common)
testname.playback.digital_attenuation - the amount of attenuation, in dB, to apply to the digital output when generating the output waveform data
testname.playback.ch[kk]_freq[mm] - the (mm + 1) playback frequencies for the channel of this test to generate

testname.record.wave_input_device_name - the wave input device name assigned by the driver
testname.record.number_of_channels - number of channels to record for a specific test
testname.record.sample_rate - the record rate for the test in KHz
testname.record.bits_per_sample - the resolution of the record for the test (8 and 16 are common)
testname.record.fft_window_function - the FFT windowing function to apply to recorded FFT information.  "NONE" and COS_SQUARED" are common.
testname.record.amplitude_tolerance - the number of dB above or below the chkk_amplitudemm values a frequency can reside
testname.record.max_dc_offset_percent - the amount of DC offset vs half of full scale that a recorded sample can exhibit. 100% effectively means don't bother with DC offset comparisons
testname.record.signal_to_noise_ratio - the allowed S/N ratio.  One value for an entire test instead of one per channel
testname.record.signal_to_noise_ratio_ignoring_crosstalk - the allowed S/N ratio when crosstalk from other channels is ignored.  One value for an entire test instead of one per channel
testname.record.channel_separation - the minimum allowed channel separation between all channels in dB.
testname.record.frequency_response_tolerance - the number of dB above or below the frequency_response_level (or average of all fundamental frequencies) that all fundamentals should fall within
testname.record.frequency_response_level - the absolute dB level that all fundamentals should be recorded at, + or - the frequency_response_tolerance.  If this is not specified or is set to AVERAGE, the average of all fundamentals will be used for this value
testname.record.frequency_shift_percent_allowed - the percent a frequency may be off from its expected value
testname.record.frequency_shift_hz_allowed - the number of hertz any particular recorded frequency is permitted to exist above or below the expected value.  This is helpful when using FFT window functions.  This works along with the testname.record.frequency_shift_percent_allowed parameter
testname.record.crc - the CRC value to expect from an audio input buffer during digital audio testing.
// The following 4 parameters specify lines that describe where noise cutoff limits should be when analyzing recorded data
testname.record.noise_limit_start_freq[nn] - the starting frequency of range (nn) for maximum noise allowed parameters
testname.record.noise_limit_stop_freq[nn] - the ending frequency of range (nn) for maximum noise allowed parameters
testname.record.noise_limit_start_level[nn] - the starting level (in dB relative to ideal 0 dB) of range (nn) for maximum noise allowed parameters
testname.record.noise_limit_stop_level[nn] - the ending level (in dB relative to ideal 0 dB) of range (nn) for maximum noise allowed parameters
testname.record.ch[kk]_amplitude[mm] - the (mm + 1) recorded frequencies' amplitudes for the channel of this test to expect
testname.record.ch[kk]_freq[mm] - the (mm + 1) recorded frequencies for the channel of this test to expect

testname.mixer.device_name - the name assigned to the mixer
testname.mixer.mixercontrolname_ID_ch[kk]_item[mm] - channel kk item mm mixer controls are listed in this format
testname.mixer.mux_control_low_dword - the low 32 bits of the audio mux control QWORD for a particular test (controls the low 8 audio mux ports)
testname.mixer.mux_control_high_dword -  the high 32 bits of the audio mux control QWORD for a particular test (controls the high 16 digital output lines and 16 future expansion signals)

All of the stuff allocated in this routine is cleaned up in the module's destructor
This routine will only execute once per test invocation so it is not re-enterent.

*/
bool CXModuleAudio::InitializeParameters ()
{
	#define SUBTEST_NAME_SIZE   80
	#define GENERAL_RECEIVE_STRING_SIZE   81
	#define PARAMETER_TEMP_STRING_SIZE     256
	#define MIXER_PARAMETER_STORAGE_SIZE     32768

	wchar_t wszTempString[PARAMETER_TEMP_STRING_SIZE];
	wchar_t wszSubtestName[SUBTEST_NAME_SIZE];
//	wchar_t wszReceiveString[GENERAL_RECEIVE_STRING_SIZE];
	LPCTSTR pwszValue = NULL;
	LPCTSTR pwszStringParam;
	DWORD j, k;
	double *pdblDtaPlaybackChannelFrequencies;

	if (!CTestObj::InitializeParameters ())
		return false;

	dwLoopCounter = 0;
	gpdwPI = NULL; // This parameter is not re-initialized with each retry loop, so initialize it here
	gdwMaxTestTrys = 1; // This is actually the number of retries + 1
	gdwIgnoreError = FALSE;
	gpWavePlaybackConfigurationData = NULL;
	gpWaveRecordConfigurationData = NULL;
	gpAudioMuxConfigurationInformation = NULL;
	gpwszAudioMixerName = NULL;
	gdwNumberOfMixerControls = 0;
	if ((pCSMixer = new CStore(MIXER_PARAMETER_STORAGE_SIZE)) == NULL)
	{
		err_AllocMixerStorage(MIXER_PARAMETER_STORAGE_SIZE);
		return false;
	}

	swprintf(wszSubtestName, L"%s", GetTestName());

	// Get dwMaxTestRetries
	swprintf(wszTempString, L"%s.%s", wszSubtestName, L"max_test_retries");
	gdwMaxTestTrys = (DWORD)GetCfgUint (wszTempString, 0);
	if (gdwMaxTestTrys > 10)
		gdwMaxTestTrys = 0;
	gdwMaxTestTrys++; // Add 1 because this represents trys, not retries

	// Get gdwDelayBetweenPlaybackStartAndRecordStart
	swprintf(wszTempString, L"%s.%s", wszSubtestName, L"delay_between_playback_start_and_record_start");
	gdwDelayBetweenPlaybackStartAndRecordStart = (DWORD)GetCfgUint (wszTempString, DEFAULT_DELAY_BETWEEN_PLAYBACK_START_AND_RECORD_START);

	// Get gdwMutexTimeout
	swprintf(wszTempString, L"%s.%s", wszSubtestName, L"mutex_timeout");
	gdwMutexTimeout = (DWORD)GetCfgUint (wszTempString, DEFAULT_MUTEX_TIMEOUT);

	// Get gdwAudioMuxComPort
	swprintf(wszTempString, L"%s.%s", wszSubtestName, L"audio_mux_com_port");
	gdwAudioMuxComPort = (DWORD)GetCfgUint (wszTempString, DEFAULT_AUDIO_MUX_COM_PORT);


	// ************************* Now get playback parameters ************************
	// Allocate a WAVE_PLAYBACK_CONFIGURATION_DATA structure
	if ((gpWavePlaybackConfigurationData = new WAVE_PLAYBACK_CONFIGURATION_DATA) == NULL)  // Create a structure to contain playback parameters
	{
		err_AllocWavePlayConfigDataL(sizeof(WAVE_PLAYBACK_CONFIGURATION_DATA));
		return false;
	}
	gpWavePlaybackConfigurationData->WaveChannelFreqData = NULL;  // Do this for safety

	// Get the name of the audio output device to use
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"playback", L"wave_output_device_name");
	gpWavePlaybackConfigurationData->pwszAudioOutDevName = GetCfgString (wszTempString, L"none");

	// All test cases will be custom with no built-in configurations.

	// Get dwSampleRate
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"playback", L"sample_rate");
	gpWavePlaybackConfigurationData->dwSampleRate = (DWORD)GetCfgUint (wszTempString, (UINT)gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->dwSampleRate);
	
	// Get dwBitsPerSample
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"playback", L"bits_per_sample");
	gpWavePlaybackConfigurationData->dwBitsPerSample = (DWORD)GetCfgUint (wszTempString, (UINT)gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->dwBitsPerSample);
	
	// Get dwDigitalAttenuation
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"playback", L"digital_attenuation");
	gpWavePlaybackConfigurationData->dwDigitalAttenuation = (DWORD)GetCfgUint (wszTempString, (UINT)gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->dwDigitalAttenuation);
	
	// Get dwNumberOfChannels
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"playback", L"number_of_channels");
	gpWavePlaybackConfigurationData->dwNumberOfChannels = (DWORD)GetCfgUint (wszTempString, (UINT)gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->dwNumberOfChannels);

	// Allocate an array of structures to contain playback frequency information
	if ((gpWavePlaybackConfigurationData->WaveChannelFreqData = new WAVE_PLAYBACK_CHANNEL_FREQ_DATA[gpWavePlaybackConfigurationData->dwNumberOfChannels]) == NULL)  // Create an array of WAVE_PLAYBACK_CHANNEL_FREQ_DATA structures; one per channel
	{
		err_AllocWavePlayChannelFreqDataL(sizeof(WAVE_PLAYBACK_CHANNEL_FREQ_DATA)*gpWavePlaybackConfigurationData->dwNumberOfChannels);
		return false;
	}
	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++) // Set all of the double array pointers to NULL for safety
	{
		gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency = NULL;
		gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod = NULL;
	}
	// Read in playback configuration parameters for all channels of this test
	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		swprintf(wszTempString, L"%s.playback.ch[%2.2lu]_freq[%2.2lu]", wszSubtestName, j, 0);

		// Need to check for the presence of the parameter, and then load with defaults if it does not exist
		if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)  // No frequencies are specified for this channel, so set default frequencies
		{
			if ((j & 0x1) == 0)  // Channels 0,2,4,6,8,... get this set of frequencies by default
			{
				pdblDtaPlaybackChannelFrequencies = gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->WaveChannelFreqData[0].pdblFrequency;
				gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->WaveChannelFreqData[0].dwNumberOfFrequencies;
			}
			else  // Channels 1,3,5,7,9,... get this set of frequencies by default
			{
				pdblDtaPlaybackChannelFrequencies = gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->WaveChannelFreqData[1].pdblFrequency;
				gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = gPlaybackTestConfigurations[DEFAULT_PLAYBACK_TEST_CONFIGURATION].data->WaveChannelFreqData[1].dwNumberOfFrequencies;
			}
			if ((gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency = new double[gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies]) == NULL)  // Create an array of double to contain frequencies
			{
				err_AllocDoublesForPlaybackFreqL(sizeof(double)*gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies);
				return false;
			}
			if ((gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod = new double[gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies]) == NULL)  // Create an array of double to contain SamplesPerPeriod
			{
				err_AllocDoublesForPlaybackSPPL(sizeof(double)*gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies);
				return false;
			}
			for (k = 0; k < gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
				gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = pdblDtaPlaybackChannelFrequencies[k];
		}
		else  // Frequencies have been specified for this channel, so read them in
		{
			for (k = 1; k > 0; k++) // Count the number of frequencies on this channel; terminate only with the break inside the loop
			{
				swprintf(wszTempString, L"%s.playback.ch[%2.2lu]_freq[%2.2lu]", wszSubtestName, j, k);
				if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)
						break;
			}
			gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = k;
			if ((gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency = new double[k]) == NULL)  // Create an array of double to contain frequencies
			{
				err_AllocDoublesForPlaybackFreqL(sizeof(double)*k);
				return false;
			}
			if ((gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod = new double[k]) == NULL)  // Create an array of double to contain SamplesPerPeriod
			{
				err_AllocDoublesForPlaybackSPPL(sizeof(double)*k);
				return false;
			}
			// Now that we know how many frequencies there are, let's read them in
			for (k = 0; k < gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
			{
				swprintf(wszTempString, L"%s.playback.ch[%2.2lu]_freq[%2.2lu]", wszSubtestName, j, k);
				if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)
				{
					// We read this parameter successfully before.  Something is wrong if we can't read it now
					err_CantReadPlaybackFreqData();
					return false;
				}
				if ((gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = wcstod(pwszStringParam, NULL)) == 0)
					gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = FLT_MIN;
			}
		}
	}
	
	// ************************* Now get record parameters ************************
	// Allocate a WAVE_RECORD_CONFIGURATION_DATA structure
	if ((gpWaveRecordConfigurationData = new WAVE_RECORD_CONFIGURATION_DATA) == NULL)  // Create a structure to contain record parameters
	{
		err_AllocWaveRecordConfigDataL(sizeof(WAVE_RECORD_CONFIGURATION_DATA));
		return false;
	}
	gpWaveRecordConfigurationData->pchChannelLabel = NULL;  // Do this for safety
	gpWaveRecordConfigurationData->WaveRecordNoiseLimit = NULL;  // Do this for safety
	gpWaveRecordConfigurationData->WaveChannelFreqData = NULL;  // Do this for safety
	
	// Get the name of the audio input device to use
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"wave_input_device_name");
	gpWaveRecordConfigurationData->pwszAudioInDevName = GetCfgString (wszTempString, L"none");

	// All test cases will be custom with no built-in configurations.

	// Get dwSampleRate
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"sample_rate");
	gpWaveRecordConfigurationData->dwSampleRate = (DWORD)GetCfgUint (wszTempString, (UINT)gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwSampleRate);

	// Get dwBitsPerSample
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"bits_per_sample");
	gpWaveRecordConfigurationData->dwBitsPerSample = (DWORD)GetCfgUint (wszTempString, (UINT)gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwBitsPerSample);
	
	// Get dwNumberOfChannels
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"number_of_channels");
	gpWaveRecordConfigurationData->dwNumberOfChannels = (DWORD)GetCfgUint (wszTempString, (UINT)gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwNumberOfChannels);
	// Set up the string channel label
	switch (gpWaveRecordConfigurationData->dwNumberOfChannels)
	{
		case 1:
			gpWaveRecordConfigurationData->pchChannelLabel = (wchar_t **)gpchMonoLabel;
			break;
		case 2:
			gpWaveRecordConfigurationData->pchChannelLabel = (wchar_t **)gpchStereoLabel;
			break;
		default:
			gpWaveRecordConfigurationData->pchChannelLabel = NULL;
			break;
	}

	// Get dwCRC
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"crc");
	gpWaveRecordConfigurationData->dwCRC = (DWORD)GetCfgUint (wszTempString, (UINT)gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwCRC);

	// Get dwFFTWindowFunction
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"fft_window_function");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dwFFTWindowFunction = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwFFTWindowFunction;
	else // The parameter was defined, what is the numerical equivalent?
	{
		j = 0;
		while (pwchFFTWindowFunctionNames[j] != NULL)
		{
			if (wcsicmp(pwchFFTWindowFunctionNames[j], pwszStringParam) == 0)  // We found a match
			{
				gpWaveRecordConfigurationData->dwFFTWindowFunction = j;
				break;
			}
			j++;
		}
		if (pwchFFTWindowFunctionNames[j] == NULL) // We didn't read in a valid FFT window type
			gpWaveRecordConfigurationData->dwFFTWindowFunction = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwFFTWindowFunction;
	}

	// Get dblAmplitudeTolerance
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"amplitude_tolerance");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblAmplitudeTolerance = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblAmplitudeTolerance;
	else
	{
		if ((gpWaveRecordConfigurationData->dblAmplitudeTolerance = wcstod(pwszStringParam, NULL)) == 0)
			gpWaveRecordConfigurationData->dblAmplitudeTolerance = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblAmplitudeTolerance;
	}
	if (gpWaveRecordConfigurationData->dblAmplitudeTolerance < 0)  // Make this value positive
		gpWaveRecordConfigurationData->dblAmplitudeTolerance = 0 - gpWaveRecordConfigurationData->dblAmplitudeTolerance;

	// Get dblMaxDCOffsetPercent
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"max_dc_offset_percent");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblMaxDCOffsetPercent = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblMaxDCOffsetPercent;
	else
	{
		if ((gpWaveRecordConfigurationData->dblMaxDCOffsetPercent = wcstod(pwszStringParam, NULL)) == 0)  // Offset percent allowed can't be 0
			gpWaveRecordConfigurationData->dblMaxDCOffsetPercent = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblMaxDCOffsetPercent;
	}
	if (gpWaveRecordConfigurationData->dblMaxDCOffsetPercent < 0)  // Convert to a positive number
		gpWaveRecordConfigurationData->dblMaxDCOffsetPercent = 0 - gpWaveRecordConfigurationData->dblMaxDCOffsetPercent;

	// Get dblSignalToNoiseRatio
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"signal_to_noise_ratio");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblSignalToNoiseRatio = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblSignalToNoiseRatio;
	else
	{
		gpWaveRecordConfigurationData->dblSignalToNoiseRatio = wcstod(pwszStringParam, NULL);
	}
	if (gpWaveRecordConfigurationData->dblSignalToNoiseRatio < 0)  // Make the value positive
		gpWaveRecordConfigurationData->dblSignalToNoiseRatio = 0 - gpWaveRecordConfigurationData->dblSignalToNoiseRatio;
	// Get dblSignalToNoiseRatioIgnoringCrosstalk
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"signal_to_noise_ratio_ignoring_crosstalk");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblSignalToNoiseRatioIgnoringCrosstalk;
	else
	{
		gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk = wcstod(pwszStringParam, NULL);
	}
	if (gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk < 0)  // Make the value positive
		gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk = 0 - gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk;

	// Get dblChannelSeparation
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"channel_separation");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblChannelSeparation = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblChannelSeparation;
	else
	{
		gpWaveRecordConfigurationData->dblChannelSeparation = wcstod(pwszStringParam, NULL);
	}
	if (gpWaveRecordConfigurationData->dblChannelSeparation < 0)  // Make the value positive
		gpWaveRecordConfigurationData->dblChannelSeparation = 0 - gpWaveRecordConfigurationData->dblChannelSeparation;

	// Get dblFrequencyResponseTolerance
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"frequency_response_tolerance");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblFrequencyResponseTolerance = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblFrequencyResponseTolerance;
	else
	{
		gpWaveRecordConfigurationData->dblFrequencyResponseTolerance = wcstod(pwszStringParam, NULL);
	}
	if (gpWaveRecordConfigurationData->dblFrequencyResponseTolerance < 0)  // Make the value positive
		gpWaveRecordConfigurationData->dblFrequencyResponseTolerance = 0 - gpWaveRecordConfigurationData->dblFrequencyResponseTolerance;

	// Get dblFrequencyResponseLevel
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"frequency_response_level");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblFrequencyResponseLevel = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblFrequencyResponseLevel;
	else
	{
		if (wcsicmp(L"average", pwszStringParam) == 0)  // Average the frequencies
			gpWaveRecordConfigurationData->dblFrequencyResponseLevel = AVERAGE_FREQUENCY_RESPONSE_LEVEL;
		else
			gpWaveRecordConfigurationData->dblFrequencyResponseLevel = wcstod(pwszStringParam, NULL);
	}
	if (gpWaveRecordConfigurationData->dblFrequencyResponseLevel > 0)  // Make the value negative
		gpWaveRecordConfigurationData->dblFrequencyResponseLevel = 0 - gpWaveRecordConfigurationData->dblFrequencyResponseLevel;

	// Get dblFrequencyShiftPercentAllowed
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"frequency_shift_percent_allowed");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)
		gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed = DEFAULT_FREQUENCY_SHIFT_PERCENT_ALLOWED;
	else
		gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed = wcstod(pwszStringParam, NULL);
	if (gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed == 0)  // 0 percent is not an acceptable value
		gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed = DEFAULT_FREQUENCY_SHIFT_PERCENT_ALLOWED;

	// Get dblFrequencyShiftHzAllowed
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"frequency_shift_hz_allowed");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
		gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dblFrequencyShiftHzAllowed;
	else
	{
		gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed = wcstod(pwszStringParam, NULL);
	}
	if (gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed < 0)  // Make the value positive
		gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed = 0 - gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed;

	// Get noise limit frequencies and levels
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"record", L"noise_limit_start_freq[00]");
	if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
	{
		gpWaveRecordConfigurationData->dwNumberOfNoiseRanges = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->dwNumberOfNoiseRanges;
		if ((gpWaveRecordConfigurationData->WaveRecordNoiseLimit = new WAVE_RECORD_NOISE_LIMIT[gpWaveRecordConfigurationData->dwNumberOfNoiseRanges]) == NULL)  // Create an array of WAVE_RECORD_NOISE_LIMIT to contain noise limit info
		{
			err_AllocWaveRecordNoiseLimitL(sizeof(WAVE_RECORD_NOISE_LIMIT)*gpWaveRecordConfigurationData->dwNumberOfNoiseRanges);
			return false;
		}
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfNoiseRanges; j++)  // Set all noise range parameters to their default values
		{
			gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartFreq = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveRecordNoiseLimit[j].dblNoiseLimitStartFreq;
			gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopFreq = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveRecordNoiseLimit[j].dblNoiseLimitStopFreq;
			gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel;
			gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopLevel = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveRecordNoiseLimit[j].dblNoiseLimitStopLevel;
		}
	}
	else // Noise ranges have been specified, so read them in
	{
		for (j = 1; j > 0; j++) // Loop until the break is reached; count the number of noise ranges
		{
			swprintf(wszTempString, L"%s.record.noise_limit_start_freq[%2.2lu]", wszSubtestName, j);
			if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
				break;
		}
		gpWaveRecordConfigurationData->dwNumberOfNoiseRanges = j;  // Now we know how many noise ranges there are
		if ((gpWaveRecordConfigurationData->WaveRecordNoiseLimit = new WAVE_RECORD_NOISE_LIMIT[j]) == NULL)  // Create an array of WAVE_RECORD_NOISE_LIMIT to contain noise limit info
		{
			err_AllocWaveRecordNoiseLimitL(sizeof(WAVE_RECORD_NOISE_LIMIT)*j);
			return false;
		}
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfNoiseRanges; j++)  // Read in all noise range parameters
		{
			swprintf(wszTempString, L"%s.record.noise_limit_start_freq[%2.2lu]", wszSubtestName, j);
			if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
			{
				// We read this parameter successfully before.  Something is wrong if we can't read it now
				err_CantReadRecordNoiseLimit();
				return false;
			}
			gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartFreq = wcstod(pwszStringParam, NULL);
			swprintf(wszTempString, L"%s.record.noise_limit_stop_freq[%2.2lu]", wszSubtestName, j);
			if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopFreq = gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartFreq;  // The end frequency of this range is not specified, so effectively make the range 0 Hz
			else
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopFreq = wcstod(pwszStringParam, NULL);
			swprintf(wszTempString, L"%s.record.noise_limit_start_level[%2.2lu]", wszSubtestName, j);
			if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel = 100;  // 100 dB above the effective 0 dB level makes the acceptable noise range almost infinite (so we won't get any failures)
			else
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel = wcstod(pwszStringParam, NULL);
			swprintf(wszTempString, L"%s.record.noise_limit_stop_level[%2.2lu]", wszSubtestName, j);
			if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL) // Parameter did not exist
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopLevel = gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel;  // The end level will default to the same amplitude as the start level
			else
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopLevel = wcstod(pwszStringParam, NULL);
		}
	}

	if ((gpWaveRecordConfigurationData->WaveChannelFreqData = new WAVE_RECORD_CHANNEL_FREQ_DATA[gpWaveRecordConfigurationData->dwNumberOfChannels]) == NULL)  // Create an array of WAVE_RECORD_CHANNEL_FREQ_DATA structures; one per channel
	{
		err_AllocWaveRecordChannelFreqDataL(sizeof(WAVE_RECORD_CHANNEL_FREQ_DATA)*gpWaveRecordConfigurationData->dwNumberOfChannels);
		return false;
	}
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++) // Set all of the double array pointers to NULL for safety
	{
		gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency = NULL;
		gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude = NULL;
	}

	// Read in record configuration parameters for all channels of this test
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)
	{
		swprintf(wszTempString, L"%s.record.ch[%2.2lu]_freq[%2.2lu]", wszSubtestName, j, 0);

		// Need to check for the presence of the parameter, and then load with defaults if it does not exist
		if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)  // No frequencies are specified for this channel
		{
			gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = 0;
		}
/*
		{
			if ((j & 0x1) == 0)  // Channels 0,2,4,6,8,... get this set of frequencies by default
			{
				pdblDtaRecordChannelFrequencies = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[0].pdblFrequency;
				pdblDtaRecordChannelAmplitudes = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[0].pdblAmplitude;
				gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[0].dwNumberOfFrequencies;
			}
			else  // Channels 1,3,5,7,9,... get this set of frequencies by default
			{
				pdblDtaRecordChannelFrequencies = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[1].pdblFrequency;
				pdblDtaRecordChannelAmplitudes = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[1].pdblAmplitude;
				gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[1].dwNumberOfFrequencies;
			}
			if ((gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency = new double[gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies]) == NULL)  // Create an array of double to contain frequencies
			{
				err_AllocDoublesForRecordFreqL(sizeof(double)*gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies);
				return false;
			}
			if ((gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude = new double[gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies]) == NULL)  // Create an array of double to contain Amplitude
			{
				err_AllocDoublesForRecordAmplitudeL(sizeof(double)*gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies);
				return false;
			}
			for (k = 0; k < gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
			{
				gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = pdblDtaRecordChannelFrequencies[k];
				gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude[k] = pdblDtaRecordChannelAmplitudes[k];
			}
		}
*/
		else  // Frequencies have been specified for this channel, so read them in
		{
			for (k = 1; k > 0; k++) // Count the number of frequencies on this channel; terminate only with the break inside the loop
			{
				swprintf(wszTempString, L"%s.record.ch[%2.2lu]_freq[%2.2lu]", wszSubtestName, j, k);
				if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)
						break;
			}
			gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies = k;
			if ((gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency = new double[k]) == NULL)  // Create an array of double to contain frequencies
			{
				err_AllocDoublesForRecordFreqL(sizeof(double)*k);
				return false;
			}
			if ((gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude = new double[k]) == NULL)  // Create an array of double to contain Amplitude
			{
				err_AllocDoublesForRecordAmplitudeL(sizeof(double)*k);
				return false;
			}
			// Now that we know how many frequencies there are, let's read them in
			for (k = 0; k < gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
			{
				swprintf(wszTempString, L"%s.record.ch[%2.2lu]_freq[%2.2lu]", wszSubtestName, j, k);
				if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)
				{
					// We read this parameter successfully before.  Something is wrong if we can't read it now
					err_CantReadRecordFreqData();
					return false;
				}
				if ((gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = wcstod(pwszStringParam, NULL)) == 0)
					gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = FLT_MIN;
				swprintf(wszTempString, L"%s.record.ch[%2.2lu]_amplitude[%2.2lu]", wszSubtestName, j, k);
				if ((pwszStringParam = GetCfgString (wszTempString, NULL)) == NULL)
				{
					// If there is no matching amplitude for this frequency, just pull the default amplitude from the first frequency of the first channel of the default configuration
					gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude[k] = gRecordTestConfigurations[DEFAULT_RECORD_TEST_CONFIGURATION].data->WaveChannelFreqData[0].pdblAmplitude[0];
				}
				else
					gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude[k] = wcstod(pwszStringParam, NULL);
			}
		}
	}

	// ************************* Now get mixer parameters ************************

	// Let's do Audio Mux parameters before the mixer parameters because they are easier.
	// Allocate an AUDIO_MUX_CONFIGURATION_INFORMATION structure
	if ((gpAudioMuxConfigurationInformation = new AUDIO_MUX_CONFIGURATION_INFORMATION) == NULL)
	{
		err_AllocAudioMuxConfigInfoL(sizeof(AUDIO_MUX_CONFIGURATION_INFORMATION));
		return false;
	}

	// Get gpAudioMuxConfigurationInformation parameters
	swprintf(wszTempString, L"%s.mixer.mux_control_low_dword", wszSubtestName);
	gpAudioMuxConfigurationInformation->dwMuxControlLowDWORD = (DWORD)GetCfgUint (wszTempString, DEFAULT_AUDIO_MUX_LOW_DWORD);

	swprintf(wszTempString, L"%s.mixer.mux_control_high_dword", wszSubtestName);
	gpAudioMuxConfigurationInformation->dwMuxControlHighDWORD = (DWORD)GetCfgUint (wszTempString, DEFAULT_AUDIO_MUX_HIGH_DWORD);

	// Get the mixer name
	swprintf(wszTempString, L"%s.%s.%s", wszSubtestName, L"mixer", L"device_name");
	gpwszAudioMixerName = (unsigned short *)GetCfgString (wszTempString, L"none");

	if (wcsicmp(gpwszAudioMixerName, L"none") != 0)  // The mixer name was defined
	{
		// Read in all mixer configuration parameters in list form
		for (gdwNumberOfMixerControls = 0;; gdwNumberOfMixerControls++)
		{
			swprintf(wszTempString, L"%s.mixer.m[%3.3lu]", wszSubtestName, gdwNumberOfMixerControls);
			if ((pwszValue = (unsigned short *)GetCfgString (wszTempString, NULL)) == NULL)
				break; // We reached the end of the list
			// Put the value into the parameter buffer
			*pCSMixer << (LPCTSTR)pwszValue;
		}
	}

	return true;
}


/*
void vAnalogPlayback(void)
{
	DWORD dwStatus = FAIL;

	while ((gdwMaxTestRetries != 0) && (dwStatus == FAIL))
	{
		if (gdwMaxTestRetries == 1)
			gdwIgnoreError = FALSE;
		else
			gdwIgnoreError = TRUE;
		dwStatus = dwAnalogPlayback();
		gdwMaxTestRetries--;
	}
	return;
}
*/


DWORD CXModuleAudio::dwAnalogPlayback(void)
{
	DWORD j, k;
	DWORD dwLocalStatus = PASS;
	WORD wSampleFormat = WAVE_FORMAT_PCM;
	DWORD dwPlaybackBytesPerSample, dwRecordBytesPerSample;
	DWORD dwWaveOutBufferSize, dwWaveInBufferSize;
	double dblActualSignalToNoiseRatio;
	double dblActualChannelSeparation;
	double dblActualFrequencyResponse;
	DWORD dwAmountOfLeadingRecordedAudioToThrowAway;
	DSBUFFERDESC dsBufferDesc;
	DWORD dwDelayBetweenPlaybackStartAndRecordStart;
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	int iError;
	LPBYTE pBMixerControls = NULL;
	int iMixerControlBufferLength = 0;

#ifndef _XBOX // Win32
	char *pcTemp = NULL;
	DWORD dwWaveFormatExSize, dwWaveFormatExSize2;
	void *pFirstDSBufferLoc, *pSecondDSBufferLoc;
	DWORD dwFirstDSBufferSize, dwSecondDSBufferSize;
	DWORD *pdwBufferBase;

	gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID = NULL;  // Initialize the playback GUID to NULL
	// Check to be sure the specified playback device is present.  If it is not, silently use the first installed playback device
	if(DirectSoundEnumerate((LPDSENUMCALLBACK)bDSEnumCallback, this) != DS_OK)
	{
		err_DirectSoundEnumerateFailed();
		return(FAIL);
	}
	if(gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID == NULL)
	{
		err_DirectSoundFindFailed();
		return(FAIL);
	}
	// The playback device GUID is now correct
#endif
	// This will simply print out the values of the configuration parameters (in Win32)
/*
	wprintf(L"Trys = %lu\n", gdwMaxTestTrys);
	wprintf(L"Delay between playback start and record start = %lu\n", gdwDelayBetweenPlaybackStartAndRecordStart);
	wprintf(L"Mutex Timeout = %lu\n", gdwMutexTimeout);
	wprintf(L"Playback device number = %lu\n", (DWORD)gpWavePlaybackConfigurationData->uiAudioOutDevToUse);
	wprintf(L"Playback number of channels = %lu\n", gpWavePlaybackConfigurationData->dwNumberOfChannels);
	wprintf(L"Playback sample rate = %lu\n", gpWavePlaybackConfigurationData->dwSampleRate);
	wprintf(L"Playback bits per sample = %lu\n", gpWavePlaybackConfigurationData->dwBitsPerSample);
	wprintf(L"Playback digital attenuation = %lu\n", gpWavePlaybackConfigurationData->dwDigitalAttenuation);
	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		for (k = 0; k < gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
		{
			wprintf(L"Channel %lu frequency %lu value is %lf\n", j, k, gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k]);
		}
	}
	wprintf(L"Record device number = %lu\n", (DWORD)gpWaveRecordConfigurationData->uiAudioInDevToUse);
	wprintf(L"Record number of channels = %lu\n", gpWaveRecordConfigurationData->dwNumberOfChannels);
	wprintf(L"Record sample rate = %lu\n", gpWaveRecordConfigurationData->dwSampleRate);
	wprintf(L"Record bits per sample = %lu\n", gpWaveRecordConfigurationData->dwBitsPerSample);
	wprintf(L"Record FFT Window function = %lu\n", gpWaveRecordConfigurationData->dwFFTWindowFunction);
	wprintf(L"Record amplitude tolerance = %lf\n", gpWaveRecordConfigurationData->dblAmplitudeTolerance);
	wprintf(L"Record max DC offset percent = %lf\n", gpWaveRecordConfigurationData->dblMaxDCOffsetPercent);
	wprintf(L"Record signal to noise ratio = %lf\n", gpWaveRecordConfigurationData->dblSignalToNoiseRatio);
	wprintf(L"Record S/N ratio ignoring crosstalk = %lf\n", gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk);
	wprintf(L"Record channel separation = %lf\n", gpWaveRecordConfigurationData->dblChannelSeparation);
	wprintf(L"Record frequency response tolerance = %lf\n", gpWaveRecordConfigurationData->dblFrequencyResponseTolerance);
	wprintf(L"Record frequency response level = %lf\n", gpWaveRecordConfigurationData->dblFrequencyResponseLevel);
	wprintf(L"Record frequency shift percent allowed = %lf\n", gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed);
	wprintf(L"Record frequency shift hz allowed = %lf\n", gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed);
	wprintf(L"Record CRC = %8.8lx\n", gpWaveRecordConfigurationData->dwCRC);
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfNoiseRanges; j++)
	{
		wprintf(L"Noise range %lu start frequency value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartFreq);
		wprintf(L"Noise range %lu stop frequency value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopFreq);
		wprintf(L"Noise range %lu start level value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel);
		wprintf(L"Noise range %lu stop level value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopLevel);
	}
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)
	{
		for (k = 0; k < gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
		{
			wprintf(L"Channel %lu freq %lu value is %lf, amp = %lf\n", j, k, gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency[k], gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude[k]);
		}
	}

*/

	// Now fix up the frequencies to fit in the playback buffer 
	// and calculate the SamplesPerPeriod from the Frequency values 
	vFixUpPlaybackFrequencies();
	vCalculateSamplesPerPeriod();

	// ***** Setup for playback
    // This assumes that 17-24 bit samples will use 3 bytes per sample
	dwPlaybackBytesPerSample = (gpWavePlaybackConfigurationData->dwBitsPerSample + 7) / 8;
	dwWaveOutBufferSize = dwPlaybackBytesPerSample * 
						  gpWavePlaybackConfigurationData->dwNumberOfChannels * 
						  WAVE_OUT_NUMBER_OF_SAMPLES;

	// *** At this point a mutex should indicate that we are using audio resources
	if (dwGetPossessionOfAudioResources(gdwMutexTimeout) != PASS)
			return(FAIL);

	// Create an IDirectSound interface for playing audio
#ifdef _XBOX

	if (DirectSoundCreate(NULL, &pDSoundOut, NULL) != DS_OK)
	{
		err_CouldNotCreateIDirectSound();
		return(FAIL);
	}
#else // not _XBOX (Win32)
	if (DirectSoundCreate8(gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID, &pDSoundOut, NULL) != DS_OK)
	{
		err_CouldNotCreateIDirectSound();
		return(FAIL);
	}
	// Get a window handle; this will change in the future (XBox will probably not require a Window handle)
	hDSWnd = GetForegroundWindow();
	if (hDSWnd == NULL)
	{
		hDSWnd = GetDesktopWindow();
	}

	if (pDSoundOut->SetCooperativeLevel(hDSWnd, DSSCL_EXCLUSIVE) != DS_OK)
	{
		err_CouldNotSetCooperativeLevel();
		return(FAIL);
	}

	// Now set up the primary sound buffer characteristics
	memset(&dsBufferDesc, 0, sizeof(DSBUFFERDESC));
	dsBufferDesc.dwSize = sizeof(DSBUFFERDESC);
	dsBufferDesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
	dsBufferDesc.dwReserved = 0;
	dsBufferDesc.dwBufferBytes = 0; // Set to 0 for a primary buffer
	dsBufferDesc.lpwfxFormat = NULL; // NULL for a primary buffer
	dsBufferDesc.guid3DAlgorithm = GUID_NULL;

	if (pDSoundOut->CreateSoundBuffer(&dsBufferDesc, &pPrimaryBuffer, NULL)  != DS_OK)
	{
		err_CouldNotGetAccessToPrimaryBuffer();
		return(FAIL);
	}
/*
	// This is here just in case we need to change to IDirectSoundBuffer8 access of primary buffers
	if (pPrimaryBufferPre8->QueryInterface(IID_IDirectSoundBuffer8, (LPVOID *)&pPrimaryBuffer)  != S_OK) // Get the IDirectSoundBuffer8 interface
	{
		err_CouldNotGetAccessToPrimaryIDirectSoundBuffer8Interface();
		return(FAIL);
	}
*/
	if ((WaveFormatex = new WAVEFORMATEX) == NULL)  // Create a WAVEFORMATX structure
	{
		err_CouldNotAllocateWAVEFORMATEX();
		return FAIL;
	}
	memset(WaveFormatex, 0, sizeof(WAVEFORMATEX));
	WaveFormatex->wFormatTag = wSampleFormat;
	WaveFormatex->nChannels = (WORD)gpWavePlaybackConfigurationData->dwNumberOfChannels;
	WaveFormatex->nSamplesPerSec = gpWavePlaybackConfigurationData->dwSampleRate;
	WaveFormatex->nBlockAlign = (WORD)(gpWavePlaybackConfigurationData->dwNumberOfChannels * dwPlaybackBytesPerSample);
	WaveFormatex->nAvgBytesPerSec = gpWavePlaybackConfigurationData->dwSampleRate * (DWORD)WaveFormatex->nBlockAlign;
	WaveFormatex->wBitsPerSample = (WORD)gpWavePlaybackConfigurationData->dwBitsPerSample;
	WaveFormatex->cbSize = 0;

	if (pPrimaryBuffer->SetFormat(WaveFormatex) != DS_OK)
	{
		err_CouldNotSetPrimaryBufferFormat();
		return(FAIL);
	}
	delete WaveFormatex;
	WaveFormatex = NULL;

	// Read back the format to make sure the hardware really supports it
	if (pPrimaryBuffer->GetFormat(NULL, 0, &dwWaveFormatExSize) != DS_OK)
	{
		err_CouldNotReadPrimaryBufferFormat();
		return(FAIL);
	}
	if ((pcTemp = new char [dwWaveFormatExSize]) == NULL)  // Create a WAVEFORMATEX structure
	{
		err_CouldNotAllocateWAVEFORMATEX();
		return FAIL;
	}
	WaveFormatex = (WAVEFORMATEX *)pcTemp;
	memset(WaveFormatex, 0, dwWaveFormatExSize);
	if (pPrimaryBuffer->GetFormat(WaveFormatex, dwWaveFormatExSize, &dwWaveFormatExSize2) != DS_OK) // Get the actual WAVEFORMATEX data
	{
		delete [] pcTemp; // Clean up this stuff
		pcTemp = NULL;
		WaveFormatex = NULL;
		err_CouldNotReadPrimaryBufferFormat();
		return(FAIL);
	}
	if (dwWaveFormatExSize != dwWaveFormatExSize2) // The whole structure had better be filled in
	{
		delete [] pcTemp; // Clean up this stuff
		pcTemp = NULL;
		WaveFormatex = NULL;
		err_CouldNotReadPrimaryBufferFormat();
		return(FAIL);
	}
	// Compare what we set to what the hardware supports
	if ((WaveFormatex->wFormatTag != wSampleFormat) ||
	    (WaveFormatex->nChannels != (WORD)gpWavePlaybackConfigurationData->dwNumberOfChannels) ||
	    (WaveFormatex->nSamplesPerSec != gpWavePlaybackConfigurationData->dwSampleRate) ||
	    (WaveFormatex->nBlockAlign != (WORD)(gpWavePlaybackConfigurationData->dwNumberOfChannels * dwPlaybackBytesPerSample)) ||
	    (WaveFormatex->nAvgBytesPerSec != gpWavePlaybackConfigurationData->dwSampleRate * (DWORD)WaveFormatex->nBlockAlign) ||
	    (WaveFormatex->wBitsPerSample != (WORD)gpWavePlaybackConfigurationData->dwBitsPerSample))
	{
		delete [] pcTemp; // Clean up this stuff
		pcTemp = NULL;
		WaveFormatex = NULL;
		err_PlaybackAudioFormatNotSupported();
		return(FAIL);
	}
	delete [] pcTemp; // Clean up this stuff
	pcTemp = NULL;
	WaveFormatex = NULL;
#endif

	// Now set up the secondary sound buffer characteristics
	if ((WaveFormatex = new WAVEFORMATEX) == NULL)  // Create a WAVEFORMATX structure
	{
		err_CouldNotAllocateWAVEFORMATEX();
		return FAIL;
	}

	// Find the largest number of frequencies in a channel
	dwNumberOfFrequencies = 0;
	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		if (gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies > dwNumberOfFrequencies)
			dwNumberOfFrequencies = gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies;
	}
	if ((pSecondaryBufferPre8 = new LPDIRECTSOUNDBUFFER[dwNumberOfFrequencies]) == NULL)  // Create an array of pointers to secondary DS sound buffers
	{
		err_CouldNotAllocateLPDIRECTSOUNDBUFFERArray();
		return FAIL;
	}
	for (j = 0; j < dwNumberOfFrequencies; j++) // Initialize these to NULL for safety
		pSecondaryBufferPre8[j] = NULL;
	if ((pSecondaryBuffer = new LPDIRECTSOUNDBUFFER8[dwNumberOfFrequencies]) == NULL)  // Create an array of pointers to secondary DS8 sound buffers
	{
		err_CouldNotAllocateLPDIRECTSOUNDBUFFER8Array();
		return FAIL;
	}
	for (j = 0; j < dwNumberOfFrequencies; j++) // Initialize these to NULL for safety
		pSecondaryBuffer[j] = NULL;

	if ((ppdwWaveOutBuffer = new DWORD *[dwNumberOfFrequencies]) == NULL)  // Create an array of pointers to data buffers
	{
		err_CouldNotAllocateWaveOutBufferArray();
		return FAIL;
	}
	for (j = 0; j < dwNumberOfFrequencies; j++) // Initialize these to NULL for safety
		ppdwWaveOutBuffer[j] = NULL;

	// Create a secondary buffer for each frequency
	for (j = 0; j < dwNumberOfFrequencies; j++)
	{
		// Allocate a buffer for the audio for this frequency, and put the frequency data in it
		if ((ppdwWaveOutBuffer[j] = (DWORD *)VirtualAlloc(NULL, dwWaveOutBufferSize, MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE)) == NULL)
		{
			err_CouldNotAllocatePlaybackBuffer(dwWaveOutBufferSize);
			return FAIL;
		}

		// Generate a sine wave in each channel of this buffer
		if (dwGenSingleSineWave(ppdwWaveOutBuffer[j], 
						  gpWavePlaybackConfigurationData->dwBitsPerSample, 
						  FFT_SIZE, 
						  gpWavePlaybackConfigurationData->WaveChannelFreqData, 
						  gpWavePlaybackConfigurationData->dwNumberOfChannels, 
						  gpWavePlaybackConfigurationData->dwDigitalAttenuation,
						  j) != PASS)
			return(FAIL);  // We failed for some reason
		for (k = 1; k < (WAVE_OUT_NUMBER_OF_SAMPLES/FFT_SIZE); k++) // Duplicate generated data throughout the rest of the playback buffer
			memcpy((char *)ppdwWaveOutBuffer[j]+(k*(dwWaveOutBufferSize/(WAVE_OUT_NUMBER_OF_SAMPLES/FFT_SIZE))), ppdwWaveOutBuffer[j], (dwWaveOutBufferSize/(WAVE_OUT_NUMBER_OF_SAMPLES/FFT_SIZE)));

		memset(WaveFormatex, 0, sizeof(WAVEFORMATEX));
		WaveFormatex->wFormatTag = wSampleFormat;
		WaveFormatex->nChannels = (WORD)gpWavePlaybackConfigurationData->dwNumberOfChannels;
		WaveFormatex->nSamplesPerSec = gpWavePlaybackConfigurationData->dwSampleRate;
		WaveFormatex->nBlockAlign = (WORD)(gpWavePlaybackConfigurationData->dwNumberOfChannels * dwPlaybackBytesPerSample);
		WaveFormatex->nAvgBytesPerSec = gpWavePlaybackConfigurationData->dwSampleRate * (DWORD)WaveFormatex->nBlockAlign;
		WaveFormatex->wBitsPerSample = (WORD)gpWavePlaybackConfigurationData->dwBitsPerSample;
		WaveFormatex->cbSize = 0;

#ifdef _XBOX
		memset(&dsBufferDesc, 0, sizeof(DSBUFFERDESC));
		dsBufferDesc.dwSize = sizeof(DSBUFFERDESC);
		dsBufferDesc.dwFlags = DSBCAPS_CTRLVOLUME;
		dsBufferDesc.dwBufferBytes = dwWaveOutBufferSize;
		dsBufferDesc.lpwfxFormat = WaveFormatex;

		if (pDSoundOut->CreateSoundBuffer(&dsBufferDesc, &pSecondaryBuffer[j], NULL) != DS_OK)
		{
			err_CouldNotGetAccessToSecondaryBuffer();
			return(FAIL);
		}

		// Set the headroom to 0 so that samples are not digitally attenuated.
		if (pSecondaryBuffer[j]->SetHeadroom(0) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		// Set the volume to maximum (no attenuation of digital buffer contents)
		if (pSecondaryBuffer[j]->SetVolume(DSBVOLUME_MAX) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		// Point to the data buffer.
		if (pSecondaryBuffer[j]->SetBufferData(ppdwWaveOutBuffer[j], dwWaveOutBufferSize) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferData();
			return(FAIL);
		}

#else // Win32
		memset(&dsBufferDesc, 0, sizeof(DSBUFFERDESC));
		dsBufferDesc.dwSize = sizeof(DSBUFFERDESC);
		dsBufferDesc.dwFlags = DSBCAPS_CTRLVOLUME |
							   DSBCAPS_CTRLPAN |
							   DSBCAPS_GLOBALFOCUS |
							   DSBCAPS_STATIC;
		dsBufferDesc.dwReserved = 0;
		dsBufferDesc.dwBufferBytes = dwWaveOutBufferSize;
		dsBufferDesc.lpwfxFormat = WaveFormatex;
		dsBufferDesc.guid3DAlgorithm = GUID_NULL;

		if (pDSoundOut->CreateSoundBuffer(&dsBufferDesc, &pSecondaryBufferPre8[j], NULL) != DS_OK)
		{
			err_CouldNotGetAccessToSecondaryBuffer();
			return(FAIL);
		}

		if (pSecondaryBufferPre8[j]->QueryInterface(IID_IDirectSoundBuffer8, (LPVOID *)&pSecondaryBuffer[j])  != S_OK) // Get the IDirectSoundBuffer8 interface
		{
			err_CouldNotGetAccessToSecondaryIDirectSoundBuffer8Interface();
			return(FAIL);
		}

		// Set the volume to maximum (no attenuation of digital buffer contents)
		if (pSecondaryBuffer[j]->SetVolume(DSBVOLUME_MAX) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		// Set the panning to center
		if (pSecondaryBuffer[j]->SetPan(DSBPAN_CENTER) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferPanning();
			return(FAIL);
		}
		// Lock the entire secondary sound buffer so that we can copy data into it
		if (pSecondaryBuffer[j]->Lock(0, dwWaveOutBufferSize, &pFirstDSBufferLoc, &dwFirstDSBufferSize, &pSecondDSBufferLoc, &dwSecondDSBufferSize, DSBLOCK_ENTIREBUFFER) != DS_OK)
		{
			err_CouldNotLockSecondaryBuffer();
			return(FAIL);
		}
		if ((dwFirstDSBufferSize + dwSecondDSBufferSize) != dwWaveOutBufferSize) // Make sure that the whole buffer was locked
		{
			err_LockedSecondaryBufferSegmentWrongSize(dwWaveOutBufferSize, dwFirstDSBufferSize + dwSecondDSBufferSize);
			return(FAIL);
		}
		// Point pdwBufferBase to the real base of the buffer
		if (pFirstDSBufferLoc == NULL)
			pdwBufferBase = (DWORD *)pSecondDSBufferLoc;
		else if (pSecondDSBufferLoc == NULL)
			pdwBufferBase = (DWORD *)pFirstDSBufferLoc;
		else if (pSecondDSBufferLoc > pFirstDSBufferLoc)
			pdwBufferBase = (DWORD *)pFirstDSBufferLoc;
		else
			pdwBufferBase = (DWORD *)pSecondDSBufferLoc;

		// Copy the contents of the data buffer to the buffer that CreateSoundBuffer gave us.
		memcpy(pdwBufferBase, (char *)ppdwWaveOutBuffer[j], dwWaveOutBufferSize);

		// Now, let's unlock the secondary buffer
		if (pSecondaryBuffer[j]->Unlock(pFirstDSBufferLoc, dwFirstDSBufferSize, pSecondDSBufferLoc, dwSecondDSBufferSize) != DS_OK)
		{
			err_CouldNotUnlockSecondaryBuffer();
			return(FAIL);
		}
#endif
	}
	delete WaveFormatex;
	WaveFormatex = NULL;

	dwRecordBytesPerSample = (gpWaveRecordConfigurationData->dwBitsPerSample+7)/8;  // This assumes that 17-24 but samples will use 3 bytes per sample
	dwWaveInBufferSize = dwRecordBytesPerSample * 
						 gpWaveRecordConfigurationData->dwNumberOfChannels * 
						 WAVE_IN_NUMBER_OF_SAMPLES;
	// Allocate memory for the waveform data.
	// This should be wBytesPerSample*wNumberOfChannels*WAVE_IN_NUMBER_OF_SAMPLES bytes long
	if ((pdwWaveInBuffer = new DWORD [dwWaveInBufferSize/(sizeof(DWORD))]) == NULL)  // Divide by 4 to correct for the fact that this a DWORD pointer
	{
		err_CouldNotAllocateRecordBuffer(dwWaveInBufferSize);
		return(FAIL);
	}
	// Now, let's play the secondary buffer in a continuous loop
	for (j = 0; j < dwNumberOfFrequencies; j++)
	{
		if (pSecondaryBuffer[j]->Play(0, 0, DSBPLAY_LOOPING) != DS_OK)
		{
			err_CouldNotPlaySecondaryBuffer();
			return(FAIL);
		}
	}

	// Figure out how many milliseconds of audio we will record before getting to data we will actually analyze
	dwAmountOfLeadingRecordedAudioToThrowAway = (((WAVE_IN_NUMBER_OF_SAMPLES/2)-16)*1000)/gpWaveRecordConfigurationData->dwSampleRate;

	if (gdwDelayBetweenPlaybackStartAndRecordStart > dwAmountOfLeadingRecordedAudioToThrowAway)
		dwDelayBetweenPlaybackStartAndRecordStart = gdwDelayBetweenPlaybackStartAndRecordStart - dwAmountOfLeadingRecordedAudioToThrowAway;
	else
		dwDelayBetweenPlaybackStartAndRecordStart = 0;

	// Create a parameter buffer and stuff it with parameters to send to the host
	// revision - DWORD revision of the data structure.  Rev 1 is listed here
	// audio_mux_com_port - DWORD indicating the COM port that the audio mux is attached to
	// mux_control_low_dword - DWORD indicating the low 32 bits of the audio mux setting
	// mux_control_high_dword - DWORD indicating the high 32 bits of the audio mux setting
	// mixer_name - string.  The name of the mixer to adjust for recording.  "none" indicates no mixer is to be used
	// number_of_mixer_controls - DWORD indicating how many mixer control strings are in the following list
	// mixer_controls - list of strings indicating the names and settings of all mixer controls to be adjusted
	// wave_input_device_name - string.  The name "none" implies that the default analog record device should be used
	// number_of_channels - DWORD indicating how many channels to record
	// sample_rate - DWORD indicating the record rate in KHz
	// bits_per_sample - DWORD indicating the resolution of the recording (8 and 16 are common)
	// wave_input_number_of_samples - DWORD indicating the number of samples to capture to the returned buffer
	// delay_between_playback_start_and_record_start - DWORD inidcating the delay between playback starting and record starting

	CStore CSParams(32768);  // The list of mixer parameters could get very long
	CSParams << (DWORD)(PARAMETER_REV_FOR_AUDIO_RECORD_ANALOG);
	CSParams << gdwAudioMuxComPort;
	CSParams << gpAudioMuxConfigurationInformation->dwMuxControlLowDWORD;
	CSParams << gpAudioMuxConfigurationInformation->dwMuxControlHighDWORD;
	CSParams << (LPCTSTR)gpwszAudioMixerName;
	CSParams << gdwNumberOfMixerControls;
	pBMixerControls = pCSMixer->GetBuffer();
	iMixerControlBufferLength = pCSMixer->GetLength();
	for (j = 0; j < (DWORD)iMixerControlBufferLength; j++) // Copy the mixer controls to the buffer we will send to the host
	{
		CSParams << pBMixerControls[j];
	}
	CSParams << (LPCTSTR)gpWaveRecordConfigurationData->pwszAudioInDevName;
	CSParams << gpWaveRecordConfigurationData->dwNumberOfChannels;
	CSParams << gpWaveRecordConfigurationData->dwSampleRate;
	CSParams << gpWaveRecordConfigurationData->dwBitsPerSample;
	CSParams << (DWORD)(WAVE_IN_NUMBER_OF_SAMPLES);
	CSParams << dwDelayBetweenPlaybackStartAndRecordStart;
	// Send message to record audio here
	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_AUDIO_RECORD_ANALOG, (char *)CSParams.GetBuffer(), CSParams.GetLength(), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, AUDIO_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			return(FAIL);
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			err_HostCommunicationError(iError);
			return(FAIL);
		}
	}
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		err_RecordBufferIsEmpty();
		return(FAIL);
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		if (dwActualBytesReceived < dwWaveInBufferSize)
		{
			err_RecordBufferIsNotCorrectLength(dwWaveInBufferSize, dwActualBytesReceived);
			return(FAIL);
		}
		// We received the record audio buffer the size that we wanted
	}

	memcpy(pdwWaveInBuffer, CHR.pvBufferFromHost, dwWaveInBufferSize);  // Copy the record data to a local buffer for processing

	// Now, let's stop the secondary buffer
	for (j = 0; j < dwNumberOfFrequencies; j++)
	{
		if (pSecondaryBuffer[j]->Stop() != DS_OK)
		{
			err_CouldNotStopPlayingSecondaryBuffer();
			return(FAIL);
		}
	}

	// *** At this point a mutex should indicate that we are done using audio resources
	vReleasePossessionOfAudioResources();

	// Uncomment the 2 lines below to feed the generated sine wave into the input analysis routines directly.  Make sure number of channels, bits per sample, and sample rate are identical between playback and record
	//memcpy(pdwWaveInBuffer, pdwWaveOutBuffer, dwWaveOutBufferSize);  // Copy the generated waveforms to the input buffer to test our analysis algorithms
	//memcpy(pdwWaveInBuffer + dwWaveOutBufferSize, pdwWaveOutBuffer, dwWaveOutBufferSize);  // Copy the generated waveforms to the input buffer to test our analysis algorithms
	if (m_debugmask & BIT0) // Do very verbose messaging at debug bit level 0
	{
		gpF = NULL;
		// The following 4 lines write the raw recorded data to a file
#ifdef _XBOX
		gpF = fopen("Z:\\BUFFER.IN", "wb");
#else // Win32
		gpF = fopen("BUFFER.IN", "wb");
#endif
		if (gpF != NULL)
		{
			fwrite(pdwWaveInBuffer, gpWaveRecordConfigurationData->dwNumberOfChannels*dwRecordBytesPerSample, WAVE_IN_NUMBER_OF_SAMPLES, gpF);
			fclose(gpF);
			gpF = NULL;
		}
		else
		{
			ReportDebug(BIT0, L"Could not open file %s", L"BUFFER.IN");
		}
	}
	// The following 3 lines read in data to the FFT input buffer from a file
	//gpF = fopen("INPUT.raw", "rb");  // Opening info file
	//fread(pdwWaveInBuffer, 1, dwWaveInBufferSize, gpF);
	//fclose(gpF);
	//gpF = NULL;

	// Allocate a buffer to contain the raw input data reorganized into seperate channel blocks
	// No matter how many bits the recorded data was, these buffers will be filled with signed DWORD data
	if ((pslFFTInputBuffer = new SLONG [FFT_SIZE*gpWaveRecordConfigurationData->dwNumberOfChannels]) == NULL)
	{
		err_CouldNotAllocateFFTInputBufferL((unsigned long)(sizeof(SLONG)*FFT_SIZE*gpWaveRecordConfigurationData->dwNumberOfChannels));
		return(FAIL);
	}
	if ((pdblDCOffsetPercents = new double [gpWaveRecordConfigurationData->dwNumberOfChannels]) == NULL)
	{
		err_CouldNotAllocateDCOffsetPercentsL((unsigned long)(sizeof(double)*gpWaveRecordConfigurationData->dwNumberOfChannels));
		return(FAIL);
	}
	// Now let's analyze the data we got back
	// This routine computes DC offset percents for all channels and resorts the data into seperate FFT buffers sections (one per channel); each value is a signed DWORD regardless of how big the recorded values were
	// The pdwWaveInBuffer + XXX term moves the starting point of the resort from sample 0 to sample 4080, 
	// past the end of garbage data left by the driver.
	if (dwTotalDCOffset((pdwWaveInBuffer + (dwRecordBytesPerSample*gpWaveRecordConfigurationData->dwNumberOfChannels*((WAVE_IN_NUMBER_OF_SAMPLES/2)-16))/sizeof(DWORD)), pslFFTInputBuffer,
						gpWaveRecordConfigurationData->dwBitsPerSample, 	FFT_SIZE, 
						gpWaveRecordConfigurationData->dwNumberOfChannels,	pdblDCOffsetPercents) != PASS)
		return(FAIL);  // We failed for some reason
		

	
	if (gpWaveRecordConfigurationData->dblMaxDCOffsetPercent < 100.0)  // See whether any of the channels' DC offsets are out of range
	{
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // This might be included in a larger loop that checks out each channel independently for DC offset, frequency response, THD+N, etc.
		{
			if (wTestNumber == ANALOG_PLAYBACK_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_ANALOG_DC_OFFSET_PERCENT_LEFT_CHANNEL, _T("%.3lf"), pdblDCOffsetPercents[j]);
				else
					ReportStatistic(XAUDIO_ANALOG_DC_OFFSET_PERCENT_RIGHT_CHANNEL, _T("%.3lf"), pdblDCOffsetPercents[j]);
			}
			else if(wTestNumber == ANALOG_SILENCE_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_SILENCE_DC_OFFSET_PERCENT_LEFT_CHANNEL, _T("%.3lf"), pdblDCOffsetPercents[j]);
				else
					ReportStatistic(XAUDIO_SILENCE_DC_OFFSET_PERCENT_RIGHT_CHANNEL, _T("%.3lf"), pdblDCOffsetPercents[j]);
			}
			else // Assume DIGITAL_PLAYBACK_TEST
			{
				if (j == 0)
					ReportStatistic(XAUDIO_DIGITAL_DC_OFFSET_PERCENT_LEFT_CHANNEL, _T("%.3lf"), pdblDCOffsetPercents[j]);
				else
					ReportStatistic(XAUDIO_DIGITAL_DC_OFFSET_PERCENT_RIGHT_CHANNEL, _T("%.3lf"), pdblDCOffsetPercents[j]);
			}
//			ReportDebug(BIT0, L"Channel %lu DC offset = %5.2lf%%\n", j, pdblDCOffsetPercents[j]);
			if (pdblDCOffsetPercents[j] > gpWaveRecordConfigurationData->dblMaxDCOffsetPercent)
			{
				err_DCOffsetsOutOfRangeLSDD(j, (gpWaveRecordConfigurationData->pchChannelLabel != NULL) ? gpWaveRecordConfigurationData->pchChannelLabel[j] : L"", pdblDCOffsetPercents[j], gpWaveRecordConfigurationData->dblMaxDCOffsetPercent);
				dwLocalStatus = FAIL;
			}
		}
	}
	if ((pdblNoiseLimitValues = new double [FFT_SIZE/2]) == NULL)  // This buffer will contain the noise limit value for each FFT bin
	{
		err_CouldNotAllocateNoiseLimitsL((unsigned long)(sizeof(double)*(FFT_SIZE/2)));
		return(FAIL);
	}
	vCalculateRecordNoiseLimit(pdblNoiseLimitValues, FFT_SIZE, gpWaveRecordConfigurationData->dwBitsPerSample, gpWaveRecordConfigurationData->dwSampleRate, gpWaveRecordConfigurationData->WaveRecordNoiseLimit, gpWaveRecordConfigurationData->dwNumberOfNoiseRanges);
	// Allocate a buffer large enough to store the FFT magnitude results for all channels
	if ((pdwMagnitudeValues = new DWORD [(FFT_SIZE/2) * gpWaveRecordConfigurationData->dwNumberOfChannels]) == NULL)  // This buffer will contain the magnitude value for each FFT bin
	{
		err_CouldNotAllocateFFTMagnitudeL((unsigned long)(sizeof(DWORD)*(FFT_SIZE/2) * gpWaveRecordConfigurationData->dwNumberOfChannels));
		return(FAIL);
	}

	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // Compute the FFT of all channels
	{
		if (dwComputeFFT(&(pslFFTInputBuffer[FFT_SIZE*j]), &(pdwMagnitudeValues[(FFT_SIZE/2)*j]), FFT_BITS, FFT_SIZE, (double)TWO_PI, (double)PI_OVER_TWO, gpWaveRecordConfigurationData->dwFFTWindowFunction) != PASS)
			return(FAIL);
	}

	if (m_debugmask & BIT0) // Do very verbose messaging at debug bit level 0
	{
		gpF = NULL;
		// Write FFT info from all channels to a file
#ifdef _XBOX
		gpF = fopen("Z:\\FFT.IN", "wb");
#else // Win32
		gpF = fopen("FFT.IN", "wb");
#endif
		if (gpF != NULL)
		{
			for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)
			{
				for (k = 0; k < FFT_SIZE/2; k++)
				{
					if (pdwMagnitudeValues[((FFT_SIZE/2)*j)+k] != 0)
						fprintf(gpF, "channel %lu fft bin %4.1lu = %5.1lu Hz  magnitude = %10.1lu, %07.2lf dB\n", j, k, ((gpWaveRecordConfigurationData->dwSampleRate * k)/FFT_SIZE), pdwMagnitudeValues[((FFT_SIZE/2)*j)+k], 20*log10((double)pdwMagnitudeValues[((FFT_SIZE/2)*j)+k]/(double)(((double)((DWORD)1 << (gpWaveRecordConfigurationData->dwBitsPerSample-2)))*(double)FFT_SIZE)));
					else
						fprintf(gpF, "channel %lu fft bin %4.1lu = %5.1lu Hz  magnitude = %10.1lu, -XXX.XX dB\n", j, k, ((gpWaveRecordConfigurationData->dwSampleRate * k)/FFT_SIZE), pdwMagnitudeValues[((FFT_SIZE/2)*j)+k]);
				}
			}
			fclose(gpF);
			gpF = NULL;
		}
		else
		{
			ReportDebug(BIT0, L"Could not open file %s", L"FFT.IN");
		}
	}

	// Now compare the received FFT to the expected frequencies and the noise limits
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // Compute the S/N ratio of all channels
	{
		if (dwCompareFrequenciesAndNoise(&(pdwMagnitudeValues[(FFT_SIZE/2)*j]), FFT_SIZE, *gpWaveRecordConfigurationData, j, pdblNoiseLimitValues) != PASS)
			dwLocalStatus = FAIL;
	}
	// Now we can perform other measurements on the FFT data.
	// Let's compare the S/N ratio
	if (gpWaveRecordConfigurationData->dblSignalToNoiseRatio != 0)  // Check S/N ratio if it is anything other than 0 dB
	{
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // Compute the S/N ratio of all channels
		{
			if (dwComputeSignalToNoise(&(pdwMagnitudeValues[(FFT_SIZE/2)*j]), FFT_SIZE, gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed, gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency, gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies, gpWaveRecordConfigurationData->dwSampleRate, pdblNoiseLimitValues, gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed, &dblActualSignalToNoiseRatio) != PASS)
				return(FAIL);
			if (wTestNumber == ANALOG_PLAYBACK_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_LEFT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
				else
					ReportStatistic(XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_RIGHT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
			}
			else if (wTestNumber == ANALOG_SILENCE_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_LEFT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
				else
					ReportStatistic(XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_RIGHT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
			}
			else // Assume DIGITAL_PLAYBACK_TEST
			{
				if (j == 0)
					ReportStatistic(XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_LEFT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
				else
					ReportStatistic(XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_RIGHT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
			}
			if (gpWaveRecordConfigurationData->dblSignalToNoiseRatio > dblActualSignalToNoiseRatio)
			{
				err_SignalToNoiseRatioTooSmallLSDD(j, (gpWaveRecordConfigurationData->pchChannelLabel != NULL) ? gpWaveRecordConfigurationData->pchChannelLabel[j] : L"", gpWaveRecordConfigurationData->dblSignalToNoiseRatio, dblActualSignalToNoiseRatio);
				dwLocalStatus = FAIL;
			}
		}
	}

	// Let's compare the S/N ratio ignoring cross-talk frequencies
	if (gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk != 0)  // Check S/N ratio ignoring crosstalk frequencies to see if it is anything other than 0 dB
	{
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // Compute the S/N ratio of all channels, ignoring crosstalk frequencies from other channels
		{
			if (dwComputeSignalToNoiseIgnoringCrosstalk(&(pdwMagnitudeValues[(FFT_SIZE/2)*j]), FFT_SIZE, gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed, gpWaveRecordConfigurationData->WaveChannelFreqData, gpWaveRecordConfigurationData->dwNumberOfChannels, gpWavePlaybackConfigurationData->WaveChannelFreqData, gpWavePlaybackConfigurationData->dwNumberOfChannels, j, gpWaveRecordConfigurationData->dwSampleRate, pdblNoiseLimitValues, gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed, &dblActualSignalToNoiseRatio) != PASS)
				return(FAIL);
			if (wTestNumber == ANALOG_PLAYBACK_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_LEFT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
				else
					ReportStatistic(XAUDIO_ANALOG_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_RIGHT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
			}
			else if (wTestNumber == ANALOG_SILENCE_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_LEFT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
				else
					ReportStatistic(XAUDIO_SILENCE_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_RIGHT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
			}
			else // Assume DIGITAL_PLAYBACK_TEST
			{
				if (j == 0)
					ReportStatistic(XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_LEFT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
				else
					ReportStatistic(XAUDIO_DIGITAL_SIGNAL_TO_NOISE_RATIO_IGNORING_CROSSTALK_RIGHT_CHANNEL, _T("%.2lf"), dblActualSignalToNoiseRatio);
			}
			if (gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk > dblActualSignalToNoiseRatio)
			{
				err_SignalToNoiseNoCrossTooSmallLSDD(j, (gpWaveRecordConfigurationData->pchChannelLabel != NULL) ? gpWaveRecordConfigurationData->pchChannelLabel[j] : L"", gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk, dblActualSignalToNoiseRatio);
				dwLocalStatus = FAIL;
			}
		}
	}

	// Let's figure out what the channel separation is
	if (gpWaveRecordConfigurationData->dblChannelSeparation != 0)  // Check channel separation
	{
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // Compute the channel separation of all channels
		{
			if (dwComputeChannelSeparation(&(pdwMagnitudeValues[(FFT_SIZE/2)*j]), FFT_SIZE, gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed, gpWaveRecordConfigurationData->WaveChannelFreqData, gpWaveRecordConfigurationData->dwNumberOfChannels, gpWavePlaybackConfigurationData->WaveChannelFreqData, gpWavePlaybackConfigurationData->dwNumberOfChannels, j, gpWaveRecordConfigurationData->dwSampleRate, gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed, &dblActualChannelSeparation, pdblNoiseLimitValues) != PASS)
				return(FAIL);
			if (wTestNumber == ANALOG_PLAYBACK_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_ANALOG_CHANNEL_SEPERATION_LEFT_CHANNEL, _T("%.3lf"), dblActualChannelSeparation);
				else
					ReportStatistic(XAUDIO_ANALOG_CHANNEL_SEPERATION_RIGHT_CHANNEL, _T("%.3lf"), dblActualChannelSeparation);
			}
			else if (wTestNumber == ANALOG_SILENCE_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_SILENCE_CHANNEL_SEPERATION_LEFT_CHANNEL, _T("%.3lf"), dblActualChannelSeparation);
				else
					ReportStatistic(XAUDIO_SILENCE_CHANNEL_SEPERATION_RIGHT_CHANNEL, _T("%.3lf"), dblActualChannelSeparation);
			}
			else // Assume DIGITAL_PLAYBACK_TEST
			{
				if (j == 0)
					ReportStatistic(XAUDIO_DIGITAL_CHANNEL_SEPERATION_LEFT_CHANNEL, _T("%.3lf"), dblActualChannelSeparation);
				else
					ReportStatistic(XAUDIO_DIGITAL_CHANNEL_SEPERATION_RIGHT_CHANNEL, _T("%.3lf"), dblActualChannelSeparation);
			}
			if (gpWaveRecordConfigurationData->dblChannelSeparation > dblActualChannelSeparation)
			{
				err_ChannelSeperationTooSmallLSDD(j, (gpWaveRecordConfigurationData->pchChannelLabel != NULL) ? gpWaveRecordConfigurationData->pchChannelLabel[j] : L"", gpWaveRecordConfigurationData->dblChannelSeparation, dblActualChannelSeparation);
				dwLocalStatus = FAIL;
			}
		}
	}

	// Let's figure out what the frequency response is
	if (gpWaveRecordConfigurationData->dblFrequencyResponseTolerance != 0)
	{
		for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)  // Compute the frequency response of all channels
		{
			if (dwComputeFrequencyResponse(&(pdwMagnitudeValues[(FFT_SIZE/2)*j]), FFT_SIZE, gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed, gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency, gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies, gpWaveRecordConfigurationData->dblFrequencyResponseLevel, gpWaveRecordConfigurationData->dwBitsPerSample, gpWaveRecordConfigurationData->dwSampleRate, gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed, &dblActualFrequencyResponse, pdblNoiseLimitValues) != PASS)
				return(FAIL);
			if (wTestNumber == ANALOG_PLAYBACK_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_ANALOG_FREQUENCY_RESPONSE_LEFT_CHANNEL, _T("%.3lf"), dblActualFrequencyResponse);
				else
					ReportStatistic(XAUDIO_ANALOG_FREQUENCY_RESPONSE_RIGHT_CHANNEL, _T("%.3lf"), dblActualFrequencyResponse);
			}
/*
			else if (wTestNumber == ANALOG_SILENCE_TEST)
			{
				if (j == 0)
					ReportStatistic(XAUDIO_SILENCE_FREQUENCY_RESPONSE_LEFT_CHANNEL, _T("%.3lf"), dblActualFrequencyResponse);
				else
					ReportStatistic(XAUDIO_SILENCE_FREQUENCY_RESPONSE_RIGHT_CHANNEL, _T("%.3lf"), dblActualFrequencyResponse);
			}
*/
			else // Assume DIGITAL_PLAYBACK_TEST
			{
				if (j == 0)
					ReportStatistic(XAUDIO_DIGITAL_FREQUENCY_RESPONSE_LEFT_CHANNEL, _T("%.3lf"), dblActualFrequencyResponse);
				else
					ReportStatistic(XAUDIO_DIGITAL_FREQUENCY_RESPONSE_RIGHT_CHANNEL, _T("%.3lf"), dblActualFrequencyResponse);
			}
			if (gpWaveRecordConfigurationData->dblFrequencyResponseTolerance < dblActualFrequencyResponse)
			{
				err_FrequencyResponseBadLSDD(j, (gpWaveRecordConfigurationData->pchChannelLabel != NULL) ? gpWaveRecordConfigurationData->pchChannelLabel[j] : L"", gpWaveRecordConfigurationData->dblFrequencyResponseTolerance, dblActualFrequencyResponse);
				dwLocalStatus = FAIL;
			}
		}
	}

/*
	if (dwLocalStatus == FAIL)
	{
		gpF = NULL;
		// Write FFT info from all channels to a file

		gpF = fopen("FFT.IN", "wb");  // Opening info file

		if( gpF != NULL)
		{
			for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)
			{
				for (k = 0; k < FFT_SIZE/2; k++)
				{
					if (pdwMagnitudeValues[((FFT_SIZE/2)*j)+k] != 0)
						fprintf(gpF, "channel %lu fft bin %4.1lu = %5.1lu Hz  magnitude = %10.1lu, %07.2lf dB\n", j, k, ((gpWaveRecordConfigurationData->dwSampleRate * k)/FFT_SIZE), pdwMagnitudeValues[((FFT_SIZE/2)*j)+k], 20*log10((double)pdwMagnitudeValues[((FFT_SIZE/2)*j)+k]/(double)(((double)((DWORD)1 << (gpWaveRecordConfigurationData->dwBitsPerSample-2)))*(double)FFT_SIZE)));
					else
						fprintf(gpF, "channel %lu fft bin %4.1lu = %5.1lu Hz  magnitude = %10.1lu, -XXX.XX dB\n", j, k, ((gpWaveRecordConfigurationData->dwSampleRate * k)/FFT_SIZE), pdwMagnitudeValues[((FFT_SIZE/2)*j)+k]);
				}
			}
			fclose(gpF);
		}
		else
		{
			wt_status("Could not open file %s", "FFT.IN");
		}

		gpF = NULL;
		// The following 4 lines write the raw recorded data to a file
		gpF = fopen("BUFFER.IN", "wb");  // Opening info file

		if( gpF != NULL)
		{

			fwrite(pdwWaveInBuffer, gpWaveRecordConfigurationData->dwNumberOfChannels*dwRecordBytesPerSample, WAVE_IN_NUMBER_OF_SAMPLES, gpF);
			fclose(gpF);
			gpF = NULL;
		}
		else
		{
			wt_status("Could not open file %s", "BUFFER.IN");
		}
		return(FAIL);
	}
*/
	return (dwLocalStatus);
}

IMPLEMENT_TESTUNLOCKED (Audio, analog_playback, ANALOG_PLAYBACK_TEST)
{
	#ifdef _DEBUG
		static int AnalogPlay;
		AnalogPlay++;
		ReportDebug(BIT0, _T("Analog Playback Test - Loop %d"), AnalogPlay);
	#endif

	wTestNumber = GetTestNumber(); // This tells us which test we are fetching parameters for

	DWORD dwStatus = FAIL;
	DWORD dwMaxTestTrys = gdwMaxTestTrys;

#ifdef _XBOX
// Make sure the audio circuit is unclamped
#endif

	while ((dwMaxTestTrys != 0) && (dwStatus == FAIL))
	{
		if (dwMaxTestTrys == 1)
		{
			gdwIgnoreError = FALSE;
		}
		else
			gdwIgnoreError = TRUE;
		vInitializeTestVariables();
		dwStatus = dwAnalogPlayback();
		vStraightenUpTestVariables();
		if (CheckAbort (HERE)) // Make sure that we don't keep looping if we are supposed to abort
			return;
		dwMaxTestTrys--;
	}
}

IMPLEMENT_TESTUNLOCKED (Audio, analog_silence, ANALOG_SILENCE_TEST)
{
	#ifdef _DEBUG
		static int AnalogSilence;
		AnalogSilence++;
		ReportDebug(BIT0, _T("Analog Playback Test - Loop %d"), AnalogSilence);
	#endif

	wTestNumber = GetTestNumber(); // This tells us which test we are fetching parameters for

	DWORD dwStatus = FAIL;
	DWORD dwMaxTestTrys = gdwMaxTestTrys;

#ifdef _XBOX
// Make sure the audio circuit is clamped
#endif

	while ((dwMaxTestTrys != 0) && (dwStatus == FAIL))
	{
		if (dwMaxTestTrys == 1)
		{
			gdwIgnoreError = FALSE;
		}
		else
			gdwIgnoreError = TRUE;
		vInitializeTestVariables();
		dwStatus = dwAnalogPlayback();
		vStraightenUpTestVariables();
		if (CheckAbort (HERE)) // Make sure that we don't keep looping if we are supposed to abort
			return;
		dwMaxTestTrys--;
	}
}

DWORD CXModuleAudio::dwDigitalAccuracy(void)
{
	DWORD j, k;
	DWORD dwLocalStatus = PASS;
	WORD wSampleFormat = WAVE_FORMAT_PCM;
	DWORD dwPlaybackBytesPerSample, dwRecordBytesPerSample;
	DWORD dwWaveOutBufferSize, dwWaveInBufferSize;
	DWORD dwAmountOfLeadingRecordedAudioToThrowAway;
	DSBUFFERDESC dsBufferDesc;
	DWORD dwDelayBetweenPlaybackStartAndRecordStart;
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	int iError;
	LPBYTE pBMixerControls = NULL;
	int iMixerControlBufferLength = 0;
	DWORD dwCRCValue;

#ifndef _XBOX // Win32
	char *pcTemp = NULL;
	DWORD dwWaveFormatExSize, dwWaveFormatExSize2;
	void *pFirstDSBufferLoc, *pSecondDSBufferLoc;
	DWORD dwFirstDSBufferSize, dwSecondDSBufferSize;
	DWORD *pdwBufferBase;

	gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID = NULL;  // Initialize the playback GUID to NULL
	// Check to be sure the specified playback device is present.  If it is not, silently use the first installed playback device
	if(DirectSoundEnumerate((LPDSENUMCALLBACK)bDSEnumCallback, this) != DS_OK)
	{
		err_DirectSoundEnumerateFailed();
		return(FAIL);
	}
	if(gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID == NULL)
	{
		err_DirectSoundFindFailed();
		return(FAIL);
	}
	// The playback device GUID is now correct
#endif
	// This will simply print out the values of the configuration parameters (in Win32)
/*
	wprintf(L"Trys = %lu\n", gdwMaxTestTrys);
	wprintf(L"Delay between playback start and record start = %lu\n", gdwDelayBetweenPlaybackStartAndRecordStart);
	wprintf(L"Mutex Timeout = %lu\n", gdwMutexTimeout);
	wprintf(L"Playback device number = %lu\n", (DWORD)gpWavePlaybackConfigurationData->uiAudioOutDevToUse);
	wprintf(L"Playback number of channels = %lu\n", gpWavePlaybackConfigurationData->dwNumberOfChannels);
	wprintf(L"Playback sample rate = %lu\n", gpWavePlaybackConfigurationData->dwSampleRate);
	wprintf(L"Playback bits per sample = %lu\n", gpWavePlaybackConfigurationData->dwBitsPerSample);
	wprintf(L"Playback digital attenuation = %lu\n", gpWavePlaybackConfigurationData->dwDigitalAttenuation);
	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		for (k = 0; k < gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
		{
			wprintf(L"Channel %lu frequency %lu value is %lf\n", j, k, gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k]);
		}
	}
	wprintf(L"Record device number = %lu\n", (DWORD)gpWaveRecordConfigurationData->uiAudioInDevToUse);
	wprintf(L"Record number of channels = %lu\n", gpWaveRecordConfigurationData->dwNumberOfChannels);
	wprintf(L"Record sample rate = %lu\n", gpWaveRecordConfigurationData->dwSampleRate);
	wprintf(L"Record bits per sample = %lu\n", gpWaveRecordConfigurationData->dwBitsPerSample);
	wprintf(L"Record FFT Window function = %lu\n", gpWaveRecordConfigurationData->dwFFTWindowFunction);
	wprintf(L"Record amplitude tolerance = %lf\n", gpWaveRecordConfigurationData->dblAmplitudeTolerance);
	wprintf(L"Record max DC offset percent = %lf\n", gpWaveRecordConfigurationData->dblMaxDCOffsetPercent);
	wprintf(L"Record signal to noise ratio = %lf\n", gpWaveRecordConfigurationData->dblSignalToNoiseRatio);
	wprintf(L"Record S/N ratio ignoring crosstalk = %lf\n", gpWaveRecordConfigurationData->dblSignalToNoiseRatioIgnoringCrosstalk);
	wprintf(L"Record channel separation = %lf\n", gpWaveRecordConfigurationData->dblChannelSeparation);
	wprintf(L"Record frequency response tolerance = %lf\n", gpWaveRecordConfigurationData->dblFrequencyResponseTolerance);
	wprintf(L"Record frequency response level = %lf\n", gpWaveRecordConfigurationData->dblFrequencyResponseLevel);
	wprintf(L"Record frequency shift percent allowed = %lf\n", gpWaveRecordConfigurationData->dblFrequencyShiftPercentAllowed);
	wprintf(L"Record frequency shift hz allowed = %lf\n", gpWaveRecordConfigurationData->dblFrequencyShiftHzAllowed);
	wprintf(L"Record CRC = %8.8lx\n", gpWaveRecordConfigurationData->dwCRC);
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfNoiseRanges; j++)
	{
		wprintf(L"Noise range %lu start frequency value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartFreq);
		wprintf(L"Noise range %lu stop frequency value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopFreq);
		wprintf(L"Noise range %lu start level value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStartLevel);
		wprintf(L"Noise range %lu stop level value is %lf\n", j, gpWaveRecordConfigurationData->WaveRecordNoiseLimit[j].dblNoiseLimitStopLevel);
	}
	for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)
	{
		for (k = 0; k < gpWaveRecordConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
		{
			wprintf(L"Channel %lu freq %lu value is %lf, amp = %lf\n", j, k, gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency[k], gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude[k]);
		}
	}

*/

	// Now fix up the frequencies to fit in the playback buffer 
	// and calculate the SamplesPerPeriod from the Frequency values 
	vFixUpPlaybackFrequencies();
	vCalculateSamplesPerPeriod();

	// ***** Setup for playback
    // This assumes that 17-24 bit samples will use 3 bytes per sample
	dwPlaybackBytesPerSample = (gpWavePlaybackConfigurationData->dwBitsPerSample + 7) / 8;
	dwWaveOutBufferSize = dwPlaybackBytesPerSample * 
						  gpWavePlaybackConfigurationData->dwNumberOfChannels * 
						  WAVE_OUT_NUMBER_OF_SAMPLES;

	// *** At this point a mutex should indicate that we are using audio resources
	if (dwGetPossessionOfAudioResources(gdwMutexTimeout) != PASS)
			return(FAIL);

	// Create an IDirectSound interface for playing audio
#ifdef _XBOX

	if (DirectSoundCreate(NULL, &pDSoundOut, NULL) != DS_OK)
	{
		err_CouldNotCreateIDirectSound();
		return(FAIL);
	}
#else // not _XBOX (Win32)
	if (DirectSoundCreate8(gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID, &pDSoundOut, NULL) != DS_OK)
	{
		err_CouldNotCreateIDirectSound();
		return(FAIL);
	}
	// Get a window handle; this will change in the future (XBox will probably not require a Window handle)
	hDSWnd = GetForegroundWindow();
	if (hDSWnd == NULL)
	{
		hDSWnd = GetDesktopWindow();
	}

	if (pDSoundOut->SetCooperativeLevel(hDSWnd, DSSCL_EXCLUSIVE) != DS_OK)
	{
		err_CouldNotSetCooperativeLevel();
		return(FAIL);
	}

	// Now set up the primary sound buffer characteristics
	memset(&dsBufferDesc, 0, sizeof(DSBUFFERDESC));
	dsBufferDesc.dwSize = sizeof(DSBUFFERDESC);
	dsBufferDesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
	dsBufferDesc.dwReserved = 0;
	dsBufferDesc.dwBufferBytes = 0; // Set to 0 for a primary buffer
	dsBufferDesc.lpwfxFormat = NULL; // NULL for a primary buffer
	dsBufferDesc.guid3DAlgorithm = GUID_NULL;

	if (pDSoundOut->CreateSoundBuffer(&dsBufferDesc, &pPrimaryBuffer, NULL)  != DS_OK)
	{
		err_CouldNotGetAccessToPrimaryBuffer();
		return(FAIL);
	}
/*
	// This is here just in case we need to change to IDirectSoundBuffer8 access of primary buffers
	if (pPrimaryBufferPre8->QueryInterface(IID_IDirectSoundBuffer8, (LPVOID *)&pPrimaryBuffer)  != S_OK) // Get the IDirectSoundBuffer8 interface
	{
		err_CouldNotGetAccessToPrimaryIDirectSoundBuffer8Interface();
		return(FAIL);
	}
*/
	if ((WaveFormatex = new WAVEFORMATEX) == NULL)  // Create a WAVEFORMATX structure
	{
		err_CouldNotAllocateWAVEFORMATEX();
		return FAIL;
	}
	memset(WaveFormatex, 0, sizeof(WAVEFORMATEX));
	WaveFormatex->wFormatTag = wSampleFormat;
	WaveFormatex->nChannels = (WORD)gpWavePlaybackConfigurationData->dwNumberOfChannels;
	WaveFormatex->nSamplesPerSec = gpWavePlaybackConfigurationData->dwSampleRate;
	WaveFormatex->nBlockAlign = (WORD)(gpWavePlaybackConfigurationData->dwNumberOfChannels * dwPlaybackBytesPerSample);
	WaveFormatex->nAvgBytesPerSec = gpWavePlaybackConfigurationData->dwSampleRate * (DWORD)WaveFormatex->nBlockAlign;
	WaveFormatex->wBitsPerSample = (WORD)gpWavePlaybackConfigurationData->dwBitsPerSample;
	WaveFormatex->cbSize = 0;

	if (pPrimaryBuffer->SetFormat(WaveFormatex) != DS_OK)
	{
		err_CouldNotSetPrimaryBufferFormat();
		return(FAIL);
	}
	delete WaveFormatex;
	WaveFormatex = NULL;

	// Read back the format to make sure the hardware really supports it
	if (pPrimaryBuffer->GetFormat(NULL, 0, &dwWaveFormatExSize) != DS_OK)
	{
		err_CouldNotReadPrimaryBufferFormat();
		return(FAIL);
	}
	if ((pcTemp = new char [dwWaveFormatExSize]) == NULL)  // Create a WAVEFORMATEX structure
	{
		err_CouldNotAllocateWAVEFORMATEX();
		return FAIL;
	}
	WaveFormatex = (WAVEFORMATEX *)pcTemp;
	memset(WaveFormatex, 0, dwWaveFormatExSize);
	if (pPrimaryBuffer->GetFormat(WaveFormatex, dwWaveFormatExSize, &dwWaveFormatExSize2) != DS_OK) // Get the actual WAVEFORMATEX data
	{
		delete [] pcTemp; // Clean up this stuff
		pcTemp = NULL;
		WaveFormatex = NULL;
		err_CouldNotReadPrimaryBufferFormat();
		return(FAIL);
	}
	if (dwWaveFormatExSize != dwWaveFormatExSize2) // The whole structure had better be filled in
	{
		delete [] pcTemp; // Clean up this stuff
		pcTemp = NULL;
		WaveFormatex = NULL;
		err_CouldNotReadPrimaryBufferFormat();
		return(FAIL);
	}
	// Compare what we set to what the hardware supports
	if ((WaveFormatex->wFormatTag != wSampleFormat) ||
	    (WaveFormatex->nChannels != (WORD)gpWavePlaybackConfigurationData->dwNumberOfChannels) ||
	    (WaveFormatex->nSamplesPerSec != gpWavePlaybackConfigurationData->dwSampleRate) ||
	    (WaveFormatex->nBlockAlign != (WORD)(gpWavePlaybackConfigurationData->dwNumberOfChannels * dwPlaybackBytesPerSample)) ||
	    (WaveFormatex->nAvgBytesPerSec != gpWavePlaybackConfigurationData->dwSampleRate * (DWORD)WaveFormatex->nBlockAlign) ||
	    (WaveFormatex->wBitsPerSample != (WORD)gpWavePlaybackConfigurationData->dwBitsPerSample))
	{
		delete [] pcTemp; // Clean up this stuff
		pcTemp = NULL;
		WaveFormatex = NULL;
		err_PlaybackAudioFormatNotSupported();
		return(FAIL);
	}
	delete [] pcTemp; // Clean up this stuff
	pcTemp = NULL;
	WaveFormatex = NULL;
#endif

	// Now set up the secondary sound buffer characteristics
	if ((WaveFormatex = new WAVEFORMATEX) == NULL)  // Create a WAVEFORMATX structure
	{
		err_CouldNotAllocateWAVEFORMATEX();
		return FAIL;
	}

	// Find the largest number of frequencies in a channel
	dwNumberOfFrequencies = 1;
//	dwNumberOfFrequencies = 0;
/*
	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		if (gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies > dwNumberOfFrequencies)
			dwNumberOfFrequencies = gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies;
	}
*/
	if ((pSecondaryBufferPre8 = new LPDIRECTSOUNDBUFFER[dwNumberOfFrequencies]) == NULL)  // Create an array of pointers to secondary DS sound buffers
	{
		err_CouldNotAllocateLPDIRECTSOUNDBUFFERArray();
		return FAIL;
	}
	for (j = 0; j < dwNumberOfFrequencies; j++) // Initialize these to NULL for safety
		pSecondaryBufferPre8[j] = NULL;
	if ((pSecondaryBuffer = new LPDIRECTSOUNDBUFFER8[dwNumberOfFrequencies]) == NULL)  // Create an array of pointers to secondary DS8 sound buffers
	{
		err_CouldNotAllocateLPDIRECTSOUNDBUFFER8Array();
		return FAIL;
	}
	for (j = 0; j < dwNumberOfFrequencies; j++) // Initialize these to NULL for safety
		pSecondaryBuffer[j] = NULL;

	if ((ppdwWaveOutBuffer = new DWORD *[dwNumberOfFrequencies]) == NULL)  // Create an array of pointers to data buffers
	{
		err_CouldNotAllocateWaveOutBufferArray();
		return FAIL;
	}
	for (j = 0; j < dwNumberOfFrequencies; j++) // Initialize these to NULL for safety
		ppdwWaveOutBuffer[j] = NULL;



	// Create a secondary buffer for each frequency
	for (j = 0; j < dwNumberOfFrequencies; j++)
	{
		// Allocate a buffer for the audio for this frequency, and put the frequency data in it
		if ((ppdwWaveOutBuffer[j] = (DWORD *)VirtualAlloc(NULL, dwWaveOutBufferSize, MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE)) == NULL)
		{
			err_CouldNotAllocatePlaybackBuffer(dwWaveOutBufferSize);
			return FAIL;
		}

		// Generate a sine wave in each channel of this buffer
/*
		if (dwGenSingleSineWave(ppdwWaveOutBuffer[j], 
						  gpWavePlaybackConfigurationData->dwBitsPerSample, 
						  FFT_SIZE, 
						  gpWavePlaybackConfigurationData->WaveChannelFreqData, 
						  gpWavePlaybackConfigurationData->dwNumberOfChannels, 
						  gpWavePlaybackConfigurationData->dwDigitalAttenuation,
						  j) != PASS)
			return(FAIL);  // We failed for some reason
*/
///*
		if (dwGenSineWave(ppdwWaveOutBuffer[j],
						  gpWavePlaybackConfigurationData->dwBitsPerSample,
						  FFT_SIZE,
						  gpWavePlaybackConfigurationData->WaveChannelFreqData,
						  gpWavePlaybackConfigurationData->dwNumberOfChannels,
						  gpWavePlaybackConfigurationData->dwDigitalAttenuation) != PASS)
			return(FAIL);  // We failed for some reason
//*/
		for (k = 1; k < (WAVE_OUT_NUMBER_OF_SAMPLES/FFT_SIZE); k++) // Duplicate generated data throughout the rest of the playback buffer
			memcpy((char *)ppdwWaveOutBuffer[j]+(k*(dwWaveOutBufferSize/(WAVE_OUT_NUMBER_OF_SAMPLES/FFT_SIZE))), ppdwWaveOutBuffer[j], (dwWaveOutBufferSize/(WAVE_OUT_NUMBER_OF_SAMPLES/FFT_SIZE)));

		// Add a footprint to the begining of the sample
		memset((((DWORD *)ppdwWaveOutBuffer[j])+0), 0, 32); // A string of 32 0s ought to be a unique footprint
/*
		memset((((DWORD *)ppdwWaveOutBuffer[j])+2), 0x55, 4);
		memset((((DWORD *)ppdwWaveOutBuffer[j])+3), 0xAA, 4);
		memset((((DWORD *)ppdwWaveOutBuffer[j])+4), 0, 1024);

		for (k = 0; k < dwWaveOutBufferSize/2; k++)
			*(((WORD *)ppdwWaveOutBuffer[j]) + k) = k + 0x7000;
*/

		memset(WaveFormatex, 0, sizeof(WAVEFORMATEX));
		WaveFormatex->wFormatTag = wSampleFormat;
		WaveFormatex->nChannels = (WORD)gpWavePlaybackConfigurationData->dwNumberOfChannels;
		WaveFormatex->nSamplesPerSec = gpWavePlaybackConfigurationData->dwSampleRate;
		WaveFormatex->nBlockAlign = (WORD)(gpWavePlaybackConfigurationData->dwNumberOfChannels * dwPlaybackBytesPerSample);
		WaveFormatex->nAvgBytesPerSec = gpWavePlaybackConfigurationData->dwSampleRate * (DWORD)WaveFormatex->nBlockAlign;
		WaveFormatex->wBitsPerSample = (WORD)gpWavePlaybackConfigurationData->dwBitsPerSample;
		WaveFormatex->cbSize = 0;

#ifdef _XBOX
		memset(&dsBufferDesc, 0, sizeof(DSBUFFERDESC));
		dsBufferDesc.dwSize = sizeof(DSBUFFERDESC);
		dsBufferDesc.dwFlags = DSBCAPS_CTRLVOLUME;
		dsBufferDesc.dwBufferBytes = dwWaveOutBufferSize;
		dsBufferDesc.lpwfxFormat = WaveFormatex;

		if (pDSoundOut->CreateSoundBuffer(&dsBufferDesc, &pSecondaryBuffer[j], NULL) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		if (pDSoundOut->SetMixBinHeadroom(0xffffffff, 0) != DS_OK) // Set all mix bins to 0 headroom
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		// Set the headroom to 0 so that samples are not digitally attenuated.
		if (pSecondaryBuffer[j]->SetHeadroom(0) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		// Set the volume to maximum (no attenuation of digital buffer contents)
		if (pSecondaryBuffer[j]->SetVolume(DSBVOLUME_MAX) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}



		// Point to the data buffer.
		if (pSecondaryBuffer[j]->SetBufferData(ppdwWaveOutBuffer[j], dwWaveOutBufferSize) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferData();
			return(FAIL);
		}

#else // Win32
		memset(&dsBufferDesc, 0, sizeof(DSBUFFERDESC));
		dsBufferDesc.dwSize = sizeof(DSBUFFERDESC);
		dsBufferDesc.dwFlags = DSBCAPS_CTRLVOLUME |
							   DSBCAPS_CTRLPAN |
							   DSBCAPS_GLOBALFOCUS |
							   DSBCAPS_STATIC;
		dsBufferDesc.dwReserved = 0;
		dsBufferDesc.dwBufferBytes = dwWaveOutBufferSize;
		dsBufferDesc.lpwfxFormat = WaveFormatex;
		dsBufferDesc.guid3DAlgorithm = GUID_NULL;

		if (pDSoundOut->CreateSoundBuffer(&dsBufferDesc, &pSecondaryBufferPre8[j], NULL) != DS_OK)
		{
			err_CouldNotGetAccessToSecondaryBuffer();
			return(FAIL);
		}

		if (pSecondaryBufferPre8[j]->QueryInterface(IID_IDirectSoundBuffer8, (LPVOID *)&pSecondaryBuffer[j])  != S_OK) // Get the IDirectSoundBuffer8 interface
		{
			err_CouldNotGetAccessToSecondaryIDirectSoundBuffer8Interface();
			return(FAIL);
		}

		// Set the volume to maximum (no attenuation of digital buffer contents)
		if (pSecondaryBuffer[j]->SetVolume(DSBVOLUME_MAX) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferVolume();
			return(FAIL);
		}

		// Set the panning to center
		if (pSecondaryBuffer[j]->SetPan(DSBPAN_CENTER) != DS_OK)
		{
			err_CouldNotSetSecondaryBufferPanning();
			return(FAIL);
		}
		// Lock the entire secondary sound buffer so that we can copy data into it
		if (pSecondaryBuffer[j]->Lock(0, dwWaveOutBufferSize, &pFirstDSBufferLoc, &dwFirstDSBufferSize, &pSecondDSBufferLoc, &dwSecondDSBufferSize, DSBLOCK_ENTIREBUFFER) != DS_OK)
		{
			err_CouldNotLockSecondaryBuffer();
			return(FAIL);
		}
		if ((dwFirstDSBufferSize + dwSecondDSBufferSize) != dwWaveOutBufferSize) // Make sure that the whole buffer was locked
		{
			err_LockedSecondaryBufferSegmentWrongSize(dwWaveOutBufferSize, dwFirstDSBufferSize + dwSecondDSBufferSize);
			return(FAIL);
		}
		// Point pdwBufferBase to the real base of the buffer
		if (pFirstDSBufferLoc == NULL)
			pdwBufferBase = (DWORD *)pSecondDSBufferLoc;
		else if (pSecondDSBufferLoc == NULL)
			pdwBufferBase = (DWORD *)pFirstDSBufferLoc;
		else if (pSecondDSBufferLoc > pFirstDSBufferLoc)
			pdwBufferBase = (DWORD *)pFirstDSBufferLoc;
		else
			pdwBufferBase = (DWORD *)pSecondDSBufferLoc;

		// Copy the contents of the data buffer to the buffer that CreateSoundBuffer gave us.
		memcpy(pdwBufferBase, (char *)ppdwWaveOutBuffer[j], dwWaveOutBufferSize);

/*
	if (m_debugmask & BIT0) // Do very verbose messaging at debug bit level 0
	{
		// The following 4 lines write the digitally generated playback buffer to a file
		gpF = fopen("BUFFER.OUT", "wb");  // Opening info file

		if(gpF != NULL)
		{
			//for (j = 0; j < 22; j++)
			fwrite(pdwBufferBase, 4, FFT_SIZE, gpF);
			fclose(gpF);
			gpF = NULL;
		}

		gpF = fopen("BUFFER.OU1", "w");  // Opening info file	
		if(gpF != NULL)
		{
			for (j = 0; j < FFT_SIZE; j++)
			{
				fprintf(gpF, "%5.5lu, %5.5x, %5.5x\n", j, (short)(pdwBufferBase[j] & 0xFFFF), (short)((pdwBufferBase[j] >> 16) & 0xFFFF));
			}
			fclose(gpF);
			gpF = NULL;
		}

	}

*/




		// Now, let's unlock the secondary buffer
		if (pSecondaryBuffer[j]->Unlock(pFirstDSBufferLoc, dwFirstDSBufferSize, pSecondDSBufferLoc, dwSecondDSBufferSize) != DS_OK)
		{
			err_CouldNotUnlockSecondaryBuffer();
			return(FAIL);
		}
#endif
	}
	delete WaveFormatex;
	WaveFormatex = NULL;

	dwRecordBytesPerSample = (gpWaveRecordConfigurationData->dwBitsPerSample+7)/8;  // This assumes that 17-24 but samples will use 3 bytes per sample
	dwWaveInBufferSize = dwRecordBytesPerSample * 
						 gpWaveRecordConfigurationData->dwNumberOfChannels * 
						 WAVE_IN_NUMBER_OF_SAMPLES;
	// Allocate memory for the waveform data.
	// This should be wBytesPerSample*wNumberOfChannels*WAVE_IN_NUMBER_OF_SAMPLES bytes long
	if ((pdwWaveInBuffer = new DWORD [dwWaveInBufferSize/(sizeof(DWORD))]) == NULL)  // Divide by 4 to correct for the fact that this a DWORD pointer
	{
		err_CouldNotAllocateRecordBuffer(dwWaveInBufferSize);
		return(FAIL);
	}
	// Now, let's play the secondary buffer in a continuous loop
	for (j = 0; j < dwNumberOfFrequencies; j++)
	{
		if (pSecondaryBuffer[j]->Play(0, 0, DSBPLAY_LOOPING) != DS_OK)
		{
			err_CouldNotPlaySecondaryBuffer();
			return(FAIL);
		}
	}

	// Figure out how many milliseconds of audio we will record before getting to data we will actually analyze
	dwAmountOfLeadingRecordedAudioToThrowAway = (((WAVE_IN_NUMBER_OF_SAMPLES/2)-16)*1000)/gpWaveRecordConfigurationData->dwSampleRate;

	if (gdwDelayBetweenPlaybackStartAndRecordStart > dwAmountOfLeadingRecordedAudioToThrowAway)
		dwDelayBetweenPlaybackStartAndRecordStart = gdwDelayBetweenPlaybackStartAndRecordStart - dwAmountOfLeadingRecordedAudioToThrowAway;
	else
		dwDelayBetweenPlaybackStartAndRecordStart = 0;

	// Create a parameter buffer and stuff it with parameters to send to the host
	// revision - DWORD revision of the data structure.  Rev 1 is listed here
	// audio_mux_com_port - DWORD indicating the COM port that the audio mux is attached to
	// mux_control_low_dword - DWORD indicating the low 32 bits of the audio mux setting
	// mux_control_high_dword - DWORD indicating the high 32 bits of the audio mux setting
	// mixer_name - string.  The name of the mixer to adjust for recording.  "none" indicates no mixer is to be used
	// number_of_mixer_controls - DWORD indicating how many mixer control strings are in the following list
	// mixer_controls - list of strings indicating the names and settings of all mixer controls to be adjusted
	// wave_input_device_name - string.  The name "none" implies that the default analog record device should be used
	// number_of_channels - DWORD indicating how many channels to record
	// sample_rate - DWORD indicating the record rate in KHz
	// bits_per_sample - DWORD indicating the resolution of the recording (8 and 16 are common)
	// wave_input_number_of_samples - DWORD indicating the number of samples to capture to the returned buffer
	// delay_between_playback_start_and_record_start - DWORD inidcating the delay between playback starting and record starting

	CStore CSParams(32768);  // The list of mixer parameters could get very long
	CSParams << (DWORD)(PARAMETER_REV_FOR_AUDIO_RECORD_ANALOG);
	CSParams << gdwAudioMuxComPort;
	CSParams << gpAudioMuxConfigurationInformation->dwMuxControlLowDWORD;
	CSParams << gpAudioMuxConfigurationInformation->dwMuxControlHighDWORD;
	CSParams << (LPCTSTR)gpwszAudioMixerName;
	CSParams << gdwNumberOfMixerControls;
	pBMixerControls = pCSMixer->GetBuffer();
	iMixerControlBufferLength = pCSMixer->GetLength();
	for (j = 0; j < (DWORD)iMixerControlBufferLength; j++) // Copy the mixer controls to the buffer we will send to the host
	{
		CSParams << pBMixerControls[j];
	}
	CSParams << (LPCTSTR)gpWaveRecordConfigurationData->pwszAudioInDevName;
	CSParams << gpWaveRecordConfigurationData->dwNumberOfChannels;
	CSParams << gpWaveRecordConfigurationData->dwSampleRate;
	CSParams << gpWaveRecordConfigurationData->dwBitsPerSample;
	CSParams << (DWORD)(WAVE_IN_NUMBER_OF_SAMPLES);
	CSParams << dwDelayBetweenPlaybackStartAndRecordStart;
	// Send message to record audio here
	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_AUDIO_RECORD_ANALOG, (char *)CSParams.GetBuffer(), CSParams.GetLength(), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, AUDIO_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			return(FAIL);
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			err_HostCommunicationError(iError);
			return(FAIL);
		}
	}
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		err_RecordBufferIsEmpty();
		return(FAIL);
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		if (dwActualBytesReceived < dwWaveInBufferSize)
		{
			err_RecordBufferIsNotCorrectLength(dwWaveInBufferSize, dwActualBytesReceived);
			return(FAIL);
		}
		// We received the record audio buffer the size that we wanted
	}

	memcpy(pdwWaveInBuffer, CHR.pvBufferFromHost, dwWaveInBufferSize);  // Copy the record data to a local buffer for processing

	// Now, let's stop the secondary buffer
	for (j = 0; j < dwNumberOfFrequencies; j++)
	{
		if (pSecondaryBuffer[j]->Stop() != DS_OK)
		{
			err_CouldNotStopPlayingSecondaryBuffer();
			return(FAIL);
		}
	}

	// *** At this point a mutex should indicate that we are done using audio resources
	vReleasePossessionOfAudioResources();

	// Uncomment the 2 lines below to feed the generated sine wave into the input analysis routines directly.  Make sure number of channels, bits per sample, and sample rate are identical between playback and record
	//memcpy(pdwWaveInBuffer, pdwWaveOutBuffer, dwWaveOutBufferSize);  // Copy the generated waveforms to the input buffer to test our analysis algorithms
	//memcpy(pdwWaveInBuffer + dwWaveOutBufferSize, pdwWaveOutBuffer, dwWaveOutBufferSize);  // Copy the generated waveforms to the input buffer to test our analysis algorithms
	if (m_debugmask & BIT0) // Do very verbose messaging at debug bit level 0
	{
		gpF = NULL;
		// The following 4 lines write the raw recorded data to a file
#ifdef _XBOX
		gpF = fopen("Z:\\BUFFER.IN", "wb");
#else // Win32
		gpF = fopen("BUFFER.IN", "wb");
#endif
		if (gpF != NULL)
		{
			fwrite(pdwWaveInBuffer, gpWaveRecordConfigurationData->dwNumberOfChannels*dwRecordBytesPerSample, WAVE_IN_NUMBER_OF_SAMPLES, gpF);
			fclose(gpF);
			gpF = NULL;
		}
		else
		{
			ReportDebug(BIT0, L"Could not open file %s", L"BUFFER.IN");
		}
	}
	// The following 3 lines read in data to the FFT input buffer from a file
	//gpF = fopen("INPUT.raw", "rb");  // Opening info file
	//fread(pdwWaveInBuffer, 1, dwWaveInBufferSize, gpF);
	//fclose(gpF);
	//gpF = NULL;

	// Look for the signature.  Start looking a ways into the buffer so that we are not
	// tricked by any partial signature of leading zeros that might exist at the start
	// of the buffer
	DWORD dwStartSample = 200;
	for (k = 0; k < 2; k++)
	{
		for (j = dwStartSample; j < (dwWaveInBufferSize/sizeof(DWORD)) - 3; j++)
		{
			if (pdwWaveInBuffer[j] == 0x00000000)
			{
				if (pdwWaveInBuffer[j+1] == 0x00000000)
				{
					if (pdwWaveInBuffer[j+2] == 0x00000000)
					{
						if (pdwWaveInBuffer[j+3] == 0x00000000)  // Found the signature
						{
							break;
						}
					}
				}
			}
		}
		if (j == dwStartSample) // This may only be a partial signature, so back up in the buffer and look for the signature again
			dwStartSample = dwStartSample - 100;
		else
			break;
	}
	if (j == ((dwWaveInBufferSize/sizeof(DWORD)) - 3)) // Did not find the signature
	{
		err_CouldNotFindDigitalSignature();
		return(FAIL);
	}

	if ((pdwMagnitudeValues = new DWORD [dwWaveOutBufferSize/(sizeof(DWORD))]) == NULL)
	{
		err_CouldNotAllocateCRCBufferL((unsigned long)(sizeof(DWORD)*dwWaveOutBufferSize));
		return(FAIL);
	}

	// Copy the recorded buffer contents into the pdwMagnitudeValues with the proper alignment before CRCing it
	DWORD dwBytesToCopy = dwWaveInBufferSize-(j*sizeof(DWORD));
	if (dwBytesToCopy > dwWaveOutBufferSize)
		dwBytesToCopy = dwWaveOutBufferSize;
	memcpy(pdwMagnitudeValues, &pdwWaveInBuffer[j], dwBytesToCopy);
	memcpy(&pdwMagnitudeValues[dwBytesToCopy/sizeof(DWORD)], &pdwWaveInBuffer[0], dwWaveOutBufferSize-dwBytesToCopy);

	// Compute the CRC based on the FFT magnitudes from all channels
	dwCRCValue = dwComputeCRC((unsigned char *)pdwMagnitudeValues, dwWaveOutBufferSize, INITIAL_CRC);

	// Compare the CRC value here
	if (gpWaveRecordConfigurationData->dwCRC != 0) // Don't compare the CRC if the config parameter is set to 0
	{
		if (gpWaveRecordConfigurationData->dwCRC != dwCRCValue)
		{
			err_CRCMiscompareLL(gpWaveRecordConfigurationData->dwCRC, dwCRCValue);
			return(FAIL);
		}
	}

	return (dwLocalStatus);
}


IMPLEMENT_TESTUNLOCKED (Audio, digital_playback, DIGITAL_PLAYBACK_TEST)
{
	#ifdef _DEBUG
		static int DigitalPlay;
		DigitalPlay++;
		ReportDebug(BIT0, _T("Digital Playback Test - Loop %d"), DigitalPlay);
	#endif

	wTestNumber = GetTestNumber(); // This tells us which test we are fetching parameters for

	DWORD dwStatus = FAIL;
	DWORD dwMaxTestTrys = gdwMaxTestTrys;

#ifdef _XBOX
// Make sure the audio circuit is unclamped
#endif

	while ((dwMaxTestTrys != 0) && (dwStatus == FAIL))
	{
		if (dwMaxTestTrys == 1)
		{
			gdwIgnoreError = FALSE;
		}
		else
			gdwIgnoreError = TRUE;
		vInitializeTestVariables();
		dwStatus = dwAnalogPlayback();
		vStraightenUpTestVariables();
		if (CheckAbort (HERE)) // Make sure that we don't keep looping if we are supposed to abort
			return;
		dwMaxTestTrys--;
	}
}

IMPLEMENT_TESTUNLOCKED (Audio, digital_accuracy, DIGITAL_ACCURACY_TEST)
{
	#ifdef _DEBUG
		static int DigitalPlay;
		DigitalPlay++;
		ReportDebug(BIT0, _T("Digital Playback Test - Loop %d"), DigitalPlay);
	#endif

	wTestNumber = GetTestNumber(); // This tells us which test we are fetching parameters for

	DWORD dwStatus = FAIL;
	DWORD dwMaxTestTrys = gdwMaxTestTrys;

#ifdef _XBOX
// Make sure the audio circuit is unclamped
#endif

	while ((dwMaxTestTrys != 0) && (dwStatus == FAIL))
	{
		if (dwMaxTestTrys == 1)
		{
			gdwIgnoreError = FALSE;
		}
		else
			gdwIgnoreError = TRUE;
		vInitializeTestVariables();
		dwStatus = dwDigitalAccuracy();
		vStraightenUpTestVariables();
		if (CheckAbort (HERE)) // Make sure that we don't keep looping if we are supposed to abort
			return;
		dwMaxTestTrys--;
	}
}


// This routine initializes a set of global variables for every test retry loop
void CXModuleAudio::vInitializeTestVariables(void)
{
	gpF = NULL;
	pDSoundOut = NULL;
	hDSWnd = NULL;
	pPrimaryBuffer = NULL;
	pSecondaryBuffer = NULL;
	pSecondaryBufferPre8 = NULL;
	dwNumberOfFrequencies = 0;
	ppdwWaveOutBuffer = NULL;
	pdwWaveInBuffer = NULL;
	WaveFormatex = NULL;
	pslFFTInputBuffer = NULL;
	pdblDCOffsetPercents = NULL;
	pdblNoiseLimitValues = NULL;
	pdwMagnitudeValues = NULL;
	hXMTAAudioMutex = (HANDLE) -1;
}



/*
vFixUpPlaybackFrequencies uses gpWavePlaybackConfigurationData as its input.

The playback frequencies are scaled to the nearest playback bin (which is currently equivalent to an
FFT bin and always should be a multiple of an FFT bin) so that no partial sine waves hang off the end
of the playback buffer.  dwSampleRate is the sample rate to which the frequencies should be scaled.

If we record at a different rate than we play back, we must use an FFT window (unless playback and record
rates are integer multiples of one another)

*/
void CXModuleAudio::vFixUpPlaybackFrequencies()
{
	DWORD j, k;

	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		for (k = 0; k < gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
		{
			gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = ((double)((DWORD)((gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k]*((double)FFT_SIZE/(double)gpWavePlaybackConfigurationData->dwSampleRate))+(double)0.5))) * ((double)gpWavePlaybackConfigurationData->dwSampleRate/(double)FFT_SIZE);
			if (gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] == 0)
				gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k] = FLT_MIN;  // This should avoid divide by zero errors; use FLT_MIN instead of DBL_MIN to keep from underflowing double representation during future computations.
		}
	}
}

/*
vCalculateSamplesPerPeriod uses gpWavePlaybackConfigurationData as its input.
*/
void CXModuleAudio::vCalculateSamplesPerPeriod()
{
	DWORD j, k;

	for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
	{
		for (k = 0; k < gpWavePlaybackConfigurationData->WaveChannelFreqData[j].dwNumberOfFrequencies; k++)
		{
			gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod[k] = (double)gpWavePlaybackConfigurationData->dwSampleRate/gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency[k];
		}
	}
}


/*****************************************************************
    dwGenSineWave  -  generate sound waveform data
  
    This routine creates a buffer full of sine wave patterns.  It should be able
	to handle buffers of any number of channels, with the number of sample bits anywhere
	between 1 and 32 bits.  This routine places all defined sine waves into their appropriate channels

	Accepts:
	pdwDataBuffer - Pointer to the buffer that will contain the generated sine wave data
	dwBitsPerSample - The number of bits per sample (for a single channel)
	dwNumberOfSamples - The number of sample points per channel (is 4096 for the first rev of this test module)
	pWaveChannelFreqData - Pointer to an array of WAVE_PLAYBACK_CHANNEL_FREQ_DATA structures
	dwNumberOfChannels - The number of audio channels (normally 1 or 2)
	dwAttenuationDB - Attenuation, in dB, to apply to the data (decreases the amplitude of the sine waves)

	Returns:
	PASS - When the pdwDataBuffer is successfully filled
	FAIL - When anything goes wrong

*****************************************************************/
DWORD CXModuleAudio::dwGenSineWave(DWORD *pdwDataBuffer, DWORD dwBitsPerSample, DWORD dwNumberOfSamples, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *pWaveChannelFreqData, DWORD dwNumberOfChannels, DWORD dwAttenuationDB)
{
	BYTE *pbDataBuffer;
	WORD *pwDataBuffer;
	SLONG *pslWorkingDataBuffer;
	DWORD dwBytesPerSample;
	DWORD dwMaxAmplitudedAllowed;
	DWORD dwNumberOfChannelsTimesBytesPerSample;
	DWORD h, i, j, k;
	double dblSamplesPerPeriod;
	double dblRadiansPerSample, dblRadians;
	double dblScaleFactor;
	DWORD dwSampleOffset;
	DWORD dwTempDWORD;


	pbDataBuffer = (BYTE *)pdwDataBuffer;
	pwDataBuffer = (WORD *)pdwDataBuffer;
	dwBytesPerSample = (dwBitsPerSample+7)/8;  // This assumes that 17-24 but samples will use 3 bytes per sample
	dwMaxAmplitudedAllowed = ((DWORD)1 << (dwBitsPerSample-1)) - (DWORD)1;
	dwNumberOfChannelsTimesBytesPerSample = dwNumberOfChannels*dwBytesPerSample;
	// Create and lock a working buffer large enough to contain the number of samples in longs for a single channel
	if ((pslWorkingDataBuffer = new SLONG [dwNumberOfSamples]) == NULL)
	{
		err_CouldNotAllocateSineWaveCreateL((unsigned long)(sizeof(SLONG)*dwNumberOfSamples));
		return FAIL;
	}

	// First generate the left channel output data
	
	for (h = 0; h < dwNumberOfChannels; h++)
	{
		memset(pslWorkingDataBuffer, 0, dwNumberOfSamples*sizeof(SLONG));  // Clear the memory buffer
		for (j = 0; j < pWaveChannelFreqData[h].dwNumberOfFrequencies; j++)  // Create sine waves for all of the frequencies passed in for this channel
		{
			dblSamplesPerPeriod = pWaveChannelFreqData[h].pdblSamplesPerPeriod[j];
			dblRadiansPerSample = TWO_PI / dblSamplesPerPeriod;
			i = 0;
			k = 0;
			while (k < dwNumberOfSamples)
			{
				dblRadians = dblRadiansPerSample * (double)i;
				pslWorkingDataBuffer[k] = pslWorkingDataBuffer[k] + (SLONG)((double)dwMaxAmplitudedAllowed * sin(dblRadians));
				k++;
				i++;
			}
		}
		// Now the working data buffer contains all of the frequencies added together at their maximum amplitudes.  Now we need to scale them down and put them in their final buffer

		dblScaleFactor = (double)pWaveChannelFreqData[h].dwNumberOfFrequencies  * pow((double)10, ((double)dwAttenuationDB/(double)20));
		dwSampleOffset = h*dwBytesPerSample;
		if (dwBytesPerSample == 1)  // Generate 8 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pbDataBuffer[i*dwNumberOfChannels + h] = (BYTE)((dwTempDWORD+128) & 0xff);  // 8-bit PCM is unsigned instead of signed
			}
		}
		else if (dwBytesPerSample == 2)  // Generate 16 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pwDataBuffer[i*dwNumberOfChannels + h] = (WORD)(dwTempDWORD & 0xffff);
			}
		}
		else if (dwBytesPerSample == 3)  // Generate 24 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pbDataBuffer[i*dwNumberOfChannelsTimesBytesPerSample + dwSampleOffset] = (BYTE)(dwTempDWORD & 0xff);
				pbDataBuffer[i*dwNumberOfChannelsTimesBytesPerSample + dwSampleOffset + 1] = (BYTE)((dwTempDWORD >> 8) & 0xff);
				pbDataBuffer[i*dwNumberOfChannelsTimesBytesPerSample + dwSampleOffset + 2] = (BYTE)((dwTempDWORD >> 16) & 0xff);
			}
		}
		else  // Assume 32 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pdwDataBuffer[i*dwNumberOfChannels + h] = dwTempDWORD;
			}
		}
	}
	delete [] pslWorkingDataBuffer;
	pslWorkingDataBuffer = NULL;
	return(PASS);
}

/*****************************************************************
    dwGenSingleSineWave  -  generate sound waveform data
  
    This routine creates a buffer full of sine wave patterns.  It should be able
	to handle buffers of any number of channels, with the number of sample bits anywhere
	between 1 and 32 bits.  This routine only places a single sine wave in every channel.

	Accepts:
	pdwDataBuffer - Pointer to the buffer that will contain the generated sine wave data
	dwBitsPerSample - The number of bits per sample (for a single channel)
	dwNumberOfSamples - The number of sample points per channel (is 4096 for the first rev of this test module)
	pWaveChannelFreqData - Pointer to an array of WAVE_PLAYBACK_CHANNEL_FREQ_DATA structures
	dwNumberOfChannels - The number of audio channels (normally 1 or 2)
	dwAttenuationDB - Attenuation, in dB, to apply to the data (decreases the amplitude of the sine waves)

	Returns:
	PASS - When the pdwDataBuffer is successfully filled
	FAIL - When anything goes wrong

*****************************************************************/
DWORD CXModuleAudio::dwGenSingleSineWave(DWORD *pdwDataBuffer, DWORD dwBitsPerSample, DWORD dwNumberOfSamples, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *pWaveChannelFreqData, DWORD dwNumberOfChannels, DWORD dwAttenuationDB, DWORD dwFrequencyNumber)
{
	BYTE *pbDataBuffer;
	WORD *pwDataBuffer;
	SLONG *pslWorkingDataBuffer;
	DWORD dwBytesPerSample;
	DWORD dwMaxAmplitudedAllowed;
	DWORD dwNumberOfChannelsTimesBytesPerSample;
	DWORD h, i;
	double dblSamplesPerPeriod;
	double dblRadiansPerSample, dblRadians;
	double dblScaleFactor;
	DWORD dwSampleOffset;
	DWORD dwTempDWORD;


	pbDataBuffer = (BYTE *)pdwDataBuffer;
	pwDataBuffer = (WORD *)pdwDataBuffer;
	dwBytesPerSample = (dwBitsPerSample+7)/8;  // This assumes that 17-24 but samples will use 3 bytes per sample
	dwMaxAmplitudedAllowed = ((DWORD)1 << (dwBitsPerSample-1)) - (DWORD)1;
	dwNumberOfChannelsTimesBytesPerSample = dwNumberOfChannels*dwBytesPerSample;
	// Create and lock a working buffer large enough to contain the number of samples in longs for a single channel
	if ((pslWorkingDataBuffer = new SLONG [dwNumberOfSamples]) == NULL)
	{
		err_CouldNotAllocateSineWaveCreateL((unsigned long)(sizeof(SLONG)*dwNumberOfSamples));
		return FAIL;
	}

	// Generate a sine wave in each channel that has a defined frequency configuration parameter
	for (h = 0; h < dwNumberOfChannels; h++)
	{
		memset(pslWorkingDataBuffer, 0, dwNumberOfSamples*sizeof(SLONG));  // Clear the memory buffer
		if (dwFrequencyNumber < pWaveChannelFreqData[h].dwNumberOfFrequencies) // Only generate a sine wave for this channel if a frequency was specified
		{
			dblSamplesPerPeriod = pWaveChannelFreqData[h].pdblSamplesPerPeriod[dwFrequencyNumber];
			dblRadiansPerSample = TWO_PI / dblSamplesPerPeriod;
			i = 0;
			while (i < dwNumberOfSamples)
			{
				dblRadians = dblRadiansPerSample * (double)i;
				pslWorkingDataBuffer[i] = (SLONG)((double)dwMaxAmplitudedAllowed * sin(dblRadians));
				i++;
			}
		}
		// Now the working data buffer contains a frequency's data for each channel.  Now we need to scale them down and put them in their final buffer

		dblScaleFactor = (double)pWaveChannelFreqData[h].dwNumberOfFrequencies  * pow((double)10, ((double)dwAttenuationDB/(double)20));
		dwSampleOffset = h*dwBytesPerSample;
		if (dwBytesPerSample == 1)  // Generate 8 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pbDataBuffer[i*dwNumberOfChannels + h] = (BYTE)((dwTempDWORD+128) & 0xff);  // 8-bit PCM is unsigned instead of signed
			}
		}
		else if (dwBytesPerSample == 2)  // Generate 16 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pwDataBuffer[i*dwNumberOfChannels + h] = (WORD)(dwTempDWORD & 0xffff);
			}
		}
		else if (dwBytesPerSample == 3)  // Generate 24 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pbDataBuffer[i*dwNumberOfChannelsTimesBytesPerSample + dwSampleOffset] = (BYTE)(dwTempDWORD & 0xff);
				pbDataBuffer[i*dwNumberOfChannelsTimesBytesPerSample + dwSampleOffset + 1] = (BYTE)((dwTempDWORD >> 8) & 0xff);
				pbDataBuffer[i*dwNumberOfChannelsTimesBytesPerSample + dwSampleOffset + 2] = (BYTE)((dwTempDWORD >> 16) & 0xff);
			}
		}
		else  // Assume 32 bit output
		{
			for (i = 0; i < dwNumberOfSamples; i++)
			{
				dwTempDWORD = (DWORD)(pslWorkingDataBuffer[i]/dblScaleFactor);  // Keep this line and the one below it seperate, or the optimizing compiler will goof up
				pdwDataBuffer[i*dwNumberOfChannels + h] = dwTempDWORD;
			}
		}
	}
	delete [] pslWorkingDataBuffer;
	pslWorkingDataBuffer = NULL;
	return(PASS);
}

DWORD CXModuleAudio::dwGetPossessionOfAudioResources(DWORD dwTimeout)
{
	DWORD x;
	int onesecond = 1000;

	// Use a mutex to avoid resource conflicts
	//
	// First, try creating the mutex. If it exists, try to open it.
	//
	hXMTAAudioMutex = CreateMutexA (NULL, FALSE, XMTA_AUDIO_MUTEX_NAME);
//	if ((hXMTAAudioMutex == NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
//		hXMTAAudioMutex = OpenMutexA (NULL, FALSE, XMTA_AUDIO_MUTEX_NAME);
	if (hXMTAAudioMutex == NULL) // still NULL?, don't even try accessing
	{
		err_MutexHandle(_T(XMTA_AUDIO_MUTEX_NAME));
		return FAIL;
	}

	// Now try to get possession of the mutex
	//
	for (x = 0; x < (dwTimeout/(DWORD)onesecond); x++)
	{
		if (WaitForSingleObject(hXMTAAudioMutex, onesecond) == WAIT_OBJECT_0)
			return (PASS);
		if (CheckAbort(HERE))
			return (FAIL);
	}
	err_MutexTimeout(_T(XMTA_AUDIO_MUTEX_NAME));
	return (FAIL);
}

void CXModuleAudio::vReleasePossessionOfAudioResources ()
{
	if (hXMTAAudioMutex != (HANDLE) -1)
	{
		ReleaseMutex (hXMTAAudioMutex);
		CloseHandle (hXMTAAudioMutex);
		hXMTAAudioMutex = (HANDLE) -1;
	}
}

// This routine computes total DC offset values for all channels and resorts the data into seperate FFT buffers sections (one per channel); each value is a signed DWORD regardless of how big the recorded values were
DWORD CXModuleAudio::dwTotalDCOffset(DWORD *pdwSourceBuffer, SLONG *pslDestBuffer, DWORD dwBitsPerSample, DWORD dwFFTSize, DWORD dwNumberOfChannels, double *pdblDCOffsetPercents)
{
	DWORD i, j;
	DWORD dwBytesPerSample;
	SLONG *pslTempPointer;
	unsigned char *pucTempPointer;
	short *pshTempPointer;
	SLONG slTotalAmplitudeTemp;
	DWORD dwTempDWORD;

	pucTempPointer = (unsigned char *)pdwSourceBuffer;  // A character pointer instead of a DWORD pointer
	pshTempPointer = (short *)pdwSourceBuffer;  // A signed 16-bit pointer instead of a DWORD pointer
	pslTempPointer = (SLONG *)pdwSourceBuffer;  // A signed 32-bit pointer instead of DWORD pointer
	dwBytesPerSample = (dwBitsPerSample+7)/8;  // This assumes that 17-24 but samples will use 3 bytes per sample
	for (i = 0; i < dwNumberOfChannels; i++)   // reconfigure for all channels
	{
		slTotalAmplitudeTemp = 0;   // Start the amplitude total at 0
		if (dwBytesPerSample == 1)  // Convert from unsigned char values to signed 32-bit values
		{
			for (j = 0; j < dwFFTSize; j++)
			{
				pslDestBuffer[j+(i*dwFFTSize)] = (SLONG)(pucTempPointer[(j*dwNumberOfChannels)+i]) - (SLONG)128;   // Fill dwDestBuffer with the channel sorted contents of dwSourceBuffer
				slTotalAmplitudeTemp = slTotalAmplitudeTemp + pslDestBuffer[j+(i*dwFFTSize)];
			}
		}
		else if (dwBytesPerSample == 2)  // Convert from signed 16-bit values to signed 32-bit values
		{
			for (j = 0; j < dwFFTSize; j++)
			{
				pslDestBuffer[j+(i*dwFFTSize)] = (SLONG)pshTempPointer[(j*dwNumberOfChannels)+i];   // Fill dwDestBuffer with the channel sorted contents of dwSourceBuffer
				slTotalAmplitudeTemp = slTotalAmplitudeTemp + pslDestBuffer[j+(i*dwFFTSize)];
			}
		}
		else if (dwBytesPerSample == 3)  // Convert from signed 24-bit values to signed 32-bit values
		{
			for (j = 0; j < dwFFTSize; j++)
			{
				dwTempDWORD = (DWORD)(pucTempPointer[(j*dwNumberOfChannels*3)+(i*3)]);
				dwTempDWORD |= ((DWORD)(pucTempPointer[(j*dwNumberOfChannels*3)+(i*3)+1]) << 8);
				dwTempDWORD |= ((DWORD)((SLONG)((char)pucTempPointer[(j*dwNumberOfChannels*3)+(i*3)+2])) << 16);  // Convert to a char, then an SLONG, and then a DWORD so that the sign is extended to fill the upper 16 bits of the DWORD
				pslDestBuffer[j+(i*dwFFTSize)] = (SLONG)dwTempDWORD;
				slTotalAmplitudeTemp = slTotalAmplitudeTemp + pslDestBuffer[j+(i*dwFFTSize)];
			}
		}
		else  // Convert from signed 32-bit values to signed 32-bit values
		{
			for (j = 0; j < dwFFTSize; j++)
			{
				pslDestBuffer[j+(i*dwFFTSize)] = pslTempPointer[(j*dwNumberOfChannels)+i];   // Fill dwDestBuffer with the channel sorted contents of dwSourceBuffer
				slTotalAmplitudeTemp = slTotalAmplitudeTemp + pslDestBuffer[j+(i*dwFFTSize)];
			}
		}
		if (slTotalAmplitudeTemp < 0)  // Make sure the offset is positive
			slTotalAmplitudeTemp = 0 - slTotalAmplitudeTemp;
		pdblDCOffsetPercents[i] = (double)slTotalAmplitudeTemp/(double)FFT_SIZE; // What is the average (the DC Offset of a single bin)?
		pdblDCOffsetPercents[i] = (pdblDCOffsetPercents[i] * (double)100)/pow((double)2, (double)(dwBitsPerSample-1)); // Now compute the percent vs. full scale
	}
	return(PASS);
}

// This routine computes the noise limit of each FFT bin based on configuration parameter settings for the noise limits
void CXModuleAudio::vCalculateRecordNoiseLimit(double *pdblNoiseLimitValues, DWORD dwFFTSize, DWORD dwBitsPerSample, DWORD dwSampleRate, WAVE_RECORD_NOISE_LIMIT* pwrnlWaveRecordNoiseLimit, DWORD dwNumberOfNoiseRanges)
{
	DWORD i, j;
	double dblZeroDBValue, dblSlope, dblLevelStart;
	DWORD dwStartBin, dwStopBin;

	dblZeroDBValue = (double)((double)((DWORD)1 << (dwBitsPerSample-2))*(double)dwFFTSize);  // This is the 0 dB value for this recorded sample
	for (i = 0; i < dwFFTSize/2; i++)
		pdblNoiseLimitValues[i] = IGNORE_BIN_VALUE;  // Fill the buffer initially with values so large that no FFT bin could reach this high; this is an indication to the test to ignore these bins when evaluating results
	for (i = 0; i < dwNumberOfNoiseRanges; i++)  // Now apply all noise ranges, one at a time
	{
		if (pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq < 1)
			pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq = 1;  // 1 Hz is the minimum frequency.  Otherwise, things get really messy with some of the computations below
		if (pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopFreq < 1)
			pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopFreq = 1;  // 1 Hz is the minimum frequency.  Otherwise, things get really messy with some of the computations below
		dwStartBin = (DWORD)((pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq * (double)dwFFTSize)/(double)dwSampleRate + (double)1.0);
		// If the value was EXACTLY aligned on an FFT bin, correct for the mathematical error
		if ((double)dwStartBin == (pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq * (double)dwFFTSize)/(double)dwSampleRate + (double)1.0)
			dwStartBin = dwStartBin - 1;
		dwStopBin = (DWORD)((pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopFreq * (double)dwFFTSize)/(double)dwSampleRate);
		dwStopBin = min(dwStopBin, (dwFFTSize/2) - 1);  // Make sure we don't run off the end of the buffer
		if (dwStartBin < dwStopBin)  // If the start and stop freqs are the same, then don't pay any attention to this range
		{
//			dblSlope = (pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopLevel - pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartLevel)/(pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopFreq - pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq);  // This would compute a linear slope across the frequency range
			dblSlope = (pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopLevel - pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartLevel)/(log10(pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStopFreq) - log10(pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq));  // This computes a logarithmic slope across the frequency range
			dblLevelStart = pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartLevel;
			for (j = dwStartBin; j <= dwStopBin; j++)
			{
//				pdblNoiseLimitValues[j] = dblZeroDBValue*pow(10.0, (dblSlope*((((double)j*(double)dwSampleRate)/(double)dwFFTSize) - (pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq)) + dblLevelStart)/20.0);  // This computes the noise level using a linear frequency range
				pdblNoiseLimitValues[j] = dblZeroDBValue*pow(10.0, (dblSlope*(log10(((double)j*(double)dwSampleRate)/(double)dwFFTSize) - log10(pwrnlWaveRecordNoiseLimit[i].dblNoiseLimitStartFreq)) + dblLevelStart)/20.0);  // This computes the noise level using a logarithmic frequency range
			}
		}
	}
}

// This routine performs an FFT on a buffer of data
// pdwMagnitude is a pre-allocated buffer of DWORDs length FFTSize/2
DWORD CXModuleAudio::dwComputeFFT(SLONG *pslInputData, DWORD *pdwMagnitude, DWORD dwFFTBits, DWORD dwFFTSize, double dblTwoPI, double dblPIOverTwo, DWORD dwWindowType)
{
	DWORD i, j, t, m, dwNum;
	DWORD dwTemp;
	double dblOmegaTemp;  /* Contains the polar values temporarily while computing the cartesian omega[] */
	double dblTempr, dblTempi;  /* A temporary real and imaginary variable set */
	int l;
	double *pdblTransformr, *pdblTransformi;
	double *pdblOmegar, *pdblOmegai;

	if (gpdwPI == NULL)  // Only spend the time computing PI if we have not done so already
	{
		if ((gpdwPI = new DWORD[dwFFTSize]) == NULL)
		{
			err_CouldNotAllocateFFTPiBufferL((unsigned long)(sizeof(DWORD)*dwFFTSize));
			return(FAIL);
		}
		for (i = 0; i < dwFFTSize; i++)  /* Generate the pi function for FFT; just binary reverse all values of i */
		{
			dwTemp = i;
			gpdwPI[i] = 0;
			for (j = 0; j < dwFFTBits; j++)
			{
				gpdwPI[i] = ((dwTemp & (DWORD)1) | (gpdwPI[i] << (DWORD)1));
				dwTemp = dwTemp >> (DWORD)1;
			}
		}
	}
	if ((pdblTransformr = new double[dwFFTSize]) == NULL)
	{
		err_CouldNotAllocateFFTRTFBufferL((unsigned long)(sizeof(double)*dwFFTSize));
		return(FAIL);
	}
	if ((pdblTransformi = new double[dwFFTSize]) == NULL)
	{
		delete [] pdblTransformr;
		pdblTransformr = NULL;
		err_CouldNotAllocateFFTITFBufferL((unsigned long)(sizeof(double)*dwFFTSize));
		return(FAIL);
	}
	if ((pdblOmegar = new double[dwFFTSize]) == NULL)
	{
		delete [] pdblTransformi;
		pdblTransformi = NULL;
		delete [] pdblTransformr;
		pdblTransformr = NULL;
		err_CouldNotAllocateFFTROFBufferL((unsigned long)(sizeof(double)*dwFFTSize));
		return(FAIL);
	}
	if ((pdblOmegai = new double[dwFFTSize]) == NULL)
	{
		delete [] pdblOmegar;
		pdblOmegar = NULL;
		delete [] pdblTransformi;
		pdblTransformi = NULL;
		delete [] pdblTransformr;
		pdblTransformr = NULL;
		err_CouldNotAllocateFFTIOFBufferL((unsigned long)(sizeof(double)*dwFFTSize));
		return(FAIL);
	}
	if (dwWindowType == COS_SQUARED_WINDOW)
	{
		for (i = 0; i < dwFFTSize; i+=2)  /* Calculate the starting point for transform[] */
		{
			pdblTransformr[i] = (double)pslInputData[gpdwPI[i]]*pow(cos((((double)gpdwPI[i]-(double)(dwFFTSize/2))/(double)(dwFFTSize/2))*dblPIOverTwo), 2) + (double)pslInputData[gpdwPI[i+1]]*pow(cos((((double)gpdwPI[i+1]-(double)(dwFFTSize/2))/(double)(dwFFTSize/2))*dblPIOverTwo), 2);
			pdblTransformi[i] = 0;
			pdblTransformr[i+1] = (double)pslInputData[gpdwPI[i]]*pow(cos((((double)gpdwPI[i]-(double)(dwFFTSize/2))/(double)(dwFFTSize/2))*dblPIOverTwo), 2) - (double)pslInputData[gpdwPI[i+1]]*pow(cos((((double)gpdwPI[i+1]-(double)(dwFFTSize/2))/(double)(dwFFTSize/2))*dblPIOverTwo), 2);
			pdblTransformi[i+1] = 0;
		}
	}
	else
	{
		for (i = 0; i < dwFFTSize; i+=2)  /* Calculate the starting point for transform[] */
		{
			pdblTransformr[i] = (double)(pslInputData[gpdwPI[i]] + pslInputData[gpdwPI[i+1]]);
			pdblTransformi[i] = 0;
			pdblTransformr[i+1] = (double)(pslInputData[gpdwPI[i]] - pslInputData[gpdwPI[i+1]]);
			pdblTransformi[i+1] = 0;
		}
	}
	for (i = 0; i < dwFFTSize; i++)  /* Calculate omega[], the dwFFTSize roots of unity for this transform */
	{
		dblOmegaTemp = ((dblTwoPI*(double)i)/(double)dwFFTSize);
		pdblOmegar[i] = cos(dblOmegaTemp);
		pdblOmegai[i] = sin(dblOmegaTemp);
	}
	m = dwFFTSize/2;
	dwNum = 2;
	for (l = (dwFFTBits-2); l >= 0; l--)
	{
		m = m/2;
		dwNum = dwNum*2;
		for (t = 0; t <= (DWORD)(((1 << l)-1)*dwNum); t += dwNum)
		{
			for (j = 0; j <= ((dwNum/2) - 1); j++)
			{
				/* First multiply omega[m*j] with transform[t+(dwNum/2)+j] */
				dblTempr = ((pdblOmegar[m*j]*pdblTransformr[t+(dwNum/2)+j]) - (pdblOmegai[m*j]*pdblTransformi[t+(dwNum/2)+j]));
				dblTempi = ((pdblOmegar[m*j]*pdblTransformi[t+(dwNum/2)+j]) + (pdblOmegai[m*j]*pdblTransformr[t+(dwNum/2)+j]));
				/* Second, compute transform[t+(dwNum/2)+j] */
				pdblTransformr[t+(dwNum/2)+j] = pdblTransformr[t+j] - dblTempr;
				pdblTransformi[t+(dwNum/2)+j] = pdblTransformi[t+j] - dblTempi;
				/* Finally, compute transform[t+j] */
				pdblTransformr[t+j] = pdblTransformr[t+j] + dblTempr;
				pdblTransformi[t+j] = pdblTransformi[t+j] + dblTempi;
			}
		}
	}
	for (i = 0; i < (dwFFTSize/2); i++)
	{
		pdwMagnitude[i] = (DWORD)sqrt(pdblTransformr[i]*pdblTransformr[i] + pdblTransformi[i]*pdblTransformi[i]);
		// We currently aren't returning dwMaxValue.  If we do in the future, the routine
		// below should be modified to ignore all bins below a certain frequency (like 20 Hz)
		// instead of arbitrarily ignoring the first 2 bins always.
		//if ((*dwMaxValue < dwMagnitude[i]) && (i >= 2))
		//	*dwMaxValue = dwMagnitude[i];
	}
	
	delete [] pdblOmegai;
	pdblOmegai = NULL;
	delete [] pdblOmegar;
	pdblOmegar = NULL;
	delete [] pdblTransformi;
	pdblTransformi = NULL;
	delete [] pdblTransformr;
	pdblTransformr = NULL;
	return(PASS);
}

// This routine makes sure all expected frequencies are within their amplitude tolerances, and 
DWORD CXModuleAudio::dwCompareFrequenciesAndNoise(DWORD *pdwMagnitude, DWORD dwFFTSize, WAVE_RECORD_CONFIGURATION_DATA wrcdWaveRecordInfo, DWORD dwChannel, double *pdblNoiseLimitValues)
{
	DWORD i, j;
	DWORD *pdwCopyOfMagnitudeBuffer = NULL;
	double dblFrequencyDB;
	double dblZeroDBValue;
	DWORD dwTempMagnitude;
	DWORD dwStatus = PASS;
	DWORD dwStartBin, dwStopBin;
	double dblMaxFrequencyDB = -1000.0, dblMaxFrequency = 1, dblMinFrequencyDB = 1000.0, dblMinFrequency = 1;
	DWORD dwMaxNoiseLevel = 1, dwMaxNoiseBin = 1;
	DWORD dwUnexpectedFrequencyErrors = 0;

	if ((pdwCopyOfMagnitudeBuffer = new DWORD [dwFFTSize/2]) == NULL)  // Allocate a buffer to work with
	{
		err_CouldNotAllocateFFTMagnitudeL((dwFFTSize/2) * sizeof(DWORD));
		return(FAIL);
	}
	memcpy(pdwCopyOfMagnitudeBuffer, pdwMagnitude, (dwFFTSize/2)*sizeof(DWORD));
	dblZeroDBValue = (double)((double)((DWORD)1 << (wrcdWaveRecordInfo.dwBitsPerSample-2))*(double)dwFFTSize);  // This is the 0 dB value for this recorded sample

	// Compare all expected frequencies to their acceptable magnitude ranges and report any errors.  Also zero out the magnitudes of those freuqencies for the noise level comparison below
	for (i = 0; i < wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].dwNumberOfFrequencies; i++)
	{
		dwTempMagnitude = 0;
		dwStartBin = min((DWORD)((((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]-wrcdWaveRecordInfo.dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) + (double)0.5), (DWORD)(((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) * ((double)1.0 - (wrcdWaveRecordInfo.dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		dwStopBin = max((DWORD)((((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]+wrcdWaveRecordInfo.dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) + (double)0.5), (DWORD)(((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) * ((double)1.0 + (wrcdWaveRecordInfo.dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		for (j = dwStartBin; j <= dwStopBin; j++)
		{
			if ((j == 0) || (j > dwFFTSize/2))  // Don't try checking FFT bins that are out of range
				continue;
			if (pdwMagnitude[j] > dwTempMagnitude)
				dwTempMagnitude = pdwMagnitude[j];
		}
		if (dwTempMagnitude == 0) // This avoids a log(0) function, which returns a strange value
			dblFrequencyDB = 20.0*log10(1/dblZeroDBValue);
		else
			dblFrequencyDB = 20.0*log10(dwTempMagnitude/dblZeroDBValue);
		if (dblMaxFrequencyDB < dblFrequencyDB) // Keep track of the maximum frequency amplitude on this channel
		{
			dblMaxFrequencyDB = dblFrequencyDB;
			dblMaxFrequency = wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i];
		}
		if (dblMinFrequencyDB > dblFrequencyDB) // Keep track of the minimum frequency amplitude on this channel
		{
			dblMinFrequencyDB = dblFrequencyDB;
			dblMinFrequency = wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i];
		}
		if ((dblFrequencyDB < (wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblAmplitude[i] - wrcdWaveRecordInfo.dblAmplitudeTolerance)) || (dblFrequencyDB > (wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblAmplitude[i] + wrcdWaveRecordInfo.dblAmplitudeTolerance)))  // The received frequency magnitude is outside of the acceptable range
		{
			err_DidNotFindExpectedSineFreqLSDDDD(dwChannel, (wrcdWaveRecordInfo.pchChannelLabel != NULL) ? wrcdWaveRecordInfo.pchChannelLabel[dwChannel] : L"", wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i], wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblAmplitude[i] + wrcdWaveRecordInfo.dblAmplitudeTolerance, wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblAmplitude[i] - wrcdWaveRecordInfo.dblAmplitudeTolerance, dblFrequencyDB);
			dwStatus = FAIL;
		}
		pdwCopyOfMagnitudeBuffer[(DWORD)(((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) + (double)0.5)] = 0;
	}
	
	// Set all of the bins within the dblFrequencyShiftPercentAllowed to 0 so that they aren't compared against noise
	for (i = 0; i < wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].dwNumberOfFrequencies; i++)
	{
		dwStartBin = min((DWORD)((((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]-wrcdWaveRecordInfo.dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) + (double)0.5), (DWORD)(((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) * ((double)1.0 - (wrcdWaveRecordInfo.dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		dwStopBin = max((DWORD)((((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]+wrcdWaveRecordInfo.dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) + (double)0.5), (DWORD)(((wrcdWaveRecordInfo.WaveChannelFreqData[dwChannel].pdblFrequency[i]*(double)dwFFTSize)/(double)wrcdWaveRecordInfo.dwSampleRate) * ((double)1.0 + (wrcdWaveRecordInfo.dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		for (j = dwStartBin; j <= dwStopBin; j++)
		{
			if ((j == 0) || (j > dwFFTSize/2))  // Don't try checking FFT bins that are out of range
				continue;
			pdwCopyOfMagnitudeBuffer[j] = 0;
		}
	}

	// Compare all bins to their permitted noise levels
	for (i = 1; i < dwFFTSize/2; i++)  // Don't ever compare the DC bin (bin 0)
	{
		if (pdblNoiseLimitValues[i] != IGNORE_BIN_VALUE)
		{
			if (dwMaxNoiseLevel < pdwCopyOfMagnitudeBuffer[i]) // Keep track of the maximum noise on this channel
			{
				dwMaxNoiseLevel = pdwCopyOfMagnitudeBuffer[i];
				dwMaxNoiseBin = i;
			}
			if (pdwCopyOfMagnitudeBuffer[i] > pdblNoiseLimitValues[i])  // This bin's noise is too high
			{
				err_DetectedUnexpectedSineFreqLSDDD(dwChannel, (wrcdWaveRecordInfo.pchChannelLabel != NULL) ? wrcdWaveRecordInfo.pchChannelLabel[dwChannel] : L"", (double)(i*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize, 20.0*log10(pdblNoiseLimitValues[i]/dblZeroDBValue), 20.0*log10(pdwCopyOfMagnitudeBuffer[i]/dblZeroDBValue));
				dwStatus = FAIL;
				if (dwUnexpectedFrequencyErrors < 6)
				{
					dwUnexpectedFrequencyErrors++;
				}
				else
				{
					if (CheckAbort(HERE))
						break;
				}
			}
		}
	}


	if (wTestNumber == ANALOG_PLAYBACK_TEST)
	{
		if (dwChannel == 0)
		{
			ReportStatistic(XAUDIO_ANALOG_MAX_FREQUENCY_AMPLITUDE_LEFT_CHANNEL, _T("%.3lf,%.1lf"), dblMaxFrequencyDB, dblMaxFrequency);
			ReportStatistic(XAUDIO_ANALOG_MIN_FREQUENCY_AMPLITUDE_LEFT_CHANNEL, _T("%.3lf,%.1lf"), dblMinFrequencyDB, dblMinFrequency);
			ReportStatistic(XAUDIO_ANALOG_MAX_NOISE_LEVEL_LEFT_CHANNEL, _T("%.3lf,%.1lf"), 20.0*log10(dwMaxNoiseLevel/dblZeroDBValue), (double)(dwMaxNoiseBin*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize);
		}
		else
		{
			ReportStatistic(XAUDIO_ANALOG_MAX_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), dblMaxFrequencyDB, dblMaxFrequency);
			ReportStatistic(XAUDIO_ANALOG_MIN_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), dblMinFrequencyDB, dblMinFrequency);
			ReportStatistic(XAUDIO_ANALOG_MAX_NOISE_LEVEL_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), 20.0*log10(dwMaxNoiseLevel/dblZeroDBValue), (double)(dwMaxNoiseBin*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize);
		}
	}
	else if (wTestNumber == ANALOG_SILENCE_TEST)
	{
		if (dwChannel == 0)
		{
//			ReportStatistic(XAUDIO_SILENCE_MAX_FREQUENCY_AMPLITUDE_LEFT_CHANNEL, _T("%.3lf,%.1lf"), dblMaxFrequencyDB, dblMaxFrequency);
//			ReportStatistic(XAUDIO_SILENCE_MIN_FREQUENCY_AMPLITUDE_LEFT_CHANNEL, _T("%.3lf,%.1lf"), dblMinFrequencyDB, dblMinFrequency);
			ReportStatistic(XAUDIO_SILENCE_MAX_NOISE_LEVEL_LEFT_CHANNEL, _T("%.3lf,%.1lf"), 20.0*log10(dwMaxNoiseLevel/dblZeroDBValue), (double)(dwMaxNoiseBin*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize);
		}
		else
		{
//			ReportStatistic(XAUDIO_SILENCE_MAX_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), dblMaxFrequencyDB, dblMaxFrequency);
//			ReportStatistic(XAUDIO_SILENCE_MIN_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), dblMinFrequencyDB, dblMinFrequency);
			ReportStatistic(XAUDIO_SILENCE_MAX_NOISE_LEVEL_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), 20.0*log10(dwMaxNoiseLevel/dblZeroDBValue), (double)(dwMaxNoiseBin*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize);
		}
	}
	else // assume DIGITAL_PLAYBACK_TEST
	{
		if (dwChannel == 0)
		{
			ReportStatistic(XAUDIO_DIGITAL_MAX_FREQUENCY_AMPLITUDE_LEFT_CHANNEL, _T("%.3lf,%.1lf"), dblMaxFrequencyDB, dblMaxFrequency);
			ReportStatistic(XAUDIO_DIGITAL_MIN_FREQUENCY_AMPLITUDE_LEFT_CHANNEL, _T("%.3lf,%.1lf"), dblMinFrequencyDB, dblMinFrequency);
			ReportStatistic(XAUDIO_DIGITAL_MAX_NOISE_LEVEL_LEFT_CHANNEL, _T("%.3lf,%.1lf"), 20.0*log10(dwMaxNoiseLevel/dblZeroDBValue), (double)(dwMaxNoiseBin*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize);
		}
		else
		{
			ReportStatistic(XAUDIO_DIGITAL_MAX_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), dblMaxFrequencyDB, dblMaxFrequency);
			ReportStatistic(XAUDIO_DIGITAL_MIN_FREQUENCY_AMPLITUDE_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), dblMinFrequencyDB, dblMinFrequency);
			ReportStatistic(XAUDIO_DIGITAL_MAX_NOISE_LEVEL_RIGHT_CHANNEL, _T("%.3lf,%.1lf"), 20.0*log10(dwMaxNoiseLevel/dblZeroDBValue), (double)(dwMaxNoiseBin*wrcdWaveRecordInfo.dwSampleRate)/(double)dwFFTSize);
		}
	}

	delete [] pdwCopyOfMagnitudeBuffer;
	pdwCopyOfMagnitudeBuffer = NULL;
	return(dwStatus);
}

// Traditional audio measurements:
//
// Total Harmonic Distortion plus noise (THD+N) is the ratio of the RMS sum of
// the noise and distortion components (but not the test signal) to 0 dB FS in the
// presence of a test signal close to FS.  To meaure this, send in a single sine wave
// of around 1 kHz between 0 and -3 dB FS.  After the FFT, RMS all bins except for the
// fundamental frequency, and compare this value to 0 dB FS.
//
// Dynamic Range (DR) is similar to THD+N, except that the test signal is -60 dB FS.
// All measurements are done the same way as with THD+N.
//
// Signal-to-Noise ratio (S/N) is not well defined.  The most common definition is the
// same as for THD+N.
//
// To compute S/N ratio in our test, we add up the amplitudes of the fundamental frequencies
// and then ratio that value to the RMS of everything else (noise, harmonics, etc).  This
// is a "real" THD+N calculation if a single near 0 dB FS sine wave of near 1000 Hz is
// applied, but will also yield satisfactory results is multiple frequencies are used
// simultaneously.
DWORD CXModuleAudio::dwComputeSignalToNoise(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, double *pdblFrequencies, DWORD dwNumberOfFrequencies, DWORD dwSampleRate, double *pdblNoiseLimitValues, double dblFrequencyShiftHzAllowed, double *pdblSignalToNoiseRatioToReturn)
{
	DWORD i, j;
	double dblTotalFreqAmplitude = 0;
	double *pdblCopyOfNoiseLimitBuffer = NULL;
	DWORD dwTempMagnitude;
	DWORD dwStartBin, dwStopBin;
	DWORD dwNumberOfBinsSummed = 0;
	double dblTotalNoiseSquared = 0, dblMeanNoiseSquared = 0, dblRootMeanSquared = 0;

	if ((pdblCopyOfNoiseLimitBuffer = new double [dwFFTSize/2]) == NULL)  // Allocate a buffer to work with
	{
		err_CouldNotAllocateNoiseLimitsL((unsigned long)(sizeof(double)*(dwFFTSize/2)));
		return(FAIL);
	}
	memcpy(pdblCopyOfNoiseLimitBuffer, pdblNoiseLimitValues, (dwFFTSize/2)*sizeof(double));
	for (i = 0; i < dwNumberOfFrequencies; i++)  // Add up the magnitudes of the received frequencies
	{
		dwTempMagnitude = 0;
		dwStartBin = min((DWORD)((((pdblFrequencies[i]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((pdblFrequencies[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		dwStopBin = max((DWORD)((((pdblFrequencies[i]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((pdblFrequencies[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		for (j = dwStartBin; j <= dwStopBin; j++)
		{
			if ((j == 0) || (j > dwFFTSize/2))  // Don't try checking FFT bins that are out of range
				continue;
			if (pdwMagnitude[j] > dwTempMagnitude)
				dwTempMagnitude = pdwMagnitude[j];
			pdblCopyOfNoiseLimitBuffer[j] = IGNORE_BIN_VALUE;
		}
		dblTotalFreqAmplitude = dblTotalFreqAmplitude + (double)dwTempMagnitude;
	}
	for (i = 0; i < dwFFTSize/2; i++)  // Now look at every bin that is not to be ignored to see which one has the largest magnitude
	{
		if (pdblCopyOfNoiseLimitBuffer[i] != IGNORE_BIN_VALUE)
		{
			dwNumberOfBinsSummed += 1;
			dblTotalNoiseSquared = dblTotalNoiseSquared + ((double)pdwMagnitude[i] * (double)pdwMagnitude[i]);
		}
	}
	dblMeanNoiseSquared = dblTotalNoiseSquared/(double)dwNumberOfBinsSummed;
	if (dblMeanNoiseSquared < 1)
		dblMeanNoiseSquared = 1; // Just for safety with calculations below
	dblRootMeanSquared = (double)sqrt(dblMeanNoiseSquared);
//ReportDebug (BIT0, L"NumberOfBinsSummed = %lu\n", dwNumberOfBinsSummed);
//ReportDebug (BIT0, L"RMS = %lf\n", dblRootMeanSquared);

	*pdblSignalToNoiseRatioToReturn = 20*log10(dblTotalFreqAmplitude/dblRootMeanSquared); // Compute the found S/N ratio
//ReportDebug (BIT0, L"S/N ratio = %lf\n", *pdblSignalToNoiseRatioToReturn);
	delete [] pdblCopyOfNoiseLimitBuffer;
	pdblCopyOfNoiseLimitBuffer = NULL;

	return(PASS);
}

// This routine computes the dB value between the sum of the fundamental frequencies received on this
// channel and the RMS of the values obtained from all other bins excluding those corresponding to playback and record
// frequencies on other channels.
DWORD CXModuleAudio::dwComputeSignalToNoiseIgnoringCrosstalk(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, WAVE_RECORD_CHANNEL_FREQ_DATA *WaveRecordChannelFreqData, DWORD dwRecordNumberOfChannels, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *WavePlaybackChannelFreqData, DWORD dwPlaybackNumberOfChannels, DWORD dwChannelNumber, DWORD dwSampleRate, double *pdblNoiseLimitValues, double dblFrequencyShiftHzAllowed, double *pdblSignalToNoiseRatioToReturn)
{
	DWORD i, j, k;
	double dblTotalFreqAmplitude = 0;
	double *pdblCopyOfNoiseLimitBuffer = NULL;
	DWORD dwTempMagnitude;
	DWORD dwStartBin, dwStopBin;
	DWORD dwNumberOfBinsSummed = 0;
	double dblTotalNoiseSquared = 0, dblMeanNoiseSquared = 0, dblRootMeanSquared = 0;

	if ((pdblCopyOfNoiseLimitBuffer = new double [dwFFTSize/2]) == NULL)  // Allocate a buffer to work with
	{
		err_CouldNotAllocateNoiseLimitsL((unsigned long)(sizeof(double)*(dwFFTSize/2)));
		return(FAIL);
	}
	memcpy(pdblCopyOfNoiseLimitBuffer, pdblNoiseLimitValues, (dwFFTSize/2)*sizeof(double));
	for (i = 0; i < WaveRecordChannelFreqData[dwChannelNumber].dwNumberOfFrequencies; i++)  // Add up the magnitudes of the received frequencies
	{
		dwTempMagnitude = 0;
		dwStartBin = min((DWORD)((((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		dwStopBin = max((DWORD)((((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		for (j = dwStartBin; j <= dwStopBin; j++)
		{
			if ((j == 0) || (j > dwFFTSize/2))  // Don't try checking FFT bins that are out of range
				continue;
			if (pdwMagnitude[j] > dwTempMagnitude)
				dwTempMagnitude = pdwMagnitude[j];
			pdblCopyOfNoiseLimitBuffer[j] = IGNORE_BIN_VALUE;
		}
		dblTotalFreqAmplitude = dblTotalFreqAmplitude + (double)dwTempMagnitude;
	}

	for (i = 0; i < dwRecordNumberOfChannels; i++)  // Now force all bins associated with a fundamental freq on any record channel to 0
	{
		for (j = 0; j < WaveRecordChannelFreqData[i].dwNumberOfFrequencies; j++)
		{
			dwStartBin = min((DWORD)((((WaveRecordChannelFreqData[i].pdblFrequency[j]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			dwStopBin = max((DWORD)((((WaveRecordChannelFreqData[i].pdblFrequency[j]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			for (k = dwStartBin; k <= dwStopBin; k++)
			{
				if ((k == 0) || (k > dwFFTSize/2))  // Don't try checking FFT bins that are out of range
					continue;
				pdblCopyOfNoiseLimitBuffer[k] = IGNORE_BIN_VALUE;
			}
		}
	}
	for (i = 0; i < dwPlaybackNumberOfChannels; i++)  // Now force all bins associated with a fundamental freq on any playback channel to 0
	{
		for (j = 0; j < WavePlaybackChannelFreqData[i].dwNumberOfFrequencies; j++)
		{
			dwStartBin = min((DWORD)((((WavePlaybackChannelFreqData[i].pdblFrequency[j]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WavePlaybackChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			dwStopBin = max((DWORD)((((WavePlaybackChannelFreqData[i].pdblFrequency[j]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WavePlaybackChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			for (k = dwStartBin; k <= dwStopBin; k++)
			{
				if ((k == 0) || (k > dwFFTSize/2))  // Don't try checking FFT bins that are out of range
					continue;
				pdblCopyOfNoiseLimitBuffer[k] = IGNORE_BIN_VALUE;
			}
		}
	}
	for (i = 0; i < dwFFTSize/2; i++)  // Now look at every bin that is not to be ignored to see which one has the largest magnitude
	{
		if (pdblCopyOfNoiseLimitBuffer[i] != IGNORE_BIN_VALUE)
		{
			dwNumberOfBinsSummed += 1;
			dblTotalNoiseSquared = dblTotalNoiseSquared + ((double)pdwMagnitude[i] * (double)pdwMagnitude[i]);
		}
	}

	dblMeanNoiseSquared = dblTotalNoiseSquared/(double)dwNumberOfBinsSummed;
	if (dblMeanNoiseSquared < 1)
		dblMeanNoiseSquared = 1; // Just for safety with calculations below
	dblRootMeanSquared = (double)sqrt(dblMeanNoiseSquared);
//ReportDebug (BIT0, L"NumberOfBinsSummed = %lu\n", dwNumberOfBinsSummed);
//ReportDebug (BIT0, L"RMS = %lf\n", dblRootMeanSquared);

	*pdblSignalToNoiseRatioToReturn = 20*log10(dblTotalFreqAmplitude/dblRootMeanSquared); // Compute the found S/N ratio
//ReportDebug (BIT0, L"S/N ratio = %lf\n", *pdblSignalToNoiseRatioToReturn);
	delete [] pdblCopyOfNoiseLimitBuffer;
	pdblCopyOfNoiseLimitBuffer = NULL;

	return(PASS);
}

// This routine computes the dB value between the average of the fundamental frequencies received on this
// channel and the largest value obtained from all bins corresponding to playback and record frequencies on other channels.
DWORD CXModuleAudio::dwComputeChannelSeparation(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, WAVE_RECORD_CHANNEL_FREQ_DATA *WaveRecordChannelFreqData, DWORD dwRecordNumberOfChannels, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *WavePlaybackChannelFreqData, DWORD dwPlaybackNumberOfChannels, DWORD dwChannelNumber, DWORD dwSampleRate, double dblFrequencyShiftHzAllowed, double *pdblChannelSeparationToReturn, double *pdblNoiseLimitValues)
{
	DWORD i, j, k;
	double dblTotalFreqAmplitude = 0;
	double dblAverageFreqAmplitude;
	DWORD *pdwCopyOfMagnitudeBuffer = NULL;
	DWORD dwMaxCrosstalkValue = 0;
	DWORD dwTempMagnitude;
	DWORD dwStartBin, dwStopBin;

	if ((pdwCopyOfMagnitudeBuffer = new DWORD [dwFFTSize/2]) == NULL)  // Allocate a buffer to work with
	{
		err_CouldNotAllocateFFTMagnitudeL((dwFFTSize/2) * sizeof(DWORD));
		return(FAIL);
	}
	memcpy(pdwCopyOfMagnitudeBuffer, pdwMagnitude, (dwFFTSize/2)*sizeof(DWORD));
	for (i = 0; i < WaveRecordChannelFreqData[dwChannelNumber].dwNumberOfFrequencies; i++)  // Add up the magnitudes of the received frequencies
	{
		dwTempMagnitude = 0;
		dwStartBin = min((DWORD)((((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		dwStopBin = max((DWORD)((((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[dwChannelNumber].pdblFrequency[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		for (j = dwStartBin; j <= dwStopBin; j++)
		{
			if ((j == 0) || (j > dwFFTSize/2) || (pdblNoiseLimitValues[j] == IGNORE_BIN_VALUE))  // Don't try checking FFT bins that are out of range
				continue;
			if (pdwMagnitude[j] > dwTempMagnitude)
				dwTempMagnitude = pdwMagnitude[j];
			pdwCopyOfMagnitudeBuffer[j] = 0;  // Zero this out so that it does not come into play when we scan this buffer for crosstalk magnitudes
		}
		dblTotalFreqAmplitude = dblTotalFreqAmplitude + (double)dwTempMagnitude;
	}
	dblAverageFreqAmplitude = dblTotalFreqAmplitude/(double)WaveRecordChannelFreqData[dwChannelNumber].dwNumberOfFrequencies;
	// Look at the record frequency bins
	for (i = 0; i < dwRecordNumberOfChannels; i++)  // Look at frequencies from all channels
	{
		for (j = 0; j < WaveRecordChannelFreqData[i].dwNumberOfFrequencies; j++)
		{
			dwTempMagnitude = 0;
			dwStartBin = min((DWORD)((((WaveRecordChannelFreqData[i].pdblFrequency[j]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			dwStopBin = max((DWORD)((((WaveRecordChannelFreqData[i].pdblFrequency[j]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WaveRecordChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			for (k = dwStartBin; k <= dwStopBin; k++)
			{
				if ((k == 0) || (k > dwFFTSize/2) || (pdblNoiseLimitValues[k] == IGNORE_BIN_VALUE))  // Don't try checking FFT bins that are out of range
					continue;
				if (pdwCopyOfMagnitudeBuffer[k] > dwTempMagnitude)
					dwTempMagnitude = pdwCopyOfMagnitudeBuffer[k];
			}
			if (dwMaxCrosstalkValue < dwTempMagnitude)
			{
				dwMaxCrosstalkValue = dwTempMagnitude;
/*
wchar_t wszLTemp[200];
wsprintf(wszLTemp, L"A Bin %lu val %lu\n", k, dwMaxCrosstalkValue);
OutputDebugString(wszLTemp);
*/
			}
		}
	}
	// Look at the playback frequency bins
	for (i = 0; i < dwPlaybackNumberOfChannels; i++)  // Look at frequencies from all channels
	{
		for (j = 0; j < WavePlaybackChannelFreqData[i].dwNumberOfFrequencies; j++)
		{
			dwTempMagnitude = 0;
			dwStartBin = min((DWORD)((((WavePlaybackChannelFreqData[i].pdblFrequency[j]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WavePlaybackChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			dwStopBin = max((DWORD)((((WavePlaybackChannelFreqData[i].pdblFrequency[j]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((WavePlaybackChannelFreqData[i].pdblFrequency[j]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			for (k = dwStartBin; k <= dwStopBin; k++)
			{
				if ((k == 0) || (k > dwFFTSize/2) || (pdblNoiseLimitValues[k] == IGNORE_BIN_VALUE))  // Don't try checking FFT bins that are out of range
					continue;
				if (pdwCopyOfMagnitudeBuffer[k] > dwTempMagnitude)
					dwTempMagnitude = pdwCopyOfMagnitudeBuffer[k];
			}
			if (dwMaxCrosstalkValue < dwTempMagnitude)
			{
				dwMaxCrosstalkValue = dwTempMagnitude;
/*
wchar_t wszLTemp[200];
wsprintf(wszLTemp, L"B Bin %lu val %lu\n", k, dwMaxCrosstalkValue);
OutputDebugString(wszLTemp);
*/
			}
		}
	}

	if (dwMaxCrosstalkValue == 0)
		dwMaxCrosstalkValue = 1;  // Avoid a divide by zero, though this is extremely unlikely
	*pdblChannelSeparationToReturn = 20*log10(dblAverageFreqAmplitude/(double)dwMaxCrosstalkValue); // Compute the found channel separation value
	delete [] pdwCopyOfMagnitudeBuffer;
	pdwCopyOfMagnitudeBuffer = NULL;
	return(PASS);
}

// This routine computes the dB value of the difference between the levels of all of the fundamental frequencies recorded.
#pragma optimize("g", off)
DWORD CXModuleAudio::dwComputeFrequencyResponse(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, double *pdblFrequencies, DWORD dwNumberOfFrequencies, double dblBaseMagnitude, DWORD dwBitsPerSample, DWORD dwSampleRate, double dblFrequencyShiftHzAllowed, double *pdblFrequencyResponseToReturn, double *pdblNoiseLimitValues)
{
	DWORD i, j;
	double dblTotalFreqAmplitude = 0;
	double dblAverageFreqAmplitude;
	double dblZeroDBValue;
	double dblTempDBDifference;
	DWORD dwTempMagnitude;
	DWORD dwStartBin, dwStopBin;

	*pdblFrequencyResponseToReturn = 0;
	dblZeroDBValue = (double)((double)((DWORD)1 << (dwBitsPerSample-2))*(double)dwFFTSize);  // This is the 0 dB value for this recorded sample
	if (dblBaseMagnitude == AVERAGE_FREQUENCY_RESPONSE_LEVEL)  // Average the BaseMagnitude value
	{
		for (i = 0; i < dwNumberOfFrequencies; i++)  // Add up the magnitudes of the received frequencies
		{
			dwTempMagnitude = 0;
			dwStartBin = min((DWORD)((((pdblFrequencies[i]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((pdblFrequencies[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			dwStopBin = max((DWORD)((((pdblFrequencies[i]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((pdblFrequencies[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
			for (j = dwStartBin; j <= dwStopBin; j++)
			{
				if ((j == 0) || (j > dwFFTSize/2) || (pdblNoiseLimitValues[j] == IGNORE_BIN_VALUE))  // Don't try checking FFT bins that are out of range
					continue;
				if (pdwMagnitude[j] > dwTempMagnitude)
					dwTempMagnitude = pdwMagnitude[j];
			}
			dblTotalFreqAmplitude = dblTotalFreqAmplitude + (double)dwTempMagnitude;
		}
		dblAverageFreqAmplitude = dblTotalFreqAmplitude/(double)dwNumberOfFrequencies;
	}
	else
		dblAverageFreqAmplitude = dblZeroDBValue * pow(10.0, (dblBaseMagnitude/20.0));

	for (i = 0; i < dwNumberOfFrequencies; i++)  // Find the largest difference between a fundamental and the base magnitude
	{
		dwTempMagnitude = 1;  // Start at 1 to prevent a log10(0) below
		dwStartBin = min((DWORD)((((pdblFrequencies[i]-dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((pdblFrequencies[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 - (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		dwStopBin = max((DWORD)((((pdblFrequencies[i]+dblFrequencyShiftHzAllowed)*(double)dwFFTSize)/(double)dwSampleRate) + (double)0.5), (DWORD)(((pdblFrequencies[i]*(double)dwFFTSize)/(double)dwSampleRate) * ((double)1.0 + (dblFrequencyShiftPercentAllowed/(double)100.0)) + (double)0.5));
		for (j = dwStartBin; j <= dwStopBin; j++)
		{
			if ((j == 0) || (j > dwFFTSize/2) || (pdblNoiseLimitValues[j] == IGNORE_BIN_VALUE))  // Don't try checking FFT bins that are out of range
				continue;
			if (pdwMagnitude[j] > dwTempMagnitude)
				dwTempMagnitude = pdwMagnitude[j];
		}

		if (dblAverageFreqAmplitude != 0)
			dblTempDBDifference = 20.0*log10(dwTempMagnitude/dblAverageFreqAmplitude);
		else
			dblTempDBDifference = 0;
		if (dblTempDBDifference < 0)
			dblTempDBDifference = 0 - dblTempDBDifference;
		if (*pdblFrequencyResponseToReturn < dblTempDBDifference)
			*pdblFrequencyResponseToReturn = dblTempDBDifference;
	}
	return(PASS);
}
#pragma optimize("", on)

// This routine computes the CRC of a buffer of Bytes
DWORD CXModuleAudio::dwComputeCRC(unsigned char *pucBuffer, DWORD dwNumBytes, DWORD dwCRC)
{
	DWORD i;

	for (i = 0; i < dwNumBytes; i++)
		dwCRC = crctab[(dwCRC ^ pucBuffer[i]) & 0x0ff] ^ (dwCRC >> 8);
	return dwCRC;
}

// This routine releases a set of global variables for every test retry loop
void CXModuleAudio::vStraightenUpTestVariables(void)
{
	DWORD j;

	if (pdwWaveInBuffer != NULL) {delete [] pdwWaveInBuffer; pdwWaveInBuffer = NULL;}
	if (WaveFormatex != NULL) {delete WaveFormatex; WaveFormatex = NULL;}
	if (pslFFTInputBuffer != NULL) {delete [] pslFFTInputBuffer; pslFFTInputBuffer = NULL;}
	if (pdblDCOffsetPercents != NULL) {delete [] pdblDCOffsetPercents; pdblDCOffsetPercents = NULL;}
	if (pdblNoiseLimitValues != NULL) {delete [] pdblNoiseLimitValues; pdblNoiseLimitValues = NULL;}
	if (pdwMagnitudeValues != NULL) {delete [] pdwMagnitudeValues; pdwMagnitudeValues = NULL;}

	// Release these in the order allocated because they lock the buffers that are set to them and will
	// not allow the buffers to be freed until after release.
	if (pSecondaryBufferPre8 != NULL)
	{
		for (j = 0; j < dwNumberOfFrequencies; j++)
		{
			if (pSecondaryBufferPre8[j] != NULL)
			{
				pSecondaryBufferPre8[j]->Release();
				pSecondaryBufferPre8[j] = NULL;
			}
		}
		delete [] pSecondaryBufferPre8;
		pSecondaryBufferPre8 = NULL;
	}
	if (pSecondaryBuffer != NULL)
	{
		for (j = 0; j < dwNumberOfFrequencies; j++)
		{
			if (pSecondaryBuffer[j] != NULL)
			{
				pSecondaryBuffer[j]->Release();
				pSecondaryBuffer[j] = NULL;
			}
		}
		delete [] pSecondaryBuffer;
		pSecondaryBuffer = NULL;
	}
	if (ppdwWaveOutBuffer != NULL)
	{
		for (j = 0; j < dwNumberOfFrequencies; j++)
		{
			if (ppdwWaveOutBuffer[j] != NULL)
			{
				VirtualFree(ppdwWaveOutBuffer[j], 0, MEM_RELEASE);
				ppdwWaveOutBuffer[j] = NULL;
			}
		}
		delete [] ppdwWaveOutBuffer;
		ppdwWaveOutBuffer = NULL;
	}

	if (pPrimaryBuffer != NULL)
	{
		pPrimaryBuffer->Release();
		pPrimaryBuffer = NULL;
	}
	if (hDSWnd != NULL)
	{
		CloseHandle(hDSWnd);
		hDSWnd = NULL;
	}
	if (pDSoundOut != NULL)
	{
		pDSoundOut->Release();
		pDSoundOut = NULL;
	}
	vReleasePossessionOfAudioResources();
	if (gpF != NULL)
	{
		fclose(gpF);
		gpF = NULL;
	}
}

#ifndef _XBOX
BOOL CALLBACK CXModuleAudio::bDSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext)
{
	UNREFERENCED_PARAMETER (lpcstrModule);
	CXModuleAudio *pthis = (CXModuleAudio *)lpContext;

	if (lpGuid != 0) // The system's primary sound driver may return a NULL LPGUID
	{
		if (wcsicmp((LPCTSTR)lpcstrDescription, pthis->gpWavePlaybackConfigurationData->pwszAudioOutDevName) == 0)  // We found a match
		{
			pthis->gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID = lpGuid;  // Use this device
			pthis->ReportDebug(0x01, L"Found a match: %s\n", lpcstrDescription);
		}
		// If pAudioOutDevToUseGUID is NULL, then this is the first device.  Use it as a default.  If a real match exists, this will be overwritten by the match in a later CALLBACK to this function
		if (pthis->gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID == NULL)
			pthis->gpWavePlaybackConfigurationData->pAudioOutDevToUseGUID = lpGuid;  // Use this device as default
	}
	if (lpcstrDescription != NULL)
		pthis->ReportDebug(0x01, L"Found DirectSound device: %s\n", lpcstrDescription);
	return TRUE;
}
#endif


// Need to add proper CheckAbort(HERE) calls.  Especially need them when waiting on other events
// Are the S/N and S/N/C calculations correct?
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xaudio\xaudio.h ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
// Intel Confidential
// WinAudio.h : main header file for the WINAUDIO WinMTA module
//
#if !defined(_XAUDIO_H_)
#define _XAUDIO_H_

// supress futile warnings about assignment operators
#pragma warning (disable:4512)

#include "..\parameter.h"
#include <dsound.h>

#ifndef _XBOX // Win32 libraries
#pragma comment (lib, "winmm.lib")
#pragma comment (lib, "dsound.lib")
#pragma comment (lib, "dxguid.lib")
#endif

// We assume that short will always be signed 16-bit, and char will always be signed 8-bit
typedef long SLONG;  // Define Signed LONG (signed 32-bit value)
#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif

#define XAUDIO_MODNUM   2

#define XMTA_AUDIO_MUTEX_NAME  "XMTA_AUDIO"

#define AUDIO_HOST_TIMEOUT 180 // Wait for 3 minutes for the host to respond to any communications
#define PARAMETER_REV_FOR_AUDIO_RECORD_ANALOG  1
#define PARAMETER_REV_FOR_AUDIO_RECORD_DIGITAL 1

// Naming of class test and module classes.
// 
// module class: CXmta<module>
// test class:   CXmta<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//

typedef struct {
	DWORD dwNumberOfFrequencies;
	double *pdblFrequency;
	double *pdblSamplesPerPeriod;
} WAVE_PLAYBACK_CHANNEL_FREQ_DATA;

typedef struct {
	LPCTSTR pwszAudioOutDevName;
	UINT  uiAudioOutDevToUse;
	LPGUID pAudioOutDevToUseGUID;
	DWORD dwNumberOfChannels;
	DWORD dwBitsPerSample;
	DWORD dwSampleRate;
	DWORD dwDigitalAttenuation;
	WAVE_PLAYBACK_CHANNEL_FREQ_DATA *WaveChannelFreqData;
} WAVE_PLAYBACK_CONFIGURATION_DATA;

typedef struct {
	char *name;
	WAVE_PLAYBACK_CONFIGURATION_DATA *data;
} PLAYBACK_TEST_CONFIGURATIONS;

typedef struct {
	DWORD dwNumberOfFrequencies;
	double *pdblFrequency;  // In Hz
	double *pdblAmplitude;  // In dB (normally negative)
} WAVE_RECORD_CHANNEL_FREQ_DATA;

// An array of these structures will contain the noise level ranges that the test will compare input data against.  The ranges are lines between the startlevel and the stoplevel
typedef struct {
	double dblNoiseLimitStartFreq;  // In Hz
	double dblNoiseLimitStopFreq;   // In Hz
	double dblNoiseLimitStartLevel; // In dB relative to full-scale (so a negative number)
	double dblNoiseLimitStopLevel;  // In dB relative to full-scale (so a negative number)
} WAVE_RECORD_NOISE_LIMIT;

typedef struct {
	LPCTSTR pwszAudioInDevName;
	UINT  uiAudioInDevToUse;
	DWORD dwNumberOfChannels;
	wchar_t **pchChannelLabel;
	DWORD dwBitsPerSample;
	DWORD dwSampleRate;
	DWORD dwCRC;                    // CRC used for digital loopback testing
	DWORD dwFFTWindowFunction;
	double dblAmplitudeTolerance;   // In dB (positive)
	double dblMaxDCOffsetPercent;   // The default for this should be 100; in which case we shouldn't even bother computing the DC offset (save some time)
	double dblSignalToNoiseRatio;   // In dB (positive)
	double dblSignalToNoiseRatioIgnoringCrosstalk;   // In dB (positive)
	double dblChannelSeparation;    // In dB (positive)
	double dblFrequencyResponseTolerance;            // In dB (positive)
	double dblFrequencyResponseLevel;                // In dB (negative)
	double dblFrequencyShiftPercentAllowed;               // 60 is great for 44100 sampling with COS_SQUARED, 35 is great for 22050 sampling with COS_SQUARED, 20 is great for 11025 sampling with COS_SQUARED
	double dblFrequencyShiftHzAllowed;               // 60 is great for 44100 sampling with COS_SQUARED, 35 is great for 22050 sampling with COS_SQUARED, 20 is great for 11025 sampling with COS_SQUARED
	DWORD dwNumberOfNoiseRanges;    // Calculated, not read from a config parameter
	WAVE_RECORD_NOISE_LIMIT *WaveRecordNoiseLimit;
	WAVE_RECORD_CHANNEL_FREQ_DATA *WaveChannelFreqData;
} WAVE_RECORD_CONFIGURATION_DATA;

typedef struct {
	char *name;
	WAVE_RECORD_CONFIGURATION_DATA *data;
} RECORD_TEST_CONFIGURATIONS;

typedef struct {
	DWORD dwMuxControlLowDWORD;
	DWORD dwMuxControlHighDWORD;
} AUDIO_MUX_CONFIGURATION_INFORMATION;


class CXModuleAudio : public CTestObj
{
public:
	DECLARE_XMTAMODULE (CXModuleAudio, "audio", XAUDIO_MODNUM);  //(module name, module number)

protected:
	// Error messages declared here ...
	//(Note: 0x000 - 0x00f reserved for XMTA)
	//

	// Error routines return true if the calling routine should abort, and false otherwise
	bool err_BADPARAMETER (LPCTSTR s1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x010, L"Can't find configuration parameter \"%s\"\nThis configuration parameter doesn't exist or is invalid", s1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateWAVEFORMATEX () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x011,L"Could not allocate a WAVEFORMATEX data structure"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateRecordBuffer (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x012,L"Could not allocate memory for a %lu byte audio record buffer", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocWavePlayConfigDataL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x013,L"Could not allocate a %lu byte WAVE_PLAYBACK_CONFIGURATION_DATA structure to hold WAVE playback configuration information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocWavePlayChannelFreqDataL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x014,L"Could not allocate a %lu byte array of WAVE_PLAYBACK_CHANNEL_FREQ_DATA structures to hold WAVE playback frequency information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocDoublesForPlaybackFreqL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x015,L"Could not allocate a %lu byte array of doubles to hold playback frequency information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocDoublesForPlaybackSPPL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x016,L"Could not allocate a %lu byte array of doubles to hold playback samples-per-period information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CantReadPlaybackFreqData () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x017,L"Could not read playback frequency configuration parameters"); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocWaveRecordConfigDataL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x018,L"Could not allocate a %lu byte WAVE_RECORD_CONFIGURATION_DATA structure to hold WAVE record configuration information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocWaveRecordNoiseLimitL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x019,L"Could not allocate a %lu byte array of WAVE_RECORD_NOISE_LIMIT structures to hold WAVE record noise limits information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocWaveRecordChannelFreqDataL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x01A,L"Could not allocate a %lu byte array of WAVE_RECORD_CHANNEL_FREQ_DATA structures to hold WAVE record frequency information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocDoublesForRecordFreqL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x01B,L"Could not allocate a %lu byte array of doubles to hold record frequency information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocDoublesForRecordAmplitudeL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x01C,L"Could not allocate a %lu byte array of doubles to hold record amplitude information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CantReadRecordNoiseLimit () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x01D,L"Could not read record noise limit configuration parameters"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CantReadRecordFreqData () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x01E,L"Could not read record frequency configuration parameters"); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocAudioMuxConfigInfoL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x01F,L"Could not allocate a %lu byte AUDIO_MUX_CONFIGURATION_INFORMATION structure to hold audio mux configuration information", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocatePlaybackBuffer (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x020,L"Could not allocate memory for a %lu byte audio playback buffer", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_PlaybackAudioFormatNotSupported () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x021,L"The specified audio playback format is not supported by this device"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTInputBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x022,L"Could not allocate a %lu byte FFT input data buffer", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateDCOffsetPercentsL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x023,L"Could not allocate a %lu byte buffer to contain DC offset percents", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_DCOffsetsOutOfRangeLSDD (DWORD dw1, LPCTSTR s1, double d1, double d2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x024,L"Channel %lu %s DC offset of %5.2lf percent detected!  This is greater than the expected %5.2lf percent", dw1, s1, d1, d2); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateNoiseLimitsL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x025,L"Could not allocate a %lu byte buffer to contain noise limit values", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTMagnitudeL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x026,L"Could not allocate a %lu byte FFT magnitude data buffer", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_SignalToNoiseRatioTooSmallLSDD (DWORD dw1, LPCTSTR s1, double d1, double d2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x027,L"Signal-to-Noise ratio is too small on channel %lu %s.  Expected %6.2lf dB, Actual %6.2lf dB", dw1, s1, d1, d2); return (CheckAbort (HERE)); } return false;
	}
	bool err_SignalToNoiseNoCrossTooSmallLSDD (DWORD dw1, LPCTSTR s1, double d1, double d2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x028,L"Signal-to-Noise ratio ignoring crosstalk is too small on channel %lu %s.  Expected %6.2lf dB, Actual %6.2lf dB", dw1, s1, d1, d2); return (CheckAbort (HERE)); } return false;
	}
	bool err_ChannelSeperationTooSmallLSDD (DWORD dw1, LPCTSTR s1, double d1, double d2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x029,L"Channel separation value is too small on channel %lu %s.  Expected %6.2lf dB, Actual %6.2lf dB", dw1, s1, d1, d2); return (CheckAbort (HERE)); } return false;
	}
	bool err_FrequencyResponseBadLSDD (DWORD dw1, LPCTSTR s1, double d1, double d2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x02A,L"Frequency response is not within tolerance on channel %lu %s.  Expected %6.2lf dB, Actual %6.2lf dB", dw1, s1, d1, d2); return (CheckAbort (HERE)); } return false;
	}
	bool err_DidNotFindExpectedSineFreqLSDDDD (DWORD dw1, LPCTSTR s1, double d1, double d2, double d3, double d4) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x02B,L"Did not find the expected channel %lu %s sine wave frequency of %8.2lf Hz\n"
				L"Expected amplitude between %7.2lf and %7.2lf dB, Actual %7.2lf dB", dw1, s1, d1, d2, d3, d4); return (CheckAbort (HERE)); } return false;
	}
	bool err_DetectedUnexpectedSineFreqLSDDD (DWORD dw1, LPCTSTR s1, double d1, double d2, double d3) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x02C,L"Detected an unexpected channel %lu %s sine wave frequency of %8.2lf Hz\n"
				L"Expected amplitude below %7.2lf dB, Actual %7.2lf dB", dw1, s1, d1, d2, d3); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTPiBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x02D,L"Could not allocate a %lu byte buffer to hold PI function data for FFT", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTRTFBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x02E,L"Could not allocate a %lu byte buffer to hold Real Transform function data for FFT", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTITFBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x02F,L"Could not allocate a %lu byte buffer to hold Imaginary Transform function data for FFT", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTROFBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x030,L"Could not allocate a %lu byte buffer to hold Real Omega function data for FFT", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateFFTIOFBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x031,L"Could not allocate a %lu byte buffer to hold Imaginary Omega function data for FFT", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateSineWaveCreateL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x032,L"Could not allocate a %lu byte buffer for sine wave data creation", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_MutexTimeout (LPCTSTR s1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x033,L"Resource confict, timed out waiting for %s mutex", s1); return (CheckAbort (HERE)); } return false;
	}
	bool err_MutexHandle (LPCTSTR s1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x034,L"Could not get a handle for %s ", s1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CRCMiscompareLL (DWORD dw1, DWORD dw2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x035,L"CRC Value is incorrect\n"
				L"Expected value is 0x%8.8lx, Actual value is 0x%8.8lx", dw1, dw2); return (CheckAbort (HERE)); } return false;
	}
	bool err_DirectSoundEnumerateFailed () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x036,L"Can not determine which Direct Sound drivers are installed"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotCreateIDirectSound () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x037,L"Could not create an IDirectSound interface to play DirectSound audio"); return (CheckAbort (HERE)); } return false;
	}
	bool err_DirectSoundFindFailed () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x038,L"Could not find a DirectSound device"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotSetCooperativeLevel () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x039,L"Could not set the cooperative level to the DirectSound device"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotGetAccessToPrimaryBuffer () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x03A,L"Could not get access to the primary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotGetAccessToSecondaryBuffer () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x03B,L"Could not get access to the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotSetPrimaryBufferFormat () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x03C,L"Could not set the format of the primary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotReadPrimaryBufferFormat () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x03D,L"Could not read the format of the primary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotSetSecondaryBufferVolume () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x03E,L"Could not set the volume of the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotSetSecondaryBufferPanning () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x03F,L"Could not set the panning characteristics of the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotLockSecondaryBuffer () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x040,L"Could not lock the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_LockedSecondaryBufferSegmentWrongSize (DWORD dw1, DWORD dw2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x041,L"The locked secondary buffer is not the correct size\n"
				L"Requested buffer size is %lu bytes; actual buffer size is %lu bytes", dw1, dw2); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotUnlockSecondaryBuffer () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x042,L"Could not unlock the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotPlaySecondaryBuffer () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x043,L"Could not play the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotStopPlayingSecondaryBuffer () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x044,L"Could not stop playing the secondary DirectSound playback buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateLPDIRECTSOUNDBUFFERArray () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x045,L"Could not allocate an array of Direct Sound buffer pointers"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateLPDIRECTSOUNDBUFFER8Array () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x046,L"Could not allocate an array of Direct Sound 8 buffer pointers"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotGetAccessToPrimaryIDirectSoundBuffer8Interface () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x047,L"Could not get access to the primary buffer's IDirectSoundBuffer8 interface"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotGetAccessToSecondaryIDirectSoundBuffer8Interface () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x048,L"Could not get access to the secondary buffer's IDirectSoundBuffer8 interface"); return (CheckAbort (HERE)); } return false;
	}
	bool err_HostCommunicationError (int i1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x049, L"iSendHost communication routine returned an error code of 0x%x", i1); return (CheckAbort (HERE)); } return false;
	}
	bool err_RecordBufferIsEmpty () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x04A, L"The recorded audio buffer from the host is empty"); return (CheckAbort (HERE)); } return false;
	}
	bool err_RecordBufferIsNotCorrectLength (DWORD dw1, DWORD dw2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x04B, L"The length of the recorded audio buffer from the host is not correct.\nExpected %ld bytes, received %ld bytes", dw1, dw2); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateWaveOutBufferArray () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x04C,L"Could not allocate an array of audio data output buffer pointers"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotSetSecondaryBufferData () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x04D,L"Could not point the secondary buffer to the local data buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_AllocMixerStorage (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x04E,L"Could not allocate a buffer of size %lu bytes to store mixer parameters", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotFindDigitalSignature () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x04F,L"Could not find the signature at the start of the recorded digital buffer"); return (CheckAbort (HERE)); } return false;
	}
	bool err_CouldNotAllocateCRCBufferL (DWORD dw1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x050,L"Could not allocate a %lu byte array to contain data for the CRC calculation", dw1); return (CheckAbort (HERE)); } return false;
	}
	bool err_HostResponseError (DWORD dwErrorCodeFromHost, LPCTSTR s1) { if (gdwIgnoreError != TRUE)
	{
		ReportError ((unsigned short)dwErrorCodeFromHost, L"The host responded with the following error message:\n%s", s1); return (CheckAbort (HERE)); } return false;
	}


	// Global variables
public:
	// Parameters defined globally (initialized only once)
	DWORD gdwMaxTestTrys;
	DWORD gdwIgnoreError;
	DWORD gdwDelayBetweenPlaybackStartAndRecordStart;     // Contains the delay in ms that the test should pause after starting a new playback stream before starting recording
	DWORD gdwMutexTimeout;     // Contains the delay in ms that the test will wiat for a mutex to become available
	DWORD gdwAudioMuxComPort;        // The COM port that the audio mux is attached to.  0 indicates no audio mux is attached
	WAVE_PLAYBACK_CONFIGURATION_DATA *gpWavePlaybackConfigurationData;  // Pointer to playback configuration data structure
	WAVE_RECORD_CONFIGURATION_DATA *gpWaveRecordConfigurationData;  // Pointer to record configuration data structure
	FILE *gpF;
	DWORD *gpdwPI; // Pointer to a buffer that will contain the PI data for the FFT function
	AUDIO_MUX_CONFIGURATION_INFORMATION *gpAudioMuxConfigurationInformation;
	LPCTSTR gpwszAudioMixerName;
	DWORD gdwNumberOfMixerControls;
	CStore *pCSMixer;  // The list of mixer parameters could get very long

	static const wchar_t * pwchFFTWindowFunctionNames[];
	static const wchar_t * gpchMonoLabel[];
	static const wchar_t * gpchStereoLabel[];
	static const double gdblStereoTwelveFrequencyQuicktestFreqCh0[];
	static const double gdblStereoTwelveFrequencyQuicktestAmp[];
	static const double gdblStereoTwelveFrequencyQuicktestFreqCh1[]; 
	static const WAVE_PLAYBACK_CHANNEL_FREQ_DATA gwpcfdStereoTwelveFrequencyQuicktest[];
	static const WAVE_RECORD_CHANNEL_FREQ_DATA gwrcfdStereoTwelveFrequencyQuicktest[];
	static const WAVE_RECORD_NOISE_LIMIT gwrnlStereoTwelveFrequencyQuicktest[];
	static const WAVE_PLAYBACK_CONFIGURATION_DATA gwpcdStereoTwelveFrequencyQuicktest;
	static const WAVE_RECORD_CONFIGURATION_DATA gwrcdStereoTwelveFrequencyQuicktest;
	static const PLAYBACK_TEST_CONFIGURATIONS gPlaybackTestConfigurations[];
	static const RECORD_TEST_CONFIGURATIONS gRecordTestConfigurations[];

	// Parameters used within the retry loop (re-initialized with each loop)
	LPDIRECTSOUND8 pDSoundOut;
	LPDIRECTSOUNDBUFFER pPrimaryBuffer, *pSecondaryBufferPre8;
	LPDIRECTSOUNDBUFFER8 *pSecondaryBuffer;
	DWORD **ppdwWaveOutBuffer;
	DWORD *pdwWaveInBuffer;
//	WAVEHDR *pWaveOutHdr;
//	WAVEHDR *pWaveInHdr;
//	HWAVEOUT hWaveOut; 
//	HWAVEIN hWaveIn;
	WAVEFORMATEX *WaveFormatex;
	SLONG *pslFFTInputBuffer;
	double *pdblDCOffsetPercents;
	double *pdblNoiseLimitValues;
	DWORD *pdwMagnitudeValues;
	DWORD dwNumberOfFrequencies;
	WORD wTestNumber;

	HANDLE hXMTAAudioMutex;
//	HANDLE ghWaveRecordDone;
	HWND hDSWnd; // This is the handle to the current Window, used for DirectSound functions.  This will probably go away on XBox.
	DWORD dwLoopCounter;



	// Configuration parameters declared here ...
	//
//	int m_cfgInt;
//	UINT m_cfgUint;
//	LPCTSTR m_cfgString;
//	int m_cfgChoice;

virtual bool InitializeParameters ();

public:
	// Common functions go here.  Put any functions that need 
	// to be global to the tests in the module class
	//
	virtual ~CXModuleAudio () // Destructor
	{
		DWORD j;

		if (gpdwPI != NULL)
		{
			delete [] gpdwPI;
			gpdwPI = NULL;
		}
		// Let's clean up the WAVE_PLAYBACK_CONFIGURATION_DATA structure if it needs some attention (delete things in the opposite order than they were created)
		if(gpWavePlaybackConfigurationData != NULL)
		{
			if (gpWavePlaybackConfigurationData->WaveChannelFreqData != NULL)
			{
				for (j = 0; j < gpWavePlaybackConfigurationData->dwNumberOfChannels; j++)
				{
					if (gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency != NULL)
					{
						delete [] gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency;
						gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblFrequency = NULL;
					}
					if (gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod != NULL)
					{
						delete [] gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod;
						gpWavePlaybackConfigurationData->WaveChannelFreqData[j].pdblSamplesPerPeriod = NULL;
					}
				}
				delete [] gpWavePlaybackConfigurationData->WaveChannelFreqData;
				gpWavePlaybackConfigurationData->WaveChannelFreqData = NULL;
			}
			delete gpWavePlaybackConfigurationData;
			gpWavePlaybackConfigurationData = NULL;
		}
		// Let's clean up the WAVE_RECORD_CONFIGURATION_DATA structure if it needs some attention (delete things in the opposite order than they were created)
		if(gpWaveRecordConfigurationData != NULL)
		{
			if (gpWaveRecordConfigurationData->WaveRecordNoiseLimit != NULL)
			{
				delete [] gpWaveRecordConfigurationData->WaveRecordNoiseLimit;
				gpWaveRecordConfigurationData->WaveRecordNoiseLimit = NULL;
			}
			if (gpWaveRecordConfigurationData->WaveChannelFreqData != NULL)
			{
				for (j = 0; j < gpWaveRecordConfigurationData->dwNumberOfChannels; j++)
				{
					if (gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency != NULL)
					{
						delete [] gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency;
						gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblFrequency = NULL;
					}
					if (gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude != NULL)
					{
						delete [] gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude;
						gpWaveRecordConfigurationData->WaveChannelFreqData[j].pdblAmplitude = NULL;
					}
				}
				delete [] gpWaveRecordConfigurationData->WaveChannelFreqData;
				gpWaveRecordConfigurationData->WaveChannelFreqData = NULL;
			}
			delete gpWaveRecordConfigurationData;
			gpWaveRecordConfigurationData = NULL;
		}
		if (gpAudioMuxConfigurationInformation != NULL)
		{
			delete gpAudioMuxConfigurationInformation;
			gpAudioMuxConfigurationInformation = NULL;
		}

		if (pCSMixer != NULL)
		{
			delete pCSMixer;
			pCSMixer = NULL;
		}
	};

	DWORD dwAnalogPlayback(void);
	DWORD dwDigitalAccuracy(void);
	void vInitializeTestVariables(void);
	void vFixUpPlaybackFrequencies(void);
	void vCalculateSamplesPerPeriod(void);
	DWORD dwGenSineWave(DWORD *pdwDataBuffer, DWORD dwBitsPerSample, DWORD dwNumberOfSamples, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *pWaveChannelFreqData, DWORD dwNumberOfChannels, DWORD dwAttenuationDB);
	DWORD dwGenSingleSineWave(DWORD *pdwDataBuffer, DWORD dwBitsPerSample, DWORD dwNumberOfSamples, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *pWaveChannelFreqData, DWORD dwNumberOfChannels, DWORD dwAttenuationDB, DWORD dwFrequencyNumber);
	DWORD dwGetPossessionOfAudioResources(DWORD dwTimeout);
	void vReleasePossessionOfAudioResources (void);
	void vStraightenUpTestVariables(void);
//	static void CALLBACK vWaveInCallback(HWAVEIN hwi, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
	DWORD dwTotalDCOffset(DWORD *pdwSourceBuffer, SLONG *pslDestBuffer, DWORD dwBitsPerSample, DWORD dwFFTSize, DWORD dwNumberOfChannels, double *pdblDCOffsetPercents);
	void vCalculateRecordNoiseLimit(double *pdblNoiseLimitValues, DWORD dwFFTSize, DWORD dwBitsPerSample, DWORD dwSampleRate, WAVE_RECORD_NOISE_LIMIT* pwrnlWaveRecordNoiseLimit, DWORD dwNumberOfNoiseRanges);
	DWORD dwComputeFFT(SLONG *pslInputData, DWORD *pdwMagnitude, DWORD dwFFTBits, DWORD dwFFTSize, double dblTwoPI, double dblPIOverTwo, DWORD dwWindowType);
	DWORD dwCompareFrequenciesAndNoise(DWORD *pdwMagnitude, DWORD dwFFTSize, WAVE_RECORD_CONFIGURATION_DATA wrcdWaveRecordInfo, DWORD dwChannel, double *pdblNoiseLimitValues);
	DWORD dwComputeSignalToNoise(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, double *pdblFrequencies, DWORD dwNumberOfFrequencies, DWORD dwSampleRate, double *pdblNoiseLimitValues, double dblFrequencyShiftHzAllowed, double *pdblSignalToNoiseRatioToReturn);
	DWORD dwComputeSignalToNoiseIgnoringCrosstalk(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, WAVE_RECORD_CHANNEL_FREQ_DATA *WaveRecordChannelFreqData, DWORD dwRecordNumberOfChannels, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *WavePlaybackChannelFreqData, DWORD dwPlaybackNumberOfChannels, DWORD dwChannelNumber, DWORD dwSampleRate, double *pdblNoiseLimitValues, double dblFrequencyShiftHzAllowed, double *pdblSignalToNoiseRatioToReturn);
	DWORD dwComputeChannelSeparation(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, WAVE_RECORD_CHANNEL_FREQ_DATA *WaveRecordChannelFreqData, DWORD dwRecordNumberOfChannels, WAVE_PLAYBACK_CHANNEL_FREQ_DATA *WavePlaybackChannelFreqData, DWORD dwPlaybackNumberOfChannels, DWORD dwChannelNumber, DWORD dwSampleRate, double dblFrequencyShiftHzAllowed, double *pdblChannelSeparationToReturn, double *pdblNoiseLimitValues);
	DWORD dwComputeFrequencyResponse(DWORD *pdwMagnitude, DWORD dwFFTSize, double dblFrequencyShiftPercentAllowed, double *pdblFrequencies, DWORD dwNumberOfFrequencies, double dblBaseMagnitude, DWORD dwBitsPerSample, DWORD dwSampleRate, double dblFrequencyShiftHzAllowed, double *pdblFrequencyResponseToReturn, double *pdblNoiseLimitValues);
	DWORD dwComputeCRC(unsigned char *pucBuffer, DWORD dwNumBytes, DWORD dwCRC);
	static BOOL CALLBACK bDSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription, LPCSTR lpcstrModule, LPVOID lpContext);
};

#endif // _WINAUDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmta.h ===
// xmta.h

#pragma once

class CHost;
class CError;
class CParameterTable;
class CDispatcher;
class CLoopManager;

class CAutoLeave
{
	CRITICAL_SECTION* m_pSection;
public:
	CAutoLeave (CRITICAL_SECTION* section) {
		m_pSection = section;
		EnterCriticalSection (m_pSection);
		}
	~CAutoLeave () {
		LeaveCriticalSection (m_pSection);
		}
};

class CAutoString
{
	LPTSTR m_str;

public:
	CAutoString (LPCTSTR format, ...);
	~CAutoString () {delete[] m_str;}
	operator LPCTSTR () {return m_str;}
};

/*
class CAutoSplit 
{
	_TCHAR m_first [128];
	LPCTSTR m_second;

public:
	CAutoSplit (LPCTSTR name, LPCTSTR separators = _T("."));
	~CAutoSplit () {}

	LPCTSTR GetFirst () {return m_first;}
	LPCTSTR GetSecond () {return m_second;}
};
CAutoSplit::CAutoSplit (LPCTSTR name, LPCTSTR separators)
{
	size_t dot = _tcscspn (name, separators);
	ASSERT (dot != -1);
	ASSERT (dot < _tcslen (name));

	m_second = &name [dot + 1];
	_tcsncpy (m_first, name, dot);
	m_first [dot] = 0;
	while (m_first [--dot] == _T(' '))
		m_first [dot] = 0;
}
*/

template<class T>
class CAutoDelete 
{
	T *p;
public:
	CAutoDelete (T *ptr = 0):p(ptr) {}
	~CAutoDelete () {delete p;}
	bool operator!() const {return (p != NULL);}
	T* get() const {return p;}
	void set (T* ptr) {p = ptr;}
};

class CAutoClose 
{
	HANDLE h;
public:
	CAutoClose (HANDLE handle = 0):h(handle) {}
	~CAutoClose () {CloseHandle (h);}
	bool IsValid () {return ((h != INVALID_HANDLE_VALUE) && (h != NULL));}
	bool operator!() const {return (h != NULL);}
	operator HANDLE () {return h;}
};

template <class T, int MAX>
class CArray
{
	T m_array [MAX];
	int m_count;

protected:
	T* GetArray () {return m_array;}

public:
	class BadIndexException {};

	CArray (int count, ...):m_count(count) 
	{
		va_list marker;
		va_start (marker, count);
		while (count-- && Append (va_arg (marker, T))) {}   
		va_end (marker );
	}

	CArray ():m_count(0) {}
	~CArray () {}

	bool Find (T t, int *i)
	{
		for (*i = 0; *i < m_count; (*i)++)
			if (array [*i] == t)
				return true;
		return false;
	}

	bool Append (T t)
	{
		if (m_count >= MAX) return false;
		m_array [m_count] = t;
		m_count++;
		return true;
	}

	bool Insert (T t, int i)
	{
		if (m_count >= MAX) return false;
		if ((i < 0) || (i > m_count)) throw BadIndexException();
		memcpy (&m_array[i+1], &m_array[i], (m_count-i)*sizeof(T));
		m_array [i] = t;
		m_count++;
		return true;
	}

	T RemoveAt (int i)
	{	
		T saved = m_array[i];
		m_count--;
		if (i < m_count) // closeup the hole
			memcpy (&m_array[i], &m_array[i+1], (m_count-i)*sizeof(T));
		return saved;
	}

	T& operator [] (int i) 
	{
		if ((i < 0) || (i >= m_count)) throw BadIndexException();
		return m_array[i];
	};

	int GetCount () {return m_count;}
	bool IsFull () {return (m_count >= MAX);}
	bool IsEmpty () {return (m_count <= 0);}
};

extern __int64 gi64CPUSpeed;
extern TCHAR g_tcXMTAVersionNumber[];
extern CError g_error;
extern CHost g_host;
extern CParameterTable g_parameters;
extern CLoopManager g_main;
extern CDispatcher g_dispatch;
extern DWORD g_tlsTestObj;
extern char *g_strHostName;
extern LPTSTR g_strSerialNumber;
void GetCPUSpeed();

#if defined( _XBOX ) 
extern LPDIRECT3D8			 g_pD3D;
extern LPDIRECT3DDEVICE8	 g_pd3dDevice;
extern D3DPRESENT_PARAMETERS g_d3dpp;
#endif
// Some constants for the app
//
const int MAX_NAME_LENGTH = 64;
const int MAX_THREAD_COUNT = 64; 
const int MAX_TIMEOUT = 30;
const int MAX_WAIT_HANDLES = 64; // Max size of WaitForMultipleObjects = 64
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xcpu\FFT.CPP ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.

//#include "stdafx.h"
#include "Prime95.h"
//#include "math.h"
#define TRUE 1
#define FALSE 0

#define INTERLEAVE		1

long addr (unsigned long p, unsigned long fftlen, unsigned long i)
{
	unsigned long addr, pass1, pass2, col, section, section_size;

	p=0;						// meaningless, just did to stop compiler from
								// complaining about unreferenced parameter.

	pass1 = i >> 9;				// Top bits
	col = (i >> 7) & 3;			// Middle 2 bits
 	pass2 = i & 127;			// Bottom 7 bits

// Compute the lower part of the address, inserting waste bytes.
// Waste is 1 cache line every 128 cache lines (32 bytes per 4K page).
// Addr is: pass1 || pass2 % 8 || optional-interleave-bit || col || 000

	addr = pass1;
	addr = (addr << 3) + (pass2 & 7);
	addr = (addr >> 7) * (128 + 1) + (addr & 127);  // Add waste
	addr *= INTERLEAVE;
	addr = ((addr << 2) + col) << 3;

// Compute the upper part of the address adding more waste bytes
// to avoid 64KB spacing.  Note there is no guarantee that the OS
// will place our 4K pages linearly in memory, but there are times
// that the OS does, so we'll optimize for that case.

	section = pass2 >> 3;
	section_size = (fftlen >> 4) * sizeof (double);
	section_size += 4096 + 8*32;	// BUG - Not ideal for all fftlen?
	section_size *= INTERLEAVE;
	addr += section * section_size;

// Return the full address

	return (inputaddrqq + addr);
}

// Routine to handle a multiplication and modulo operation where
// the intermediate multiplication result can be more than 32 bits.

unsigned long mulmod (
	unsigned long a,
	unsigned long b,
	unsigned long c)
{
	unsigned long tmp;
	tmp = a * (b & 0x3FF);
	tmp += ((a << 10) % c) * (b >> 10);
	return (tmp % c);
}

// Some words in the FFT data contain floor(p/N), some words contain
// floor(p/N)+1 bits.  This function returns TRUE in the latter case.

int is_big_word (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i)
{
	unsigned long b, s;

// The first FFT word is always big.

	if (i == 0) return (TRUE);

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// The rest are uniformly distributed. Use floating point
// arithmetic to avoid losing data in the b * i operation.

	return (mulmod (b, i, fftlen) > s);
}

// Each FFT word is multiplied by a two-to-phi value.  These
// routines set and get the FFT value without the two-to-phi
// multiplier.

#pragma warning(disable:4725) // Disables Pentium FDIV warning.
void get_fft_value (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i,
	long	*retval)
{
	double	*dblp, tmp, pow;
	unsigned long b, s;

// Get address of fft value

	dblp = (double *) addr (p, fftlen, i);

// The first FFT word is not multiplied by anything.

	if (i == 0) {
		*retval = (long)*dblp;
		return;
	}

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// Divide by two-to-phi to generate an integer.
// Do not trust the pow routine.  The assembly code will
// generate the value with greater accuracy.

	tmp = *dblp;
	pow = (double) mulmod (s, i, fftlen) / (double) fftlen;
	__asm fld tmp
	__asm fld pow
	__asm f2xm1
	__asm fld1
	__asm faddp st(1), st
	__asm fdivp st(1), st
	__asm frndint
	__asm fstp tmp
	*retval = (long) tmp;
}
#pragma warning(default:4725)

void set_fft_value (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i,
	long	val)
{
	double	*dblp, tmp, pow;
	unsigned long b, s;

// Get address of fft value

	dblp = (double *) addr (p, fftlen, i);

// The first FFT word is not multiplied by anything.

	if (i == 0) {
		*dblp = val;
		return;
	}

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// Multiply value by two-to-phi before setting fft value.
// Do not trust the pow routine.  The assembly code will
// generate the value with greater accuracy.

	pow = (double) mulmod (s, i, fftlen) / (double) fftlen;
	__asm fld pow
	__asm f2xm1
	__asm fld1
	__asm faddp st(1), st
	__asm fimul val
	__asm fstp tmp
	*dblp = tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xcpu\PRIME95.H ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// Prime95.h : main header file for the PRIME95 application
//

//#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// My non-MFC stuff went here
/////////////////////////////////////////////////////////////////////////////

// Constants

#define MIN_PRIME	5L		// Smallest testable prime
#define MAX_PRIME	LIMIT256	// Largest testable prime
#define MAX_FACTOR	LIMIT256	// Largest factorable number

// Limits based on 1000 iterations with an error no greater than 0.30.

#define LIMIT256	5260000L	// Crossover points
#define LIMIT224	4605000L
#define LIMIT192	3960000L
#define LIMIT160	3310000L
#define LIMIT128	2655000L
#define LIMIT112	2330000L
#define LIMIT96		2000000L
#define LIMIT80		1675000L
#define LIMIT64		1345000L

#define FAC61	LIMIT224		// How far to factor
#define FAC60	3540000L
#define FAC59	2750000L
#define FAC58	LIMIT112
#define FAC57	1750000L
#define FAC56	LIMIT64
#define FAC55	1050000L
#define FAC54	750000L

#define THE_END_64	0x000C0780	// Max addr for 64K FFT len
#define THE_END_80	0x200FBF00	// Max addr for 80K FFT len
#define THE_END_96	0x20127700	// Max addr for 96K FFT len
#define THE_END_112	0x201531C0	// Max addr for 112K FFT len
#define THE_END_128	0x2017E9C0	// Max addr for 128K FFT len
#define THE_END_160	0x201D61A0	// Max addr for 160K FFT len
#define THE_END_192	0x2022D520	// Max addr for 192K FFT len
#define THE_END_224	0x202848E0	// Max addr for 224K FFT len
#define THE_END_256	0x202DBBC0	// Max addr for 256K FFT len
extern long THE_END;			// End of the used address space
extern "C" unsigned long inputaddrqq;

#define REL_486_SPEED	7.0	// 486 is 7 times slower than Pentium
#define REL_PRO_SPEED	0.87	// Pro is little faster than Pentium

#ifndef SEC1
#define SEC1(p)		0
#define SEC2(p,hi,lo)	0
#define SEC3(p)		0
#define SEC4(p)		0
#endif

// Global variables

extern char *INI_SECTION;		// Section name in INI file
extern int THREAD_ACTIVE;		// True if a thread is active
extern int volatile THREAD_STOP;	// TRUE if thread should stop
extern int AUTO_CONTINUE;		// 1 if auto continue is on
extern int ADVANCED_ENABLED;		// 1 if advanced menu is enabled
extern int TRAY_ICON;			// Display tiny tray icon
extern int HIDE_ICON;			// Display no icon
//extern "C" int volatile ERRCHK;		// 1 to turn on error checking
extern int JUST_FIND_FACTORS;		// Factor the range
extern int DOUBLE_CHECK;		// Double-check the range
extern "C" unsigned int volatile CPU_TYPE;// 3=Cyrix, 4=486, 5=Pentium, 6=Pro
extern unsigned long volatile CPU_SPEED;// For 90MHz = 90
extern unsigned long RANGE_START;	// Start of range to test
extern unsigned long RANGE_END;		// End of range to test
extern unsigned long NEXT_RANGE_START;	// Start of range to test next
extern unsigned long NEXT_RANGE_END;	// End of range to test next
extern unsigned int volatile ITER_OUTPUT;// Iterations between outputs
extern int TXT_EXTENSION;		// True if output file is results.txt

extern int PRIORITY;			// Desired priority level
extern int TIMED_RUN;			// TRUE if this is a timed run
extern int SILENT_VICTORY;		// Quiet find of new Mersenne prime

extern int (__stdcall *HPROC_GET_NEXT_EXPONENT)(unsigned long *, int *);
extern int (__stdcall *HPROC_WRITE_RESULTS)(char *);

const int NumLines = 32;
extern char *lines[NumLines];
extern int charHeight;

// Internal routines

void findSmallestP (unsigned long *);
int readFileHeader (char *, int *, short *, unsigned long *);
int readFileData (int, unsigned long, unsigned long);
int writeToFile (unsigned long, char *, unsigned long, unsigned long);
void clearPrime (unsigned long, int);
void makestr64 (char *);
void writeResults (char *);
void primeClear (unsigned long, unsigned long);
void generateRandomData (unsigned long, unsigned long);
void checkResultsFile (unsigned long, int *, int *);

extern "C" void setupf ();
extern "C" int factor64 ();
extern "C" void setup64 ();
extern "C" int lucas64 ();
extern "C" void setup80 ();
extern "C" int lucas80 ();
extern "C" void setup96 ();
extern "C" int lucas96 ();
extern "C" void setup112 ();
extern "C" int lucas112 ();
extern "C" void setup128 ();
extern "C" int lucas128 ();
extern "C" void setup160 ();
extern "C" int lucas160 ();
extern "C" void setup192 ();
extern "C" int lucas192 ();
extern "C" void setup224 ();
extern "C" int lucas224 ();
extern "C" void setup256 ();
extern "C" int lucas256 ();

long  addr (unsigned long, unsigned long, unsigned long);
int is_big_word (unsigned long, unsigned long, unsigned long);
void get_fft_value (unsigned long, unsigned long, unsigned long, long *);
void set_fft_value (unsigned long, unsigned long, unsigned long, long);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xcpu\xcpu.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// Title: xCPU
//
// History:
//
// 09/25/00 V1.00 BLI Release V1.00.
// 10/03/00 V1.01 BLI Modified FPU Stress test so that the data buffer
//          is now relocateable.  Also changed module to use new XMTA Macro module
//          and test declarations.
// 10/05/00 X1.02 BLI Changed module and test declarations to work with XMTA 1.03
// 10/05/00 X1.03 BLI Changed module and test declarations to work with XMTA 1.04 and
//          added CheckAbort() calls appropriately

#include "..\stdafx.h"
#include "..\testobj.h"
#include "xcpu.h"
#include "prime95.h"

IMPLEMENT_MODULEUNLOCKED (CXModuleCPU);

bool CXModuleCPU::InitializeParameters ()
{
	if (!CTestObj::InitializeParameters ())
		return false;
//	m_cfgString = GetCfgString (_T("string"), NULL);
	if ((iFamily = GetCfgInt (L"family", -1)) == -1)
	{
		err_BADPARAMETER(L"FAMILY");
		if (CheckAbort (HERE)) return true;
	}
	if ((iModel = GetCfgInt (L"model", -1)) == -1)
	{
		err_BADPARAMETER(L"MODEL");
		if (CheckAbort (HERE)) return true;
	}
	if ((iCPUType = GetCfgInt (L"cpu_type", -1)) == -1)
	{
		err_BADPARAMETER(L"CPU_TYPE");
		if (CheckAbort (HERE)) return true;
	}
	dwCacheDescriptor = GetCfgUint (L"cache_descriptor", 0xFFFFFFFF);
	if ((iCPUInternalSpeed = GetCfgInt (L"cpu_internal_speed", -1)) == -1)
	{
		err_BADPARAMETER(L"CPU_INTERNAL_SPEED");
		if (CheckAbort (HERE)) return true;
	}
	iCPUTolerance = GetCfgInt (L"cpu_speed_tolerance", 5);
	iFPUStressLoops = GetCfgInt (L"fpu_stress_loops", 20);
//	m_cfgUint = GetCfgUint (_T("unsigned"), 0);
//	m_cfgChoice = GetCfgChoice (_T("choice"), 0, _T("none"), _T("one"), _T("many"));
	return true;
}

extern "C" unsigned long PARG=0;
extern "C" double MAXERR=0;
extern "C" double SUMINP=0;
extern "C" double SUMOUT=0;
extern "C" DWORD ERRCHK=0;
extern "C" unsigned long inputaddrqq=0;
extern "C" unsigned long FPSHALF=0x3F000000;
extern "C" unsigned long FPSMINUS2=0xC0000000;
extern "C" unsigned long FPSBIGVAL=0;
extern "C" unsigned long FPSscaled_numbig=0;
extern "C" unsigned long FPSscaled_numlit=0;
extern "C" unsigned long FPSp=0;
extern "C" unsigned long FPSnumlit=0;
extern "C" unsigned long FPSnumbig=0;

//******************************************************************
// Title: CXCPUTestFeatureCheck
//
// Abstract: Checks the features on the CPU vs any parameters
//
// Uses config parameters:
//           family
//           model
//           cpu_type
//           cache_descriptor
//           steppings_allowed[XX]
//           steppings_not_allowed[XX]
//******************************************************************
IMPLEMENT_TESTUNLOCKED (CPU, feature_check, 1)
{
//	#ifdef _DEBUG
		static int FeatureChk;
		FeatureChk++;
		ReportDebug(BIT0, _T("FeatureCheck Test - Loop %d"), FeatureChk);
//	#endif

	int x, locStepAllw, locStepNotAllw;
	int SteppingsAllowed;
	int SteppingsNotAllowed;
	BOOL SteppingOK;
	DWORD dwEAX, dwEBX, dwECX, dwEDX;
	wchar_t SteppingsParamName[64];
	CPUType ActualCPUType;
	Features ActualCPUFeatures;

//ReportWarning (L"This is my warning message");
//ReportDebug (BIT1, L"This is my bit 1 debug message");
//ReportDebug (BIT4, L"This is my bit 4 debug message");
//ReportStatistic (L"my_stat_key", L"This is my stat message");

	locStepAllw = FALSE;
	locStepNotAllw = FALSE;
	_asm // Get CPUID
	{
		push eax
		push ebx
		push ecx
		push edx
		mov	eax, 1
		cpuid
		mov	ActualCPUType.reg, eax
		mov	ActualCPUFeatures.reg, edx
		pop edx
		pop ecx
		pop ebx
		pop eax
	}

	// Check the falmily, model, and cpu type
	if(iFamily != (int)ActualCPUType.Family)
	{
		err_WRONGFAMILY_D((int)ActualCPUType.Family);
		if (CheckAbort (HERE)) return;
	}
	if(iModel != (int)ActualCPUType.Model)
	{
		err_WRONGMODEL_D((int)ActualCPUType.Model);
		if (CheckAbort (HERE)) return;
	}
	if(iCPUType != (int)ActualCPUType.ProcType)
	{
		if (CheckAbort (HERE)) return;
		err_WRONG_CPU_TYPE_DD((int)ActualCPUType.ProcType, iCPUType);
	}

	// check for steppings not allowed
	// Normally configuration parameter capturing happens in the InitializeParameters()
	// routine, but these are done here to simplify the code.
	for(x=0;x<99;x++)
	{
		swprintf(SteppingsParamName,L"steppings_not_allowed[%d]",x);
		if ((SteppingsNotAllowed = GetCfgInt (SteppingsParamName, -1)) == -1)
			break;
		locStepNotAllw=TRUE;
		// Now see if this matches the actual stepping
		if( SteppingsNotAllowed == (int)ActualCPUType.Stepping)
		{
			err_STEPPINGNOTALLOWED_X((int)ActualCPUType.Stepping);
			if (CheckAbort (HERE)) return;
		}
	}

	// check the steppings allowed
	SteppingOK = TRUE;
	for(x=0;x<99;x++)
	{
		swprintf(SteppingsParamName,L"steppings_allowed[%d]",x);
		if ((SteppingsAllowed = GetCfgInt (SteppingsParamName, -1)) == -1)
			break;
		locStepAllw=TRUE;
		// Now see if this matches the actual stepping
		SteppingOK = FALSE;
		if( SteppingsAllowed == (int)ActualCPUType.Stepping)
		{
			SteppingOK = TRUE;
			break;
		}
	}
	// can't have both a "Steppings Allowed" AND a "Steppings Not Allowed" list
	if (locStepAllw && locStepNotAllw)
	{
		err_2STEPPINGLISTS();
		if (CheckAbort (HERE)) return;
	}

	if (SteppingOK == FALSE)
	{
		err_STEPPINGNOTALLOWED_X(ActualCPUType.Stepping);
		if (CheckAbort (HERE)) return;
	}

		
	// check for MMX
	if(ActualCPUFeatures.MMX != 1)
	{
		err_MMXNOTPRESENT();
		if (CheckAbort (HERE)) return;
	}

	// check for SIMD/mmx2
	if(ActualCPUFeatures.XMM != 1)
	{
		err_SIMDNOTPRESENT();
		if (CheckAbort (HERE)) return;
	}

	// check for FPU
	if(ActualCPUFeatures.FPU != 1)
	{
		err_FPUNOTPRESENT();
		if (CheckAbort (HERE)) return;
	}

	// retrieve the cache description.  This is a shortcut instead of walking the
	// list of descriptors.
	_asm // Get the CPUID descriptor information
	{
		push eax
		push ebx
		push ecx
		push edx
		mov	eax, 2
		cpuid
		mov dwEAX, eax
		mov dwEBX, ebx
		mov dwECX, ecx
		mov dwEDX, edx
		pop edx
		pop ecx
		pop ebx
		pop eax
	}

	// check for correct cache Features
	if (dwCacheDescriptor != 0xFFFFFFFF) // Only check this if the config parameter was present
	{
		if(dwEDX != dwCacheDescriptor)
		{
			err_NOMATCH_CACHE_DD(dwEDX, dwCacheDescriptor);
			if (CheckAbort (HERE)) return;
		}
	}
}


//******************************************************************
// Title: CXCPUTestMultimediaExtensions
//
// Abstract: Executes MMX instructions to confirm proper operation
//
// Uses config parameters:
//
//******************************************************************
IMPLEMENT_TESTUNLOCKED (CPU, multimedia_extensions, 2)
{
//	#ifdef _DEBUG
		static int MMEx;
		MMEx++;
		ReportDebug(BIT0, _T("MultimediaExtensions Test - Loop %d"), MMEx);
//	#endif

	DWORD dwTempDword;
	DWORD dwResult;
	Features ActualCPUFeatures;

	// check for an MMX unit
	_asm // Get CPUID
	{
		push eax
		push ebx
		push ecx
		push edx
		mov	eax, 1
		cpuid
		mov	ActualCPUFeatures.reg, edx
		pop edx
		pop ecx
		pop ebx
		pop eax
	}
	if(ActualCPUFeatures.MMX == 0)
	{
		err_MMXNOTPRESENT();
		if (CheckAbort (HERE)) return;
	}
	else // MMX feature is present
	{
		_asm
		{
			push eax
			push ebx

			mov	eax,12345678h
			movd	mm0,eax
			movd	ebx,mm0
			movd	mm1,ebx
			movd	dwTempDword,mm1
			movd	mm2,dwTempDword
			movq	mm3,mm2
			movd	dwTempDword,mm3
			movq	mm4,dwTempDword
			movq	mm5,mm4
			movq	mm6,mm5
			movq	mm7,mm6
			movd	dwResult,mm7
			emms		     ; empty MMX state

			pop ebx
			pop eax
		}
		if(dwResult != 0x12345678)
		{
			err_MMX_MOVE();
			if (CheckAbort (HERE)) return;
		}
	}
}

//******************************************************************
// Title: CXCPUTestFPUStress
//
// Abstract: Executes a stressful loop of floating point instructions
//           Computes Mersenne Prime Numbers
//           Uses Dr. Richard Crandall's algorithm
//
// Uses config parameters:
//
//******************************************************************
IMPLEMENT_TESTUNLOCKED (CPU, fpu_stress, 3)
{

//	#ifdef _DEBUG
		static int FpuStress;
		FpuStress++;
		ReportDebug(BIT0, _T("FPUStress Test - Loop %d"), FpuStress);
//	#endif

	//	static LPVOID memreserved;
	static char *memreserved;
	unsigned long fftlen;
	wchar_t buf[100];
	unsigned long k, l;
	unsigned int i;
	unsigned long p;
	unsigned int ll_iters;
	char failed;

	memreserved = NULL;
	failed=FALSE;
	fftlen=65536;
	ll_iters = iFPUStressLoops;
	PARG = 0;
	MAXERR = 0.0;
	SUMINP = 0.0;
	SUMOUT = 0.0;
	ERRCHK = 0;

	// Load the appropriate EXE file and setup
	THE_END = THE_END_64;
	lucas = lucas64;
	
	// Now we know how much memory to reserve

	//freeing memory
	if (memreserved != NULL) 
	{
		delete [] memreserved;
		memreserved = NULL;
	}
//	err_FREEINGMEMORY();

	// Allocate memory for the assembly code
	if ((memreserved = new char[THE_END]) == NULL)
	{
		err_ALLOCMEMORY(); // Don't need to CheckAbort here because we return anyway
		return;
	}
	inputaddrqq = (unsigned long)memreserved;



	// Determine the range from which we'll choose an exponent to test.
	i=128; 
	p=1344999;


	// Now run Lucas setup
	PARG = p;
	setup64 ();

	// Do Lucas-Lehmer iterations
	for (k = 0; k <ll_iters; k++) 
	{
		if (CheckAbort (HERE)) break;  // Do this CheckAbort because this loop could be long
/*
		if (CheckAbort (HERE))
		{
			printf("Loop = %ld\n", k);
			break;  // Do this CheckAbort because this loop could be long
		}
*/
		// Don't need to CheckAbort anywhere else in this loop because all errors cause the
		// loop to break and then quickly exit the test.
		// Init data area with a pre-determined value
		//clear the memory
		for (l=0; l<fftlen; l++) 
			set_fft_value(p, fftlen,l,0);
		set_fft_value (p, fftlen, 0, 4);

		// One Lucas-Lehmer test with error checking			
		
		ERRCHK++;
		(*lucas)();
		ERRCHK--;
		
		// If the sum of the output values is an error (such as infinity)
		// then raise an error.  For some reason these bad values are treated
		// as zero by the C compiler.  There is probably a better way to
		// check for this error condition.

		if (SUMOUT <= 0.0) 
		{
			failed=TRUE;
			break;
		}

		// Check that the sum of the input numbers squared is approximately
		// equal to the sum of unfft results.  Note that as the sum of the
		// inputs approaches zero the more error we must tolerate. 

//printf("insum = %lf, outsum = %lf\n", SUMINP, SUMOUT);
		if (SUMOUT < SUMINP-0.1 || SUMOUT > SUMINP+0.1) 
		{
//			sprintf (buf, ERRMSG1B, SUMINP, SUMOUT);
			wsprintf(buf,L"i=%u, k=%lu, ",i,k);
			err_SQ_NUM_S(buf);
			failed=TRUE;
			break;
		}


		// Make sure round off error is tolerable
		if (MAXERR > 0.40) 
		{
//			sprintf (buf, ERRMSG1C, MAXERR);
			wsprintf(buf,L"k=%lu, ",k);
			failed=TRUE;
			err_ROUNDING_S(buf);
			break;
		}

	} // end for

	// Check for failure 
	if (failed==TRUE) 
	{
		wsprintf(buf,L"FFT length=%lu --> ",fftlen);
		err_FFT_FAILURE_S(buf);
		// FAILED!
	}
	if (memreserved != NULL) 
	{
		delete [] memreserved;
		memreserved = NULL;
	}
}

//******************************************************************
// Title: CXCPUTestSIMDNewInstructions
//
// Abstract: Executes SIMD instructions to confirm proper operation
//
// Uses config parameters:
//
//******************************************************************
IMPLEMENT_TESTUNLOCKED (CPU, simd_new_instructions, 4)
{
//	#ifdef _DEBUG
		static int SimdInstr;
		SimdInstr++;
		ReportDebug(BIT0, _T("SimdNewInstructions Test - Loop %d"), SimdInstr);
//	#endif


	Features ActualCPUFeatures;
	// set up 128 bit INT data and INT results
	struct_128 data_int, iresult, data_float1, data_float2, exp_fresult, fresult, check2, check3;
	void *datai, *dataf1, *dataf2;
	struct_128 *iresultp, *fresultp;

	data_int.a = 1;  // Initialize the DWORD structure
	data_int.b = 2;
	data_int.c = 3;
	data_int.d = 4;
	data_float1.aa = (float)1.2;
	data_float1.bb = (float)5.6;
	data_float1.cc = (float)9.7;
	data_float1.dd = (float)0.4;
	data_float2.aa = (float)5.3;
	data_float2.bb = (float)2.1;
	data_float2.cc = (float)10.2;
	data_float2.dd = (float)7.0;
	exp_fresult.aa = (float)2.5495097637176514;
	exp_fresult.bb = (float)2.100000;
	exp_fresult.cc = (float)4.460942;
	exp_fresult.dd = (float)2.7202942371368408;
	check2.aa = (float)-4.10000038146972660000;
	check2.bb = (float)-2.1;
	check2.cc = (float)-.5;
	check2.dd = (float)-6.6;
	check3.aa = (float)20;
	check3.bb = (float)42;
	check3.cc = (float)42;
	check3.dd = (float)40;

	// check for an SIMD support in CPU
	_asm // Get CPUID
	{
		push eax
		push ebx
		push ecx
		push edx
		mov	eax, 1
		cpuid
		mov	ActualCPUFeatures.reg, edx
		pop edx
		pop ecx
		pop ebx
		pop eax
	}
	if(ActualCPUFeatures.XMM == 0)
	{
		err_SIMDNOTPRESENT();
		if (CheckAbort (HERE)) return;
	}
	else // SIMD is supported
	{
		datai = &data_int;
		iresultp = &iresult;
		_asm
		{
			push eax
			push edi
			mov	eax,datai
			movups	xmm0,[eax]
			movaps	xmm1, xmm0
			movaps	xmm2, xmm1
			movaps	xmm3, xmm2
			movaps	xmm4, xmm3
			movaps	xmm5, xmm4
			movaps	xmm6, xmm5
			movaps	xmm7, xmm6
			shufps	xmm7, xmm7, 1bh	;shuffle a3,a2,a1,a0 to a0,a1,a2,a3
			shufps	xmm7, xmm7, 1bh	;shuffle a3,a2,a1,a0 to a0,a1,a2,a3
			mov	edi,iresultp
			movups	[edi],xmm7
			pop edi
			pop eax
			emms
		}
		if(memcmp(&data_int,&iresult,16) != 0)
		{
			err_SIMD_MOVE(data_int.d,data_int.c,data_int.b,data_int.a,iresult.d,iresult.c,iresult.b,iresult.a);
			if (CheckAbort (HERE)) return;
		}
	
		dataf1 = &data_float1;
		dataf2 = &data_float2;
		fresultp = &fresult;
		_asm
		{
			push eax
			push edi
			mov	eax, dataf1		;load 2 registers with 128 bit floats
			movups	xmm0, [eax]
			mov	eax, dataf2
			movups	xmm1, [eax]		
			addps	xmm0, xmm1		;add xmm0 + xmm1 store in xmm0
			sqrtps	xmm2, xmm0		;sqrt xmm0 store in xmm2
			minps	xmm1, xmm2		;take the min of xmm1 and xmm2, store in xmm1
			mov	edi,  fresultp		;point to result structure
			movups	[edi],xmm1		;xfr result to structure
			pop edi
			pop eax
			emms
		}
		if(memcmp(&exp_fresult,&fresult,16) != 0)
		{
			err_SIMD_FP_SP(exp_fresult.aa,exp_fresult.bb,exp_fresult.cc,exp_fresult.dd, fresult.aa,fresult.bb,fresult.cc,fresult.dd);
			if (CheckAbort (HERE)) return;
		}
		_asm
		{
			push eax
			push edi
			mov	eax, dataf1
			movups	xmm0, [eax]
			mov	eax, dataf2
			movups	xmm1, [eax]
			maxps	xmm1, xmm0	;find max and store in xmm1
			movups	xmm2, [eax]
			cmpeqps	xmm1, xmm2	;which value changed?  should be second value
			andps	xmm0, xmm1	;lose the second value in xmm0
			subps	xmm0, xmm2	;
			mov	edi,  fresultp	;point to result structure
			movups	[edi],xmm0	;xfr result to structure				
			pop edi
			pop eax
			emms
		}
		if(memcmp(&check2,&fresult,16) != 0)
		{
			err_SIMD_CMP_MAX_SUB(check2.aa,check2.bb,check2.cc,check2.dd,fresult.aa,fresult.bb,fresult.cc,fresult.dd);
			if (CheckAbort (HERE)) return;
		}  
		_asm
		{
			push eax
			push edi
			mov		eax, 5
			cvtsi2ss	xmm0, eax		;load 5 into lsd
			shufps		xmm0, xmm0, 93h		;rotate by 32 bits 5 in 2 of 4
			mov		eax, 6
			cvtsi2ss	xmm0, eax		;load 6 into lsd
			shufps		xmm0, xmm0, 93h		;rotate by 32 bits 5 in 3 of 4
			mov		eax, 7
			cvtsi2ss	xmm0, eax		;load 7	
			shufps		xmm0, xmm0, 93h		;rotate by 32 bits 5 in 4 of 4
			mov		eax, 8
			cvtsi2ss	xmm0, eax		;load 8   xmm0 = 5678
			movaps		xmm1, xmm0
			shufps		xmm1, xmm1, 1bh		;rotate	  xmm1 = 8765
			mulps		xmm1, xmm0		;ans  40,42,42,40
			mov		eax, 2
			cvtsi2ss	xmm0, eax		;load 2
			divss		xmm1, xmm0		;divide by 2 scalar

			mov		edi,  fresultp		;point to result structure
			movups		[edi],xmm1		;xfr result to structure
			pop edi
			pop eax
			emms
		}
		if(memcmp(&check3,&fresult,16) != 0)
		{
			err_SIMD_MUL_DIV_CVT(check3.aa,check3.bb,check3.cc,check3.dd,fresult.aa,fresult.bb,fresult.cc,fresult.dd);
			if (CheckAbort (HERE)) return;
		}  
	}
}

//******************************************************************
// Title: CXCPUTestCPUInternalSpeed
//
// Abstract: Computes the internal speed of the CPU by comparing the
// rate of the known system clock to the rate of the CPU Time Stamp Counter
//
// Uses config parameters:
//
//******************************************************************
IMPLEMENT_TESTUNLOCKED (CPU, cpu_internal_speed, 5)
{
	int iCPUUpper, iCPULower;

	iCPUUpper = iCPUInternalSpeed + (int)((float)iCPUInternalSpeed * ((float)iCPUTolerance/100.0));
	iCPULower = iCPUInternalSpeed - (int)((float)iCPUInternalSpeed * ((float)iCPUTolerance/100.0));

//	#ifdef _DEBUG
		static int CpuIntSpd;
		CpuIntSpd++;
		ReportDebug(BIT0, _T("CPUInternalSpeed Test - Loop %d"), CpuIntSpd);
//	#endif

	#define CPU_NUM_TIMES 20
	double b, c, results[CPU_NUM_TIMES], sorted_results[CPU_NUM_TIMES];
	int i, j, k, cpu_speed;
	DWORD e;
	LARGE_INTEGER speed_v, speed_w, speed_x, speed_y, speed_z;

	cpu_speed = 0;
	QueryPerformanceFrequency(&speed_v);
	for(i=0; i < CPU_NUM_TIMES; i++)					// # of tests to make - pick median
	{
// CLI and STI are priveledged instructions in Windows 2000, so we should probably put a pre-compiler directive
// in here to only include the instructions when building an XBOX application.
//		__asm cli  // This should be enough to get full CPU time for this thread in a single-process OS
		QueryPerformanceCounter(&speed_x);
		__asm rdtsc									// read TimeStampCounter
		__asm mov speed_y.HighPart, edx
	    __asm mov speed_y.LowPart, eax
	    Sleep(15);									// wait X milliseconds
	    QueryPerformanceCounter(&speed_w);
	    __asm rdtsc									// Read TimeStampCounter again
	    __asm mov speed_z.HighPart, edx
	    __asm mov speed_z.LowPart, eax
//		__asm sti
		results[i]=(double)(speed_w.QuadPart-speed_x.QuadPart)/speed_v.QuadPart;
		results[i]=(double)(speed_z.QuadPart-speed_y.QuadPart)/results[i];
	}
	// Sort array - will pick median value
	for (i=0; i < CPU_NUM_TIMES; i++)		// find largest value	 
	{
		for (j=0, b=0, k=0; j < CPU_NUM_TIMES; j++)
		{
			if (results[j]>b)
			{
				b=results[j];
			    k=j;
			}
		}
	    // move into sorted_results[i]
	    sorted_results[i]=b;
	    results[k]=0;
	}

	// round speed value 
	c=sorted_results[CPU_NUM_TIMES/2];
	c=c/1000;
	e=(int)c/1000;

/*	
	d=e % 100;			// retrieve last two digits
	e=e/100;			// retrieve first digit
	if (d >= 0 && d <=2) 
		d=0;
	else if (d >= 22 && d <= 27)
		d=25;
	else if (d>=30 && d <= 35)
		d=33;
	else if (d >= 46 && d <= 52)
		d=50;
	else if (d >= 63 && d <= 69)
		d=66;
	else if (d >= 71 && d <= 77)
		d=75;
	else if (d >= 96 && d <= 100)
		d=100;
	// otherwise, just leave d the way it is
	cpu_speed=(int)((e*100)+d);

	// compare speeds
	if (iCPUInternalSpeed != cpu_speed)
	{
		err_NOMATCH_ORIGANDNEW_DD(iCPUInternalSpeed, cpu_speed);
		if (CheckAbort (HERE)) return;
	}
*/
	cpu_speed = e;
	if ((cpu_speed > iCPUUpper) || (cpu_speed < iCPULower))
	{
		err_NOMATCH_ORIGANDNEW_DDD(cpu_speed, iCPULower, iCPUUpper);
		if (CheckAbort (HERE)) return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\gfxtest.h ===
typedef struct _GFXTEST_RESULTS {
    HRESULT hr;
    UINT    uFrame;
    DWORD   dwCRCResult[3];
    DWORD   dwCRCExpected[3];
    bool    bHardwareChecksum;
} GFXTEST_RESULTS, *PGFXTEST_RESULTS;

extern "C" 
{
	HRESULT Grafx_StartupAnimation_TestMain(PGFXTEST_RESULTS pgtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xcpu\xcpu.h ===
// xCPU.h - CPU testing module

#if !defined(_XCPU_H_)
#define _XCPU_H_

// supress futile warnings about assignment operators
#pragma warning (disable:4512)

#include "..\parameter.h"


#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif

#define XCPU_MODNUM   3
// Naming of class test and module classes.
// 
// module class: CX<module>
// test class:   CX<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//
long THE_END;			// End of the used address space
int (__cdecl *lucas)();

class CXModuleCPU : public CTestObj
{
public:
	DECLARE_XMTAMODULE (CXModuleCPU, "cpu", XCPU_MODNUM);  //(module name, module number)

protected:
	// Error messages declared here ...
	//(Note: 0x000 - 0x00f reserved for XMTA)
	//
	DWORD err_BADPARAMETER (LPCTSTR s1)
	{
		ReportError (0x010, L"Can't find configuration parameter \"%s\"\nThis configuration parameter doesn't exist or is invalid", s1); return FAIL;
	}
	DWORD err_WRONGFAMILY_D (int i1)
	{
		ReportError (0x011, L"The CPU is not of the correct family (value retrieved=%d).", i1); return FAIL;
	}
	DWORD err_WRONGMODEL_D (int i1)
	{
		ReportError (0x012, L"The CPU is not of the correct model (value retrieved=%d).", i1); return FAIL;
	}
	DWORD err_STEPPINGNOTALLOWED_X (int i1)
	{
		ReportError (0x013, L"Stepping is not allowed: 0x%x.", i1); return FAIL;
	}
	DWORD err_MMXNOTPRESENT ()
	{
		ReportError (0x014, L"MMX support not present when it should be."); return FAIL;
	}
	DWORD err_SIMDNOTPRESENT ()
	{
		ReportError (0x015, L"SIMD support not present when it should be."); return FAIL;
	}
	DWORD err_FPUNOTPRESENT ()
	{
		ReportError (0x016, L"FPU unit not present when it should be."); return FAIL;
	}
	DWORD err_NOMATCH_CACHE_DD (DWORD dw1, DWORD dw2)
	{
		ReportError (0x017, L"Actual cache descriptor value (0x%8.8lx) does not match expected value (0x%8.8lx).", dw1, dw2); return FAIL;
	}
	DWORD err_MMX_MOVE ()
	{
		ReportError (0x018, L"MMX mov operations failed."); return FAIL;
	}
	DWORD err_FREEINGMEMORY ()
	{
		ReportError (0x019, L"Error Freeing Memory."); return FAIL;
	}
	DWORD err_ALLOCMEMORY ()
	{
		ReportError (0x01A, L"Error Allocating Memory."); return FAIL;
	}
	DWORD err_SIMD_MOVE (DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6, DWORD dw7, DWORD dw8)
	{
		ReportError (0x01B, L"Streaming SIMD Register move operations failed with an unexpected result.\nExpected=%08lx%08lx%08lx%08lx\nReceived=%08lx%08lx%08lx%08lx", dw1, dw2, dw3, dw4, dw5, dw6, dw7, dw8); return FAIL;
	}
	DWORD err_SIMD_FP_SP (float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8)
	{
		ReportError (0x01C, L"SIMD FP SP operations failed with an unexpected result.\nExpected=%08.10f %08.10f %08.10f %08.10f\nReceived=%08.10f %08.10f %08.10f %08.10f", f1, f2, f3, f4, f5, f6, f7, f8); return FAIL;
	}
	DWORD err_SIMD_CMP_MAX_SUB (float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8)
	{
		ReportError (0x01D, L"SIMD CMP MAX AND SUB FP SP operations failed with an unexpected result.\nExpected=%08.10f %08.10f %08.10f %08.10f\nReceived=%08.10f %08.10f %08.10f %08.10f", f1, f2, f3, f4, f5, f6, f7, f8); return FAIL;
	}
	DWORD err_SIMD_MUL_DIV_CVT (float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8)
	{
		ReportError (0x01E, L"SIMD MUL, DIV, CVT FP SP operations failed with an unexpected result.\nExpected=%08.10f %08.10f %08.10f %08.10f\nReceived=%08.10f %08.10f %08.10f %08.10f", f1, f2, f3, f4, f5, f6, f7, f8); return FAIL;
	}
	DWORD err_NOMATCH_ORIGANDNEW_DD (int i1, int i2)
	{
		ReportError (0x01F, L"Expected value (%d) did not match actual value (%d).", i1, i2); return FAIL;
	}
	DWORD err_SQ_NUM_S (LPCTSTR s1)
	{
		ReportError (0x020, L"Squaring: %s.", s1); return FAIL;
	}
	DWORD err_ROUNDING_S (LPCTSTR s1)
	{
		ReportError (0x021, L"Rounding: %s.", s1); return FAIL;
	}
	DWORD err_FFT_FAILURE_S (LPCTSTR s1)
	{
		ReportError (0x022, L"FFT Failure: %s.", s1); return FAIL;
	}
	DWORD err_WRONG_CPU_TYPE_DD (int i1, int i2)
	{
		ReportError (0x023, L"The CPU (%d) is not of the correct type (%d).", i1, i2); return FAIL;
	}
	DWORD err_2STEPPINGLISTS ()
	{
		ReportError (0x024, L"Cannot have both 'Steppings Allowed' and 'Steppings Not Allowed' lists."); return FAIL;
	}
	DWORD err_NOMATCH_ORIGANDNEW_DDD (int i1, int i2, int i3)
	{
		ReportError (0x025, L"Actual speed MHz value (%d) did not fall in the expected range (%d - %d).", i1, i2, i3); return FAIL;
	}
	DWORD err_XXX ()
	{
		ReportError (0x026, L""); return FAIL;
	}


	// Parameters declared here ...
	//
	int iFamily;
	int iModel;
	int iCPUType;
	DWORD dwCacheDescriptor;
	int iCPUInternalSpeed;
	int iCPUTolerance;
	int iFPUStressLoops;
//	int m_cfgInt;
//	UINT m_cfgUint;
//	LPCTSTR m_cfgString;
//	int m_cfgChoice;

virtual bool InitializeParameters ();

public:
	// Common functions go here.  Put any functions that need 
	// to be global to the tests in the module class
	//
	void HelperFunction (); // delete this
};

#pragma warning (disable:4201)
union CPUType 
{
	DWORD reg;
	struct
	{
		DWORD Stepping:4;
		DWORD Model:4;
		DWORD Family:4;		// used to be 3, but spec says should be 4!
		DWORD ProcType:2;
	};
public:
};

union Cache
{
	DWORD reg;
	struct 
	{
		DWORD byte0:8;
		DWORD byte1:8;
		DWORD byte2:8;
		DWORD byte3:8;		// bit 7 of byte3 will be 0 if this register is valid
	};
	public:
};


union Features
{
	DWORD reg;
	struct
	{
		DWORD FPU:1;
		DWORD VME:1;
		DWORD DE:1;
		DWORD PSE:1;
		DWORD TSC:1;
		DWORD MSR:1;
		DWORD PAE:1;
		DWORD MCE:1;
		DWORD CXS:1;
		DWORD APIC:1;
		DWORD RES1:2;
		DWORD MTRR:1;
		DWORD PGE:1;
		DWORD MCA:1;
		DWORD CMOV:1;
		DWORD WHOKNOWS:7;
		DWORD MMX:1;
		DWORD FXSR:1;
		DWORD XMM:1;
		DWORD WNI:1;	//bit 26
	};
};

union struct_128 
{
	struct					// view data as 32 bit floating point numbers
	{
		float aa,bb,cc,dd;
	};
	struct
	{
		double low_float, high_float;
	};
	struct					// view data as 32 bit integers
	{
		DWORD a, b, c, d;
	};
	struct
	{
		DWORD low_int,high_int;	// view data as 64 bit integers
	};
public:
};
struct int_2x32{__int32 a, b;};
#pragma warning (default:4201)

#endif // _XCPU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xcpu\i386\LUCAS64.ASM ===
TITLE   setup

	.386

_TEXT32 SEGMENT PARA USE32 PUBLIC 'DATA'

IFDEF WIN31
_MAXERR		DQ	0.0		; Maximum error
_SUMINP		DQ	0.0		; Sum of inputs
_SUMOUT		DQ	0.0		; Sum of outputs
_ERRCHK		DD	0		; Is error checking enabled?
_PARG		DD	0		; Prime exponent being tested

ELSE
EXTRN	_MAXERR:QWORD
EXTRN	_SUMINP:QWORD
EXTRN	_SUMOUT:QWORD
EXTRN	_ERRCHK:DWORD
EXTRN	_PARG:DWORD
EXTRN	_inputaddrqq:DWORD
ENDIF

;
; Global variables needed in squaring
;

IFDEF WIN31
        align   8
_FPSHALF		DD	0.5		; One-half
_FPSMINUS2		DD	-2.0		; Used to subtract 2.
_FPSBIGVAL		DD	0.0		; Used to round to an integer
_FPSscaled_numbig	DD	0		; numbig * (2^32 / n)
_FPSscaled_numlit	DD	0		; numlit * (2^32 / n)
		; These values only used during setup
_FPSp		DD	0		; Mersenne prime being tested
_FPSnumlit		DD	0		; number of small words in the fft
_FPSnumbig		DD	0		; number of big words in the fft

ELSE
EXTRN _FPSHALF:DWORD
EXTRN _FPSMINUS2:DWORD
EXTRN _FPSBIGVAL:DWORD
EXTRN _FPSscaled_numbig:DWORD
EXTRN _FPSscaled_numlit:DWORD
		; These values only used during setup
EXTRN _FPSp:DWORD
EXTRN _FPSnumlit:DWORD
EXTRN _FPSnumbig:DWORD
ENDIF

_TEXT32	ENDS


	ASSUME  CS: _TEXT32, DS: _TEXT32, SS: _TEXT32, ES: _TEXT32

n	EQU	65536		; size of the FFT

INCLUDE common.mac

;
; FFT.CPP should fully describe the memory layout.
; In pass1:
;	The distance between each data element is 8 bytes.
;	The distance between every fourth element is 256 bytes.
;	The distance between every 64th element is 4K bytes + gap.
; In pass2:
;	The distance between each data element is 32 bytes.
;	The distance between every eighth element is 32K bytes + gaps.
;	The distance between every 128th element is 4K bytes + gap.
;

	assign_addrs 0, 3072, 1536, 0, 179520

pass1_distances MACRO
	dist1 = 8
	dist4 =	256			*INTERLEAVE
	dist64 = (4096+32)		*INTERLEAVE
	dist512 = 32			*INTERLEAVE
	dist4096 = (32768+4096+8*32)	*INTERLEAVE
	ENDM
pass2_distances MACRO
	dist1 = 32			*INTERLEAVE
	dist8 = (32768+4096+8*32)	*INTERLEAVE
	dist128 = 8
	dist512 = 256			*INTERLEAVE
	dist8192 = (4096+32)		*INTERLEAVE
	ENDM

_TEXT32	SEGMENT 'CODE'

; Setup routine

	PUBLIC	_setup64
	IFDEF WIN31
	ORG	0400h
_setup64 PROC FAR
	push	es			; USE32 routines must preserve es,bp
	push	ebp
	push	ds			; copy ds to es
	pop	es
	mov	_PARG, ecx
	ELSE
_setup64 PROC NEAR
	push	ebp
	push	ebx
	push	edi
	push	esi
	ENDIF

; Initialize

	finit				; Init FPU

; Save p

	mov	eax, _PARG		; p
	mov	_FPSp, eax

; Compute two-to-phi and two-to-minus-phi multipliers

	normalize_setup

; Compute the array of sine and cosine/sine values

	sine_cosine_1_setup
	sine_cosine_2_setup
	pre_multiplier_setup pre_qqmults2, n, 128

; Return

	IFDEF WIN31
	pop	ebp
	pop	es
	ELSE
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ENDIF
	ret
_setup64 ENDP

;
; Compute next number in lucas sequence.  i.e.
; square the input number mod 2**p-1, subtract 2
;

	PUBLIC	_lucas64
	IFDEF WIN31
	ORG	1000h
_lucas64 PROC FAR
	push	es			; USE32 routines must preserve es,bp
	push	ebp
	push	ds			; copy ds to es
	pop	es
	mov	_ERRCHK, ecx		; ERRCHK is passed in ecx
	ELSE
_lucas64 PROC NEAR
	push	ebp
	push	ebx
	push	edi
	push	esi
	ENDIF

; Init the FPU every iteration just to be safe

	finit

; Start the fft process, do pass1 fft
; 128 sections of 512 values
; Perform nine levels of the FFT on 512 real values.

	pass1_distances
	mov	esi, _inputaddrqq		; U - Starting address
	mov	edx, 16*256+8		; V - 16 iterations of 8 iterations
b0a:	nine_levels_fft
	dec	dl			; V - Test inner loop counter
	JNZ_X	b0a			;*V - Iterate if necessary
	lea	esi, [esi-8*dist512+dist4096]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 8			; U - Reload inner loop counter
	JNZ_X	b0a			; V - Iterate if necessary

; Do the first section of pass 2

	pass2_distances
	seven_levels_real_fft_sq_unfft

; Do the other 255 sections of pass 2

	mov	esi, _inputaddrqq	; U - Restore source pointer
	add esi, 2*dist128
	mov ebp, _inputaddrqq
	add	ebp, pre_qqmults2		; V - Addr of group pre-multipliers
	mov	edx, 8*256+16+80000000h	; U - 8 iters of 16 iters of 1 or 2
b1b:	seven_levels_fft_sq_unfft
	xor	edx, 80000000h		; U - Test inner loop counter
	JS_X	b1b			; V - Iterate if necessary
	lea	esi, [esi-4*dist128+dist512]; U - Next source pointer
	dec	dl			; V - Test outer loop counter
	JNZ_X	b1b			;*V - Iterate if necessary
	lea	esi, [esi-16*dist512+dist8192]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 16			; U - Reload inner loop counter
	JNZ_X	b1b			; V - Iterate if necessary

; Finish the inverse fft process, do pass1 inverse fft

	pass1_distances
	mov	esi, _inputaddrqq		; U - Source pointer
	mov	edx, 16*256+8		; V - 16 iterations of 8 iterations
b2a:	nine_levels_unfft
	dec	dl			; V - Test inner loop counter
	JNZ_X	b2a			;*V - Iterate if necessary
	lea	esi, [esi-8*dist512+dist4096]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 8			; U - Reload inner loop counter
	JNZ_X	b2a			; V - Iterate if necessary

; Error check - find largest round off error

	cmp	_ERRCHK, 0
	JZ_X	noechk

; Code to check for how close we are to incurring a round-off error

	pass2_distances
	fldz				; Maximum error
	mov	edx, _inputaddrqq	; Address of the group multipliers
	add	edx, norm_grp_qqmults	; Address of the group multipliers
	mov	esi, _inputaddrqq		; Address of squared number
	mov	edi, _FPSscaled_numlit	; Used to compute big vs little words
	mov	ebp, _FPSscaled_numbig
	mov	eax, -1			; First word is a big word (-1)
	mov	ebx, 8*256+16		; 8 iterations of 16 iterations of
elp4:
	push esi
	mov esi, _inputaddrqq
	mov [esi+save_counterqq], ebx
	pop esi
	mov	ecx, 4*256		; 4 iterations of
elp3:	mov	cl, 16			; 128 / 8 iterations
	mov ebx, _inputaddrqq
	add	ebx, norm_col_qqmults	; Restart the column multipliers
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi group multiplier
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi
elp2:	error_check			; Error check eight values
	lea	esi, [esi+dist8]	; Next source
	lea	ebx, [ebx+4*norm_gap]	; Next set of 8 column multipliers
	dec	cl
	JNZ_X	elp2			; Loop til done
	lea	esi, [esi-16*dist8+dist128]; Next source
	lea	edx, [edx+8]		; Next group multiplier
	fcompp				; Pop group multipliers
	sub	ecx, 256
	JNZ_X	elp3			; Loop til done
	lea	esi, [esi-4*dist128+dist512]; Next source
	lea	edx, [edx-4*8+big_norm_gap]; Next group multiplier
	push esi
	mov esi, _inputaddrqq
	mov ebx, [esi+save_counterqq]
	pop esi
	dec	bl
	JNZ_X	elp4			; Loop til done
	lea	esi, [esi-16*dist512+dist8192]; Next source
	sub	ebx, 256
	mov	bl, 16
	JNZ_X	elp4			; Loop til done
	fstp	_MAXERR			; Store maximum error

; Normalize the results

noechk:	pass2_distances
	fldz				; Init SUMOUT
	fld	_FPSMINUS2			; Start normalization process
	fadd	_FPSBIGVAL			; with a _FPSBIGVAL-2.0 carry!
	mov edx, _inputaddrqq
	add	edx, norm_grp_qqmults	; Address of the group multipliers
	mov	esi, _inputaddrqq		; Address of squared number
	mov	edi, _FPSscaled_numlit	; Used to compute big vs little words
	mov	ebp, _FPSscaled_numbig
	mov	eax, -1			; First word is a big word (-1)
	mov	ebx, 8*256+16		; 8 iterations of 16 iterations of
nlp4:
	push esi
	mov esi, _inputaddrqq
	mov [esi+save_counterqq], ebx
	pop esi
	mov	ecx, 4*256		; 4 iterations of
nlp3:	mov	cl, 16			; 128 / 8 iterations
	mov ebx, _inputaddrqq
	add	ebx, norm_col_qqmults	; Restart the column multipliers
	fld	QWORD PTR [edx]		; Two-to-phi
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi group multiplier
	fld	QWORD PTR [edx]		; Two-to-phi group multiplier
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi
nlp2:	normalize			; Normalize 8 values
	lea	esi, [esi+dist8]	; Next source
	lea	ebx, [ebx+4*norm_gap]	; Next set of 8 column multipliers
	dec	cl
	JNZ_X	nlp2			; Loop til done
	lea	esi, [esi-16*dist8+dist128]; Next source
	lea	edx, [edx+8]		; Next group multiplier
	fcompp				; Pop group multipliers
	fcompp				; Pop group multipliers
	sub	ecx, 256
	JNZ_X	nlp3			; Loop til done
	lea	esi, [esi-4*dist128+dist512]; Next source
	lea	edx, [edx-4*8+big_norm_gap]; Next group multiplier
	push esi
	mov esi, _inputaddrqq
	mov ebx, [esi+save_counterqq]
	pop esi
	dec	bl
	JNZ_X	nlp4			; Loop til done
	lea	esi, [esi-16*dist512+dist8192]; Next source
	sub	ebx, 256
	mov	bl, 16
	JNZ_X	nlp4			; Loop til done

					; Add any carry to first values
	mov	esi, _inputaddrqq		; Address of squared number
	mov	edi, _FPSscaled_numlit	; To compute big vs little words
	mov ebx, _inputaddrqq
	add	ebx, norm_col_qqmults	; Restart the column multipliers
	normalize_012

; Normalize SUMOUT value by multiplying by 1 / (n/2).
; This is the value of the first two-to-minus-phi group multiplier

	push esi
	mov esi, _inputaddrqq
	fmul	QWORD PTR ds:[esi + norm_grp_qqmults+norm_gap]
	pop esi
	fstp	_SUMOUT

; Return

exit:	IFDEF WIN31
	fld	_SUMINP			;; Return values in floating
	fld	_SUMOUT			;; point registers
	fld	_MAXERR
	pop	ebp
	pop	es
	ELSE
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ENDIF
	ret

_lucas64 ENDP

_TEXT32	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\Blobs.h ===
///////////////////////////////////////////////////////////////////////////////
// File: Blobs.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef BLOBS_H
#define BLOBS_H


#include "render_object.h"
#include "qrand.h"



struct BlobVertex
{
	D3DVECTOR pos;
    // D3DVECTOR normal;		// sphere with radius 1, normal is the pos!
	// Diffuse color is set as a constant.
};

   
class LavaLampInterior;


class LLBlob : public RenderObject
{
protected:
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

    LPDIRECT3DVERTEXBUFFER8 m_pBlobVB;
    LPDIRECT3DINDEXBUFFER8  m_pBlobIB;

	D3DVECTOR4				m_BlobColor;


	D3DVECTOR				m_Pos;
	D3DVECTOR				m_Scale;
	float					m_DeformationInertia;
	FLOAT					m_fRadius;


	float					m_Temperature;
	float					m_TemperatureAbsorbance;
	D3DVECTOR				m_Velocity;
	D3DVECTOR				m_Accel;


	int						m_Subdivisions;		// number of quads in a direction for each face
	float					m_fDivisionStep;	// distance on cube face that a division spans

	int						m_Species;

	// Cube has dimensions from -1 to +1.
	void					calcFacePoint(D3DVECTOR* ppos, int face, int u, int v);


public:
	LLBlob();

	void					create(D3DVECTOR pos, D3DVECTOR4 color);

	virtual void create() {}
	virtual void destroy();

	virtual void render();
	virtual void advanceTime(float fElapsedTime, float fDt);


	void			collided(D3DVECTOR pos, D3DVECTOR normal);
	void			interactWithBlob(const LLBlob* pllb, float dt);

	D3DVECTOR		getPos() const { return m_Pos; }
	float			getRadius() const { return m_fRadius; }
	float			getRadius2() const { return m_fRadius*m_fRadius; }

	int				getSpecies() const { return m_Species; }
	void			setSpecies(int s) { m_Species = s; }

	void			setColor(D3DVECTOR4 color) { m_BlobColor = color; }
	const D3DVECTOR4& getColor() const { return m_BlobColor; }


	static const LavaLampInterior* spLL;
};


class LavaLampInterior : public RenderObject
{
protected:
	enum { NUM_LLBLOBS = 64 };
	LLBlob m_Blobs[NUM_LLBLOBS];

    DWORD                   m_dwVertexShader;   // Vertex shader handle
    DWORD					m_dwPixelShader;	// Handle for pixel shader

	LPDIRECT3DCUBETEXTURE8	m_pNormCubemap;
	LPDIRECT3DDEVICE8		m_pd3dDevice;

	void					InitPixelShader();

	enum { MAX_CONIC_SECTIONS = 32 };
	int						m_NumConicSections;
	float					m_ConicSectionCenterX, m_ConicSectionCenterY;
	float					m_ConicSectionBotZ[MAX_CONIC_SECTIONS+1];
	float					m_ConicSectionRadius[MAX_CONIC_SECTIONS+1];
	float					m_ConicSectionSlope[MAX_CONIC_SECTIONS];	// dr/dz
	float					m_ConicSectionNormalR[MAX_CONIC_SECTIONS];	// -1, normalized
	float					m_ConicSectionNormalZ[MAX_CONIC_SECTIONS];	// slope, normalized

	static QRand			m_QRand;



public:

	virtual bool isVisible() { return true; }
	virtual void create();
	virtual void destroy();

	virtual void render();
	virtual void advanceTime(float fElapsedTime, float fDt);


	float	getBottom() const { return m_ConicSectionBotZ[0]; }
	float	getTop() const { return m_ConicSectionBotZ[m_NumConicSections+1]; }

	float	getRadius(float z) const
	{
		if (z < m_ConicSectionBotZ[0]) return 0.0f;
		for (int i=1; i<=m_NumConicSections; i++)
		{
			if (m_ConicSectionBotZ[i+1] < z) continue;
			float diff = m_ConicSectionBotZ[i+1] - m_ConicSectionBotZ[i];
			float s = (z - m_ConicSectionBotZ[i]) / diff;
			return m_ConicSectionRadius[i] + s*(m_ConicSectionRadius[i+1] - m_ConicSectionRadius[i]);
		}
		return 0.0f;
	}


	// Temperature is 1.0f at bottom, ramps to 0.0f at top.
	float getTemperature(float z) const;

	void collide(LLBlob* pllb, float x, float y, float z, float radius, float dt) const;
	bool collideWithCaps(LLBlob* pllb, float x, float y, float z, float radius) const;


	void recomputeSpecie();

	static inline float fRand01();
	static inline float fRand11();
};


#define LLI_RAND_MAX  0x00010000
#define LLI_RAND_MASK 0x0000FFFF

float LavaLampInterior::fRand01()
{
	static float mul = 1.0f / ((float)LLI_RAND_MAX);
	return ((float)(m_QRand.Rand()&LLI_RAND_MASK)) * mul;
}

float LavaLampInterior::fRand11()
{
	static float mul = 2.0f / ((float)LLI_RAND_MAX);
	return (((float)(m_QRand.Rand()&LLI_RAND_MASK)) * mul) - 1.0f;
}



#endif // BLOBS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\bootsnd.h ===
struct	DSPpatch {
	unsigned short *Start;				// address of start of sample
	unsigned short	Length;				// length of sample
	unsigned short	LoopStart;			// bytes from beg of sound to loop point 
	unsigned short	LoopLength;			// bytes form loop start to loop end
	unsigned short	LoopEnable;			// loop sound? T or F
	LPDSENVELOPEDESC		lpAmpEnvelope;
	LPDSENVELOPEDESC		lpMultiEnvelope;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\bootsound.h ===
/*
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 */



extern "C"  do_sos_init_return(void);
extern "C"	sos_main(void);
extern "C"  put_fifo(unsigned char);
extern "C"  dev_cleanup(void);

#ifdef  __cplusplus
extern "C" {
#endif

// All boot sound functions must be called at passive level

void BootSound_Start(); // Call once to start boot sound
void BootSound_Stop(void); // Call once to stop boot sound





#ifdef  __cplusplus
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\animate.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    animate.c

Abstract:

    Startup animation implementation.

--*/

#include <stddef.h>

#pragma code_seg("INIT")
#pragma data_seg("INIT_RW")
#pragma const_seg("INIT_RD")

#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "wtypes.h"

#include "ani.h"

// Tell linker to put startup animation code and data into INIT section
#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")
#pragma comment(linker, "/merge:D3D=INIT")
#pragma comment(linker, "/merge:D3D_RD=INIT")
#pragma comment(linker, "/merge:D3D_RW=INIT")
#pragma comment(linker, "/merge:XGRPH=INIT")
#pragma comment(linker, "/merge:XGRPH_RD=INIT")

// We always want to link with the animation code, so that we can
// keep the build from breaking. Thats why we use a global to
// decide whether to run the animation or not. The global tricks
// the linker into linking in all the code the animation uses.

#ifdef NOANI
BOOL gBootAnimation_DoAnimation = FALSE;
#else
BOOL gBootAnimation_DoAnimation = TRUE;
#endif

#ifdef BOOTSOUND
BOOL gBootAnimation_DoSound = TRUE;
#else
BOOL gBootAnimation_DoSound = FALSE;
#endif

// Background animation thread.
HANDLE g_hThread;

// Entrypoing into the animation thread.
VOID AnipStartAnimationThread(PKSTART_ROUTINE StartRoutine, PVOID StartContext);

// Main animation routine as defined in the animation library.
VOID AnipRunAnimation();

#define CONTIGUOUS_BLOCK_SIZE           (5 * 1024 * 1024 / 2)
#define AGP_APERTURE_BYTES              (64*1024*1024)
#define INSTANCE_MEM_MAXSIZE            (20*1024)
#define NV_INSTANCE_SIZE                (INSTANCE_MEM_MAXSIZE)

//------------------------------------------------------------------------
// Starts the animation which will run on a background thread.  This API
// returns immediately.
//

BOOL g_bShortVersion;

void AniStartAnimation(BOOLEAN fShort)
{
    NTSTATUS Status;

    if (gBootAnimation_DoAnimation){

        g_bShortVersion = fShort;

        Status = PsCreateSystemThreadEx(&g_hThread,
                                        0,
                                        0x4000,  // Stack size, 16K
                                        0,
                                        NULL,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        AnipStartAnimationThread);

        if (!NT_SUCCESS(Status))
        {
            // RIP(("AniStartAnimation - Unable to create thread."));
            g_hThread = NULL;
        }
    }
}

//------------------------------------------------------------------------
// Shut down the animation.  This will block until the animation finishes.
//
void AniTerminateAnimation()
{
    if (g_hThread)
    {
        NTSTATUS Status;
#if DBG
        int start = NtGetTickCount();
#endif

        // Wait for it to go away.
        Status = NtWaitForSingleObjectEx(g_hThread, KernelMode, FALSE, NULL);

#if DBG
        DbgPrint("Boot animation wait %d\n", NtGetTickCount() - start);

        if (Status == STATUS_TIMEOUT)
        {
            //RIP(("AniTerminateAnimation - Animation is stuck!"));
        }
#endif

        NtClose(g_hThread);

        g_hThread = NULL;
    }
}

void AnipBreak()
{
#if DBG
   _asm int 3;
#endif
}

#if DBG
int gcMemAllocsContiguous = 0;
#endif

//------------------------------------------------------------------------
// Blocks until the animation has completed (until the animation is ready
// to display the Microsoft logo).
//
void AniBlockOnAnimation(void)
{
    extern KEVENT g_EventLogoWaiting;

    NTSTATUS status;
    PETHREAD ThreadObject;
    PVOID WaitObjects[2];
    KWAIT_BLOCK WaitBlocks[2];

    if (g_hThread)
    {
        status = ObReferenceObjectByHandle(g_hThread, &PsThreadObjectType,
            (PVOID*)&ThreadObject);

        if (NT_SUCCESS(status))
        {
            WaitObjects[0] = ThreadObject;
            WaitObjects[1] = &g_EventLogoWaiting;

            KeWaitForMultipleObjects(2, WaitObjects, WaitAny, Executive,
                KernelMode, FALSE, NULL, WaitBlocks);

            ObDereferenceObject(ThreadObject);
        }
    }
}

//------------------------------------------------------------------------
// MemAllocContiguous
//
void *MemAllocContiguous(size_t Size, DWORD Alignment)
{
#if DBG
    gcMemAllocsContiguous++;
#endif

    return MmAllocateContiguousMemoryEx(
            Size,
            0,
            AGP_APERTURE_BYTES - NV_INSTANCE_SIZE,
            Alignment,
            PAGE_READWRITE | PAGE_WRITECOMBINE);
}

//------------------------------------------------------------------------
// MemFreeContiguous
//
void MemFreeContiguous(void *pv)
{
#if DBG
    if (gcMemAllocsContiguous <= 0)
    {
        AnipBreak();
    }
    gcMemAllocsContiguous--;
#endif

    MmFreeContiguousMemory(pv);
}

//------------------------------------------------------------------------
// Main animation procedure.  Defers to the startup animation library.
//
VOID AnipStartAnimationThread(
    PKSTART_ROUTINE StartRoutine, 
    PVOID StartContext
    )
{
    AnipRunAnimation();

    // Make this thread go away.
    PsTerminateSystemThread(0);
}

///////////////////////////////////////////////////////////////////////////////
// Defined so we don't have to pull libc in
typedef void (__cdecl *_PVFV)(void);

int __cdecl atexit(_PVFV func)
{
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
// Define a couple of debug-only methods used in XGRAPHICS that normally
// are implemented in XTL.

#ifdef STARTUPANIMATION

long __cdecl _ftol2(float x)
{
    DWORD result[2];
    unsigned short oldcw;
    unsigned short newcw;

    _asm
    {
        fstcw   [oldcw]         ; get control word
        fwait                   ; synchronize

        mov ax, [oldcw]         ; round mode saved
        or  ah, 0ch             ; set chop rounding mode
        mov [newcw], ax         ; back to memory

        fldcw   [newcw]         ; reset rounding
        fistp   qword ptr [result]  ; store chopped integer
        fldcw   [oldcw]         ; restore rounding

        mov eax, dword ptr [result]
        mov edx, dword ptr [result+4]
    }
}

#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))

#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
                         (*D_HI(x) << 13 || *D_LO(x)))
                         
int __cdecl _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
        return 1;
    }
    return 0;
}

VOID
XDebugError(PCHAR Module, PCHAR Format, ...)
{
    _asm int 3;
}

void Sleep(DWORD Milliseconds)
{
    _asm int 3;
}

VOID
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )
{
    DbgPrint((PSTR)lpOutputString);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\BlobRenderer.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: BlobRenderer.cpp
//
// Copyright 2001 Pipeworks Software
//
// WORK HALTED: Patent issues
//
///////////////////////////////////////////////////////////////////////////////
#include <xtl.h>
#include "xbs_math.h"
#include "xbs_app.h"
#include "Blobs.h"
#include "BlobRenderer.h"


///////////////////////////////////////////////////////////////////////////////
#define LLI_RAND_MAX  0x00010000
#define LLI_RAND_MASK 0x0000FFFF
///////////////////////////////////////////////////////////////////////////////
float FRand01()
{
	static QRand qrand;
	static float mul = 1.0f / ((float)LLI_RAND_MAX);
	return ((float)(qrand.Rand()&LLI_RAND_MASK)) * mul;
}
///////////////////////////////////////////////////////////////////////////////
float FRand11()
{
	static QRand qrand;
	static float mul = 2.0f / ((float)LLI_RAND_MAX);
	return (((float)(qrand.Rand()&LLI_RAND_MASK)) * mul) - 1.0f;
}
///////////////////////////////////////////////////////////////////////////////
BlobRenderer::BlobRenderer()
{
	m_pLLI = NULL;
	m_pBlobArray = NULL;
	m_NumBlobs = 0;

	m_Threshhold = 1.0f;

    m_dwNumVertices = 0;
    m_dwNumIndices = 0;
    m_pBlobVB = NULL;
    m_pBlobIB = NULL;

	m_pField = NULL;
	m_pVertexIndices = NULL;
}
///////////////////////////////////////////////////////////////////////////////
BlobRenderer::~BlobRenderer()
{
	destroy();
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::destroy()
{
	if (m_pBlobVB) m_pBlobVB->Release();
	if (m_pBlobIB) m_pBlobIB->Release();
	delete m_pField;
	delete m_pVertexIndices;

	m_pBlobArray = NULL;

	m_pLLI = NULL;
	m_pBlobArray = NULL;
	m_NumBlobs = 0;

    m_dwNumVertices = 0;
    m_dwNumIndices = 0;
    m_pBlobVB = NULL;
    m_pBlobIB = NULL;

	m_pField = NULL;
	m_pVertexIndices = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::render()
{
	int next_affiliation = m_pSources[0]->dAffiliation;
	int i;
	for (i=1; i<m_NumBlobs; i++)
	{
		next_affiliation = min(next_affiliation, m_pSources[i]->dAffiliation);
	}

	for (int affiliation = next_affiliation; affiliation < m_NumBlobs; affiliation = next_affiliation)
	{
		next_affiliation = m_NumBlobs;
		D3DVECTOR pt_min, pt_max;
		pt_min = pt_max = bs.ptPosition;
		bool b_unset = true;

		// For this affiliation, iterate through all the sources, adjusting
		// the min/max for any blobs with the correct affiliation.
		for (int i=0; i<m_NumBlobs; i++)
		{
			BlobSource& bs = m_pSources[i];

			// Keep track of what the smallest affiliation larger than the current affiliation is.
			int aff = bs.dAffiliation;
			if (aff > affiliation) next_affiliation = min(aff, next_affiliation);

			if (aff == affiliation)
			{
				if (b_unset)
				{
					b_unset = false;
					pt_min = pt_max = bs.ptPosition;
					pt_min.x -= bs.fConsiderationRadius;
					pt_min.y -= bs.fConsiderationRadius;
					pt_min.z -= bs.fConsiderationRadius;
					pt_max.x += bs.fConsiderationRadius;
					pt_max.y += bs.fConsiderationRadius;
					pt_max.z += bs.fConsiderationRadius;
				}
				else
				{
					pt_min.x = min(pt_min.x, bs.ptPosition.x - bs.fConsiderationRadius);
					pt_min.y = min(pt_min.y, bs.ptPosition.y - bs.fConsiderationRadius);
					pt_min.z = min(pt_min.z, bs.ptPosition.z - bs.fConsiderationRadius);

					pt_max.x = min(pt_max.x, bs.ptPosition.x + bs.fConsiderationRadius);
					pt_max.y = min(pt_max.y, bs.ptPosition.y + bs.fConsiderationRadius);
					pt_max.z = min(pt_max.z, bs.ptPosition.z + bs.fConsiderationRadius);
				}
			}
		}

		// Now have the boundaries for the rendering region. Blobs outside the area may
		// affect the energy threshold, but no polygons will be drawn outside it.
		int sx, sy, sz, ex, ey, ez;
		getCoords(pt_min, &sx, &sy, &sz);
		getCoords(pt_max, &ex, &ey, &ez);
		ex++; ey++; ez++;

		int len_x = ex - sx + 1;
		int len_y = ey - sy + 1;
		int len_z = ez - sz + 1;
		int len_xy = len_x*len_y;
		int len_xyz = len_xy * len_z;

		if (len_x*len_y*len_z > m_FieldX*m_FieldY*m_FieldZ)
		{
			continue;	// can't render it, it is too big
		}


		// Clear the part of the field that will be used. Note that this does not
		// share the rows/columns/levels that would be used if the entire field
		// was used. Instead, the minimum amount of memory is used in a contiguous
		// fashion.
		for (i=0; i<len_xyz; i++) m_pField[i] = 0.0f;


		// For each blob, isolate the box within influence and iterate for each point.
		// The box of influence can (and must) be clipped to the previously determined
		// region.
		for (i=0; i<m_NumBlobs; i++)
		{
			BlobSource& bs = m_pSources[i];
			D3DVECTOR pt_start, pt_end;
			Set(&pt_start,
				max(pt_min.x, bs.ptPosition.x - bs.fConsiderationRadius),
				max(pt_min.y, bs.ptPosition.y - bs.fConsiderationRadius),
				max(pt_min.z, bs.ptPosition.z - bs.fConsiderationRadius)
				);
			Set(&pt_end,
				min(pt_max.x, bs.ptPosition.x + bs.fConsiderationRadius),
				min(pt_max.y, bs.ptPosition.y + bs.fConsiderationRadius),
				min(pt_max.z, bs.ptPosition.z + bs.fConsiderationRadius)
				);

			int bsx, bsy, bsz, bex, bey, bez;
			getCoords(pt_start, &bsx, &bsy, &bsz);
			getCoords(pt_end  , &bex, &bey, &bez);
			bex++; bey++; bez++;
			// The coordinates have already been capped to the rendering region.

			if ( (bsx<=bex) && (bsy<=bey) && (bsz<=bez) )
			{
				D3DVECTOR pos, posll;
				getWorldPos(&posll, bsx, bsy, bsz);
				pos.z = posll.z;
				for (int w=bsz; w<=bez; w++, pos.z += m_FieldToWorld.z)
				{
					pos.y = posll.y;
					for (int v=bsy; v<=bey; v++, pos.y += m_FieldToWorld.y)
					{
						pos.x = posll.x;
						float* p_field = &m_pField[w*len_xy + v*len_x + bsx];
						for (int u=bsx; u<=bex; u++, pos.x += m_FieldToWorld.x)
						{
							*(p_field++) += bs.calculate(affiliation, pos);
						}
					}
				}
			}
		}
		// It is legitimate for the outermost points to have a negative energy accumulation,
		// but nothing should be giving it a positive value. It would be nice to enforce this,
		// but I'm not sure it's worth the trouble.

		// Woohoo! The field is complete for this affiliation. Start rendering.

		// Lock the buffers.
		int max_tris = len_xyz * 5 * 2;		// for a Sierpinski cube relative, maybe...
		BlobVertex* p_verts;
		u16* p_indices;
		if (D3D_OK != m_pBlobVB->Lock(0, len_xyz*6, (BYTE**) &pbv_buf, D3DLOCK_DISCARD))
		{
			continue;
		}
		if (D3D_OK != m_pBlobIB->Lock(0, max_tris*3, (BYTE**) &pbv_buf, D3DLOCK_DISCARD))
		{
			m_pBlobVB->Unlock();
			continue;
		}

		int num_tris = 0;
		int num_verts = 0;
		BlobVertex* p_vert = p_verts;
		u16* p_index = p_indices;


		// This buffer stores the vertex indices (or -1) for the vertex on each segment
		// of a voxel. The offsets march through the buffer, returning to zero when they
		// reach the voxel_wrap value. m_pVertexIndices[voxel_offset] is for the voxel
		// with the current point in the max_pt position.
		int voxel_offset = 0;
		int voxel_offset_x = 6*1;
		int voxel_offset_y = 6*len_x;
		int voxel_offset_z = 6*len_xy;
		int voxel_wrap = 6*(len_xy+1);
		memset(m_pVertexIndices, -1, sizeof(int) * voxel_wrap);



		D3DVECTOR pos;
		pos.z = pt_min.z;
		for (int w=sz; w<ez; w++, pos.z += m_FieldToWorld.z)
		{
			pos.y = pt_min.y;
			for (int v=sy; v<ey; v++, pos.y += m_FieldToWorld.y)
			{
				pos.x = pt_min.x;
				p_field = &m_pField[w*len_xy + v*len_x];
				for (int u=sx; u<ex; u++, pos.x += m_FieldToWorld.x)
				{
					u32 in_or_out;
					if (p_field[             0] > m_Threshhold) in_or_out |= 0x0001;
					if (p_field[             1] > m_Threshhold) in_or_out |= 0x0002;
					if (p_field[       len_x  ] > m_Threshhold) in_or_out |= 0x0004;
					if (p_field[       len_x+1] > m_Threshhold) in_or_out |= 0x0008;
					if (p_field[len_xy        ] > m_Threshhold) in_or_out |= 0x0010;
					if (p_field[len_xy+      1] > m_Threshhold) in_or_out |= 0x0020;
					if (p_field[len_xy+len_x  ] > m_Threshhold) in_or_out |= 0x0040;
					if (p_field[len_xy+len_x+1] > m_Threshhold) in_or_out |= 0x0080;

					if ((in_or_out!=0) && (in_or_out!=0x00FF))
					{
						// Not all corners are the same. Analyze the five tetrahedrons.
						// The five tetrahedrons are defined as corners:
						const int  odd_tetrahedrons[20] = { 0,1,2,4,  5,1,4,7,  3,1,2,7,  6,2,7,4,  1,2,4,7 };
						const int even_tetrahedrons[20] = { 1,0,5,3,  7,3,5,6,  2,0,6,3,  4,0,6,5,  0,6,5,3 };
						const int* tetrahedrons = ((u+v+w)&0x01) ? odd_tetrahedrons : even_tetrahedrons;
						
						for (int tet=0; tet<5; tet++)
						{
							int mask = 0;
							mask |= (1<<(tetrahedrons[4*tet+0]));
							mask |= (1<<(tetrahedrons[4*tet+1]));
							mask |= (1<<(tetrahedrons[4*tet+2]));
							mask |= (1<<(tetrahedrons[4*tet+3]));

							int masked = in_or_out & mask;
							if ((masked!=0) && (masked!=mask))
							{
								// Mixed corners for this tetrahedron. Triangles are needed.
								int ins[4];
								int outs[4];
								int num_in = 0;
								int num_out = 0;
								if (mask & 0x0001) ins[num_in++] = 0;
								if (mask & 0x0002) ins[num_in++] = 1;
								if (mask & 0x0004) ins[num_in++] = 2;
								if (mask & 0x0008) ins[num_in++] = 3;
								if (mask & 0x0010) ins[num_in++] = 4;
								if (mask & 0x0020) ins[num_in++] = 5;
								if (mask & 0x0040) ins[num_in++] = 6;
								if (mask & 0x0080) ins[num_in++] = 7;

								if (num_in==1)
								{
									// One is in, three are out.
									D3DVECTOR pos_in = pos;
									if (ins[0] & 0x01) pos_in.x += m_FieldToWorld.x * 0.5f;
									if (ins[0] & 0x02) pos_in.y += m_FieldToWorld.y * 0.5f;
									if (ins[0] & 0x04) pos_in.z += m_FieldToWorld.z * 0.5f;
								}
							}
						}
					}
				}
			}
		}


		// Render.


		m_pBlobIB->Unlock();
		m_pBlobVB->Unlock();
	}	
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::init(	const BlobSource* p_blob_sources, int num_blobs,
							float xy_spacing, float z_spacing,
							const D3DVECTOR& center, const D3DVECTOR& half_dim)
{
	m_FieldX = (int)((half_dim.x * 2.0f / xy_spacing) + 2.0f);
	m_FieldY = (int)((half_dim.y * 2.0f / xy_spacing) + 2.0f);
	m_FieldZ = (int)((half_dim.z * 2.0f /  z_spacing) + 2.0f);
	m_FieldXY = m_FieldX * m_FieldY;
	m_pField = new float[m_FieldXY * m_FieldZ];
	m_pVertexIndices = new int[(m_FieldXY+1) * 6];

	Sub(&m_LowerLeftCorner, center, half_dim);
	m_FieldToWorld.x = xy_spacing;
	m_FieldToWorld.y = xy_spacing;
	m_FieldToWorld.z =  z_spacing;
	m_WorldToField.x = 1.0f / xy_spacing;
	m_WorldToField.y = 1.0f / xy_spacing;
	m_WorldToField.z = 1.0f /  z_spacing;

	// Create a vertex buffer, too.
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::getCoords(const D3DVECTOR& pos, int* p_x, int* p_y, int* p_z, D3DVECTOR* p_remainder)
{
	float fx = (pos.x - m_LowerLeftCorner.x) * m_WorldToField.x;
	float fy = (pos.y - m_LowerLeftCorner.y) * m_WorldToField.y;
	float fz = (pos.z - m_LowerLeftCorner.z) * m_WorldToField.z;
	*p_x = (int) (fx);
	*p_y = (int) (fy);
	*p_z = (int) (fz);

	if (p_remainder)
	{
		p_remainder->x = fx - ((float)*p_x);
		p_remainder->y = fy - ((float)*p_y);
		p_remainder->z = fz - ((float)*p_z);
	}
	return (*p_z * m_FieldXY) + (*p_y * m_FieldX) + (*p_x);
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::getWorldPos(D3DVECTOR* pos, int x, int y, int z)
{
	pos->x = m_LowerLeftCorner.x + ((float)x) * m_FieldToWorld.x;
	pos->y = m_LowerLeftCorner.y + ((float)y) * m_FieldToWorld.y;
	pos->z = m_LowerLeftCorner.z + ((float)z) * m_FieldToWorld.z;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
TestBlobRenderer::TestBlobRenderer()
{
}
///////////////////////////////////////////////////////////////////////////////
TestBlobRenderer::~TestBlobRenderer()
{
	destroy();
}
///////////////////////////////////////////////////////////////////////////////
void TestBlobRenderer::create()
{
	for (int i=0; i<NUM_BLOBS; i++)
	{
		Set(&m_Sources[i].ptPosition, FRand01() * 0.2f, FRand01() * 0.2f, FRand01() * 0.2f);
		m_Sources[i].fStrength = 1.0f;
		m_Sources[i].fConsiderationRadius = 0.09f;
		m_Sources[i].fConsiderationRadius2 = m_Sources[i].fConsiderationRadius * m_Sources[i].fConsiderationRadius;
		m_Sources[i].dAffiliation = 0;
	}

	D3DVECTOR center, hd;
	Set(&center, 0.0f, 0.0f, 0.0f);
	Set(&hd, 1.0f, 1.0f, 1.0f);
	init(&m_Sources[i], NUM_BLOBS, 0.005f, 0.005f, center, hd);
}
///////////////////////////////////////////////////////////////////////////////
void TestBlobRenderer::advanceTime(float fElapsedTime, float fDt)
{
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\Blobs.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: Blobs.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include <xtl.h>
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "Blobs.h"


const LavaLampInterior* LLBlob::spLL = NULL;
QRand LavaLampInterior::m_QRand;


void LavaLampInterior::destroy()
{
//MTS	m_BlobRenderer.destroy();

	for (int i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].destroy();
	}


    if( m_dwPixelShader )
    {
        gpd3dDev->DeletePixelShader( m_dwPixelShader );
        m_dwPixelShader = 0;
    }

	if ( m_dwVertexShader )
	{
		gpd3dDev->DeleteVertexShader( m_dwVertexShader );
		m_dwVertexShader = 0;
	}
}



LLBlob::LLBlob()
{
	m_pBlobVB = NULL;
	m_pBlobIB = NULL;
	m_Temperature = 0.5f;
	Set(&m_Accel, 0.0f, 0.0f, 0.0f);
	Set(&m_Velocity, 0.0f, 0.0f, 0.0f);
	m_DeformationInertia = 0.3f;
}



void LLBlob::destroy()
{
	if (m_pBlobVB)
	{
		m_pBlobVB->Release();
		m_pBlobVB = NULL;
	}

	if (m_pBlobIB)
	{
		m_pBlobIB->Release();
		m_pBlobIB = NULL;
	}
}


void LavaLampInterior::InitPixelShader()
{
    if( m_dwPixelShader )
    {
        gpd3dDev->DeletePixelShader( m_dwPixelShader );
        m_dwPixelShader = 0;
    }

	m_dwPixelShader = gApp.loadPixelShader("D:\\Shaders\\blob.xpu");
}







void LavaLampInterior::create()
{
	LLBlob::spLL = this;


	m_ConicSectionCenterX = +0.04f;
	m_ConicSectionCenterY = -0.082f;

	m_NumConicSections = 2;
	m_ConicSectionBotZ[0] = -0.47f;
	m_ConicSectionBotZ[1] = -0.25f;
	m_ConicSectionBotZ[2] = +0.35f;

	m_ConicSectionRadius[0] = 0.11f;
	m_ConicSectionRadius[1] = 0.25f;
	m_ConicSectionRadius[2] = 0.12f;


	int i;
	for (i=0; i<m_NumConicSections; i++)
	{
		m_ConicSectionSlope[i] =	(m_ConicSectionRadius[i+1] - m_ConicSectionRadius[i+0]) /
									(m_ConicSectionBotZ[i+1]   - m_ConicSectionBotZ[i+0]);
		float norm = 1.0f / sqrtf(1 + m_ConicSectionSlope[i]*m_ConicSectionSlope[i]);
		m_ConicSectionNormalR[i] = norm * -1.0f;
		m_ConicSectionNormalZ[i] = norm * m_ConicSectionSlope[i];
	}


    // Initialize pixel shader
    InitPixelShader();

    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // Position
        D3DVSD_END()
    };


	m_dwVertexShader = gApp.loadVertexShader("D:\\Shaders\\blob.xvu", dwShaderVertexDecl);



	float bot = m_ConicSectionBotZ[0];
	float sx = m_ConicSectionCenterX - 0.1f;
	float sy = m_ConicSectionCenterY - 0.1f;
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		D3DVECTOR pos;
		D3DVECTOR4 color, base_color;
		Set(&pos, m_ConicSectionCenterX, m_ConicSectionCenterY, m_ConicSectionBotZ[m_NumConicSections>>1] );
		Set(&color, (i&0x04) ? 0.0f : 1.0f, (i&0x02) ? 0.0f : 1.0f, (i&0x01) ? 0.0f : 1.0f, 1.0f);
		Set(&base_color, 0.724f, 0.732f, 0.556f, 1.0f);
		
//MTS		m_Blobs[i].create(pos, color*0.1f + base_color*0.9f);
		m_Blobs[i].create(pos, base_color);
		m_Blobs[i].setSpecies(i);
	}


//MTS	m_BlobRenderer.create();
//MTS	m_BlobRenderer.init(this, &m_Blobs[0], NUM_LLBLOBS, 0.01f, 0.01f, m_ConicSectionCenterX, m_ConicSectionCenterY);

    return;
};


void LLBlob::calcFacePoint(D3DVECTOR* ppos, int face, int u, int v)
{
	float fu = (u==m_Subdivisions) ? +1.0f : -1.0f + m_fDivisionStep * ((float)u);
	float fv = (v==m_Subdivisions) ? +1.0f : -1.0f + m_fDivisionStep * ((float)v);
	switch(face)
	{
		case 0: Set(ppos, -1.0f, -fu, +fv); break;
		case 1: Set(ppos, +fv, -1.0f, -fu); break;
		case 2: Set(ppos, -fu, +fv, -1.0f); break;
		case 3: Set(ppos, +1.0f, +fu, +fv); break;
		case 4: Set(ppos, +fv, +1.0f, +fu); break;
		case 5: Set(ppos, +fu, +fv, +1.0f); break;
	}
}


void LLBlob::create(D3DVECTOR pos, D3DVECTOR4 color)
{
	// A blob is modeled as a subdivided cube.

	m_BlobColor = color;
	m_Pos = pos;
	Set(&m_Scale, 0.9f, 0.9f, 0.9f);
	m_DeformationInertia = spLL->fRand11() * 0.1f;


	m_fRadius = LavaLampInterior::fRand01();
	m_fRadius = 0.5f * (m_fRadius*m_fRadius + LavaLampInterior::fRand01());
	m_fRadius = 0.03f + 0.05f * m_fRadius;
	m_TemperatureAbsorbance = 0.05f / m_fRadius;	// is just representational

	m_Temperature = 0.5f + 0.2f * LavaLampInterior::fRand11();


	m_Subdivisions = 4;	// face is a grid of sd+1 quads square
	m_fDivisionStep = 2.0f / m_Subdivisions;

//MTS	m_dwNumVertices = 2*(subdivisions+2)*(subdivisions+2) + 4*subdivisions*(subdivisions+1);	// number of unique vertices
	m_dwNumVertices = 6*(m_Subdivisions+1)*(m_Subdivisions+1);
	m_dwNumIndices = 6*(m_Subdivisions)*(m_Subdivisions)*2*3;


	gpd3dDev->CreateVertexBuffer( m_dwNumVertices * sizeof(BlobVertex), 0, 0, 0, &m_pBlobVB);
	gpd3dDev->CreateIndexBuffer(  m_dwNumIndices  * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pBlobIB);


	BlobVertex* p_verts;
	WORD* p_indices;

	m_pBlobVB->Lock(0, 0, (BYTE**)&p_verts, 0);
	m_pBlobIB->Lock(0, 0, (BYTE**)&p_indices, 0);



	// Create vertices.
	BlobVertex* p_vert = &p_verts[0];
	for (int k=0; k<6; k++)
	{
		for (int j=0; j<=m_Subdivisions; j++)
		{
			for (int i=0; i<=m_Subdivisions; i++)
			{
				calcFacePoint(&p_vert->pos, k, i, j);
				float oo_dist = 1.0f / sqrtf(p_vert->pos.x*p_vert->pos.x + p_vert->pos.y*p_vert->pos.y + p_vert->pos.z*p_vert->pos.z);
				p_vert->pos.x *= oo_dist;
				p_vert->pos.y *= oo_dist;
				p_vert->pos.z *= oo_dist;
				p_vert++;
			}
		}
	}


	// Create indices.
	WORD* p_index = &p_indices[0];
	for (int k=0; k<6; k++)
	{
		int face_start = k*(m_Subdivisions+1)*(m_Subdivisions+1);
		for (int j=0; j<m_Subdivisions; j++)
		{
			for (int i=0; i<m_Subdivisions; i++)
			{
				*(p_index++) = face_start + (j+0)*(m_Subdivisions+1) + (i+0);
				*(p_index++) = face_start + (j+0)*(m_Subdivisions+1) + (i+1);
				*(p_index++) = face_start + (j+1)*(m_Subdivisions+1) + (i+0);

				*(p_index++) = face_start + (j+1)*(m_Subdivisions+1) + (i+1);
				*(p_index++) = face_start + (j+1)*(m_Subdivisions+1) + (i+0);
				*(p_index++) = face_start + (j+0)*(m_Subdivisions+1) + (i+1);
			}
		}
	}



	m_pBlobVB->Unlock();
	m_pBlobIB->Unlock();
}




void LavaLampInterior::advanceTime(float fElapsedTime, float fDt)
{
	if (fDt < 0.0f) fDt = 0.0f;
	if (fDt > 0.1f) fDt = 0.1f;

//MTS	m_BlobRenderer.advanceTime(fElapsedTime, fDt);

	for (int i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].advanceTime(fElapsedTime, fDt);
	}

	recomputeSpecie();
}


void LLBlob::advanceTime(float fElapsedTime, float fDt)
{
	float ambient_temp = spLL->getTemperature(m_Pos.z);
	float scale = 0.002f * m_TemperatureAbsorbance*m_TemperatureAbsorbance * fDt;
	m_Temperature += scale * (ambient_temp - m_Temperature);

	// For purposes of the simulation, water stays at a constant density.
	// A blob's density is equal to water at temperature 0.5f. For each unit
	// of temperature difference, an acceleration of 1.0 m/s/s is applied.
	m_Velocity.z += fDt * 1.0f * (m_Temperature-0.5f);

	m_Accel.x += LavaLampInterior::fRand11() * fDt;
	m_Accel.y += LavaLampInterior::fRand11() * fDt;
	m_Accel.z += LavaLampInterior::fRand11() * fDt;
//MTS	m_Velocity.x += LavaLampInterior::fRand11() * fDt * fDt;
//MTS	m_Velocity.y += LavaLampInterior::fRand11() * fDt * fDt;
//MTS	m_Velocity.z += LavaLampInterior::fRand11() * fDt * fDt;

	m_Accel.x = min(+0.05f, max(-0.05f, m_Accel.x));
	m_Accel.y = min(+0.05f, max(-0.05f, m_Accel.y));
	m_Accel.z = min(+0.05f, max(-0.05f, m_Accel.z));

	if (Length2(m_Accel) > 1.0f) Scale(&m_Accel, 0.96f);

	// Friction moving through water.
	AddScaled(&m_Velocity, m_Accel, fDt);
	float vel2 = Length2(m_Velocity);
	Scale(&m_Velocity, 1.0f - fDt * 120.0f * vel2);

	AddScaled(&m_Pos, m_Velocity, fDt);


	// Do collisions.
	spLL->collide(this, m_Pos.x, m_Pos.y, m_Pos.z, m_fRadius, fDt);


	// Adjust render wobble.
	m_Scale.x += m_DeformationInertia * fDt * m_TemperatureAbsorbance;
	m_Scale.y += m_DeformationInertia * fDt * m_TemperatureAbsorbance;
	m_Scale.z = 0.9f - (m_Scale.x - 0.9f) * (0.9f+0.9f)*0.9f / (0.9f*0.9f);

	float accel;
	if (m_DeformationInertia > 0.0f)
	{
		accel = 0.91f - m_Scale.x;
	}
	else
	{
		accel = 0.89f - m_Scale.x;
	}

	m_DeformationInertia += 20.0f * accel * fDt;
	m_DeformationInertia = max(-0.3f, min(+0.3f, m_DeformationInertia));
}


float LavaLampInterior::getTemperature(float z) const
{
	float dz = -0.5f + (z - m_ConicSectionBotZ[0]) / (m_ConicSectionBotZ[m_NumConicSections] - m_ConicSectionBotZ[0]);
	dz *= 2.6f;
	dz *= dz*dz;
	return max(0.0f, min(1.0f, 0.5f - dz));
}


bool LavaLampInterior::collideWithCaps(LLBlob* pllb, float x, float y, float z, float radius) const
{
	if (z - radius < m_ConicSectionBotZ[0])
	{
		D3DVECTOR pos, norm;
		Set(&pos, x, y, m_ConicSectionBotZ[0] + radius + 0.001f);
		Set(&norm, 0.0f, 0.0f, +1.0f);
		pllb->collided(pos, norm);
		return true;
	}

	if (z + radius > m_ConicSectionBotZ[m_NumConicSections])
	{
		D3DVECTOR pos, norm;
		Set(&pos, x, y, m_ConicSectionBotZ[m_NumConicSections] - radius - 0.001f);
		Set(&norm, 0.0f, 0.0f, -1.0f);
		pllb->collided(pos, norm);
		return true;
	}
	return false;
}


void LavaLampInterior::collide(LLBlob* pllb, float x, float y, float z, float radius, float dt) const
{
	// Bounce off the caps.
	if (collideWithCaps(pllb, x, y, z, radius))
	{
		z = pllb->getPos().z;
	}

	x -= m_ConicSectionCenterX;
	y -= m_ConicSectionCenterY;
	float r = sqrtf( x*x + y*y );

	// Check the conic sections. Check the surfaces first, the corners will be checked afterwards.
	int i;
	bool b_hit_wall = false;
	for (i=0; i<m_NumConicSections; i++)
	{
		if (m_ConicSectionBotZ[i+1] < z - radius) continue;
		if (m_ConicSectionBotZ[i+0] > z + radius) break;

		// Sphere overlaps the section at least somewhat. Find the nearest
		// point on the cone surface and see if that is within the range.
		float dz = z - m_ConicSectionBotZ[i];
		float dr = r - m_ConicSectionRadius[i];

		float overlap = radius - (dr*m_ConicSectionNormalR[i] + dz*m_ConicSectionNormalZ[i]);
		if (overlap < 0.0f) continue;

		// Calculate distance along surface to the nearest point of collision.
		float s = dr*m_ConicSectionNormalZ[i] - dz*m_ConicSectionNormalR[i];
		if (s<0.0f) continue;
		float height = m_ConicSectionBotZ[i+1]-m_ConicSectionBotZ[i];
		if (s*s > height*height * (1.0f + m_ConicSectionSlope[i]*m_ConicSectionSlope[i])) continue;

		// Collision.
		float nz = m_ConicSectionNormalZ[i];
		float oo_r = 1.0f / max(0.001f, r);
		float nx = x * oo_r * m_ConicSectionNormalR[i];
		float ny = y * oo_r * m_ConicSectionNormalR[i];

		D3DVECTOR pos, norm;
		x += nx*overlap;
		y += ny*overlap;
		z += nz*overlap;
		r = sqrtf( x*x + y*y );	// recompute radius
		Set(&pos, m_ConicSectionCenterX + x, m_ConicSectionCenterY + y, z);
		Set(&norm, nx, ny, nz);
		pllb->collided(pos, norm);
		b_hit_wall = true;
	}


	// Check the corners.
	if (!b_hit_wall) for (i=0; i<m_NumConicSections; i++)
	{
		if (m_ConicSectionBotZ[i+1] < z - radius) continue;
		if (m_ConicSectionBotZ[i+0] > z + radius) break;

		float dz = z - m_ConicSectionBotZ[i];
		float dr = r - m_ConicSectionRadius[i];

		if (dz*dz + dr*dr > radius*radius) continue;
		float dist = sqrtf(dz*dz + dr*dr);
		float overlap =  radius - dist;

		float f_norm = 1.0f / max(0.001f, dist);
		float nz = -dz * f_norm;
		float nr = -dr * f_norm;

		float oo_r = 1.0f / max(0.001f, r);
		float nx = x * oo_r * nr;
		float ny = y * oo_r * nr;

		D3DVECTOR pos, norm;
		x += nx*overlap;
		y += ny*overlap;
		z += nz*overlap;
		r = sqrtf( x*x + y*y );	// recompute radius
		Set(&pos, m_ConicSectionCenterX + x, m_ConicSectionCenterY + y, z);
		Set(&norm, nx, ny, nz);
		pllb->collided(pos, norm);
		b_hit_wall = true;
	}


	// Check other blobs.
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		if (&m_Blobs[i] == pllb) continue;
		D3DVECTOR delta;
		Sub(m_Blobs[i].getPos(), pllb->getPos(), &delta);
		float rad = (m_Blobs[i].getRadius() + pllb->getRadius());

		if (Length2(delta) > rad*rad) continue;
		pllb->interactWithBlob(&m_Blobs[i], dt);
	}

	if (collideWithCaps(pllb, x + m_ConicSectionCenterX, y + m_ConicSectionCenterY, z, radius))
	{
		// Should never happen with convex hull.
		z = pllb->getPos().z;
	}
}


void LLBlob::collided(D3DVECTOR pos, D3DVECTOR normal)
{
	D3DVECTOR diff;
	Sub(pos, m_Pos, &diff);
	if (Length2(diff) > 0.5f * m_fRadius * m_fRadius)
	{
		int a = 0;
	}

	float dot;
	dot = Dot(normal, m_Accel);
	if (dot<0.0f) AddScaled(&m_Accel, normal, -dot);

	dot = Dot(normal, m_Velocity);
	if (dot<0.0f) AddScaled(&m_Velocity, normal, -dot);

	m_Pos = pos;
}


void LLBlob::interactWithBlob(const LLBlob* pllb, float dt)
{
	// Attract at range, repel when close.

	float mass_b = pllb->m_fRadius;
	mass_b *= mass_b*mass_b;

	D3DVECTOR delta;
	Sub(pllb->getPos(), getPos(), &delta);
	float dist2 = Length2(delta);
	if (dist2 < 0.000001f) return;

	D3DVECTOR delta_v;
	Sub(pllb->m_Velocity, m_Velocity, &delta_v);
	float f_part_mag = Dot(delta_v, delta);


	if (getSpecies() == pllb->getSpecies())
	{
		// Same species.
		float extreme_rad = (m_fRadius + pllb->m_fRadius);
		float attract = mass_b * dt * 10000.0f * ((f_part_mag > 0.0f) ? 1.0f : 0.5f);
		AddScaled(&m_Velocity, delta, attract);
//MTS		float attract = ((1.0f / dist2) - (1.0f / (extreme_rad*extreme_rad))) * mass_b * dt * 5.0f;
//MTS		AddScaled(&m_Accel, delta, attract);

		// Should try adding to the velocity directly...

		extreme_rad *= 0.6f;
		float extreme_rad2 = extreme_rad*extreme_rad;
		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 5.0f;
		repel *=  ((f_part_mag > 0.0f) ? 0.3f : 1.0f);
		if (repel > 0.0f) AddScaled(&m_Velocity, delta, -repel);
//MTS		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 500.0f;
//MTS		if (repel > 0.0f) AddScaled(&m_Accel, delta, -repel);
	}
	else
	{
		// Different specie.
		float extreme_rad2 = (m_fRadius + pllb->m_fRadius);
		extreme_rad2 *= extreme_rad2;
		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 1.0f;
		repel *=  ((f_part_mag > 0.0f) ? 0.3f : 1.0f);
		AddScaled(&m_Velocity, delta, -repel);
//MTS		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 50.0f;
//MTS		AddScaled(&m_Accel, delta, -repel);
	}
}



void LavaLampInterior::recomputeSpecie()
{
	int prev_species[NUM_LLBLOBS];
	int i;
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		prev_species[i] = m_Blobs[i].getSpecies();
		m_Blobs[i].setSpecies(i);
	}

	for (i=0; i<NUM_LLBLOBS-1; i++)
	{
		for (int j=i+1; j<NUM_LLBLOBS; j++)
		{
			D3DVECTOR diff;
			Sub(m_Blobs[i].getPos(), m_Blobs[j].getPos(), &diff);
			float dist2 = Length2(diff);
			if (prev_species[i] == prev_species[j])
			{
				// Were connected.
				float radii2 = m_Blobs[i].getRadius() + m_Blobs[j].getRadius();
				radii2 *= radii2;
				if (dist2 < 0.9f*0.9f * radii2)
				{
					// Are still touching. Maintain the same specie.
					m_Blobs[j].setSpecies( m_Blobs[i].getSpecies() );
				}
			}
			else
			{
				// Were not connected.
				float check_rad = max(m_Blobs[i].getRadius(), m_Blobs[j].getRadius());
				check_rad += 0.7f * min(m_Blobs[i].getRadius(), m_Blobs[j].getRadius());
				if (dist2 < check_rad*check_rad)
				{
					// Connect them only if they are in the top or bottom.
					bool b_close_to_end = false;
					float z = m_Blobs[i].getPos().z;
					float r = m_Blobs[i].getRadius();
					b_close_to_end = b_close_to_end || (z - m_ConicSectionBotZ[0] < 1.5f * r);
					b_close_to_end = b_close_to_end || (m_ConicSectionBotZ[m_NumConicSections] - z < 1.5f * r);
					z = m_Blobs[j].getPos().z;
					r = m_Blobs[j].getRadius();
					b_close_to_end = b_close_to_end || (z - m_ConicSectionBotZ[0] < 1.5f * r);
					b_close_to_end = b_close_to_end || (m_ConicSectionBotZ[m_NumConicSections] - z < 1.5f * r);

					if (b_close_to_end)
					{
						m_Blobs[j].setSpecies( m_Blobs[i].getSpecies() );
					}
				}
			}
		}
	}

	for (i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].setSpecies( m_Blobs[m_Blobs[i].getSpecies()].getSpecies() );
	}


	// For debug purposes, color code the blobs based on specie.
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		D3DVECTOR4 color, base_color;
		int s = m_Blobs[i].getSpecies();
		Set(&color, (s&0x04) ? 0.0f : 1.0f, (s&0x02) ? 0.0f : 1.0f, (s&0x01) ? 0.0f : 1.0f, 1.0f);
		Set(&base_color, 0.724f, 0.732f, 0.556f, 1.0f);
		color.x = color.x*0.05f + base_color.x*0.95f;
		color.y = color.y*0.05f + base_color.y*0.95f;
		color.z = color.z*0.05f + base_color.z*0.95f;
		color.w = color.w*0.05f + base_color.w*0.95f;
//MTS		m_Blobs[i].setColor(color);
	}
}




void LavaLampInterior::render()
{
    // Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,  TRUE );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    gpd3dDev->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_ALPHAFUNC,       D3DCMP_GREATEREQUAL );
    gpd3dDev->SetRenderState( D3DRS_ALPHAREF,        0x00000001 );
    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
//MTS    gpd3dDev->SetRenderState( D3DRS_FILLMODE,         D3DFILL_WIREFRAME );

    gpd3dDev->SetTexture( 0, gApp.pNormalCubeMap );


    gpd3dDev->SetVertexShader( m_dwVertexShader );
    gpd3dDev->SetPixelShader( m_dwPixelShader );



    // Note: when passing matrices to a vertex shader, we transpose them, since
    // matrix multiplies are done with dot product operations on the matrix rows.

	D3DMATRIX matFinal,matTmp;
	MulMats(gApp.theCamera.matWTC,gApp.theCamera.matProj,&matTmp);
	SetTranspose(matTmp,&matFinal);
	gpd3dDev->SetVertexShaderConstant(4,(CONST void *)&matFinal,4);


	//; Expected vertex shaders constants
	//;    c0-c3    = Transpose of world matrix
	//;    c4-c7    = Transpose of view*projection matrix
	//;    c8       = some constants, x=0, y=1, z=2, w=0.5
	D3DVECTOR4 val;

	// Constants
	Set(&val, 0.0f, 1.0f, 2.0f, 0.5f);
	gpd3dDev->SetVertexShaderConstant( 8, &val, 1 );



//MTS	m_BlobRenderer.render();

    
	for (int i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].render();
	}


    // Restore the state
    gpd3dDev->SetPixelShader( NULL );
    gpd3dDev->SetVertexShader( NULL );

	gpd3dDev->SetTexture(0, NULL);
}



void LLBlob::render()
{
	// Make the object to World transform. Transpose it.
    D3DMATRIX matT, mat;

	SetIdentity( &mat );
	mat.m[0][0] = m_Scale.x * m_fRadius;
	mat.m[1][1] = m_Scale.y * m_fRadius;
	mat.m[2][2] = m_Scale.z * m_fRadius;
	mat.m[3][0] = m_Pos.x;
	mat.m[3][1] = m_Pos.y;
	mat.m[3][2] = m_Pos.z;

	SetTranspose( mat, &matT );
    gpd3dDev->SetVertexShaderConstant( 0, &matT, 4 );


	// Expected pixel shader constants
	//; c0          = light 1 direction
	//; c1          = light 2 direction
	//; c2          = base blob color
	//; c3          = ambient color
	D3DVECTOR4 val;
	Set(&val, 0.5f, 0.6f, 0.5f, 1.0f );
	gpd3dDev->SetPixelShaderConstant( 0, &val, 1 );

	Set(&val, 0.5f, 0.4f, 0.5f, 1.0f );
	gpd3dDev->SetPixelShaderConstant( 1, &val, 1 );

	// Blob color
	gpd3dDev->SetPixelShaderConstant( 2, &m_BlobColor, 1 );

	// Ambient light
	val = m_BlobColor;
	val.x *= 0.6f;
	val.y *= 0.6f;
	val.z *= 0.6f;
	gpd3dDev->SetPixelShaderConstant( 3, &val, 1 );


    // This could be set in the lava lamp, but we might have blobs with different numbers of vertices.
	gpd3dDev->SetIndices( m_pBlobIB, 0 );
    gpd3dDev->SetStreamSource( 0, m_pBlobVB, sizeof(BlobVertex) );

    gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumVertices, 
                                        0, m_dwNumIndices/3 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\BlobRenderer.h ===
///////////////////////////////////////////////////////////////////////////////
// File: BlobRenderer.h
//
// Copyright 2001 Pipeworks Software
//
// WORK HALTED: Patent issues
//
///////////////////////////////////////////////////////////////////////////////
#ifndef BLOBRENDERER_H
#define BLOBRENDERER_H

#include "render_object.h"


// Adapted from: http://www.gamasutra.com/features/20000523/lander_01.htm
// Possibly in violation of US Patent #4,710,876
// http://164.195.100.11/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=/netahtml/search-bool.html&r=1&f=G&l=50&co1=AND&d=pall&s1='4710876'.WKU.&OS=PN/4710876&RS=PN/4710876



struct BlobVertex
{
	D3DVECTOR pos;
    D3DVECTOR normal;	// not normalized, do it in the GPU
	// Diffuse color is set as a constant.
};








class BlobSource
{
public:
	D3DVECTOR		ptPosition;
	float			fStrength;
	float			fConsiderationRadius;
	float			fConsiderationRadius2;
	int				dAffiliation;	// affiliation of -1 is never rendered, but does repulse

	inline float	calculate(int affiliation, const D3DVECTOR& pos) const
	{
		float dist2 = Distance2(ptPosition, pos);
		if (dist2 > fConsiderationRadius2) return 0.0f;
		float falloff = 1.0f - (dist2/fConsiderationRadius2);
		return ((affiliation==dAffiliation) ? 1.0f : -1.0f) * fStrength * falloff*falloff;
	}
};




class BlobRenderer : public RenderObject
{
protected:
	const BlobSource*		m_pSources;
	int m_NumBlobs;

	float					m_Threshhold;

    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

    LPDIRECT3DVERTEXBUFFER8 m_pBlobVB;
    LPDIRECT3DINDEXBUFFER8  m_pBlobIB;
	


	float*		m_pField;
	int*		m_pVertexIndices;	// circular fifo which stores one layer of vertex indices
	int			m_FieldX, m_FieldY, m_FieldXY, m_FieldZ;		// number of entries in each field coord

	D3DVECTOR	m_LowerLeftCorner;
	D3DVECTOR	m_FieldToWorld;
	D3DVECTOR	m_WorldToField;

	int			getCoords(const D3DVECTOR& pos, int* p_x, int* p_y, int* p_z, D3DVECTOR* p_remainder=NULL);
	void		getWorldPos(D3DVECTOR* pos, int x, int y, int z);

public:
	BlobRenderer();
	~BlobRenderer();

	virtual bool isVisible() { return true; }
	virtual void destroy();

	virtual void render();
	virtual void advanceTime(float fElapsedTime, float fDt) {}

	
	void init(	const BlobSource* p_blob_sources, int num_blobs,
				float xy_spacing, float z_spacing,
				const D3DVECTOR& center, const D3DVECTOR& half_dim);

	void	getThreshhold() const	{ return m_Threshhold; }
	void	setThreshhold(float th)	{ m_Threshhold = th; }
};


class TestBlobRenderer : public BlobRenderer
{
protected:
	enum { NUM_BLOBS = 6 };
	BlobSource m_Sources[NUM_BLOBS];

public:
	TestBlobRenderer();
	~TestBlobRenderer();

	virtual void create();
	virtual void advanceTime(float fElapsedTime, float fDt);
};



#endif // BLOBRENDERER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\camera.cpp ===
//
//	camera.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "camera.h"
#include "renderer.h"

///////////////////////////////////////////////////////////////////////////////
void Camera::Init()
{
	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::UnInit()
{
}
///////////////////////////////////////////////////////////////////////////////
void Camera::lookAt(const D3DVECTOR &cam_pos, const D3DVECTOR &look_pt, const D3DVECTOR &up)
{
	SetLookAt(cam_pos,look_pt,up,&matWTC);

	vPos = cam_pos;
	vLook = look_pt;
	vUp = up;
	SetInverse(matWTC,&matCTW);
	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::setProjection(float fov_in_y, float aspect, float near_plane, float far_plane)
{
	SetProjection(fov_in_y,aspect,near_plane,far_plane,&matProj);
	fNearPlane = near_plane;
	fFarPlane = far_plane;
	fAspectRatio = aspect;
	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::translate(const D3DVECTOR &rv)
{
	matCTW._41 += rv.x;
	matCTW._42 += rv.y;
	matCTW._43 += rv.z;

	SetInverse(matCTW,&matWTC);

	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::setCTW(const D3DMATRIX &ctw)
{
	matCTW = ctw;
	SetInverse(matCTW,&matWTC);

	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::setWTC(const D3DMATRIX &wtc)
{
	matWTC = wtc;
	SetInverse(matWTC,&matCTW);

	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
bool Camera::sphereVisCheck(const D3DVECTOR &pos, float rad)
{
	D3DVECTOR dv;

	Set(&dv,pos.x-matCTW._41,pos.y-matCTW._42,pos.z-matCTW._43);
	float dot = Dot(dv,*((D3DVECTOR *)&matCTW._31));

	if(dot+rad < fNearPlane)
		return false;
	if(dot-rad > fFarPlane)
		return false;

	if(!bClipPlanesSet)
	{
		updateClipPlanes();
	}

	for(int i=0; i<4; i++)
	{
		dot = Dot(pos,clipPlanes[i]);
		if(dot - clipPlanes[i].w > rad)
			return false;
	}
	
	return true;		
}
///////////////////////////////////////////////////////////////////////////////
void Camera::updateClipPlanes()
{
	D3DVECTOR pts[4];
	Set(&pts[0], 1.f, 1.f, 1.f);
	Set(&pts[1], 1.f,-1.f, 1.f);
	Set(&pts[2],-1.f, 1.f, 1.f);
	Set(&pts[3],-1.f,-1.f, 1.f);

	int ids[] =
	{
		0,1, 
		3,2, 
		2,0, 
		1,3, 
	};

	for(int i=0; i<4; i++)
	{
		D3DVECTOR norm,v;
		Sub(pts[ids[i*2+1]],pts[ids[i*2]],&v);
		Cross(pts[ids[i*2]],v,&norm);
		Normalize(&norm);

		TransformVector(norm,matCTW,&clipPlanes[i]);
		clipPlanes[i].w = Dot(clipPlanes[i],*(D3DVECTOR *)&matCTW._41);
	}

	bClipPlanesSet = true;
}
///////////////////////////////////////////////////////////////////////////////
float Camera::getPixelScaleForZ(float z) const
{
	float v = z / (matProj._11 * 320.f);
	return v;
}
///////////////////////////////////////////////////////////////////////////////
D3DMATRIX & Camera::getWTP()
{
	if( !bWTPValid )
	{
		MulMats(matWTC,matProj,&matWTP);
		bWTPValid = true;
	}

	return matWTP;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\CamControl.h ===
///////////////////////////////////////////////////////////////////////////////
// File: CamControl.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef CAMCONTROL_H
#define CAMCONTROL_H

#include "xbs_math.h"



/*
Uses Hermite interpolation, from page 54 of "Real-Time Rendering" (Moeller, Haines)


The finish nodes are:
	0: before the beginning of the slash, anything before this doesn't need to render the slash
	1: after exiting slash
	2: translated down, but still looking at center (but it is eclipsed by slash geometry) after this, only render slash
	3: partly rotated to final position, looking at slash center now
	4: final position
	5: final position, with high time value (the endcap)

*/


struct CamControlNodeData
{
public:
	unsigned char	ucTime;					// Time when the camera arrives here (0 indicates start of new path, 100 is start of finalization)
	signed char		scTension, scBias;		// Tension and bias of point, from -100 to +100
	D3DVECTOR		ptPosition;				// Position of node
	D3DVECTOR		vecLookAt;				// Position the camera looks at
};




struct CamControlNode
{
public:
	float		fTime;			// Time when the camera arrives here (0 indicates start of new path)
	D3DVECTOR	ptPosition;		// Position of node
	D3DVECTOR	vecVelocity;	// Velocity at this point
	D3DVECTOR	vecLookAt;		// Position the camera looks at
	D3DVECTOR	vecLookAtW;		// Velocity of what the camera looks at
	float		tension, bias;
};


class CameraController
{
protected:
	static CamControlNodeData	svCameraListData[];
	static CamControlNode		svCameraList[];

	enum { NUM_FINISH_NODES = 8 };
	CamControlNode		finishNodes[NUM_FINISH_NODES];
	D3DMATRIX	xfSlash;
	D3DVECTOR	ptSlashCenter;
	D3DVECTOR	ptFinalLookAt;

	int			numNodes;
	int			numPaths;


	int			curPathNum;
	int			curStartNode;
	int			curNumNodes;
	int			curVariableNodes;
	
	float		fCameraLookatInterpStart, fOOCameraLookatInterpDelta;


	CamControlNode*			getNode(int i)			{ return (i<curVariableNodes) ? &svCameraList[i+curStartNode] : &finishNodes[i-curVariableNodes]; }
	const CamControlNode*	getNode(int i)	const	{ return (i<curVariableNodes) ? &svCameraList[i+curStartNode] : &finishNodes[i-curVariableNodes]; }

public:
	void Init();
	void UnInit() {}

	void		buttonPressed();


	void		pickPath(int path = -1);	// negative indicates random


	void		getPosition(float t, D3DVECTOR* p_pos, D3DVECTOR* p_look, bool* pb_render_geom, bool* pb_render_slash);

	const D3DMATRIX&	getSlashTransform()	const	{ return xfSlash; }
};



#endif // CAMCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\bootsound.cpp ===
//depot/xbox/private/ntos/ani2/bootsound.cpp#7 - edit change 15970 (text)
/*
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 */



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>
#include <pci.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include "xtl.h"
#include "xdbg.h"
#include "bootsound.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

#if DBG
EXTERN_C g_dwDirectSoundPoolMemoryUsage;
EXTERN_C g_dwDirectSoundPhysicalMemoryUsage;
#endif

EXTERN_C SHORT system_clock_music;

KTIMER    g_BootSoundTimer;
KDPC      g_BootSoundDpc;

VOID
BootSoundDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
	system_clock_music++;
	sos_main();
    return;
}


void BootSound_Start(){
    LARGE_INTEGER dueTime;

    dueTime.QuadPart = 0;

  	do_sos_init_return();

    KeInitializeTimerEx(&g_BootSoundTimer,NotificationTimer);
    KeInitializeDpc(&g_BootSoundDpc,BootSoundDpc,NULL);

    KeSetTimerEx(&g_BootSoundTimer,
                 dueTime,
                 5,
                 &g_BootSoundDpc);
}


// 
// here's our main sos worker thread.  This needs to get called regularly
// it does all the sequencing and writing to the sound chip to make noise
//
// not true...we create a worker thread instead in the init routine



void BootSound_Stop(void){

    KeCancelTimer(&g_BootSoundTimer);

    //
    // free dsound objects
    //

    dev_cleanup();

#if DBG
    //
    // check if we leaked any mem
    //

    ASSERT(g_dwDirectSoundPoolMemoryUsage == 0);
    ASSERT(g_dwDirectSoundPhysicalMemoryUsage == 0);

#endif

}


extern "C" int _cdecl _purecall(
	void
	)
{
	_asm int 3; return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\CF.C ===
/*************************************************************************
*                                                                        *
* 	Here live the sound call processing functions			  *
*                                                                        *
*************************************************************************/

#include "sos.h"
#include "protos.h"
#include "externs.h"
#include <dsound.h>

extern	unsigned char	sound_call;	
extern struct timer_music music_timers[];
extern	unsigned char	n_timers;


#ifdef	BIGOS
unsigned char	restore_volume;

#endif

/*************************************************************************
*                                                                        *
* 	New Music Call:							  *
*	Note that if no tracks are specified, this is a silence call	  *
*									  *
* 	1.  Remove all current process for this level			  *
* 	2.  For each track in the new sound, create a new process	  *
* 	    for it.							  *
*                                                                        *
*************************************************************************/


	
void call_silence()
{
	struct process *tpp;
	struct process *pp;
	uchar	i;

	pp = process_queue->next;
	while (pp != NULL) {
	    tpp = pp->next;
	    kill_process(pp);
	    pp = tpp;
	}
	current_timer_priority = 0;
	for (i = 0; i < max_tracks; i++) {
	    channel_level[i] = 0;
		init_track_status(LEVEL_MUSIC,i);
		init_track_status(LEVEL_EFFECT,i);
	    nosound(i);
	}

	user_silence_function();
}


void call_music()
{
	ushort	const **track_ptr;		/* pointer to addr's of tracks */
	uchar	i;
	ushort	mask;
	ushort	track_map;

	marker = 0;	
	last_music_call = sound_call;

	remove_processes_by_level(LEVEL_MUSIC);
	track_map = current_call->track_map;
	track_ptr = current_call->tbl_ptr;
	for (i = 0,mask = 1; i < max_tracks; i++,mask <<= 1) {
	    if (track_map & mask) {	/* got a track to pl*/
			init_track_status(LEVEL_MUSIC,i);
			create_process((ushort *)*(track_ptr++),LEVEL_MUSIC,i);	
			if (channel_level[i] < LEVEL_EFFECT) {
				nosound(i);
			    channel_level[i] = LEVEL_MUSIC;
			}
	    }
	}

}

void call_play_timer()
{

}

void call_timer()
{

}

void call_end_timer()
{


}
void call_ignore()
{

}

extern	flash_yellow();
void call_effect()
{
	ushort	const **track_ptr;		/* pointer to addr's of tracks */
	uchar	i;
	ushort	mask;
	ushort	track_map;

	track_ptr = current_call->tbl_ptr;
	track_map = current_call->track_map;
	for (i = 0,mask = 1; i < max_tracks; i++,mask <<= 1) {
	    if (track_map & mask) {	/* got a track to pl*/
			remove_processes_by_level_and_channel(LEVEL_EFFECT,i);
			channel_level[i] = LEVEL_EFFECT;
			init_track_status(LEVEL_EFFECT,i);
			create_process((ushort *)*(track_ptr++),LEVEL_EFFECT,i);
	    }
	}
}

/*************************************************************************
*                                                                        *
* 	kill fx on all tracks											  *
*                                                                        *
*************************************************************************/

void call_kill_effect()
{

}



/*************************************************************************
*                                                                        *
* 	Send a byte to the yamaha										  *
* 	WARNING:  This routine blocks until it recieves both the		  *
* 	address AND data												  *
*                                                                        *
*************************************************************************/
#define	CALL_WAITING  (fifo.fifo_read != fifo.fifo_write)

void call_senddev()
{
#ifdef	BIGOS

	while (!CALL_WAITING)
		;
	b_value = get_fifo();
	while (!CALL_WAITING)
		;
	a_value = get_fifo();
	send_dev_function();
#endif
}
/*************************************************************************
*                                                                        *
* 	VOLUME SOUND CALL						  *
* 	byte 1:("type")	       	3 -> volume call			  *
* 	byte 2:("priority")	1 -> music volume; 2 -> fx volume	  *
* 	byte 3,4:("track_map")	level 					  *
* 	byte 5,6:		not used (MUST BE THERE)		  *
*                                                                        *
*************************************************************************/

void call_volume()
{

}


/************************************************************************
*                                                                      *
* 	MARK SOUND CALL
* 	byte 1:("type")	       	6 -> mark call							*
* 	byte 2:("priority")	marker #
* 	byte 3,4:("track_map")	NOT USED				  				*
* 	byte 5,6:		not used (MUST BE THERE)		  				*
*                                                                      *
*************************************************************************/

void call_mark()
{
	marker = current_call->priority;
}
		
init_track_status(uchar level, uchar channel)
{
	struct	track_info	*ti;
	ti = get_track_info_block2(level,channel);
/*	ti = get_track_info_block();*/
	
	ti->patch = 0;
	ti->loop_level = 0;
	ti->mux_level = 0;
	ti->transpose = 0;
	ti->filtercutoff = 0;
	ti->volume = 127;  /* */
	ti->pan = 0;
}


/*
 *	stop sound on channel chan
 */

void nosound(uchar chan)
{
	if (chan < max_tracks)
		silence_functions[chan](chan);
}

/*
 *	Remove all processes of level, 'level' from process queue
 */


remove_processes_by_level(uchar level)
{
	struct process *tpp;
	struct process *pp;

	pp = process_queue->next;

	while (pp != NULL) {
	    tpp = pp->next;
	    if (pp->level == level)
	        kill_process(pp);
	    pp = tpp;
	}
}
void remove_processes_by_level_and_channel(uchar level, uchar channel)
{
	struct process *tpp;
	struct process *pp;

	pp = process_queue->next;

	while (pp != NULL) {
	    tpp = pp->next;
	    if (pp->level == level) {
			if (pp->hard_channel == channel) {
		    	kill_process(pp);
			}
	    }
	    pp = tpp;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\CamControl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: CamControl.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "CamControl.h"
///////////////////////////////////////////////////////////////////////////////
// Negative tension is rounder, Positive tension is sharper (and comes
// to more of a stop at the point).
// Negative bias favors direction from previous to current, positive
// favors direction from current to next.
CamControlNodeData CameraController::svCameraListData[] =
{
//MTS	// Focusing on widgets, passing past blob.
//MTS    {  0,   +00, +00,        +3.2f,   -17.4f,   +13.0f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 20,   +00, +00,        +2.1f,   -12.1f,    +6.15f,      -1.9f,    +7.8f,   -15.3f },
//MTS    { 40,   +00, +00,        +1.0f,    -6.8f,    -0.7f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 55,   +00, +00,        -7.2f,    -3.6f,    -7.5f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 70,   +00, +00,       -18.5f,   +14.1f,   -18.4f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 85,   +00, +00,       -16.2f,   +29.2f,   -23.1f,       -5.1f,    +8.4f,   -10.3f },
//MTS    { 95,   +00, +00,       -10.6f,   +49.3f,   -21.2f,       -5.1f,    +8.4f,   -10.3f },
//MTS
//MTS    // "drunken"
//MTS	{  0,   +00, +00,        -1.5f,    +2.8f,   -14.0f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 20,   +00, +00,        -3.8f,   +16.9f,   -22.8f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 45,   +00, +00,       +20.7f,   +27.6f,   -21.6f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 75,   +00, +00,       +18.1f,   +46.8f,   -27.0f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 95,   +00, +00,       +28.9f,   +75.1f,   -36.7f,       -0.0f,    -1.3f,    +0.0f },

	// Top, pan down, pull out.
    {  0,   +00, +00,       +11.4f,   -32.1f,   +33.0f,       +0.0f,    +0.0f,    +0.0f },
    { 20,   +00, +00,       +13.4f,   -37.7f,   +25.6f,       +0.0f,    +0.0f,    +0.0f },
    { 40,   +00, +00,       +15.6f,   -43.9f,    +8.8f,       +0.0f,    +0.0f,    +0.0f },
    { 60,   +00, +00,       +16.0f,   -45.0f,   -12.8f,       +0.0f,    +0.0f,    +0.0f },
    { 90,   +00, +00,       +18.2f,   -51.2f,   -29.6f,       +0.0f,    +0.0f,    +0.0f },

//MTS	// Low, looking up, pull out, and pan up.
//MTS    {  0,   +00, +00,       +15.2f,    -3.3f,   -15.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 20,   +00, +00,       +26.2f,    -5.7f,   -20.5f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 45,   +00, +00,       +40.2f,    -8.7f,   -23.6f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 65,   +00, +00,       +61.2f,   -13.3f,    -3.6f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 85,   +00, +00,       +84.4f,    -4.8f,   +11.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 95,   +00, +00,      +120.4f,    -8.8f,   +14.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Looking low, closeup on the bottom, pull out and pan up.
//MTS    {  0,   +00, +00,       -20.5f,   +48.8f,   +12.0f,       +0.0f,    +0.0f,   -18.6f },
//MTS    { 35,   +00, +00,       -10.4f,   +24.6f,    -2.4f,       +0.0f,    +0.0f,   -18.6f },
//MTS    { 70,   +00, +00,       -10.4f,   +24.6f,    -2.4f,       +0.0f,    +0.0f,   -18.6f },
//MTS    { 85,   +00, +00,       -16.5f,   +39.3f,    +4.2f,       -0.3f,    +0.1f,    -5.3f },
//MTS    { 95,   +00, +00,       -26.3f,   +75.4f,    -4.6f,       -0.3f,    +0.1f,    -0.5f },
//MTS
//MTS	// Somewhat high, rotate left, recenter, pause, and pull out.
//MTS    {  00,   +0, +0,       -92.5f,   -10.1f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  15,   +0, +0,       -88.0f,   +30.4f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  30,   +0, +0,       -64.7f,   +67.0f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  45,   +0, +0,       -22.6f,   +90.3f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  60,   +0, +0,       +21.7f,   +90.5f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  72,   +0, +0,       +65.4f,   +66.2f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  85,   +0, +0,       +97.5f,   +23.7f,   +16.1f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,      +110.8f,    -6.1f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// start a little low, slowly move up, drift right, pull out.
//MTS    {  00,   +0, +0,       +62.3f,   -28.5f,   -20.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  30,   +0, +0,       +62.3f,   -28.5f,   -20.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  50,   +0, +0,       +55.2f,   -25.3f,   -10.1f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  75,   +0, +0,       +56.7f,   -12.9f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       +73.9f,   -13.0f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Towards top, tube to the right, move down and left.
//MTS    {  00,   +0, +0,       +50.4f,   +33.2f,   +25.3f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  30,   +0, +0,       +50.4f,   +33.2f,   +25.3f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  45,   +0, +0,       +55.7f,    +9.3f,   +15.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  65,   +0, +0,       +39.1f,   -35.8f,    +3.3f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  90,   +0, +0,        +7.1f,   -53.7f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       -16.8f,   -78.0f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },

	// Start low near tube, pause, quickly go up and to the right, pause, pull out.
    {  00,   +0, +0,       -55.4f,   +19.7f,   -31.5f,       +0.0f,    +0.0f,    +0.0f },
    {  30,   +0, +0,       -55.4f,   +19.7f,   -31.5f,       +0.0f,    +0.0f,    +0.0f },
    {  45,   +0, +0,       -39.5f,    -0.6f,    -7.8f,       +0.0f,    +0.0f,    +0.0f },
    {  60,   +0, +0,        -4.3f,   -35.5f,   +16.6f,       +0.0f,    +0.0f,    +0.0f },
    {  70,   +0, +0,       +31.1f,   -32.6f,   +17.6f,       +0.0f,    +0.0f,    +0.0f },
    {  80,   +0, +0,       +57.7f,    -7.2f,    +3.3f,       +0.0f,    +0.0f,    +0.0f },
    {  95,   +0, +0,       +70.9f,    +1.8f,    +3.1f,       +0.0f,    +0.0f,    +0.0f },

	// Low, move up, go left, pull out.
//MTS    {  00,   +0, +0,       -51.7f,    -2.4f,   -32.4f,       +0.0f,    +0.0f,   +12.0f },
//MTS    {  25,   +0, +0,       -51.7f,    -2.4f,   -32.4f,       +0.0f,    +0.0f,   +12.0f },
//MTS    {  40,   +0, +0,       -54.4f,    -2.6f,   -23.3f,       +0.0f,    +0.0f,   +10.0f },
//MTS    {  50,   +0, +0,       -53.2f,    +6.7f,   -14.3f,       +0.0f,    +0.0f,    +7.0f },
//MTS    {  60,   +0, +0,       -41.8f,   +21.2f,    -9.3f,       +0.0f,    +0.0f,    +4.5f },
//MTS    {  70,   +0, +0,       -27.1f,   +34.2f,    -9.3f,       +0.0f,    +0.0f,    +2.0f },
//MTS    {  80,   +0, +0,        -6.9f,   +47.5f,    -9.3f,       +0.0f,    +0.0f,    +1.0f },
//MTS    {  88,   +0, +0,       +11.3f,   +52.3f,    -9.2f,       +0.0f,    +0.0f,    +0.5f },
//MTS    {  95,   +0, +0,       +24.2f,   +62.8f,    -9.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Orbit right (a little up).
//MTS    {  00,   +0, +0,        -2.6f,   -85.0f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  20,   +0, +0,       +48.1f,   -70.1f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  40,   +0, +0,       +80.1f,   -28.6f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  60,   +0, +0,       +81.4f,   +24.8f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  80,   +0, +0,       +56.5f,   +63.6f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       +27.9f,   +86.5f,    +8.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Orbit left.
//MTS    {  00,   +0, +0,       +47.3f,   -76.6f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  25,   +0, +0,       +11.5f,   -89.3f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  50,   +0, +0,       -35.7f,   -82.6f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  75,   +0, +0,       -71.9f,   -54.2f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       -89.5f,    -9.6f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Move down and to the right.
//MTS    {  00,   +0, +0,       -11.2f,   -42.9f,   +17.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  20,   +0, +0,        +2.6f,   -46.9f,    +7.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  40,   +0, +0,       +24.3f,   -40.5f,    -4.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  60,   +0, +0,       +38.7f,   -24.8f,    -9.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  80,   +0, +0,       +44.3f,   -12.1f,    -7.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       +52.4f,    +6.3f,    +2.0f,       +0.0f,    +0.0f,    +0.0f },

	// Rotate to left, fairly close.
    {  00,   +0, +0,       +34.7f,   +25.9f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  25,   +0, +0,       +42.3f,    +9.3f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  50,   +0, +0,       +42.4f,    -8.8f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  75,   +0, +0,       +34.4f,   -26.3f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  95,   +0, +0,       +30.7f,   -48.1f,   +14.3f,       +0.0f,    +0.0f,    +0.0f },

	// Start out low, pause, rotate up slightly and pull out.
	{  0,   +00, +00,       -50.1f,    -0.3f,   -51.5f,       +0.0f,    +0.0f,    +0.0f },
	{  25,  +00, +00,       -50.1f,    -0.3f,   -51.5f,       +0.0f,    +0.0f,    +0.0f },
	{  75,  +00, +00,       -50.1f,    -0.3f,   -51.5f,       +0.0f,    +0.0f,    +0.0f },
    {  95,  +00, +00,       -62.2f,    -0.4f,   -12.0f,       +0.0f,    +0.0f,    +0.0f },
};

#define NUM_CC_NODES  (sizeof(CameraController::svCameraListData)/sizeof(CamControlNodeData))

CamControlNode CameraController::svCameraList[NUM_CC_NODES];
///////////////////////////////////////////////////////////////////////////////
void CameraController::Init()
{
	numNodes = NUM_CC_NODES;
	numPaths = 0;
	curPathNum = -1;
	for (int i=0; i<numNodes; i++)
	{
		if (svCameraListData[i].ucTime == (unsigned char) 0) numPaths++;

		svCameraList[i].fTime = FINISH_START_TIME * ((float)svCameraListData[i].ucTime) * 0.01f;
		svCameraList[i].ptPosition = svCameraListData[i].ptPosition;
		svCameraList[i].vecLookAt = svCameraListData[i].vecLookAt;
		svCameraList[i].tension = ((float)svCameraListData[i].scTension) * 0.01f;
		svCameraList[i].bias = ((float)svCameraListData[i].scBias) * 0.01f;

//MTS		char buf[1024];
//MTS		D3DVECTOR pos = svCameraList[i].ptPosition;
//MTS		D3DVECTOR la = svCameraList[i].vecLookAt;
//MTS		sprintf(buf, "    {  %02d,   %+02d, %+02d,    %+8.1ff,%+8.1ff,%+8.1ff,   %+8.1ff,%+8.1ff,%+8.1ff },\n",
//MTS						(int) svCameraListData[i].ucTime, (int) svCameraListData[i].scTension, (int) svCameraListData[i].scBias,
//MTS						pos.x, pos.y, pos.z, la.x, la.y, la.z);
//MTS		if (svCameraListData[i].ucTime==0) OutputDebugString("\n");
//MTS		OutputDebugString(buf);
	}

	pickPath(-1);
}
///////////////////////////////////////////////////////////////////////////////
// negative indicates random
void CameraController::pickPath(int path)
{
	if (path<0)
	{
		path = ((unsigned int) (gApp.rand() & 0x7FFFFFFF));
	}
	if (path >= numPaths) path = path % numPaths;


	// The following line cycles the selected path. Without it, path selection is random.
//MTS	path = (curPathNum + 1) % numPaths;


//MTS	path = 1;

	curPathNum = path;



//MTS	char buf[1024];
//MTS	sprintf(buf, "Picked path %d\n", path);
//MTS	OutputDebugString(buf);


	int i;
	for (i=0; i<numNodes; i++)
	{
		if (svCameraList[i].fTime == 0.0f)
		{
			if (!path) break;
			path--;
		}
	}
	curStartNode = i;

	for (i=curStartNode+1; i<numNodes; i++)
	{
		if (svCameraList[i].fTime == 0.0f) break;
	}
	curVariableNodes = i - curStartNode;
	curNumNodes = curVariableNodes + NUM_FINISH_NODES;


	// Calculate the finishNodes.
	int j;
	for (j=0; j<NUM_FINISH_NODES; j++)
	{
		finishNodes[j].fTime = FINISH_START_TIME + FINISH_TRANSITION_TIME * ((float)j) / ((float)(NUM_FINISH_NODES-1));
		finishNodes[j].tension = +0.0f;
		finishNodes[j].bias = 0.0f;
	}

	fCameraLookatInterpStart = finishNodes[2].fTime;
	fOOCameraLookatInterpDelta = 1.0f / (finishNodes[5].fTime - fCameraLookatInterpStart);




	const CamControlNode* plast = &svCameraList[curStartNode + curVariableNodes - 1];
	CamControlNode* pthis = &finishNodes[0];
	
	float start_time = plast->fTime;

//MTS	const float slash_start_rad = -185.0f;
	const float slash_start_rad = -95.0f;
	const float slash_end_rad = 132.14f;

//MTS	const float cfYPositions[NUM_FINISH_NODES] = { 185.0f, 117.548f, -8.819f, -150.298f, -220.64f, -243.021f, -261.441f, -287.773f };
	const float cfYPositions[NUM_FINISH_NODES] = { +95.0f, +30.548f, -70.819f, -150.298f, -220.64f, -243.021f, -261.441f, -287.773f };
	const float cfZPositions[NUM_FINISH_NODES] = { 0.0f,   0.322f,   1.821f, 2.323f,    -11.926f,  -39.973f,  -60.774f,  -90.795f };
	const float camera_end_coord_y = cfYPositions[NUM_FINISH_NODES-1];
	const float camera_end_coord_z = cfZPositions[NUM_FINISH_NODES-1];

	const float lookat_offset = slash_end_rad * camera_end_coord_z / camera_end_coord_y;
	const float cfSlashDist = slash_end_rad - slash_start_rad;
	const float cfMinStartDist = 100.0f;






	
	// First finish node is at the entrance of the slash. Take the last nodes
	// velocity, move along it for a little bit, and then push it out to the
	// appropriate radius, about 200 units.
	// The slash's transform will also be set now.

	pthis->ptPosition = plast->ptPosition;

	D3DVECTOR vel;
	if (curVariableNodes >= 2)
	{
		Sub(getNode(curVariableNodes-1)->ptPosition, getNode(curVariableNodes-2)->ptPosition, &vel);
		Scale(&vel, 1.0f / (getNode(curVariableNodes-1)->fTime - getNode(curVariableNodes-2)->fTime));
	}
	else
	{
		Set(&vel, 0.0f, 0.0f, 0.0f);
	}

	AddScaled(&pthis->ptPosition, vel, (pthis->fTime - plast->fTime) * 0.7f);
	float vel_adj_len = Length(pthis->ptPosition);
	Scale(&pthis->ptPosition, 1.0f / vel_adj_len);	// normalizes

	D3DVECTOR slash_dir = pthis->ptPosition;
	float slash_y_offset = max(cfMinStartDist - slash_start_rad, vel_adj_len * 1.2f - slash_start_rad);
	Scale(&pthis->ptPosition, slash_y_offset + slash_start_rad);

	Set(&pthis->vecLookAt, 0.0f, 0.0f, 0.0f);



//MTS// Matches slash with barry's coordinates.
//MTSSet(&pthis->ptPosition, 0.0f, -1.0f, 0.0f);
//MTSSet(&slash_dir, 0.0f, -1.0f, 0.0f);
//MTSslash_y_offset = 0.0f;



	// Now do the slash xform.

	D3DVECTOR origin, up, x_dir, y_dir, z_dir;
	Set(&origin, 0.0f, 0.0f, 0.0f);
	Set(&up, 0.0f, 0.0f, 1.0f);

	// The shape has negative y going away from core.
	// Negative Y is normalized vector from slash_pos to origin
	y_dir = slash_dir;
	Scale(&y_dir, -1.0f);

	// X is y_dir crossed with up and normalized.
	Cross(y_dir, up, &x_dir);
	Normalize(&x_dir);

	// Z is x_dir cross y_dir.
	Cross(x_dir, y_dir, &z_dir);		// I think this is the wrong cross order...

	SetIdentity(&xfSlash);
	*((D3DVECTOR*)(&xfSlash._11)) = x_dir;
	*((D3DVECTOR*)(&xfSlash._21)) = y_dir;
	*((D3DVECTOR*)(&xfSlash._31)) = z_dir;
	*((D3DVECTOR*)(&xfSlash._41)) = y_dir;
	Scale((D3DVECTOR*)(&xfSlash._41), -slash_y_offset);
	ptSlashCenter = y_dir;
	Scale(&ptSlashCenter, - slash_end_rad - slash_y_offset);

//MTS	AddScaled(&pthis->ptPosition, z_dir, -7.0f);



	//const float cfYPositions[NUM_FINISH_NODES] = { 185.0f, 177.548f, 58.819f, -170.298f, -220.871f, -243.021f, -260.364f, -277.299f };
	float y_basis = slash_end_rad;
	for (j=1; j<NUM_FINISH_NODES; j++)
	{
		plast = pthis++;
		D3DVECTOR pt_in_slash;
		Set(&pt_in_slash, 0.0f, cfYPositions[j] + y_basis , cfZPositions[j]);
		TransformVector(pt_in_slash, xfSlash, &pthis->ptPosition);
		Add(pthis->ptPosition, ptSlashCenter, &pthis->ptPosition);
		Set(&pthis->vecLookAt, 0.0f, 0.0f, 0.0f);
	}






	// Set the final lookat point
	D3DVECTOR t;
	Set(&t, 0.0f, slash_end_rad, 25.0f);
	TransformVector(t, xfSlash, &ptFinalLookAt);
	Add(ptFinalLookAt, ptSlashCenter, &ptFinalLookAt);


	
	// Set the "m" parameters implicitly.

	for (j=0; j<curNumNodes; j++)
	{
		CamControlNode* pthis = getNode(j);
		Set(&pthis->vecVelocity, 0.0f, 0.0f, 0.0f);
		Set(&pthis->vecLookAtW, 0.0f, 0.0f, 0.0f);

		if (j)
		{
			D3DVECTOR delta;
			Sub(pthis->ptPosition, getNode(j-1)->ptPosition, &delta);
			AddScaled(&pthis->vecVelocity, delta, (1.0f - pthis->tension) * (1.0f + pthis->bias) * 0.5f);

			Sub(pthis->vecLookAt, getNode(j-1)->vecLookAt, &delta);
			AddScaled(&pthis->vecLookAtW, delta, (1.0f - pthis->tension) * (1.0f + pthis->bias) * 0.5f);
		}
		if (j<curNumNodes-1)
		{
			D3DVECTOR delta;
			Sub(getNode(j+1)->ptPosition, pthis->ptPosition, &delta);
			AddScaled(&pthis->vecVelocity, delta, (1.0f - pthis->tension) * (1.0f - pthis->bias) * 0.5f);

			Sub(getNode(j+1)->vecLookAt, pthis->vecLookAt, &delta);
			AddScaled(&pthis->vecLookAtW, delta, (1.0f - pthis->tension) * (1.0f - pthis->bias) * 0.5f);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void CameraController::getPosition(float t, D3DVECTOR* p_pos, D3DVECTOR* p_look, bool* pb_render_geom, bool* pb_render_slash)
{

	if (t > FINISH_STOP_TIME)
	{
		*p_pos = finishNodes[NUM_FINISH_NODES-1].ptPosition;
		*p_look = ptFinalLookAt;
		*pb_render_slash = true;
		*pb_render_geom = false;
		return;
	}

	int i;
	for (i=1; i<curNumNodes; i++)
	{
		if (getNode(i)->fTime > t) break;
	}
	if (i==curNumNodes)
	{
		*p_pos = getNode(curNumNodes-1)->ptPosition;
		*p_look = ptFinalLookAt;
		*pb_render_slash = true;
		*pb_render_geom = false;
		return;
	}
	if (i==0)
	{
		// Should never happen, but something is causing a lock...
		Set(p_pos, 0.0f, -90.0f, 0.0f);
		Set(p_look, 0.0f, 0.0f, 0.0f);
		*pb_render_slash = true;
		*pb_render_geom = false;
		return;
	}


	const CamControlNode* pprev = getNode(i-1);
	const CamControlNode* pnext = getNode(i);

	float dtc = max(0.001f, pnext->fTime - pprev->fTime);
	float dtp = max(0.001f, (i>=2) ? pprev->fTime - getNode(i-2)->fTime : dtc);
	float dtn = max(0.001f, (i<curNumNodes-1) ? getNode(i+1)->fTime - pnext->fTime : dtc);

	float uts = min(1.0f, max(0.0f, (t - pprev->fTime) / dtc));	// un-tweaked s
	float utss = uts*uts;
	float utsss = utss*uts;
	float frac = -2.0f*utsss + 3.0f*utss;
	float s = (t - pprev->fTime) / ((1.0f-frac)*dtp + frac*dtc);


	float ss = s*s;
	float sss = ss*s;
	float cA = 2.0f * sss - 3.0f * ss + 1.0f;
	float cB = sss - 2.0f * ss + s;
	float cC = sss - ss;
	float cD = -2.0f * sss + 3.0f * ss;

	p_pos->x = cA * pprev->ptPosition.x + cB * pprev->vecVelocity.x + cC * pnext->vecVelocity.x + cD * pnext->ptPosition.x;
	p_pos->y = cA * pprev->ptPosition.y + cB * pprev->vecVelocity.y + cC * pnext->vecVelocity.y + cD * pnext->ptPosition.y;
	p_pos->z = cA * pprev->ptPosition.z + cB * pprev->vecVelocity.z + cC * pnext->vecVelocity.z + cD * pnext->ptPosition.z;

	p_look->x = cA * pprev->vecLookAt.x + cB * pprev->vecLookAtW.x + cC * pnext->vecLookAtW.x + cD * pnext->vecLookAt.x;
	p_look->y = cA * pprev->vecLookAt.y + cB * pprev->vecLookAtW.y + cC * pnext->vecLookAtW.y + cD * pnext->vecLookAt.y;
	p_look->z = cA * pprev->vecLookAt.z + cB * pprev->vecLookAtW.z + cC * pnext->vecLookAtW.z + cD * pnext->vecLookAt.z;


	float sl = max(0.0f, min(1.0f, (t - fCameraLookatInterpStart) * fOOCameraLookatInterpDelta));
	
	float _sin,_cos;
	SinCos(sl * Pi,&_sin,&_cos);
	float interp = 0.5f*(1.0f - _cos);

	Scale(p_look, 1.0f - interp);
	AddScaled(p_look, ptFinalLookAt, interp);



	*pb_render_slash = (i > curVariableNodes - 1);
	*pb_render_geom  = (i < curNumNodes - 1);
}
///////////////////////////////////////////////////////////////////////////////
void CameraController::buttonPressed()
{
#ifndef STARTUPANIMATION
#ifdef INCLUDE_PLACEMENT_DOODAD	
	char buf[1024];
	D3DVECTOR pos;
	D3DVECTOR la = gApp.getLookatPoint();
	gApp.theCamera.getCameraPos(&pos);
	sprintf(buf, "    {  0,   +00, +00,    %+8.1ff,%+8.1ff,%+8.1ff,   %+8.1ff,%+8.1ff,%+8.1ff },\n",
					pos.x, pos.y, pos.z, la.x, la.y, la.z);
	OutputDebugString(buf);
#endif
#endif // STARTUPANIMATION
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\dsptables.h ===
#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION


unsigned const short pitch_table_dsp[] = {
		0x80
};



unsigned short	FM32768[32768];

unsigned short	Sin128[128];


unsigned short	Saw128[128];



unsigned short Noise8192[8192];

unsigned short	ThunEl16[0x5540];	// size from thunel16k.equ
unsigned short	ReverseThunEl16[0x5540]; // reversed version

unsigned const char	ThunEl16Data[] = {
#include "thunel16.x00"
};


unsigned short	Glock[3768];	// size from glock.equ

unsigned const char	GlockData[] = {
#include "glock.x00"
};


unsigned short	Bubble[6719];	// size from bubble.equ

unsigned const char	BubbleData[] = {
#include "Bubble.x00"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\fastmath.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK Framework

Module Name:

    FastMath.h

Abstract:

    General math support including fast replacements for the standard math
    library. These fast replacements use SSE/SIMD instructions.

Revision History:

	7/1/2000	added fast_acos and fast_asin for SSE.
	7/3/2000	Fixed fast_log10 and fast_inversesqrt.
	7/4/2000	Fixed fast_atan2 bug.
	7/5/2000	improved quality of fast_acos and fast_asin.
	7/6/2000	improved algorithm of fast_log.
	8/1/2000	implemented hypot.
	8/8/2000	implemented fast_ceil and fast_floor.
	8/21/2000	implemented 3 fast hyperbolic functions.


TODO:
	Fix up arc-tangent quality.

--*/

#if !defined(SDK_HEADER_FASTMATH)
#define SDK_HEADER_FASTMATH


#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include "xmmintrin.h"
#include "math.h"

//------------------------------------------------------------------------------
#define PI              3.14159265358979323846f             // Pi
#define PI_MUL_2        6.28318530717958623200f             // 2 * Pi
#define PI_DIV_2        1.57079632679489655800f             // Pi / 2
#define PI_DIV_4        0.78539816339744827900f             // Pi / 4
#define INV_PI          0.31830988618379069122f             // 1 / Pi
#define DEGTORAD        0.01745329251994329547f             // Degrees to Radians
#define RADTODEG        57.29577951308232286465f            // Radians to Degrees
#define FLOAT_SMALL     1.0e-6f                             // Small number for floats
#define FLOAT_HUGE      1.0e+38f                            // Huge number for floats
#define FLOAT_EPSILON   1.0e-5f                             // Tolerance for floats
#define FLOAT_INFINITY  ((float)3.40282346638528860e+38)    // Infinity value for float


//----------------------------------------------------------------------------
// Flaoting point manipulation macros, used by the inline functions below.
#define FP_BITS(fp) (*(DWORD *)&(fp))
#define FP_ABS_BITS(fp) (FP_BITS(fp)&0x7FFFFFFF)
#define FP_SIGN_BIT(fp) (FP_BITS(fp)&0x80000000)
#define FP_ONE_BITS     0x3F800000
#define FP_HALFH        0x3f000000
#define FP_EXP_BITS     0x7f800000
#define FP_SMAN_BITS    0x807fffff

//----------------------------------------------------------------------------
// Define a C structure to hold a pair of floats.
struct SinCosPair
{
    float   fCos;
    float   fSin;
};


//----------------------------------------------------------------------------
extern float fast_atan(float x);
extern float fast_atan2(float x, float y);
extern float fast_acos(float x);
extern float fast_asin(float x);
extern float fast_log(float x);
extern float fast_log10(float x);
extern float fast_exp(float x);
extern float fast_sqrt(float x);
extern float fast_inversesqrt(float x);
extern float fast_fabs(float x);
extern void fast_sincos(float x, SinCosPair* v);
extern float fast_sin(float x);
extern float fast_cos(float x);
extern float fast_tan(float x);
extern float fast_pow(float x, float y);

extern float fast_hypot(float x, float y);
extern float fast_ceil(float x);
extern float fast_floor(float x);
extern float fast_tanh(float x);
extern float fast_cosh(float x);
extern float fast_sinh(float x);

#endif //SDK_HEADER_FASTMATH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\defines.h ===
//
//	defines.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __DEFINES_H__
#define __DEFINES_H__


//#define FINAL_BUILD



const float DEMO_TOTAL_TIME = 8.0f;
const float FINAL_HOLD_TIME	= 2.0f;
const float FINISH_TRANSITION_TIME = 0.8f;

#define TEXT_ANIM_START_TIME                (DEMO_TOTAL_TIME - FINAL_HOLD_TIME - 0.1f)
const float TEXT_ANIM_LEN = 0.25f;


const float BLOB_STATIC_END_TIME = 0.6f;
#define OO_BLOB_STATIC_END_TIME				(1.0f / BLOB_STATIC_END_TIME)
#define BLOB_ZERO_INTENSE_END_TIME			(BLOB_STATIC_END_TIME + 0.5f)
const float BLOB_BASE_INTENSITY = 0.3f;

#define FINISH_START_TIME					(DEMO_TOTAL_TIME - FINAL_HOLD_TIME - FINISH_TRANSITION_TIME)
#define FINISH_STOP_TIME					(DEMO_TOTAL_TIME - FINAL_HOLD_TIME)
#define OO_FINISH_DELTA						(1.0f / FINISH_TRANSITION_TIME)

#define MAX_INTENSITY_TIME					(FINISH_START_TIME - 0.0f)
#define MAX_INTENSITY_DELTA					(MAX_INTENSITY_TIME - BLOB_ZERO_INTENSE_END_TIME)
#define OO_MAX_INTENSITY_DELTA				(1.0f / MAX_INTENSITY_DELTA)
const float DEMO_START_INTENSITY = 0.0f;


// For timing the blob pulses.
#define BLOB_PULSE_START					(BLOB_STATIC_END_TIME)
#define BLOB_PULSE_END						(FINISH_STOP_TIME - 0.4f)
#define BLOB_PULSE_ELAPSED					(BLOB_PULSE_END - BLOB_PULSE_START)

#define BLOB_JITTER_START					(BLOB_STATIC_END_TIME)
#define BLOB_JITTER_DELTA					(FINISH_START_TIME)
#define OO_BLOB_JITTER_DELTA				(1.0f / BLOB_JITTER_DELTA)


const float SCENE_ANIM_LEN = 4.5f;
#define SCENE_ANIM_START_TIME				(BLOB_STATIC_END_TIME + 0.25f)


const float START_PUSHOUT_RADIUS = 0.0f;
const float PUSHOUT_START_TIME = 0.5f;
const float PUSHOUT_DELTA = 2.7f;
#define OO_PUSHOUT_DELTA					(1.0f / PUSHOUT_DELTA)


#define SHIELD_FADE_IN_START_TIME			(BLOB_STATIC_END_TIME)
const float SHIELD_FADE_IN_DELTA = 1.2f;
#define OO_SHIELD_FADE_IN_DELTA				(1.0f / SHIELD_FADE_IN_DELTA)
#define SHIELD_FADE_OUT_START_TIME			(FINISH_START_TIME - 0.1f)
#define SHIELD_FADE_OUT_DELTA				(FINISH_TRANSITION_TIME * 0.2f)
#define OO_SHIELD_FADE_OUT_DELTA			(1.0f / SHIELD_FADE_OUT_DELTA)


#define GLOW_FADE_CIRCLE_START				(FINISH_START_TIME - 0.5f)
#define GLOW_FADE_CIRCLE_MUL				(1.0f / 0.3f)

#define GLOW_FADE_SCREEN_START				(GLOW_FADE_CIRCLE_START + 0.3f)
#define GLOW_FADE_SCREEN_MUL				(1.0f / 0.25f)


#define SLASH_GRADIENT_TRANSITION_START		(FINISH_START_TIME - 0.5f)
//MTS#define SLASH_GRADIENT_TRANSITION_END		(FINISH_STOP_TIME + 0.75f)
#define SLASH_GRADIENT_TRANSITION_END		(FINISH_STOP_TIME)
#define SLASH_GRADIENT_TRANSITION_MUL		(1.0f / (SLASH_GRADIENT_TRANSITION_END - SLASH_GRADIENT_TRANSITION_START))

#define SCENE_LO_DETAIL_START               (FINISH_START_TIME)

#ifdef STARTUPANIMATION
#define FINAL_BUILD
#endif // STARTUPANIMATION




#ifndef FINAL_BUILD

#define INCLUDE_PLACEMENT_DOODAD
//#define INCLUDE_INPUT

#endif






#endif // __DEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\camera.h ===
//
//	camera.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __CAMERA_H__
#define __CAMERA_H__

#include "xbs_math.h"

///////////////////////////////////////////////////////////////////////////////
class Camera
{
protected:

	

	D3DVECTOR4   clipPlanes[4];
	bool         bClipPlanesSet;
	float        fNearPlane;
	float        fFarPlane;
	float		 fAspectRatio;

	bool         bWTPValid;

	float        fTime;

	D3DVECTOR    vPos;
	D3DVECTOR    vLook;
	D3DVECTOR    vUp;

	D3DMATRIX    matWTP;

public:

	D3DMATRIX    matCTW;
	D3DMATRIX    matWTC;
	D3DMATRIX    matProj;


	void Init();
	void UnInit();

	void lookAt(const D3DVECTOR &cam_pos, const D3DVECTOR &look_pt, const D3DVECTOR &up);
	void setProjection(float fov_in_y, float aspect, float near_plane, float far_plane);
	void setCTW(const D3DMATRIX &ctw);
	void setWTC(const D3DMATRIX &wtc);
	void translate(const D3DVECTOR &relative_vector);

	bool sphereVisCheck(const D3DVECTOR &pos, float r);
	void updateClipPlanes();

	float getPixelScaleForZ(float z) const ;
	D3DMATRIX & getWTP();
	void		getCameraPos (D3DVECTOR* p_pos)		const	{ *p_pos = vPos; }
	void		getCameraLook(D3DVECTOR* p_look)	const	{ *p_look= vLook; }
	float		getFarPlane()						const	{ return fFarPlane; }
	float		getAspectRatio()					const	{ return fAspectRatio; }
};
#endif // __BS_CAMERA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\GLOBALS.C ===
#include "sos.h"
#include "error.h"
#include "protos.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")


#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

struct	process	*  process_queue;		/* pointer to process queue 	*/
struct sound	*  current_call;		/* pointer to current sound call*/
struct process *  current_process;	/* pointer to current s. proc 	*/

struct	fifo fifo;			/* sound call fifo		*/

struct	track_info	*  ti;   	/* global pointer to current track info*/
 ushort		value_16_bit;	/* value to pass to asm routine */

short 		system_clock_music ;/* global music system timer     	*/
uchar		system_clock_mlow;  /* for 3 byte clocks		*/
short 		system_clock_fx; /* global fx system timer	    	*/
uchar		system_clock_fxlow; /* for 3-byte clocks	*/
uchar 		clock_cntr[2];	/* clock count-downer		*/
uchar 		clock_cntr_value[2];	/* clock count-downer reset val	*/
uchar		clock_cntr_save;	/* save value of clock count-downer */
ushort 		global_music_xpose;	/* master transposition for mus	*/
ushort		global_effect_xpose;	/* master transposition for f/x	*/
uchar		a_value;		/* byte for register a data 	*/
uchar		b_value;		/* byte for register b data 	*/
uchar		master_music_volume;	/* main attenuation for music	*/
uchar		master_effect_volume;	/* main attenuation for f/x	*/
uchar		music_atten;		/* music attenuation control */

uchar		marker;					/* tune transition marker	*/
uchar		current_level;		/* global level of current process */
uchar		current_channel;	/* global chan of current process */


ushort		dp_word1;			/* temp var */

uchar		gtifbtmp;			/* temp var for get_info_block */
uchar		last_music_call;	/* last music call made		*/
uchar		current_timer_priority;	/* priority of last timer call */
uchar		sos_only;			/* 1 to loop forever, 0 to return */
uchar		sound_call_table;	/* which soundtable are we on ?*/
ushort		global_fxpose;		/* global transpose value */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\EXTERNS.H ===
/*************************************************************************
*                                                                        *
* 	External Variables						  *
*                                                                        *
*************************************************************************/
#define _base_

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")


#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

extern		struct process	* _base_ process_queue;		/* pointer to process queue */
extern		struct sound	* _base_ current_call;		/* pointer to current sound call */
extern		struct sound	sound_calls[];
extern		struct sound	sound_calls2[];				/* alternate sound call table */
extern		struct process 	* _base_ current_process;	/* pointer to current s. proc */
extern		struct fifo	fifo;

extern		_base_ uchar hcount;			/* counter for oki nmi		*/
extern		_base_ uchar voice_state;		/* current nmi voice state	*/
extern		uchar * _base_ voice_data_pointer;	/* pointer to cur. voice data	*/
extern		uchar * _base_ voice_data_end;	/* pointer to end of v data	*/

extern		_base_ uchar 	a_value;		/* byte for register a data */
extern		_base_ uchar 	b_value;		/* byte for register b data */
extern		struct track_info * _base_ ti;/* global pointer to current track info*/
extern		_base_ ushort 	value_16_bit;		/* tmp value for passing */


extern _base_ short 		system_clock_music ;/* global music system timer     	*/
extern _base_ uchar		system_clock_mlow;  /* for 3 byte clocks		*/
extern _base_ short 		system_clock_fx; /* global fx system timer	    	*/
extern _base_ uchar		system_clock_fxlow; /* for 3-byte clocks	*/

extern		_base_ uchar 	clock_cntr[2];		/* timer count-downer	*/
extern		_base_ uchar 	clock_cntr_value[2];	/* timer count-downer	*/
extern		_base_ uchar	clock_cntr_save;	/* save val of clock cntr */
extern 	_base_ uchar 	master_music_volume;	/* main attenuation for music	*/
extern 	_base_ uchar 	master_effect_volume;	/* main attenuation for f/x	*/
extern		_base_ uchar	music_atten;		/* music attenuateion */
extern 	_base_ uchar 	master_music_amd;	/* main amp mod depth for music	*/
extern 	_base_ uchar 	master_effect_amd;	/* main amp mod depth for effect*/
extern 	_base_ uchar 	master_music_pmd;	/* main phase mod depth/music	*/
extern 	_base_ uchar 	master_effect_pmd;	/* main phase mod depth/effect	*/
extern		_base_ uchar 	marker;
extern		_base_ uchar	current_level;		/* global level of current process */
extern		_base_ uchar	current_channel;	/* global chan of current process */

extern	_base_	ushort		int_vars[12];		/* variables 2-byte */
extern	_base_ uchar		byte_vars[12];		/* variables 1-byte */

extern	_base_	uchar		dp_byte1;			/* temp var */
extern	_base_	uchar		dp_byte2;			/* temp var */
extern	_base_	uchar		dp_byte3;			/* temp var */
extern	_base_	uchar		dp_byte4;			/* temp var */
extern	_base_	uchar		dp_byte5;			/* temp var */
extern	_base_	ushort		dp_word1;			/* temp var */
extern	_base_	ushort		dp_word2;			/* temp var */
extern	_base_	ushort		dp_word3;			/* temp var */
extern	_base_	ushort		dp_word4;			/* temp var */
extern	_base_	ushort		dp_word5;			/* temp var */
extern	_base_ uchar		last_music_call;	/* last music call made		*/
extern _base_ uchar 	current_timer_priority;	/* priority of last timer call */
extern	uchar		music_timer_status[]; 
extern _base_ uchar	sos_only;
extern _base_ uchar		sound_call_table;	/* which soundtable are we on ?*/
extern	ushort		global_fxpose;		/* global transpose value */

extern	uchar		channel_level[];	/* current level for each chan*/
extern	struct track_info track_status[];
extern	struct process 	queue_list[]; 	/* pre-allocated process packets */


extern	const uchar	max_tracks;				/* from dev.c		*/
extern	void	do_watchdog(void);			/* from dev.c		*/
extern			dtimer_int();			/* from dev.c		*/
extern			etimer_int();			/* from dev.c		*/
extern			send_dev_function();	/* from dev.c		*/
extern	int	(*silence_functions[])();	/* from dev.c		*/
extern	int	(*note_on_functions[])();	/* from dev.c 		*/
extern	int	(*slur_functions[])();		/* from dev.c 		*/
extern	int	(*note_off_functions[])();	/* from dev.c		*/
extern	int	(*patch_functions[])();		/* from dev.c		*/
extern	int	(*volume_functions[])();   	/* from dev.c		*/
extern	int	(*pan_functions[])();		/* from dev.c		*/
extern	int	(*filter_functions[])();	/* from dev.c		*/
extern	int	dev_init();					/* from dev.c		*/
extern  int dev_cleanup();              /* from dev.c       */

extern	int	(*user_1_var_evf_functions[])();		/* from dev.c		*/
extern	int	(*user_2_var_evf_functions[])();		/* from dev.c		*/
extern	int   user_silence_function();				/* from dev.c		*/
extern int signal_function();			/* from dev.c */


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\DEV.C ===
/*************************************************************************
*                                                                        *
*   This file contains the tables and definitions for                 *
*   the synthesis specific DEVice                                     *
*      The device tables are in devtab.c                                  *
**************************************************************************
*
*   The following variables and tables must be defined:
*
*   max_tracks:     1 byte, max # of synthesis channels
*   dev_init:       function called to initialize device
*   do_watchdog     function called to  kick watchdog timer
*   dtimer_int      function called to  disable timer interrupt
*   etimer_int      function called to  enable timer interrupt
*   send_dev_function:
*       function called to send a byte of data to the synthesis
*       device (sound call callable)
*       The data is in the global, "a_value" and the address is
*       in the global, "b_value."
**************************************************************************/

#define _base_

extern  struct DSPpatch *Patches[];
extern  unsigned short  Noise8192[];

#include    <dsound.h>
#include "sosdsp.h"
#include "sos.h"
#include "bootsnd.h"
#include    <xtl.h>
#include "dsptables.h"

#define MAX_BUFFERS 16

#ifdef STARTUPANIMATION
#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif

LPDIRECTSOUND8          m_pDSound;                          // DirectSound object
LPDIRECTSOUNDBUFFER8    m_pDSBuffer[MAX_BUFFERS];           // DirectSoundBuffer
extern WCHAR    StringBuffer[];

#define MIN(a,b) (((signed) a) < ((signed) b) ? (a) : (b))

/*
 *  track_status has the necessary items to restore the state of
 *  a track after a track of a higher level on the same channel
 *  ends
 */

#define MAX_TRACKS  16
#define MAX_PROCESSES       30
#define MAX_LEVELS      2

uchar       channel_level[MAX_TRACKS];/* current level for each chan*/
struct track_info track_status[(MAX_LEVELS) * MAX_TRACKS];
struct process queue_list[MAX_PROCESSES]; /* pre-allocated process packets */
extern      struct sound    * _base_ current_call;      /* pointer to current sound call */
extern  uchar   sound_call_table;


const   unsigned short  max_processes = MAX_PROCESSES;

extern          uchar       a_value, b_value;
unsigned int    dsp_address;
unsigned int    dsp_data;   
extern  ushort      value_16_bit;
extern  uchar   current_channel;
extern  uchar       master_music_volume;    /* main attenuation for music   */
extern  uchar       master_effect_volume;   /* main attenuation for f/x */
extern  uchar       music_atten;            /* music attenuation */
extern  uchar   init_call;
extern  uchar   current_level;      /* global level of current process */
extern  struct  track_info  * _base_ ti;    /* track info pointer */
extern  uchar   pan_table[];                    /* panning table (8-bit) */
void    put_dsp(void);
extern  reset_dsp();
void    init_dsp(void);
void    put_fifo(unsigned char);
const   unsigned char   max_tracks = MAX_TRACKS;

extern void (* const call_fcns[])();

int volume_dsp(uchar, uchar, uchar *,uchar);
int silence_dsp(uchar);
int note_on_dsp();
int slur_dsp();
int note_off_dsp();
int patch_dsp(unsigned short);
int pan_dsp(uchar , signed char, uchar *);
int vp_filter();



int (* const filter_functions[])() = {
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter   
};


int (* const silence_functions[])() = {
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    
};

/**************************************************************************
*                                                                        *
*   The note_on functions turn a note on.  They assume that           *
*   the global, "a_value" has the current channel # and that          *
*   the global "value_16_bit" has the 16 bit pitch (iiiiiiii.ffffffff *
*      and "b_value" has the integer part of the pitch                    *
*************************************************************************/
int (* const note_on_functions[])() = {
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
};



int (* const slur_functions[])() = {
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
};


/*************************************************************************
*                                                                        *
*   The note_off functions turn a note off.  They assume that         *
*   the global, "a_value" has the current channel.                    *
*************************************************************************/
int (* const note_off_functions[])() = {
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
};
int (* const patch_functions[]) () = {
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,

};


int (* const volume_functions[])() = {
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,

};
int (* const pan_functions[])() = {
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,

};


int (* const user_1_var_evf_functions[])() = {
    pan_dsp
};
int (* const user_2_var_evf_functions[])() = {
    pan_dsp
};

//
// write data from global var dsp_data to x memory space "dsp_address"
//

void put_dsp()
{

//  LPVOID pvXramBuffer;
//  pvXramBuffer = (LPVOID) (dsp_address);

//    memcpy(pvXramBuffer,pvData,dwDataSize);

//  *(PDWORD) (GPXMEM + dsp_address) = dsp_data;
    
}


WriteDSPDatablock
(
    DWORD                   dwDSPAddress, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize
)
{
    LPVOID pvXramBuffer;

        //
        // poke directly the XRAM offset
        //

    pvXramBuffer = (LPVOID) (GPXMEM + dwDSPAddress);
    memcpy(pvXramBuffer,pvData,dwDataSize);

 
    return 1;

}

ReadDSPDatablock
(
    DWORD                   dwDSPAddress, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPVOID pvXramBuffer;
    //
    // copy fx data
    //
    pvXramBuffer = (LPVOID) (GPXMEM + dwDSPAddress);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return 1;
}

ReadDSPProgblock
(
    DWORD                   dwDSPAddress, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPVOID pvXramBuffer;
    //
    // copy fx data
    //
    pvXramBuffer = (LPVOID) (GPPMEM + dwDSPAddress);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return 1;
}

// return dsp data
int get_dsp(unsigned int addr)
{
//  return( (*PDWORD) (GPXMEM + dsp_address) );
    return(1);
}

silence_dsp(unsigned char chan)
{

    return(1);
}   


note_on_dsp()
{
    DWORD   dwFreq;
    struct DSPpatch *addr;

#if DBG

//  dwFreq = pitch_table_dsp[value_16_bit>>8];
//  swprintf( StringBuffer, L"Current Pitch: 0x%x", dwFreq);

#endif

    dwFreq = (DWORD) ( ((value_16_bit >> 8) - 60) * (4096/12) );
    dwFreq += ((((DWORD) value_16_bit & 0xff) * 341) / 255);
//  IDirectSoundBuffer_StopEx(m_pDSBuffer[current_channel], 0, DSBSTOPEX_ENVELOPE);
    IDirectSoundBuffer_SetPitch(m_pDSBuffer[current_channel], dwFreq);

    addr = Patches[ti->patch];
    if (addr->LoopEnable) 
        IDirectSoundBuffer_Play(m_pDSBuffer[current_channel], 0,0,DSBPLAY_LOOPING);
    else
        IDirectSoundBuffer_Play(m_pDSBuffer[current_channel], 0,0,0);

    return(1);

}
slur_dsp()
{
    DWORD   dwFreq;

    dwFreq = (DWORD) ( ((value_16_bit >> 8) - 60) * (4096/12) );
    dwFreq += ((((DWORD) value_16_bit & 0xff) * 341) / 255);

#if DBG
//  swprintf( StringBuffer, L"Current Pitch Slur: 0x%x", dwFreq);
#endif

    IDirectSoundBuffer_SetPitch(m_pDSBuffer[current_channel], dwFreq);

    return(1);
}

note_off_dsp()
{
    IDirectSoundBuffer_StopEx(m_pDSBuffer[current_channel], 0, DSBSTOPEX_ENVELOPE);
    return(1);

}

vp_filter()
{
    DSFILTERDESC    fdesc;


    fdesc.dwMode = DSFILTER_MODE_DLS2;
    fdesc.dwQCoefficient = 0;
    fdesc.adwCoefficients[0] = ti->filtercutoff + 32768;
    fdesc.adwCoefficients[1] = ti->filterres;
    fdesc.adwCoefficients[2] = ti->filtercutoff + 32768;
    fdesc.adwCoefficients[3] = ti->filterres;
    IDirectSoundBuffer_SetFilter(m_pDSBuffer[current_channel], &fdesc);
    return(1);
}



patch_dsp(unsigned short pat)
{
    struct DSPpatch *addr;

    addr = Patches[pat];

    IDirectSoundBuffer_SetEG(m_pDSBuffer[current_channel], addr->lpAmpEnvelope);
    IDirectSoundBuffer_SetEG(m_pDSBuffer[current_channel], addr->lpMultiEnvelope);
    IDirectSoundBuffer_SetBufferData(m_pDSBuffer[current_channel], addr->Start, addr->Length );
    IDirectSoundBuffer_SetLoopRegion( m_pDSBuffer[current_channel],0, addr->Length );
    IDirectSoundBuffer_SetCurrentPosition(m_pDSBuffer[current_channel], 0 );
    
    return(1);
}



pan_dsp(uchar chan, signed char pan, uchar *patch)
{
    uchar   mod;
    unsigned int    vol_mul;
    unsigned int    tmp;
    char            tmp_pan;

    vol_mul = 0x7fff;
    if (current_level >= 1) {           
/*      mod = master_effect_volume;*/
//      vol_mul = volume_table_dsp[master_music_volume];
    }
    else {
/*      mod = 0;*/
//      tmp = volume_table_dsp[music_atten];
//      vol_mul = volume_table_dsp[master_music_volume];

//      vol_mul = (long)((long)tmp * (long)vol_mul) >>15;
    
    }

    mod = 0;

    tmp_pan = ti->pan >> 3;

    tmp_pan += 16;                      /* set range 0 - 31 */
    tmp = 1;    
//  tmp = volume_table_dsp[MIN(127,ti->volume + mod)];
    tmp = (long)((long)tmp * (long)vol_mul) >>15;

/*  tmp >>= 7;*/
    dsp_data = (long) ((long)tmp * (long)pan_table[tmp_pan]) >> 7;
/*  dsp_data = (char)tmp * pan_table[tmp_pan];*/
//  a_value = VOLUME_L_ADDRESS(chan);
    put_dsp();

    dsp_data = (long) ((long)tmp * (long)pan_table[31 - tmp_pan]) >> 7;
/*  dsp_data = (char)tmp * pan_table[31 - tmp_pan];*/
//  a_value = VOLUME_R_ADDRESS(chan);
    put_dsp();

    return(1);

}


// initialize stuff for the dsp.
// write sine wave into high x memory.
// also create 16 dsound buffers that we'll use
// for our sounds.


static long holdrand = 1L;

void __cdecl srand(unsigned int seed)
{
    holdrand = (long)seed;
}

int __cdecl rand(void)
{
    return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}

dev_init()
{
    
    DSBUFFERDESC dsbdesc;
    WAVEFORMATEX wfFirst;
//    DWORD       dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FXSEND_0;
    DSMIXBINS    dsmb;
    DSMIXBINVOLUMEPAIR dsvp[3];
    long        lVolumes[3];
    int j;
    double  dtmp;
    double  FMc = 4.0;
    double  FMm = 2.0;


    int i;

    srand(1003);
    for (i = 0; i < 8192; i++) {
        Noise8192[i] = (unsigned short) rand();
    }

    for (i = 0; i < 128; i++) {
        Sin128[i] = (unsigned short)(32767*sin(2.0*3.14159*(double)i/128.0));
    }
    j = 0;
    for (i = 0; i < 32768; i++) {
        if (i < 16384)
            j++;
        else
            j--;
        dtmp = (double)j/16384.0  * sin(FMm * 2.0*3.14159*(double)i/128.0);
        FM32768[i] = (unsigned short)(32767*sin(dtmp + FMc * 2.0*3.14159*(double)i/128.0));
    }

    for (i = 0; i < 128; i++) {         // create sawtooth wave
        Saw128[i] = (unsigned short) (65536 * ((float)(i-64) /128.0));
    }

    for (i = 0; i < 0x5540; i++) {      // size of glock sound..make 16-bit
        ThunEl16[i] = (ThunEl16Data[i]) << 8;
    }
    for (i = 0,j=0x5540; i < 0x5540; i++,j--) {     // size of glock sound..make 16-bit
        ReverseThunEl16[i] = ThunEl16[j];
    }

    

    for (i = 0; i < 3768; i++) {        // size of glock sound..make 16-bit
        Glock[i] = (GlockData[i]^0x80) << 8;
    }
        
    for (i = 0; i < 6719; i++) {        // size of glock sound..make 16-bit
        Bubble[i] = (BubbleData[i]^0x80) << 8;
    }


    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return (0);


    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    wfFirst.wFormatTag = WAVE_FORMAT_PCM;
    wfFirst.nChannels = 1;
    wfFirst.nSamplesPerSec = 48000;
    wfFirst.wBitsPerSample = 16;
    wfFirst.nBlockAlign = wfFirst.nChannels * wfFirst.wBitsPerSample/8;
    wfFirst.nAvgBytesPerSec = wfFirst.nSamplesPerSec * wfFirst.nBlockAlign;

    dsbdesc.dwFlags = 0;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = &wfFirst;
//    dsbdesc.dwMixBinMask = dwMixBinMask;
    dsbdesc.lpMixBins = &dsmb;

    dsmb.lpMixBinVolumePairs = dsvp;

    for (i = 0; i < MAX_BUFFERS; i++) {


        if (i%2) {
//        lVolumes[0] = -600;
//        lVolumes[1] = 0;
//        lVolumes[2] = -2800;
//        dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;  
//            dsbdesc.dwMixBinMask = dwMixBinMask;        
        dsmb.dwMixBinCount = 2;
        dsvp[0].dwMixBin = DSMIXBIN_FRONT_LEFT;
        dsvp[0].lVolume = -600;
        dsvp[1].dwMixBin = DSMIXBIN_FRONT_RIGHT;
        dsvp[1].lVolume = 0;
        }
        else {
//        lVolumes[0] = 0;
//        lVolumes[1] = -600;
//        lVolumes[2] = -2800;
//        dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;  
//            dsbdesc.dwMixBinMask = dwMixBinMask;    
        dsmb.dwMixBinCount = 2;
        dsvp[0].dwMixBin = DSMIXBIN_FRONT_LEFT;
        dsvp[0].lVolume = 0;
        dsvp[1].dwMixBin = DSMIXBIN_FRONT_RIGHT;
        dsvp[1].lVolume = -600;
        }
        if ((i == 3) || (i == 5)) {
//        lVolumes[0] = 0;
//        lVolumes[1] = -100;
//        lVolumes[2] = 00;
//        dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FXSEND_0;
//            dsbdesc.dwMixBinMask = dwMixBinMask;
        dsmb.dwMixBinCount = 3;
        dsvp[0].dwMixBin = DSMIXBIN_FRONT_LEFT;
        dsvp[0].lVolume = 0;
        dsvp[1].dwMixBin = DSMIXBIN_FRONT_RIGHT;
        dsvp[1].lVolume = -100;
        dsvp[2].dwMixBin = DSMIXBIN_FXSEND_0;
        dsvp[2].lVolume = 0;
        }

            if( FAILED( DirectSoundCreateBuffer( &dsbdesc, &m_pDSBuffer[i]) ) )
                return E_FAIL;

//            IDirectSoundBuffer_SetMixBinVolumes(m_pDSBuffer[i], dwMixBinMask, lVolumes);
            IDirectSoundBuffer_SetMixBinVolumes(m_pDSBuffer[i], &dsmb);
    }

//  ReadDSPDatablock(0xa00*4, databack, sizeof(databack) );

     put_fifo(0x1);
     return(1);
}
//
// free dsound buffers and dsound object we created
//
dev_cleanup()
{
    int i;

    for (i = 0; i < MAX_BUFFERS; i++) {
        IDirectSoundBuffer_Release(m_pDSBuffer[i]);
    }
    IDirectSound_Release(m_pDSound);

}


do_watchdog()
{
}
dtimer_int()
{
}
etimer_int()
{
}
send_dev_function()
{
}
/*************************************************************************
*                                                                        *
*   Adjust the volume of that patch, "patch_addr" on channel,     *
*   "chan" by the amount volume + whatever the global volume is   *
*   for "level"                           *
*                                                                        *
*************************************************************************/

volume_dsp(
uchar op_level, 
uchar sound_level,
uchar *patch_addr,
uchar   chan)
{

    IDirectSoundBuffer_SetVolume(m_pDSBuffer[current_channel], (-1*op_level*30) + 200);
    return(1);
}

call_user_function()
{

}

extern  f_end();


user_silence_function()
{
#if DBG
//  swprintf( StringBuffer, L"Current Sound: %S", "SilenceFunction");
#endif
}

uchar pan_table[] = {
    1,2,3,4,5,6,7,8
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\logo_renderer.h ===
///////////////////////////////////////////////////////////////////////////////
// File: logo_renderer.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef __LOGO_RENDERER_H__
#define __LOGO_RENDERER_H__

class LogoRenderer
{
private:

	LPDIRECT3DVERTEXBUFFER8  pLipVB;
	WORD                    *pLipIndices;
	DWORD					 nLipVerts;
	DWORD					 nLipIndices;		
	LPDIRECT3DTEXTURE8       pLipTex;

	LPDIRECT3DVERTEXBUFFER8  pSurfaceVB;
	WORD					*pSurfaceIndices;
	DWORD					 nSurfaceVerts;
	DWORD					 nSurfaceIndices;
	LPDIRECT3DTEXTURE8       pSurfaceTex;
	

	LPDIRECT3DVERTEXBUFFER8  pSurfaceTopVB;
	WORD					*pSurfaceTopIndices;
	DWORD					 nSurfaceTopVerts;
	DWORD					 nSurfaceTopIndices;
	LPDIRECT3DTEXTURE8       pSurfaceTopTex;

	LPDIRECT3DVERTEXBUFFER8  pInteriorVB;
	WORD					*pInteriorIndices;
	DWORD					 nInteriorVerts;
	DWORD					 nInteriorIndices;

	bool					 bRenderText;

	LPDIRECT3DVERTEXBUFFER8  pText_VB;
	WORD					*pText_Indices;
	DWORD					 nText_Verts;
	DWORD					 nText_Indices;
	D3DMATRIX				 matText_Anim;

	LPDIRECT3DVERTEXBUFFER8  pSlashTM_VB;
	WORD					*pSlashTM_Indices;
	DWORD					 nSlashTM_Verts;
	DWORD					 nSlashTM_Indices;

	LPDIRECT3DVERTEXBUFFER8  pTextTM_VB;
	WORD					*pTextTM_Indices;
	DWORD					 nTextTM_Verts;
	DWORD					 nTextTM_Indices;

	LPDIRECT3DTEXTURE8       pTMTex;
	float					 fTMAlpha;

	DWORD					 dwInteriorPShader;
	DWORD					 dwInteriorVShader;

	void createSlash();
	void createText();
	void createTMs();


	LPDIRECT3DTEXTURE8		pSlashTexture;
	bool					bHasWordmark;
	void createSlashSurface();	// don't call until camera is in final position


	// Decompressed slash data.
	WORD		* indices_xboxlogolip_0;
	float		* verts_xboxlogolip_0;
	WORD		* indices_xboxlogosurface_0;
	float		* verts_xboxlogosurface_0;
	WORD		* indices_xboxlogosurfacetop_0;
	float	    * verts_xboxlogosurfacetop_0;
	WORD        * indices_xboxlogointerior_0;
	float		* verts_xboxlogointerior_0;
	WORD		* indices_tm_wordmark_0;
	float		* verts_tm_wordmark_0;
	WORD		* indices_tm_slash_0;
	float		* verts_tm_slash_0;

	// Decompressed wordmark data.
	WORD		* indices_text_0;
	float		* verts_text_0;
	
	void decompressData();

	float * decompressPosData(short *pdata,int ncount,float f_oo_pos_scale,float f_pos_delta );
	float * decompressPosTexData(short *pdata,int ncount,float f_oo_pos_scale,float f_pos_delta,
														 float f_oo_tex_scale,float f_tex_delta );
	WORD  * decompressIndexData(char *pdata,int ncount);

public:

	void create();
	void destroy();

	void advanceTime(float fElapsedTime, float fDt);
	void render(const D3DMATRIX &mat_otw, bool b_force_3d_render = false);
};

#endif // __LOGO_RENDERER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\Macros.h ===
#define	F_NOTE	1
#define	F_REST	0
#define	F_JUMPTO	2
#define	F_LOOP	3
#define	F_ENDLOOP	4
#define	F_PATCH	5
#define	F_PAN	6
#define	F_MUX	7
#define	F_DEMUX	8
#define	F_VOLUME	9
#define	F_XPOSE	10
#define	F_XSET	11
#define	F_SLUR	12
#define	F_RING	13
#define	F_CLOCKSET	14
#define	F_END	15

#define	F_FILTERINC	16
#define	F_FILTERSET	17



#define	note(pitch,dur)	F_NOTE,pitch,dur
#define	rest(dur)		F_REST,dur
#define	jumpto(label)	F_JUMPTO,label
#define	loop(n)			F_LOOP,n
#define	endloop			F_ENDLOOP
#define	patch(num)		F_PATCH,num
#define	pan(value)		F_PAN,value
#define	mux(label)		F_MUX,label
#define	demux			F_DEMUX
#define	volume(val)		F_VOLUME,val
#define	xpose(val)		F_XPOSE,val
#define	xset(val)		F_XSET,val
#define	slur(pitch,dur)	F_SLUR,pitch,dur
#define	ring(dur)		F_RING,dur
#define	clockset(val)	F_CLOCKSET,val
#define	sosend			F_END
#define	finc(f,res)		F_FILTERINC,f,res
#define	fset(f,res)		F_FILTERSET,f,res
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\mslogo.cpp ===
#ifdef STARTUPANIMATION

#include "ntos.h"

#include "precomp.h"
#include "mslogo.h"
#include "renderer.h"
#include "xbs_app.h"
#include "xbs_math.h"

#pragma pack(1)

typedef struct _IMAGE_RUN1 {
    UINT fOne : 1;
    UINT Size : 3;
    UINT Intensity : 4;
} IMAGE_RUN1;

typedef struct _IMAGE_RUN2 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 10;
    UINT Intensity : 4;
} IMAGE_RUN2;

#pragma pack()

// MS Logo sync event
extern "C" {
INITIALIZED_KEVENT(g_EventLogo, NotificationEvent, FALSE);
INITIALIZED_KEVENT(g_EventLogoWaiting, NotificationEvent, FALSE);
}

IDirect3DVertexBuffer8 *g_pVBMicrosoftLogo;
IDirect3DTexture8* g_pTexMicrosoftLogo;
PBYTE g_ImageLogo;
UINT g_ImageLogoSize;

typedef struct _TheVerts {
    float x,y,z,w;
    float u, v;
} TheVerts;

const TheVerts Verts[] =
{
    {270.0f,  400.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    {370.0f,  417.0f, 0.5f, 1.0f, 100.0f,  17.0f},
    {270.0f,  417.0f, 0.5f, 1.0f,   0.0f,  17.0f},
    {370.0f,  400.0f, 0.5f, 1.0f, 100.0f,   0.0f},
    {370.0f,  417.0f, 0.5f, 1.0f, 100.0f,  17.0f},
    {270.0f,  400.0f, 0.5f, 1.0f,   0.0f,   0.0f},
};

BOOL InitVB(IDirect3DDevice8 *pDev)
{
    IDirect3DVertexBuffer8 *pVB;
    void *pVerts;

    if (FAILED(IDirect3DDevice8_CreateVertexBuffer(pDev,
            sizeof(Verts),
            D3DUSAGE_WRITEONLY,
            D3DFVF_XYZRHW | D3DFVF_TEX1,
            D3DPOOL_MANAGED,
            &pVB)))
    {
        return FALSE;
    }

    g_pVBMicrosoftLogo = pVB;

    IDirect3DVertexBuffer8_Lock(pVB, 0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof(Verts));
    IDirect3DVertexBuffer8_Unlock(pVB);

    return TRUE;
}

const float F_15 = 15.0f;
const float F_P_5 = 0.5f;

COLORREF ColorFromIntensity(UINT intensity4bits)
{
    UINT Base = 0xCC;

    UINT cr = (UINT)((Base * intensity4bits) / F_15 + F_P_5);

    return D3DCOLOR_ARGB(0xFF, cr, cr, cr);
}

BOOL InitTexture(IDirect3DDevice8 *pDev)
{
    IDirect3DTexture8* pTex;
    D3DLOCKED_RECT lock;
    UINT x = 0, i, j;
    DWORD dwLine;
    DWORD dwAddr;
    IMAGE_RUN1 *pRun1;
    IMAGE_RUN2 *pRun2;
    UINT Size;
    UINT Intensity;

    if (FAILED(IDirect3DDevice8_CreateTexture(pDev,
            100,
            17,
            1,
            0,
            D3DFMT_LIN_X8R8G8B8,
            0,
            &pTex)))
    {
        return FALSE;
    }

    g_pTexMicrosoftLogo = pTex;

    IDirect3DTexture8_LockRect(pTex, 0, &lock, NULL, 0);
    dwLine = (DWORD)lock.pBits;
    dwAddr = dwLine;
    i = 0;

    while(i < g_ImageLogoSize)
    {
        Size = 0;
        Intensity = 0;

        pRun1 = (IMAGE_RUN1*)&g_ImageLogo[i];
        if (pRun1->fOne)
        {
            Size = pRun1->Size;
            Intensity = pRun1->Intensity;
            i += 1;
        }
        else
        {
            pRun2 = (IMAGE_RUN2*)&g_ImageLogo[i];
            if (pRun2->fTwo)
            {
                Size = pRun2->Size;
                Intensity = pRun2->Intensity;
                i += 2;
            }
        }

        for (j = 0; j < Size; j++)
        {
            if (Intensity == 0)
            {
                *(DWORD*)dwAddr = 0xFF000000;
            }
            else
            {
                *(DWORD*)dwAddr = ColorFromIntensity(Intensity);
            }
            if (x >= 99)
            {
                x = 0;
                dwLine += lock.Pitch;
                dwAddr = dwLine;
            }
            else
            {
                x++;
                dwAddr += sizeof(DWORD);
            }
        }
    }

    IDirect3DTexture8_UnlockRect(pTex, 0);

    return TRUE;
}

void UnInitMicrosoftLogo()
{
    if (g_ImageLogo != NULL)
    {
        MemFree(g_ImageLogo);
    }

    if (g_pVBMicrosoftLogo != NULL)
    {
        g_pVBMicrosoftLogo->Release();
    }

    if (g_pTexMicrosoftLogo != NULL)
    {
        g_pTexMicrosoftLogo->Release();
    }
}

void RenderMicrosoftLogo()
{
    if (g_ImageLogo == NULL)
    {
        return;
    }

    if (!InitVB(gpd3dDev) || !InitTexture(gpd3dDev))
    {
        UnInitMicrosoftLogo();
        return;
    }

    IDirect3DDevice8 *pDev = gpd3dDev;
    IDirect3DSurface8 *pSurface;
    pDev->GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pSurface);
    pDev->SetRenderTarget(pSurface, NULL);

    const DWORD RenderStates[] =
    {
        D3DRS_FILLMODE,         D3DFILL_SOLID,
        D3DRS_BACKFILLMODE,     D3DFILL_SOLID,
        D3DRS_CULLMODE,         D3DCULL_NONE,
        D3DRS_DITHERENABLE,     TRUE,
        D3DRS_ALPHATESTENABLE,  FALSE,
        D3DRS_ALPHABLENDENABLE, FALSE,
        D3DRS_FOGENABLE,        FALSE,
        D3DRS_EDGEANTIALIAS,    FALSE,
        D3DRS_STENCILENABLE,    FALSE,
        D3DRS_LIGHTING,         FALSE,
        D3DRS_MULTISAMPLEMASK,  0xffffffff,
        D3DRS_LOGICOP,          D3DLOGICOP_NONE,
        D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL,
        D3DRS_YUVENABLE,        FALSE,
    };
    
    const DWORD TextureStates[] =
    {
        D3DTSS_COLOROP,         D3DTOP_SELECTARG1,
        D3DTSS_COLORARG1,       D3DTA_TEXTURE,
        D3DTSS_ALPHAOP,         D3DTOP_DISABLE,
        D3DTSS_TEXCOORDINDEX,   0,
        D3DTSS_ADDRESSU,        D3DTADDRESS_CLAMP,
        D3DTSS_ADDRESSV,        D3DTADDRESS_CLAMP,
        D3DTSS_COLORKEYOP,      D3DTCOLORKEYOP_DISABLE,
        D3DTSS_COLORSIGN,       0,
        D3DTSS_ALPHAKILL,       D3DTALPHAKILL_DISABLE,
        D3DTSS_MINFILTER,       D3DTEXF_LINEAR,
        D3DTSS_MAGFILTER,       D3DTEXF_LINEAR,
    };

    int i;

    for (i = 0; i < sizeof(RenderStates) / (sizeof(DWORD) * 2); i++)
    {
        pDev->SetRenderState((D3DRENDERSTATETYPE)RenderStates[2*i],
                RenderStates[2*i + 1]);
    }

    for (i = 0; i < sizeof(TextureStates) / (sizeof(DWORD) * 2); i++)
    {
        pDev->SetTextureStageState(0,
                (D3DTEXTURESTAGESTATETYPE)TextureStates[2*i],
                TextureStates[2*i + 1]);
    }

    IDirect3DDevice8_SetStreamSource(pDev, 0, g_pVBMicrosoftLogo, sizeof(Verts[0]));
    IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_TEX1);
    IDirect3DDevice8_SetTexture(pDev, 0, (D3DBaseTexture*)g_pTexMicrosoftLogo);

    IDirect3DDevice8_DrawPrimitive(pDev,
            D3DPT_TRIANGLELIST,
            0,
            2);

    pSurface->Release();
    UnInitMicrosoftLogo();
    pDev->PersistDisplay();
}

extern "C"
VOID AniSetLogo(PVOID pv, ULONG Size)
{
    if (KeReadStateEvent(&g_EventLogo) == 0)
    {
        if (gpd3dDev != NULL && pv != NULL && Size <= PAGE_SIZE)
        {
            g_ImageLogo = (PBYTE)MemAlloc(Size);
            if (g_ImageLogo != NULL)
            {
                memcpy(g_ImageLogo, pv, Size);
                g_ImageLogoSize = Size;
            }
        }

        KeSetEvent(&g_EventLogo, EVENT_INCREMENT, FALSE);
    }
}

void WaitOnMicrosoftLogo()
{
    // Signal the initialization thread that we're waiting for the logo.  Note
    // that this returns with the dispatcher database lock held, which the
    // following wait call will release.  This avoids an unnecessary context
    // switch.
    KeSetEvent(&g_EventLogoWaiting, EVENT_INCREMENT, TRUE);

    KeWaitForSingleObject(&g_EventLogo, Executive, KernelMode, FALSE, NULL);
    RenderMicrosoftLogo();
}

#endif // STARTUPANIMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\FTABLES.H ===
/*************************************************************************
*                                                                        *
* 	Function tables for event functions and sound call functions	  *
*                                                                        *
*************************************************************************/

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

extern int	f_note(void);
extern int	f_rest(void);
extern int	f_jumpto(void);
extern int	f_loop(void);
extern int	f_endloop(void);
extern int	f_patch(void);
extern	int	f_pan(void);
extern	int	f_mux(void);
extern	int	f_demux(void);
extern	int	f_volume(void);
extern	int	f_xpose(void);
extern	int	f_xset(void);
extern	int	f_slur(void);
extern	int	f_ring(void);
extern	int	f_clockset(void);
extern	int	f_end(void);
extern	int	f_filterset(void);
extern	int	f_filterinc(void);


extern	int	f_mark(void);
extern	int	f_sound_call(void);
extern	int	f_srest(void);
extern	int	f_intvarset(void);
extern	int	f_intvarinc(void);
extern	int	f_user_1_var_evf(void);
extern	int	f_user_2_var_evf(void);
extern int f_sig(void);
extern	int	f_gliss(void);
extern	int	f_clockinc(void);
extern	int	f_paninc(void);
extern int f_musicclockinc(void);
extern	int	f_MidiNoteOn(void);
extern	int	f_MidiNoteOff(void);
extern	int	f_MidiProgram(void);
extern	int	f_MidiVolume(void);
extern	int	f_MidiTempo(void);
extern	int	f_MidiControl(void);
extern	int	f_MidiEOT(void);

extern	int	f_fxset(void);

extern void	call_silence(void);
extern void	call_music(void);
extern void	call_effect(void);
extern	void	call_volume(void);
extern	void	call_senddev(void);
extern	void	call_mark(void);
extern	void	call_ignore(void);
extern	void	call_user_function(void);
extern	void	call_timer(void);
extern	void	call_end_timer(void);
extern void	call_play_timer(void);
extern void call_kill_effect(void);

int	(* const event_fcns[])() = {
	f_rest,				//0
	f_note,				//1
	f_jumpto,			//2
	f_loop,				//3
	f_endloop,			//4
	f_patch,			//5
	f_pan,				//6
	f_mux,				//7
	f_demux,			//8
	f_volume,			//9
	f_xpose,			//10
	f_xset,				//11
	f_slur,				//12
	f_ring,				//13
	f_clockset,			//14
	f_end,				//15
	f_filterinc,		//16
	f_filterset,		//17
	f_gliss,			//18

	f_mark,
	f_sound_call,
	f_srest,
	f_intvarset,
	f_intvarinc,
	f_user_1_var_evf,
	f_user_2_var_evf,
	f_sig,

	f_clockinc,
	f_paninc,
	f_musicclockinc,
	f_MidiNoteOn,	/* 35 */
	f_MidiNoteOff,	/* 36 */
	f_MidiProgram,	/* 37 */
	f_MidiVolume,	/* 38 */
	f_MidiTempo,	/* 39 */
	f_MidiControl,	/* 40 */
	f_MidiEOT,		/* 41 */
	f_fxset,


};

/*
 *	NOTE:
 *	call music is used for BOTH forground sounds and background music
 *	This is becuase the code is essentially the same so it saves space
 */


void	(* const call_fcns[])() = {
	call_silence,		/* 0 sound call type 0 (silence)*/
	call_music,			/* 1 sound call type 1 (music)  */
	call_effect,		/* 2 sound call type 2 (effect) */
	call_volume, 		/* 3 sound call type 3 (volume) */
	call_ignore,  		/* 4 formerly call_oki	*/
	call_senddev,		/* 5 send data directly to yamaha chip */
	call_mark,			/* 6 leave a marker				*/
	call_ignore,		/* 7 ignore sound call		*/
	call_user_function,	/* 8 user defined function 	*/
	call_timer,			/* 9 make a music timer call	*/
	call_end_timer,		/* 10 stop timer, go back to prev back music */
	call_play_timer,		/* 11 sound table entry for timer */
	call_kill_effect	/* 12 kill all forground fx		*/
};
	

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\EVF.C ===
/*************************************************************************
*                                                                        *
* 	Here live the event functions					  *
*                                                                        *
*************************************************************************/
#include	"sos.h"
#include	"protos.h"
#include	"externs.h"

#define	c_p 	current_process		/* shorthand */


ushort	* ptr;				/* pointer to cur. voice data	*/


unsigned short	un_int;
uchar			un_char;

int	f_MidiNoteOn()
{
	return(1);
}
int	f_MidiNoteOff()
{
	return(1);
}
int	f_MidiProgram()
{
	return(1);
}
int	f_MidiVolume()
{
	return(1);
}
int	f_MidiTempo()
{
	return(1);
}
int	f_MidiControl()
{
	return(1);
}
int	f_MidiEOT()
{
	return(1);
}


int f_note()
{
	ptr = ++current_process->mem_ptr.i;	/* get past func byte */
	b_value = (uchar) *(ushort *)ptr++; 		/* point to delay */
	if (b_value	& 0x80) {			/* 1 byte duration */
		dp_word1 = *(uchar *) ptr;
		b_value &= 0x7f;
	}
	else {

	dp_word1 = *(unsigned short *)ptr++;

	}
	current_process->function = *(ptr);
	current_process->mem_ptr.i = ptr;
	current_process->timer += dp_word1;
	ti->pitch = value_16_bit = (b_value << 8) + ti->transpose;
	if (current_level == LEVEL_EFFECT) {
		ti->pitch += global_fxpose;
	}
/*		ti->pitch += global_fxpose;*/
		value_16_bit = ti->pitch;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	note_on_functions[current_channel]();
	return(1);
}

f_gliss()
{
#ifdef GLISS
/*#ifdef	BIGOS*/
	uchar	*tmp_ptr;

	tmp_ptr = c_p->mem_ptr.c++;
	if (c_p->type == 0) {		/* first time						*/
		c_p->type = 1;			/* set not first time flag			*/
		c_p->data1 = *c_p->mem_ptr.i++;		/* get base pitch	*/
		c_p->mem_ptr.i++;					/* pass delta		*/
		c_p->data2 = *c_p->mem_ptr.i;		/* get counter		*/
		c_p->mem_ptr.c = tmp_ptr;		
	}
	else {
		if (c_p->data2-- == 0) {
			c_p->mem_ptr.c = tmp_ptr + 7;		/* point to xtra time	*/
			c_p->type = 0;
			c_p->timer += *c_p->mem_ptr.i++;	/* get xtra time*/
			c_p->data1 += *c_p->mem_ptr.i++;		/* get xtra frac	*/
			c_p->function = *c_p->mem_ptr.c;

		}
		else {
			c_p->data1 += *(++c_p->mem_ptr.i);
			c_p->timer += 4;
			c_p->mem_ptr.c = tmp_ptr;			/* point back to us	*/
	    }
		ti->pitch = value_16_bit = c_p->data1 + ti->transpose;
		if (current_level < channel_level[current_channel]) 
		    return(1);
		slur_functions[current_channel]();
	}		
	return(1);
#endif
	return(1);
}

int f_rest()
{
/*	unsigned int	del;*/

	ptr = ++current_process->mem_ptr.i;
	un_int  = *(unsigned short *)ptr++;
	current_process->function = *ptr;
	current_process->timer += un_int;
	current_process->mem_ptr.i = ptr;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	note_off_functions[current_channel]();
	return(1);
}



int f_srest()
{

	return(1);
}

int f_jumpto()
{

/*	uchar	*addr;*/

	current_process->mem_ptr.i++;		/* get past func byte */
	ptr = *(ushort **)current_process->mem_ptr.i++;  /* point to next func */
	current_process->mem_ptr.i = ptr;
	current_process->function = *ptr;	/* get function */
	return(1);
}

int f_loop()
{
	ti->loop_counter[ti->loop_level] = *(++c_p->mem_ptr.i);
	ti->loop_addr[(ti->loop_level)++] = (ushort *) ++c_p->mem_ptr.i;
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}

int f_endloop()
{
	if (--(ti->loop_counter[ti->loop_level-1]) != 0) {
	  c_p->mem_ptr.i = (ushort *)ti->loop_addr[ti->loop_level-1];
	}
	else {					/* done looping */
	    c_p->mem_ptr.i++;
	    ti->loop_level--;
	}
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}



int f_patch()
{
	ushort	pat;

    ptr = ++current_process->mem_ptr.i;		/* get past func byte */
	pat = *(ushort *)ptr++;  /* point to patch # */
	current_process->function = *(ptr);
	current_process->mem_ptr.i = ptr;
	ti->patch = pat;
	ti->pan = ti->volume = 0;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	patch_functions[current_channel](pat);
	return(1);
}

int f_pan()
{
      	ptr = ++current_process->mem_ptr.i;		  /* get past func byte */
	a_value = *(uchar *)ptr++; /* point to pan */
	current_process->function = *ptr;
	current_process->mem_ptr.i = ptr;
	ti->pan = a_value;
	if (current_level < channel_level[current_channel]) 
	    return(1);
	pan_functions[current_channel](current_channel,a_value,ti->patch);
	return(1);
}
int f_paninc()
{
/*#ifdef	BIGOS */
      	ptr = ++current_process->mem_ptr.i;		  /* get past func byte */
	a_value = *(char *)ptr++; /* point to pan */
	current_process->function = *ptr;
	current_process->mem_ptr.i = ptr;
	ti->pan += (signed char) a_value;
	if (current_level < channel_level[current_channel]) 
	    return(1);
	pan_functions[current_channel](current_channel,ti->pan,ti->patch);
	return(1);
/*#endif*/
}



int f_mux()
{
	ti->mux_addr[(ti->mux_level)++] = (ushort *) (++c_p->mem_ptr.c + 2);
	c_p->mem_ptr.c = (uchar *)*(ushort *)(c_p->mem_ptr.c);
	c_p->function = *c_p->mem_ptr.c;
	return(1);
}
int f_demux()
{
/*	uchar	tmp;*/

	un_char = --(ti->mux_level);
	c_p->mem_ptr.c = (uchar *)ti->mux_addr[un_char];
	c_p->function = *c_p->mem_ptr.c;
	return(1);
}

int f_volume()
{
	un_char = ti->volume + *(short *)++current_process->mem_ptr.i; /* point to vol */
	current_process->function = *++current_process->mem_ptr.i;
	ti->volume = un_char;
	if (current_level < channel_level[current_channel]) 
	    return(1);
	volume_functions[current_channel](un_char,current_level,ti->patch,current_channel);
	return(1);
}



int f_fxset()
{
	c_p->mem_ptr.c++;
	global_fxpose = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.c;
	return(1);
}


int f_xpose()
{
	c_p->mem_ptr.i++;
	ti->transpose += *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}

int f_xset()
{
	c_p->mem_ptr.i++;
	ti->transpose = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}


int f_filterinc()
{
	c_p->mem_ptr.i++;
	ti->filtercutoff += *c_p->mem_ptr.i++;
	ti->filterres = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	filter_functions[current_channel]();
	return(1);
}

int f_filterset()
{
	c_p->mem_ptr.i++;
	ti->filtercutoff = *c_p->mem_ptr.i++;
	ti->filterres = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	filter_functions[current_channel]();
	return(1);
}


int f_slur()
{
/*	unsigned int	del;*/

	ptr = ++current_process->mem_ptr.i;	/* get past func byte */
	b_value = (uchar) *(ushort *)ptr++; 		/* point to delay */
	if (b_value	& 0x80) {			/* 1 byte duration */
		dp_word1 = *(uchar *) ptr;
		b_value &= 0x7f;
	}
	else {

	dp_word1 = *(unsigned short *)ptr++;

	}
	current_process->function = *(ptr);
	current_process->mem_ptr.i = ptr;
	current_process->timer += dp_word1;
	ti->pitch = value_16_bit = (b_value << 8) + ti->transpose;
	if (current_level == LEVEL_EFFECT) {
		ti->pitch += global_fxpose;
	}
/*		ti->pitch += global_fxpose;*/
		value_16_bit = ti->pitch;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	slur_functions[current_channel]();
	return(1);
	//

}


int f_ring()
{

	ptr = ++current_process->mem_ptr.i;
	un_int = *(unsigned short *)ptr++;
	current_process->function = *ptr;
	current_process->timer += un_int;
	current_process->mem_ptr.i = ptr;
	return(1);
}


f_clockset()
{
	current_process->mem_ptr.c++;		/* get past func byte */
	clock_cntr_value[c_p->level] = *(uchar *)current_process->mem_ptr.c++;/* point to next func */
	current_process->function = *current_process->mem_ptr.c;
	return(1);
}

f_clockinc()
{
	return(1);
}


f_musicclockinc()
{
	return(1);
}



/*************************************************************************
*                                                                        *
* 	Used to end a track of music or a sound effect			  *
*                                                                        *
*************************************************************************/

int f_end()
{
/*	un_char = c_p->hard_channel;*/
//	nosound(current_channel);
//	ti = get_music_info_block();
//	remove_processes_by_level_and_channel(LEVEL_EFFECT,current_channel);
//	channel_level[current_channel] = LEVEL_MUSIC;
//	current_level = LEVEL_MUSIC;
//	if (ti->patch == NULL)
//		return(0);
//	ptr = ti->patch;
//	patch_functions[current_channel](ptr);
//	pan_functions[current_channel](current_channel,ti->pan,ptr);
//	volume_functions[current_channel](ti->volume,current_level,ptr,current_channel);
	return(0);
}


	







int f_mark()
{
#ifdef	BIGOS
	uchar	m_value;
	uchar	dest;
	
	c_p->mem_ptr.c++;
	m_value = *c_p->mem_ptr.c++;	/* get marker # */
	dest =  *c_p->mem_ptr.c++;	/* get destination */
	c_p->function = *c_p->mem_ptr.c;
	if (m_value == marker) {
		DINT;
		put_fifo(dest);
		EINT;
		marker = 0;
	}
#endif
	return(1);
}


int f_sound_call()
{
/*#ifdef	BIGOS*/
	uchar	dest;
	
	c_p->mem_ptr.c++;
	dest =  *c_p->mem_ptr.c++;	/* get destination */
	c_p->function = *c_p->mem_ptr.c;
/*	DINT;*/
	put_fifo(dest);
/*	EINT;*/
	return(1);
/*#endif*/
}

int f_intvarset()
{
#ifdef	BIGOS
	uchar	index;
	c_p->mem_ptr.c++;
	index = *c_p->mem_ptr.c++;
	int_vars[index] = *(ushort *)c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.c;
	return(1);
#endif
	return(1);
}
int f_intvarinc()
{
#ifdef	BIGOS
	uchar	index;
	c_p->mem_ptr.c++;
	index = *c_p->mem_ptr.c++;
	int_vars[index] += *(char *)c_p->mem_ptr.c++;
	c_p->function = *c_p->mem_ptr.c;
	return(1);
#endif
	return(1);
}



int f_user_1_var_evf()
{
/*#ifdef	BIGOS*/

	a_value = *(++c_p->mem_ptr.c);		/* get parameter in a_value */
	c_p->function = *++c_p->mem_ptr.c;
	user_1_var_evf_functions[current_channel]();
	return(1);
/*#endif*/
}
int f_user_2_var_evf()
{
	a_value = *(++c_p->mem_ptr.c);		/* get parameter in a_value */
	b_value = *(++c_p->mem_ptr.c);		/* get 2nd parameter in b_value */
	c_p->function = *++c_p->mem_ptr.c;
	user_2_var_evf_functions[current_channel]();
	return(1);

}


f_sig()
{
	a_value = *(++c_p->mem_ptr.c);		/* get parameter in a_value */
	c_p->function = *++c_p->mem_ptr.c;
//	signal_function();
	return(1);
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\GreenFog.h ===
///////////////////////////////////////////////////////////////////////////////
// File: GreenFog.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef GREENFOG_H
#define GREENFOG_H



class GreenFog
{
public:
	void Init();
	void UnInit() { destroy(); }

	
	void create();
	void destroy();

	void advanceTime(float fElapsedTime, float fDt);

	void render(bool b_cmp_to_one);

	void restart();


	LPDIRECT3DVERTEXBUFFER8 borrowScreenQuad() { return pQuadVB; }

protected:
	enum { NUM_PLASMAS = 3 };
	LPDIRECT3DVERTEXBUFFER8		pQuadVB;
	LPDIRECT3DVERTEXBUFFER8		pIntensityQuadVB;
	LPDIRECT3DTEXTURE8			pPlasmaTexture[NUM_PLASMAS];
	LPDIRECT3DTEXTURE8			pIntensityTextureR;		// for rendering (swapped in render)
	LPDIRECT3DTEXTURE8			pIntensityTextureU;		// for updating
	LPDIRECT3DSURFACE8			pIntensityZ;

	DWORD		dwFogPShader, dwFogVShader;


	void renderIntensityTexture();
};
///////////////////////////////////////////////////////////////////////////////
struct GreenFogVertexBuffer
{
	D3DVECTOR	pos;
	FLOAT		tu0, tv0;	// texture coordinate in intensity lookup
	FLOAT		tu1, tv1;	// texture coordinate in plasma, which wraps
};



#endif // GREENFOG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\mslogo.h ===
#ifndef __MSLOGO_H__
#define __MSLOGO_H__

void WaitOnMicrosoftLogo();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\logo_geometry.h ===
/*

xbl.h

*/
#ifndef __xbl_h__
#define __xbl_h__

#include "d3d8types.h"

#define FVF_xbl D3DFVF_XYZ|D3DFVF_TEX1

struct xbl_vertex
{
	float x,y,z;
	float u0;
	float v0;
};


#define xbl_OO_POS_SCALE 0.009876f
#define xbl_POS_DELTA 161.715363f
#define xbl_OO_TEX_SCALE 0.000058f
#define xbl_TEX_DELTA 0.947661f


///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogointerior_0 = 501;
short verts_xboxlogointerior_0C[] = 
{
		-12386,-26498,-20838, //	x,y,z
		-14730,-203, //	u,v
		-12260,-26498,-20920, //	x,y,z
		-14871,-127, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-16049,-10475, //	u,v
		-12386,-26498,-20838, //	x,y,z
		-14730,-203, //	u,v
		-12845,-26498,-20558, //	x,y,z
		-14226,-477, //	u,v
		-7807,1871,-26421, //	x,y,z
		-10529,-261, //	u,v
		-12985,-26498,-20445, //	x,y,z
		-14057,-569, //	u,v
		-12845,-26498,-20558, //	x,y,z
		-14226,-477, //	u,v
		-13340,-29287,-19982, //	x,y,z
		-15380,-11167, //	u,v
		-12985,-26498,-20445, //	x,y,z
		-14057,-569, //	u,v
		-13493,-26498,-20080, //	x,y,z
		-13469,-888, //	u,v
		-9371,1871,-25156, //	x,y,z
		-8637,-1288, //	u,v
		-13640,-26498,-19948, //	x,y,z
		-13283,-989, //	u,v
		-13493,-26498,-20080, //	x,y,z
		-13469,-888, //	u,v
		-13898,-29287,-19581, //	x,y,z
		-14598,-11977, //	u,v
		-13640,-26498,-19948, //	x,y,z
		-13283,-989, //	u,v
		-14175,-26498,-19498, //	x,y,z
		-12626,-1346, //	u,v
		-11017,1871,-23682, //	x,y,z
		-6564,-2414, //	u,v
		-14323,-26498,-19360, //	x,y,z
		-12437,-1449, //	u,v
		-14175,-26498,-19498, //	x,y,z
		-12626,-1346, //	u,v
		-14485,-29287,-19087, //	x,y,z
		-13726,-12881, //	u,v
		-14323,-26498,-19360, //	x,y,z
		-12437,-1449, //	u,v
		-14859,-26498,-18900, //	x,y,z
		-11773,-1809, //	u,v
		-12666,1871,-22138, //	x,y,z
		-4448,-3563, //	u,v
		-14996,-26498,-18770, //	x,y,z
		-11596,-1905, //	u,v
		-14859,-26498,-18900, //	x,y,z
		-11773,-1809, //	u,v
		-15074,-29287,-18582, //	x,y,z
		-12844,-13793, //	u,v
		-14996,-26498,-18770, //	x,y,z
		-11596,-1905, //	u,v
		-15497,-26498,-18314, //	x,y,z
		-10961,-2250, //	u,v
		-14205,1871,-20682, //	x,y,z
		-2466,-4639, //	u,v
		-15612,-26498,-18208, //	x,y,z
		-10814,-2330, //	u,v
		-15624,-29287,-18082, //	x,y,z
		-12002,-14666, //	u,v
		-16030,-26498,-17821, //	x,y,z
		-10280,-2619, //	u,v
		-15493,1871,-19492, //	x,y,z
		-823,-5531, //	u,v
		-12678,-26498,-20424, //	x,y,z
		-14435,-7413, //	u,v
		-12793,-26498,-20278, //	x,y,z
		-14363,-7531, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15384,-8200, //	u,v
		-12678,-26498,-20424, //	x,y,z
		-14275,-451, //	u,v
		-12260,-26498,-20920, //	x,y,z
		-14871,-127, //	u,v
		-6396,1871,-27339, //	x,y,z
		-12110,596, //	u,v
		-13188,-26498,-19747, //	x,y,z
		-13507,-867, //	u,v
		-13297,-26498,-19592, //	x,y,z
		-13337,-960, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-14462,-12118, //	u,v
		-13188,-26498,-19747, //	x,y,z
		-13507,-867, //	u,v
		-12793,-26498,-20278, //	x,y,z
		-14105,-543, //	u,v
		-7683,1871,-25712, //	x,y,z
		-10218,-430, //	u,v
		-13674,-26498,-19048, //	x,y,z
		-12745,-1281, //	u,v
		-13778,-26498,-18889, //	x,y,z
		-12576,-1373, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-13675,-12933, //	u,v
		-13674,-26498,-19048, //	x,y,z
		-12745,-1281, //	u,v
		-8899,1871,-23976, //	x,y,z
		-8318,-1462, //	u,v
		-16113,-26498,-17741, //	x,y,z
		-10173,-2678, //	u,v
		-16030,-26498,-17821, //	x,y,z
		-10280,-2619, //	u,v
		-16083,-29287,-17657, //	x,y,z
		-11292,-15400, //	u,v
		-16113,-26498,-17741, //	x,y,z
		-10173,-2678, //	u,v
		-16411,-26498,-17468, //	x,y,z
		-9794,-2884, //	u,v
		-16411,1871,-18598, //	x,y,z
		373,-6181, //	u,v
		-16493,-26498,-17548, //	x,y,z
		-11372,-5060, //	u,v
		-16411,-26498,-17468, //	x,y,z
		-11290,-5173, //	u,v
		-16411,-29287,-17356, //	x,y,z
		-11563,-15959, //	u,v
		-16493,-26498,-17548, //	x,y,z
		-11372,-5060, //	u,v
		-16791,-26498,-17821, //	x,y,z
		-11663,-4659, //	u,v
		-17328,1871,-19492, //	x,y,z
		-1061,-5456, //	u,v
		-16906,-26498,-17927, //	x,y,z
		-11776,-4504, //	u,v
		-16738,-29287,-17657, //	x,y,z
		-11998,-15360, //	u,v
		-17325,-26498,-18314, //	x,y,z
		-12187,-3939, //	u,v
		-18616,1871,-20682, //	x,y,z
		-2446,-4556, //	u,v
		-17463,-26498,-18445, //	x,y,z
		-12323,-3751, //	u,v
		-17198,-29287,-18082, //	x,y,z
		-12611,-14516, //	u,v
		-17463,-26498,-18445, //	x,y,z
		-12323,-3751, //	u,v
		-17963,-26498,-18900, //	x,y,z
		-12810,-3080, //	u,v
		-20155,1871,-22138, //	x,y,z
		-4119,-3470, //	u,v
		-18110,-26498,-19038, //	x,y,z
		-12956,-2880, //	u,v
		-17963,-26498,-18900, //	x,y,z
		-12810,-3080, //	u,v
		-17747,-29287,-18582, //	x,y,z
		-13339,-13514, //	u,v
		-18110,-26498,-19038, //	x,y,z
		-12956,-2880, //	u,v
		-18647,-26498,-19498, //	x,y,z
		-13465,-2179, //	u,v
		-21805,1871,-23682, //	x,y,z
		-5903,-2311, //	u,v
		-18794,-26498,-19630, //	x,y,z
		-13608,-1983, //	u,v
		-18647,-26498,-19498, //	x,y,z
		-13465,-2179, //	u,v
		-18336,-29287,-19087, //	x,y,z
		-14100,-12467, //	u,v
		-18794,-26498,-19630, //	x,y,z
		-13608,-1983, //	u,v
		-19329,-26498,-20080, //	x,y,z
		-14112,-1289, //	u,v
		-23451,1871,-25156, //	x,y,z
		-7651,-1176, //	u,v
		-19469,-26498,-20193, //	x,y,z
		-14242,-1110, //	u,v
		-19329,-26498,-20080, //	x,y,z
		-14112,-1289, //	u,v
		-18924,-29287,-19581, //	x,y,z
		-14853,-11430, //	u,v
		-19469,-26498,-20193, //	x,y,z
		-14242,-1110, //	u,v
		-19977,-26498,-20558, //	x,y,z
		-14693,-489, //	u,v
		-25014,1871,-26421, //	x,y,z
		-9244,-141, //	u,v
		-20103,-26498,-20640, //	x,y,z
		-14801,-340, //	u,v
		-19977,-26498,-20558, //	x,y,z
		-14693,-489, //	u,v
		-19482,-29287,-19982, //	x,y,z
		-15526,-10503, //	u,v
		-20103,-26498,-20640, //	x,y,z
		-14801,-340, //	u,v
		-20562,-26498,-20920, //	x,y,z
		-15186,189, //	u,v
		-26426,1871,-27339, //	x,y,z
		-10572,720, //	u,v
		-20447,-26498,-20775, //	x,y,z
		-15056,9, //	u,v
		-20562,-26498,-20920, //	x,y,z
		-15186,189, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-16101,-9712, //	u,v
		-20447,-26498,-20775, //	x,y,z
		-15056,9, //	u,v
		-20028,-26498,-20278, //	x,y,z
		-14596,-623, //	u,v
		-25138,1871,-25712, //	x,y,z
		-8970,-319, //	u,v
		-19919,-26498,-20123, //	x,y,z
		-14464,-804, //	u,v
		-20028,-26498,-20278, //	x,y,z
		-14596,-623, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15414,-10658, //	u,v
		-19919,-26498,-20123, //	x,y,z
		-14464,-804, //	u,v
		-19524,-26498,-19592, //	x,y,z
		-14002,-1440, //	u,v
		-23923,1871,-23976, //	x,y,z
		-7358,-1366, //	u,v
		-19421,-26498,-19433, //	x,y,z
		-13872,-1620, //	u,v
		-19524,-26498,-19592, //	x,y,z
		-14002,-1440, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-14724,-11607, //	u,v
		-19421,-26498,-19433, //	x,y,z
		-13872,-1620, //	u,v
		-19044,-26498,-18889, //	x,y,z
		-13414,-2250, //	u,v
		-22764,1871,-22195, //	x,y,z
		-5759,-2404, //	u,v
		-14136,-26498,-18352, //	x,y,z
		-12002,-1685, //	u,v
		-14234,-26498,-18195, //	x,y,z
		-11839,-1773, //	u,v
		-14537,-29287,-17974, //	x,y,z
		-12912,-13723, //	u,v
		-14136,-26498,-18352, //	x,y,z
		-12002,-1685, //	u,v
		-10058,1871,-22195, //	x,y,z
		-6435,-2484, //	u,v
		-18945,-26498,-18731, //	x,y,z
		-13288,-2424, //	u,v
		-19044,-26498,-18889, //	x,y,z
		-13414,-2250, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-14041,-12548, //	u,v
		-18945,-26498,-18731, //	x,y,z
		-13288,-2424, //	u,v
		-18587,-26498,-18195, //	x,y,z
		-12843,-3035, //	u,v
		-21662,1871,-20439, //	x,y,z
		-4208,-3412, //	u,v
		-14568,-26498,-17685, //	x,y,z
		-11298,-2067, //	u,v
		-14660,-26498,-17536, //	x,y,z
		-11144,-2150, //	u,v
		-14903,-29287,-17415, //	x,y,z
		-12195,-14466, //	u,v
		-14568,-26498,-17685, //	x,y,z
		-11298,-2067, //	u,v
		-14234,-26498,-18195, //	x,y,z
		-11839,-1773, //	u,v
		-11160,1871,-20439, //	x,y,z
		-4608,-3476, //	u,v
		-18495,-26498,-18045, //	x,y,z
		-12724,-3199, //	u,v
		-18587,-26498,-18195, //	x,y,z
		-12843,-3035, //	u,v
		-18285,-29287,-17974, //	x,y,z
		-13377,-13461, //	u,v
		-18495,-26498,-18045, //	x,y,z
		-12724,-3199, //	u,v
		-18162,-26498,-17536, //	x,y,z
		-12306,-3774, //	u,v
		-20635,1871,-18772, //	x,y,z
		-2747,-4361, //	u,v
		-14957,-26498,-17076, //	x,y,z
		-10660,-2413, //	u,v
		-15038,-26498,-16941, //	x,y,z
		-10522,-2488, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-11551,-15132, //	u,v
		-14957,-26498,-17076, //	x,y,z
		-10660,-2413, //	u,v
		-14660,-26498,-17536, //	x,y,z
		-11144,-2150, //	u,v
		-12187,1871,-18772, //	x,y,z
		-2889,-4409, //	u,v
		-18080,-26498,-17401, //	x,y,z
		-12200,-3921, //	u,v
		-18162,-26498,-17536, //	x,y,z
		-12306,-3774, //	u,v
		-17919,-29287,-17415, //	x,y,z
		-12753,-14320, //	u,v
		-18080,-26498,-17401, //	x,y,z
		-12200,-3921, //	u,v
		-17783,-26498,-16941, //	x,y,z
		-11825,-4437, //	u,v
		-19722,1871,-17265, //	x,y,z
		-1436,-5212, //	u,v
		-15255,-26498,-16549, //	x,y,z
		-10137,-2697, //	u,v
		-15323,-26498,-16435, //	x,y,z
		-10020,-2761, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-11039,-15662, //	u,v
		-15255,-26498,-16549, //	x,y,z
		-10137,-2697, //	u,v
		-15038,-26498,-16941, //	x,y,z
		-10522,-2488, //	u,v
		-13099,1871,-17265, //	x,y,z
		-1346,-5247, //	u,v
		-15011,-26498,-16109, //	x,y,z
		-9545,-6003, //	u,v
		-14916,-26498,-16014, //	x,y,z
		-9611,-5890, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-14320,-16076, //	u,v
		-15011,-26498,-16109, //	x,y,z
		-9545,-6003, //	u,v
		-15323,-26498,-16435, //	x,y,z
		-9323,-6380, //	u,v
		-13863,1871,-15983, //	x,y,z
		-2130,429, //	u,v
		-14561,-26498,-15655, //	x,y,z
		-9861,-5466, //	u,v
		-14464,-26498,-15550, //	x,y,z
		-9931,-5347, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-14665,-15944, //	u,v
		-14561,-26498,-15655, //	x,y,z
		-9861,-5466, //	u,v
		-12806,1871,-14918, //	x,y,z
		-3592,442, //	u,v
		-14109,-26498,-15168, //	x,y,z
		-10187,-4912, //	u,v
		-14011,-26498,-15056, //	x,y,z
		-10259,-4790, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-15019,-15808, //	u,v
		-14109,-26498,-15168, //	x,y,z
		-10187,-4912, //	u,v
		-11713,1871,-13743, //	x,y,z
		-5143,455, //	u,v
		-13667,-26498,-14666, //	x,y,z
		-10512,-4360, //	u,v
		-13573,-26498,-14552, //	x,y,z
		-10584,-4238, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-15369,-15673, //	u,v
		-13667,-26498,-14666, //	x,y,z
		-10512,-4360, //	u,v
		-10620,1871,-12494, //	x,y,z
		-6734,469, //	u,v
		-13252,-26498,-14167, //	x,y,z
		-10826,-3827, //	u,v
		-13164,-26498,-14054, //	x,y,z
		-10894,-3711, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-15704,-15545, //	u,v
		-13252,-26498,-14167, //	x,y,z
		-10826,-3827, //	u,v
		-9563,1871,-11217, //	x,y,z
		-8310,483, //	u,v
		-12878,-26498,-13687, //	x,y,z
		-11117,-3334, //	u,v
		-12799,-26498,-13579, //	x,y,z
		-11180,-3227, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-16012,-15427, //	u,v
		-12878,-26498,-13687, //	x,y,z
		-11117,-3334, //	u,v
		-8577,1871,-9956, //	x,y,z
		-9818,496, //	u,v
		-12558,-26498,-13245, //	x,y,z
		-11374,-2898, //	u,v
		-12492,-26498,-13147, //	x,y,z
		-11429,-2804, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16280,-15324, //	u,v
		-12558,-26498,-13245, //	x,y,z
		-11374,-2898, //	u,v
		-7696,1871,-8755, //	x,y,z
		-11204,508, //	u,v
		-12823,-26498,-13403, //	x,y,z
		-11217,-3163, //	u,v
		-12914,-26498,-13477, //	x,y,z
		-11158,-3263, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-15988,-15436, //	u,v
		-12823,-26498,-13403, //	x,y,z
		-11217,-3163, //	u,v
		-12492,-26498,-13147, //	x,y,z
		-11429,-2804, //	u,v
		-6957,1872,-7660, //	x,y,z
		-12415,519, //	u,v
		-13334,-26498,-13761, //	x,y,z
		-10901,-3700, //	u,v
		-13449,-26498,-13845, //	x,y,z
		-10829,-3822, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-15633,-15572, //	u,v
		-13334,-26498,-13761, //	x,y,z
		-10901,-3700, //	u,v
		-12914,-26498,-13477, //	x,y,z
		-11158,-3263, //	u,v
		-7974,1871,-8497, //	x,y,z
		-11109,508, //	u,v
		-13927,-26498,-14137, //	x,y,z
		-10545,-4304, //	u,v
		-14058,-26498,-14223, //	x,y,z
		-10466,-4439, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-15240,-15723, //	u,v
		-13927,-26498,-14137, //	x,y,z
		-10545,-4304, //	u,v
		-13449,-26498,-13845, //	x,y,z
		-10829,-3822, //	u,v
		-9266,1871,-9427, //	x,y,z
		-9521,494, //	u,v
		-14561,-26498,-14505, //	x,y,z
		-10174,-4934, //	u,v
		-14699,-26498,-14588, //	x,y,z
		-10092,-5073, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-14836,-15878, //	u,v
		-14561,-26498,-14505, //	x,y,z
		-10174,-4934, //	u,v
		-14058,-26498,-14223, //	x,y,z
		-10466,-4439, //	u,v
		-10735,1871,-10384, //	x,y,z
		-7769,478, //	u,v
		-15196,-26498,-14840, //	x,y,z
		-9811,-5550, //	u,v
		-15333,-26498,-14913, //	x,y,z
		-9733,-5684, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-14447,-16027, //	u,v
		-15196,-26498,-14840, //	x,y,z
		-9811,-5550, //	u,v
		-14699,-26498,-14588, //	x,y,z
		-10092,-5073, //	u,v
		-12282,1871,-11308, //	x,y,z
		-5970,463, //	u,v
		-15790,-26498,-15116, //	x,y,z
		-9481,-6110, //	u,v
		-15917,-26498,-15176, //	x,y,z
		-9411,-6229, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-14100,-16161, //	u,v
		-15790,-26498,-15116, //	x,y,z
		-9481,-6110, //	u,v
		-15333,-26498,-14913, //	x,y,z
		-9733,-5684, //	u,v
		-13809,1871,-12133, //	x,y,z
		-4240,447, //	u,v
		-16304,-26498,-15310, //	x,y,z
		-9209,-6572, //	u,v
		-16411,-26498,-15349, //	x,y,z
		-9153,-6668, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-13820,-16268, //	u,v
		-16304,-26498,-15310, //	x,y,z
		-9209,-6572, //	u,v
		-15917,-26498,-15176, //	x,y,z
		-9411,-6229, //	u,v
		-15218,1871,-12796, //	x,y,z
		-2697,434, //	u,v
		-16798,-26498,-15215, //	x,y,z
		-12696,-8315, //	u,v
		-16904,-26498,-15176, //	x,y,z
		-12520,-8145, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-5988,-12294, //	u,v
		-16798,-26498,-15215, //	x,y,z
		-12696,-8315, //	u,v
		-16411,-26498,-15349, //	x,y,z
		-13329,-8926, //	u,v
		-16411,1871,-13235, //	x,y,z
		-15802,-6256, //	u,v
		-17361,-26498,-14973, //	x,y,z
		-11741,-7392, //	u,v
		-17486,-26498,-14913, //	x,y,z
		-11523,-7182, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-5179,-11513, //	u,v
		-17361,-26498,-14973, //	x,y,z
		-11741,-7392, //	u,v
		-16904,-26498,-15176, //	x,y,z
		-12520,-8145, //	u,v
		-17601,1871,-12796, //	x,y,z
		-15029,-5510, //	u,v
		-17981,-26498,-14661, //	x,y,z
		-10653,-6342, //	u,v
		-18117,-26498,-14588, //	x,y,z
		-10410,-6108, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-4277,-10641, //	u,v
		-17981,-26498,-14661, //	x,y,z
		-10653,-6342, //	u,v
		-17486,-26498,-14913, //	x,y,z
		-11523,-7182, //	u,v
		-19006,1871,-12133, //	x,y,z
		-14074,-4587, //	u,v
		-18619,-26498,-14306, //	x,y,z
		-9508,-5236, //	u,v
		-18757,-26498,-14223, //	x,y,z
		-9256,-4993, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-3341,-9737, //	u,v
		-18619,-26498,-14306, //	x,y,z
		-9508,-5236, //	u,v
		-18117,-26498,-14588, //	x,y,z
		-10410,-6108, //	u,v
		-20528,1871,-11308, //	x,y,z
		-13007,-3556, //	u,v
		-19234,-26498,-13930, //	x,y,z
		-8379,-4146, //	u,v
		-19366,-26498,-13845, //	x,y,z
		-8133,-3909, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-2431,-8859, //	u,v
		-19234,-26498,-13930, //	x,y,z
		-8379,-4146, //	u,v
		-22072,1871,-10384, //	x,y,z
		-11898,-2486, //	u,v
		-19787,-26498,-13561, //	x,y,z
		-7339,-3142, //	u,v
		-19903,-26498,-13477, //	x,y,z
		-7117,-2927, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-1608,-8064, //	u,v
		-19787,-26498,-13561, //	x,y,z
		-7339,-3142, //	u,v
		-19366,-26498,-13845, //	x,y,z
		-8133,-3909, //	u,v
		-23540,1871,-9427, //	x,y,z
		-10820,-1444, //	u,v
		-20237,-26498,-13222, //	x,y,z
		-6464,-2297, //	u,v
		-20329,-26498,-13147, //	x,y,z
		-6281,-2120, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-931,-7409, //	u,v
		-20237,-26498,-13222, //	x,y,z
		-6464,-2297, //	u,v
		-19903,-26498,-13477, //	x,y,z
		-7117,-2927, //	u,v
		-24837,1871,-8497, //	x,y,z
		-9843,-501, //	u,v
		-20093,-26498,-13478, //	x,y,z
		-6857,-2676, //	u,v
		-20028,-26498,-13574, //	x,y,z
		-7020,-2834, //	u,v
		-19526,-29286,-14049, //	x,y,z
		-1528,-7987, //	u,v
		-20093,-26498,-13478, //	x,y,z
		-6857,-2676, //	u,v
		-20329,-26498,-13147, //	x,y,z
		-6281,-2120, //	u,v
		-25865,1872,-7660, //	x,y,z
		-9038,276, //	u,v
		-19743,-26498,-13940, //	x,y,z
		-7689,-3480, //	u,v
		-19665,-26498,-14047, //	x,y,z
		-7878,-3662, //	u,v
		-19213,-29286,-14450, //	x,y,z
		-2222,-8657, //	u,v
		-19743,-26498,-13940, //	x,y,z
		-7689,-3480, //	u,v
		-20028,-26498,-13574, //	x,y,z
		-7020,-2834, //	u,v
		-25138,1871,-8742, //	x,y,z
		-9755,-415, //	u,v
		-19344,-26498,-14432, //	x,y,z
		-8612,-4371, //	u,v
		-19256,-26498,-14545, //	x,y,z
		-8819,-4571, //	u,v
		-18861,-29286,-14874, //	x,y,z
		-2983,-9392, //	u,v
		-19344,-26498,-14432, //	x,y,z
		-8612,-4371, //	u,v
		-19665,-26498,-14047, //	x,y,z
		-7878,-3662, //	u,v
		-24262,1871,-9938, //	x,y,z
		-10585,-1218, //	u,v
		-18911,-26498,-14937, //	x,y,z
		-9591,-5316, //	u,v
		-18816,-26498,-15051, //	x,y,z
		-9808,-5527, //	u,v
		-18482,-29287,-15304, //	x,y,z
		-3783,-10165, //	u,v
		-18911,-26498,-14937, //	x,y,z
		-9591,-5316, //	u,v
		-19256,-26498,-14545, //	x,y,z
		-8819,-4571, //	u,v
		-23275,1871,-11200, //	x,y,z
		-11496,-2097, //	u,v
		-18459,-26498,-15434, //	x,y,z
		-10590,-6281, //	u,v
		-18361,-26498,-15547, //	x,y,z
		-10810,-6494, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-4594,-10948, //	u,v
		-18459,-26498,-15434, //	x,y,z
		-10590,-6281, //	u,v
		-18816,-26498,-15051, //	x,y,z
		-9808,-5527, //	u,v
		-22213,1871,-12481, //	x,y,z
		-12452,-3021, //	u,v
		-18004,-26498,-15907, //	x,y,z
		-11574,-7232, //	u,v
		-17906,-26498,-16013, //	x,y,z
		-11789,-7440, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-5386,-11713, //	u,v
		-18004,-26498,-15907, //	x,y,z
		-11574,-7232, //	u,v
		-18361,-26498,-15547, //	x,y,z
		-10810,-6494, //	u,v
		-21115,1871,-13736, //	x,y,z
		-13420,-3956, //	u,v
		-17589,-26498,-16339, //	x,y,z
		-12472,-8099, //	u,v
		-17495,-26498,-16435, //	x,y,z
		-12675,-8295, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-6095,-12397, //	u,v
		-17906,-26498,-16013, //	x,y,z
		-11789,-7440, //	u,v
		-20018,1871,-14916, //	x,y,z
		-14366,-4869, //	u,v
		-17715,-26498,-16826, //	x,y,z
		-11734,-4561, //	u,v
		-17783,-26498,-16941, //	x,y,z
		-11825,-4437, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-12193,-15091, //	u,v
		-17715,-26498,-16826, //	x,y,z
		-11734,-4561, //	u,v
		-17495,-26498,-16435, //	x,y,z
		-11433,-4976, //	u,v
		-18959,1871,-15983, //	x,y,z
		-329,-5931, //	u,v
		-6396,1871,-27339, //	x,y,z
		-12110,596, //	u,v
		-7807,1871,-26421, //	x,y,z
		-10529,-261, //	u,v
		-13340,-29287,-19982, //	x,y,z
		-15380,-11167, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-16049,-10475, //	u,v
		-7807,1871,-26421, //	x,y,z
		-10529,-261, //	u,v
		-9371,1871,-25156, //	x,y,z
		-8637,-1288, //	u,v
		-13898,-29287,-19581, //	x,y,z
		-14598,-11977, //	u,v
		-13340,-29287,-19982, //	x,y,z
		-15380,-11167, //	u,v
		-9371,1871,-25156, //	x,y,z
		-8637,-1288, //	u,v
		-11017,1871,-23682, //	x,y,z
		-6564,-2414, //	u,v
		-14485,-29287,-19087, //	x,y,z
		-13726,-12881, //	u,v
		-13898,-29287,-19581, //	x,y,z
		-14598,-11977, //	u,v
		-11017,1871,-23682, //	x,y,z
		-6564,-2414, //	u,v
		-12666,1871,-22138, //	x,y,z
		-4448,-3563, //	u,v
		-15074,-29287,-18582, //	x,y,z
		-12844,-13793, //	u,v
		-14205,1871,-20682, //	x,y,z
		-2466,-4639, //	u,v
		-15074,-29287,-18582, //	x,y,z
		-12844,-13793, //	u,v
		-16083,-29287,-17657, //	x,y,z
		-11292,-15400, //	u,v
		-7683,1871,-25712, //	x,y,z
		-3982,-732, //	u,v
		-6396,1871,-27339, //	x,y,z
		-12110,596, //	u,v
		-7683,1871,-25712, //	x,y,z
		-10218,-430, //	u,v
		-12678,-26498,-20424, //	x,y,z
		-14275,-451, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-16049,-10475, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15256,-11296, //	u,v
		-7683,1871,-25712, //	x,y,z
		-10218,-430, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15256,-11296, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-14462,-12118, //	u,v
		-8899,1871,-23976, //	x,y,z
		-8318,-1462, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-13675,-12933, //	u,v
		-15493,1871,-19492, //	x,y,z
		-823,-5531, //	u,v
		-16411,1871,-18598, //	x,y,z
		373,-6181, //	u,v
		-16411,-29287,-17356, //	x,y,z
		-10789,-15922, //	u,v
		-16411,1871,-18598, //	x,y,z
		-50,-6112, //	u,v
		-17328,1871,-19492, //	x,y,z
		-1061,-5456, //	u,v
		-16411,-29287,-17356, //	x,y,z
		-11563,-15959, //	u,v
		-20155,1871,-22138, //	x,y,z
		-4119,-3470, //	u,v
		-17747,-29287,-18582, //	x,y,z
		-13339,-13514, //	u,v
		-17198,-29287,-18082, //	x,y,z
		-12611,-14516, //	u,v
		-21805,1871,-23682, //	x,y,z
		-5903,-2311, //	u,v
		-18336,-29287,-19087, //	x,y,z
		-14100,-12467, //	u,v
		-17747,-29287,-18582, //	x,y,z
		-13339,-13514, //	u,v
		-21805,1871,-23682, //	x,y,z
		-5903,-2311, //	u,v
		-23451,1871,-25156, //	x,y,z
		-7651,-1176, //	u,v
		-18924,-29287,-19581, //	x,y,z
		-14853,-11430, //	u,v
		-23451,1871,-25156, //	x,y,z
		-7651,-1176, //	u,v
		-25014,1871,-26421, //	x,y,z
		-9244,-141, //	u,v
		-19482,-29287,-19982, //	x,y,z
		-15526,-10503, //	u,v
		-18924,-29287,-19581, //	x,y,z
		-14853,-11430, //	u,v
		-25014,1871,-26421, //	x,y,z
		-9244,-141, //	u,v
		-26426,1871,-27339, //	x,y,z
		-10572,720, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-16101,-9712, //	u,v
		-19482,-29287,-19982, //	x,y,z
		-15526,-10503, //	u,v
		-26426,1871,-27339, //	x,y,z
		-10572,720, //	u,v
		-25138,1871,-25712, //	x,y,z
		-8970,-319, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15414,-10658, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-16101,-9712, //	u,v
		-25138,1871,-25712, //	x,y,z
		-8970,-319, //	u,v
		-23923,1871,-23976, //	x,y,z
		-7358,-1366, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-14724,-11607, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15414,-10658, //	u,v
		-23923,1871,-23976, //	x,y,z
		-7358,-1366, //	u,v
		-22764,1871,-22195, //	x,y,z
		-5759,-2404, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-14041,-12548, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-14724,-11607, //	u,v
		-11160,1871,-20439, //	x,y,z
		-4608,-3476, //	u,v
		-10058,1871,-22195, //	x,y,z
		-6435,-2484, //	u,v
		-14537,-29287,-17974, //	x,y,z
		-12912,-13723, //	u,v
		-22764,1871,-22195, //	x,y,z
		-5759,-2404, //	u,v
		-21662,1871,-20439, //	x,y,z
		-4208,-3412, //	u,v
		-18285,-29287,-17974, //	x,y,z
		-13377,-13461, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-14041,-12548, //	u,v
		-12187,1871,-18772, //	x,y,z
		-2889,-4409, //	u,v
		-14903,-29287,-17415, //	x,y,z
		-12195,-14466, //	u,v
		-20635,1871,-18772, //	x,y,z
		-2747,-4361, //	u,v
		-17919,-29287,-17415, //	x,y,z
		-12753,-14320, //	u,v
		-13099,1871,-17265, //	x,y,z
		-1346,-5247, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-11551,-15132, //	u,v
		-19722,1871,-17265, //	x,y,z
		-1436,-5212, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-12193,-15091, //	u,v
		-13863,1871,-15983, //	x,y,z
		-44,-5954, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-11551,-15132, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-11039,-15662, //	u,v
		-13863,1871,-15983, //	x,y,z
		-2130,429, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-14012,-16194, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-14320,-16076, //	u,v
		-12806,1871,-14918, //	x,y,z
		-3592,442, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-14665,-15944, //	u,v
		-11713,1871,-13743, //	x,y,z
		-5143,455, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-15019,-15808, //	u,v
		-10620,1871,-12494, //	x,y,z
		-6734,469, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-15369,-15673, //	u,v
		-9563,1871,-11217, //	x,y,z
		-8310,483, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-15704,-15545, //	u,v
		-8577,1871,-9956, //	x,y,z
		-9818,496, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-16012,-15427, //	u,v
		-6957,1872,-7660, //	x,y,z
		-12415,519, //	u,v
		-7696,1871,-8755, //	x,y,z
		-11204,508, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16280,-15324, //	u,v
		-7974,1871,-8497, //	x,y,z
		-11109,508, //	u,v
		-6957,1872,-7660, //	x,y,z
		-12415,519, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16280,-15324, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-15988,-15436, //	u,v
		-9266,1871,-9427, //	x,y,z
		-9521,494, //	u,v
		-7974,1871,-8497, //	x,y,z
		-11109,508, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-15988,-15436, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-15633,-15572, //	u,v
		-10735,1871,-10384, //	x,y,z
		-7769,478, //	u,v
		-9266,1871,-9427, //	x,y,z
		-9521,494, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-15633,-15572, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-15240,-15723, //	u,v
		-12282,1871,-11308, //	x,y,z
		-5970,463, //	u,v
		-10735,1871,-10384, //	x,y,z
		-7769,478, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-15240,-15723, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-14836,-15878, //	u,v
		-13809,1871,-12133, //	x,y,z
		-4240,447, //	u,v
		-12282,1871,-11308, //	x,y,z
		-5970,463, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-14836,-15878, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-14447,-16027, //	u,v
		-15218,1871,-12796, //	x,y,z
		-2697,434, //	u,v
		-13809,1871,-12133, //	x,y,z
		-4240,447, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-14447,-16027, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-14100,-16161, //	u,v
		-16411,1871,-13235, //	x,y,z
		-1456,423, //	u,v
		-15218,1871,-12796, //	x,y,z
		-2697,434, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-14100,-16161, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-13820,-16268, //	u,v
		-17601,1871,-12796, //	x,y,z
		-15029,-5510, //	u,v
		-16411,1871,-13235, //	x,y,z
		-15802,-6256, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-6644,-12927, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-5988,-12294, //	u,v
		-19006,1871,-12133, //	x,y,z
		-14074,-4587, //	u,v
		-17601,1871,-12796, //	x,y,z
		-15029,-5510, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-5988,-12294, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-5179,-11513, //	u,v
		-20528,1871,-11308, //	x,y,z
		-13007,-3556, //	u,v
		-19006,1871,-12133, //	x,y,z
		-14074,-4587, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-5179,-11513, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-4277,-10641, //	u,v
		-20528,1871,-11308, //	x,y,z
		-13007,-3556, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-4277,-10641, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-3341,-9737, //	u,v
		-23540,1871,-9427, //	x,y,z
		-10820,-1444, //	u,v
		-22072,1871,-10384, //	x,y,z
		-11898,-2486, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-2431,-8859, //	u,v
		-24837,1871,-8497, //	x,y,z
		-9843,-501, //	u,v
		-23540,1871,-9427, //	x,y,z
		-10820,-1444, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-2431,-8859, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-1608,-8064, //	u,v
		-25865,1872,-7660, //	x,y,z
		-9038,276, //	u,v
		-24837,1871,-8497, //	x,y,z
		-9843,-501, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-1608,-8064, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-931,-7409, //	u,v
		-25138,1871,-8742, //	x,y,z
		-9755,-415, //	u,v
		-25865,1872,-7660, //	x,y,z
		-9038,276, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-931,-7409, //	u,v
		-19526,-29286,-14049, //	x,y,z
		-1528,-7987, //	u,v
		-24262,1871,-9938, //	x,y,z
		-10585,-1218, //	u,v
		-25138,1871,-8742, //	x,y,z
		-9755,-415, //	u,v
		-19526,-29286,-14049, //	x,y,z
		-1528,-7987, //	u,v
		-19213,-29286,-14450, //	x,y,z
		-2222,-8657, //	u,v
		-23275,1871,-11200, //	x,y,z
		-11496,-2097, //	u,v
		-24262,1871,-9938, //	x,y,z
		-10585,-1218, //	u,v
		-19213,-29286,-14450, //	x,y,z
		-2222,-8657, //	u,v
		-18861,-29286,-14874, //	x,y,z
		-2983,-9392, //	u,v
		-22213,1871,-12481, //	x,y,z
		-12452,-3021, //	u,v
		-23275,1871,-11200, //	x,y,z
		-11496,-2097, //	u,v
		-18861,-29286,-14874, //	x,y,z
		-2983,-9392, //	u,v
		-18482,-29287,-15304, //	x,y,z
		-3783,-10165, //	u,v
		-21115,1871,-13736, //	x,y,z
		-13420,-3956, //	u,v
		-22213,1871,-12481, //	x,y,z
		-12452,-3021, //	u,v
		-18482,-29287,-15304, //	x,y,z
		-3783,-10165, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-4594,-10948, //	u,v
		-20018,1871,-14916, //	x,y,z
		-14366,-4869, //	u,v
		-21115,1871,-13736, //	x,y,z
		-13420,-3956, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-4594,-10948, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-5386,-11713, //	u,v
		-18959,1871,-15983, //	x,y,z
		-15257,-5729, //	u,v
		-18959,1871,-15983, //	x,y,z
		-329,-5931, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-11744,-15710, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-12193,-15091, //	u,v
};
const int index_count_xboxlogointerior_0 = 1008;
char indices_xboxlogointerior_0C[] = 
{
	2,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-3,2,
	3,-1,-2,
	6,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-9,8,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-3,2,
	3,-1,-2,
	5,-3,2,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-71,70,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-9,8,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-9,8,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-1,-3,
	7,-1,-1,
	5,-1,-1,
	126,-2,-61,126,1,64,126,-2,-65,
	0,126,1,65,1,
	126,-2,-62,126,1,63,126,-2,-64,
	0,126,1,64,1,
	126,-2,-61,126,1,62,126,-2,-63,
	0,126,1,63,1,
	126,-2,-60,126,1,61,126,-2,-62,
	0,126,1,62,1,
	126,-2,-59,126,1,60,126,-2,-61,
	0,126,1,61,1,
	126,-2,-58,126,1,59,126,-2,-60,
	0,126,1,60,1,
	126,-2,-57,126,1,58,126,-2,-59,
	0,126,1,59,1,
	126,-2,-56,126,1,57,126,-2,-58,
	0,126,1,58,-4,
	126,-2,-50,126,1,53,126,-2,-54,
	0,126,1,54,2,
	126,-2,-52,3,-4,
	0,4,126,1,50,
	126,-2,-53,1,1,
	0,-1,4,
	-1,126,1,50,126,-2,-52,
	0,126,1,52,126,-2,-51,
	4,126,1,48,126,-2,-49,
	126,1,52,-1,-1,
	126,-2,-46,126,1,49,126,-2,-50,
	0,126,1,50,1,
	126,-2,-47,9,-10,
	0,10,126,1,39,
	126,-2,-45,126,1,46,126,-2,-47,
	0,126,1,47,1,
	126,-2,-44,71,-72,
	0,72,126,0,-26,
	126,-2,-51,1,7,
	0,-7,126,1,51,
	126,-2,-41,126,1,42,126,-2,-43,
	0,126,1,43,1,
	126,-2,-40,126,1,41,126,-2,-42,
	0,126,1,42,-14,
	126,-2,-24,126,1,39,126,-2,-40,
	0,126,1,40,1,
	126,-2,-37,3,-4,
	0,4,126,1,35,
	126,-2,-38,1,1,
	0,-1,4,
	-1,3,-5,
	0,5,-4,
	1,1,1,
	0,-1,126,1,34,
	126,-2,-30,126,1,31,126,-2,-32,
	0,126,1,32,1,
	126,-2,-29,126,1,27,126,-2,-28,
	0,126,1,28,3,
	126,-2,-27,126,1,28,126,-2,-29,
	0,126,1,29,1,
	126,-2,-26,126,1,27,126,-2,-28,
	0,126,1,28,1,
	126,-2,-25,126,1,26,126,-2,-27,
	0,126,1,27,-4,
	126,-2,-19,126,1,24,126,-2,-25,
	0,126,1,25,1,
	126,-2,-22,126,1,23,126,-2,-24,
	0,126,1,24,1,
	126,-2,-21,126,1,22,126,-2,-23,
	0,126,1,23,1,
	126,-2,-20,126,1,21,126,-2,-22,
	0,126,1,22,1,
	126,-2,-19,126,1,20,126,-2,-21,
	0,126,1,21,1,
	126,-2,-18,126,1,19,126,-2,-20,
	0,126,1,20,1,
	126,-2,-17,126,1,18,126,-2,-19,
	0,126,1,19,1,
	126,-2,-16,126,1,17,126,-2,-18,
	0,126,1,18,1,
	126,-2,-15,126,1,16,126,-2,-17,
	0,126,1,17,1,
	126,-2,-14,126,1,15,126,-2,-16,
	0,126,1,16,1,
	126,-2,-13,126,1,14,126,-2,-15,
	0,126,1,15,1,
	126,-2,-83,1,69,
	0,-69,126,1,83,
	126,-2,-11,126,1,12,126,-2,-13,
	0,126,1,13,1,
	126,-2,-10,126,1,11,126,-2,-12,
	0,126,1,12,1,
	126,-2,-9,126,1,10,126,-2,-11,
	0,126,1,11,-7,
	126,-1,0,126,1,2,126,-2,-3,
	0,126,1,3,6,
	126,-2,-5,126,1,1,126,-2,-2,
	0,126,1,2,5,
	126,-2,-3,126,1,4,126,-2,-5,
	0,126,1,5,-5,
	126,-1,4,126,1,2,126,-2,-3,
	0,126,1,3,-4,
	126,-1,5,126,0,-4,126,-1,3,
	0,126,0,-3,4,
	126,-1,3,126,0,-6,126,-1,5,
	0,126,0,-5,4,
	126,-1,5,126,0,-4,126,-1,3,
	0,126,0,-3,-4,
	126,-1,11,126,0,-6,126,-1,5,
	0,126,0,-5,-4,
	126,-1,13,126,0,-8,126,-1,7,
	0,126,0,-7,1,
	126,-1,10,9,-10,
	0,10,126,0,-18,
	126,-1,12,126,0,-11,126,-1,10,
	0,126,0,-10,1,
	126,-1,13,8,-9,
	0,9,126,0,-20,
	126,-1,6,1,7,
	0,-7,126,0,-6,
	126,-1,16,8,-9,
	0,9,126,0,-23,
	126,-1,10,1,6,
	0,-6,126,0,-10,
	126,-1,19,8,-9,
	0,9,126,0,-26,
	126,-1,13,1,6,
	0,-6,126,0,-13,
	126,-1,22,8,-9,
	0,9,126,0,-29,
	126,-1,16,1,6,
	0,-6,126,0,-16,
	126,-1,25,8,-9,
	0,9,126,0,-32,
	126,-1,19,1,6,
	0,-6,126,0,-19,
	126,-1,28,126,0,-27,126,-1,26,
	0,126,0,-26,1,
	126,-1,21,1,6,
	0,-6,126,0,-21,
	126,-1,30,126,0,-29,126,-1,28,
	0,126,0,-28,1,
	126,-1,31,126,0,-30,126,-1,29,
	0,126,0,-29,1,
	126,-1,32,126,0,-31,126,-1,30,
	0,126,0,-30,1,
	126,-1,33,126,0,-32,126,-1,31,
	0,126,0,-31,1,
	126,-1,34,126,0,-33,126,-1,32,
	0,126,0,-32,1,
	126,-1,35,126,0,-34,126,-1,33,
	0,126,0,-33,1,
	126,-1,36,126,0,-35,126,-1,34,
	0,126,0,-34,1,
	126,-1,37,126,0,-36,126,-1,35,
	0,126,0,-35,1,
	126,-1,38,126,0,-37,126,-1,36,
	0,126,0,-36,1,
	126,-1,39,126,0,-38,126,-1,37,
	0,126,0,-37,1,
	126,-1,40,126,0,-39,126,-1,38,
	0,126,0,-38,1,
	126,-1,41,126,0,-40,126,-1,39,
	0,126,0,-39,1,
	126,-1,42,126,0,-41,126,-1,40,
	0,126,0,-40,1,
	126,-1,43,126,0,-42,126,-1,41,
	0,126,0,-41,1,
	126,-1,44,126,0,-43,126,-1,42,
	0,126,0,-42,1,
	126,-1,45,126,0,-44,126,-1,43,
	0,126,0,-43,1,
	126,-1,46,126,0,-45,126,-1,44,
	0,126,0,-44,1,
	126,-1,47,126,0,-46,126,-1,45,
	0,126,0,-45,1,
	126,-1,48,126,0,-47,126,-1,46,
	0,126,0,-46,1,
	126,-1,49,126,0,-48,126,-1,47,
	0,126,0,-47,1,
	126,-1,50,9,-10,
	0,10,126,0,-58,
	126,-1,52,126,0,-51,126,-1,50,
	0,126,0,-50,1,
	126,-1,53,126,0,-52,126,-1,51,
	0,126,0,-51,1,
	126,-1,45,1,7,
	0,-7,126,0,-45,
	126,-1,55,126,0,-54,126,-1,53,
	0,126,0,-53,1,
	126,-1,56,126,0,-55,126,-1,54,
	0,126,0,-54,1,
	126,-1,57,126,0,-56,126,-1,55,
	0,126,0,-55,1,
	126,-1,58,126,0,-57,126,-1,56,
	0,126,0,-56,1,
	126,-1,59,126,0,-58,126,-1,57,
	0,126,0,-57,1,
	126,-1,60,126,0,-59,126,-1,58,
	0,126,0,-58,1,
	126,-1,61,126,0,-60,126,-1,59,
	0,126,0,-59,1,
	126,-1,62,126,0,-61,126,-1,60,
	0,126,0,-60,1,
	126,-1,63,126,0,-62,126,-1,61,
	0,126,0,-61,1,
	126,-1,64,126,0,-63,126,-1,62,
	0,126,0,-62,1,
	126,-1,65,126,0,-64,126,-1,63,
	0,126,0,-63,1,
	126,-1,66,126,0,-65,126,-1,64,
	0,126,0,-64,1,
	126,-1,67,126,0,-66,126,-1,65,
	0,126,0,-65,1,
	126,-1,68,126,0,-67,126,-1,66,
	0,126,0,-66,1,
	126,-1,69,126,0,-68,126,-1,67,
	0,126,0,-67,1,
	126,-1,70,126,0,-69,126,-1,68,
	0,126,0,-68,1,
	126,-1,71,126,0,-70,126,-1,69,
	0,126,0,-69,126,-1,73,
	-1,126,0,-73,126,-1,70,
	0,126,0,-70,126,-1,72,
	4,82,-83,
	0,83,100,
	126,-1,77,126,0,-76,126,-1,75,
	0,126,0,-75,1,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogolip_0 = 210;
short verts_xboxlogolip_0C[] = 
{
		-13340,-29287,-19982, //	x,y,z
		381,-1307, //	u,v
		-12836,-29287,-20290, //	x,y,z
		297,895, //	u,v
		-12836,-29754,-20290, //	x,y,z
		-16366,889, //	u,v
		-13340,-29754,-19982, //	x,y,z
		-16282,-1313, //	u,v
		-13898,-29287,-19581, //	x,y,z
		477,-3961, //	u,v
		-13340,-29287,-19982, //	x,y,z
		381,-1307, //	u,v
		-13340,-29754,-19982, //	x,y,z
		-16282,-1313, //	u,v
		-13898,-29754,-19581, //	x,y,z
		-16186,-3967, //	u,v
		-14485,-29287,-19087, //	x,y,z
		577,-6847, //	u,v
		-13898,-29287,-19581, //	x,y,z
		477,-3961, //	u,v
		-13898,-29754,-19581, //	x,y,z
		-16186,-3967, //	u,v
		-14485,-29754,-19087, //	x,y,z
		-16085,-6853, //	u,v
		-15074,-29287,-18582, //	x,y,z
		676,-9748, //	u,v
		-15074,-29754,-18582, //	x,y,z
		-15987,-9754, //	u,v
		-15624,-29287,-18082, //	x,y,z
		766,-12446, //	u,v
		-15074,-29287,-18582, //	x,y,z
		676,-9748, //	u,v
		-15074,-29754,-18582, //	x,y,z
		-15987,-9754, //	u,v
		-15624,-29754,-18082, //	x,y,z
		-15897,-12452, //	u,v
		-16083,-29287,-17657, //	x,y,z
		842,-14723, //	u,v
		-16083,-29754,-17657, //	x,y,z
		-15821,-14729, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-15877,717, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15877,-3694, //	u,v
		-13296,-29754,-19744, //	x,y,z
		407,-3694, //	u,v
		-12836,-29754,-20290, //	x,y,z
		407,717, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15877,-3694, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-15877,-7725, //	u,v
		-13729,-29754,-19161, //	x,y,z
		407,-7725, //	u,v
		-13296,-29754,-19744, //	x,y,z
		407,-3694, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-15877,-7725, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-15877,-9784, //	u,v
		-14143,-29754,-18564, //	x,y,z
		407,-9784, //	u,v
		-13729,-29754,-19161, //	x,y,z
		407,-7725, //	u,v
		-16411,-29287,-17356, //	x,y,z
		895,-16360, //	u,v
		-16411,-29754,-17356, //	x,y,z
		-15768,-16366, //	u,v
		-16738,-29287,-17657, //	x,y,z
		513,-14543, //	u,v
		-16411,-29287,-17356, //	x,y,z
		561,-16133, //	u,v
		-16411,-29754,-17356, //	x,y,z
		-15643,-16139, //	u,v
		-16738,-29754,-17657, //	x,y,z
		-15690,-14549, //	u,v
		-17198,-29287,-18082, //	x,y,z
		447,-12333, //	u,v
		-17198,-29754,-18082, //	x,y,z
		-15756,-12338, //	u,v
		-17747,-29287,-18582, //	x,y,z
		370,-9713, //	u,v
		-17747,-29754,-18582, //	x,y,z
		-15833,-9719, //	u,v
		-18336,-29287,-19087, //	x,y,z
		289,-6896, //	u,v
		-17747,-29287,-18582, //	x,y,z
		370,-9713, //	u,v
		-17747,-29754,-18582, //	x,y,z
		-15833,-9719, //	u,v
		-18336,-29754,-19087, //	x,y,z
		-15914,-6902, //	u,v
		-18924,-29287,-19581, //	x,y,z
		211,-4094, //	u,v
		-18924,-29754,-19581, //	x,y,z
		-15993,-4100, //	u,v
		-19482,-29287,-19982, //	x,y,z
		142,-1518, //	u,v
		-18924,-29287,-19581, //	x,y,z
		211,-4094, //	u,v
		-18924,-29754,-19581, //	x,y,z
		-15993,-4100, //	u,v
		-19482,-29754,-19982, //	x,y,z
		-16062,-1524, //	u,v
		-19986,-29287,-20290, //	x,y,z
		89,620, //	u,v
		-19482,-29287,-19982, //	x,y,z
		142,-1518, //	u,v
		-19482,-29754,-19982, //	x,y,z
		-16062,-1524, //	u,v
		-19986,-29754,-20290, //	x,y,z
		-16114,614, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15801,-265, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-15801,590, //	u,v
		-19986,-29754,-20290, //	x,y,z
		331,590, //	u,v
		-19526,-29754,-19744, //	x,y,z
		331,-265, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-15801,-1151, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15801,-265, //	u,v
		-19526,-29754,-19744, //	x,y,z
		331,-265, //	u,v
		-19092,-29754,-19161, //	x,y,z
		331,-1151, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-15801,-2400, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-15801,-1151, //	u,v
		-19092,-29754,-19161, //	x,y,z
		331,-1151, //	u,v
		-18678,-29754,-18564, //	x,y,z
		331,-2400, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-15877,-9784, //	u,v
		-14537,-29287,-17974, //	x,y,z
		-15877,-11729, //	u,v
		-14537,-29754,-17974, //	x,y,z
		407,-11729, //	u,v
		-14143,-29754,-18564, //	x,y,z
		407,-9784, //	u,v
		-18285,-29287,-17974, //	x,y,z
		-15801,-3495, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-15801,-2400, //	u,v
		-18678,-29754,-18564, //	x,y,z
		331,-2400, //	u,v
		-18285,-29754,-17974, //	x,y,z
		331,-3495, //	u,v
		-14903,-29287,-17415, //	x,y,z
		-15877,-13400, //	u,v
		-14903,-29754,-17415, //	x,y,z
		407,-13400, //	u,v
		-17919,-29287,-17415, //	x,y,z
		-15801,-4613, //	u,v
		-17919,-29754,-17415, //	x,y,z
		331,-4613, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-15877,-14908, //	u,v
		-15229,-29754,-16909, //	x,y,z
		407,-14908, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-15801,-5829, //	u,v
		-17593,-29754,-16909, //	x,y,z
		331,-5829, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-15877,-14908, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-15877,-16118, //	u,v
		-15501,-29754,-16479, //	x,y,z
		407,-16205, //	u,v
		-15501,-29754,-16479, //	x,y,z
		407,-16205, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-8006,-14045, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-6755,-11969, //	u,v
		-15124,-29753,-16122, //	x,y,z
		-13617,-11615, //	u,v
		-15124,-29753,-16122, //	x,y,z
		-13617,-11615, //	u,v
		-15501,-29754,-16479, //	x,y,z
		-14868,-13691, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-8006,-14045, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-6755,-11969, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-5434,-9778, //	u,v
		-14734,-29753,-15727, //	x,y,z
		-12296,-9424, //	u,v
		-15124,-29753,-16122, //	x,y,z
		-13617,-11615, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-5434,-9778, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-4088,-7547, //	u,v
		-14344,-29753,-15308, //	x,y,z
		-10950,-7193, //	u,v
		-14734,-29753,-15727, //	x,y,z
		-12296,-9424, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-4088,-7547, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-2762,-5349, //	u,v
		-13967,-29753,-14880, //	x,y,z
		-9623,-4995, //	u,v
		-14344,-29753,-15308, //	x,y,z
		-10950,-7193, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-2762,-5349, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-1501,-3260, //	u,v
		-13614,-29753,-14456, //	x,y,z
		-8362,-2906, //	u,v
		-13967,-29753,-14880, //	x,y,z
		-9623,-4995, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-1501,-3260, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-349,-1354, //	u,v
		-13300,-29753,-14054, //	x,y,z
		-7211,-1000, //	u,v
		-13614,-29753,-14456, //	x,y,z
		-8362,-2906, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-349,-1354, //	u,v
		-13036,-29286,-13686, //	x,y,z
		646,294, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-6214,648, //	u,v
		-13300,-29753,-14054, //	x,y,z
		-7211,-1000, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16034,727, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-16026,-1379, //	u,v
		-13399,-29753,-13967, //	x,y,z
		536,-1379, //	u,v
		-13036,-29753,-13686, //	x,y,z
		528,727, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-16026,-1379, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-16019,-3692, //	u,v
		-13860,-29753,-14279, //	x,y,z
		543,-3692, //	u,v
		-13399,-29753,-13967, //	x,y,z
		536,-1379, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-16019,-3692, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-16012,-5992, //	u,v
		-14385,-29753,-14600, //	x,y,z
		549,-5992, //	u,v
		-13860,-29753,-14279, //	x,y,z
		543,-3692, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-16012,-5992, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-16007,-8224, //	u,v
		-14937,-29753,-14910, //	x,y,z
		555,-8224, //	u,v
		-14385,-29753,-14600, //	x,y,z
		549,-5992, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-16007,-8224, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-16002,-10920, //	u,v
		-15482,-29753,-15187, //	x,y,z
		560,-10920, //	u,v
		-14937,-29753,-14910, //	x,y,z
		555,-8224, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-16002,-10920, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-16000,-13359, //	u,v
		-15985,-29753,-15409, //	x,y,z
		562,-13359, //	u,v
		-15482,-29753,-15187, //	x,y,z
		560,-10920, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-16000,-13359, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-15998,-15361, //	u,v
		-16411,-29754,-15557, //	x,y,z
		563,-15361, //	u,v
		-15985,-29753,-15409, //	x,y,z
		562,-13359, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-16079,-16196, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-16080,-14202, //	u,v
		-16836,-29753,-15409, //	x,y,z
		643,-14202, //	u,v
		-16411,-29754,-15557, //	x,y,z
		644,-16196, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-16080,-14202, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-16083,-12066, //	u,v
		-17337,-29753,-15187, //	x,y,z
		640,-12066, //	u,v
		-16836,-29753,-15409, //	x,y,z
		643,-14202, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-16083,-12066, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-16087,-9713, //	u,v
		-17881,-29753,-14910, //	x,y,z
		636,-9713, //	u,v
		-17337,-29753,-15187, //	x,y,z
		640,-12066, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-16087,-9713, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-16093,-7360, //	u,v
		-18431,-29753,-14600, //	x,y,z
		630,-7360, //	u,v
		-17881,-29753,-14910, //	x,y,z
		636,-9713, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-16093,-7360, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-16100,-4976, //	u,v
		-18956,-29753,-14279, //	x,y,z
		623,-4976, //	u,v
		-18431,-29753,-14600, //	x,y,z
		630,-7360, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-16100,-4976, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-16107,-2569, //	u,v
		-19418,-29753,-13967, //	x,y,z
		616,-2569, //	u,v
		-18956,-29753,-14279, //	x,y,z
		623,-4976, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-16107,-2569, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-16114,518, //	u,v
		-19785,-29753,-13686, //	x,y,z
		608,518, //	u,v
		-19418,-29753,-13967, //	x,y,z
		616,-2569, //	u,v
		-19785,-29286,-13686, //	x,y,z
		645,635, //	u,v
		-19526,-29286,-14049, //	x,y,z
		511,-1067, //	u,v
		-19526,-29753,-14049, //	x,y,z
		-15266,-1056, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-15132,646, //	u,v
		-19526,-29286,-14049, //	x,y,z
		511,-1067, //	u,v
		-19213,-29286,-14450, //	x,y,z
		365,-3049, //	u,v
		-19213,-29753,-14450, //	x,y,z
		-15412,-3039, //	u,v
		-19526,-29753,-14049, //	x,y,z
		-15266,-1056, //	u,v
		-19213,-29286,-14450, //	x,y,z
		365,-3049, //	u,v
		-18861,-29286,-14874, //	x,y,z
		214,-5230, //	u,v
		-18861,-29753,-14874, //	x,y,z
		-15563,-5220, //	u,v
		-19213,-29753,-14450, //	x,y,z
		-15412,-3039, //	u,v
		-18861,-29286,-14874, //	x,y,z
		214,-5230, //	u,v
		-18482,-29287,-15304, //	x,y,z
		63,-7527, //	u,v
		-18482,-29753,-15304, //	x,y,z
		-15715,-7516, //	u,v
		-18861,-29753,-14874, //	x,y,z
		-15563,-5220, //	u,v
		-18482,-29287,-15304, //	x,y,z
		63,-7527, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-82,-9857, //	u,v
		-18090,-29753,-15725, //	x,y,z
		-15860,-9847, //	u,v
		-18482,-29753,-15304, //	x,y,z
		-15715,-7516, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-82,-9857, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-217,-12140, //	u,v
		-17698,-29753,-16121, //	x,y,z
		-15995,-12130, //	u,v
		-18090,-29753,-15725, //	x,y,z
		-15860,-9847, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-217,-12140, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-335,-14293, //	u,v
		-17320,-29754,-16479, //	x,y,z
		-16113,-14283, //	u,v
		-17320,-29754,-16479, //	x,y,z
		-16113,-14283, //	u,v
		-17698,-29753,-16121, //	x,y,z
		-15995,-12130, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-217,-12140, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-15801,-6895, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-15801,-5829, //	u,v
		-17593,-29754,-16909, //	x,y,z
		331,-5829, //	u,v
		-17593,-29754,-16909, //	x,y,z
		331,-5829, //	u,v
		-17320,-29754,-16479, //	x,y,z
		331,-6971, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-15801,-6895, //	u,v
};
const int index_count_xboxlogolip_0 = 336;
char indices_xboxlogolip_0C[] = 
{
	2,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	-11,-1,14,
	0,1,-14,
	17,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	2,-1,2,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	3,-1,-7,
	0,1,7,
	-2,-3,6,
	0,1,-4,
	6,-1,-4,
	0,1,4,
	-2,-1,4,
	0,1,-4,
	7,-1,-1,
	-4,1,6,
	3,-1,-1,
	5,-1,-1,
	5,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogosurfacetop_0 = 34;
short verts_xboxlogosurfacetop_0C[] = 
{
		-13399,-29753,-13967, //	x,y,z
		-12037,-16047, //	u,v
		-16411,-29754,-7827, //	x,y,z
		-7734,-31845, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-12555,-16770, //	u,v
		-13860,-29753,-14279, //	x,y,z
		-11378,-15245, //	u,v
		-14385,-29753,-14600, //	x,y,z
		-10629,-14418, //	u,v
		-14937,-29753,-14910, //	x,y,z
		-9840,-13490, //	u,v
		-15482,-29753,-15187, //	x,y,z
		-9061,-12344, //	u,v
		-15539,-29753,-14734, //	x,y,z
		-8980,-13943, //	u,v
		-15985,-29753,-15409, //	x,y,z
		-8343,-11144, //	u,v
		-16005,-29753,-15058, //	x,y,z
		-8315,-12675, //	u,v
		-16411,-29754,-15057, //	x,y,z
		-7735,-12677, //	u,v
		-16028,-29754,-14642, //	x,y,z
		-8281,-14179, //	u,v
		-16836,-29753,-15409, //	x,y,z
		-7128,-11144, //	u,v
		-16411,-29754,-15557, //	x,y,z
		-7735,-10269, //	u,v
		-17337,-29753,-15187, //	x,y,z
		-6412,-12344, //	u,v
		-17289,-29753,-14757, //	x,y,z
		-6480,-13882, //	u,v
		-16794,-29753,-14661, //	x,y,z
		-7187,-14129, //	u,v
		-17881,-29753,-14910, //	x,y,z
		-5635,-13490, //	u,v
		-18431,-29753,-14600, //	x,y,z
		-4848,-14418, //	u,v
		-18956,-29753,-14279, //	x,y,z
		-4100,-15245, //	u,v
		-19418,-29753,-13967, //	x,y,z
		-3439,-16047, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-2914,-16770, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-14622, //	x,y,z
		-7735,-14232, //	u,v
		-16822,-29753,-15089, //	x,y,z
		-7147,-12595, //	u,v
};
const int index_count_xboxlogosurfacetop_0 = 105;
char indices_xboxlogosurfacetop_0C[] = 
{
	2,-1,-1,
	0,1,2,
	0,-2,3,
	0,-3,4,
	0,2,-1,
	0,3,-1,
	3,-1,-1,
	4,-3,2,
	4,-1,-1,
	0,1,2,
	0,-16,17,
	0,-17,18,
	0,-18,19,
	0,-19,20,
	3,-1,-1,
	5,-1,-1,
	0,4,-1,
	-3,3,-1,
	4,-1,-7,
	-16,-6,10,
	-6,-4,6,
	0,2,-3,
	2,1,4,
	19,-31,15,
	-5,-10,31,
	0,1,-23,
	2,21,-19,
	1,-14,16,
	-1,-15,14,
	-6,1,3,
	-6,4,-2,
	1,23,-21,
	-1,21,-22,
	23,-17,-2,
	18,-16,17,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogosurface_0 = 77;
short verts_xboxlogosurface_0C[] = 
{
		-13296,-29754,-19744, //	x,y,z
		-15182,-3867, //	u,v
		-5054,-29754,-16500, //	x,y,z
		-31514,-8048, //	u,v
		-12836,-29754,-20290, //	x,y,z
		-16093,-3163, //	u,v
		-12836,-29754,-20290, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-13340,-29754,-19982, //	x,y,z
		-16374,904, //	u,v
		-13898,-29754,-19581, //	x,y,z
		-16374,904, //	u,v
		-14485,-29754,-19087, //	x,y,z
		-16374,904, //	u,v
		-15074,-29754,-18582, //	x,y,z
		-16374,904, //	u,v
		-15624,-29754,-18082, //	x,y,z
		-16374,904, //	u,v
		-16083,-29754,-17657, //	x,y,z
		-16374,904, //	u,v
		-13729,-29754,-19161, //	x,y,z
		-14322,-4618, //	u,v
		-14143,-29754,-18564, //	x,y,z
		-13503,-5388, //	u,v
		-14537,-29754,-17974, //	x,y,z
		-12625,-6148, //	u,v
		-16411,-29754,-17356, //	x,y,z
		-16374,904, //	u,v
		-16738,-29754,-17657, //	x,y,z
		-16374,904, //	u,v
		-17198,-29754,-18082, //	x,y,z
		-16374,904, //	u,v
		-17747,-29754,-18582, //	x,y,z
		-16374,904, //	u,v
		-18336,-29754,-19087, //	x,y,z
		-16374,904, //	u,v
		-18924,-29754,-19581, //	x,y,z
		-16374,904, //	u,v
		-19482,-29754,-19982, //	x,y,z
		-16374,904, //	u,v
		-19986,-29754,-20290, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-16480, //	x,y,z
		-16374,904, //	u,v
		-19526,-29754,-19744, //	x,y,z
		-16374,904, //	u,v
		-19092,-29754,-19161, //	x,y,z
		-16374,904, //	u,v
		-18678,-29754,-18564, //	x,y,z
		-16374,904, //	u,v
		-14903,-29754,-17415, //	x,y,z
		-11458,-6869, //	u,v
		-14375,-29754,-17366, //	x,y,z
		-12945,-6932, //	u,v
		-18285,-29754,-17974, //	x,y,z
		-16374,904, //	u,v
		-15229,-29754,-16909, //	x,y,z
		-10298,-7521, //	u,v
		-14703,-29754,-16888, //	x,y,z
		-11856,-7548, //	u,v
		-17919,-29754,-17415, //	x,y,z
		-16374,904, //	u,v
		-15501,-29754,-16479, //	x,y,z
		-9758,-8075, //	u,v
		-14953,-29754,-16480, //	x,y,z
		-10845,-8074, //	u,v
		-17593,-29754,-16909, //	x,y,z
		-16374,904, //	u,v
		-15124,-29754,-16122, //	x,y,z
		-10506,-8536, //	u,v
		-14645,-29754,-16138, //	x,y,z
		-11969,-8515, //	u,v
		-14606,-29754,-16481, //	x,y,z
		-12047,-8073, //	u,v
		-14734,-29753,-15727, //	x,y,z
		-11793,-9044, //	u,v
		-14290,-29753,-15749, //	x,y,z
		-13113,-9017, //	u,v
		-14344,-29753,-15308, //	x,y,z
		-13007,-9584, //	u,v
		-13967,-29753,-14880, //	x,y,z
		-13852,-10137, //	u,v
		-13614,-29753,-14456, //	x,y,z
		-14550,-10682, //	u,v
		-13300,-29753,-14054, //	x,y,z
		-15173,-11201, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-15696,-11675, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-16500, //	x,y,z
		-16374,904, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-19526,-29753,-14049, //	x,y,z
		-16374,904, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-19213,-29753,-14450, //	x,y,z
		-16374,904, //	u,v
		-18861,-29753,-14874, //	x,y,z
		-16374,904, //	u,v
		-18482,-29753,-15304, //	x,y,z
		-16374,904, //	u,v
		-18090,-29753,-15725, //	x,y,z
		-16374,904, //	u,v
		-17698,-29753,-16121, //	x,y,z
		-16374,904, //	u,v
		-17320,-29754,-16479, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-16500, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-16480, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-14268,-29754,-16150, //	x,y,z
		-13156,-8499, //	u,v
		-14282,-29754,-16481, //	x,y,z
		-13130,-8072, //	u,v
		-14316,-29754,-16872, //	x,y,z
		-13061,-7568, //	u,v
};
const int index_count_xboxlogosurface_0 = 225;
char indices_xboxlogosurface_0C[] = 
{
	2,-1,-1,
	5,-1,-1,
	2,-2,3,
	-1,1,1,
	-2,2,1,
	-3,3,1,
	-4,4,1,
	-5,5,1,
	-11,1,11,
	0,-11,12,
	0,-12,13,
	-9,6,4,
	-10,10,1,
	-11,11,1,
	-12,12,1,
	-13,13,1,
	-14,14,1,
	-15,15,1,
	-16,16,1,
	2,-1,-1,
	2,-2,3,
	-1,1,1,
	-2,2,1,
	-13,15,-1,
	-4,3,3,
	-2,4,-1,
	-7,6,3,
	-2,4,-1,
	-10,9,3,
	3,-1,-1,
	1,3,-1,
	0,1,1,
	0,-41,42,
	0,-42,43,
	0,-43,44,
	0,-44,45,
	3,-1,-1,
	4,-27,26,
	0,-26,28,
	0,-28,29,
	0,-29,30,
	0,-30,31,
	0,-31,32,
	0,-32,33,
	0,-33,12,
	24,-1,-1,
	0,4,-1,
	4,-1,-1,
	0,4,-1,
	4,-1,-1,
	0,4,-1,
	-13,3,-1,
	-57,1,44,
	20,3,-1,
	3,-49,27,
	12,3,-1,
	-42,-18,17,
	19,-40,41,
	-5,1,2,
	34,-73,40,
	-7,1,2,
	38,-74,73,
	-43,1,3,
	41,-75,74,
	-47,1,47,
	-47,-28,75,
	-62,-13,28,
	10,36,-1,
	2,-1,-36,
	37,-37,-7,
	3,4,-2,
	1,36,-33,
	-2,35,-36,
	-6,7,-4,
	-7,48,-44,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_tm_slash_0 = 4;
short verts_tm_slash_0C[] = 
{
		-12770,-29763,-13794, //	x,y,z
		-16034,563, //	u,v
		-12410,-29763,-13794, //	x,y,z
		563,563, //	u,v
		-12410,-29763,-13435, //	x,y,z
		563,-16034, //	u,v
		-12770,-29763,-13435, //	x,y,z
		-16034,-16034, //	u,v
};
const int index_count_tm_slash_0 = 6;
char indices_tm_slash_0C[] = 
{
	0,1,1,
	1,-3,2,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_tm_wordmark_0 = 4;
short verts_tm_wordmark_0C[] = 
{
		-11684,-29763,-21238, //	x,y,z
		-16034,563, //	u,v
		-11379,-29763,-21238, //	x,y,z
		563,563, //	u,v
		-11379,-29763,-20934, //	x,y,z
		563,-16034, //	u,v
		-11684,-29763,-20934, //	x,y,z
		-16034,-16034, //	u,v
};
const int index_count_tm_wordmark_0 = 6;
char indices_tm_wordmark_0C[] = 
{
	0,1,1,
	1,-3,2,
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\fastmath.cpp ===
/*--
Copyright (c) 2000  Microsoft Corporation - Xbox SDK

Module Name:

    fastmath.cpp
--*/

#include "precomp.h"
//#include "Debug.h"

//----------------------------------------------------------------------------
// Katmai and MMX(TM) constants implementation
#define _MM_ALIGN16 __declspec(align(16))

#define SC_OPT

#if !defined(M128)
#define M128(x) (*(__m128*)&(x))
#endif

typedef unsigned long DWORD;

#define _M128_CONST(Name, Val) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val, Val, Val, Val }

#define _M128_CONST4(Name, Val0, Val1, Val2, Val3) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val0, Val1, Val2, Val3 }

#define M128_EXTERN_CONST(Name, Val) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val, Val, Val, Val }; \
const __m128* p##Name = (__m128*)_m128const_##Name

#define M128_EXTERN_CONST_TYPE(Name, Val, Type) \
static const _MM_ALIGN16 Type _m128const_##Name[4] = { Val, Val, Val, Val }; \
const __m128* p##Name = (__m128*)_m128const_##Name

#define M128_CONST(Name, Val) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val, Val, Val, Val }; \
const __m128 Name = M128(_m128const_##Name)

M128_EXTERN_CONST(am_0, 0.0f);
M128_EXTERN_CONST(am_1, 1.0f);
M128_EXTERN_CONST(am_minus_1, -1.0f);
M128_EXTERN_CONST(am_0p5, 0.5f);
M128_EXTERN_CONST(am_1p5, 1.5f);
M128_EXTERN_CONST(am_3_over_2, 3.0f / 2.0f);
M128_EXTERN_CONST(am_pi, PI);
M128_EXTERN_CONST(am_pi_over_2, (PI / 2.0f));
M128_EXTERN_CONST(am_2_over_pi, (2.0f / PI));
M128_EXTERN_CONST_TYPE(am_sign_mask, 0x80000000, DWORD);
M128_EXTERN_CONST_TYPE(am_inv_sign_mask, ~0x80000000, DWORD);
M128_EXTERN_CONST_TYPE(am_min_pos_norm, 0x00800000, DWORD);
M128_EXTERN_CONST_TYPE(am_mant_mask, 0x7f800000, DWORD);
M128_EXTERN_CONST_TYPE(am_inv_mant_mask, ~0x7f800000, DWORD);


//----------------------------------------------------------------------------
// Katmai and MMX(TM) constants implementation
static const float p0 = 0.15707963267948963959e1f;
static const float p1 = -0.64596409750621907082e0f;
static const float p2 = 0.7969262624561800806e-1f;
static const float p3 = -0.468175413106023168e-2f;

static const float t0 = -0.91646118527267623468e-1f;
static const float t1 = -0.13956945682312098640e1f;
static const float t2 = -0.94393926122725531747e2f;
static const float t3 =  0.12888383034157279340e2f;
static const float s0 =  0.12797564625607904396e1f;
static const float s1 =  0.21972168858277355914e1f;
static const float s2 =  0.68193064729268275701e1f;
static const float s3 =  0.28205206687035841409e2f;

static const float p0exp = 1.26177193074810590878e-4f;
static const float p1exp = 3.02994407707441961300e-2f;

static const float q0 = 3.00198505138664455042e-6f;
static const float q1 = 2.52448340349684104192e-3f;
static const float q2 = 2.27265548208155028766e-1f;
static const float q3 = 2.00000000000000000009e0f;

static const float rln2 = 1.4426950408889634073599f;
static const float c1 = 6.93145751953125e-1f;
static const float c2 = 1.42860682030941723212e-6f;

	const float at3613 = 2.7692309f;
	const float at2511 = 2.2727273f;
	const float at36 = 36.0f;
	const float at25 = 25.0f;
	const float at16 = 16.0f;
	const float at11 = 11.0f;
	const float at9 = 9.0f;
	const float at7 = 7.0f;
	const float at5 = 5.0f;
	const float at4 = 4.0f;
	const float at3 = 3.0f;
	const float at1 = 1.0f;
	const float at_p2 = PI_DIV_2;
	const float mp2 = -PI_DIV_2;

	const float as2 = FLOAT_SMALL;

	const float SQ2 = 1.4142136f;
	const float SQ3 = 0.3333333f;
	const float SQ5 = 1.4000000f;
	const float SQ7 = 0.1428571f;
	const float LOG2 = 0.3465736f;

    static const float log_p0 = -7.89580278884799154124e-1f;
    static const float log_p1 = 1.63866645699558079767e1f;
    static const float log_p2 = -6.41409952958715622951e1f;

    static const float log_q0 = -3.56722798256324312549e1f;
    static const float log_q1 = 3.12093766372244180303e2f;
    static const float log_q2 = -7.69691943550460008604e2f;

    static const float log_rsqrt2 = 7.07106781186547524401e-1f;
    static const float log_c0 = 0.693147180559945f;

    static const float fmax = 88.0f;
    static const float fmin = -88.0f;

    static const float pow_p0 = -7.89580278884799154124e-1f;
    static const float pow_p1 = 1.63866645699558079767e1f;
    static const float pow_p2 = -6.41409952958715622951e1f;

    static const float pow_q0 = -3.56722798256324312549e1f;
    static const float pow_q1 = 3.12093766372244180303e2f;
    static const float pow_q2 = -7.69691943550460008604e2f;

    static const float pow_rsqrt2 = 7.07106781186547524401e-1f;
    static const float pow_c0 = 1.44269504088896340735992f;

    static const float pow_r0 = 2.30933477057345225087e-2f;
    static const float pow_r1 = 2.02020656693165307700e1f;
    static const float pow_r2 = 1.51390680115615096133e3f;

    static const float pow_s0 = 2.33184211722314911771e2f;
    static const float pow_s1 = 4.36821166879210612817e3f;

    static const float pow_fmax = 128.0f;
    static const float pow_fmin = -127.0f;

	const float th1 = 1.0f;
	const float th2p = 2.0f;
	const float th2m = -2.0f;
	const float th3 = 0.3333333f;


	const float sh1 = 1.0f;
	const float sh5 = 0.5f;
	const float sh6 = 0.1666667f;

	const float t_as[49] = {
		0.9698000f,
		0.9691796f, 0.9685330f, 0.9678589f, 0.9671551f, 0.9664199f, 0.9656509f, 0.9648460f, 0.9640023f,
		0.9631173f, 0.9621876f, 0.9612098f, 0.9601802f, 0.9590943f, 0.9579477f, 0.9567349f, 0.9554501f,
		0.9540865f, 0.9526370f, 0.9510929f, 0.9494448f, 0.9476817f, 0.9457912f, 0.9437591f, 0.9415686f,
		0.9392007f, 0.9366328f, 0.9338384f, 0.9307863f, 0.9274390f, 0.9237517f, 0.9196697f, 0.9151261f,
		0.9100379f, 0.9043011f, 0.8977833f, 0.8903134f, 0.8816667f, 0.8715416f, 0.8595238f, 0.8450292f,
		0.8272059f, 0.8047620f, 0.7756411f, 0.7363636f, 0.6805556f, 0.5952381f, 0.4500000f, 0.1666667f
	};

//----------------------------------------------------------------------------
// atan
float fast_atan
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 154 cycles
    return atanf(x);

#else
#if defined(SC_OPT)
	_asm {
		mov		eax, x
		movss	xmm0, x
		cmp		eax, 0bf800000h
		jnc		minus1
		cmp		eax, 3f800000h
		jnc		plus1
		movss	xmm1, xmm0
		mulss	xmm1, xmm1
		movss	xmm2, xmm1
		movss	xmm3, xmm1
		movss	xmm4, xmm1
		movss	xmm5, xmm1
		mulss	xmm2, at2511
		mulss	xmm3, at16
		mulss	xmm4, at9
		mulss	xmm5, at4
		addss	xmm2, at9
		rcpss	xmm6, xmm2
		mulss	xmm6, xmm3
		addss	xmm6, at7
		rcpss	xmm2, xmm6
		mulss	xmm2, xmm4
		addss	xmm2, at5
		rcpss	xmm6, xmm2
		mulss	xmm6, xmm5
		addss	xmm6, at3
		rcpss	xmm2, xmm6
		mulss	xmm1, xmm2
		addss	xmm1, at1
		rcpss	xmm2, xmm1
		movss	xmm7, xmm2
		addss	xmm2, xmm2
		mulss	xmm7, xmm7
		mulss	xmm7, xmm1
		subss	xmm2, xmm7

		mulss	xmm0, xmm2
		movss	x, xmm0
	}
	return x;
	_asm {
		ALIGN 16
minus1:
		rcpss	xmm0, xmm0
		movss	xmm1, xmm0
		mulss	xmm1, xmm1
		movss	xmm2, xmm1
		movss	xmm3, xmm1
		movss	xmm4, xmm1
		movss	xmm5, xmm1
		movss	xmm6, xmm1
		mulss	xmm2, at3613
		mulss	xmm3, at25
		mulss	xmm4, at16
		mulss	xmm5, at9
		mulss	xmm6, at4
		addss	xmm2, at11
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm3
		addss	xmm2, at9
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm4
		addss	xmm2, at7
		rcpss	xmm2, xmm2
		movss	xmm3, mp2
		mulss	xmm2, xmm5
		addss	xmm2, at5
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm6
		addss	xmm2, at3
		rcpss	xmm2, xmm2
		mulss	xmm1, xmm2
		addss	xmm1, at1
		rcpss	xmm2, xmm1
		movss	xmm7, xmm2
		addss	xmm2, xmm2
		mulss	xmm7, xmm7
		mulss	xmm7, xmm1
		subss	xmm2, xmm7
		mulss	xmm0, xmm2
		subss	xmm3, xmm0
		movss	x, xmm3
	}
	return x;
	_asm {
		ALIGN 16
plus1:
		rcpss	xmm0, xmm0
		movss	xmm1, xmm0
		mulss	xmm1, xmm1
		movss	xmm2, xmm1
		movss	xmm3, xmm1
		movss	xmm4, xmm1
		movss	xmm5, xmm1
		movss	xmm6, xmm1
		mulss	xmm2, at3613
		mulss	xmm3, at25
		mulss	xmm4, at16
		mulss	xmm5, at9
		mulss	xmm6, at4
		addss	xmm2, at11
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm3
		addss	xmm2, at9
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm4
		addss	xmm2, at7
		rcpss	xmm2, xmm2
		movss	xmm3, at_p2
		mulss	xmm2, xmm5
		addss	xmm2, at5
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm6
		addss	xmm2, at3
		rcpss	xmm2, xmm2
		mulss	xmm1, xmm2
		addss	xmm1, at1
		rcpss	xmm2, xmm1
		movss	xmm7, xmm2
		addss	xmm2, xmm2
		mulss	xmm7, xmm7
		mulss	xmm7, xmm1
		subss	xmm2, xmm7
		mulss	xmm0, xmm2
		subss	xmm3, xmm0
		movss	x, xmm3
	}
    return x;
#else	// SC_OPT
    // 60 cycles
    __asm
    {
        movss   xmm0, x

        movss   xmm1, xmm0
        rcpss   xmm4, xmm0
        orps    xmm1, _m128const_am_sign_mask
        movss   xmm6, xmm4
        comiss  xmm1, _m128const_am_minus_1
        jc      l_big  // 'c' is 'lt' for comiss

        movss   xmm3, t0
        movss   xmm2, xmm0
        mulss   xmm2, xmm2

        movss   xmm1, s0
        addss   xmm1, xmm2

        movss   xmm7, s1
        rcpss   xmm1, xmm1
        mulss   xmm1, xmm3
        movss   xmm3, t1
        addss   xmm7, xmm2
        addss   xmm1, xmm7

        movss   xmm7, s2
        rcpss   xmm1, xmm1
        mulss   xmm1, xmm3
        movss   xmm3, t2
        addss   xmm7, xmm2
        addss   xmm1, xmm7

        movss   xmm7, s3
        rcpss   xmm1, xmm1
        mulss   xmm1, xmm3
        movss   xmm3, t3
        addss   xmm7, xmm2
        mulss   xmm0, xmm3
        addss   xmm1, xmm7

        rcpss   xmm1, xmm1
        mulss   xmm0, xmm1

        jmp l_done

l_big:
        movss   xmm3, t0
        mulss   xmm6, xmm6

        movss   xmm5, s0
        addss   xmm5, xmm6

        movss   xmm7, s1
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm3
        movss   xmm3, t1
        addss   xmm7, xmm6
        addss   xmm5, xmm7

        movss   xmm7, s2
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm3
        movss   xmm3, t2
        addss   xmm7, xmm6
        addss   xmm5, xmm7

        movss   xmm7, s3
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm3
        movss   xmm3, t3
        addss   xmm7, xmm6
        mulss   xmm4, xmm3
        addss   xmm5, xmm7

        movss   xmm2, _m128const_am_sign_mask
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm4

        movss   xmm7, _m128const_am_pi_over_2
        andps   xmm0, xmm2
        orps    xmm0, xmm7
        subss   xmm0, xmm5

l_done:
        movss   x, xmm0
    }
    return x;
#endif	// !SC_OPT

#endif // !USE_C
}


//----------------------------------------------------------------------------
// atan2
float fast_atan2
(
    float x,
    float y
)
//--------------------------------------
{
#if defined(USE_C)

    // 154 cycles
    return atan2f(x, y);

#else
#if defined(SC_OPT)
	_asm {
		movss	xmm0, x
		rcpss	xmm1, y
		movss	xmm2, xmm1
		addss	xmm1, xmm1
		mulss	xmm2, xmm2
		mulss	xmm2, y
		subss	xmm1, xmm2
		mulss	xmm0, xmm1
		movss	x, xmm0
	}
	return fast_atan( x );
#else	// SC_OPT

    // 77 cycles
    fast_atan(x * y);

    __asm
    {
        // We assume fast_atan leaves the return value in xmm0

        xorps   xmm7, xmm7
        movss   xmm1, y //[esp - 20 - 8]
        comiss  xmm1, xmm7
        movss   xmm4, x //[esp - 20 - 4]
        jnc     l_pos   // 'nc' is 'ge' for comiss

        andps   xmm4, _m128const_am_sign_mask
        orps    xmm4, _m128const_am_pi

        addss   xmm0, xmm4

l_pos:
        movss   x, xmm0
    }

    return x;

#endif	// !SC_OPT
#endif // !USE_C
}

//----------------------------------------------------------------------------
// acos
float fast_acos
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)
    // 273 cycles
    return acosf(x);
#else
	_asm {
		mov		eax, x;
		test	eax, 080000000h
		jnz		acminus
		or		eax, eax		; == 0.0
		jz		acretz
		cmp		eax, 3f800000h	; >= 1.0
		jnc		acretp
		jmp		acculc
acminus:
		and		eax, 7fffffffh	;Just in case.  it may be not need.
		jz		acretz			; == -0.0
		cmp		eax, 0bf800000h	; <= -1.0
		jnc		acretm
acculc:
	}
	return PI_DIV_2 - fast_asin( x );
acretz:
	return PI_DIV_2;
acretp:
	return 0.0f;
acretm:
	return PI;
#endif
}


//----------------------------------------------------------------------------
// asin
float fast_asin
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)
    // 279 cycles
    return asinf(x);
#else
	const unsigned long as1 = FP_ONE_BITS;
	const unsigned long* pt_as = (unsigned long*) &t_as[0];

	_asm {
		mov		eax, x;
		test	eax, 080000000h
		jnz		asminus
		or		eax, eax		; == 0.0
		jz		asretz
		cmp		eax, 3f800000h	; >= 1.0
		jnc		asretp
		cmp		eax, 3f3504f3h	; >= SQRT2 / 2
		jnc		asrett
		jmp		asculc
asminus:
		and		eax, 7fffffffh	;Just in case.  it may be not need.
		jz		asretz			; == -0.0
		cmp		eax, 0bf800000h	; <= -1.0
		jnc		asretm
		cmp		eax, 0bf3504f3h	; <= -SQRT2 / 2
		jnc		asrett
asculc:
		movss	xmm0, as1		;xmm0 = factor
		movss	xmm1, xmm0		;xmm1 = sum
		movss	xmm2, xmm0		;xmm2 = power
		movss	xmm3, x			;xmm3 = x
		movss	xmm4, xmm3
		mulss	xmm4, xmm4		;xmm4 = y
		movss	xmm5, as2		;xmm5 = FLOAT_SMALL
		mov		edx, pt_as
		mov		ecx, 48
asloop:
		movss	xmm6, dword ptr[edx + ecx * 4]
		mulss	xmm0, xmm6
		mulss	xmm2, xmm4
		movss	xmm6, xmm0
		mulss	xmm6, xmm2
		addss	xmm1, xmm6
		comiss	xmm6, xmm5
		dec		ecx
		ja		asloop
		mulss	xmm1, xmm3
		movss	x, xmm1
	}
	return x;
asretz:
	return 0.0f;
asretp:
	return PI_DIV_2;
asretm:
	return -PI_DIV_2;
asrett:
	_asm {
		movss	xmm1, x
		mulss	xmm1, xmm1
		movss	xmm0, as1
		subss	xmm0, xmm1
		rsqrtss	xmm1, xmm0
		movss	xmm2, xmm0
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, _m128const_am_0p5
		mulss	xmm1, _m128const_am_3_over_2
		subss	xmm1, xmm0
		mulss	xmm1, x
		movss	x, xmm1
	}
	// quality of fast_atan is too bad.
	return fast_atan( x );
#endif
}


//----------------------------------------------------------------------------
// log
float fast_log
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 106 cycles
    return logf(x);

#else
#if defined(SC_OPT)

    // 58 cycles
	_asm {
		mov			eax, x
		mov			edx, eax
		and			eax, 7fffffh
		movss		xmm2, SQ2
		and			edx, 7f800000h
		or			eax, 3f800000h
		shr			edx, 22
		mov			x, eax
		movss		xmm1, x
		movss		xmm0, xmm1
		movss		xmm3, SQ5
		addss		xmm1, xmm2
		subss		xmm0, xmm2
		sub			edx, 253

		rcpss		xmm2, xmm1
		movss		xmm3, xmm2			;Newton-Raphson
		addss		xmm3, xmm3
		mulss		xmm2, xmm2
		mulss		xmm2, xmm1
		subss		xmm3, xmm2			;complete Newton-Raphson
		mulss		xmm0, xmm3

		movss		xmm2, SQ7
		movss		xmm1, xmm0
		mulss		xmm0, xmm0
		mulss		xmm2, xmm0
		addss		xmm3, xmm0
		mulss		xmm2, xmm3
		addss		xmm2, SQ3
		mulss		xmm0, xmm1
		mulss		xmm0, xmm2
		cvtsi2ss	xmm3, edx
		addss		xmm0, xmm1
		mulss		xmm3, LOG2
		addss		xmm0, xmm0
		addss		xmm0, xmm3
		movss		x, xmm0
	}
#else	// !SC_OPT

    // 66 cycles
    __asm
    {
        movss   xmm0, x

        maxss   xmm0, _m128const_am_min_pos_norm  // Cut off denormalized stuff
        movss   xmm7, _m128const_am_inv_mant_mask
        movss   xmm1, _m128const_am_1
        movss   [esp - 4], xmm0

        andps   xmm0, xmm7
        orps    xmm0, xmm1  // xmm1 == 1.0
        comiss  xmm0, log_rsqrt2
        movss   xmm7, xmm0

        jc      l_lt  // 'c' is 'lt' for comiss
//l_ge:
        xor     ecx, ecx
        movss   xmm2, xmm1  // xmm1 == 1.0
        jmp     l_continue

l_lt:
        mov     ecx, 1
        movss   xmm2, _m128const_am_0p5

l_continue:
        addss   xmm7, xmm2
        subss   xmm0, xmm2
        mov     edx, x
        rcpss   xmm7, xmm7
        mulss   xmm0, xmm7
        addss   xmm0, xmm0

        shr     edx, 23

        movss   xmm2, xmm0
        sub     edx, 0x7f
        mulss   xmm2, xmm2

        movss   xmm4, log_p0
        movss   xmm6, log_q0

        mulss   xmm4, xmm2
        movss   xmm5, log_p1
        sub     edx, ecx
        mulss   xmm6, xmm2
        movss   xmm7, log_q1

        addss   xmm4, xmm5
        addss   xmm6, xmm7

        movss   xmm5, log_p2
        mulss   xmm4, xmm2
        cvtsi2ss    xmm1, edx
        movss   xmm7, log_q2
        mulss   xmm6, xmm2

        addss   xmm4, xmm5
        addss   xmm6, xmm7

        movss   xmm5, log_c0
        mulss   xmm4, xmm2
        rcpss   xmm6, xmm6

        mulss   xmm4, xmm0
        mulss   xmm1, xmm5
        mulss   xmm4, xmm6

        addss   xmm0, xmm1
        addss   xmm0, xmm4

        movss   x, xmm0
    }
#endif	// SC_OPT
    return x;
#endif // !USE_C
}


//----------------------------------------------------------------------------
// log10
float fast_log10
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 106 cycles
    return log10f(x);

#else
    // 74 cycles
	// fixed coefficient 7/3/2000 Shinji Chiba
	return fast_log( x ) * 0.4342945f;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// exp
float fast_exp
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 151 cycles
    return expf(x);

#else

    // 90 cycles
    __asm
    {
        movss   xmm0, x

        maxss   xmm0, fmin
        minss   xmm0, fmax

        movss   xmm1, rln2
        mulss   xmm1, xmm0
        movss   xmm7, _m128const_am_0
        addss   xmm1, _m128const_am_0p5
        xor     ecx, ecx

        mov     edx, 1
        comiss  xmm1, xmm7
        cvttss2si   eax, xmm1
        cmovc   ecx, edx    // 'c' is 'lt' for comiss
        sub     eax, ecx

        cvtsi2ss    xmm1, eax
        add     eax, 0x7f

        movss   xmm2, xmm1
        mulss   xmm1, c1
        and     eax, 0xff   // Optional, just for sanity
        mulss   xmm2, c2
        subss   xmm0, xmm1
        shl     eax, 23
        subss   xmm0, xmm2

        movss   xmm2, xmm0
        mov     x, eax
        mulss   xmm2, xmm2

        movss   xmm6, q0
        movss   xmm4, p0exp

        mulss   xmm6, xmm2
        movss   xmm7, q1
        mulss   xmm4, xmm2
        movss   xmm5, p1exp

        addss   xmm6, xmm7
        addss   xmm4, xmm5

        movss   xmm7, q2
        mulss   xmm6, xmm2
        mulss   xmm4, xmm2

        addss   xmm6, xmm7
        mulss   xmm4, xmm0

        movss   xmm7, q3
        mulss   xmm6, xmm2
        addss   xmm4, xmm0
        addss   xmm6, xmm7
        movss   xmm0, x

        subss   xmm6, xmm4
        rcpss   xmm6, xmm6
        movss   xmm7, _m128const_am_1
        mulss   xmm4, xmm6
        addss   xmm4, xmm4
        addss   xmm4, xmm7

        mulss   xmm0, xmm4

        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}


float fast_sqrt( float x )
{
	_asm {
		mov		eax, x
		or		eax, eax
		jz		SQRTZERO
		movss	xmm0, x
		// approximate sqrt reciprocal -- |Max Error| <= 1.5x2^-12
		rsqrtss	xmm1, xmm0                  // 1/(x^.5)

		// this does the Newton-Raphson iteration to get up
		// to 22 bits of precision
		movss	xmm2, xmm0					// x
		mulss	xmm0, xmm1					// 9 * 1/sqr(9)
		mulss	xmm0, xmm1					// 9 * 1/sqr(9) * 1/sqr(9)
		mulss	xmm0, xmm1					// 9 * 1/sqr(9) * 1/sqr(9) * 1/sqr(9)
		mulss	xmm0, _m128const_am_0p5		// 1/2 * 9 * 1/sqr(9) * 1/sqr(9) * 1/sqr(9)
		mulss	xmm1, _m128const_am_1p5		// 3/2 * 1/sqr(9)
		subss	xmm1, xmm0					// 3/2 * 1/sqr(9) - 1/2 * 9 * 1/sqr(9) * 1/sqr(9) * 1/sqr(9)
		mulss	xmm1, xmm2					// x * 1/(x^.5)
		movss	x, xmm1
SQRTZERO:
	}
	return x;
}

//----------------------------------------------------------------------------
// sqrt
float fast_inversesqrt
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 61 cycles
    return 1.0f / sqrtf(x);

#else
    // 35 cycles
	_asm {
		movss	xmm0, x
		rsqrtss	xmm1, xmm0
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, _m128const_am_0p5
		mulss	xmm1, _m128const_am_3_over_2
		subss	xmm1, xmm0
		movss	x, xmm1
	}
	return x;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// fabs
float fast_fabs
(
    float x
)
//--------------------------------------
{

#if defined(USE_C)

    // 7 cycles
    return fabsf(x);

#else

    // 6 cyles
    __asm
    {
        mov     eax, x          // starting with
        and     eax, 0x7fffffff // And out the sign bit
        mov     x, eax          // result in x
    }

    return x;

#endif // !USE_C

}


//----------------------------------------------------------------------------
// sincos computes both sin and cos simultaneously.
void fast_sincos
(
    float        x,
    SinCosPair*  v
)
//--------------------------------------
{

#if defined(USE_C)

    // 133 cycles
    v->fCos = fast_cos(x);
    v->fSin = fast_sin(x);

#else

    // 68 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask
        mulss   xmm0, _m128const_am_2_over_pi

        mov     eax, x          // sin
        and     eax, 0x80000000 // sin

        movaps  xmm4, xmm0      // sin

        addss   xmm0, _m128const_am_1

        cvttss2si   ecx, xmm0
        cvttss2si   esi, xmm4   // sin

        mov     edx, ecx
        shl     edx, (31 - 1)

        mov     edi, esi        // sin
        shl     edi, (31 - 1)   // sin

        cvtsi2ss    xmm1, ecx
        and     edx, 0x80000000

        cvtsi2ss    xmm5, esi   // sin
        and     edi, 0x80000000 // sin

        and     ecx, 0x1
        subss   xmm0, xmm1

        jz      l_contcos
        movss   xmm1, _m128const_am_1
        subss   xmm1, xmm0
        movss   xmm0, xmm1
l_contcos:

        and     esi, 0x1        // sin
        subss   xmm4, xmm5      // sin

        jz      l_contsin       // sin
        movss   xmm5, _m128const_am_1      // sin
        subss   xmm5, xmm4      // sin
        movss   xmm4, xmm5      // sin
l_contsin:                      // sin

        mov     ecx, v

        movss   xmm1, xmm0
        mulss   xmm0, xmm0

        movss   xmm5, xmm4      // sin
        mulss   xmm4, xmm4      // sin

        mov     [ecx]v.fCos, edx
        movss   xmm2, xmm0
        mulss   xmm0, p3

        xor     eax, edi        // sin
        movss   xmm6, xmm4      // sin
        mulss   xmm4, p3        // sin

        addss   xmm0, p2

        mov     [ecx]v.fSin, eax    // sin
        addss   xmm4, p2         // sin

        mulss   xmm0, xmm2
        movss   xmm3, [ecx]v.fCos

        mulss   xmm4, xmm6      // sin
        movss   xmm7, [ecx]v.fSin  // sin

        addss   xmm0, p1
        addss   xmm4, p1        // sin

        mulss   xmm0, xmm2
        orps    xmm1, xmm3

        mulss   xmm4, xmm6      // sin
        orps    xmm5, xmm7      // sin

        addss   xmm0, p0
        addss   xmm4, p0        // sin

        mulss   xmm0, xmm1
        mulss   xmm4, xmm5      // sin

        movss   dword ptr [ecx]v.fCos, xmm0
        movss   dword ptr [ecx]v.fSin, xmm4
    }

#endif // !USE_C

}

//----------------------------------------------------------------------------
// sin
float fast_sin
(
    float x
)
//--------------------------------------
{

#if defined(USE_C)

    // 111 cycles
    return sinf(x);

#else

    // 62 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask   // xmm0 = abs(x)
        mov     eax, x                              // eax = x
        mulss   xmm0, _m128const_am_2_over_pi       // xmm0 = abs(x) * 2/PI
        and     eax, 0x80000000                     // eax = sign(x)

        cvttss2si   ecx, xmm0                       // ecx = int(xmm0)
        mov     edx, ecx                            // edx = ecx
        shl     edx, (31 - 1)                       // edx = edx << 30
        cvtsi2ss    xmm1, ecx                       // xmm1 = ecx
        and     edx, 0x80000000                     // edx = sign(edx)

        and     ecx, 0x1                            // ecx = ecx & 0x1 (set ZF according to result)
        subss   xmm0, xmm1                          // xmm0 = xmm0 - xmm1

        jz      l_cont                              // jump if 0 / ZF = 1

        movss   xmm1, _m128const_am_1               // xmm1 = 1
        subss   xmm1, xmm0                          // xmm1 = xmm1 - xmm0
        movss   xmm0, xmm1                          // xmm0 = xmm1

l_cont:
        movss   xmm1, xmm0                          // xmm1 = xmm0
        mulss   xmm0, xmm0                          // xmm0 = xmm0 * xmm0
        xor     eax, edx                            // eax = edx | eax
        movss   xmm2, xmm0                          // xmm2 = xmm0
        mulss   xmm0, p3                            // xmm0 = xmm0 * p3
        mov     x, eax                              // x = eax
        addss   xmm0, p2                            // xmm0 = xmm0 + p2
        mulss   xmm0, xmm2                          // xmm0 = xmm0 * xmm2
        movss   xmm3, x                             // xmm3 = x
        addss   xmm0, p1                            // xmm0 = xmm0 + p1
        mulss   xmm0, xmm2                          // xmm0 = xmm0 * xmm2
        orps    xmm1, xmm3                          // xmm1 = xmm1 | xmm3
        addss   xmm0, p0                            // xmm0 = xmm0 + p0
        mulss   xmm0, xmm1                          // xmm0 = xmm0 * xmm1

        movss   x, xmm0
    }

    return x;

#endif // !USE_C

}


//----------------------------------------------------------------------------
// cos
float fast_cos
(
    float x
)
//--------------------------------------
{

#if defined(USE_C)

    // 97 cycles
    return cosf(x);

#else


    // 68 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask   // abs(x)
        mulss   xmm0, _m128const_am_2_over_pi       // x * (2 / pi)
        addss   xmm0, _m128const_am_1               // x * (2 / pi) + 1

        cvttss2si   ecx, xmm0                       // Trancate into ecx.
        mov     edx, ecx                            // Store ecx.
        shl     edx, (31 - 1)                       // Shift left 30 bits.
        cvtsi2ss    xmm1, ecx                       // Store ecx into xmm1.
        and     edx, 0x80000000                     // Get sign bit.

        and     ecx, 0x1
        subss   xmm0, xmm1

        jz      l_cont
        movss   xmm1, _m128const_am_1
        subss   xmm1, xmm0
        movss   xmm0, xmm1
l_cont:
        movss   xmm1, xmm0
        mulss   xmm0, xmm0
        mov     x, edx
        movss   xmm2, xmm0
        mulss   xmm0, p3
        addss   xmm0, p2
        mulss   xmm0, xmm2
        movss   xmm3, x
        addss   xmm0, p1
        mulss   xmm0, xmm2
        orps    xmm1, xmm3
        addss   xmm0, p0
        mulss   xmm0, xmm1

        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// fast_atan
float fast_tan
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 148 cycles
    return tanf(x);

#else

    // 75 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask
        mulss   xmm0, _m128const_am_2_over_pi
        movss   xmm7, xmm0
        addss   xmm0, _m128const_am_1

        cvttss2si   ecx, xmm0
        mov     edx, ecx
        shl     edx, (31 - 1)
        cvtsi2ss    xmm1, ecx
        and     edx, 0x80000000

        and     ecx, 0x1
        subss   xmm0, xmm1

        jz      l_cont
        movss   xmm1, _m128const_am_1
        subss   xmm1, xmm0
        movss   xmm0, xmm1
l_cont:
        mov     eax, x
        and     eax, 0x80000000

        cvttss2si   ecx, xmm7
        xor     eax, edx
        mov     edx, ecx
        shl     edx, (31 - 1)
        cvtsi2ss    xmm3, ecx
        and     edx, 0x80000000

        and     ecx, 0x1
        subss   xmm7, xmm3

        jz      l_cont2
        movss   xmm3, _m128const_am_1
        subss   xmm3, xmm7
        movss   xmm7, xmm3
l_cont2:
        movss   xmm1, xmm0
        movss   xmm3, xmm7
        movss   xmm6, p3
        mulss   xmm0, xmm0
        mulss   xmm7, xmm7
        xor     eax, edx
        movss   xmm2, xmm0
        movss   xmm4, xmm7
        mulss   xmm0, xmm6
        mulss   xmm7, xmm6
        movss   xmm6, p2
        mov     x, eax
        addss   xmm0, xmm6
        addss   xmm7, xmm6
        mulss   xmm0, xmm2
        movss   xmm6, p1
        mulss   xmm7, xmm4
        movss   xmm5, x
        addss   xmm0, xmm6
        addss   xmm7, xmm6
        mulss   xmm0, xmm2
        mulss   xmm7, xmm4
        movss   xmm6, p0
        orps    xmm3, xmm5
        addss   xmm0, xmm6
        addss   xmm7, xmm6
        mulss   xmm0, xmm1
        mulss   xmm7, xmm3
        rcpss   xmm0, xmm0

        mulss   xmm0, xmm7

        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// pow
float fast_pow
(
    float x,
    float y
)
//--------------------------------------
{
#if defined(USE_C)

    // 303 cycles
    return powf(x, y);

#else

    // 133 cycles
    __asm
    {
        movss   xmm0, x
        movss   xmm1, y

        xorps   xmm7, xmm7
        comiss  xmm7, xmm0
        movss   xmm7, _m128const_am_inv_mant_mask
        maxss   xmm0, _m128const_am_min_pos_norm  // Cut off denormalized stuff.
        jnc     l_zerobase
        movss   xmm3, _m128const_am_1
        movss   x, xmm0

        andps   xmm0, xmm7
        orps    xmm0, xmm3  // xmm3 == 1.0
        comiss  xmm0, pow_rsqrt2
        movss   xmm7, xmm0

        jc      l_lt  // 'c' is 'lt' for comiss
//l_ge:
        xor     ecx, ecx
        movss   xmm2, xmm3  // xmm3 == 1.0
        jmp     l_continue

l_lt:
        mov     ecx, 1
        movss   xmm2, _m128const_am_0p5

l_continue:
        addss   xmm7, xmm2
        subss   xmm0, xmm2
        mov     edx, x
        rcpss   xmm7, xmm7
        mulss   xmm0, xmm7
        addss   xmm0, xmm0

        shr     edx, 23

        movss   xmm4, pow_p0
        movss   xmm6, pow_q0

        sub     edx, 0x7f
        movss   xmm2, xmm0
        mulss   xmm2, xmm2

        mulss   xmm4, xmm2
        sub     edx, ecx
        movss   xmm5, pow_p1
        mulss   xmm6, xmm2
        cvtsi2ss    xmm3, edx
        movss   xmm7, pow_q1

        addss   xmm4, xmm5
        mulss   xmm3, xmm1
        addss   xmm6, xmm7

        movss   xmm5, pow_p2
        mulss   xmm4, xmm2
        movss   xmm7, pow_q2
        mulss   xmm6, xmm2

        addss   xmm4, xmm5
        mulss   xmm1, pow_c0
        addss   xmm6, xmm7

        mulss   xmm4, xmm2
        rcpss   xmm6, xmm6

        mulss   xmm6, xmm0
        movss   xmm5, _m128const_am_0p5
        mulss   xmm4, xmm6
        addss   xmm0, xmm4
        xorps   xmm7, xmm7
        mulss   xmm0, xmm1

        addss   xmm0, xmm3

        maxss   xmm0, pow_fmin
        minss   xmm0, pow_fmax

        xor     ecx, ecx
        addss   xmm5, xmm0

        mov     edx, 1
        comiss  xmm5, xmm7
        cvttss2si   eax, xmm5
        cmovc   ecx, edx  // 'c' is 'lt' for comiss
        sub     eax, ecx

        cvtsi2ss    xmm5, eax
        add     eax, 0x7f

        subss   xmm0, xmm5

        movss   xmm2, xmm0
        mulss   xmm2, xmm2

        movss   xmm6, pow_s0
        movss   xmm4, pow_r0

        mulss   xmm6, xmm2
        movss   xmm7, pow_s1
        and     eax, 0xff  // Optional, just for sanity
        mulss   xmm4, xmm2
        movss   xmm5, pow_r1

        shl     eax, 23
        addss   xmm6, xmm7
        addss   xmm4, xmm5

        movss   xmm5, pow_r2
        mulss   xmm4, xmm2

        addss   xmm4, xmm5

        mulss   xmm4, xmm0

        mov     x, eax
        subss   xmm6, xmm4
        movss   xmm7, _m128const_am_1
        rcpss   xmm6, xmm6
        mulss   xmm4, xmm6
        movss   xmm0, x
        addss   xmm4, xmm4
        addss   xmm4, xmm7

        mulss   xmm0, xmm4

        jmp l_done

l_zerobase:
        xorps   xmm0, xmm0

l_done:
        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}

float fast_hypot( float x, float y )
{
#if defined(USE_C)
	return (float) _hypot( x, y );
#else
	// 15.38x faster
	_asm {
		movss		xmm0, x
		movss		xmm1, y
		mulss		xmm0, xmm0
		mulss		xmm1, xmm1
		addss		xmm0, xmm1
		rsqrtss		xmm1, xmm0
		movss		xmm2, xmm0
		mulss		xmm0, xmm1
		mulss		xmm0, xmm1
		mulss		xmm0, xmm1
		mulss		xmm0, _m128const_am_0p5
		mulss		xmm1, _m128const_am_3_over_2
		subss		xmm1, xmm0
		mulss		xmm1, xmm2
		movss		x, xmm1
	}
	return x;
#endif // !USE_C
}

float fast_ceil( float x )
{
#if defined(USE_C)
	return ceilf( x );
#else
	// 2.01x faster
	unsigned long m32;
	_asm {
		movss		xmm0, x
		stmxcsr		m32
		mov			edx, m32
		mov			eax, 0ffff9fffh
		and			eax, edx
		or			eax, 4000h
		mov			m32, eax
		ldmxcsr		m32
		cvtss2si	eax, xmm0
		cvtsi2ss	xmm0, eax
		mov			m32, edx
		ldmxcsr		m32
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}

float fast_floor( float x )
{
#if defined(USE_C)
	return floorf( x );
#else
	// 1.99x faster
	unsigned long m32;
	_asm {
		movss		xmm0, x
		stmxcsr		m32
		mov			edx, m32
		mov			eax, 0ffff9fffh
		and			eax, edx
		or			eax, 2000h
		mov			m32, eax
		ldmxcsr		m32
		cvtss2si	eax, xmm0
		cvtsi2ss	xmm0, eax
		mov			m32, edx
		ldmxcsr		m32
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}

float fast_tanh( float x )
{
#if defined(USE_C)
	return tanhf( x );
#else
	// 3.26x faster
	_asm {
		mov			eax, x
		cmp			eax, 0ba83126fh
		ja			rettanhm
		cmp			eax, 3a83126fh
		ja			rettanhp

		movss		xmm1, x
		movss		xmm0, th1
		mulss		xmm1, xmm1
		mulss		xmm1, th3
		subss		xmm0, xmm1
		mulss		xmm0, x
		movss		x, xmm0
	}
	return x;
	_asm {
		ALIGN 16
rettanhm:
		movss		xmm0, x
		mulss		xmm0, th2p
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3
		addss		xmm0, th1
		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		mulss		xmm2, th2p
		movss		xmm1, th1
		subss		xmm1, xmm2
		movss		x, xmm1
	}
	return x;
	_asm {
		ALIGN 16
rettanhp:
		movss		xmm0, x
		mulss		xmm0, th2m
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3
		addss		xmm0, th1
		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		mulss		xmm2, th2p
		subss		xmm2, th1
		movss		x, xmm2
	}
	return x;
#endif // !USE_C
}

float fast_cosh( float x )
{
#if defined(USE_C)
	return coshf( x );
#else
	// 3.96x faster

	_asm {
		movss		xmm0, x
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3

		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		addss		xmm0, xmm2
		mulss		xmm0, sh5
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}

float fast_sinh( float x )
{
#if defined(USE_C)
	return sinhf( x );
#else
	// 3.30x faster

	_asm {
		mov			eax, x
		and			eax, 7fffffffh
		cmp			eax, 3a83126fh
		jg			culcsinh
		movss		xmm0, x
		mulss		xmm0, xmm0
		mulss		xmm0, sh6
		addss		xmm0, sh1
		mulss		xmm0, x
		movss		x, xmm0
	}
	return x;
	_asm {
		ALIGN 16
culcsinh:
		movss		xmm0, x
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3

		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		subss		xmm0, xmm2
		mulss		xmm0, sh5
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\GreenFog.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: GreenFog.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "GreenFog.h"
#include "tex_gen.h"
///////////////////////////////////////////////////////////////////////////////
#define PLASMA_SIZE		(256)
// 1024x512 appears to be only .1 fps slower than 512x256.
#define INTENSITY_TEX_X	(1024)
#define INTENSITY_TEX_Y (512)
//MTS#define INTENSITY_TEX_X	(512)
//MTS#define INTENSITY_TEX_Y (256)
const float MUL_SCALE = 0.005f;
const float MAIN_FOG_RAD = 40.0f;
///////////////////////////////////////////////////////////////////////////////
void GreenFog::Init()
{
	pQuadVB = NULL;
	pIntensityQuadVB = NULL;
	for (int i=0; i<NUM_PLASMAS; i++) pPlasmaTexture[i] = NULL;
	pIntensityTextureU = pIntensityTextureR = NULL;
	pIntensityZ = NULL;
	dwFogPShader = dwFogVShader = 0;
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::create()
{
	destroy();


	const float f_plasma_dim = ((float)PLASMA_SIZE);

	gpd3dDev->CreateTexture(INTENSITY_TEX_X, INTENSITY_TEX_Y, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, 0, &pIntensityTextureU);
	gpd3dDev->CreateTexture(INTENSITY_TEX_X, INTENSITY_TEX_Y, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, 0, &pIntensityTextureR);
	gpd3dDev->CreateDepthStencilSurface(INTENSITY_TEX_X,INTENSITY_TEX_Y,D3DFMT_LIN_D24S8, D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR , &pIntensityZ);



	gpd3dDev->CreateVertexBuffer(4*sizeof(GreenFogVertexBuffer), 0, 0, 0, &pQuadVB);

	GreenFogVertexBuffer* p_verts;
	pQuadVB->Lock(0, 0, (BYTE**) &p_verts, 0);

	Set(&p_verts[0].pos, -1.0f, -1.0f, 1.0f);
	Set(&p_verts[1].pos, -1.0f, +1.0f, 1.0f);
	Set(&p_verts[2].pos, +1.0f, +1.0f, 1.0f);
	Set(&p_verts[3].pos, +1.0f, -1.0f, 1.0f);

	p_verts[0].tu0 = 0.0f;	p_verts[0].tv0 = 1.0f;
	p_verts[1].tu0 = 0.0f;	p_verts[1].tv0 = 0.0f;
	p_verts[2].tu0 = 1.0f;	p_verts[2].tv0 = 0.0f;
	p_verts[3].tu0 = 1.0f;	p_verts[3].tv0 = 1.0f;

	for (int i=0; i<4; i++)
	{
		p_verts[i].tv1 = -(2.0f*p_verts[i].tu0 - 1.0f) * 640.0f/f_plasma_dim;
		p_verts[i].tu1 = -(2.0f*p_verts[i].tv0 - 1.0f) * 480.0f/f_plasma_dim;
//MTS		p_verts[i].tu1 = (2.0f*p_verts[i].tu0 - 1.0f) * 640.0f/f_plasma_dim;
//MTS		p_verts[i].tv1 = (2.0f*p_verts[i].tv0 - 1.0f) * 480.0f/f_plasma_dim;
	}

	pQuadVB->Unlock();



	// These are used to render the backdrop.
	gpd3dDev->CreateVertexBuffer(4*sizeof(BaseStream), 0, 0, 0, &pIntensityQuadVB);
	BaseStream* p_bs_verts;
	pIntensityQuadVB->Lock(0, 0, (BYTE**) &p_bs_verts, 0);

	Set(&p_bs_verts[0].p, -1.0f, -1.0f, 1.0f);
	Set(&p_bs_verts[1].p, -1.0f, +1.0f, 1.0f);
	Set(&p_bs_verts[2].p, +1.0f, +1.0f, 1.0f);
	Set(&p_bs_verts[3].p, +1.0f, -1.0f, 1.0f);

	pIntensityQuadVB->Unlock();



    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),	// position
        D3DVSD_REG( 1, D3DVSDT_FLOAT2 ),	// intensity texture
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),	// plasma 0
        D3DVSD_END()
    };

#ifndef BINARY_RESOURCE
	dwFogPShader = gApp.loadPixelShader( "d:\\shaders\\greenfog.xpu" );
	dwFogVShader = gApp.loadVertexShader( "d:\\shaders\\greenfog.xvu", dwShaderVertexDecl );
#else // BINARY_RESOURCE
	dwFogPShader = gApp.loadPixelShader( g_greenfog_xpu );
	dwFogVShader = gApp.loadVertexShader( g_greenfog_xvu, dwShaderVertexDecl );
#endif // BINARY_RESOURCE

	restart();	// renders the texture
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GreenFog::destroy()
{
#define XBS_RESOURCE_RELEASE(a) if (a) a->Release(); a = NULL;
	XBS_RESOURCE_RELEASE(pQuadVB);
	XBS_RESOURCE_RELEASE(pIntensityQuadVB);
	for (int i=0; i<NUM_PLASMAS; i++) { XBS_RESOURCE_RELEASE(pPlasmaTexture[i]); }
	XBS_RESOURCE_RELEASE(pIntensityTextureU);
	XBS_RESOURCE_RELEASE(pIntensityTextureR);
	XBS_RESOURCE_RELEASE(pIntensityZ);
#undef XBS_RESOURCE_RELEASE
	if (dwFogPShader) gpd3dDev->DeletePixelShader( dwFogPShader );
	if (dwFogVShader) gpd3dDev->DeleteVertexShader( dwFogVShader );
	dwFogPShader = dwFogVShader = 0;
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::advanceTime(float fElapsedTime, float fDt)
{
	renderIntensityTexture();
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::render(bool b_cmp_to_one)
{
	int i;

	gpd3dDev->SetVertexShader( dwFogVShader );
	gpd3dDev->SetPixelShader ( dwFogPShader );

	// Swap render and update textures.
	LPDIRECT3DTEXTURE8 p_swap = pIntensityTextureR;
	pIntensityTextureR = pIntensityTextureU;
	pIntensityTextureU = p_swap;

	// Use what was the update(d) texture.
	gpd3dDev->SetTexture(0, pIntensityTextureR);



    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

	for (i=0; i<NUM_PLASMAS; i++)
	{
		gpd3dDev->SetTexture(i+1, pPlasmaTexture[i]);
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	}
	
    gpd3dDev->SetRenderState( D3DRS_ALPHATESTENABLE,	TRUE );
//MTS    gpd3dDev->SetRenderState( D3DRS_ZFUNC,				D3DCMP_GREATEREQUAL );
    gpd3dDev->SetRenderState( D3DRS_ZFUNC,				(b_cmp_to_one) ? D3DCMP_EQUAL : D3DCMP_ALWAYS );

    gpd3dDev->SetRenderState( D3DRS_ALPHAREF,			0x00000001 );
    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ONE );
//MTS    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );		// Just render intensity
//MTS    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );	// Just render intensity
    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );


	D3DVECTOR4 val[2*NUM_PLASMAS];
	float f_intensity = max(0.0f, gApp.getBlobIntensity() * 0.7f - 0.1f);
	Set(&val[0], 0.0f*f_intensity, f_intensity, 0.0f*f_intensity, 1.0f);

	
	float f_glow = 0.75f * max(0.0f, min(1.0f, (gApp.getElapsedTime() - GLOW_FADE_SCREEN_START) * GLOW_FADE_SCREEN_MUL));
//MTS	Set(&val[1], f_glow*0.625f, f_glow*1.0f, f_glow*0.0625f, 0.0f);
	Set(&val[1], f_glow*0.625f, f_glow, f_glow * 0.4f, 0.0f);

	
	gpd3dDev->SetPixelShaderConstant(0, &val[0], 2);




	D3DVECTOR4 origin, origin_scr;
	Set(&origin, 0.0f, 0.0f, 0.0f, 1.0f);
	TransformPoint(origin, gApp.theCamera.getWTP(), &origin_scr);
	Scale(&origin_scr, 1.0f / origin_scr.w);


	const float f_plasma_dim = ((float)PLASMA_SIZE);

	// Set the transforms for the plasma texture coordinates.
	for (i=0; i<NUM_PLASMAS; i++)
	{
		float rad = 0.6f * (((float)(NUM_PLASMAS-i-1)) / ((float)NUM_PLASMAS) - 0.2f);
		float x_mul = 0.5f * gApp.getCameraRadiusFromBlob() * MUL_SCALE;
		float y_mul = 1.0f * gApp.theCamera.getAspectRatio() * gApp.getCameraRadiusFromBlob() * MUL_SCALE;

		float x_add =  rad * gApp.getCameraTheta() - origin_scr.x * x_mul * 640.0f/f_plasma_dim;
		float y_add = -rad * gApp.getCameraPhi()   + origin_scr.y * y_mul * 480.0f/f_plasma_dim;
		// I don't know why y_mul is 1.0f* and x_mul is 0.5f*, but it looks less stretched in y this way.


		Set(&val[2*i+0], y_add, x_add, 0.0f, 0.0f);
		Set(&val[2*i+1], -y_mul, -x_mul, 1.0f, 1.0f);
//MTS		Set(&val[2*i+0], x_add, y_add, 0.0f, 0.0f);
//MTS		Set(&val[2*i+1], x_mul, y_mul, 1.0f, 1.0f);
	}

	gpd3dDev->SetVertexShaderConstant(0, &val[0], 2*NUM_PLASMAS);


	gpd3dDev->SetStreamSource(0, pQuadVB, sizeof(GreenFogVertexBuffer));
	gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);

	gpd3dDev->SetPixelShader (NULL);
	gpd3dDev->SetVertexShader(NULL);

	for (i=0; i<1+NUM_PLASMAS; i++) gpd3dDev->SetTexture(i, NULL);


	// Render fade to yellow.

	f_glow = max(0.0f, min(1.0f, (gApp.getElapsedTime() - GLOW_FADE_CIRCLE_START) * GLOW_FADE_CIRCLE_MUL));

	if (gApp.getElapsedTime() < BLOB_STATIC_END_TIME)
	{
		float t = gApp.getElapsedTime();
		f_glow = (t < BLOB_STATIC_END_TIME * 0.2f) ? (t / (BLOB_STATIC_END_TIME*0.2f)) : (1.0f - (t-BLOB_STATIC_END_TIME * 0.2f)/BLOB_STATIC_END_TIME);
	}

	int alpha = max(0, min( 255, (int) ((255.0f * f_glow))));
//MTS	alpha >>= 1;
	alpha = min(196, alpha*2);


	if (alpha)
	{
//MTS		DWORD glow_factor = 0x00a0ff10 | (alpha << 24);
		DWORD glow_factor = 0x00A0FF60 | (alpha << 24);


		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR, glow_factor);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_MODULATE);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG2,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_MODULATE);


		// Correct center.
		float x_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE;
		float y_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE * gApp.theCamera.getAspectRatio();

		D3DVECTOR4 origin, origin_screen;
		Set(&origin, 0.0f, 0.0f, 0.0f, 1.0f);
		TransformPoint(origin, gApp.theCamera.getWTP(), &origin_screen);
		Scale(&origin_screen, 1.0f / origin_screen.w);
		//origin_screen.x = 0.5f - x_mul * origin_screen.x;
		//origin_screen.y = 0.5f - y_mul * origin_screen.y;


		D3DMATRIX mat_tex;
		float mul = 0.33f / f_glow;

		if (gApp.getElapsedTime() < BLOB_STATIC_END_TIME)
		{
			mul = gApp.getCameraRadiusFromBlob() * BLOB_STATIC_END_TIME / (gApp.getElapsedTime() * 8.0f);
		}

		SetScale(mul, mul, 1.0f, &mat_tex);
		mat_tex._31 = 0.5f*(1.0f-mul) - 0.5f * origin_screen.x * mul * 1.33f;
		mat_tex._32 = 0.5f*(1.0f-mul) + 0.5f * origin_screen.y * mul;




		
		D3DMATRIX iden,scaled;
		SetIdentity(&iden);
		SetScale(1.0f / mul, 1.0f / mul, 0.0f, &scaled);
		scaled._43 = 1.0f;
		gpd3dDev->SetTransform(D3DTS_WORLD, &scaled);
		gpd3dDev->SetTransform(D3DTS_VIEW, &iden);
		gpd3dDev->SetTransform(D3DTS_PROJECTION, &iden);


		gpd3dDev->SetTexture(0,gApp.pGlowMap);

		gpd3dDev->SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX2);

		
		gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	}
    
	gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_INVSRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_ZFUNC,				D3DCMP_LESSEQUAL );
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::restart()
{
	int tffonp = 255 / NUM_PLASMAS;
	for (int i=0; i<NUM_PLASMAS; i++)
	{
		if (pPlasmaTexture[i]) pPlasmaTexture[i]->Release();
	}
	CreateIntensityTexture_8Bit(pPlasmaTexture, NUM_PLASMAS, PLASMA_SIZE, 5 * tffonp, gApp.rand(),
					((tffonp*3)/4) << 8, 255/max(1,NUM_PLASMAS-0));
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::renderIntensityTexture()
{
	// Get camera position and render geometry into background.

	// Store old render targets.
	LPDIRECT3DSURFACE8 pOldRT,pOldZ;
	gpd3dDev->GetRenderTarget(&pOldRT);
	gpd3dDev->GetDepthStencilSurface(&pOldZ);


	// Leave the camera position where it is.
	LPDIRECT3DSURFACE8 p_update_surf;
	pIntensityTextureU->GetSurfaceLevel(0, &p_update_surf);
	gpd3dDev->SetRenderTarget(p_update_surf, pIntensityZ);

	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
						0xffff0000,
						1.f,
						0 );

		// Render a backdrop.

		gpd3dDev->SetRenderState( D3DRS_ALPHATESTENABLE,	TRUE );
		gpd3dDev->SetRenderState( D3DRS_ALPHAFUNC,			D3DCMP_GREATEREQUAL );
		gpd3dDev->SetRenderState( D3DRS_ALPHAREF,			0x00000001 );
		gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
		gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );
		gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );

		gpd3dDev->SetVertexShader(gApp.dwVShader[st_Depth]);
		gpd3dDev->SetPixelShader (gApp.dwPShader[st_Depth]);


		//#define Z_ADD			c16
		//#define Z_MUL			c17
		//#define POS_MUL		c18
		//#define POS_SHIFT		c19


		D3DVECTOR4 val[4];
		float max_color_dist = 2.0f * MAIN_FOG_RAD;
		float z_mul = 1.0f;	// set later on for the geometry case, this is just the backdrop
		float z_add = 0.0f;

		Set(&val[0], z_mul, z_mul, z_mul, 1.0f );
		Set(&val[1], z_add, z_add, z_add, 1.0f );

		float x_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE;
		float y_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE * gApp.theCamera.getAspectRatio();

		Set(&val[2], x_mul, y_mul, 0.0f, 1.0f);


		D3DVECTOR4 origin;
		Set(&origin, 0.0f, 0.0f, 0.0f, 1.0f);
		TransformPoint(origin, gApp.theCamera.getWTP(), &val[3]);
		Scale(&val[3], 1.0f / val[3].w);
		val[3].x = 0.5f - val[2].x * val[3].x;
		val[3].y = 0.5f - val[2].y * val[3].y;
		val[3].z = 0.5f;
		val[3].w = 0.0f;
		// If looking at origin, then Set(&val[3], 0.5f, 0.5f, 0.5f, 0.0f);
//MTS		Set(&val[3], 0.5f, 0.5f, 0.5f, 0.0f);
		gpd3dDev->SetVertexShaderConstant(16, &val[0], 4);


		D3DMATRIX iden;
		SetIdentity(&iden);
		iden._43 = 1.0f;
		iden._44 = 0.0f;
		gpd3dDev->SetVertexShaderConstant(0, &iden, 4);


		gpd3dDev->SetStreamSource(0, pIntensityQuadVB, sizeof(BaseStream));
		gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);


		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE);
		gpd3dDev->SetRenderState( D3DRS_ZENABLE,			TRUE);

		z_add = MAIN_FOG_RAD - gApp.getCameraRadiusFromBlob();
		z_mul = 1.0f / max_color_dist;
		Set(&val[0], z_mul, z_mul, z_mul, 1.0f );
		Set(&val[1], z_add, z_add, z_add, 1.0f );
		gpd3dDev->SetVertexShaderConstant(16, &val, 2);

		gApp.sceneGeom.renderZ();

		// Without NULLing the pixel shader, the shields aren't transparent. Dunno why.
		gpd3dDev->SetPixelShader (NULL);
		gpd3dDev->SetVertexShader(NULL);


		// Clear stencil and depth buffer, but not the "target", or ARGB values.
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER,
						0xffffffff,
						1.f,
						0 );



		gpd3dDev->EndScene();
	}
	else
	{
		int a = 0;
	}

	gpd3dDev->SetRenderTarget(pOldRT,pOldZ);
	p_update_surf->Release();
	pOldRT->Release();
	pOldZ->Release();
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\logo_renderer.cpp ===
//
//	logo_renderer.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "xbs_app.h"
#include "logo_renderer.h"
#include "logo_geometry.h"
#include "text_geometry.h"
#include "tm_pixels.h"
#include "renderer.h"
#include "tex_gen.h"
#include "xbs_app.h"


///////////////////////////////////////////////////////////////////////////////
float * LogoRenderer::decompressPosData(short *pdata,int ncount,float f_oo_scale,float f_delta)
{
	float * p_data = (float *)MemAlloc(ncount * sizeof(float) * 3);
	for(int i = 0; i < ncount * 3;i++)
	{
		p_data[i] = ( (float)pdata[i] ) * f_oo_scale + f_delta;
	}
	return p_data;
}
///////////////////////////////////////////////////////////////////////////////
float * LogoRenderer::decompressPosTexData(short *pdata,int ncount,
										   float f_oo_pos_scale,float f_pos_delta,
										   float f_oo_tex_scale,float f_tex_delta )
{
	float * p_data = (float *)MemAlloc(ncount * sizeof(float) * 5);
	for(int i = 0; i < ncount*5;i+=5)
	{
		p_data[i  ] = ( (float)pdata[i  ] ) * f_oo_pos_scale + f_pos_delta;
		p_data[i+1] = ( (float)pdata[i+1] ) * f_oo_pos_scale + f_pos_delta;
		p_data[i+2] = ( (float)pdata[i+2] ) * f_oo_pos_scale + f_pos_delta;
		p_data[i+3] = ( (float)pdata[i+3] ) * f_oo_tex_scale + f_tex_delta;
		p_data[i+4] = ( (float)pdata[i+4] ) * f_oo_tex_scale + f_tex_delta;
	}
	return p_data;	
}															
///////////////////////////////////////////////////////////////////////////////
WORD * LogoRenderer::decompressIndexData(char *pdata,int ncount)
{
	WORD * p_data = (WORD *)MemAlloc(ncount * sizeof(WORD));
	
	p_data[0] = (WORD)pdata[0];

	char * pbytes = pdata;
	for(int i = 1; i < ncount; i++)
	{
		if(pbytes[i] == 126)
		{
			char hi = pbytes[i+1];
			char lo = pbytes[i+2];

			p_data[i] = ((((short)hi)&0xff)<<8) | (((short)lo)&0xff);
			p_data[i] += p_data[i-1];
			pbytes += 2;
		}
		else
		{
			p_data[i] = p_data[i-1] + pbytes[i];
		}
	}
	return p_data;
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::create()
{
	decompressData();
	createSlash();
	createText();
	createTMs();

	pSlashTexture = NULL;

#ifndef BINARY_RESOURCE
	dwInteriorPShader = gApp.loadPixelShader ("d:\\shaders\\slash_interior.xpu");
#else // BINARY_RESOURCE
	dwInteriorPShader = gApp.loadPixelShader ( g_slash_interior_xpu );
#endif // BINARY_RESOURCE
	
	DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
		D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),
		D3DVSD_REG( 1, D3DVSDT_FLOAT2 ),     
		D3DVSD_END()
    };

#ifndef BINARY_RESOURCE
	dwInteriorVShader = gApp.loadVertexShader("d:\\shaders\\slash_interior.xvu",dwDecl);
#else // BINARY_RESOURCE
	dwInteriorVShader = gApp.loadVertexShader ( g_slash_interior_xvu,dwDecl );
#endif // BINARY_RESOURCE
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::decompressData()
{
	indices_xboxlogolip_0 = decompressIndexData(indices_xboxlogolip_0C,index_count_xboxlogolip_0);
	verts_xboxlogolip_0 = decompressPosTexData(verts_xboxlogolip_0C,
											   vertex_count_xboxlogolip_0,
											   xbl_OO_POS_SCALE,xbl_POS_DELTA,
											   xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_xboxlogosurface_0 = decompressIndexData(indices_xboxlogosurface_0C,index_count_xboxlogosurface_0);
	verts_xboxlogosurface_0 = decompressPosTexData(verts_xboxlogosurface_0C,
												   vertex_count_xboxlogosurface_0,
												   xbl_OO_POS_SCALE,xbl_POS_DELTA,
												   xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_xboxlogosurfacetop_0 = decompressIndexData(indices_xboxlogosurfacetop_0C,index_count_xboxlogosurfacetop_0);
	verts_xboxlogosurfacetop_0 = decompressPosTexData(verts_xboxlogosurfacetop_0C,
												      vertex_count_xboxlogosurfacetop_0,
												      xbl_OO_POS_SCALE,xbl_POS_DELTA,
												      xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_xboxlogointerior_0 = decompressIndexData(indices_xboxlogointerior_0C,index_count_xboxlogointerior_0);
	verts_xboxlogointerior_0 = decompressPosTexData(verts_xboxlogointerior_0C,
												    vertex_count_xboxlogointerior_0,
												    xbl_OO_POS_SCALE,xbl_POS_DELTA,
												    xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_tm_slash_0 = decompressIndexData(indices_tm_slash_0C,index_count_tm_slash_0);
	verts_tm_slash_0 = decompressPosTexData(verts_tm_slash_0C,
										    vertex_count_tm_slash_0,
											xbl_OO_POS_SCALE,xbl_POS_DELTA,
											xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_tm_wordmark_0 = decompressIndexData(indices_tm_wordmark_0C,index_count_tm_wordmark_0);
	verts_tm_wordmark_0 = decompressPosTexData(verts_tm_wordmark_0C,
											   vertex_count_tm_wordmark_0,
											   xbl_OO_POS_SCALE,xbl_POS_DELTA,
											   xbl_OO_TEX_SCALE,xbl_TEX_DELTA );
	
	indices_text_0 = decompressIndexData(indices_text_0C,index_count_text_0);
	verts_text_0 = decompressPosData(verts_text_0C,vertex_count_text_0,xbt_OO_POS_SCALE,xbt_POS_DELTA );
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createSlash()
{
	xbl_vertex *pv = NULL;

	nLipIndices = index_count_xboxlogolip_0;
	nLipVerts = vertex_count_xboxlogolip_0;
	pLipIndices = indices_xboxlogolip_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nLipVerts,NULL,FVF_xbl,NULL,&pLipVB);
	pLipVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogolip_0,sizeof(xbl_vertex) * nLipVerts);
	pLipVB->Unlock();
	pLipTex = CreateGradientTexture(16,128,0xff000100,0xff4b9b4b);

	nSurfaceIndices = index_count_xboxlogosurface_0;
	nSurfaceVerts = vertex_count_xboxlogosurface_0;
	pSurfaceIndices = indices_xboxlogosurface_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nSurfaceVerts,NULL,FVF_xbl,NULL,&pSurfaceVB);
	pSurfaceVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogosurface_0,sizeof(xbl_vertex) * nSurfaceVerts);
	pSurfaceVB->Unlock();
	pSurfaceTex = CreateHighlightTexture(256,6,false,0.5f,0.5f);

	nSurfaceTopIndices = index_count_xboxlogosurfacetop_0;
	nSurfaceTopVerts = vertex_count_xboxlogosurfacetop_0;
	pSurfaceTopIndices = indices_xboxlogosurfacetop_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nSurfaceVerts,NULL,FVF_xbl,NULL,&pSurfaceTopVB);
	pSurfaceTopVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogosurfacetop_0,sizeof(xbl_vertex) * nSurfaceTopVerts);

	// HACK to enforce border color.
	for(int i=0; i < (int)nSurfaceTopVerts;i++)
	{
		if(fast_fabs(pv[i].v0-1.f) <= 0.01f) 
			pv[i].v0 = -1.f;
	}

	pSurfaceTopVB->Unlock();
	pSurfaceTopTex = CreateGradientTexture(16,128,0xff000000,0xffffffff);

	nInteriorIndices = index_count_xboxlogointerior_0;
	nInteriorVerts = vertex_count_xboxlogointerior_0;
	pInteriorIndices = indices_xboxlogointerior_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nInteriorVerts,NULL,FVF_xbl,NULL,&pInteriorVB);
	pInteriorVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogointerior_0,sizeof(xbl_vertex) * nInteriorVerts);
	pInteriorVB->Unlock();
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createText()
{ 	
	xbt_vertex *pv;

	nText_Verts = vertex_count_text_0;
	nText_Indices = index_count_text_0;
	pText_Indices = indices_text_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbt_vertex) * nText_Verts,NULL,FVF_xbt,NULL,&pText_VB);
	pText_VB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_text_0,sizeof(xbt_vertex) * nText_Verts);
	pText_VB->Unlock();
	SetIdentity(&matText_Anim);

	bRenderText = false;
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createTMs()
{
	xbl_vertex *pv;

	nSlashTM_Verts = vertex_count_tm_slash_0;
	nSlashTM_Indices = index_count_tm_slash_0;
	pSlashTM_Indices = indices_tm_slash_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nSlashTM_Verts,NULL,FVF_xbl,NULL,&pSlashTM_VB);
	pSlashTM_VB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_tm_slash_0,sizeof(xbl_vertex) * nSlashTM_Verts);
	pSlashTM_VB->Unlock();

	nTextTM_Verts = vertex_count_tm_wordmark_0;
	nTextTM_Indices = index_count_tm_wordmark_0;
	pTextTM_Indices = indices_tm_wordmark_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nTextTM_Verts,NULL,FVF_xbl,NULL,&pTextTM_VB);
	pTextTM_VB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_tm_wordmark_0,sizeof(xbl_vertex) * nTextTM_Verts);
	pTextTM_VB->Unlock();

	gpd3dDev->CreateTexture( 16,16,1,0,D3DFMT_A8R8G8B8,0,&pTMTex);
	
	D3DLOCKED_RECT rc;
	pTMTex->LockRect(0,&rc,NULL,0);
	XGSwizzleRect( tm_pixels,
				   0,
				   NULL,
				   rc.pBits,
				   16,
				   16,
				   NULL,
				   sizeof(DWORD) );

	pTMTex->UnlockRect(0);

	fTMAlpha = 0.f;
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createSlashSurface()
{
	bool b_want_wordmark = (gApp.getElapsedTime() >= TEXT_ANIM_START_TIME + TEXT_ANIM_LEN);
	if (pSlashTexture && (b_want_wordmark == bHasWordmark)) return;

	LPDIRECT3DSURFACE8		pSlashSurface;
	LPDIRECT3DSURFACE8		pSlashDepthBuf;

	D3DFORMAT fmt = D3DFMT_A8R8G8B8;
	DWORD mst = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR;
	int x_dim = 1024;	
	int y_dim = 1024;
	gpd3dDev->CreateRenderTarget(x_dim, y_dim, fmt, mst, TRUE, &pSlashSurface);
	gpd3dDev->CreateDepthStencilSurface(x_dim,y_dim,D3DFMT_LIN_D24S8, mst, &pSlashDepthBuf);
	if (!pSlashTexture) gpd3dDev->CreateTexture(x_dim, y_dim, 1, 0, fmt, 0, &pSlashTexture);


	LPDIRECT3DSURFACE8 pOldRT,pOldZ;
	gpd3dDev->GetRenderTarget(&pOldRT);
	gpd3dDev->GetDepthStencilSurface(&pOldZ);

	gpd3dDev->SetRenderTarget(pSlashSurface, pSlashDepthBuf);

	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,
						0xff000000,
						1.f,
						0 );

		bool b_old_render_text = bRenderText;
		bRenderText = b_want_wordmark;

		render(gApp.camController.getSlashTransform(), true);

		bRenderText = b_old_render_text;

		gpd3dDev->EndScene();


		LPDIRECT3DSURFACE8 p_tex_surf;
		pSlashTexture->GetSurfaceLevel(0, &p_tex_surf);

		gpd3dDev->CopyRects(pSlashSurface, NULL, 0, p_tex_surf, NULL);
		p_tex_surf->Release();

		bHasWordmark = b_want_wordmark;
	}

	pSlashSurface->Release();
	pSlashDepthBuf->Release();

	gpd3dDev->SetRenderTarget(pOldRT,pOldZ);
	pOldRT->Release();
	pOldZ->Release();
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::destroy()
{
	pLipVB->Release();
	pLipTex->Release();
	pSurfaceVB->Release();
	pSurfaceTex->Release();
	pSurfaceTopVB->Release();
	pSurfaceTopTex->Release();
	pInteriorVB->Release();
	pText_VB->Release();
	pSlashTM_VB->Release();
	pTextTM_VB->Release();
	pTMTex->Release();
	pSlashTexture->Release();

	MemFree(indices_xboxlogolip_0);
	MemFree(verts_xboxlogolip_0);
	MemFree(indices_xboxlogosurface_0);
	MemFree(verts_xboxlogosurface_0);
	MemFree(indices_xboxlogosurfacetop_0);
	MemFree(verts_xboxlogosurfacetop_0);
	MemFree(indices_xboxlogointerior_0);
	MemFree(verts_xboxlogointerior_0);
	MemFree(indices_tm_wordmark_0);
	MemFree(verts_tm_wordmark_0);
	MemFree(indices_tm_slash_0);
	MemFree(verts_tm_slash_0);
	MemFree(indices_text_0);
	MemFree(verts_text_0);

	gpd3dDev->DeleteVertexShader(dwInteriorVShader);
	gpd3dDev->DeletePixelShader (dwInteriorPShader);
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::advanceTime(float fElapsedTime, float fDt)
{
	if(fElapsedTime >= TEXT_ANIM_START_TIME)
	{
		bRenderText = true;

		int n_samples = sizeof(pos_anim_text)/sizeof( D3DVECTOR );

		float f_norm_pos = (fElapsedTime - TEXT_ANIM_START_TIME) / TEXT_ANIM_LEN;
		float f_pos = f_norm_pos * (n_samples-1);

		int pos_idx;

		 __asm
		{
			cvttss2si eax, f_pos
			mov pos_idx, eax
		}

		if(f_norm_pos <= 0.f)
		{
			matText_Anim._41 = pos_anim_text[0].x;
			matText_Anim._42 = pos_anim_text[0].y;
			matText_Anim._43 = pos_anim_text[0].z;
		}
		else if(f_norm_pos >= 1.f)
		{
			int last_pos = n_samples - 1;
			
			matText_Anim._41 = pos_anim_text[last_pos].x;
			matText_Anim._42 = pos_anim_text[last_pos].y;
			matText_Anim._43 = pos_anim_text[last_pos].z;
		}
		else
		{
			float f_frac = f_pos - ((float)pos_idx);

			D3DVECTOR &s = pos_anim_text[pos_idx];
			D3DVECTOR &e = pos_anim_text[pos_idx+1];

			matText_Anim._41 = s.x * (1.f-f_frac) + e.x * f_frac;
			matText_Anim._42 = s.y * (1.f-f_frac) + e.y * f_frac;
			matText_Anim._43 = s.z * (1.f-f_frac) + e.z * f_frac;
		}

		
		fTMAlpha = (fElapsedTime - (TEXT_ANIM_START_TIME)) / (TEXT_ANIM_LEN);
		fTMAlpha = max(0.f,min(1.f,fTMAlpha));
		fTMAlpha *= 255.f;
	}
	else
	{
		bRenderText = false;
		fTMAlpha = 0.f;
	}

	if (fElapsedTime >= FINISH_STOP_TIME)
	{
		createSlashSurface();
	}
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::render(const D3DMATRIX &mat_otw, bool b_force_3d_render)
{
	gpd3dDev->SetVertexShader(FVF_xbl);
	gpd3dDev->SetPixelShader (NULL);

	if (b_force_3d_render || (gApp.getElapsedTime() < FINISH_STOP_TIME))
	{
		Camera &cam = gApp.theCamera;

		gpd3dDev->SetTransform(D3DTS_WORLD,&mat_otw);
		gpd3dDev->SetTransform(D3DTS_VIEW,&cam.matWTC);
		gpd3dDev->SetTransform(D3DTS_PROJECTION,&cam.matProj);

		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);

		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSU,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSV,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_BORDERCOLOR, 0xff000000 );
  
  		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
  		gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
  		gpd3dDev->SetRenderState(D3DRS_CULLMODE,D3DCULL_CW);


		gpd3dDev->SetStreamSource(0,pLipVB,sizeof(xbl_vertex));
		gpd3dDev->SetTexture(0,pLipTex);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nLipIndices,pLipIndices);

		gpd3dDev->SetStreamSource(0,pSurfaceVB,sizeof(xbl_vertex));
		gpd3dDev->SetTexture(0,pSurfaceTex);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nSurfaceIndices,pSurfaceIndices);

		gpd3dDev->SetStreamSource(0,pSurfaceTopVB,sizeof(xbl_vertex));
		gpd3dDev->SetTexture(0,pSurfaceTopTex);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nSurfaceTopIndices,pSurfaceTopIndices);

		gpd3dDev->SetStreamSource(0,pInteriorVB,sizeof(xbl_vertex));

		float fmag = -1.0f + 2.0f * (gApp.getElapsedTime() - SLASH_GRADIENT_TRANSITION_START) * SLASH_GRADIENT_TRANSITION_MUL;
		float w1 = max(0.f, min(1.f,-fmag));
		float w3 = max(0.f, min(1.f,+fmag));
		float w2 = max(0.f, min(1.f,1.f - w1 - w3));

		gpd3dDev->SetVertexShader(dwInteriorVShader);
		gpd3dDev->SetPixelShader (dwInteriorPShader);

		D3DMATRIX mat_final,tmp;
		MulMats(mat_otw,cam.getWTP(),&tmp);
		SetTranspose(tmp,&mat_final);
		gpd3dDev->SetVertexShaderConstant(0,(void *)&mat_final,4);

		D3DVECTOR4 vals[5];
		if(fmag < 0.f)
		{
			Set(&vals[0],0.81568f,1.f,0.5921f,1.f);
			Set(&vals[1],0.81568f,1.f,0.5921f,1.f);
			Set(&vals[2],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[3],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[4],w1,w1,w1,1.f);
		}
		else
		{
			Set(&vals[0],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[1],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[2],0.796f,0.8745f,0.0039f,1.f);
			Set(&vals[3],0.1294f,0.4168f,0.0901f,1.f);
			Set(&vals[4],w2,w2,w2,1.f);
		}

		gpd3dDev->SetVertexShaderConstant(4,(void *)&vals,5);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nInteriorIndices,pInteriorIndices);
	}

	else
	{				
		gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE);
   		gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );
   		gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );
   		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );
   
   		D3DMATRIX iden;
   		SetIdentity(&iden);
   		gpd3dDev->SetTransform(D3DTS_WORLD, &iden);
   		gpd3dDev->SetTransform(D3DTS_VIEW, &iden);
   		gpd3dDev->SetTransform(D3DTS_PROJECTION, &iden);
   
  		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR, 0xFFFFFFFF);
   		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
   		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TEXTURE);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_SELECTARG1);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TFACTOR);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG2,D3DTA_TFACTOR);
  		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);
  
   		gpd3dDev->SetTextureStageState(0,D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
   		
   
   		gpd3dDev->SetTexture(0,pSlashTexture);
   
   		gpd3dDev->SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX2);
   
   		
   		gpd3dDev->SetStreamSource(0, gApp.greenFog.borrowScreenQuad(), sizeof(GreenFogVertexBuffer));
   		gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
   
  		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
  
   		// Prepare for rendering text...
   		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
   		gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
  		gpd3dDev->SetRenderState(D3DRS_CULLMODE,D3DCULL_CW);
 		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,TRUE );
   
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSU,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSV,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_BORDERCOLOR, 0xff000000 );
     
   		gpd3dDev->SetTransform(D3DTS_WORLD,&mat_otw);
   		gpd3dDev->SetTransform(D3DTS_VIEW,&gApp.theCamera.matWTC);
   		gpd3dDev->SetTransform(D3DTS_PROJECTION,&gApp.theCamera.matProj);

	}

	if(bRenderText && !bHasWordmark)
	{
		gpd3dDev->SetVertexShader(FVF_xbl);
		gpd3dDev->SetPixelShader (NULL);

		gpd3dDev->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);

		DWORD dw_alpha;
		float f_alpha = fTMAlpha;

		__asm
		{
			cvttss2si eax, f_alpha
			shl eax,24
			mov dw_alpha,eax
		}

		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
		gpd3dDev->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
		gpd3dDev->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);

		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR,dw_alpha);

		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_MODULATE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG2,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);
		gpd3dDev->SetTexture(0,pTMTex);

		gpd3dDev->SetStreamSource(0,pSlashTM_VB,sizeof(xbl_vertex));
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nSlashTM_Indices,pSlashTM_Indices);

		gpd3dDev->SetStreamSource(0,pTextTM_VB,sizeof(xbl_vertex));
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nTextTM_Indices,pTextTM_Indices);

		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);

		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR,0xff62ca13);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TFACTOR);

		D3DMATRIX anim_otw;

		D3DMATRIX flip;
		SetXRotation(Pi/2.f,&flip);

		D3DMATRIX tmp;

		MulMats(flip,matText_Anim,&tmp);
		MulMats(tmp,mat_otw,&anim_otw);

		gpd3dDev->SetVertexShader(FVF_xbt);

		gpd3dDev->SetTransform(D3DTS_WORLD,&anim_otw);
		gpd3dDev->SetStreamSource(0,pText_VB,sizeof(xbt_vertex));
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nText_Indices,pText_Indices);

		gpd3dDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
	}

	gpd3dDev->SetRenderState(D3DRS_CULLMODE,D3DCULL_CCW);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\PROC.C ===
/*************************************************************************
*                                                                        *
* 	Routines for process creation and control			  *
*                                                                        *
*************************************************************************/

#include "error.h"
#include "sos.h"
#include "protos.h"
#include "externs.h"

extern	int	(*event_fcns[])();

/*
 *	return a new process or NULL if error
 *	Put the process in the process queue
 */

struct process *pp;

int create_process(
ushort	*mem_ptr,			/* pointer to event list */
uchar	level,				/* sound level */
uchar	channel)			/* channel for this process */
{
 	struct process	*tpp;		

	pp = get_process_packet();

	pp->mem_ptr.i = mem_ptr;		/* get event-list pointer */
	pp->level = level;		/* get level		  */
	pp->timer = 0;		/* timer for process 	  */
	pp->hard_channel = channel;	/* get hardware channel   */
	pp->function = *mem_ptr;	/* get function byte	  */
	pp->type = 0;				/* clear type field			*/
	pp->prev = process_queue;	/* put process at head of q */

	if (level == 0)
		pp->prev_timer = system_clock_music;  /* make us current	  */
	else
		pp->prev_timer = system_clock_fx;  /* make us current	  */

	pp->next = tpp = process_queue->next;
	if (tpp != (struct process *)NULL) {
	    tpp->prev = pp;
	}
	process_queue->next = pp;
	return(1);
}

/*
 * 	remove a process from the process queue and free up the memory
 */

void kill_process(struct process *pp)
{
	pp->prev->next = pp->next;
	if (pp->next != (struct process *)NULL)
	   pp->next->prev = pp->prev;		/* remove ourselves */

	pp->next = queue_list[0].next;
	pp->prev = &(queue_list[0]);
/*	pp->function = 0;*/
	queue_list[0].next = pp;
	if (pp->next == (struct process *)NULL)
	    return;
	pp->next->prev = pp;
}

struct process *get_process_packet()
{
	struct process * pp;

	pp = queue_list[0].next;
	queue_list[0].next = pp->next;
	if (pp->next == (struct process *)NULL)
	    return(pp);
	pp->next->prev = &(queue_list[0]);
	return(pp);
}


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\PROTOS.H ===
#ifndef _PROTOS_H_
#define _PROTOS_H_ 


init_track_status(uchar level, uchar channel);
remove_processes_by_level(uchar level);


void	do_sos_init_return();

void	sos_main(void);
void	sos_error(int);
int	create_process(ushort * p, uchar l, uchar c);
struct process * get_process_packet();
int	free_process_packet(struct process *pp);
struct track_info *get_track_info_block();
struct track_info *get_track_info_block2(uchar, uchar);
struct track_info *get_music_info_block();
struct track_info *get_music_info_block_i(uchar);
uchar	read_sound_call();
void	put_fifo(uchar);
void	nosound(uchar);
void	kill_process( struct process *pp);
uchar	get_fifo(void);
void do_volume_adjust(uchar volume,uchar level,uchar *patch_addr,uchar chan);
void	remove_processes_by_level_and_channel(uchar, uchar);
int	init_queuelist();
void	do_watchdog(void);


int	f_note(void);
int	f_rest(void);
int	f_jumpto(void);
int	f_loop(void);
int	f_endloop(void);
int	f_patch(void);
int	f_pan(void);
int	f_mux(void);
int	f_demux(void);
int	f_volume(void);
int	f_xpose(void);
int	f_xset(void);
int	f_slur(void);
int	f_ring(void);
int	f_clockset(void);
int	f_end(void);
int	f_filterset(void);
int	f_filterinc(void);


int	f_mark(void);
int	f_sound_call(void);
int	f_srest(void);
int	f_intvarset(void);
int	f_intvarinc(void);
int	f_user_1_var_evf(void);
int	f_user_2_var_evf(void);
int 	f_sig(void);
int	f_gliss(void);
int	f_clockinc(void);
int	f_paninc(void);
int 	f_musicclockinc(void);
int	f_MidiNoteOn(void);
int	f_MidiNoteOff(void);
int	f_MidiProgram(void);
int	f_MidiVolume(void);
int	f_MidiTempo(void);
int	f_MidiControl(void);
int	f_MidiEOT(void);

int	f_fxset(void);

void	call_silence(void);
void	call_music(void);
void	call_effect(void);
void	call_volume(void);
void	call_senddev(void);
void	call_mark(void);
void	call_ignore(void);
void	call_user_function(void);
void	call_timer(void);
void	call_end_timer(void);
void	call_play_timer(void);
void 	call_kill_effect(void);

#endif //protos_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\qrand.cpp ===
//
//	qrand.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
#include "precomp.h"
#include "qrand.h"

int	QRand::Rand(int scale)
{
	_asm
	{
		mov		edi,this
		mov		eax,[edi]
		mov		ebx,eax
		ror		eax,13
		sub		ebx,11
		sub		eax,ebx
		mov		[edi],eax
		mul		scale
		mov		eax,edx
	}
}

int	QRand::Rand()
{

	_asm
	{
		mov		edi,this
		mov		eax,[edi]
		mov		ebx,eax
		ror		eax,13
		sub		ebx,11
		sub		eax,ebx
		mov		[edi],eax
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\qrand.h ===
//
//	qrand.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __QRAND__
#define __QRAND__

class QRand
{
private:
	
	int seed;

public:
	
	void Init(int initSeed=0x76543210) { seed = initSeed; }
	void	SetSeed(int newSeed)   { seed = newSeed;  }
	int		Rand(int scale);	
	int		Rand();
};


#endif  //__QRAND__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\Pitches.h ===
#define	cc0 	0
#define	cs0		1
#define	dd0		2
#define	ds0		3
#define	ee0		4
#define	ff0		5
#define	fs0		6
#define	gg0		7
#define	gs0		8
#define	aa0		9
#define	as0		10
#define	bb0		11
#define	cc1		12

#define	cs1		13
#define	dd1		14
#define	ds1		15
#define	ee1		16
#define	ff1		17
#define	fs1		18
#define	gg1		19
#define	gs1		20
#define	aa1		21
#define	as1		22
#define	bb1		23
#define	cc2		24

#define	cs2		25
#define	dd2		26
#define	ds2		27
#define	ee2		28
#define	ff2		29
#define	fs2		30
#define	gg2		31
#define	gs2		32
#define	aa2		33
#define	as2		34
#define	bb2		35
#define	cc3		36

#define	cs3		37
#define	dd3		38
#define	ds3		39
#define	ee3		40
#define	ff3		41
#define	fs3		42
#define	gg3		43
#define	gs3		44
#define	aa3		45
#define	as3		46
#define	bb3		47
#define	cc4		48

#define	cs4		49
#define	dd4		50
#define	ds4		51
#define	ee4		52
#define	ff4		53
#define	fs4		54
#define	gg4		55
#define	gs4		56
#define	aa4		57
#define	as4		58
#define	bb4		59
#define	cc5		60

#define	cs5		61
#define	dd5		62
#define	ds5		63
#define	ee5		64
#define	ff5		65
#define	fs5		66
#define	gg5		67
#define	gs5		68
#define	aa5		69
#define	as5		70
#define	bb5		71
#define	cc6		72

#define	cs6		73
#define	dd6		74
#define	ds6		75
#define	ee6		76
#define	ff6		77
#define	fs6		78
#define	gg6		79
#define	gs6		80
#define	aa6		81
#define	as6		82
#define	bb6		83
#define	cc7		84

#define	cs7		85
#define	dd7		86
#define	ds7		87
#define	ee7		88
#define	ff7		89
#define	fs7		90
#define	gg7		91
#define	gs7		92
#define	aa7		93
#define	as7		94
#define	bb7		95
#define	cc8		96

#define	cs8		87
#define	dd8		88
#define	ds8		89
#define	ee8		90
#define	ff8		91
#define	fs8		92
#define	gg8		93
#define	gs8		94
#define	aa8		95
#define	as8		96
#define	bb8		97
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\PlacementDoodad.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: PlacementDoodad.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "defines.h"
#ifdef INCLUDE_PLACEMENT_DOODAD

#include "xbs_math.h"
#include "renderer.h"
#include "PlacementDoodad.h"
///////////////////////////////////////////////////////////////////////////////
#define FVF_xyzrgba (D3DFVF_XYZ|D3DFVF_DIFFUSE)
struct xyzrgba_vertex
{
	float x,y,z;
	DWORD diffuse;
};
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::Init()
{
    m_pVB = NULL;
    m_pIB = NULL;
    m_dwNumVertices = 0;
    m_dwNumIndices = 0;
}
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::create()
{
	m_dwNumVertices = 6;
	m_dwNumIndices = 6;
	
	gpd3dDev->CreateVertexBuffer(sizeof(xyzrgba_vertex) * m_dwNumVertices, NULL, FVF_xyzrgba,NULL, &m_pVB);
	gpd3dDev->CreateIndexBuffer(m_dwNumIndices, D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);

	xyzrgba_vertex* p_vb;
	m_pVB->Lock(0, 0, (BYTE**) &p_vb, 0);

	int i;
	for (i=0; i<3; i++)
	{
		p_vb[2*i+0].x = (i==0) ? -100.0f : 0.0f;
		p_vb[2*i+1].x = (i==0) ? +100.0f : 0.0f;
		p_vb[2*i+0].y = (i==1) ? -100.0f : 0.0f;
		p_vb[2*i+1].y = (i==1) ? +100.0f : 0.0f;
		p_vb[2*i+0].z = (i==2) ? -100.0f : 0.0f;
		p_vb[2*i+1].z = (i==2) ? +100.0f : 0.0f;
		p_vb[2*i+0].diffuse = p_vb[2*i+1].diffuse = 0xFFFFFFFF;
	}

	m_pVB->Unlock();


	WORD* p_ib;
	m_pIB->Lock(0, 0, (BYTE**) &p_ib, 0);

	for (i=0; i<6; i++) p_ib[i] = (WORD)i;

	m_pIB->Unlock();
}
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::destroy()
{
	m_pVB->Release();
	m_pIB->Release();
	m_pVB = NULL;
	m_pIB = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::render(const D3DVECTOR* p_pos, const D3DMATRIX* view_mat, const D3DMATRIX* proj_mat)
{
    // Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING,			FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,			TRUE );
    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );

	gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_INVSRCALPHA );

	gpd3dDev->SetVertexShader(FVF_xyzrgba);

	D3DMATRIX iden;
	SetIdentity(&iden);
	*((D3DVECTOR*)(&iden._41)) = *p_pos;
	gpd3dDev->SetTransform(D3DTS_WORLD, &iden);

	if (view_mat) gpd3dDev->SetTransform(D3DTS_VIEW, view_mat);
	if (proj_mat) gpd3dDev->SetTransform(D3DTS_PROJECTION, proj_mat);
	
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,	D3DTOP_SELECTARG1);
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,	D3DTA_DIFFUSE);
	gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,	D3DTOP_SELECTARG1);
	gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,	D3DTA_DIFFUSE);
	gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,	D3DTOP_DISABLE);

	gpd3dDev->SetIndices( m_pIB, 0 );
	gpd3dDev->SetStreamSource(0, m_pVB, sizeof(xyzrgba_vertex));
	gpd3dDev->DrawIndexedPrimitive(D3DPT_LINELIST, 0, m_dwNumVertices, 0, m_dwNumIndices / 2);

	gpd3dDev->SetPixelShader(NULL);
	gpd3dDev->SetVertexShader(NULL);

    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,	D3DTOP_DISABLE);
}
///////////////////////////////////////////////////////////////////////////////
#endif // INCLUDE_PLACEMENT_DOODAD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\scene_renderer.h ===
//
//	scene_renderer.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved

#ifndef __SCENE_RENDERER_H__
#define __SCENE_RENDERER_H__

#include "xbs_math.h"
#include "prim_types.h"

///////////////////////////////////////////////////////////////////////////////
enum ShaderTypes
{
	st_Phong		= 0,
	st_Bump			= 1,
	st_Depth		= 2,
	st_ShadowMap	= 3,
	st_NoTypes		= 4,
};
///////////////////////////////////////////////////////////////////////////////
struct BaseStream
{
	D3DVECTOR p;
};
///////////////////////////////////////////////////////////////////////////////
struct BumpStream
{
	FLOAT	  u,v;
	D3DVECTOR s;
	D3DVECTOR t;
	D3DVECTOR n;
};
///////////////////////////////////////////////////////////////////////////////
struct PhongStream
{
	D3DVECTOR s;
	D3DVECTOR t;
	D3DVECTOR n;
};
///////////////////////////////////////////////////////////////////////////////
struct PrimitiveVersionRecord
{
	DWORD		dwVertexStart;
	DWORD		dwVertexCount;
	DWORD		dwIndexStart;
	DWORD		dwPrimCount;
	DWORD		dwIndexCount;
	DWORD		dwParameter;
};
///////////////////////////////////////////////////////////////////////////////
struct PrimitiveInstanceRecord
{
	unsigned short		idxVersion;

	short				idxPosAnim;
	short				idxRotAnim;
	
	D3DMATRIX			matOffset;		
	D3DMATRIX           matInvOffset;
	
	D3DMATRIX			matScale;
	D3DVECTOR4          vObjScale;
	
	D3DMATRIX			matScaleOffset; 

	bool				bHiZ;
};
///////////////////////////////////////////////////////////////////////////////
class PrimitiveSet
{
private:
	
	LPDIRECT3DVERTEXBUFFER8    pBaseStream;
	LPDIRECT3DVERTEXBUFFER8    pExtraStream;

	LPDIRECT3DINDEXBUFFER8     pIB;

	PrimitiveVersionRecord	 * aVersRecs;
	int						   nVersions;

	PrimitiveInstanceRecord  * aInstRecs;
	int						   nInstances;

	D3DPRIMITIVETYPE           d3dType;
	

	LPDIRECT3DTEXTURE8         pNormalMap;
	LPDIRECT3DCUBETEXTURE8	   pCubeMap;

	D3DVECTOR4				   vAmbient;
	D3DVECTOR4                 vDiffuse;
	D3DVECTOR4                 vSpecular;

	DWORD					   dwPShader;
	DWORD					   dwVShader;

	ShaderTypes				   shaderType;
	PrimitiveTypes             primitiveType;
	bool					   bHiZ;


	void createSphereVersion(const SphereVers *psphere,
							 BYTE *pbase,BYTE *pextra,
							 unsigned short *pi,
							 int idx,int ndet_bias );

	void createCylinderVersion(const CylinderVers *pcyl,
							   BYTE *pbase,BYTE *pextra,
							   unsigned short *pi,
							   int idx,int ndet_bias );

	void createConeVersion(const ConeVers  * pcone,
		                   BYTE *pbase,BYTE *pextra,
						   unsigned short *pi,
						   int idx, int ndet_bias );

	void createBoxVersion(BYTE *pbase,BYTE *pextra,
		                  unsigned short *pi,
						  int idx );

	void createTorusVersion(const TorusVers  * ptorus,
		                    BYTE *pbase,BYTE *pextra,
							unsigned short *pi, 
							int idx,int ndet_bias );

	void createSurfOfRevVersion(const SurfOfRevVers *psurf,
		                        BYTE *pbase,BYTE *pextra,
								unsigned short *pi,
								int idx,int ndet_bias);
	
	void initSphereInstance( const SphereInst *psphere, int idx);
	void initCylinderInstance( const CylinderInst *pcyl, int idx);
	void initConeInstance(const ConeInst *pcone,int idx);
	void initBoxInstance(const BoxInst *pbox,int idx);
	void initTorusInstance(const TorusInst *ptorus,int idx);
	void initSurfOfRevInstance(const SurfOfRevInst *psurf,int idx);

	void initSphereVersion(const SphereVers *psphere,int idx,int ndet_bias);
	void initCylinderVersion(const CylinderVers *pcyl,int idx,int ndet_bias);
	void initConeVersion(const ConeVers *pcone,int idx,int ndet_bias);
	void initBoxVersion(int idx);
	void initTorusVersion(const TorusVers *ptorus,int idx,int ndet_bias);
	void initSurfOfRevVersion(const SurfOfRevVers *psurf,int idx,int ndet_bias);
	
public:

	void Init();
	void UnInit();

	void render(const D3DLIGHT8 &light,bool b_query_blob);
	void renderZ();
	void renderShadowMap(bool b_hi_z);

	void create( const void      *		version_data, 
				 int					num_versions, 
		         const void      *		instance_data,
				 int					num_insts,
				 int					ndet_bias,
				 ShaderTypes			shader,
				 PrimitiveTypes			primitive,
				 LPDIRECT3DTEXTURE8		pnormal_map,
				 LPDIRECT3DCUBETEXTURE8 pcubemap );
};
///////////////////////////////////////////////////////////////////////////////
class SceneRenderer 
{
protected:

	PrimitiveSet	  * pSetHiDet[pt_NoTypes];
	PrimitiveSet	  * pSetLoDet[pt_NoTypes];

	IDirect3DSurface8 * pSBufTarget;			


    IDirect3DSurface8 * pRenderTarget;
    IDirect3DSurface8 * pZBuffer;				  			

    D3DSurface			fakeTarget;

    float				fZOffset;				  
    float				fZSlopeScale;
	
	bool				bUseLoDetail;

	D3DVECTOR4 * decompressQuats(short *p_quat_data, DWORD *p_sign_data,int nquats);
	D3DVECTOR  * decompressVecs(short *p_vec_data, int nvecs);
	short      * decompressIndices(char *p_index_data,int nindices);
	void		 updateSBuffer(bool b_hi_z);

	void createSceneGeometry(PrimitiveSet **pp_sets,int ndet_bias);

public:

	D3DVECTOR4			*pQuats;
	short				*pQuatIdSeq[NUM_ROT_SEQ];

	D3DVECTOR			*pPos;
	short				*pPosIdSeq[NUM_POS_SEQ];

	IDirect3DTexture8	*pSBufDepthHi;           
	IDirect3DTexture8   *pSBufDepthLo;

	D3DMATRIX			matWTSHi;
	D3DMATRIX			matWTSLo;

	D3DMATRIX			*pRotAnims;
	int					nRotAnims;

	D3DVECTOR           *pPosAnims;
	int					nPosAnims;

	void create();
	void destroy();

	void render(bool b_with_shadows,bool b_use_blob_intensity);
	void renderZ();

	void advanceTime(float fElapsedTime, float fDt);
	void updateShadows();
};

#endif // __SCENE_RENDERER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\PlacementDoodad.h ===
///////////////////////////////////////////////////////////////////////////////
// File: PlacementDoodad.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef __PLACEMENTDOODAD_H__
#define __PLACEMENTDOODAD_H__


#include "defines.h"

#ifdef INCLUDE_PLACEMENT_DOODAD


// Renders a visible item at a specific location.
   

class PlacementDoodad
{
protected:
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    LPDIRECT3DINDEXBUFFER8  m_pIB;
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;


public:
	void Init();
	void UnInit()
    {
        destroy();
    }

	void create();
	void destroy();

	void render(const D3DVECTOR* p_pos, const D3DMATRIX* view_mat, const D3DMATRIX* proj_mat);
};


#endif // INCLUDE_PLACEMENT_DOODAD
#endif // __PLACEMENTDOODAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\precomp.h ===
#pragma once

#ifdef STARTUPANIMATION

#pragma code_seg("INIT")
#pragma data_seg("INIT_RW")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
};

#endif // STARTUPANIMATION

#include <xtl.h>
#include <xgraphics.h>

#include <stdio.h>

#ifdef _DEBUG
extern int gcMemAllocs;

#ifdef STARTUPANIMATION
extern "C" int gcMemAllocsContiguous;
#endif // STARTUPANIMATION
#endif

#ifndef XSS_TEST
inline void* MemAlloc(UINT cBytes)
#else
inline void* MemAlloc_(UINT cBytes)
#endif
{
#ifdef _DEBUG
    gcMemAllocs++;
#endif

#ifndef STARTUPANIMATION
    void* p = LocalAlloc(LMEM_FIXED, cBytes);
    if (p)
    {
        ZeroMemory(p, cBytes);
    }
    return p;
#else // STARTUPANIMATION
    void* p = ExAllocatePoolWithTag(cBytes, 'KD3D');
    if (p)
    {
        // Last-minute hack to fix start-up animation hangs [andrewgo]
        ZeroMemory(p, cBytes);
    }
    return p;
#endif // STARTUPANIMATION
}

inline void* MemAllocNoZero(ULONG cBytes)
{
#ifndef XSS_TEST
    return MemAlloc(cBytes);
#else
    return MemAlloc_(cBytes);
#endif
}

#ifndef XSS_TEST
inline void MemFree(void* pv)
#else
inline void MemFree_(void* pv)
#endif
{
#ifdef _DEBUG
    if (gcMemAllocs <= 0)
    {
        __asm int 3;
    }
    gcMemAllocs--;
#endif

#ifndef STARTUPANIMATION
    LocalFree(pv);
#else // STARTUPANIMATION
    ExFreePool(pv);
#endif // STARTUPANIMATION
}

#ifdef STARTUPANIMATION
extern "C"
void *MemAllocContiguous(size_t Size, DWORD Alignment);
extern "C"
void MemFreeContiguous(void *pv);
#endif // STARTUPANIMATION

#ifdef BINARY_RESOURCE
#include "shaders.h"
#endif // BINARY_RESOURCE

#include "fastmath.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\renderer.h ===
//
//	renderer.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __RENDERER_H__
#define __RENDERER_H__

///////////////////////////////////////////////////////////////////////////////
class Renderer
{
private:

	IDirect3D8				*pD3D8;
	IDirect3DDevice8		*pD3DDev8;
	D3DPRESENT_PARAMETERS	d3dPresentParams;

public:

	void Init();
	void UnInit();

	bool init(int width,int height);
	void shutdown();
};

extern IDirect3DDevice8 *gpd3dDev;
/////////////////////////////////////////////////////////////////////////////// 


#endif // __RENDERER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\prim_types.h ===
//
//	prim_types.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __PRIM_TYPES_H__
#define __PRIM_TYPES_H__


enum PrimitiveTypes
{
	pt_Sphere    = 0,
	pt_Cylinder  = 1,
	pt_Box       = 2,
	pt_Torus     = 3,
	pt_Cone      = 4,
	pt_SurfOfRev = 5,
	pt_NoTypes   = 6
};

const float OO_PRIM_TRANS_SCALE_X = 0.004131f;
const float OO_PRIM_TRANS_SCALE_Y = 0.008252f;
const float OO_PRIM_TRANS_SCALE_Z = 0.004421f;
const float PRIM_TRANS_DELTA_X =    -27.844984f;
const float PRIM_TRANS_DELTA_Y =    -0.228729f;
const float PRIM_TRANS_DELTA_Z =    0.497086f;

struct SphereInst
{
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
	float fRad;
};

struct SphereVers
{
	char nSegs;
};

struct CylinderInst
{
	char  idQuat;
	short tx,ty,tz;
	char  idVersion;
	char  idPosAnim;
	char  idRotAnim;
	float fRad;
	float fHalfHeight;
};

struct CylinderVers
{
	char nHeightSeg;
	char nSides;
};

struct BoxInst
{
	char  idQuat;
	short tx,ty,tz;
	char  idVersion;
	char  idPosAnim;
	char  idRotAnim;
	float fLen;
	float fHeight;
	float fWidth;
};

struct TorusInst
{
	char idQuat;
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
	float fRad1;
};

struct TorusVers
{
	float fRatio;
	char nSegs;
	char nSides;
};

struct ConeInst
{
	char idQuat;
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
};

struct ConeVers
{
	float fRad1;
	float fRad2;
	float fHeight;
	char nHeightSeg;
	char nSides;
};

#define MAX_SOR_PTS 19
struct SurfOfRevInst
{
	char idQuat;
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
};

struct SurfOfRevPt
{
	float x,y,z;
	char flags;
};

struct SurfOfRevVers
{
	SurfOfRevPt pts[MAX_SOR_PTS];
	float ax,ay,az;
	float px,py,pz;
	char nSegs;
	char nPts;
};

enum SurfOfRevPtFlags
{
	sr_Smooth = 1
};

#define MAX_POS_SAMPLES 30
#define NUM_POS_SEQ 32
const float OO_POS_ANIM_SCALE_X = 0.002755f;
const float OO_POS_ANIM_SCALE_Y = 0.002755f;
const float OO_POS_ANIM_SCALE_Z = 0.002440f;
const float POS_ANIM_DELTA_X = -0.159046f;
const float POS_ANIM_DELTA_Y = -0.741611f;
const float POS_ANIM_DELTA_Z = 2.155624f;

struct PosAnimSeq
{
	char posIds[MAX_POS_SAMPLES*3];
};

#define MAX_ROT_SAMPLES 30
#define NUM_ROT_SEQ 29
struct RotAnimSeq
{
	char quatIds[MAX_ROT_SAMPLES*3];
};

#endif // __PRIM_TYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\renderer.cpp ===
//
//	renderer.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "renderer.h"
#include "xbs_app.h"

#ifdef STARTUPANIMATION
#include "mslogo.h"
extern "C" {
#include "av.h"
}
#endif // STARTUPANIMATION

#ifdef HARDWARE_CHECKSUM
extern "C" void __cdecl Ani_ChecksumCallback(DWORD dwContext);
#endif

IDirect3DDevice8 *gpd3dDev = NULL;

///////////////////////////////////////////////////////////////////////////////
void Renderer::Init()
{
	pD3D8 = NULL;
	pD3DDev8 = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void Renderer::UnInit()
{
}
///////////////////////////////////////////////////////////////////////////////
bool Renderer::init(int width,int height)
{
	pD3D8 = Direct3DCreate8(D3D_SDK_VERSION);
	if(!pD3D8)
		return false;

	const int size_mul = 2;
	const int kick_mul = 2;
	pD3D8->SetPushBufferSize(size_mul * 512 * 1024, kick_mul * 32 * 1024);


	ZeroMemory( &d3dPresentParams, sizeof(d3dPresentParams) );
    d3dPresentParams.BackBufferWidth        = width;
    d3dPresentParams.BackBufferHeight       = height;
    d3dPresentParams.BackBufferFormat       = D3DFMT_A8R8G8B8;
    d3dPresentParams.BackBufferCount        = 1;
    d3dPresentParams.EnableAutoDepthStencil = TRUE;
    d3dPresentParams.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dPresentParams.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	d3dPresentParams.MultiSampleType        = D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR; 
//	d3dPresentParams.MultiSampleType        = D3DMULTISAMPLE_NONE; 

	// No VSync.
//	d3dPresentParams.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;

    if (gApp.bWideScreen)
    {
        d3dPresentParams.Flags |= D3DPRESENTFLAG_WIDESCREEN;
    }

#ifdef STARTUPANIMATION
    // Always do interlaced output on an HDTV.
    ULONG AvInfo;
    AvSendTVEncoderOption(NULL, AV_QUERY_AV_CAPABILITIES, 0, &AvInfo);

    if ((AvInfo & AV_PACK_MASK) == AV_PACK_HDTV)
    {
        d3dPresentParams.Flags |= D3DPRESENTFLAG_INTERLACED;
    }
#endif 
    
	if( pD3D8->CreateDevice(D3DADAPTER_DEFAULT,
		                    D3DDEVTYPE_HAL,
						    NULL,
						    D3DCREATE_HARDWARE_VERTEXPROCESSING,
						    &d3dPresentParams,
						    &pD3DDev8 ) != D3D_OK )
	{
#ifndef STARTUPANIMATION
		OutputDebugString("Could not initalize Xbox Video!\n");
#endif // STARTUPANIMATION
		return false;
	}

	for( int i=0; i<4; i++ )
	{
		pD3DDev8->SetTextureStageState( i, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
		pD3DDev8->SetTextureStageState( i, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		pD3DDev8->SetTextureStageState( i, D3DTSS_MIPFILTER, D3DTEXF_NONE );

		pD3DDev8->SetTextureStageState( i, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
		pD3DDev8->SetTextureStageState( i, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
		pD3DDev8->SetTextureStageState( i, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP );

		pD3DDev8->SetTextureStageState( i, D3DTSS_MAXANISOTROPY,4);
	}

	gpd3dDev = pD3DDev8;

#ifdef STARTUPANIMATION

    gpd3dDev->Clear(0,NULL,
                    D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
                    0x00000000,
                    1.f,
                    0 );

    gpd3dDev->Present(NULL,NULL,NULL,NULL);

    // This delay should allow the TV enough time to lock and ensure
    // that the picture doesn't roll on the first few frames of the
    // animation.

    for (i = 0; i < 4; i++)
    {
        gpd3dDev->BlockUntilVerticalBlank();
    }

#endif // STARTUPANIMATION

#ifdef HARDWARE_CHECKSUM
    gpd3dDev->SetVerticalBlankCallback(Ani_ChecksumCallback);
#endif

	return true;
}
///////////////////////////////////////////////////////////////////////////////
void Renderer::shutdown()
{
	if( pD3DDev8 )
	{
		pD3DDev8->Release();
		gpd3dDev = NULL;
	}

	if( pD3D8 )
	{
		pD3D8->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\scene_geometry.h ===
#ifndef __DEFAULT_NAME_H__
#define __DEFAULT_NAME_H__

#include "prim_types.h"

RotAnimSeq theRotAnimSeq[] = 
{
{2,0,48,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{60,0,0,0,0,0,0,0,-1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{86,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{108,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{127,0,-126,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{64,0,0,88,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-86,0,0,0,0,0,0}
,{108,0,0,64,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-62,0,0,0,0,0,0}
,{127,0,-126,0,0,62,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-60,0,0,0,0,0,0}
,{86,0,0,126,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-124,0,0,0,0,0,0}
,{2,0,0,0,0,127,0,-26,1,1,1,1,1,127,-1,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-18,0,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{2,127,0,-10,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,127,0,-62,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{6,127,1,6,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{108,127,0,-86,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-18,50,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-126,127,0,-88,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{23,127,1,29,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,62,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{2,127,1,71,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,127,1,19,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{6,127,1,87,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{108,127,0,-5,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-18,127,0,-125,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-126,127,0,-7,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{23,127,1,110,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,62,81,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,127,1,89,1,1,1,127,-2,-48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

PosAnimSeq thePosAnimSeq[] = 
{
{0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{13,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{26,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{33,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{49,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{65,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{81,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{97,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{113,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-127,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-111,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-95,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-89,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-76,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-63,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-56,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-49,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-42,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-35,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-28,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-21,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-14,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-7,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,7,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,14,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,21,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,28,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,35,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,42,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,49,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,57,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

short numPos = 320;
short thePos[]=
{
	46,374,9290,
	46,374,9282,
	46,374,9029,
	46,374,8776,
	46,374,8679,
	46,374,8562,
	46,374,7863,
	46,374,7163,
	46,374,6916,
	46,374,6821,
	46,374,6725,
	46,374,7078,
	46,374,7129,
	57,268,-10221,
	57,268,-10201,
	57,268,-9624,
	57,268,-9047,
	57,268,-8825,
	57,268,-8751,
	57,268,-8308,
	57,268,-7865,
	57,268,-7572,
	57,268,-7695,
	57,268,-7819,
	57,268,-7942,
	57,268,-7957,
	57,269,-16816,
	57,269,-16555,
	57,269,-16294,
	57,269,-16033,
	57,269,-15772,
	57,269,-15511,
	57,269,-15428,
	-16187,16454,-11876,
	-15779,16045,-11876,
	-15370,15637,-11876,
	-14962,15229,-11876,
	-14554,14820,-11876,
	-14145,14412,-11876,
	-13737,14004,-11876,
	-13329,13595,-11876,
	-12920,13187,-11876,
	-12512,12779,-11876,
	-12104,12370,-11876,
	-11695,11962,-11876,
	-11287,11554,-11876,
	-10879,11145,-11876,
	-10470,10737,-11876,
	-10463,10730,-11876,
	16402,16509,-11876,
	15978,16085,-11876,
	15554,15661,-11876,
	15130,15237,-11876,
	14706,14813,-11876,
	14282,14390,-11876,
	13858,13966,-11876,
	13434,13542,-11876,
	13010,13118,-11876,
	12586,12694,-11876,
	12163,12270,-11876,
	11739,11846,-11876,
	11315,11422,-11876,
	10891,10998,-11876,
	10467,10574,-11876,
	10459,10567,-11876,
	-16346,-16240,-11876,
	-15907,-15802,-11876,
	-15469,-15363,-11876,
	-15031,-14925,-11876,
	-14592,-14487,-11876,
	-14154,-14048,-11876,
	-13715,-13610,-11876,
	-13277,-13171,-11876,
	-12839,-12733,-11876,
	-12400,-12295,-11876,
	-11962,-11856,-11876,
	-11524,-11418,-11876,
	-11085,-10980,-11876,
	-10647,-10541,-11876,
	-10208,-10103,-11876,
	-10200,-10095,-11876,
	16402,-16134,-11876,
	15971,-15702,-11876,
	15539,-15271,-11876,
	15108,-14840,-11876,
	14676,-14408,-11876,
	14245,-13977,-11876,
	13814,-13546,-11876,
	13382,-13114,-11876,
	12951,-12683,-11876,
	12519,-12251,-11876,
	12088,-11820,-11876,
	11657,-11389,-11876,
	11225,-10957,-11876,
	10794,-10526,-11876,
	10362,-10094,-11876,
	10355,-10087,-11876,
	-16187,16454,10668,
	-15949,16216,10668,
	-15541,15807,10668,
	-15132,15399,10668,
	-14724,14991,10668,
	-14316,14582,10668,
	-13907,14174,10668,
	-13499,13766,10668,
	-13091,13357,10668,
	-12682,12949,10668,
	-12274,12541,10668,
	-11866,12132,10668,
	-11457,11724,10668,
	-11049,11316,10668,
	-10640,10907,10668,
	-10463,10730,10668,
	-16346,-16240,10668,
	-16090,-15984,10668,
	-15652,-15546,10668,
	-15213,-15108,10668,
	-14775,-14669,10668,
	-14337,-14231,10668,
	-13898,-13793,10668,
	-13460,-13354,10668,
	-13021,-12916,10668,
	-12583,-12478,10668,
	-12145,-12039,10668,
	-11706,-11601,10668,
	-11268,-11162,10668,
	-10830,-10724,10668,
	-10391,-10286,10668,
	-10200,-10095,10668,
	16402,-16134,10668,
	16162,-15893,10668,
	15749,-15481,10668,
	15337,-15069,10668,
	14924,-14656,10668,
	14512,-14244,10668,
	14100,-13831,10668,
	13687,-13419,10668,
	13275,-13007,10668,
	12862,-12594,10668,
	12450,-12182,10668,
	12037,-11769,10668,
	11625,-11357,10668,
	11213,-10945,10668,
	10800,-10532,10668,
	10621,-10353,10668,
	16403,16508,10668,
	16156,16260,10668,
	15732,15836,10668,
	15308,15413,10668,
	14884,14989,10668,
	14460,14565,10668,
	14037,14141,10668,
	13613,13717,10668,
	13189,13293,10668,
	12765,12869,10668,
	12341,12445,10668,
	11917,12021,10668,
	11493,11597,10668,
	11069,11173,10668,
	10645,10750,10668,
	10461,10565,10668,
	57,269,15933,
	57,269,15644,
	57,269,15354,
	57,269,15065,
	57,269,14776,
	57,269,14535,
	51,269,-11962,
	51,269,-11943,
	51,269,-11366,
	51,269,-10788,
	51,269,-10567,
	51,269,-10493,
	51,269,-10050,
	51,269,-9606,
	51,269,-9314,
	51,269,-9437,
	51,269,-9560,
	51,269,-9684,
	51,269,-9698,
	51,269,11058,
	51,269,11050,
	51,269,10797,
	51,269,10544,
	51,269,10446,
	51,269,10330,
	51,269,9631,
	51,269,8931,
	51,269,8684,
	51,269,8588,
	51,269,8493,
	51,269,8846,
	51,269,8897,
	-3760,264,-8917,
	-3760,264,-8657,
	-3760,264,-8398,
	-3760,264,-8138,
	-3760,264,-7879,
	-3760,264,-7619,
	-3760,264,-7537,
	-2638,-2434,-8917,
	-2638,-2434,-8657,
	-2638,-2434,-8398,
	-2638,-2434,-8138,
	-2638,-2434,-7879,
	-2638,-2434,-7619,
	-2638,-2434,-7537,
	62,-3548,-8917,
	62,-3548,-8657,
	62,-3548,-8398,
	62,-3548,-8138,
	62,-3548,-7879,
	62,-3548,-7619,
	62,-3548,-7537,
	2761,-2427,-8917,
	2761,-2427,-8657,
	2761,-2427,-8398,
	2761,-2427,-8138,
	2761,-2427,-7879,
	2761,-2427,-7619,
	2761,-2427,-7537,
	3875,274,-8917,
	3875,274,-8657,
	3875,274,-8398,
	3875,274,-8138,
	3875,274,-7879,
	3875,274,-7619,
	3875,274,-7537,
	2754,2972,-8917,
	2754,2972,-8657,
	2754,2972,-8398,
	2754,2972,-8138,
	2754,2972,-7879,
	2754,2972,-7619,
	2754,2972,-7537,
	52,4087,-8917,
	52,4087,-8657,
	52,4087,-8398,
	52,4087,-8138,
	52,4087,-7879,
	52,4087,-7619,
	52,4087,-7537,
	-2645,2965,-8917,
	-2645,2965,-8657,
	-2645,2965,-8398,
	-2645,2965,-8138,
	-2645,2965,-7879,
	-2645,2965,-7619,
	-2645,2965,-7537,
	-3760,264,7941,
	-3760,264,7682,
	-3760,264,7423,
	-3760,264,7165,
	-3760,264,6906,
	-3760,264,6647,
	-3760,264,6565,
	-2638,-2434,7941,
	-2638,-2434,7682,
	-2638,-2434,7423,
	-2638,-2434,7165,
	-2638,-2434,6906,
	-2638,-2434,6647,
	-2638,-2434,6565,
	62,-3548,7941,
	62,-3548,7682,
	62,-3548,7423,
	62,-3548,7165,
	62,-3548,6906,
	62,-3548,6647,
	62,-3548,6565,
	2761,-2427,7941,
	2761,-2427,7682,
	2761,-2427,7423,
	2761,-2427,7165,
	2761,-2427,6906,
	2761,-2427,6647,
	2761,-2427,6565,
	3875,274,7941,
	3875,274,7682,
	3875,274,7423,
	3875,274,7165,
	3875,274,6906,
	3875,274,6647,
	3875,274,6565,
	2754,2972,7941,
	2754,2972,7682,
	2754,2972,7423,
	2754,2972,7165,
	2754,2972,6906,
	2754,2972,6647,
	2754,2972,6565,
	52,4087,7941,
	52,4087,7682,
	52,4087,7423,
	52,4087,7165,
	52,4087,6906,
	52,4087,6647,
	52,4087,6565,
	-2645,2965,7941,
	-2645,2965,7682,
	-2645,2965,7423,
	-2645,2965,7165,
	-2645,2965,6906,
	-2645,2965,6647,
	-2645,2965,6565,
	57,269,-13617,
	57,269,-13397,
	57,269,-13178,
	57,269,-12958,
	57,269,-12739,
	57,269,-12663,
	57,269,-13307,
	57,269,-13801,
	57,269,12556,
	57,269,12339,
	57,269,12121,
	57,269,11903,
	57,269,11772,
	57,269,12202,
	57,269,12546,
};

short numQuats = 413;
short theQuats[]=
{
	0,32750,0,
	8862,-21394,-8862,
	0,0,0,
	-16375,-16375,16375,
	-8862,-21394,8862,
	16375,-16375,-16375,
	0,0,-23157,
	-23157,-23157,0,
	-23030,23030,2420,
	-12464,30091,3162,
	0,32570,3423,
	-30091,12464,1310,
	-32570,0,0,
	-12464,-30091,-3162,
	-23030,-23030,-2420,
	-30091,-12464,-1310,
	-16374,-16375,16374,
	2721,2721,-22997,
	2721,-2721,22997,
	0,3849,-32522,
	3849,0,0,
	-16374,16374,16375,
	16375,-16375,16374,
	0,0,23157,
	-23157,23157,0,
	-16375,16374,16375,
	23005,22728,-3751,
	23157,-23157,0,
	0,0,-23157,
	23157,23157,0,
	-16374,16375,-16374,
	-16375,-16375,16374,
	16375,-16374,-16375,
	15645,17073,17073,
	-18783,-18723,-13418,
	3793,22963,22770,
	0,-23157,-23157,
	0,-23157,23157,
	9048,-21316,21316,
	8675,21471,-21471,
	21471,-8675,8675,
	21316,9048,-9048,
	21316,-9048,-9048,
	-21471,-8675,-8675,
	8675,-21471,-21471,
	-9048,-21316,-21316,
	13751,13418,-18723,
	23157,0,0,
	21394,-8862,8862,
	16374,16375,-16375,
	0,0,-314,
	0,0,-788,
	0,0,-798,
	0,0,270,
	0,0,2327,
	0,0,4941,
	0,0,7845,
	0,0,10771,
	0,0,13467,
	0,0,13840,
	0,0,12400,
	0,0,18945,
	0,0,23433,
	0,0,24049,
	0,0,-12532,
	32,-77,-12532,
	118,-286,-12532,
	244,-590,-12530,
	395,-954,-12526,
	556,-1342,-12520,
	711,-1718,-12512,
	847,-2046,-12504,
	949,-2292,-12496,
	1001,-2418,-12492,
	990,-2390,-12493,
	900,-2173,-12500,
	716,-1730,-12512,
	424,-1024,-12525,
	8,-21,-12532,
	-781,1886,-12508,
	-2089,5045,-12357,
	-3723,8988,-11967,
	-5468,13203,-11276,
	-7119,17189,-10314,
	-8510,20545,-9200,
	-8862,21394,-8862,
	-12532,-30257,0,
	-12532,-30256,32,
	-12532,-30255,118,
	-12530,-30251,244,
	-12526,-30241,395,
	-12520,-30227,556,
	-12512,-30208,711,
	-12504,-30187,847,
	-12496,-30170,949,
	-12492,-30160,1001,
	-12493,-30162,990,
	-12500,-30178,900,
	-12512,-30207,716,
	-12525,-30239,424,
	-12532,-30257,8,
	-12508,-30198,-781,
	-12357,-29833,-2089,
	-11967,-28891,-3723,
	-11276,-27224,-5468,
	-10314,-24900,-7119,
	-9200,-22211,-8510,
	-8862,-21394,-8862,
	0,0,-30257,
	-77,32,-30256,
	-286,118,-30255,
	-590,244,-30251,
	-954,395,-30241,
	-1342,556,-30227,
	-1718,711,-30208,
	-2046,847,-30187,
	-2292,949,-30170,
	-2418,1001,-30160,
	-2390,990,-30162,
	-2173,900,-30178,
	-1730,716,-30207,
	-1024,424,-30239,
	-21,8,-30257,
	1886,-781,-30198,
	5045,-2089,-29833,
	8988,-3723,-28891,
	13203,-5468,-27224,
	17189,-7119,-24900,
	20545,-8510,-22211,
	21394,-8862,-21394,
	0,0,30257,
	-77,-32,30256,
	-286,-118,30255,
	-590,-244,30251,
	-954,-395,30241,
	-1342,-556,30227,
	-1718,-711,30208,
	-2046,-847,30187,
	-2292,-949,30170,
	-2418,-1001,30160,
	-2390,-990,30162,
	-2173,-900,30178,
	-1730,-716,30207,
	-1024,-424,30239,
	-21,-8,30257,
	1886,781,30198,
	5045,2089,29833,
	8988,3723,28891,
	13203,5468,27224,
	17189,7119,24900,
	20545,8510,22211,
	21394,8862,21394,
	11,-27,-12532,
	78,-190,-12532,
	192,-465,-12531,
	338,-817,-12528,
	500,-1208,-12522,
	664,-1603,-12515,
	813,-1964,-12506,
	934,-2255,-12498,
	1010,-2440,-12492,
	1028,-2482,-12490,
	971,-2345,-12495,
	825,-1992,-12505,
	574,-1385,-12519,
	202,-489,-12531,
	-406,980,-12526,
	-1649,3981,-12423,
	-3353,8095,-12075,
	-5247,12667,-11381,
	-7058,17040,-10356,
	-8566,20682,-9147,
	-27,11,-30257,
	-190,78,-30256,
	-465,192,-30253,
	-817,338,-30246,
	-1208,500,-30232,
	-1603,664,-30214,
	-1964,813,-30193,
	-2255,934,-30172,
	-2440,1010,-30158,
	-2482,1028,-30155,
	-2345,971,-30166,
	-1992,825,-30191,
	-1385,574,-30225,
	-489,202,-30253,
	980,-406,-30241,
	3981,-1649,-29993,
	8095,-3353,-29153,
	12667,-5247,-27477,
	17040,-7058,-25002,
	20682,-8566,-22084,
	-27,-11,30257,
	-190,-78,30256,
	-465,-192,30253,
	-817,-338,30246,
	-1208,-500,30232,
	-1603,-664,30214,
	-1964,-813,30193,
	-2255,-934,30172,
	-2440,-1010,30158,
	-2482,-1028,30155,
	-2345,-971,30166,
	-1992,-825,30191,
	-1385,-574,30225,
	-489,-202,30253,
	980,406,30241,
	3981,1649,29993,
	8095,3353,29153,
	12667,5247,27477,
	17040,7058,25002,
	20682,8566,22084,
	-12532,-30257,11,
	-12532,-30256,78,
	-12531,-30253,192,
	-12528,-30246,338,
	-12522,-30232,500,
	-12515,-30214,664,
	-12506,-30193,813,
	-12498,-30172,934,
	-12492,-30158,1010,
	-12490,-30155,1028,
	-12495,-30166,971,
	-12505,-30191,825,
	-12519,-30225,574,
	-12531,-30253,202,
	-12526,-30241,-406,
	-12423,-29993,-1649,
	-12075,-29153,-3353,
	-11381,-27477,-5247,
	-10356,-25002,-7058,
	-9147,-22084,-8566,
	0,0,-24,
	0,0,-753,
	0,0,-1100,
	0,0,892,
	0,0,6514,
	0,0,13000,
	0,0,32750,
	0,0,32748,
	0,0,32740,
	0,0,32748,
	0,0,32667,
	0,0,32375,
	0,0,31796,
	0,0,30928,
	0,0,29852,
	0,0,29681,
	0,586,0,
	0,1802,0,
	0,2831,0,
	0,2861,0,
	0,1077,0,
	0,-3544,0,
	0,-11170,0,
	0,-19638,0,
	0,-26599,0,
	0,-29681,0,
	-224,542,-12530,
	-689,1665,-12513,
	-1083,2615,-12485,
	-1094,2643,-12484,
	-412,995,-12526,
	1356,-3274,-12459,
	4274,-10320,-11781,
	7515,-18143,-10029,
	10179,-24574,-7311,
	11358,-27422,-5296,
	-414,414,-23154,
	-1274,1274,-23122,
	-2001,2001,-23071,
	-2023,2023,-23069,
	-762,762,-23145,
	2506,-2506,-23021,
	7898,-7898,-21769,
	13886,-13886,-18532,
	18808,-18808,-13509,
	20988,-20988,-9786,
	-542,224,-30252,
	-1665,689,-30211,
	-2615,1083,-30143,
	-2643,1094,-30141,
	-995,412,-30240,
	3274,-1356,-30079,
	10320,-4274,-28442,
	18143,-7515,-24213,
	24574,-10179,-17651,
	27422,-11358,-12787,
	586,0,32744,
	1802,0,32700,
	2831,0,32627,
	2861,0,32624,
	1077,0,32732,
	-3544,0,32557,
	-11170,0,30786,
	-19638,0,26208,
	-26599,0,19105,
	-29681,0,13840,
	542,224,30252,
	1665,689,30211,
	2615,1083,30143,
	2643,1094,30141,
	995,412,30240,
	-3274,-1356,30079,
	-10320,-4274,28442,
	-18143,-7515,24213,
	-24574,-10179,17651,
	-27422,-11358,12787,
	414,414,23154,
	1274,1274,23122,
	2001,2001,23071,
	2023,2023,23069,
	762,762,23145,
	-2506,-2506,23021,
	-7898,-7898,21769,
	-13886,-13886,18532,
	-18808,-18808,13509,
	-20988,-20988,9786,
	0,0,12532,
	224,542,12530,
	689,1665,12513,
	1083,2615,12485,
	1094,2643,12484,
	412,995,12526,
	-1356,-3274,12459,
	-4274,-10320,11781,
	-7515,-18143,10029,
	-10179,-24574,7311,
	-11358,-27422,5296,
	0,-756,0,
	0,-2324,0,
	0,-3649,0,
	0,-3687,0,
	0,-1390,0,
	0,4566,0,
	0,14215,0,
	0,24156,0,
	0,30786,0,
	0,32561,0,
	293,-708,-12529,
	901,-2177,-12500,
	1415,-3417,-12452,
	1430,-3453,-12450,
	539,-1301,-12521,
	-1771,4276,-12407,
	-5509,13301,-11256,
	-9340,22548,-8356,
	-11851,28612,-4075,
	-12485,30141,-1092,
	542,-542,-23151,
	1666,-1666,-23097,
	2615,-2615,-23009,
	2643,-2643,-23006,
	996,-996,-23136,
	-3273,3273,-22925,
	-10180,10180,-20800,
	-17258,17258,-15441,
	-21899,21899,-7530,
	-23069,23069,-2018,
	708,-293,-30248,
	2177,-901,-30178,
	3417,-1415,-30063,
	3453,-1430,-30059,
	1301,-539,-30229,
	-4276,1771,-29953,
	-13301,5509,-27176,
	-22549,9340,-20175,
	-28612,11851,-9839,
	-30141,12485,-2637,
	-767,0,32741,
	-2356,0,32665,
	-3699,0,32540,
	-3738,0,32535,
	-1409,0,32719,
	4628,0,32421,
	14397,0,29415,
	24406,0,21837,
	30969,0,10650,
	32625,0,2854,
	-708,-293,30248,
	-2177,-901,30178,
	-3417,-1415,30063,
	-3453,-1430,30059,
	-1301,-539,30229,
	4276,1771,29953,
	13301,5509,27176,
	22548,9340,20175,
	28612,11851,9839,
	30141,12485,2637,
	-542,-542,23151,
	-1666,-1666,23097,
	-2615,-2615,23009,
	-2643,-2643,23006,
	-996,-996,23136,
	3273,3273,22925,
	10180,10180,20800,
	17258,17258,15441,
	21899,21899,7530,
	23069,23069,2018,
	-293,-708,12529,
	-901,-2177,12500,
	-1415,-3417,12452,
	-1430,-3453,12450,
	-539,-1301,12521,
	1771,4276,12407,
	5509,13301,11256,
	9340,22549,8356,
	11851,28612,4075,
	12485,30141,1092,
	0,0,-17262,
	0,0,-21537,
	0,0,-25244,
	0,0,-28287,
};


DWORD theQuatSigns[]=
{
	0XEFFFFFFF,
	0XFFFFEBFF,
	0XFFFFFFFF,
	0XFFFFF01F,
	0XFFFFFFFF,
	0XFFFFFFFF,
	0XFFFFFFFF,
	0XFF01FF03,
	0XFFFFFFFF,
	0XFFFFFCFF,
	0XFFFFFFFF,
	0XFFFFFFFF,
	0X1FFFFFFF,
};

SphereInst theSphereInsts[]=
{
{5704,27,-230,0,0,0,1.522714f},
{7776,27,-230,0,0,0,1.522714f},
{6027,403,-230,0,0,0,1.522714f},
{7486,387,-230,0,0,0,1.522714f},
{7454,-348,-230,0,0,0,1.522714f},
{6795,545,-230,0,0,0,1.522714f},
{5995,-332,-230,0,0,0,1.522714f},
{6750,27,-112,0,0,0,2.671428f},
{6686,-490,-230,0,0,0,1.522714f},
{6733,27,-112,0,1,1,2.283272f},
{5855,27,-11,0,1,1,1.301465f},
{6103,-280,-11,0,1,1,1.301465f},
{7350,-293,-11,0,1,1,1.301465f},
{6694,-414,-11,0,1,1,1.301465f},
{6787,470,-11,0,1,1,1.301465f},
{7377,335,-11,0,1,1,1.301465f},
{7626,27,-11,0,1,1,1.301465f},
{6131,349,-11,0,1,1,1.301465f},
{-2847,4790,6279,1,-1,-1,7.010400f},
{6737,8161,-6189,1,-1,-1,7.010400f},
{6737,8161,6279,1,-1,-1,7.010400f},
{16375,4798,6279,1,-1,-1,7.010400f},
{16375,-4805,6279,1,-1,-1,7.010400f},
{16375,4798,-6189,1,-1,-1,7.010400f},
{16375,-4805,-6189,1,-1,-1,7.010400f},
{-2840,-4805,-6189,1,-1,-1,7.010400f},
{-2847,4790,-6189,1,-1,-1,7.010400f},
{-2840,-4805,6279,1,-1,-1,7.010400f}
};

SphereVers theSphereVers[]=
{
{16},
{24}
};

CylinderInst theCylinderInsts[]=
{
{0,16367,-4804,-250,0,-1,-1,3.567284f,1.981200f},
{0,-2836,4798,-250,0,-1,-1,3.567284f,1.981200f},
{1,-16374,-11578,6302,1,-1,-1,3.353000f,135.129410f},
{2,-2836,4798,18,0,-1,-1,3.567284f,1.981200f},
{3,6756,16375,6302,1,-1,-1,3.353000f,135.129501f},
{4,-16375,11578,-6180,1,-1,-1,3.353000f,135.129410f},
{2,-2836,-4804,18,0,-1,-1,3.567284f,1.981200f},
{0,-2836,-4804,-250,0,-1,-1,3.567284f,1.981200f},
{2,-2846,-4799,-16142,2,-1,-1,2.104218f,79.909309f},
{2,-2846,4804,-16142,2,-1,-1,2.104218f,79.909309f},
{5,6756,-16375,-6180,1,-1,-1,3.353000f,135.129410f},
{2,6738,8174,-16142,2,-1,-1,2.104218f,79.909309f},
{2,16356,-4799,-16142,2,-1,-1,2.104218f,79.909309f},
{2,16356,4804,-16142,2,-1,-1,2.104218f,79.909309f},
{2,16367,-4804,18,0,-1,-1,3.567284f,1.981200f},
{4,-16375,11578,6302,1,-1,-1,3.353000f,135.129410f},
{1,-16374,-11578,-6180,1,-1,-1,3.353000f,135.129410f},
{2,16367,4798,18,0,-1,-1,3.567284f,1.981200f},
{0,16367,4798,-250,0,-1,-1,3.567284f,1.981200f},
{2,6748,8169,18,0,-1,-1,3.567284f,1.981200f},
{0,6748,8169,-250,0,-1,-1,3.567284f,1.981200f},
{6,6726,41,-16374,3,-1,-1,7.174442f,15.087600f},
{7,6729,31,16374,3,-1,-1,7.174442f,15.087600f},
{8,4182,30,4210,4,2,-1,0.324547f,19.536489f},
{9,4936,935,4210,4,2,-1,0.324547f,19.536489f},
{10,6747,1308,4210,4,2,-1,0.324547f,19.536491f},
{11,4927,-875,4210,4,2,-1,0.324547f,19.536491f},
{12,6734,-1252,4210,4,2,-1,0.324547f,19.536489f},
{13,8553,930,4210,4,2,-1,0.324547f,19.536489f},
{14,9298,24,4210,4,2,-1,0.324547f,19.536489f},
{15,8545,-879,4210,4,2,-1,0.324547f,19.536486f},
{16,6740,2700,-112,5,3,2,5.387035f,20.375206f},
{16,6740,2700,-112,5,4,3,5.387035f,20.375206f},
{16,6740,2700,-112,5,5,4,5.387035f,20.375206f},
{16,6740,2700,-112,5,6,5,5.387035f,20.375206f},
{16,6740,2700,-112,5,7,6,5.387035f,20.375206f},
{16,6740,2700,-112,5,8,7,5.387035f,20.375206f},
{16,6740,2700,-112,5,9,8,5.387035f,20.375206f},
{16,6740,2700,-112,5,10,9,5.387035f,20.375206f},
{8,11265,24,4210,4,11,-1,0.324547f,19.536488f},
{9,9935,-1575,4210,4,11,-1,0.324547f,19.536488f},
{10,6734,-2237,4210,4,11,-1,0.324547f,19.536489f},
{11,9944,1627,4210,4,11,-1,0.324547f,19.536489f},
{12,6747,2292,4210,4,11,-1,0.324547f,19.536489f},
{13,3537,-1571,4210,4,11,-1,0.324547f,19.536489f},
{14,2216,30,4210,4,11,-1,0.324547f,19.536489f},
{15,3545,1631,4210,4,11,-1,0.324547f,19.536488f}
};

CylinderVers theCylinderVers[]=
{
{1,16},
{5,16},
{5,10},
{1,12},
{1,6},
{1,20}
};

BoxInst theBoxInsts[]=
{
{17,8856,27,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{18,4634,27,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{19,6745,1084,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{20,6745,-1028,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{17,4970,27,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{18,8502,27,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{19,6736,-856,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{20,6736,911,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{21,5519,-1916,-166,0,3,2,1.271931f,6.522720f,1.891589f},
{22,7957,-1916,-157,0,3,2,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,3,2,1.271931f,6.522721f,1.891589f},
{24,6745,-1916,-1214,0,3,2,1.271931f,6.522720f,1.891589f},
{21,5519,-1916,-166,0,4,3,1.271930f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,4,3,1.271930f,6.522719f,1.891589f},
{23,6736,-1916,1021,0,4,3,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,4,3,1.271931f,6.522719f,1.891589f},
{21,5519,-1916,-166,0,5,4,1.271931f,6.522719f,1.891588f},
{22,7957,-1916,-157,0,5,4,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,5,4,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,5,4,1.271930f,6.522719f,1.891589f},
{25,5519,-1916,-166,0,6,5,1.271931f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,6,5,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,6,5,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,6,5,1.271930f,6.522719f,1.891589f},
{21,5519,-1916,-166,0,7,6,1.271931f,6.522720f,1.891589f},
{22,7957,-1916,-157,0,7,6,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,7,6,1.271931f,6.522721f,1.891589f},
{24,6745,-1916,-1214,0,7,6,1.271931f,6.522720f,1.891589f},
{21,5519,-1916,-166,0,8,7,1.271931f,6.522719f,1.891588f},
{22,7957,-1916,-157,0,8,7,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,8,7,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,8,7,1.271930f,6.522719f,1.891589f},
{25,5519,-1916,-166,0,9,8,1.271931f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,9,8,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,9,8,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,9,8,1.271930f,6.522719f,1.891589f},
{21,5519,-1916,-166,0,10,9,1.271930f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,10,9,1.271930f,6.522719f,1.891589f},
{23,6736,-1916,1021,0,10,9,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,10,9,1.271931f,6.522719f,1.891589f},
{26,6703,-28,-2,0,14,12,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,14,12,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,15,13,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,15,13,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,16,14,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,16,14,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,17,15,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,17,15,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,18,16,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,18,16,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,19,17,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,19,17,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,20,18,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,20,18,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,21,19,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,21,19,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,22,20,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,22,20,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,23,21,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,23,21,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,24,22,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,24,22,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,25,23,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,25,23,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,26,24,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,26,24,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,27,25,2.053631f,0.328581f,0.821453f},
{26,6705,84,-4,0,27,25,2.053631f,0.328581f,0.821453f},
{26,6703,-28,-2,0,28,26,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,28,26,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,29,27,2.053632f,0.328582f,0.821453f},
{26,6705,84,-4,0,29,27,2.053632f,0.328582f,0.821453f}
};

TorusInst theTorusInsts[]=
{
{27,6740,52,-4956,0,-1,-1,13.368955f},
{28,6715,42,4956,0,-1,-1,13.368955f},
{29,6745,27,416,1,12,10,7.843735f},
{29,6745,27,973,2,12,10,6.464866f},
{29,6736,27,-1198,2,13,11,6.464863f},
{29,6736,27,-641,1,13,11,7.843732f},
{29,6740,27,2241,3,30,28,9.715066f},
{29,6740,27,-2465,3,31,-1,9.715062f},
{16,6740,-1539,-112,4,3,2,7.760977f},
{16,6740,-2180,-112,4,3,2,7.760977f},
{30,6758,-2149,-112,4,4,3,7.760977f},
{30,6758,-1508,-112,4,4,3,7.760977f},
{31,6740,-2166,-112,4,5,4,7.760977f},
{31,6740,-1534,-112,4,5,4,7.760977f},
{32,6740,-1501,-112,4,6,5,7.760977f},
{32,6740,-2142,-112,4,6,5,7.760977f},
{16,6740,-1550,-142,4,7,6,7.760977f},
{16,6740,-2191,-142,4,7,6,7.760977f},
{31,6723,-2239,-142,4,8,7,7.760977f},
{31,6723,-1598,-142,4,8,7,7.760977f},
{32,6740,-1574,-142,4,9,8,7.760977f},
{32,6740,-2214,-142,4,9,8,7.760977f},
{33,6814,-1496,-76,4,10,9,7.760977f},
{33,6814,-2137,-76,4,10,9,7.760977f},
{34,6682,28,-94,5,14,12,0.980577f},
{34,6740,28,-112,5,14,12,0.980577f},
{35,6726,28,-108,5,14,12,0.980578f},
{35,6726,28,-108,5,15,13,0.980578f},
{34,6682,28,-94,5,15,13,0.980577f},
{34,6740,28,-112,5,15,13,0.980577f},
{34,6740,28,-112,5,16,14,0.980577f},
{34,6682,28,-94,5,16,14,0.980577f},
{35,6726,28,-108,5,16,14,0.980578f},
{35,6726,28,-108,5,17,15,0.980578f},
{34,6682,28,-94,5,17,15,0.980577f},
{34,6740,28,-112,5,17,15,0.980577f},
{35,6726,28,-108,5,18,16,0.980578f},
{34,6682,28,-94,5,18,16,0.980577f},
{34,6740,28,-112,5,18,16,0.980577f},
{35,6726,28,-108,5,19,17,0.980578f},
{34,6682,28,-94,5,19,17,0.980578f},
{34,6740,28,-112,5,19,17,0.980578f},
{35,6726,28,-108,5,20,18,0.980578f},
{34,6682,28,-94,5,20,18,0.980577f},
{34,6740,28,-112,5,20,18,0.980577f},
{35,6726,28,-108,5,21,19,0.980578f},
{34,6682,28,-94,5,21,19,0.980577f},
{34,6740,28,-112,5,21,19,0.980577f},
{35,6726,28,-108,5,22,20,0.980578f},
{34,6682,28,-94,5,22,20,0.980577f},
{34,6740,28,-112,5,22,20,0.980577f},
{34,6740,28,-112,5,23,21,0.980578f},
{35,6726,28,-108,5,23,21,0.980578f},
{34,6682,28,-94,5,23,21,0.980578f},
{34,6740,28,-112,5,24,22,0.980577f},
{35,6726,28,-108,5,24,22,0.980577f},
{34,6682,28,-94,5,24,22,0.980577f},
{34,6682,28,-94,5,25,23,0.980577f},
{35,6726,28,-108,5,25,23,0.980578f},
{34,6740,28,-112,5,25,23,0.980577f},
{34,6740,28,-112,5,26,24,0.980577f},
{35,6726,28,-108,5,26,24,0.980578f},
{34,6682,28,-94,5,26,24,0.980577f},
{34,6740,28,-112,5,27,25,0.980577f},
{35,6726,28,-108,5,27,25,0.980577f},
{34,6682,28,-94,5,27,25,0.980577f},
{34,6740,28,-112,5,28,26,0.980577f},
{35,6726,28,-108,5,28,26,0.980577f},
{34,6682,28,-94,5,28,26,0.980577f},
{34,6740,28,-112,5,29,27,0.980578f},
{35,6726,28,-108,5,29,27,0.980577f},
{34,6682,28,-94,5,29,27,0.980578f},
{36,6764,2981,-6140,6,-1,-1,5.359474f},
{37,6744,2295,6305,6,-1,-1,5.359473f},
{37,6744,3669,6305,6,-1,-1,5.359473f},
{37,6744,2982,6305,6,-1,-1,5.359473f},
{36,6764,2295,-6140,6,-1,-1,5.359474f},
{36,6764,3669,-6140,6,-1,-1,5.359474f},
{36,6764,-3081,-6140,6,-1,-1,5.359474f},
{37,6744,-3080,6305,6,-1,-1,5.359473f},
{37,6744,-2393,6305,6,-1,-1,5.359473f},
{36,6764,-2393,-6140,6,-1,-1,5.359474f},
{36,6764,-3767,-6140,6,-1,-1,5.359474f},
{37,6744,-3767,6305,6,-1,-1,5.359473f}
};

TorusVers theTorusVers[]=
{
{0.076322f,32,12},
{0.079062f,32,10},
{0.057254f,32,10},
{0.082361f,24,10},
{0.166786f,32,8},
{0.078551f,12,6},
{0.165014f,32,10}
};

ConeInst theConeInsts[]=
{
{2,-2836,4798,1044,0,-1,-1},
{0,-2836,4798,-1276,0,-1,-1},
{2,-2836,-4804,1044,0,-1,-1},
{0,-2836,-4804,-1276,0,-1,-1},
{2,16367,-4804,1044,0,-1,-1},
{0,16367,-4804,-1276,0,-1,-1},
{2,16367,4798,1044,0,-1,-1},
{0,16367,4798,-1276,0,-1,-1},
{2,6748,8169,1044,0,-1,-1},
{0,6748,8169,-1276,0,-1,-1},
{38,3029,1849,-6322,1,-1,-1},
{39,10379,1885,-6322,1,-1,-1},
{40,3101,-1830,-6322,1,-1,-1},
{41,10452,-1793,-6322,1,-1,-1},
{42,10426,1839,6322,1,-1,-1},
{43,3076,1875,6322,1,-1,-1},
{44,10354,-1840,6322,1,-1,-1},
{45,3003,-1803,6322,1,-1,-1},
{46,6980,26,-185,2,14,12},
{46,6980,26,-185,2,15,13},
{46,6980,26,-185,2,16,14},
{46,6980,26,-185,2,17,15},
{46,6980,26,-185,2,18,16},
{46,6980,26,-185,2,19,17},
{46,6980,26,-185,2,20,18},
{46,6980,26,-185,2,21,19},
{46,6980,26,-185,2,22,20},
{46,6980,26,-185,2,23,21},
{46,6980,26,-185,2,24,22},
{46,6980,26,-185,2,25,23},
{46,6980,26,-185,2,26,24},
{46,6980,26,-185,2,27,25},
{46,6980,26,-185,2,28,26},
{46,6980,26,-185,2,29,27}
};

ConeVers theConeVers[]=
{
{3.594747f,2.523780f,6.400800f,2,10},
{5.576570f,5.387035f,7.578804f,1,16},
{0.268712f,0.138889f,3.377083f,1,8}
};

SurfOfRevInst theSurfOfRevInsts[]=
{
{47,9275,94,-5620,0,-1,-1},
{36,4180,84,5620,0,-1,-1},
{37,4182,27,-1372,1,12,10},
{37,9299,27,1147,2,13,11},
{48,8556,-881,1620,3,30,28},
{49,6740,-1258,-1836,4,31,-1}
};

SurfOfRevVers theSurfOfRevVers[]=
{
{{-4.359139f,-2.958513f,-0.000000f,4,1.970802f,-2.925227f,-0.000000f,4,1.970802f,-3.197081f,0.000000f,4,1.988851f,-3.298593f,-0.000000f,3,2.027048f,-3.375998f,-0.000000f,3,2.084253f,-3.432359f,-0.000000f,3,2.159328f,-3.470741f,-0.000000f,3,2.251134f,-3.494205f,-0.000000f,3,2.358533f,-3.505817f,-0.000000f,3,2.480385f,-3.508639f,-0.000000f,4,2.566736f,-3.500061f,-0.000000f,3,2.641094f,-3.472886f,-0.000000f,3,2.704348f,-3.431704f,-0.000000f,3,2.757388f,-3.381108f,-0.000000f,3,2.801100f,-3.325687f,-0.000000f,3,2.836375f,-3.270034f,-0.000000f,3,2.864100f,-3.218738f,0.000000f,4,11.824816f,17.751820f,0.000000f,4,-4.380587f,17.751820f,0.000000f,4},0.000000f,1.000000f,0.000000f,-10.616185f,0.000000f,0.000000f,24,19},
{{-5.504433f,-10.641512f,0.000000f,4,-4.774506f,-10.642336f,0.000000f,4,-3.894176f,-10.139321f,0.000000f,4,-3.686893f,-9.865250f,0.000000f,4,-1.490274f,-0.327833f,0.000001f,4,-5.505459f,-0.327833f,-0.000000f,4},0.000000f,1.000000f,0.000000f,-10.586493f,-0.000000f,-0.000000f,24,6},
{{5.504433f,10.569339f,-0.000002f,4,5.464631f,10.713093f,-0.000002f,3,5.382375f,10.793278f,-0.000002f,3,5.247026f,10.808883f,-0.000002f,3,5.047949f,10.758904f,-0.000002f,3,4.774506f,10.642333f,-0.000002f,4,3.894175f,10.139318f,-0.000002f,4,3.839351f,10.110714f,-0.000002f,3,3.792788f,10.076303f,-0.000001f,3,3.752907f,10.028785f,-0.000001f,3,3.718134f,9.960867f,-0.000001f,3,3.686892f,9.865248f,-0.000001f,4,1.490273f,0.327833f,-0.000001f,4,5.505459f,0.327833f,0.000000f,4},0.000000f,-1.000000f,0.000000f,10.586493f,-0.000000f,0.000000f,24,14},
{{-8.638294f,3.612662f,0.000001f,4,-2.510784f,3.622479f,0.000001f,4,-2.510784f,-2.186819f,0.000001f,4,-0.669379f,-2.186883f,0.000000f,4,4.378792f,17.751820f,0.000001f,4,-8.659742f,17.751820f,0.000000f,4},0.000000f,1.000000f,0.000000f,-10.616185f,0.000000f,0.000000f,24,6},
{{8.638292f,-3.612659f,-0.000001f,4,2.510784f,-3.622476f,-0.000001f,4,2.510783f,2.186817f,-0.000000f,4,0.669379f,2.186882f,-0.000000f,4,-4.378790f,-17.751804f,-0.000001f,4,8.659740f,-17.751804f,-0.000000f,4},0.000000f,-1.000000f,-0.000000f,10.616182f,-0.000000f,0.000000f,24,6}
};

#endif //__DEFAULT_NAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\SOS.H ===
/*
 	structures and equates for sound operation system
 */

typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned long	ulong;


#ifndef NULL
#define	NULL			0
#endif

#define	LEVEL_SILENCE		0
#define	LEVEL_MUSIC		0
#define	LEVEL_EFFECT	1

#define	MUSIC_VOLUME		0
#define	EFFECT_VOLUME		1
#define	MUSIC_FADE			2
#define	RESTORE_MUSIC_VOLUME	3
#define	SET_RESTORE_VOLUME	4
#define	MUSIC_ATTEN		5

#define	MAX_DURATION		(0xffff-12)		/* max duration */

/* 
 * process (event) structure 
 */

struct	process {
	struct process *next;		/* pointer to next process in queue */
	struct process *prev;		/* pointer to previous process in queue*/
	union  {
			uchar	*c;
			ushort	*i;
			} mem_ptr;
	short	timer;			/* timer value for this process */
	short	prev_timer;		/* last value of timer for delta */
	ushort	function;		/* event type (function) */
	uchar	level;			/* sound level (type) NOT volume */
	uchar	hard_channel;		/* synthesis device channel */
	uchar	type;			/* for later use...*/
	ushort	data1;
	ushort	data2;
};


/*
 *	sound (call) structure
 */

struct	sound {
	const uchar	type;		/* sound type (backg, forg, vox, etc) */
	const uchar	priority;	/* priority of this sound */
	const ushort	track_map;	/* bit map for tracks this sound uses */
	const ushort	**tbl_ptr;	/* pointer to this sounds event pointers */
};	

/*
 * sound call receive fifo structure
 */
  
#define	FIFO_SIZE	16

struct	fifo {
	uchar	fifo_read;
	uchar	fifo_write;
	uchar	data[FIFO_SIZE];
};



/*************************************************************************
*                                                                        *
* 	Track information						  *
*      NOTE:								  *
*	Tracks are soft                                                   *
*************************************************************************/
#define	MAX_LOOP	4	/* # of nested loops allowed 	*/
#define	MAX_MUX		3   	/* # of nested mux's allowed 	*/

struct	track_info {
	ushort 	patch;			/* pointer to this tracks voice */
	signed char	pan;			/* left/right/center pan	*/
	uchar	volume;			/* patch's attenuation value	*/
	uchar	lfo_sens;		/* patch's lfo sensitivity value*/
	ushort	pitch;			/* current pitch 		*/
	ushort	loop_counter[MAX_LOOP];	/* # of times to loop		*/
	ushort	*loop_addr[MAX_LOOP];	/* address of loop back points  */
	uchar	loop_level;		/* deepness of loop		*/
	ushort	*mux_addr[MAX_MUX];	/* address of mux back points   */
	uchar	mux_level;		/* deepness of mux		*/
	short	transpose;		/* transposition of track	*/
	ushort	filtercutoff;	/* filter cutoff */
	ushort	filterres;		/* filter resonance */
};

/*************************************************************************
*                                                                        *
* 	Timer music structurs											  *
*                                                                        *
*************************************************************************/
#define	MUSIC_TIMER_PENDING	2		/* silent but "playing" */
#define	MUSIC_TIMER_ON		1		/* playing				*/
#define	MUSIC_TIMER_OFF		0		/* not playing			*/
#define	MAX_TIMERS			17

struct	timer_music {
	uchar	priority;		/* priority of timer					*/
	uchar	sound_call;		/* sound call to make for this timer	*/
	uchar	off_fx;			/* sound fx call to make for end of timr*/
};

/*************************************************************************
*                                                                        *
* 	Channel information						  *
* 	NOTE:								  *
* 	Channels are hard						  *
*                                                                        *
*************************************************************************/


struct	channel_info {
	uchar	type;		/* type of channel 			 */
	uchar	level;		/* current highest level playing on chan */
};



/*************************************************************************
*                                                                        *
* 	Add a watchdog check to code					  *
*                                                                        *
*************************************************************************/


#define	DOGIT	do_watchdog()







=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\scene_renderer.cpp ===
//
//	scene_renderer.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "xbs_app.h"
#include "scene_renderer.h"
#include "scene_geometry.h"
#include "renderer.h"
#include "tex_gen.h"
	
const float LO_Z_VAL =   (00.f);
const float CEIL_Z =	   (40.f);
const float FLOOR_Z =    (-30.f);
#define SB_WIDTH   (512)
#define SB_HEIGHT  (512)


DWORD FtoDW(float f)
{
	return *((DWORD *)(&f));
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::Init()
{
	nInstances = 0;
	nVersions  = 0;

	aInstRecs = NULL;
	aVersRecs = NULL;
	
	pIB = NULL;
	pBaseStream = NULL;
	pExtraStream = NULL;
}

///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::UnInit()
{
	if( pBaseStream )
	{
		pBaseStream->Release();
		pBaseStream = NULL;
	}

	if( pExtraStream )
	{
		pExtraStream->Release();
		pExtraStream = NULL;
	}

	if( pIB )
	{
		pIB->Release();
		pIB = NULL;
	}

	if( aInstRecs )
	{
		MemFree(aInstRecs);
		aInstRecs = NULL;
	}

	if( aVersRecs )
	{
		MemFree(aVersRecs);
		aVersRecs = NULL;
	}

	nInstances = 0;
	nVersions  = 0;
}

///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createSphereVersion( const SphereVers  *psphere, 
									    BYTE *pbase, BYTE *pextra,
										unsigned short *pi,
										int idx,int ndet_bias )
{
	int nSegs   = (int) psphere->nSegs>>ndet_bias;
	int nSlices = (int) nSegs/2;

	float fDeltaTheta = (2.f*Pi)/((float)nSegs);
	float fDeltaPhi   = Pi/((float)nSlices-1);

	int i;

	BaseStream *pbase_stream = (BaseStream *)pbase;

	for(i = 0; i < nSlices; i++)
	{
		float fPhi = fDeltaPhi * ((float)i);

		float fSinPhi,fCosPhi;
		SinCos(fPhi,&fSinPhi,&fCosPhi);
		
		float fV = fPhi/Pi;

		for(int j = 0; j < nSegs; j++)
		{	
			float fTheta = fDeltaTheta * ((float)j);

			float fSinTheta,fCosTheta;
			SinCos(fTheta,&fSinTheta,&fCosTheta);

			Set(&pbase_stream->p,fCosPhi,fCosTheta * fSinPhi,fSinTheta * fSinPhi);
			
			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					Set( &pps->s, 0.f, -fSinTheta, fCosTheta );
					pps->n = pbase_stream->p;
					Cross( pps->s, pps->n, &pps->t );

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;
					
					Set( &pbs->s, 0.f, -fSinTheta, fCosTheta );
					pbs->n = pbase_stream->p;
					Cross( pbs->s, pbs->n, &pbs->t );
					
					pbs->u = fTheta / (2.f*Pi); 
					pbs->v = fV;

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream; 
		}
	}

	WORD wCurVert = (WORD)aVersRecs[idx].dwVertexStart;

	for(i = 0; i < nSlices - 1; i++)
	{
		WORD wStartVert = wCurVert;

		for(int j = 0; j < nSegs + 1; j++)
		{
			*pi++ = wCurVert + nSegs;
			*pi++ = wCurVert;

			if(j < nSegs - 1)
				++wCurVert;
			else
				wCurVert = wStartVert;
		}

		wCurVert += (WORD)nSegs;
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createCylinderVersion( const CylinderVers  * pcyl,
										  BYTE *pbase, BYTE *pextra,
										  unsigned short *pi, 
										  int idx,int ndet_bias)
{
	int nsides = pcyl->nSides>>ndet_bias;

	float fDeltaZ = 1.f/((float)pcyl->nHeightSeg);
	float fDeltaTheta = (2.f * Pi)/((float)nsides);

	D3DVECTOR *ppts = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(nsides+1));

	BaseStream *pbase_stream = (BaseStream *)pbase;
	
	int i;
	for(i = 0; i < nsides+1; i++)
	{
		float fTheta = fDeltaTheta * ((float)i);
		float fSinTheta,fCosTheta;

		SinCos(fTheta,&fSinTheta,&fCosTheta);
		
		Set( &ppts[i],fCosTheta,fSinTheta,fTheta/(2.f*Pi));
	}

	for(i = nsides-1; i >= 0; i--)
	{
		Set(&pbase_stream->p,ppts[i].x,ppts[i].y,1.f);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,1.f,0.f);
				Set(&pps->n,0.f,0.f,1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts[i].x + 0.5f;
				pbs->v = ppts[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,1.f,0.f);
				Set(&pbs->n,0.f,0.f,1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < nsides; i++)
	{
		Set(&pbase_stream->p,ppts[i].x,ppts[i].y,0.f);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,-1.f,0.f);
				Set(&pps->n,0.f,0.f,-1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts[i].x + 0.5f;
				pbs->v = ppts[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,-1.f,0.f);
				Set(&pbs->n,0.f,0.f,-1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < pcyl->nHeightSeg+1; i++)
	{
		float fZ = fDeltaZ * ((float)i);

		for(unsigned short j = 0; j < nsides+1; j++)
		{
			Set(&pbase_stream->p,ppts[j].x,ppts[j].y,fZ);
			
			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					Set(&pps->s,-ppts[j].y,ppts[j].x,0.f);
					Set(&pps->t,0.f,0.f,1.f);
					Set(&pps->n,ppts[j].x,ppts[j].y,0.f);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					pbs->u = 4.0f * ppts[j].z;
					pbs->v = fZ * 32.0f;
		
					Set(&pbs->s,-ppts[j].y,ppts[j].x,0.f);
					Set(&pbs->t,0.f,0.f,1.f);
					Set(&pbs->n,ppts[j].x,ppts[j].y,0.f);

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}
	}

	MemFree(ppts);

	
	WORD wStartCap = (WORD)aVersRecs[idx].dwVertexStart;
	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}

	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}

	CreateTristripForMesh(pi, nsides, pcyl->nHeightSeg, false, false, wStartCap);
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createConeVersion( const ConeVers * pcone,
									  BYTE *pbase,BYTE *pextra,
									  unsigned short *pi, 
									  int idx,int ndet_bias )
{
	int nsides = pcone->nSides>>ndet_bias;

	float fDeltaTheta = (2.f * Pi)/((float)nsides);

	D3DVECTOR *ppts_bot = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(nsides+1));
	D3DVECTOR *ppts_top = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(nsides+1));

	BaseStream *pbase_stream = (BaseStream *)pbase;

	int i;
	for(i = 0; i < nsides+1; i++)
	{
		float fTheta = fDeltaTheta * ((float)i);
		float fSinTheta,fCosTheta;

		SinCos(fTheta,&fSinTheta,&fCosTheta);
		
		Set(&ppts_bot[i],fCosTheta * pcone->fRad1,fSinTheta * pcone->fRad1,fTheta/(2.f*Pi));
		Set(&ppts_top[i],fCosTheta * pcone->fRad2,fSinTheta * pcone->fRad2,fTheta/(2.f*Pi));
	}

	float fDeltaZ = 1.f/((float)(pcone->nHeightSeg));

	for(i = nsides-1; i >= 0; i--)
	{
		Set(&pbase_stream->p,ppts_top[i].x,ppts_top[i].y,pcone->fHeight);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,1.f,0.f);
				Set(&pps->n,0.f,0.f,1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts_top[i].x + 0.5f;
				pbs->v = ppts_top[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,1.f,0.f);
				Set(&pbs->n,0.f,0.f,1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < nsides; i++)
	{
		Set(&pbase_stream->p,ppts_bot[i].x,ppts_bot[i].y,0.f);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,-1.f,0.f);
				Set(&pps->n,0.f,0.f,-1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts_bot[i].x + 0.5f;
				pbs->v = ppts_bot[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,-1.f,0.f);
				Set(&pbs->n,0.f,0.f,-1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < pcone->nHeightSeg + 1; i++)
	{
		float fZ = fDeltaZ * ((float)i);

		for(unsigned short j = 0; j < nsides+1; j++)
		{	
			Set( &pbase_stream->p,
				 ppts_bot[j].x + fZ * ( ppts_top[j].x - ppts_bot[j].x ),
				 ppts_bot[j].y + fZ * ( ppts_top[j].y - ppts_bot[j].y ),
				 fZ * pcone->fHeight );


			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					Set(&pps->s, -ppts_top[j].y, ppts_top[j].x, 0.f );
					Normalize(&pps->s);
					Set(&pps->t,ppts_top[j].x - ppts_bot[j].x,ppts_top[j].y - ppts_bot[j].y,pcone->fHeight);
					Normalize(&pps->t);
					Cross(pps->s,pps->t,&pps->n);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					Set(&pbs->s, -ppts_top[j].y, ppts_top[j].x, 0.f );
					Normalize(&pbs->s);
					Set(&pbs->t,ppts_top[j].x - ppts_bot[j].x,ppts_top[j].y - ppts_bot[j].y,pcone->fHeight);
					Normalize(&pbs->t);
					Cross(pbs->s,pbs->t,&pbs->n);

					pbs->u = ppts_top[j].z;
					pbs->v = fZ;

					pextra += sizeof(BumpStream);
				}
				break;
			}
			
			++pbase_stream;
		}
	}

	MemFree(ppts_bot);
	MemFree(ppts_top);
	

	WORD wStartCap = (WORD)aVersRecs[idx].dwVertexStart;
	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}

	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}	

	CreateTristripForMesh(pi, nsides, pcone->nHeightSeg, false, false, wStartCap);
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createBoxVersion( BYTE *pbase, BYTE *pextra,
									 unsigned short *pi,int idx)
{
	float fUV[4][2] = 
	{ 
		{ 0.f,1.f }, 
		{ 1.f,1.f }, 
		{ 1.f,0.f },
		{ 0.f,0.f } 
	};

	BaseStream *pbase_stream = (BaseStream *)pbase;

	for(int i = 0; i < 6; i++)
	{
		D3DVECTOR vS,vT,vN;
		D3DVECTOR vPos[4];

		switch(i)
		{
			case 0: 
			{
				Set(&vS,0.f,1.f,0.f);
				Set(&vT,0.f,0.f,1.f);
				Set(&vN,1.f,0.f,0.f);
				
				Set(&vPos[0],0.5f,-0.5f, 0.5f);
				Set(&vPos[1],0.5f, 0.5f, 0.5f);
				Set(&vPos[2],0.5f, 0.5f,-0.5f);
				Set(&vPos[3],0.5f,-0.5f,-0.5f);
				break;
			}
			case 1: 
			{
				Set(&vS,-1.f,0.f,0.f);
				Set(&vT, 0.f,0.f,1.f);
				Set(&vN, 0.f,1.f,0.f);
			
				Set(&vPos[0], 0.5f,0.5f, 0.5f);
				Set(&vPos[1],-0.5f,0.5f, 0.5f);
				Set(&vPos[2],-0.5f,0.5f,-0.5f);
				Set(&vPos[3], 0.5f,0.5f,-0.5f);
				break;
			}

			case 2: 
			{
				Set(&vS,0.f,-1.f,0.f);
				Set(&vT,0.f, 0.f,1.f);
				Set(&vN,0.f,-1.f,0.f);

				Set(&vPos[0],-0.5f, 0.5f, 0.5f);
				Set(&vPos[1],-0.5f,-0.5f, 0.5f);
				Set(&vPos[2],-0.5f,-0.5f,-0.5f);
				Set(&vPos[3],-0.5f, 0.5f,-0.5f);
				break;
			}

			case 3: 
			{
				Set(&vS,1.f, 0.f,0.f);
				Set(&vT,0.f, 0.f,1.f);
				Set(&vN,0.f,-1.f,0.f);

				Set(&vPos[0],-0.5f,-0.5f, 0.5f);
				Set(&vPos[1], 0.5f,-0.5f, 0.5f);
				Set(&vPos[2], 0.5f,-0.5f,-0.5f);
				Set(&vPos[3],-0.5f,-0.5f,-0.5f);
				break;
			}

			case 4: 
			{
				Set(&vS,1.f,0.f,0.f);
				Set(&vT,0.f,1.f,0.f);
				Set(&vN,0.f,0.f,1.f);

				Set(&vPos[0],-0.5f, 0.5f,0.5f);
				Set(&vPos[1], 0.5f, 0.5f,0.5f);
				Set(&vPos[2], 0.5f,-0.5f,0.5f);
				Set(&vPos[3],-0.5f,-0.5f,0.5f);
				break;
			}

			case 5: 
			{
				Set(&vS,1.f, 0.f, 0.f);
				Set(&vT,0.f,-1.f, 0.f);
				Set(&vN,0.f, 0.f,-1.f);

				Set(&vPos[0],-0.5f,-0.5f,-0.5f);
				Set(&vPos[1], 0.5f,-0.5f,-0.5f);
				Set(&vPos[2], 0.5f, 0.5f,-0.5f);
				Set(&vPos[3],-0.5f, 0.5f,-0.5f);
				break;
			}
		}

		for(int j = 0; j < 4; j++)
		{
			pbase_stream->p = vPos[j];
			
			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					pps->s = vS;
					pps->t = vT;
					pps->n = vN;

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					pbs->u = fUV[j][0];
					pbs->v = fUV[j][1];
					pbs->s = vS;
					pbs->t = vT;
					pbs->n = vN;

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}

		WORD wVertStart = i * 4;

		*pi++ = wVertStart;
		*pi++ = wVertStart+1;
		*pi++ = wVertStart+2;
		*pi++ = wVertStart;
		*pi++ = wVertStart+2;
		*pi++ = wVertStart+3;
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createTorusVersion( const TorusVers  * ptorus,
									   BYTE *pbase, BYTE *pextra,
									   unsigned short *pi, 
									   int idx,int ndet_bias)
{
	int nsegs = ptorus->nSegs>>ndet_bias;
	int nsides = ptorus->nSides>>ndet_bias;

	float fDeltaTheta = (2.f*Pi)/((float)nsegs);
	float fDeltaPhi   = (2.f*Pi)/((float)nsides);

	BaseStream *pbase_stream = (BaseStream *)pbase;

	int i;
	for(i = 0; i < nsides; i++)
	{
		float fPhi = fDeltaPhi * ((float)i);
		float fSinPhi,fCosPhi;

		SinCos(fPhi,&fSinPhi,&fCosPhi);

		float fRad = 1.f + (fCosPhi * ptorus->fRatio);
		float fV   = fPhi/(2.f * Pi);
		float fZ   = fSinPhi * ptorus->fRatio; 
		
		for(unsigned short j = 0; j < nsegs; j++)
		{
			float fTheta = fDeltaTheta * ((float)j);
			float fSinTheta,fCosTheta;

			SinCos(fTheta,&fSinTheta,&fCosTheta);

			Set(&pbase_stream->p,fCosTheta * fRad,fSinTheta * fRad,fZ);

			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					Set(&pps->s,-fSinTheta,fCosTheta,0.f);
					Set(&pps->t, fCosTheta * -fSinPhi,fSinTheta * -fSinPhi,fCosPhi);

					Cross(pps->s,pps->t,&pps->n);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					pbs->u = fTheta/(2.f*Pi);
					pbs->v = fV;

					Set(&pbs->s,-fSinTheta,fCosTheta,0.f);
					Set(&pbs->t, fCosTheta * -fSinPhi,fSinTheta * -fSinPhi,fCosPhi);

					Cross(pbs->s,pbs->t,&pbs->n);

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}
	}

	WORD wVersionStart = (WORD)aVersRecs[idx].dwVertexStart;
	WORD wLoVert = wVersionStart;
	WORD wHiVert = wVersionStart + nsegs;

	for(i = 0; i < nsides; i++)
	{
		WORD wStripStartLo = wLoVert;
		WORD wStripStartHi = wHiVert;
		
		for(unsigned short j = 0; j < nsegs + 1; j++)
		{
			*pi++ = wLoVert;
			*pi++ = wHiVert;
			
			if(j < nsegs - 1)
			{
				++wLoVert;
				++wHiVert;
			}
			else
			{
				wLoVert = wStripStartLo;
				wHiVert = wStripStartHi;
			}
		}

		wLoVert += (WORD)nsegs;

		if ( (i+1) < (nsides - 1) )
		{
			wHiVert += (WORD)nsegs;
		}
		else
		{
			wHiVert = wVersionStart;	
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createSurfOfRevVersion( const SurfOfRevVers  * psurf,
										   BYTE *pbase, BYTE *pextra, 
										   unsigned short *pi, 
										   int idx,int ndet_bias )
{		
	DWORD dwPolyPts = psurf->nPts;
	for (int i = 0; i < psurf->nPts; i++)
	{
		if (!(psurf->pts[i].flags & sr_Smooth))
			++dwPolyPts;
	}

	D3DVECTOR *pSegNorms = (D3DVECTOR *) _alloca(dwPolyPts * sizeof(D3DVECTOR));
	D3DVECTOR *pVerts    = (D3DVECTOR *) _alloca(dwPolyPts * sizeof(D3DVECTOR));

	enum NormalCalcFlags
	{
		nf_PrevSeg,	
		nf_NextSeg, 
		nf_BothSeg  
	};

	DWORD * dwVertFlags = (DWORD *)_alloca(dwPolyPts * sizeof(DWORD));

	D3DVECTOR vAxis;
	D3DVECTOR ptOnAxis;

	Set(&vAxis,psurf->ax,psurf->ay,psurf->az);
	Set(&ptOnAxis,psurf->px,psurf->py,psurf->pz);

	int ntot = 0;
	for (i = 0; i < psurf->nPts; i++)
	{
		Set(&pVerts[ntot],psurf->pts[i].x,psurf->pts[i].y,psurf->pts[i].z); 

		if (!(psurf->pts[i].flags & sr_Smooth))
		{
			dwVertFlags[ntot] = nf_PrevSeg;
			Set(&pSegNorms[ntot],0.f,0.f,0.f);
			ntot++;
			
			Set(&pVerts[ntot],psurf->pts[i].x,psurf->pts[i].y,psurf->pts[i].z); 
			dwVertFlags[ntot] = nf_NextSeg;
		}
		else 
		{
			dwVertFlags[ntot] = nf_BothSeg;
		}

		DWORD dwNextVert = i + 1;
		if(dwNextVert == psurf->nPts)
			dwNextVert = 0;

		D3DVECTOR seg;
		Set(&seg, psurf->pts[dwNextVert].x - psurf->pts[i].x,
			      psurf->pts[dwNextVert].y - psurf->pts[i].y,
				  psurf->pts[dwNextVert].z - psurf->pts[i].z );

		D3DVECTOR axisToPt;
		Set(&axisToPt,psurf->pts[dwNextVert].x - ptOnAxis.x,
					  psurf->pts[dwNextVert].y - ptOnAxis.y,
					  psurf->pts[dwNextVert].z - ptOnAxis.z );

		D3DVECTOR tang;
		Cross( vAxis,axisToPt,&tang );
		Cross( tang, seg, &pSegNorms[ntot] );
		Normalize(&pSegNorms[ntot]);

		ntot++;
	}

	D3DVECTOR *pVertNorms = (D3DVECTOR *) _alloca(dwPolyPts * sizeof(D3DVECTOR));
	for (i = 0; i < (int)dwPolyPts; i++)
	{
		switch(dwVertFlags[i])
		{
			case nf_PrevSeg:
				pVertNorms[i] = pSegNorms[(i + dwPolyPts - 1) % dwPolyPts];
				break;

			case nf_NextSeg:
				pVertNorms[i] = pSegNorms[i];
				break;

			case nf_BothSeg:
				Add( pSegNorms[(i + dwPolyPts - 1) % dwPolyPts], pSegNorms[i], &pVertNorms[i] );
				Normalize(&pVertNorms[i]);
				break;
		}
	}

	int nsegs = psurf->nSegs>>ndet_bias;

	float fDeltaTheta = (2.f * Pi)/((float)nsegs);
	float fDeltaV     = 1.f/((float)psurf->nPts-1);

	BaseStream *pbase_stream = (BaseStream *)pbase;

	for (i = 0; i < (nsegs+1); i++)
	{
		float fTheta = fDeltaTheta * ((float)i);
		
		D3DVECTOR4 quat;
		SetQuatFromAxis(vAxis,fTheta,&quat);

		D3DMATRIX rotMat;
		SetRotationFromRHQuat(quat,&rotMat);

		float fU = fTheta/(2.f * Pi);

		unsigned unique_vert_count = 0;
		for (unsigned int j = 0; j < dwPolyPts; j++)
		{
			float fV = fDeltaV * ((float)unique_vert_count);

			if(dwVertFlags[j] != nf_PrevSeg)
				++unique_vert_count;

			D3DVECTOR pt;
			Sub(pVerts[j],ptOnAxis,&pt);
			TransformVector(pt,rotMat,&pbase_stream->p);
			
			pbase_stream->p.x += ptOnAxis.x;
			pbase_stream->p.y += ptOnAxis.y;
			pbase_stream->p.z += ptOnAxis.z;

			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					D3DVECTOR tang;
					Cross(vAxis,pt,&tang);
					TransformVector(tang,rotMat,&pps->s);
					Normalize(&pps->s);

					TransformVector(pVertNorms[j],rotMat,&pps->n);
					Cross(pps->n,pps->s,&pps->t);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					D3DVECTOR tang;
					Cross(vAxis,pt,&tang);
					TransformVector(tang,rotMat,&pbs->s);
					Normalize(&pbs->s);

					TransformVector(pVertNorms[j],rotMat,&pbs->n);
					Cross(pbs->n,pbs->s,&pbs->t);

					pbs->u = fU * 10.f;
					pbs->v = fV * 10.f;

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}
	}

	WORD wLeftVert  = (WORD)aVersRecs[idx].dwVertexStart;
	WORD wRightVert = (WORD)(wLeftVert + dwPolyPts);

	for (i = 0; i < nsegs; i++)
	{
		WORD wStartStripRight = wRightVert;
		WORD wStartStripLeft  = wLeftVert;

		for (unsigned int j = 0; j < dwPolyPts + 1; j++)
		{
			*pi++ = wRightVert;
			*pi++ = wLeftVert;

			if( j < dwPolyPts - 1 )
			{
				++wRightVert;
				++wLeftVert;
			}
			else
			{
				wRightVert = wStartStripRight;
				wLeftVert  = wStartStripLeft;
			}
		}

		wLeftVert = wRightVert;
		wRightVert += (WORD)dwPolyPts;
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSphereInstance(const SphereInst *psphere, int idx)
{
	SetScale( psphere->fRad, psphere->fRad, psphere->fRad, &aInstRecs[idx].matScale );
	Set( &aInstRecs[idx].vObjScale,psphere->fRad,psphere->fRad,psphere->fRad,1.f );
	
	SetIdentity( &aInstRecs[idx].matOffset );
	aInstRecs[idx].matOffset._41 = ((float)psphere->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)psphere->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)psphere->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;

	SetIdentity(&aInstRecs[idx].matInvOffset);
	aInstRecs[idx].matInvOffset._41 = -(((float)psphere->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X);
	aInstRecs[idx].matInvOffset._42 = -(((float)psphere->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y);
	aInstRecs[idx].matInvOffset._43 = -(((float)psphere->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z);

	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = psphere->idVersion;

	aInstRecs[idx].idxPosAnim = psphere->idPosAnim;
	aInstRecs[idx].idxRotAnim = psphere->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initCylinderInstance( const CylinderInst *pcyl, int idx )
{
	SetScale(pcyl->fRad,pcyl->fRad,pcyl->fHalfHeight*2.f,&aInstRecs[idx].matScale);
	Set(&aInstRecs[idx].vObjScale,pcyl->fRad,pcyl->fRad,pcyl->fHalfHeight*2.f,1.f);


	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[pcyl->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)pcyl->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)pcyl->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)pcyl->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);

	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = pcyl->idVersion;

	aInstRecs[idx].idxPosAnim = pcyl->idPosAnim;
	aInstRecs[idx].idxRotAnim = pcyl->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initConeInstance( const ConeInst *pcone, int idx )
{
	SetScale(1.f,1.f,1.f,&aInstRecs[idx].matScale);
	Set(&aInstRecs[idx].vObjScale,1.f,1.f,1.f,1.f);

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[pcone->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)pcone->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)pcone->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)pcone->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);
	
	aInstRecs[idx].matScaleOffset = aInstRecs[idx].matOffset;

	aInstRecs[idx].idxVersion = pcone->idVersion;

	aInstRecs[idx].idxPosAnim = pcone->idPosAnim;
	aInstRecs[idx].idxRotAnim = pcone->idRotAnim;


	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initBoxInstance( const BoxInst *pbox, int idx )
{
	SetScale(pbox->fWidth,pbox->fLen,pbox->fHeight,&aInstRecs[idx].matScale);
	Set(&aInstRecs[idx].vObjScale,pbox->fWidth,pbox->fLen,pbox->fHeight,1.f);	

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[pbox->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)pbox->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)pbox->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)pbox->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;	
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);
	
	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = 0;

	aInstRecs[idx].idxPosAnim = pbox->idPosAnim;
	aInstRecs[idx].idxRotAnim = pbox->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initTorusInstance( const TorusInst *ptorus, int idx )
{	
	SetScale( ptorus->fRad1, ptorus->fRad1, ptorus->fRad1, &aInstRecs[idx].matScale );
	Set(&aInstRecs[idx].vObjScale,ptorus->fRad1,ptorus->fRad1,ptorus->fRad1,1.f);

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[ptorus->idQuat],&aInstRecs[idx].matOffset);		
	aInstRecs[idx].matOffset._41 = ((float)ptorus->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)ptorus->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)ptorus->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);

	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = ptorus->idVersion;

	aInstRecs[idx].idxPosAnim = ptorus->idPosAnim;
	aInstRecs[idx].idxRotAnim = ptorus->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSurfOfRevInstance( const SurfOfRevInst *psurf, int idx )
{
	SetScale(1.f,1.f,1.f,&aInstRecs[idx].matScale);
	Set( &aInstRecs[idx].vObjScale, 1.f,1.f,1.f,1.f );

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[psurf->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)psurf->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)psurf->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)psurf->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);
	
	aInstRecs[idx].matScaleOffset = aInstRecs[idx].matOffset;

	aInstRecs[idx].idxVersion = psurf->idVersion;

	aInstRecs[idx].idxPosAnim = psurf->idPosAnim;
	aInstRecs[idx].idxRotAnim = psurf->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSphereVersion(const SphereVers *psphere, int idx,int ndet_bias)
{
	DWORD dwSegs   = psphere->nSegs>>ndet_bias;
	DWORD dwSlices = dwSegs/2;

	aVersRecs[idx].dwVertexCount = dwSegs * dwSlices; 
	aVersRecs[idx].dwPrimCount   = (dwSlices-1) * (dwSegs+1) * 2 - 2;
	aVersRecs[idx].dwIndexCount  = aVersRecs[idx].dwPrimCount + 2;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initCylinderVersion(const CylinderVers *pcyl, int idx,int ndet_bias)
{
	int nsides = pcyl->nSides>>ndet_bias;

	aVersRecs[idx].dwVertexCount = (nsides+1) * (pcyl->nHeightSeg+1) + (nsides+1) * 2;
	aVersRecs[idx].dwPrimCount   = 0;
	aVersRecs[idx].dwIndexCount  = 2*nsides + GetNumberOfIndicesForTristripMesh(nsides, pcyl->nHeightSeg);
	aVersRecs[idx].dwParameter   = nsides;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initConeVersion(const ConeVers *pcone,int idx,int ndet_bias)
{
	int nsides = pcone->nSides>>ndet_bias;

	aVersRecs[idx].dwVertexCount = (nsides+1) * (pcone->nHeightSeg+1) + (nsides+1) * 2;
	aVersRecs[idx].dwPrimCount   = 0;
	aVersRecs[idx].dwIndexCount  = 2*nsides + GetNumberOfIndicesForTristripMesh(nsides, pcone->nHeightSeg);
	aVersRecs[idx].dwParameter   = nsides;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initBoxVersion( int idx )
{
	aVersRecs[idx].dwVertexCount = 24;
	aVersRecs[idx].dwPrimCount   = 12;
	aVersRecs[idx].dwIndexCount  = 36;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initTorusVersion(const TorusVers *ptorus,int idx,int ndet_bias)
{
	int nsides = ptorus->nSides>>ndet_bias;
	int nsegs = ptorus->nSegs>>ndet_bias;

	aVersRecs[idx].dwVertexCount = nsegs * nsides; 
	aVersRecs[idx].dwPrimCount   = (nsegs + 1) * nsides * 2 - 2;
	aVersRecs[idx].dwIndexCount  = aVersRecs[idx].dwPrimCount + 2;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSurfOfRevVersion(const SurfOfRevVers *psurf,int idx,int ndet_bias)
{
	DWORD dwDupVerts = 0;

	for (unsigned short i = 0; i < psurf->nPts; i++)
	{
		if (!(psurf->pts[i].flags & sr_Smooth))
			++dwDupVerts;
	}

	int nsegs = psurf->nSegs>>ndet_bias;

	aVersRecs[idx].dwVertexCount = (dwDupVerts + psurf->nPts) * (nsegs+1);
	aVersRecs[idx].dwPrimCount   = (psurf->nPts + dwDupVerts +1) * 2 * nsegs - 2;
	aVersRecs[idx].dwIndexCount  = aVersRecs[idx].dwPrimCount + 2;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::renderZ()
{
	ShaderTypes shader = shaderType;
	shaderType = st_Depth;
	
	render(gApp.blobLight,false);
	
	shaderType = shader;
}

///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::renderShadowMap(bool b_hi_z)
{
	ShaderTypes shader = shaderType;
	shaderType = st_ShadowMap;
	
	bHiZ = b_hi_z;
	
	render(gApp.blobLight,false);
	
	shaderType = shader;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::render( const D3DLIGHT8 &light,bool b_query_blob )
{
	gpd3dDev->SetStreamSource( 0, pBaseStream, sizeof(BaseStream) );
	gpd3dDev->SetIndices( pIB, 0 );

	bool b_no_lighting = false;

	switch( shaderType )
	{
	case st_Bump:
		{
			gpd3dDev->SetTexture(0,pNormalMap);
			gpd3dDev->SetTexture(1,pCubeMap);
			gpd3dDev->SetTexture(2,pCubeMap);
			
			gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
			gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);
			gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
			gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
			gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
			gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSW,  D3DTADDRESS_WRAP );

			gpd3dDev->SetStreamSource( 1, pExtraStream, sizeof(BumpStream) );
			gpd3dDev->SetVertexShader(gApp.dwVShader[st_Bump]);
			gpd3dDev->SetPixelShader (gApp.dwPShader[st_Bump]);
		}
		break;

	case st_Phong:
		{
			gpd3dDev->SetTexture(1,pCubeMap);
			gpd3dDev->SetTexture(2,pCubeMap);
			gpd3dDev->SetStreamSource( 1, pExtraStream, sizeof(PhongStream) );
			gpd3dDev->SetVertexShader( gApp.dwVShader[st_Phong] );
			gpd3dDev->SetPixelShader ( gApp.dwPShader[st_Phong] );
		}
		break;

	case st_Depth:
		{
			b_no_lighting = true;
		}
		break;

	case st_ShadowMap:
		{
			b_no_lighting = true;
			gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
			gpd3dDev->SetRenderState( D3DRS_ZENABLE,			TRUE );
		}
		break;
	}

	D3DVECTOR4 light_val[3];

	if( !b_query_blob  && !b_no_lighting)
	{
		Set(&light_val[0],vAmbient.x * light.Ambient.r,
						  vAmbient.y * light.Ambient.g,
						  vAmbient.z * light.Ambient.b, 1.f );

		Set(&light_val[1],vDiffuse.x * light.Diffuse.r,
						  vDiffuse.y * light.Diffuse.g,
						  vDiffuse.z * light.Diffuse.b, 1.f );

		Set(&light_val[2],vSpecular.x * light.Specular.r,
						  vSpecular.y * light.Specular.g,
						  vSpecular.z * light.Specular.b, 1.f );

		gpd3dDev->SetPixelShaderConstant ( 0,(CONST void *)&light_val, 3 );

		D3DVECTOR4 vAtten;
		Set(&vAtten,light.Attenuation0,light.Attenuation1,light.Attenuation2, 1.f );
		gpd3dDev->SetVertexShaderConstant( 7, (CONST void *)&vAtten,1 );	
	}

	const D3DMATRIX  &matWTP = gApp.theCamera.getWTP();

	SceneRenderer & scene = gApp.sceneGeom;

	for(int i = 0; i < nInstances; i++)
	{
		const PrimitiveInstanceRecord &inst = aInstRecs[i];

		D3DMATRIX world_mat;
		D3DMATRIX inv_world_mat;
		
		if (inst.idxPosAnim >= 0 || inst.idxRotAnim >= 0)
		{
			D3DMATRIX tmp;
			if(inst.idxRotAnim >= 0)
			{
			
				MulMats( inst.matOffset,scene.pRotAnims[inst.idxRotAnim], &tmp );
			}
			else
			{
				tmp = inst.matOffset;
			}

			if(inst.idxPosAnim >= 0)
			{
				tmp._41 += scene.pPosAnims[inst.idxPosAnim].x;
				tmp._42 += scene.pPosAnims[inst.idxPosAnim].y;
				tmp._43 += scene.pPosAnims[inst.idxPosAnim].z;
			}
			

			SetInverse(tmp,&inv_world_mat);
			MulMats(inst.matScale,tmp,&world_mat);
		}
		else
		{
			world_mat = inst.matScaleOffset;
			inv_world_mat = inst.matInvOffset;
		}

		if(shaderType == st_ShadowMap)
		{
			if(inst.bHiZ != bHiZ)
				continue;

			gpd3dDev->SetTransform(D3DTS_WORLD,&world_mat);
		}
		else
		{
			D3DMATRIX matTmp,matFinal;

			MulMats(world_mat,matWTP,&matTmp);
			SetTranspose(matTmp,&matFinal);

			gpd3dDev->SetVertexShaderConstant(0,&matFinal,4);
		}

		D3DVECTOR4 vObjEyePos;
		D3DVECTOR4 vObjLightPos;

		if( b_query_blob && !b_no_lighting )
		{
			D3DVECTOR4 tmp;

			float fIntensity;

			tmp.w = 1.0f;
			gApp.vblob.getLightForPosition(&tmp,&fIntensity,*((D3DVECTOR *) &world_mat._41));
			
			fIntensity = gApp.getBlobIntensity() * 2.f ;

			Set(&light_val[0],vAmbient.x * light.Ambient.r * fIntensity,
							  vAmbient.y * light.Ambient.g * fIntensity,
							  vAmbient.z * light.Ambient.b * fIntensity, 1.f );
		
			Set(&light_val[1],vDiffuse.x * light.Diffuse.r * fIntensity,
							  vDiffuse.y * light.Diffuse.g * fIntensity,
							  vDiffuse.z * light.Diffuse.b * fIntensity, 1.f );

  			Set(&light_val[2],vSpecular.x * light.Specular.r * fIntensity,
							  vSpecular.y * light.Specular.g * fIntensity,
							  vSpecular.z * light.Specular.b * fIntensity, 1.f );


			gpd3dDev->SetPixelShaderConstant ( 0,(CONST void *)&light_val, 3 );

			TransformPoint( tmp, inv_world_mat, &vObjLightPos);

			D3DVECTOR4 vAtten;

			float f_oo_intensity = 1.f/fIntensity;
			Set(&vAtten,light.Attenuation0,light.Attenuation1 * f_oo_intensity, 
										   light.Attenuation2 * f_oo_intensity, 1.f );
			gpd3dDev->SetVertexShaderConstant( 7, (CONST void *)&vAtten,1 );
		}
		else if(shaderType != st_ShadowMap && shaderType != st_Depth)
		{
			TransformPoint( light.Position, inv_world_mat, &vObjLightPos);	
		}
		
		if( shaderType != st_ShadowMap && shaderType != st_Depth )
		{
			vObjLightPos.w = 1.f;
			gpd3dDev->SetVertexShaderConstant(4,&vObjLightPos,1);

			TransformPoint(*((D3DVECTOR *)&gApp.theCamera.matCTW._41),inv_world_mat,&vObjEyePos);
			vObjEyePos.w = 1.f;
		
			gpd3dDev->SetVertexShaderConstant(5,&vObjEyePos,1);
			gpd3dDev->SetVertexShaderConstant(6,&inst.vObjScale,1);

			D3DMATRIX matOTS,finalSMat;
			MulMats(world_mat, (inst.bHiZ) ? scene.matWTSHi : scene.matWTSLo , &matOTS );
			SetTranspose(matOTS,&finalSMat);
			gpd3dDev->SetVertexShaderConstant(8,&finalSMat,4);

			gpd3dDev->SetTexture(3,(inst.bHiZ) ? scene.pSBufDepthHi: scene.pSBufDepthLo );
		}
		
		const PrimitiveVersionRecord &vs = aVersRecs[aInstRecs[i].idxVersion];

		if ((primitiveType==pt_Cylinder) || (primitiveType==pt_Cone))
		{
			int num_indices_in_cap = vs.dwParameter;
			if (num_indices_in_cap)
			{
				gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLEFAN,vs.dwVertexStart,vs.dwVertexCount,
												vs.dwIndexStart + 0, num_indices_in_cap-2 );
				gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLEFAN,vs.dwVertexStart,vs.dwVertexCount,
												vs.dwIndexStart + num_indices_in_cap, num_indices_in_cap-2 );
			}

			gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP,vs.dwVertexStart,vs.dwVertexCount,
											vs.dwIndexStart + 2*num_indices_in_cap,vs.dwIndexCount - 2*num_indices_in_cap - 2 );
		}
		else
		{
			gpd3dDev->DrawIndexedPrimitive( d3dType,vs.dwVertexStart,vs.dwVertexCount,
											vs.dwIndexStart,vs.dwPrimCount );
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::create( const void *				version_data, 
						   int						num_versions, 
						   const void *				instance_data,
						   int						num_insts,
						   int						ndet_bias,
						   ShaderTypes				shader,
						   PrimitiveTypes			primitive,
						   LPDIRECT3DTEXTURE8		pnormal_map,
						   LPDIRECT3DCUBETEXTURE8	pcube_map)
{
	nVersions  = num_versions;
	nInstances = num_insts;

	shaderType = shader;
	primitiveType = primitive;
	pNormalMap = pnormal_map;
	pCubeMap   = pcube_map;

	aVersRecs = (PrimitiveVersionRecord*)MemAlloc(sizeof(PrimitiveVersionRecord)*nVersions);
	ZeroMemory(aVersRecs,sizeof(PrimitiveVersionRecord)*nVersions);

	DWORD dwVertCount  = 0;
	DWORD dwIndexCount = 0;

	unsigned short i;
	for(i = 0; i < nVersions; i++)
	{
		aVersRecs[i].dwVertexStart = dwVertCount;
		aVersRecs[i].dwIndexStart  = dwIndexCount;
		
		switch(primitiveType)
		{
		case pt_Sphere:		
			initSphereVersion( ((const SphereVers *)version_data)+i,i,ndet_bias);
			break;
		case pt_Cone:		
			initConeVersion( ((const ConeVers *)version_data)+i,i,ndet_bias);				
			break;
		case pt_Cylinder:	
			initCylinderVersion( ((const CylinderVers *)version_data)+i,i,ndet_bias);
			break;
		case pt_Box:		
			initBoxVersion(i);													
			break;
		case pt_Torus:		
			initTorusVersion( ((const TorusVers *)version_data)+i,i,ndet_bias);			
			break;
		case pt_SurfOfRev:	
			initSurfOfRevVersion( ((const SurfOfRevVers *)version_data)+i,i,ndet_bias);	
			break;
		}

		dwVertCount  += aVersRecs[i].dwVertexCount;
		dwIndexCount += aVersRecs[i].dwIndexCount;
	}

	DWORD dwExtraStride = 0;

	switch(shaderType)
	{
	case st_Bump:  dwExtraStride = sizeof(BumpStream);  break;
	case st_Phong: dwExtraStride = sizeof(PhongStream); break;
	}

	gpd3dDev->CreateVertexBuffer( sizeof(BaseStream) * dwVertCount, NULL, NULL, NULL, &pBaseStream );
	gpd3dDev->CreateVertexBuffer( dwExtraStride * dwVertCount, NULL, NULL, NULL, &pExtraStream );

	gpd3dDev->CreateIndexBuffer ( sizeof(unsigned short) * dwIndexCount,NULL,D3DFMT_INDEX16,NULL,&pIB);

	BYTE *pbase,*pextra;

	pBaseStream->Lock(0,sizeof(BaseStream) * dwVertCount,&pbase,NULL);
	pExtraStream->Lock(0,dwExtraStride * dwVertCount,&pextra,NULL);

	unsigned short *pi;
	pIB->Lock(0,sizeof(unsigned short) * dwIndexCount,(BYTE **)&pi,NULL);

	for(i = 0; i < nVersions; i++)
	{
		switch(primitiveType)
		{
		case pt_Sphere:		
			createSphereVersion( ((const SphereVers *)version_data)+i,pbase, pextra, pi, i,ndet_bias ); 
			break;		  
		case pt_Cone:		
			createConeVersion( ((const ConeVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias );	
			break;
		case pt_Cylinder:	
			createCylinderVersion( ((const CylinderVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias);  
			break;
		case pt_Box:		
			createBoxVersion(pbase,pextra,pi,i);
			break;
		case pt_Torus:		
			createTorusVersion( ((const TorusVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias);
			break;
		case pt_SurfOfRev:	
			createSurfOfRevVersion( ((const SurfOfRevVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias );
			break;
		}
		
		pbase  += (aVersRecs[i].dwVertexCount * sizeof(BaseStream));
		pextra += (aVersRecs[i].dwVertexCount * dwExtraStride );
		pi     += aVersRecs[i].dwIndexCount;
	}

	pBaseStream->Unlock();
	pExtraStream->Unlock();

	pIB->Unlock();

	aInstRecs  = (PrimitiveInstanceRecord*)MemAlloc(sizeof(PrimitiveInstanceRecord)*nInstances);
	ZeroMemory(aInstRecs,sizeof(PrimitiveInstanceRecord)*nInstances);

	for(i = 0; i < nInstances; i++)
	{
		switch(primitiveType)
		{
		case pt_Sphere:		
			initSphereInstance(((const SphereInst *)instance_data)+i,i);		
			break;
		case pt_Cone:		
			initConeInstance( ((const ConeInst *)instance_data)+i,i);			
			break;
		case pt_Cylinder:	
			initCylinderInstance( ((const CylinderInst *)instance_data)+i,i);   
			break;
		case pt_Box:		
			initBoxInstance( ((const BoxInst *)instance_data)+i,i);			    
			break;											  
		case pt_Torus:		
			initTorusInstance( ((const TorusInst *)instance_data)+i,i);         
			break;
		case pt_SurfOfRev:	
			initSurfOfRevInstance( ((const SurfOfRevInst *)instance_data)+i,i); 
			break;
		}	
	}

	switch(primitiveType)
	{	
	case pt_Box:
		d3dType = D3DPT_TRIANGLELIST;
		break;

	case pt_Cone:	
	case pt_Cylinder:	
	case pt_Sphere:	
	case pt_Torus:		
	case pt_SurfOfRev:
		d3dType = D3DPT_TRIANGLESTRIP;
		break;
	}	

	Set(&vAmbient, 0.2079f,1.f,0.100f,1.f );
	Set(&vDiffuse, 0.2079f,1.f,0.100f,1.f );
	Set(&vSpecular,0.2079f,1.f,0.100f,1.f );
}
///////////////////////////////////////////////////////////////////////////////
D3DVECTOR4 * SceneRenderer::decompressQuats(short *p_quat_data,DWORD *p_sign_data,int nquats)
{
	D3DVECTOR4 *pquats = (D3DVECTOR4 *)MemAlloc(sizeof(D3DVECTOR4)*nquats);
	float f_oo_scale = 1.f/32750.f;
	for(int i = 0; i < nquats; i++,p_quat_data+=3)
	{
		pquats[i].x = ((float)p_quat_data[0]) * f_oo_scale;
		pquats[i].y = ((float)p_quat_data[1]) * f_oo_scale;
		pquats[i].z = ((float)p_quat_data[2]) * f_oo_scale;

		pquats[i].w = fast_sqrt(1.f - pquats[i].x*pquats[i].x - 
						          pquats[i].y*pquats[i].y - 
								  pquats[i].z*pquats[i].z );
		
		int idw  = i >> 5;
		int bpos = i & 31;
		bool b_pos_w = ((p_sign_data[idw] & (1<<bpos))) != 0;
		if(!b_pos_w) 
			pquats[i].w *= -1.f;
	}

	return pquats;
}
///////////////////////////////////////////////////////////////////////////////
D3DVECTOR * SceneRenderer::decompressVecs(short *p_vec_data,int nvecs)
{
	D3DVECTOR * pvecs = (D3DVECTOR *)MemAlloc(sizeof(D3DVECTOR)*nvecs);
	for(int i = 0; i < nvecs; i++,p_vec_data+=3)
	{
		pvecs[i].x = ((float)p_vec_data[0]) * OO_POS_ANIM_SCALE_X + POS_ANIM_DELTA_X;
		pvecs[i].y = ((float)p_vec_data[1]) * OO_POS_ANIM_SCALE_Y + POS_ANIM_DELTA_Y;
		pvecs[i].z = ((float)p_vec_data[2]) * OO_POS_ANIM_SCALE_Z + POS_ANIM_DELTA_Z;
	}
	return pvecs;
}
///////////////////////////////////////////////////////////////////////////////
short * SceneRenderer::decompressIndices(char * p_indices,int nindices)
{
	short * pindices = (short *)MemAlloc(sizeof(short)*nindices);

	if(p_indices[0] == 127)
	{
		char hi = p_indices[1];
		char lo = p_indices[2];

		pindices[0] = ((((short)hi)&0xff)<<8) | (((short)lo)&0xff);
		p_indices += 2;
	}
	else
	{
		pindices[0] = p_indices[0];
	}

	for(int i = 1; i < nindices; i++)
	{
		if(p_indices[i] == 127)
		{
			char hi = p_indices[i+1];
			char lo = p_indices[i+2];

			pindices[i] = ((((short)hi)&0xff)<<8) | (((short)lo)&0xff);
			pindices[i] += pindices[i-1];
			
			p_indices   += 2;
		}
		else
		{
			pindices[i] = pindices[i-1] + p_indices[i];
		}
	}

	return pindices;
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::create()
{
	for(int i = 0; i < pt_NoTypes; i++)
	{
		pSetHiDet[i] = (PrimitiveSet *)MemAlloc(sizeof(PrimitiveSet));
        pSetHiDet[i]->Init();

		pSetLoDet[i] = (PrimitiveSet *)MemAlloc(sizeof(PrimitiveSet));
        pSetLoDet[i]->Init();
	}

	pQuats = decompressQuats(theQuats,theQuatSigns,numQuats);
	for(i = 0; i < NUM_ROT_SEQ; i++)
	{
		pQuatIdSeq[i] = decompressIndices(theRotAnimSeq[i].quatIds,MAX_ROT_SAMPLES);	
	}

	pPos = decompressVecs(thePos,numPos);
	for(i = 0; i < NUM_POS_SEQ; i++)
	{
		pPosIdSeq[i] = decompressIndices(thePosAnimSeq[i].posIds,MAX_POS_SAMPLES);
	}

	createSceneGeometry(pSetHiDet,0);
	createSceneGeometry(pSetLoDet,1);
	bUseLoDetail = false;

    gpd3dDev->CreateTexture(SB_WIDTH,SB_HEIGHT,1,0,D3DFMT_LIN_D16,0,&pSBufDepthLo);
	gpd3dDev->CreateTexture(SB_WIDTH,SB_HEIGHT,1,0,D3DFMT_LIN_D16,0,&pSBufDepthHi);

    memset(&fakeTarget, 0, sizeof(fakeTarget));

    XGSetSurfaceHeader(SB_WIDTH,
                       SB_HEIGHT,
                       D3DFMT_LIN_R5G6B5,
                       &fakeTarget,
                       0,
                       0);

    pSBufTarget = &fakeTarget;

    gpd3dDev->GetDepthStencilSurface(&pZBuffer);
    gpd3dDev->GetRenderTarget(&pRenderTarget);

	fZOffset = 10.f;
    fZSlopeScale = 4.0f;

	nRotAnims = sizeof(theRotAnimSeq)/sizeof(RotAnimSeq);
	nPosAnims = sizeof(thePosAnimSeq)/sizeof(PosAnimSeq);

	pRotAnims = (D3DMATRIX *)MemAlloc(sizeof(D3DMATRIX)*nRotAnims);
	pPosAnims = (D3DVECTOR *)MemAlloc(sizeof(D3DVECTOR)*nPosAnims);
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::createSceneGeometry(PrimitiveSet **pp_sets,int ndet_bias)
{
	pp_sets[pt_Sphere]->create(
		(const void *)theSphereVers, 
		sizeof(theSphereVers)/sizeof(SphereVers),
		(const void *)theSphereInsts, 
		sizeof(theSphereInsts)/sizeof(SphereInst),
		ndet_bias,
		st_Bump,
		pt_Sphere,
		gApp.pRoughBumpMap,
		gApp.pNormalCubeMapLoRes ); 

	pp_sets[pt_SurfOfRev]->create(
		(const void *)theSurfOfRevVers, 
		sizeof(theSurfOfRevVers)/sizeof(SurfOfRevVers),
		(const void *)theSurfOfRevInsts, 
		sizeof(theSurfOfRevInsts)/sizeof(SurfOfRevInst),
		ndet_bias,
		st_Bump, 
		pt_SurfOfRev,
		gApp.pRoughBumpMap,
		gApp.pNormalCubeMapHiRes );

	pp_sets[pt_Cone]->create(
		(const void *)theConeVers, 
		sizeof(theConeVers)/sizeof(ConeVers),
		(const void *)theConeInsts, 
		sizeof(theConeInsts)/sizeof(ConeInst),
		ndet_bias,
		st_Phong,
		pt_Cone,
		NULL, 
		gApp.pNormalCubeMapLoRes );

	pp_sets[pt_Box]->create( 
		NULL,1,
		(const void *)theBoxInsts, 
		sizeof(theBoxInsts)/sizeof(BoxInst),
		ndet_bias,
		st_Phong,
		pt_Box,
		NULL,
		gApp.pNormalCubeMapLoRes );

	pp_sets[pt_Cylinder]->create(
		(const void *)theCylinderVers, 
		sizeof(theCylinderVers)/sizeof(CylinderVers),
		(const void *)theCylinderInsts, 
		sizeof(theCylinderInsts)/sizeof(CylinderInst),
		ndet_bias,
		st_Phong,
		pt_Cylinder,
		NULL,gApp.pNormalCubeMapHiRes );

	pp_sets[pt_Torus]->create(
		(const void *)theTorusVers, 
		sizeof(theTorusVers)/sizeof(TorusVers),
		(const void *)theTorusInsts, 
		sizeof(theTorusInsts)/sizeof(TorusInst),
		ndet_bias,
		st_Phong,
		pt_Torus,
		NULL,
		gApp.pNormalCubeMapLoRes );	
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::destroy()
{
	for(int i = 0; i < pt_NoTypes; i++)
	{
        pSetHiDet[i]->UnInit();
        MemFree(pSetHiDet[i]);
        pSetHiDet[i] = NULL;

		pSetLoDet[i]->UnInit();
        MemFree(pSetLoDet[i]);
        pSetLoDet[i] = NULL;
	}

	MemFree(pRotAnims);
	MemFree(pPosAnims);

	MemFree(pQuats);
	for(i = 0; i < NUM_ROT_SEQ; i++)
	{
		MemFree(pQuatIdSeq[i]);
	}

	MemFree(pPos);
	for(i = 0; i < NUM_POS_SEQ; i++)
	{
		MemFree(pPosIdSeq[i]);
	}

#define XBS_RESOURCE_RELEASE(a) if (a) a->Release(); a = NULL;
    XBS_RESOURCE_RELEASE(pSBufDepthLo);
    XBS_RESOURCE_RELEASE(pSBufDepthHi);
#undef XBS_RESOURCE_RELEASE
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::render(bool b_with_shadows,bool b_use_blob_intensity)
{
	gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
	gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

	gpd3dDev->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSW,  D3DTADDRESS_CLAMP );

	gpd3dDev->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSW,  D3DTADDRESS_CLAMP );
	
	gpd3dDev->SetTextureStageState(3,D3DTSS_ADDRESSU,    D3DTADDRESS_BORDER );
	gpd3dDev->SetTextureStageState(3,D3DTSS_ADDRESSV,    D3DTADDRESS_BORDER );
	gpd3dDev->SetTextureStageState(3,D3DTSS_BORDERCOLOR, 0xffffffff );
	gpd3dDev->SetTextureStageState(3,D3DTSS_MINFILTER,   D3DTEXF_LINEAR );
	gpd3dDev->SetTextureStageState(3,D3DTSS_MAGFILTER,   D3DTEXF_LINEAR );
	gpd3dDev->SetTextureStageState(3,D3DTSS_MIPFILTER,   D3DTEXF_NONE );

	if(b_with_shadows)
	{
		gpd3dDev->SetRenderState(D3DRS_SHADOWFUNC,D3DCMP_GREATER);
	}

	for(int i = 0; i < pt_NoTypes; i++)
	{
		if(bUseLoDetail)
			pSetLoDet[i]->render(gApp.blobLight,b_use_blob_intensity);
		else
			pSetHiDet[i]->render(gApp.blobLight,b_use_blob_intensity);
	}
	if(b_with_shadows)
	{
		gpd3dDev->SetRenderState(D3DRS_SHADOWFUNC,D3DCMP_ALWAYS);
	}

	gpd3dDev->SetTexture(3,NULL);
	gpd3dDev->SetPixelShader(NULL);
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::renderZ()
{
	for(int i = 0; i < pt_NoTypes; i++)
	{
		if(bUseLoDetail)
			pSetLoDet[i]->renderZ();
		else
			pSetHiDet[i]->renderZ();
	}
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::advanceTime(float fElapsedTime, float fDt)
{
	float fpos = ((fElapsedTime-SCENE_ANIM_START_TIME) / SCENE_ANIM_LEN);
	float ffrac_pos =  fpos * ((float)MAX_POS_SAMPLES-2);
	int   pos_id;

    __asm
    {
        cvttss2si eax, ffrac_pos
        mov pos_id, eax
    }

	float ffrac = ffrac_pos - (float)pos_id;
    
	for(int i = 0; i < nPosAnims; i++)
	{
		if(fpos <= 0.f)
		{
			pPosAnims[i] = pPos[pPosIdSeq[i][0]];
		}
		else if(fpos >= 1.f)
		{
			pPosAnims[i] = pPos[pPosIdSeq[i][MAX_POS_SAMPLES-1]];
		}
		else
		{
			D3DVECTOR &a = pPos[pPosIdSeq[i][pos_id]];
			D3DVECTOR &b = pPos[pPosIdSeq[i][pos_id+1]];

			pPosAnims[i].x = a.x * (1.f-ffrac) + b.x * ffrac; 
			pPosAnims[i].y = a.y * (1.f-ffrac) + b.y * ffrac; 
			pPosAnims[i].z = a.z * (1.f-ffrac) + b.z * ffrac; 
		}
	}

	ffrac_pos =  fpos * ((float)MAX_ROT_SAMPLES-2);

    __asm
    {
        cvttss2si eax, ffrac_pos
        mov pos_id, eax
    }

	ffrac = ffrac_pos - (float)pos_id;

	for(i = 0; i < nRotAnims; i++)
	{
		if(fpos <= 0.f)
		{
			D3DVECTOR4 &q = pQuats[pQuatIdSeq[i][0]];
			SetRotationFromLHQuat(q,&pRotAnims[i]);
		}
		else if(fpos >= 1.f)
		{
			D3DVECTOR4 &q = pQuats[pQuatIdSeq[i][MAX_ROT_SAMPLES-1]];
			SetRotationFromLHQuat(q,&pRotAnims[i]);
		}
		else
		{
			D3DVECTOR4 &a = pQuats[pQuatIdSeq[i][pos_id]];
			D3DVECTOR4 &b = pQuats[pQuatIdSeq[i][pos_id+1]];

			D3DVECTOR4 res;
			SlerpQuats(a,b,ffrac,&res);
			SetRotationFromLHQuat(res,&pRotAnims[i]);
		}	
	}

	bUseLoDetail = fElapsedTime >= SCENE_LO_DETAIL_START;
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::updateShadows()
{
	Camera cam = gApp.theCamera;
	updateSBuffer( false);
	updateSBuffer( true );
	gApp.theCamera = cam;
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::updateSBuffer(bool b_hi_z)
{
	Camera &cam = gApp.theCamera;

	D3DVECTOR eye_pos,look_pt,up;

	D3DVECTOR pos;
	pos.x = 0.0f;
	pos.y = 0.0f;
	pos.z = b_hi_z ? CEIL_Z : FLOOR_Z;

	float fi;
	gApp.vblob.getLightForPosition(&eye_pos,&fi,pos);

	D3DVECTOR dir ;
	Set(&dir,0.f,0.f,(b_hi_z) ? 1.f : -1.f);
	Add(eye_pos,dir,&look_pt);
	Set(&up,0.f,(b_hi_z) ? -1.f : 1.f,0.f);
	
	cam.lookAt(eye_pos,look_pt,up);
	cam.setProjection(Pi/1.5f,1.f,1.f,500.f);

	D3DMATRIX shadow_proj_mat = cam.matProj;
	D3DMATRIX shadow_vp_mat;
    SetIdentity(&shadow_vp_mat);

    shadow_vp_mat._11 = SB_WIDTH   * 0.5f;
    shadow_vp_mat._22 = -SB_HEIGHT * 0.5f;
    shadow_vp_mat._33 = D3DZ_MAX_D16;

    shadow_vp_mat._41 = SB_WIDTH  * 0.5f + 0.5f;
    shadow_vp_mat._42 = SB_HEIGHT * 0.5f + 0.5f;

	D3DMATRIX mat;
	MulMats( cam.matWTC,shadow_proj_mat,&mat );
    MulMats( mat, shadow_vp_mat, (b_hi_z) ? &matWTSHi : &matWTSLo );
	
	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		IDirect3DSurface8 *psurf;

		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
		gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE,FALSE);
		gpd3dDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
		
		if(b_hi_z) 
			pSBufDepthHi->GetSurfaceLevel(0,&psurf);
		else	   
			pSBufDepthLo->GetSurfaceLevel(0,&psurf);

		gpd3dDev->SetRenderTarget(pSBufTarget,psurf);

		D3DVIEWPORT8 viewport = { 0, 0, SB_WIDTH, SB_HEIGHT, 0.0f, 1.0f };
		gpd3dDev->SetViewport(&viewport);

		gpd3dDev->Clear(0,NULL,D3DCLEAR_ZBUFFER,0,1.0f,0);
		gpd3dDev->SetRenderState(D3DRS_COLORWRITEENABLE,0);

		gpd3dDev->SetRenderState(D3DRS_SOLIDOFFSETENABLE, TRUE);
		gpd3dDev->SetRenderState(D3DRS_POLYGONOFFSETZOFFSET, FtoDW(fZOffset));
		gpd3dDev->SetRenderState(D3DRS_POLYGONOFFSETZSLOPESCALE, FtoDW(fZSlopeScale));

		gpd3dDev->SetVertexShader(D3DFVF_XYZ);
		gpd3dDev->SetPixelShader (NULL);

		gpd3dDev->SetTransform(D3DTS_VIEW,&cam.matWTC);
		gpd3dDev->SetTransform(D3DTS_PROJECTION,&shadow_proj_mat);

		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);

		for(int i = 0; i < 4; i++)
			gpd3dDev->SetTexture(i,NULL);

		const PrimitiveTypes sb_types[] = { pt_Torus, pt_Cone, pt_Box, pt_Cylinder };
		const int num_sb_types = sizeof(sb_types)/sizeof(PrimitiveTypes); 

		for(i = 0; i < num_sb_types; i++)
		{
			if(bUseLoDetail)
				pSetLoDet[sb_types[i]]->renderShadowMap(b_hi_z);
			else
				pSetHiDet[sb_types[i]]->renderShadowMap(b_hi_z);
		}

		gpd3dDev->SetRenderTarget(pRenderTarget, pZBuffer);
		gpd3dDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL);
		gpd3dDev->SetRenderState(D3DRS_SOLIDOFFSETENABLE, FALSE);
		
		psurf->Release();

		gpd3dDev->EndScene();
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\sosdsp.h ===
#define	GPXMEM	0xfe830000
#define	GPYMEM	0xfe836000
#define	GPPMEM	0xfe83a000



struct	patch {
	unsigned int	start;
	unsigned int	end;
	unsigned int	loop;
	unsigned char	pitch;
	unsigned char	bank;
};
struct	word {
	unsigned int	start;
	unsigned int	end;
	unsigned char	bank;
	unsigned int	volume;
};


struct	two_pole_lpf {
	unsigned short	c0;
	unsigned short	c1;
	unsigned short	c2;
};
#define	N_OSCS		11
#define	OSC_SIZE	6

#define	ST_VOLUME_R			66
#define	ST_VOLUME_L			77


/*
 *	adpcm equates
 */

#define		ADP_END			109
#define		ADP_BANK		111
#define		ADP_PRE_VOLUME_R 116
#define		ADP_PRE_VOLUME_L 120
#define		ADP_PRE_START	117
#define		ADP_STATUS		115
#define		ADP_VOLUME_R 110
#define		ADP_VOLUME_L 112


#define	OSC_0_MOD_INDEX	119
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\text_geometry.h ===
/*

xbt.h

*/
#ifndef __xbt_h__
#define __xbt_h__

#include "d3d8types.h"

#define FVF_xbt D3DFVF_XYZ

struct xbt_vertex
{
	float x,y,z;
};

const float xbt_OO_POS_SCALE = 0.002508f;
const float xbt_POS_DELTA = 41.065369f;
const float xbt_OO_TEX_SCALE = -61.068704f;
const float xbt_TEX_DELTA = -1000000.000000f;


///////////////////////////////////////////////////////////////////////////////
const int vertex_count_text_0 = 156;
short verts_text_0C[] = 
{
		-29368,-16381,-16375, //	x,y,z
		-32752,-19098,-16375, //	x,y,z
		-31303,-19096,-16375, //	x,y,z
		-28656,-16952,-16375, //	x,y,z
		-27947,-16381,-16375, //	x,y,z
		-24567,-13668,-16375, //	x,y,z
		-26012,-13668,-16375, //	x,y,z
		-28656,-15814,-16375, //	x,y,z
		-31323,-13667,-16375, //	x,y,z
		-32748,-13668,-16375, //	x,y,z
		-26011,-19099,-16375, //	x,y,z
		-24563,-19098,-16375, //	x,y,z
		-17241,-16195,-16375, //	x,y,z
		-16875,-15892,-16375, //	x,y,z
		-23197,-16837,-16375, //	x,y,z
		-17767,-16837,-16375, //	x,y,z
		-17241,-16592,-16375, //	x,y,z
		-17482,-13978,-16375, //	x,y,z
		-17631,-13777,-16375, //	x,y,z
		-18229,-14512,-16375, //	x,y,z
		-17341,-14216,-16375, //	x,y,z
		-18180,-14621,-16375, //	x,y,z
		-18115,-14760,-16375, //	x,y,z
		-17211,-14489,-16375, //	x,y,z
		-18042,-14928,-16375, //	x,y,z
		-17096,-14794,-16375, //	x,y,z
		-17965,-15125,-16375, //	x,y,z
		-16999,-15131,-16375, //	x,y,z
		-17890,-15350,-16375, //	x,y,z
		-17825,-15603,-16375, //	x,y,z
		-16925,-15498,-16375, //	x,y,z
		-17775,-15884,-16375, //	x,y,z
		-23189,-15884,-16375, //	x,y,z
		-24897,-15884,-16375, //	x,y,z
		-24897,-16837,-16375, //	x,y,z
		-24093,-16837,-16375, //	x,y,z
		-24089,-15884,-16375, //	x,y,z
		-17771,-13594,-16375, //	x,y,z
		-23188,-13593,-16375, //	x,y,z
		-22735,-14514,-16375, //	x,y,z
		-23341,-13768,-16375, //	x,y,z
		-23488,-13970,-16375, //	x,y,z
		-23627,-14208,-16375, //	x,y,z
		-22784,-14624,-16375, //	x,y,z
		-22849,-14762,-16375, //	x,y,z
		-23755,-14481,-16375, //	x,y,z
		-22922,-14930,-16375, //	x,y,z
		-23868,-14787,-16375, //	x,y,z
		-22999,-15127,-16375, //	x,y,z
		-23964,-15124,-16375, //	x,y,z
		-23073,-15352,-16375, //	x,y,z
		-24038,-15491,-16375, //	x,y,z
		-23139,-15605,-16375, //	x,y,z
		-24046,-17245,-16375, //	x,y,z
		-23154,-17120,-16375, //	x,y,z
		-23971,-17623,-16375, //	x,y,z
		-23099,-17366,-16375, //	x,y,z
		-23873,-17969,-16375, //	x,y,z
		-23035,-17579,-16375, //	x,y,z
		-22964,-17766,-16375, //	x,y,z
		-23755,-18281,-16375, //	x,y,z
		-22887,-17934,-16375, //	x,y,z
		-23622,-18558,-16375, //	x,y,z
		-22807,-18089,-16375, //	x,y,z
		-23477,-18796,-16375, //	x,y,z
		-22725,-18238,-16375, //	x,y,z
		-23325,-18994,-16375, //	x,y,z
		-23181,-19156,-16375, //	x,y,z
		-17783,-19156,-16375, //	x,y,z
		-18244,-18241,-16375, //	x,y,z
		-17607,-18874,-16375, //	x,y,z
		-17437,-18588,-16375, //	x,y,z
		-18221,-18195,-16375, //	x,y,z
		-18163,-18080,-16375, //	x,y,z
		-17279,-18291,-16375, //	x,y,z
		-18082,-17905,-16375, //	x,y,z
		-17138,-17978,-16375, //	x,y,z
		-17990,-17683,-16375, //	x,y,z
		-17899,-17424,-16375, //	x,y,z
		-17019,-17643,-16375, //	x,y,z
		-17821,-17138,-16375, //	x,y,z
		-16930,-17283,-16375, //	x,y,z
		-16875,-16890,-16375, //	x,y,z
		-14534,-14523,-16375, //	x,y,z
		-9555,-13605,-16375, //	x,y,z
		-15016,-13619,-16375, //	x,y,z
		-10027,-14518,-16375, //	x,y,z
		-9376,-13854,-16375, //	x,y,z
		-15135,-13768,-16375, //	x,y,z
		-9197,-14166,-16375, //	x,y,z
		-15307,-14007,-16375, //	x,y,z
		-9965,-14655,-16375, //	x,y,z
		-9028,-14534,-16375, //	x,y,z
		-9882,-14833,-16375, //	x,y,z
		-9789,-15055,-16375, //	x,y,z
		-8879,-14949,-16375, //	x,y,z
		-9697,-15320,-16375, //	x,y,z
		-8761,-15403,-16375, //	x,y,z
		-9618,-15631,-16375, //	x,y,z
		-8682,-15885,-16375, //	x,y,z
		-9562,-15987,-16375, //	x,y,z
		-8654,-16389,-16375, //	x,y,z
		-9541,-16389,-16375, //	x,y,z
		-8681,-16881,-16375, //	x,y,z
		-9563,-16789,-16375, //	x,y,z
		-8757,-17327,-16375, //	x,y,z
		-9620,-17140,-16375, //	x,y,z
		-8874,-17736,-16375, //	x,y,z
		-9701,-17445,-16375, //	x,y,z
		-9023,-18116,-16375, //	x,y,z
		-9794,-17704,-16375, //	x,y,z
		-15468,-14296,-16375, //	x,y,z
		-14598,-14659,-16375, //	x,y,z
		-14682,-14838,-16375, //	x,y,z
		-15611,-14633,-16375, //	x,y,z
		-14777,-15059,-16375, //	x,y,z
		-15733,-15013,-16375, //	x,y,z
		-14870,-15324,-16375, //	x,y,z
		-15826,-15435,-16375, //	x,y,z
		-14950,-15633,-16375, //	x,y,z
		-15886,-15894,-16375, //	x,y,z
		-15006,-15988,-16375, //	x,y,z
		-15907,-16389,-16375, //	x,y,z
		-15028,-16389,-16375, //	x,y,z
		-15880,-16881,-16375, //	x,y,z
		-15006,-16788,-16375, //	x,y,z
		-15805,-17327,-16375, //	x,y,z
		-14947,-17139,-16375, //	x,y,z
		-15688,-17736,-16375, //	x,y,z
		-14865,-17442,-16375, //	x,y,z
		-15540,-18116,-16375, //	x,y,z
		-14769,-17700,-16375, //	x,y,z
		-9888,-17920,-16375, //	x,y,z
		-9197,-18473,-16375, //	x,y,z
		-9973,-18094,-16375, //	x,y,z
		-9387,-18814,-16375, //	x,y,z
		-10035,-18227,-16375, //	x,y,z
		-14673,-17915,-16375, //	x,y,z
		-15367,-18473,-16375, //	x,y,z
		-14588,-18088,-16375, //	x,y,z
		-15177,-18814,-16375, //	x,y,z
		-14525,-18221,-16375, //	x,y,z
		-9585,-19149,-16375, //	x,y,z
		-14980,-19149,-16375, //	x,y,z
		-4808,-16381,-16375, //	x,y,z
		-8192,-19098,-16375, //	x,y,z
		-6744,-19098,-16375, //	x,y,z
		-4099,-16952,-16375, //	x,y,z
		-1453,-19099,-16375, //	x,y,z
		-2,-19098,-16375, //	x,y,z
		-3386,-16381,-16375, //	x,y,z
		-6764,-13662,-16375, //	x,y,z
		-8188,-13668,-16375, //	x,y,z
		-4099,-15814,-16375, //	x,y,z
		-6,-13714,-16375, //	x,y,z
		-1430,-13678,-16375, //	x,y,z
};
const int index_count_text_0 = 462;
char indices_text_0C[] = 
{
	0,1,1,
	-2,2,1,
	1,1,1,
	-2,2,1,
	1,1,-9,
	7,1,-8,
	10,1,-7,
	-1,7,-6,
	3,-7,3,
	4,-4,1,
	8,1,1,
	-2,2,1,
	1,-4,3,
	2,1,1,
	1,-3,2,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	1,-1,2,
	-18,17,1,
	-17,-1,18,
	-17,17,1,
	1,1,1,
	1,-3,2,
	-16,-1,19,
	-18,18,1,
	1,-20,19,
	1,-1,2,
	-1,1,1,
	-2,2,1,
	1,-4,3,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	-19,20,-1,
	-19,19,-15,
	-22,18,4,
	-22,22,-1,
	-21,21,18,
	1,-40,39,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	-1,1,1,
	-2,2,1,
	1,-4,3,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	-66,65,1,
	-65,-1,66,
	1,-66,65,
	2,1,1,
	-1,-1,3,
	1,-3,2,
	-3,2,3,
	1,-2,-1,
	-3,5,2,
	-1,-3,5,
	1,-3,2,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	-27,7,21,
	1,-29,28,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	-21,1,22,
	1,-24,23,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-6,-1,
	7,-7,8,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	2,-7,1,
	7,-1,-6,
	7,-7,5,
	2,-2,-1,
	4,1,1,
	-2,2,1,
	1,1,1,
	-3,1,2,
	1,1,-8,
	9,-2,-7,
	6,4,1,
	-5,5,-2,
	-6,3,3,
	-9,3,6,
};

D3DVECTOR pos_anim_text[2] = 
{
	{-0.229403f,-267.650421f,-103.040421f},	
	{-0.229403f,-141.053757f,-54.439625f} 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\sources.inc ===
# C_DEFINES=$(C_DEFINES) -DPROFILE
# C_DEFINES=$(C_DEFINES) -DDETERMINISTIC

LINKER_FLAGS=$(LINKER_FLAGS) /MAP

SOURCES=\
CamControl.cpp \
camera.cpp \
GreenFog.cpp \
logo_renderer.cpp \
qrand.cpp \
renderer.cpp \
scene_renderer.cpp \
Shield.cpp \
tex_gen.cpp \
VBlob.cpp \
xbs_app.cpp \
fastmath.cpp \
placementdoodad.cpp \
bootsound.cpp \
mslogo.cpp \
dev.c \
cf.c \
evf.c \
globals.c \
sos.c \
proc.c \
stboot.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\SOS.C ===
/*
 *	Sound Operating System
 */



#include "sos.h"
#include "protos.h"
#include "ftables.h"			/* event/call function tables */

#include "externs.h"
#include <xtl.h>

#include <stdio.h>


unsigned char	sound_call;

//WCHAR	StringBuffer[256];

//extern	uchar	max_tracks;
extern	uchar	max_sound_call;
extern	ushort	default_clock_value;
extern	const ushort	max_processes;
extern	_base_	uchar	gtifbtmp;

#define	c_p	current_process

/* 
 * boolean T if a sound call is in buffer 
 */
#define	CALL_WAITING  (fifo.fifo_read != fifo.fifo_write)
/*
 * return the sound call in the buffer 
 */


/*************************************************************************
*                                                                        *
* 	Call main if we are going to do sos only						  *
* 	call do_sos_init_return followed by repeated calls to			  *
* 	sos_main if we are just part of another program					  *
*                                                                        *
*************************************************************************/

void	sos_main(void)
{
	struct	process	*tpp;
	do {
	    if (CALL_WAITING) {
			sound_call = get_fifo();
#if DBG
//			swprintf( StringBuffer, L"Current Sound: %d", sound_call);
#endif
			if (sound_call > max_sound_call)
		   	 	continue;
			current_call = &sound_calls[sound_call];
			call_fcns[current_call->type]();
	    }

		current_process = process_queue->next;
		while (current_process != (struct process *)NULL) {
		    tpp = current_process->next;
//			DINT;

				c_p->timer = c_p->timer +c_p->prev_timer - system_clock_music;
				current_process->prev_timer = system_clock_music;


//			EINT;
		    if (current_process->timer < 0) {
				current_channel = current_process->hard_channel;
				current_level = current_process->level;
/*				gtifbtmp = current_channel + current_level*max_tracks;*/
				if (current_level == 0)
					gtifbtmp = current_channel;
				else
					gtifbtmp = current_channel + max_tracks;
				ti = &(track_status[gtifbtmp]);
				if (event_fcns[current_process->function]() == 0) {
					current_process = process_queue->next;
					break;
				}
		    }
		    current_process = tpp;
		}
	} while (sos_only);
}



void	do_sos_init_return()
{

	sos_only = 0;
	fifo.fifo_read = 0;	
	fifo.fifo_write = 0;	
	dev_init();
	init_queuelist();
//	clock_cntr_value[0] = default_clock_value;
	system_clock_music = 1;
	sound_call_table = 0;
}

/*************************************************************************
*                                                                        *
* 	Put the value, value in the receive fifo			  *
*                                                                        *
*************************************************************************/

void put_fifo(uchar value)
{
	fifo.data[fifo.fifo_write++] = value;
	if (fifo.fifo_write >= FIFO_SIZE)
	    fifo.fifo_write = 0;
}

/*************************************************************************
*                                                                        *
* 	Get the next byte in the receive fifo				  *
*                                                                        *
*************************************************************************/
uchar	get_fifo(void)
{
	uchar	retval;

	retval = fifo.data[fifo.fifo_read++];
	if (fifo.fifo_read >= FIFO_SIZE)
	    fifo.fifo_read = 0;
	return(retval);
}
init_queuelist()
{
	uchar	i;
	queue_list[0].prev = (struct process *)NULL;
	queue_list[0].next = &(queue_list[1]);
	for (i = 1; i < max_processes - 1; i++) {
	    queue_list[i].next = &(queue_list[i+1]);	
	    queue_list[i].prev = &(queue_list[i-1]);
	}
	queue_list[max_processes-1].next = (struct process *)NULL;
	queue_list[max_processes-1].prev = &(queue_list[max_processes-2]);

	if ((process_queue = get_process_packet()) == NULL) {
//	    sos_error(SOS_NO_MEM);
	    return(0);
	}
	(*process_queue).next = (struct process *)NULL;
	process_queue->prev = (struct process *)NULL;
	for (i = 0; i < max_tracks; i++)
	    channel_level[i] = 0;
	return(0);
}


void	sos_error(int n)
{

}


/*************************************************************************
*                                                                        *
* 	Utilities for SOS						  *
*                                                                        *
*************************************************************************/



struct track_info *get_track_info_block()
{
	gtifbtmp = (current_level)*max_tracks + current_channel;	
	return(&(track_status[gtifbtmp]));
}
struct track_info *get_track_info_block2(uchar level, uchar chan)
{
	gtifbtmp = (level)*max_tracks + chan;	
	return(&(track_status[gtifbtmp]));
}

struct track_info *get_music_info_block()
{
#if LEVEL_MUSIC==0
	return(&(track_status[current_channel]));
#else
	gtifbtmp = (LEVEL_MUSIC)*max_tracks + current_channel;	
	return(&(track_status[gtifbtmp]));
#endif
}

	
struct track_info *get_music_info_block_i(uchar i)
{
#if LEVEL_MUSIC==0
	return(&(track_status[i]));
#else
	gtifbtmp = (LEVEL_MUSIC)*max_tracks + i;
	return(&(track_status[gtifbtmp]));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\st.c ===
#include <dsound.h>
#include "sos.h"
#include "macros.h"
#include "bootsnd.h"
#include "pitches.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

DSENVELOPEDESC	Env1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x5,						// hold
	0x20,						// decay
	0x0,						// release
	0x7f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x7f,						// filter scale
};




DSENVELOPEDESC	Env2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x40,						// pitch scale
	0x4f,						// filter scale
};
	

DSENVELOPEDESC	Env3a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0x10,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env3m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x1f,						// filter scale
};



DSENVELOPEDESC	OpenEnva = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x0,						// attack
	0x0,						// hold
	0x0,						// decay
	0x0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	OpenEnvm = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0,						// attack
	0x0,						// hold
	0x00,						// decay
	0x00,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

extern	unsigned short  Sin128[];
extern	unsigned short	Saw128[];
extern	unsigned short	Noise8192[];
extern	unsigned short	FM32768[];
extern	unsigned short	Glock[];
extern	unsigned short	Thun8k[];
extern	unsigned short	Cannon[];
extern	unsigned short	Bubble[];
extern	unsigned short	ThunEl16[];
extern	unsigned short	ReverseThunEl16[];


//
// patch is table, loop, env1, env2
// so, patches are defined by a waveform, a length, a loop address
// and the pair of envelopes.
//


const struct DSPpatch PatchSin = {
	Sin128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env1a,			// ampitude envelope
	&Env1m			// multi purpose envelope
};

///////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	SawEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x2,						// hold
	0x10,						// decay
	0x0,						// release
	0x9f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x10,						// attack
	0x100,						// hold
	0x100,						// decay
	0x80,						// release
	0xff,						// sustain
	0x00,						// pitch scale
	-80,						// filter scale
};


const struct DSPpatch PatchSaw1 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv1a,			// ampitude envelope
	&SawEnv1m			// multi purpose envelope
};




///////////////////////////////////////////////////////////////////////

DSENVELOPEDESC	SawEnv2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x00,						// pitch scale
	0x0,						// filter scale
};

const struct DSPpatch PatchSaw2 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv2a,			// ampitude envelope
	&SawEnv2m			// multi purpose envelope
};



	

///////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchSaw3 = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};



const struct DSPpatch PatchSquare = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};


/////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	NoiseEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	NoiseEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x30,						// decay
	0xc0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

/////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchEnvNoise1 = {
	Noise8192,			// start addr
	8192*2,			// length
	0,				// loop start
	8192*2,			// loop end
	1,				// loop sound
	&NoiseEnv1a,			// ampitude envelope
	&NoiseEnv1m			// multi purpose envelope
};


//////////////////////////////
const struct DSPpatch PatchFM = {
	FM32768,			// start addr
	32768,			// length
	0,				// loop start
	32768,			// loop end
	0,				// loop sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchGlock = {
	Glock,			// start addr
	3768*2,			// length...from glock.equ
	0,				// loop start
	3768*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};

///////////////////////////////////////////////////////////////
const struct DSPpatch PatchThun8k = {
	Thun8k,			// start addr
	10922*2,			// length...from glock.equ
	0,				// loop start
	10922*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchThunEl16 = {
	ThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchRevThun = {
	ReverseThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////

const struct DSPpatch PatchCannon = {
	Cannon,			// start addr
	3086*2,			// length...from glock.equ
	0,				// loop start
	3086*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
const struct DSPpatch PatchBubble = {
	Bubble,			// start addr
	6719*2,			// length...from glock.equ
	0,				// loop start
	6719*2,			// loop end
	1,				//  loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};


#define	PSIN1	0
#define	PSAW1	1
#define	PSQUARE	2
#define	PSAW2	3
#define	PSAW3	4
#define	PNOISE1	5
#define	PGLOCK	6
#define	PTHUN	7
#define	PCANNON	8
#define	PBUBBLE	9
#define	PFM		10
#define	PTHUNEL16 11
#define	PREVTHUN	12
struct DSPpatch	const *Patches[] = {
	&PatchSin,			// patch 0
	&PatchSaw1,			// patch 1
	&PatchSquare,		// patch 2
	&PatchSaw2,			// patch 3
	&PatchSaw3,			// patch 4
	&PatchEnvNoise1,	// patch 5
	&PatchGlock,		// patch 6
	&PatchThun8k,		// patch 7
	&PatchCannon,		// 8
	&PatchBubble,		// 9
	&PatchFM,			// 10
	&PatchThunEl16,		//11
	&PatchRevThun		// 12
};



// throbbing bass
//
const unsigned short Boot0[] = {
	rest(194),
	fset(25000,26000),
	patch(PSAW1),
	volume(40),
	loop(13),

		note(dd1,57),
		rest(3),
	endloop,
	note(dd1,28),
	rest(2),
	loop(6),
		volume(15),
		note(dd1,27),
		rest(3),
	endloop,

	loop(255),
	rest(2000),
	endloop
};





//noise whoosh for opening
const unsigned short Boot1[] = {
	fset(1000,26000),
	patch(5),
	volume(43),
	note(cc2,1),
	loop(10),
		finc(3000,26000),
		slur(cc2,13),
	endloop,
	ring(4),
	volume(20),
	loop(60),
		volume(1),
		finc(-1000,26000),
		slur(cc2,15),
	endloop,

	loop(255),
	rest(2000),
	endloop
};

// bubbling sound
const unsigned short Boot2[] = {
	patch(PBUBBLE),
	volume(0),
	fset(5000,26000),
	rest(194),
	note(dd2,412),
	loop(20),
		ring(20),
		finc(1000,26000),
	endloop,
	loop(30),
		ring(10),
		volume(4),
	endloop,
	loop(255),
		rest(2000),
	endloop
};


// first and last flashes
const unsigned short Boot3[] = {
	patch(PTHUN),
	volume(20),
	fset(32767,26000),
	rest(134),
	note(dd2,820),
	note(dd2,200),
	loop(20),
		ring(20),
		volume(2),
		finc(-1000,26000),
	endloop,
	ring(10000),
	loop(255),
		rest(2000),
	endloop
};

// fast noisy stuff...
//
const unsigned short Boot4[] = {
	rest(194),
	fset(32000,26000),
	patch(PNOISE1),
	volume(160),
	loop(10),
		volume(-3),
		note(cc4,15),
		rest(5),
		note(ff4,15),
		volume(-3),
		rest(5),
		note(gg5,15),
		rest(5),
		volume(-3),
		note(ff4,15),
		rest(5),
	endloop,
	note(ff4,18),

	loop(255),
	rest(2000),
	endloop
};

// glocks....
const unsigned short Boot5[] = {
	patch(PGLOCK),
	volume(70),
	rest(1194),
	fset(32000,26000),
	loop(40),
		note(cc4,18),
		rest(2),

		volume(15),
	endloop,
	note(cc4,500),
	loop(255),
	rest(2000),
	endloop
};

// glocks....
const unsigned short Boot6[] = {
	patch(PGLOCK),
	volume(70),
	rest(1194),
	fset(32000,26000),
	loop(40),
		note(cc3,18),
		rest(2),
		volume(15),
	endloop,
	note(cc3,500),
	loop(255),
	rest(2000),
	endloop
};

/////
// glocks....
const unsigned short Boot8[] = {
	patch(PGLOCK),
	volume(70),
	rest(1194),
	fset(32000,26000),
	loop(40),
		note(gg3,18),
		rest(2),
		volume(15),
	endloop,
	note(cc3,500),
	loop(255),
	rest(2000),
	endloop
};


// bass beg....
const unsigned short Boot7[] = {
	patch(PSAW2),
	volume(3),
	fset(1000,26000),
	note(dd2,1),
	loop(19),
		slur(dd2,10),
		finc(1500,2600),
	endloop,

	loop(255),
	rest(2000),
	endloop
};


const unsigned short *Boot[] = {
	Boot0,Boot1,Boot2,Boot3,Boot4,Boot5,Boot6,Boot7,Boot8
};
/////////////////////////////////////////////////////////////////////////

const unsigned short Tune0[] = {

	patch(PREVTHUN),
	note(cc3,800),
	patch(PTHUNEL16),
	note(cc3,800),

	rest(200),
	patch(PSIN1),

	loop(5),
	loop(120),
		note(cc2,50),
		xpose(200),
		rest(0),
	endloop,
	loop(120),
		note(cc0,50),
		xpose(-200),
		rest(0),
	endloop,
	endloop,
	note(5,6),
	rest(0x10),
	
//	0,1,2,3,4
};

const unsigned short Tune1[] = {

//	fset(6000,26000),
	patch(PSIN1),

	note(cc3,200),

};

const unsigned short *Tune[] = {
	Tune0
};

const struct sound sound_calls[] = {
	0,0,0,NULL,				//0 
	1,0,0x1ff,Boot,			//1
	1,0,0x001,Tune,			//2
	1,0,0x001,Tune,			//2
};


struct sound sound_calls2[2];

int	max_sound_call = 0x2;
int	default_clock_value = 80;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\Shield.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: Shield.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "Shield.h"
#include "tex_gen.h"

///////////////////////////////////////////////////////////////////////////////
D3DVECTOR Shield::ms_Pos;
const float SHIELD_ROTATION_RATE = (2.0f);
///////////////////////////////////////////////////////////////////////////////
void Shield::Init()
{
	m_RadiusScale = 1.0f;
	m_Speed = 1.0f;
}
///////////////////////////////////////////////////////////////////////////////
void Shield::create()
{
}
///////////////////////////////////////////////////////////////////////////////
void Shield::destroy()
{
	// Nothing to do.
}
///////////////////////////////////////////////////////////////////////////////
void Shield::render(const D3DMATRIX& mat_wtp)
{
	D3DMATRIX transp;
	SetTranspose(m_CurMatrix, &transp);
	gpd3dDev->SetVertexShaderConstant(0,(CONST void *)&transp,4);
	// The ShieldMgr will do the rest of the rendering.
}
///////////////////////////////////////////////////////////////////////////////
void Shield::advanceTime(float fElapsedTime, float fDt)
{
	D3DVECTOR4 quat;

	float pushout_radius = max(0.0f, (PUSHOUT_START_TIME + PUSHOUT_DELTA - fElapsedTime) * OO_PUSHOUT_DELTA);
	pushout_radius = START_PUSHOUT_RADIUS * pushout_radius*pushout_radius;

//MTS	if (gApp.getPulseIntensity() > 0.0f) m_Speed += fDt * 1.65f;
	m_Speed += fDt * 0.8f;

	float theta = fDt * SHIELD_ROTATION_RATE * m_Speed + m_ThetaZero;
	m_ThetaZero = theta;

	SetQuatFromAxis(m_RotationDir, theta, &quat);
	D3DMATRIX mat;
	SetRotationFromRHQuat(quat, &mat);
	MulMats(m_StartRotation, mat, &m_CurMatrix);

	m_CurMatrix._11 *= m_RadiusScale;
	m_CurMatrix._12 *= m_RadiusScale;
	m_CurMatrix._13 *= m_RadiusScale;
	m_CurMatrix._21 *= m_RadiusScale;
	m_CurMatrix._22 *= m_RadiusScale;
	m_CurMatrix._23 *= m_RadiusScale;
	m_CurMatrix._31 *= m_RadiusScale;
	m_CurMatrix._32 *= m_RadiusScale;
	m_CurMatrix._33 *= m_RadiusScale;
//MTS	m_CurMatrix._41 = ms_Pos.x;
//MTS	m_CurMatrix._42 = ms_Pos.y;
//MTS	m_CurMatrix._43 = ms_Pos.z;
	// Adjusted so that the reflection is now stationary as the shield moves around.
	m_CurMatrix._41 = ms_Pos.x + m_CurMatrix._11 * (2.0f + pushout_radius);
	m_CurMatrix._42 = ms_Pos.y + m_CurMatrix._12 * (2.0f + pushout_radius);
	m_CurMatrix._43 = ms_Pos.z + m_CurMatrix._13 * (2.0f);

//MTS	bool b_far_side = m_CurCenter.y > ms_Pos.y;
	TransformPoint(m_ObjectCenter, m_CurMatrix, &m_CurCenter);
}
///////////////////////////////////////////////////////////////////////////////
void Shield::restart(float radian_extent)
{
	float crossing_radian = gApp.fRand01() * 2.09f * Pi;

	// Find the constants to make this happen.
	// First pick a "peak" orientation.
	const float f_RY_ARC = Pi * 1.2f;
	bool b_flipped = false;

	float rz = gApp.fRand01() * 2.0f * Pi;
	float ry = gApp.fRand01() * f_RY_ARC * 2.0f - f_RY_ARC*0.5f;

	if (ry > f_RY_ARC * 0.5f)
	{
		ry += Pi - f_RY_ARC;
		b_flipped = true;
	}

	if (b_flipped)
	{
		m_ThetaZero = rz + Pi - crossing_radian;
	}
	else
	{
		m_ThetaZero = - rz - crossing_radian;
	}

//MTS	char buf[512];
//MTS	sprintf(buf, "Ry=%f, Rz=%f, theta_zero=%f, crossing_radian=%f\n",
//MTS		ry, rz, m_ThetaZero, crossing_radian);
//MTS	OutputDebugString(buf);

	// Rotate around ry
	// Rotate around rz
	D3DMATRIX mat1, mat2;
	SetYRotation(ry, &mat1);
	SetZRotation(rz, &mat2);
	MulMats(mat1, mat2, &m_StartRotation);
	m_RotationDir.x = m_StartRotation._31;
	m_RotationDir.y = m_StartRotation._32;
	m_RotationDir.z = m_StartRotation._33;
//MTS	sprintf(buf, "    RotationDir=%+f,%+f,%+f\n",
//MTS		m_RotationDir.x, m_RotationDir.y, m_RotationDir.z);
//MTS	OutputDebugString(buf);

	m_Speed = 0.0f;
	
	advanceTime(0.0f, 0.0f);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void ZShield::Init()
{
	m_pShieldVB = NULL;
	m_pShieldIB = NULL;
	m_dwNumVertices = m_dwNumIndices = 0;
	m_Speed = 0.0f;
	m_Theta = 0.0f;
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::create()
{
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::destroy()
{
#define XBS_RELEASE(a) if (a) a->Release(); a = NULL;
	XBS_RELEASE(m_pShieldVB);
	XBS_RELEASE(m_pShieldIB);
#undef XBS_RELEASE
	m_dwNumVertices = 0;
	m_dwNumIndices = 0;
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::render(const D3DMATRIX& mat_wtp)
{
	D3DMATRIX transp;
	SetTranspose(m_CurMatrix, &transp);
	gpd3dDev->SetVertexShaderConstant(0,(CONST void *)&transp,4);

	gpd3dDev->SetStreamSource(0, m_pShieldVB, sizeof(ShieldVertex));
	gpd3dDev->SetIndices(m_pShieldIB, 0);
	gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumVertices,  0, m_dwNumIndices-2 );
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::advanceTime(float fElapsedTime, float fDt)
{
//MTS	if (gApp.getPulseIntensity() > 0.0f) m_Speed += fDt * 1.0f;
	m_Speed += fDt * 0.8f;
	m_Theta += m_Speed * fDt;


	float pushout_radius = max(0.0f, (PUSHOUT_START_TIME + PUSHOUT_DELTA - fElapsedTime) * OO_PUSHOUT_DELTA);
	pushout_radius = START_PUSHOUT_RADIUS * pushout_radius*pushout_radius;

	SetZRotation(m_Theta, &m_CurMatrix);
	m_CurMatrix._41 += m_CurMatrix._11 * (2.0f + pushout_radius);
	m_CurMatrix._42 += m_CurMatrix._12 * (2.0f + pushout_radius);
	m_CurMatrix._43 += m_CurMatrix._13 * (2.0f);
}
///////////////////////////////////////////////////////////////////////////////
// returns the new start_radian, from bottom (-Pi/2) up.
void ZShield::restart(float start_radian, float end_radian, float outside_radius)
{
	destroy();

	m_Theta = gApp.fRand01() * 2.0f * Pi;
	m_Speed = 0.0f;


	// Create the index and vertex buffers.
	const int width = 8;		// number of panels, one less than the number of vertices
	const int height = 6;
	const float inside_radius = outside_radius - 0.5f;
	const float f_vert_radians = end_radian - start_radian;
	const float f_horiz_radians = 1.2f;

	int num_verts_per_face = (height+1) * (width+1);
	int num_side_verts = 2*2*(height+1) + 2*2*(width+1);
	m_dwNumVertices = 
				2*num_verts_per_face +			// top and bottom
				num_side_verts;					// edges

	m_dwNumIndices =
				GetNumberOfIndicesForTristripMesh(width, height, false, true) +
				GetNumberOfIndicesForTristripMesh(width, height, true, true) +
				(height+1)*2 + 2 +
				(width+1)*2 + 2 +
				(height+1)*2 + 2 +
				(width+1)*2 + 1;

	gpd3dDev->CreateVertexBuffer( m_dwNumVertices * sizeof(ShieldVertex), 0, 0, 0, &m_pShieldVB);
	gpd3dDev->CreateIndexBuffer(  m_dwNumIndices  * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pShieldIB);




	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face+num_side_verts : 0)
	// or for the sides num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0


	ShieldVertex* p_verts;
	m_pShieldVB->Lock(0, 0, (BYTE**)&p_verts, 0);
	ShieldVertex* pverto = &p_verts[0];
	ShieldVertex* pverti = &p_verts[num_verts_per_face+num_side_verts];

	float f_left_rad   = -0.5f * f_horiz_radians;
	float f_right_rad  = +0.5f * f_horiz_radians;
	float f_top_rad    = end_radian;
	float f_bottom_rad = start_radian;
	float f_horiz_step = (f_right_rad-f_left_rad) / ((float)width);
	float f_vert_step  = (f_top_rad-f_bottom_rad) / ((float)height);

	int i,j;
	float f_i, f_j;

	for (j=0, f_j=f_bottom_rad; j<=height; j++, f_j+=f_vert_step)
	{
		float vs,vc;
		SinCos(f_j, &vs, &vc);
		for (i=0, f_i=f_left_rad; i<=width; i++, f_i+=f_horiz_step)
		{
			float hs,hc;
			SinCos(f_i, &hs, &hc);

			D3DVECTOR norm;
			Set(&norm, vc*hc, vc*hs, vs);

			Set(&pverto->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
			pverto->normal = norm;
			pverto++;
			Set(&pverti->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
			pverti->normal = norm;
			Scale(&pverti->normal, -1.0f);
			pverti++;

			if ((!j) && (i==width)) f_right_rad = f_i;		// set it exactly to what we iterate to
		}
		if (j==height) f_top_rad = f_j;						// set it exactly to what we iterate to
	}

	ShieldVertex* pvert = pverto;


	// Fill in the vertices around the edges.
	f_i = f_left_rad;
	float vs,vc,hs,hc;

	// Start at left, move up.
	SinCos(f_i, &hs, &hc);
	for (j=0, f_j=f_bottom_rad; j<=height; j++, f_j+=f_vert_step)
	{
		SinCos(f_j, &vs, &vc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, hs, -hc, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}
	j = height;
	f_j = f_top_rad;

	// At UL, move right
	for (i=0, f_i=f_left_rad; i<=width; i++, f_i+=f_horiz_step)
	{
		SinCos(f_i, &hs, &hc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, -vs*hc, -vs*hs, vc);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At UR, move down
	for (j=height, f_j=f_top_rad; j>=0; j--, f_j-=f_vert_step)
	{
		if (!j) f_j=f_bottom_rad;
		SinCos(f_j, &vs, &vc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, -hs, hc, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At LR, move left
	for (i=width, f_i=f_right_rad; i>=0; i--, f_i-=f_horiz_step)
	{
		if (!i) f_i=f_left_rad;
		SinCos(f_i, &hs, &hc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, vs*hc, vs*hs, -vc);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// Done with the vertices!
	m_pShieldVB->Unlock();






	WORD* p_indices;
	m_pShieldIB->Lock(0, 0, (BYTE**)&p_indices, 0);

	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face : 0)
	// or for the sides 2*num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0

	// Outside surface.
	int index_num = 0;
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height, false, true, 0);
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height,  true, true, num_verts_per_face+num_side_verts+width, 0, -1);

	int vertex_index = num_verts_per_face;

	// Sides
	for (i=0; i<4; i++)
	{
		p_indices[index_num++] = (WORD)vertex_index;	// first tap of a double-tap

		int length = (i&1) ? width : height;
		for (j=0; j<=length; j++)
		{
			p_indices[index_num++] = vertex_index + 0;
			p_indices[index_num++] = vertex_index + 1;
			vertex_index += 2;
		}
		if (i<3) p_indices[index_num++] = vertex_index - 1;	// double-tap
	}

	m_pShieldIB->Unlock();

}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::Init()
{
    int i;

    for (i = 0; i < MAX_SHIELDS; i++)
    {
        m_Shields[i].Init();
    }

    for (int i = 0; i < MAX_ZSHIELDS; i++)
    {
        m_ZShields[i].Init();
    }

	m_NumShields = 0;
	m_pShieldVB = NULL;
	m_pShieldIB = NULL;
	m_dwNumVertices = 0;
	m_dwNumIndices = 0;
	m_dwPShader = 0;
	m_dwVShader = 0;

	Set(&m_Pos, 0.0f, 0.0f, 0.0f);
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::create()
{
	// Make the meshes and stuff.
	const int width = 8;		// number of panels, one less than the number of vertices
	const int height = 6;
	const float inside_radius = 13.1f;
	const float outside_radius = 14.0f;
	const float f_vert_dim = 0.9f;
	const float f_horiz_dim = 1.2f;
	// Partial sphere surface is made by generating a mesh at x=1.0f, and normalizing the vertices.

	m_RadiusScale = 1.0f - 1.2f * (outside_radius-inside_radius) / outside_radius;
	m_MidRadius = (inside_radius + outside_radius) * 0.5f;

	int num_verts_per_face = (height+1) * (width+1);
	int num_side_verts = 2*2*(height+1) + 2*2*(width+1);
	m_dwNumVertices = 
				2*num_verts_per_face +			// top and bottom
				num_side_verts;					// edges

	m_dwNumIndices =
				GetNumberOfIndicesForTristripMesh(width, height, false, true) +
				GetNumberOfIndicesForTristripMesh(width, height, true, true) +
				(height+1)*2 + 2 +
				(width+1)*2 + 2 +
				(height+1)*2 + 2 +
				(width+1)*2 + 1;

	gpd3dDev->CreateVertexBuffer( m_dwNumVertices * sizeof(ShieldVertex), 0, 0, 0, &m_pShieldVB);
	gpd3dDev->CreateIndexBuffer(  m_dwNumIndices  * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pShieldIB);




	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face+num_side_verts : 0)
	// or for the sides num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0


	ShieldVertex* p_verts;
	m_pShieldVB->Lock(0, 0, (BYTE**)&p_verts, 0);
	ShieldVertex* pverto = &p_verts[0];
	ShieldVertex* pverti = &p_verts[num_verts_per_face+num_side_verts];

	float f_left_c		= -0.5f * f_horiz_dim;
	float f_right_c		= +0.5f * f_horiz_dim;
	float f_top_c		= +0.5f * f_vert_dim;
	float f_bottom_c	= -0.5f * f_vert_dim;
	float f_horiz_step	= (f_right_c-f_left_c) / ((float)width);
	float f_vert_step	= (f_top_c-f_bottom_c) / ((float)height);

	int i,j;
	float f_i, f_j;

	for (j=0, f_j=f_bottom_c; j<=height; j++, f_j+=f_vert_step)
	{
		for (i=0, f_i=f_left_c; i<=width; i++, f_i+=f_horiz_step)
		{
			D3DVECTOR norm;
			Set(&norm, 1.0f, f_i, f_j);
			Normalize(&norm);

			Set(&pverto->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
			pverto->normal = norm;
			pverto++;
			Set(&pverti->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
			pverti->normal = norm;
			Scale(&pverti->normal, -1.0f);
			pverti++;

			if ((!j) && (i==width)) f_right_c = f_i;		// set it exactly to what we iterate to
		}
		if (j==height) f_top_c = f_j;						// set it exactly to what we iterate to
	}

	ShieldVertex* pvert = pverto;


	// Fill in the vertices around the edges.
	f_i = f_left_c;

	// Start at left, move up.
	for (j=0, f_j=f_bottom_c; j<=height; j++, f_j+=f_vert_step)
	{
		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, -1.0f, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}
	j = height;
	f_j = f_top_c;

	// At UL, move right
	for (i=0, f_i=f_left_c; i<=width; i++, f_i+=f_horiz_step)
	{
		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, 0.0f, +1.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At UR, move down
	f_i = f_right_c;
	for (j=height, f_j=f_top_c; j>=0; j--, f_j-=f_vert_step)
	{
		if (!j) f_j=f_bottom_c;

		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, +1.0f, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At LR, move left
	f_j = f_bottom_c;
	for (i=width, f_i=f_right_c; i>=0; i--, f_i-=f_horiz_step)
	{
		if (!i) f_i=f_left_c;

		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, 0.0f, -1.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// Done with the vertices!
	m_pShieldVB->Unlock();






	WORD* p_indices;
	m_pShieldIB->Lock(0, 0, (BYTE**)&p_indices, 0);

	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face : 0)
	// or for the sides 2*num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0

	// Outside surface.
	int index_num = 0;
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height, false, true, 0);
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height,  true, true, num_verts_per_face+num_side_verts+width, 0, -1);

	int vertex_index = num_verts_per_face;

	// Sides
	for (i=0; i<4; i++)
	{
		p_indices[index_num++] = (WORD)vertex_index;	// first tap of a double-tap

		int length = (i&1) ? width : height;
		for (j=0; j<=length; j++)
		{
			p_indices[index_num++] = vertex_index + 0;
			p_indices[index_num++] = vertex_index + 1;
			vertex_index += 2;
		}
		if (i<3) p_indices[index_num++] = vertex_index - 1;	// double-tap
	}

	m_pShieldIB->Unlock();



	// Create the shaders.

	
	// Initialize the pixel shaders.
    if( m_dwPShader )
    {
        gpd3dDev->DeletePixelShader( m_dwPShader );
        m_dwPShader = 0;
    }
#ifndef BINARY_RESOURCE
	m_dwPShader = gApp.loadPixelShader("D:\\Shaders\\shield.xpu");
#else // BINARY_RESOURCE
	m_dwPShader = gApp.loadPixelShader(g_shield_xpu);
#endif // BINARY_RESOURCE

	

	// Initialize the vertex shaders.
    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),	// position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),	// normal
        D3DVSD_END()
    };
	if (m_dwVShader)
	{
		gpd3dDev->DeleteVertexShader( m_dwVShader );
		m_dwVShader = 0;
	}
#ifndef BINARY_RESOURCE
	m_dwVShader = gApp.loadVertexShader("D:\\Shaders\\shield.xvu", dwShaderVertexDecl);
#else // BINARY_RESOURCE
	m_dwVShader = gApp.loadVertexShader(g_shield_xvu, dwShaderVertexDecl);
#endif // BINARY_RESOURCE



	for (i=0; i<MAX_SHIELDS; i++) m_Shields[i].create();
	for (i=0; i<MAX_ZSHIELDS; i++) m_ZShields[i].create();


	restart();
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::destroy()
{
	for (int i=0; i<m_NumShields; i++) m_Shields[i].destroy();
	m_NumShields = 0;

    if (m_dwPShader) gpd3dDev->DeletePixelShader(  m_dwPShader );
	if (m_dwVShader) gpd3dDev->DeleteVertexShader( m_dwVShader );
    m_dwPShader = 0;
	m_dwVShader = 0;

#define XBS_RELEASE(a) if (a) a->Release(); a = NULL;
	XBS_RELEASE(m_pShieldVB);
	XBS_RELEASE(m_pShieldIB);
#undef XBS_RELEASE
	m_dwNumVertices = 0;
	m_dwNumIndices  = 0;
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::render(bool b_far_side)
{
	// Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,  TRUE );
    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,  FALSE );

    gpd3dDev->SetTexture( 0, gApp.pStaticReflectionCubeMap );
	gpd3dDev->SetTexture( 1, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 2, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 3, gApp.pNormalCubeMapHiRes );


    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

	gpd3dDev->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

	gpd3dDev->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

	
	gpd3dDev->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 3, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 3, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 3, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 3, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);


    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );

    gpd3dDev->SetTexture( 0, gApp.pStaticReflectionCubeMap );
	gpd3dDev->SetTexture( 1, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 2, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 3, gApp.pNormalCubeMapHiRes );



    gpd3dDev->SetVertexShader( m_dwVShader );
    gpd3dDev->SetPixelShader(  m_dwPShader );




	D3DVECTOR cam_pos, look_dir, look_at;
	gApp.theCamera.getCameraPos (&cam_pos);
	gApp.theCamera.getCameraLook(&look_at);
	Sub(look_at, cam_pos, &look_dir);


	//; Expected vertex shaders constants
	//;    c0-c3    = Transpose of object to world matrix
	//;    c4-c7    = Transpose of view*projection matrix
	//;    c8       = some constants, x=0, y=1, z=2, w=0.5
	//;    c9       = eye location in world space
	//;    c10      = light pos in world space

    // Note: when passing matrices to a vertex shader, we transpose them, since
    // matrix multiplies are done with dot product operations on the matrix rows.
	D3DMATRIX matFinal,matWTP;
	MulMats(gApp.theCamera.matWTC,gApp.theCamera.matProj,&matWTP);
	SetTranspose(matWTP,&matFinal);
	gpd3dDev->SetVertexShaderConstant(4,(CONST void *)&matFinal,4);

	// Constants
	D3DVECTOR4 val[4];
	Set(&val[0], 0.0f, 1.0f, 2.0f, 0.5f);

	// Eye position
	Set(&val[1], cam_pos.x, cam_pos.y, cam_pos.z, 0.0f);

	// Blob Light position
	Set(&val[2],0.f,0.f,0.f,1.f);

	// Mood Light position
	const D3DVECTOR &mlp = gApp.moodLight.Position;
	Set(&val[3],mlp.x,mlp.y,mlp.z,1.f);

	gpd3dDev->SetVertexShaderConstant( 8, &val[0], 4 );

	// alpha
	float f_shading = 0.75f;	// 1 = black, 0 = no shading
	if (gApp.getElapsedTime() < SHIELD_FADE_IN_START_TIME + SHIELD_FADE_IN_DELTA)
	{
		f_shading *= (gApp.getElapsedTime() - SHIELD_FADE_IN_START_TIME) * OO_SHIELD_FADE_IN_DELTA;
	}
	else if (gApp.getElapsedTime() > SHIELD_FADE_OUT_START_TIME)
	{
		f_shading *= (SHIELD_FADE_OUT_START_TIME + SHIELD_FADE_OUT_DELTA - gApp.getElapsedTime()) * OO_SHIELD_FADE_OUT_DELTA;
	}
	f_shading = min(1.0f, max(0.0f, f_shading));
	Set(&val[0], 0.0f, 0.0f, 0.0f, f_shading);	// final alpha is 1.0f - f_shading

	// blob light
	float f_intensity = gApp.getBlobIntensity() * 2.f;
	float fscale = max(0.0f, min(1.0f, (gApp.getElapsedTime()-PUSHOUT_START_TIME) * OO_PUSHOUT_DELTA));
	f_intensity *= fscale*fscale;
	
	Set(&val[1], f_intensity, f_intensity, f_intensity, f_intensity);

	// Specular coefficient
	Set(&val[2], 0.4f,1.f,0.3f,1.f);
	gpd3dDev->SetPixelShaderConstant( 0, &val[0], 3 );


	gpd3dDev->SetIndices( m_pShieldIB, 0 );
    gpd3dDev->SetStreamSource( 0, m_pShieldVB, sizeof(ShieldVertex) );


	float shield_dot[MAX_SHIELDS];
	int shield_order[MAX_SHIELDS];
	int i;
	for (i=0; i<m_NumShields; i++)
	{
		shield_dot[i] = Dot(m_Shields[i].getCenter(), look_dir);
		shield_order[i] = i;
	}


	float f_blob_dot = Dot(m_Pos, look_dir);
	for (int j=m_NumShields-1; j>=0; j--)
	{
		int i = (b_far_side) ? m_NumShields-1-j : j;
		if (  (( b_far_side) && (shield_dot[i]>=f_blob_dot)) ||
			  ((!b_far_side) && (shield_dot[i]< f_blob_dot)) )
		{
			m_Shields[shield_order[i]].render(matWTP);
			gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumVertices,  0, m_dwNumIndices-2 );

		}
	}

	for (int j=m_NumZShields-1; j>=0; j--)
	{
		if (b_far_side) break;
		// Oh, don't bother sorting, see how it looks.
		m_ZShields[j].render(matWTP);	// sets the object to world transpose transform
	}


    // Restore the state
    gpd3dDev->SetPixelShader(  NULL );
    gpd3dDev->SetVertexShader( NULL );

	gpd3dDev->SetTexture(0, NULL);
	gpd3dDev->SetTexture(1, NULL);

    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );
	 gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::advanceTime(float fElapsedTime, float fDt)
{
	int i;
	for (i=0; i<m_NumShields; i++) m_Shields[i].advanceTime(fElapsedTime, fDt);
	for (i=0; i<m_NumZShields; i++) m_ZShields[i].advanceTime(fElapsedTime, fDt);
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::restart()
{
	Set(&m_Pos, 0.0f, 0.0f, 1.0f);
	Shield::sSetCenter(m_Pos);

	restartShields();
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::restartShields()
{
	float radian_extent = Pi / 6.0f;
	float scale = 1.0f;

	for (m_NumShields=0; m_NumShields<MAX_SHIELDS; m_NumShields++)
	{
		m_Shields[m_NumShields].restart(radian_extent);
		m_Shields[m_NumShields].setRadiusScale(scale, m_MidRadius);
		scale *= m_RadiusScale;
	}

	float min_rad = -0.45f * Pi;
	float max_rad = +0.45f * Pi;
	float rad_step = (max_rad-min_rad) / MAX_ZSHIELDS;
	for (m_NumZShields=0; m_NumZShields<MAX_ZSHIELDS; m_NumZShields++)
	{
		float mid_rad = min_rad + rad_step;
		m_ZShields[m_NumZShields].restart(min_rad, mid_rad, scale * m_MidRadius);
		min_rad = mid_rad;
	}
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\Shield.h ===
///////////////////////////////////////////////////////////////////////////////
// File: Shield.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef SHIELD_H
#define SHIELD_H


#include "qrand.h"



// The vertex list holding the unit sphere coordinates remain on the card.
// Each frame another list is streamed.

struct ShieldVertex
{
	D3DVECTOR position;
	D3DVECTOR normal;
};




// The shields actually look like they are the surface of a sphere that has been cut
// off by cuts perpendicular/parallel to each other and in the direction from
// the center of the shield to the center of the sphere. IOW, a piece bounded by
// lat and long lines where the center is on the equator.
   

class Shield
{
protected:
	D3DMATRIX				m_CurOTPMatrix;
	D3DMATRIX				m_CurMatrix;
	D3DVECTOR				m_CurCenter;	// world coordinates
	D3DVECTOR				m_ObjectCenter;	// object coordinates

	D3DMATRIX				m_StartRotation;
	D3DVECTOR				m_RotationDir;
	FLOAT					m_ThetaZero;	// start angle offset
	FLOAT					m_Speed;


	float					m_RadiusScale;

	static D3DVECTOR		ms_Pos;		// position of center


public:
	void Init();
	void UnInit()	{ destroy(); }

	void create();
	void destroy();

	void render(const D3DMATRIX& mat_wtp);	// sets object to world matrix constants
	void advanceTime(float fElapsedTime, float fDt);

	void restart(float radian_extent);	// pairs of floats


	const D3DVECTOR& getCenter() const { return m_CurCenter; }

	void		setRadiusScale(float rs, float dist)
	{
		m_RadiusScale = rs;
		Set(&m_ObjectCenter, dist*rs, 0.0f, 0.0f);
	}

	float	getRadiusScale()	const	{ return m_RadiusScale; }
	float	getSpeed()			const	{ return m_Speed; }

	const D3DMATRIX&	getObjectToWorldMatrix()	const	{ return m_CurMatrix; }

	static void sSetCenter(const D3DVECTOR& pos) { ms_Pos = pos; }
};



class ZShield
{
protected:
    LPDIRECT3DVERTEXBUFFER8 m_pShieldVB;
    LPDIRECT3DINDEXBUFFER8  m_pShieldIB;
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

	D3DMATRIX				m_CurMatrix;
	float					m_Speed;
	float					m_Theta;

public:
	void Init();
	void UnInit()	{ destroy(); }

	void create();
	void destroy();

	void render(const D3DMATRIX& mat_wtp);
	void advanceTime(float fElapsedTime, float fDt);

	void restart(float start_radian, float end_radian, float outside_radius);
};





class ShieldMgr
{
protected:
	enum { MAX_SHIELDS = 3 };
	enum { MAX_ZSHIELDS = 5 };
	Shield					m_Shields[MAX_SHIELDS];
	ZShield					m_ZShields[MAX_ZSHIELDS];
	int						m_NumShields;
	int						m_NumZShields;

	void					restartShields();


    LPDIRECT3DVERTEXBUFFER8 m_pShieldVB;
    LPDIRECT3DINDEXBUFFER8  m_pShieldIB;
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

    DWORD                   m_dwVShader;
    DWORD					m_dwPShader;



	D3DVECTOR				m_Pos;		// position of center
	float					m_RadiusScale;
	float					m_MidRadius;	// assumes full scale


public:
	void Init();
	void UnInit()
    {
        int i;

        for (i = 0; i < MAX_SHIELDS; i++)
        {
            m_Shields[i].UnInit();
        }

        for (int i = 0; i < MAX_ZSHIELDS; i++)
        {
            m_ZShields[i].UnInit();
        }

        destroy();
    }


	void create();
	void destroy();

	void advanceTime(float fElapsedTime, float fDt);	// resets if fElapsedTime is zero

	void render(bool b_far_side);

	void restart();
};



#endif // SHIELD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\shaders.h ===
const BYTE g_greenfog_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x30, 0xDA, 0x30, 0xD9, 0x30, 0xDB,
0x30, 0xDD, 0x10, 0x10, 0xD1, 0xDD, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D,
0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x20, 0xDA, 0x20, 0xD9, 0x20, 0xDB, 0x20, 0xCD, 0x00, 0x00,
0xC1, 0xCD, 0x00, 0x00, 0xCD, 0xC8, 0x20, 0xC1, 0x20, 0xCC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x11, 0x01, 0x00,
0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xF0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};

const BYTE g_scene_bump_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x5A, 0x58, 0x59, 0x58, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0B, 0x0C,
0x80, 0x11, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x4A, 0x48, 0x49, 0x48, 0x00, 0x00, 0x0D, 0x0D, 0x00, 0x00,
0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD,
0x0D, 0xC2, 0x0C, 0xC1, 0xC1, 0x20, 0x05, 0xC4, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0xFF,
0x00, 0x00, 0x00, 0x00, 0xCD, 0x30, 0x0C, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
0xD0, 0x00, 0x00, 0x00, 0xCD, 0x05, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x11, 0x01, 0x00,
0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0x1F, 0xF0, 0xFF, 0xFF, 0x2F, 0xFF,
0xF4, 0x01, 0x00, 0x00,

};


const BYTE g_scene_phong_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x5A, 0xD1, 0x59, 0xD1, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0B, 0x0C,
0x80, 0x11, 0x01, 0x0C, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x4A, 0xC1, 0x49, 0xC1, 0x00, 0x00, 0x0D, 0x0D, 0x00, 0x00,
0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD,
0x00, 0x00, 0xCD, 0xCD, 0x0D, 0xC2, 0x0C, 0xC1, 0xC1, 0x20,
0x05, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0xFF,
0x00, 0x00, 0x00, 0x00, 0xCD, 0x30, 0x0C, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
0xD0, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xCD, 0x05,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x11, 0x01, 0x00,
0x20, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xF3, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xF2,
0xF4, 0x01, 0x00, 0x00,

};


const BYTE g_scene_zr_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
0x3D, 0x3D, 0x10, 0x10, 0xDD, 0xD4, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x48, 0x48, 0x00, 0x00, 0x2D, 0x2D, 0x00, 0x00,
0xCD, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xD0, 0x20, 0x08, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x11, 0x01, 0x00,
0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_shield_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x5B, 0x5A, 0x5B, 0x59, 0x1D, 0x1D,
0x1C, 0x1C, 0xDD, 0xDD, 0xDC, 0xDC, 0xDD, 0xDD, 0xDC, 0xDC,
0xDD, 0xDD, 0xDC, 0xDC, 0xDC, 0x30, 0xD1, 0xDC, 0x30, 0x1D,
0x30, 0x1C, 0x10, 0x10, 0x30, 0xD2, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x33, 0xFF, 0x66, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xCD, 0x04, 0x00, 0x00, 0xCD, 0x04, 0x00, 0x00,
0xCD, 0x04, 0x00, 0x00, 0xCD, 0x04, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x4B, 0x4A, 0x4B, 0x49, 0x0D, 0x0D, 0x0C, 0x0C, 0xCD, 0xCD,
0xCC, 0xCC, 0xCD, 0xCD, 0xCC, 0xCC, 0xCD, 0xCD, 0xCC, 0xCC,
0xCC, 0x20, 0xC1, 0xCC, 0x20, 0x0D, 0x20, 0x0C, 0xC8, 0x20,
0xC1, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xCD, 0x30, 0x0C, 0x00, 0xCD, 0x04,
0x00, 0x00, 0xCD, 0x04, 0x00, 0x00, 0xCD, 0x04, 0x00, 0x00,
0xCD, 0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x11, 0x01, 0x00,
0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x2F, 0xFF, 0xFF, 0xFF, 0x0F,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_shield_sh_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x10, 0x10, 0x30, 0xD4, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
0x80, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x20, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_vblob_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
0x30, 0x1C, 0x10, 0x10, 0x3D, 0x3D, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x30, 0xD1, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x49, 0x48, 0x00, 0x00, 0x20, 0x0C, 0x00, 0x00,
0x2D, 0x2D, 0x00, 0x00, 0xC1, 0x2C, 0x20, 0xC1, 0x20, 0xCC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x20, 0x08, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x11, 0x01, 0x00,
0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x0F, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_vbloblet_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
0x30, 0x1C, 0x10, 0x10, 0x3D, 0x3D, 0x10, 0x10, 0xD1, 0x3C,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0xD1, 0xDC, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x49, 0x48, 0x00, 0x00, 0x20, 0x0C, 0x00, 0x00,
0x2D, 0x2D, 0x00, 0x00, 0xC1, 0x2C, 0x20, 0xC1, 0x20, 0xCC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x20, 0x08, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x11, 0x01, 0x00,
0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x0F, 0x21, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_greenfog_xvu[] =
{

0x78, 0x20, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x20, 0x00, 0x6C, 0x10, 0x36, 0x08, 0x00, 0xF8, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x02, 0x20, 0x00, 0x6C, 0x10,
0x36, 0x08, 0x48, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x24, 0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x64, 0x4C, 0x00,
0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x30, 0x2F, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xA4, 0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08,
0xF8, 0x0F, 0x40, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x6C, 0x00, 0x6C, 0x10, 0x36, 0x24, 0x50, 0xF8, 0x70, 0x30,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x6C, 0x00, 0x6C, 0x10,
0x36, 0x34, 0x58, 0xF8, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x80, 0x6C, 0x00, 0x6C, 0x10, 0x36, 0x44, 0x60, 0xF8,
0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4,
0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_scene_bump_xvu[] =
{

0x78, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x88, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x28,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08,
0x60, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x20,
0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x60, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0xED, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x60, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x02, 0x6C, 0x03,
0x6C, 0x18, 0x36, 0x0C, 0x4C, 0xF8, 0x30, 0x21, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x00, 0x40, 0x01, 0x6C, 0x68, 0xFE, 0x25,
0x60, 0x18, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xC0,
0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x40, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x80, 0x6C, 0x00, 0x69, 0x14,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x1E, 0x00, 0x00, 0x00, 0x00,
0x1A, 0xA0, 0x6C, 0x00, 0x69, 0x14, 0x36, 0x0C, 0xF8, 0x0F,
0xA0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00,
0x6C, 0xA8, 0x34, 0x54, 0xF8, 0x0F, 0x60, 0x28, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xA0, 0x08, 0x6D, 0x48, 0x37, 0xA4,
0xF8, 0x0F, 0xB1, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x09, 0x6E, 0x28, 0xFE, 0x65, 0xF8, 0x0F, 0x78, 0xDE,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xAC, 0x00, 0x6C, 0x18,
0x36, 0x74, 0xF8, 0x0F, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x00, 0x6C, 0x48, 0x35, 0x14, 0xF8, 0x0F,
0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x40, 0x06,
0x6E, 0xA8, 0x36, 0x14, 0x1C, 0xE8, 0x90, 0x1E, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x04, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94,
0x50, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x06,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94, 0x50, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x08, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x94, 0x50, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x60, 0x00, 0x6A, 0x10, 0x36, 0x04, 0xF8, 0x0F,
0x20, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x04, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24,
0x58, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x06,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24, 0x58, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x08, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x24, 0x58, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8,
0x70, 0x30,

};


const BYTE g_scene_phong_xvu[] =
{

0x78, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x88, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x28,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08,
0x60, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x20,
0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x60, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0xED, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x60, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x6C, 0x01,
0x6C, 0x18, 0x36, 0x0C, 0xF8, 0x0F, 0x30, 0x21, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x00, 0x40, 0x01, 0x6C, 0x68, 0xFE, 0x25,
0x60, 0x18, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xC0,
0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x40, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x80, 0x6C, 0x00, 0x69, 0x14,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x1E, 0x00, 0x00, 0x00, 0x00,
0x1A, 0xA0, 0x6C, 0x00, 0x69, 0x14, 0x36, 0x0C, 0xF8, 0x0F,
0xA0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00,
0x6C, 0xA8, 0x34, 0x54, 0xF8, 0x0F, 0x60, 0x28, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xA0, 0x08, 0x6D, 0x48, 0x37, 0xA4,
0xF8, 0x0F, 0xB1, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x09, 0x6E, 0x28, 0xFE, 0x65, 0xF8, 0x0F, 0x78, 0xDE,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xAC, 0x00, 0x6C, 0x18,
0x36, 0x74, 0xF8, 0x0F, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x00, 0x6C, 0x48, 0x35, 0x14, 0xF8, 0x0F,
0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x40, 0x06,
0x6E, 0xA8, 0x36, 0x14, 0x1C, 0xE8, 0x90, 0x1E, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x02, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94,
0x50, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x04,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94, 0x50, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x06, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x94, 0x50, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x60, 0x00, 0x6A, 0x10, 0x36, 0x04, 0xF8, 0x0F,
0x20, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x02, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24,
0x58, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x04,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24, 0x58, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x06, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x24, 0x58, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8,
0x70, 0x30,

};


const BYTE g_scene_zr_xvu[] =
{

0x78, 0x20, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x28,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0xF8, 0x0F, 0x20, 0x24, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00,
0x00, 0x00, 0xAA, 0x00, 0x20, 0x02, 0x6C, 0x10, 0x36, 0x24,
0x04, 0xF8, 0x30, 0x9F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
0x20, 0x00, 0x6C, 0x10, 0x36, 0x24, 0xF8, 0x0F, 0x40, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0x6E, 0x00, 0x6C, 0x10,
0x36, 0x34, 0xF8, 0x0F, 0x50, 0x3E, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x80, 0x05, 0xFD, 0x6B, 0x36, 0x34, 0xF8, 0x0F,
0x6F, 0x11, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x4E, 0x00,
0x6C, 0xA8, 0x36, 0x0C, 0xF8, 0x0F, 0x60, 0x2E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x60, 0x01, 0x6C, 0x68, 0x36, 0x34,
0xF8, 0x0F, 0x70, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x80, 0x01, 0x6C, 0x68, 0x36, 0x34, 0xF8, 0x0F, 0x70, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x40, 0x01, 0x6C, 0xE8,
0x36, 0x64, 0x18, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x40, 0x00, 0x6C, 0x28, 0x36, 0x24, 0xF8, 0x0F,
0x80, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x4E, 0x00,
0x6C, 0x18, 0x36, 0x84, 0xF8, 0x0F, 0x90, 0x2E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x6E, 0x00, 0x6C, 0x10, 0x36, 0x94,
0x48, 0xE8, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x80, 0x01, 0x6C, 0x28, 0x36, 0x14, 0x48, 0x18, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B,
0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8,
0x70, 0x30,

};


const BYTE g_shield_xvu[] =
{

0x78, 0x20, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x28,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0xF8, 0x0F, 0x20, 0x24, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x02, 0xAC, 0x00, 0x6C, 0x18, 0x34, 0x08,
0xF8, 0x0F, 0x30, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22,
0xAC, 0x00, 0x6C, 0x18, 0x34, 0x08, 0xF8, 0x0F, 0x30, 0x24,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x42, 0xAC, 0x00, 0x6C, 0x18,
0x34, 0x08, 0xF8, 0x0F, 0x30, 0x22, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x20, 0x6D, 0x00, 0x6C, 0x14, 0x36, 0x24, 0xF8, 0x0F,
0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x6D, 0x00,
0x6C, 0x14, 0x36, 0x24, 0xF8, 0x0F, 0x70, 0x3E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xA0, 0x02, 0x6D, 0x6C, 0x36, 0x44,
0x64, 0xE8, 0x50, 0x18, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00,
0xA0, 0x00, 0x6C, 0x68, 0x34, 0x74, 0xF8, 0x0F, 0x80, 0x28,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x6C, 0x18,
0x54, 0x57, 0xF8, 0x0F, 0x60, 0x24, 0x00, 0x00, 0x00, 0x00,
0x55, 0x00, 0x80, 0x00, 0x69, 0x68, 0x34, 0x64, 0x48, 0xE8,
0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x00,
0x6C, 0x18, 0x54, 0x87, 0xF8, 0x0F, 0x90, 0x24, 0x00, 0x00,
0x00, 0x00, 0x55, 0x00, 0x80, 0x00, 0x69, 0x68, 0x34, 0x94,
0x50, 0xE8, 0x30, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x60,
0x6D, 0x00, 0x68, 0x14, 0x36, 0x24, 0xF8, 0x0F, 0xA0, 0x3E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x80, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x24, 0x00, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0xA0, 0x00, 0x6C, 0x68, 0x34, 0xA4, 0xF8, 0x0F,
0xB0, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x24, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x6C, 0x18, 0x54, 0xB7,
0xF8, 0x0F, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00,
0x80, 0x00, 0x6A, 0x68, 0x34, 0x04, 0x58, 0xE8, 0x30, 0x90,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xC0, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x24, 0x00, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0xE0, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x24, 0x00, 0x18,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4,
0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_shield_sh_xvu[] =
{

0x78, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x20, 0x00, 0x6C, 0x10, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x2F,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x80, 0x01, 0x6C, 0x48,
0x36, 0x24, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F,
0x30, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xED, 0x00,
0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F, 0x30, 0x24, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x40, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x24,
0xF8, 0x0F, 0x30, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0xED, 0x00, 0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F, 0x30, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x80, 0x2D, 0x00, 0x6C, 0x10,
0x36, 0x0C, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x6E, 0x00, 0x6C, 0x14, 0x36, 0x34, 0xF8, 0x0F,
0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0xA0, 0x00,
0x6C, 0x88, 0x36, 0x44, 0xF8, 0x0F, 0x50, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x00, 0x08, 0xFD, 0x13, 0x36, 0x08,
0xF8, 0x0F, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x40, 0x00, 0x6C, 0x88, 0x36, 0x14, 0xF8, 0x0F, 0x60, 0x2F,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x80, 0x01, 0x6C, 0x28,
0x36, 0x14, 0xF8, 0x0F, 0x70, 0x2F, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x60, 0x00, 0xFC, 0x17, 0x36, 0x74, 0xF8, 0x0F,
0x80, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xC0, 0x4C, 0x00,
0x6C, 0x18, 0x36, 0x84, 0xF8, 0x0F, 0x90, 0x2F, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x80, 0x00, 0x6C, 0xC8, 0x36, 0x94,
0xF8, 0x0F, 0xA0, 0xDF, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xA0, 0x00, 0x6C, 0x48, 0x37, 0xA4, 0xF8, 0x0F, 0xB0, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0xA4, 0xF8, 0x0F, 0x70, 0x24, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0xEC, 0x08, 0xFE, 0x1B, 0x36, 0xA4, 0xF8, 0x0F,
0x7E, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0xA4, 0xF8, 0x0F, 0x70, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x60, 0x01, 0x6C, 0x48, 0x37, 0xA4,
0x18, 0xE8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x40, 0x02, 0x6D, 0x48, 0x37, 0x14, 0x04, 0xD8, 0x00, 0xDE,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xAC, 0x00, 0x6C, 0x18,
0x36, 0x04, 0xF8, 0x0F, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00,
0xFF, 0x00, 0x20, 0x00, 0x6C, 0x10, 0x36, 0x74, 0xF8, 0x0F,
0x80, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0, 0x8D, 0x00,
0x6C, 0x48, 0x36, 0x04, 0xF8, 0x0F, 0x30, 0x31, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x40, 0x00, 0x6C, 0x08, 0x36, 0x04,
0xF8, 0x0F, 0x40, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xC0,
0x8D, 0x00, 0x6C, 0x18, 0x36, 0x44, 0xF8, 0x0F, 0x50, 0xD1,
0x00, 0x00, 0x00, 0x00, 0xAA, 0x80, 0x4C, 0x00, 0x6C, 0x08,
0x55, 0x0D, 0x00, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0xE0, 0x4D, 0x01, 0x6C, 0x18, 0x36, 0x54, 0xF8, 0x0F,
0x60, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0, 0x4C, 0x00,
0x6C, 0x18, 0x36, 0x64, 0xF8, 0x0F, 0x90, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x40, 0x00, 0x6C, 0x10, 0xFE, 0x95,
0x18, 0x18, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40,
0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28,
0x00, 0xC4, 0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_vblob_xvu[] =
{

0x78, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0x4D, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0xA0, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0xA0, 0x00, 0x6C, 0x48,
0x37, 0xA4, 0xF8, 0x0F, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0x4D, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0xB0, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x2D, 0x08,
0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0xA8, 0x91, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x80, 0x6D, 0x00, 0x6C, 0x10, 0x36, 0xB4,
0xF8, 0x0F, 0xB0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x40, 0x00, 0x6C, 0x48, 0x35, 0x14, 0xF8, 0x0F, 0xA0, 0x2E,
0x00, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x20, 0x00, 0x6C, 0x10,
0x36, 0x08, 0xF8, 0x0F, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x2D, 0x00, 0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F,
0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x80, 0x00,
0x6E, 0x08, 0x36, 0xA4, 0xF8, 0x0F, 0xB0, 0xDF, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x20, 0x6D, 0x00, 0x6A, 0x14, 0x36, 0x0C,
0xF8, 0x0F, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00,
0x2D, 0x00, 0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0x20, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00, 0x6C, 0x08,
0x34, 0x04, 0xF8, 0x0F, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x80, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0xB4, 0x00, 0x88,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x2D, 0x08,
0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0x98, 0x91, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xA0, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0xB4,
0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x40, 0x00, 0x6C, 0x08, 0x34, 0x14, 0xF8, 0x0F, 0x20, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x62, 0x4D, 0x02, 0x6C, 0x18,
0x36, 0x08, 0x54, 0xF8, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0xA0, 0x00, 0x6C, 0x08, 0x36, 0x04, 0xF8, 0x0F,
0x20, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0xB4, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xC0, 0xEC, 0x08, 0x6C, 0x18, 0x36, 0xB4,
0x00, 0x28, 0x18, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x40, 0x00, 0x6C, 0x08, 0x36, 0x14, 0xF8, 0x0F, 0x90, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x20, 0x00, 0x6C, 0x10,
0x36, 0x94, 0x48, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8,
0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0x87, 0x00,
0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_vbloblet_xvu[] =
{

0x78, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0xAD, 0x02, 0x6C, 0x18, 0x36, 0x08, 0x4C, 0xF8, 0x20, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x2D, 0x00, 0x6C, 0x10,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x21, 0x00, 0x00, 0x00, 0x00,
0x1B, 0xA0, 0x4D, 0x00, 0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F,
0x30, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x80, 0x8D, 0x00,
0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0x40, 0xDE, 0x00, 0x00,
0x00, 0x00, 0x55, 0x00, 0x2D, 0x00, 0x6C, 0x10, 0x36, 0x0C,
0xF8, 0x0F, 0x80, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40,
0x6D, 0x00, 0x6C, 0x10, 0x36, 0x44, 0xF8, 0x0F, 0x50, 0x3E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x20, 0x6D, 0x00, 0x69, 0x14,
0x36, 0x0C, 0xF8, 0x0F, 0x60, 0x5E, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x80, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x54, 0x00, 0x88,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00,
0x6C, 0xC8, 0x34, 0x64, 0xF8, 0x0F, 0x70, 0x28, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xC0, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x54,
0x00, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0,
0xEC, 0x08, 0x6D, 0x18, 0x36, 0x54, 0x00, 0x48, 0x18, 0xD0,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x54, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x00, 0x6C, 0xC8, 0x34, 0x14, 0xF8, 0x0F,
0x80, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x20, 0x00,
0x6C, 0x10, 0x36, 0x84, 0x50, 0xF8, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4,
0x00, 0xE8, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8, 0x70, 0x30,

};

const BYTE g_slash_interior_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x10, 0x10, 0x30, 0xD4, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x20, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};

const BYTE g_slash_interior_xvu[] =
{

0x78, 0x20, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x88, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x28,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1A, 0xA0, 0x2C, 0x00, 0x6C, 0x10, 0x36, 0x0C,
0xF8, 0x0F, 0x20, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x80,
0x6C, 0x00, 0x68, 0x14, 0x36, 0x0C, 0xF8, 0x0F, 0x30, 0x9E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0xE0, 0x2C, 0x00, 0x6C, 0x10,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x2E, 0x00, 0x00, 0x00, 0x00,
0x1A, 0xA2, 0x8C, 0x00, 0x68, 0x10, 0xAA, 0x34, 0xF8, 0x0F,
0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xC0, 0x6C, 0x00,
0x69, 0x14, 0x36, 0x0C, 0xF8, 0x0F, 0x60, 0x5E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4,
0x00, 0xE8, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xE2,
0x8C, 0x00, 0x68, 0x10, 0xAA, 0x64, 0xF8, 0x0F, 0x70, 0x3E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x8D, 0x00, 0x69, 0x18,
0x34, 0x44, 0xF8, 0x0F, 0x80, 0xDE, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x4D, 0x00, 0x6C, 0x18, 0x34, 0x74, 0xF8, 0x0F,
0x90, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x60, 0x00,
0x6A, 0x14, 0x36, 0x84, 0x18, 0xE8, 0x70, 0x50, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4,
0x01, 0xE8, 0x70, 0x30,

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\stboot.c ===
#include <dsound.h>
#include "sos.h"
#include "macros.h"
#include "bootsnd.h"
#include "pitches.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

DSENVELOPEDESC	Env1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x5,						// hold
	0x20,						// decay
	0x0,						// release
	0x7f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x7f,						// filter scale
};




DSENVELOPEDESC	Env2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x40,						// pitch scale
	0x4f,						// filter scale
};
	

DSENVELOPEDESC	Env3a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0x10,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env3m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x1f,						// filter scale
};



DSENVELOPEDESC	OpenEnva = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x0,						// attack
	0x0,						// hold
	0x0,						// decay
	0x0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	OpenEnvm = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0,						// attack
	0x0,						// hold
	0x00,						// decay
	0x00,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

extern	unsigned short  Sin128[];
extern	unsigned short	Saw128[];
extern	unsigned short	Noise8192[];
extern	unsigned short	FM32768[];
extern	unsigned short	Glock[];

extern	unsigned short	Bubble[];
extern	unsigned short	ThunEl16[];
extern	unsigned short	ReverseThunEl16[];


//
// patch is table, loop, env1, env2
// so, patches are defined by a waveform, a length, a loop address
// and the pair of envelopes.
//


const struct DSPpatch PatchSin = {
	Sin128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env1a,			// ampitude envelope
	&Env1m			// multi purpose envelope
};

///////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	SawEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x2,						// hold
	0x10,						// decay
	0x0,						// release
	0x9f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x10,						// attack
	0x100,						// hold
	0x100,						// decay
	0x80,						// release
	0xff,						// sustain
	0x00,						// pitch scale
	-80,						// filter scale
};


const struct DSPpatch PatchSaw1 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv1a,			// ampitude envelope
	&SawEnv1m			// multi purpose envelope
};




///////////////////////////////////////////////////////////////////////

DSENVELOPEDESC	SawEnv2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x00,						// pitch scale
	0x0,						// filter scale
};

const struct DSPpatch PatchSaw2 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv2a,			// ampitude envelope
	&SawEnv2m			// multi purpose envelope
};



	

///////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchSaw3 = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};



const struct DSPpatch PatchSquare = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};


/////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	NoiseEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	NoiseEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x30,						// decay
	0xc0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

/////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchEnvNoise1 = {
	Noise8192,			// start addr
	8192*2,			// length
	0,				// loop start
	8192*2,			// loop end
	1,				// loop sound
	&NoiseEnv1a,			// ampitude envelope
	&NoiseEnv1m			// multi purpose envelope
};


//////////////////////////////
const struct DSPpatch PatchFM = {
	FM32768,			// start addr
	32768,			// length
	0,				// loop start
	32768,			// loop end
	0,				// loop sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchGlock = {
	Glock,			// start addr
	3768*2,			// length...from glock.equ
	0,				// loop start
	3768*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};

///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
const struct DSPpatch PatchThunEl16 = {
	ThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchRevThun = {
	ReverseThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////

const struct DSPpatch PatchBubble = {
	Bubble,			// start addr
	6719*2,			// length...from glock.equ
	0,				// loop start
	6719*2,			// loop end
	1,				//  loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};


#define	PSIN1		0
#define	PSAW1		1
#define	PSQUARE		2
#define	PSAW2		3
#define	PSAW3		4
#define	PNOISE1		5
#define	PGLOCK		6
#define	PBUBBLE		7
#define	PFM		8
#define	PTHUNEL16 	9
#define	PREVTHUN	10

struct DSPpatch	const *Patches[] = {
	&PatchSin,			// patch 0
	&PatchSaw1,			// patch 1
	&PatchSquare,		// patch 2
	&PatchSaw2,			// patch 3
	&PatchSaw3,			// patch 4
	&PatchEnvNoise1,	// patch 5
	&PatchGlock,		// patch 6
	&PatchBubble,		// 7
	&PatchFM,		// 8
	&PatchThunEl16,		//9
	&PatchRevThun		// 10
};



// throbbing bass
//
const unsigned short Boot0[] = {
	fset(29000,26000),
	patch(PSAW1),
	volume(10),
	rest(194-50),
	note(dd1,130),
	rest(2),
	note(dd1,125),
	rest(3),
	note(dd1,70),
	rest(2),
	note(dd1,77),
	rest(3),
	note(dd1,97),
	rest(3),
	note(dd1,91),
	rest(3),
	note(dd1,47),
	rest(3),
	note(dd1,51),
	rest(3),
	note(dd1,57),
	rest(3),
	note(dd1,132),
	rest(0),





//	rest(194),
//	fset(29000,26000),
//	patch(PSAW1),
//	volume(10),
//	loop(13),
//
//		note(dd1,57),
//		rest(3),
//	endloop,
//	note(dd1,28),
//	rest(2),
//	loop(6),
//		volume(15),
//		note(dd1,27),
//		rest(3),
//	endloop,
//
	loop(255),
	rest(20000),
	endloop
};






//noise whoosh for opening
const unsigned short Boot1[] = {
	fset(1000,26000),
	patch(5),
	volume(43),
	note(cc2,1),
	loop(10),
		finc(3000,26000),
		slur(cc2,13),
	endloop,
	ring(4),
	volume(20),
	loop(60),
		volume(1),
		finc(-1000,26000),
		slur(cc2,15),
	endloop,

	loop(255),
	rest(2000),
	endloop
};

// bubbling sound
const unsigned short Boot2[] = {
	patch(PBUBBLE),
	volume(12),
	fset(6000,26000),
	rest(134),
	note(dd2,412+60),
	loop(20),
		ring(20),
		finc(1000,26000),
	endloop,
	loop(30),
		ring(10),
		volume(4),
	endloop,
	loop(255),
		rest(20000),
	endloop
};


// first and last flashes
const unsigned short Boot3[] = {
	patch(PTHUNEL16),
	volume(40),
	fset(32767,26000),
	rest(134),
	note(dd3,820),
	volume(-25),
	note(dd3,200),
	loop(20),
		ring(20),
		volume(2),
		finc(-1000,26000),
	endloop,
	ring(10000),
	loop(255),
		rest(2000),
	endloop
};

// fast noisy stuff...
//
const unsigned short Boot4[] = {
	rest(194),
	fset(32000,26000),
	patch(PNOISE1),
	volume(160),
	loop(8),
		volume(-3),
		note(cc4,15),
		rest(5),
		note(ff4,15),
		volume(-3),
		rest(5),
		note(gg5,15),
		rest(5),
		volume(-3),
		note(ff4,15),
		rest(5),
	endloop,
	loop(3),
		xpose(0x100),
		volume(-3),
		note(cc4,10),
		rest(5),
		note(ff4,10),
		volume(-3),
		rest(5),
		note(gg5,10),
		rest(5),
		volume(-3),
		note(ff4,10),
		rest(5),
	endloop,


	note(ff4,10),

	loop(255),
	rest(20000),
	endloop
};

// glocks....
const unsigned short Boot5[] = {
	patch(PGLOCK),
	volume(55),
	rest(1114),
	fset(32000,26000),
	
	note(as2,20),
	note(ff2,20),
	note(as1,20),

	volume(10),	
	loop(6),

		note(as2,18),
		rest(2),

		volume(30),
		note(as2,18),
		rest(2),

		volume(20),

		note(as2,18),
		rest(2),
		
		volume(-35),

		finc(-2500,26000),
	endloop,

	loop(255),
	rest(20000),
	endloop
};

// glocks....
const unsigned short Boot6[] = {




//	patch(PGLOCK),
//	volume(10),
//	loop(100),
//		note(cc3,55),
//		rest(5),
//	endloop,
//	rest(1194),
//	fset(32000,26000),

//	note(cc3,40),
//	rest(1),
//	note(ff3,40),
//	rest(1),
//	note(cc3,40),
//	rest(1),
//	note(gg3,400),
//	rest(1),

//	loop(40),
//		note(cc3,18),
//		rest(2),
//		volume(2),
//	endloop,
//	note(cc3,500),
	loop(255),
	rest(20000),
	endloop
};

/////
// glocks....
const unsigned short Boot8[] = {
	patch(PGLOCK),
	volume(100),
	rest(1194),
	fset(32000,26000),
//	note(cc2,40),
//	rest(1),
//	note(ff2,40),
//	rest(1),
//	note(cc2,40),
//	rest(1),
//	note(gg2,400),
//	rest(1),



//	loop(40),
//		note(gg2,18),
//		rest(2),
//		volume(2),
//	endloop,
//	note(cc3,500),

	loop(255),
	rest(20000),
	endloop
};


// bass beg....
const unsigned short Boot7[] = {
	patch(PSAW2),
	xpose(0x60),
	volume(18),
	fset(1000,26000),
	note(dd2,1),
	loop(19),
		slur(dd2,10),
		finc(1500,2600),
	endloop,
	rest(800),
	note(dd2,1),
	loop(30),
		slur(dd2,10),
		finc(-750,2600),
	endloop,
	loop(30),
		slur(dd2,5),
		volume(3),
	endloop,


	loop(255),
	rest(2000),
	endloop
};

////////////////////////////////////////////////////////
// Boot track 9:  Pulses in sync with blob

const unsigned short Boot9[] = {
	patch(PTHUNEL16),
	volume(50),
	rest(326-50),
	note(aa2,280),
	rest(0),
	volume(-15),
	note(aa2,244),
	rest(0),
	volume(-15),
	note(aa2,500),

	loop(255),
	rest(2000),
	endloop
};

////////////////////////////////////////////////////////
// Boot track A:  Pulses in sync with blob

const unsigned short BootA[] = {
	patch(PTHUNEL16),
	volume(50),
	rest(454-50),
	note(aa2,252),
	rest(0),
	note(aa2,194),
	rest(0),
	volume(-20),
	note(aa2,200),


	loop(255),
	rest(2000),
	endloop
};

////////////////////////////////////////////////////////
// Boot track B:  Pulses in sync with blob

const unsigned short BootB[] = {
	patch(PTHUNEL16),
	volume(50),
	rest(526-50),
	note(aa2,274),
	rest(0),
	note(aa2,154),
	rest(0),
	volume(-20),
	note(aa2,200),

	loop(255),
	rest(2000),
	endloop
};



const unsigned short *Boot[] = {
	Boot0,Boot1,Boot2,Boot3,Boot4,Boot5,Boot6,Boot7,Boot8,Boot9,BootA,BootB
};
/////////////////////////////////////////////////////////////////////////

const unsigned short Tune0[] = {

	patch(PREVTHUN),
	note(cc3,800),
	patch(PTHUNEL16),
	note(cc3,800),

	rest(200),
	patch(PSIN1),

	loop(5),
	loop(120),
		note(cc2,50),
		xpose(200),
		rest(0),
	endloop,
	loop(120),
		note(cc0,50),
		xpose(-200),
		rest(0),
	endloop,
	endloop,
	note(5,6),
	rest(0x10),
	
//	0,1,2,3,4
};

const unsigned short Tune1[] = {

//	fset(6000,26000),
	patch(PSIN1),

	note(cc3,200),

};

const unsigned short *Tune[] = {
	Tune0
};

const struct sound sound_calls[] = {
	0,0,0,NULL,				//0 
	1,0,0xfff,Boot,			//1
	1,0,0x001,Tune,			//2
	1,0,0x001,Tune,			//2
};


struct sound sound_calls2[2];

int	max_sound_call = 0x2;
int	default_clock_value = 80;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\VBlob.h ===
///////////////////////////////////////////////////////////////////////////////
// File: VBlob.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef VBLOB_H
#define VBLOB_H


#include "qrand.h"




// The vertex list holding the unit sphere coordinates remain on the card.
// Each frame another list is streamed.

struct VBlobConstantVertex
{
	D3DVECTOR unit_sphere_normal;
};


struct VBlobChangingVertex
{
    D3DVECTOR4 normal;	// not normalized (do it in the GPU); w is the displacement due to bumps
};




// Bloblets need to be able to be copied.
class VBloblet
{
public:
	void Init()  { fWobble = 1.0f; fWobbleDirection = 0.0f; }
	void UnInit() {}

	void set(float rad, float x, float y, float z)
	{
		fRadius = rad;
		Set(&vPosition, x, y, z);
	}

	// Perturbation is normal * fMagnitude * f( (r*r)/(fRadius*fRadius) ).
	// f(r/R) will start at a peak of 1 (at r=0) and fall to 0 as r goes to R. The
	// slope at 0 and 1 will be 0.
	// The perturbation needs to be applied in code so the normals can be accumulated.
	float fRadius;
	D3DVECTOR vPosition;
	bool bFarSide;

	D3DVECTOR vDirection;
	float fStartTime;
	float fTimeMultiple;
	float fMaxDist;	// in world units

	float fCurDist; // fMaxDist * sin(...)

	float fWobble;
	float fWobbleDirection;





	bool update(float elapsed_time, float dt);	// returns false if it consents to be deleted
};





class VBlobBump
{
public:
	void Init();
	void UnInit();

	void set(float rad, float mag, float x, float y, float z)
	{
		fRadius = rad;
		fRadius2 = fRadius*fRadius;
		fOORadius2 = 1.0f / fRadius2;
		fMagnitude = mag;
		Set(&vPosition, x, y, z);
	}

	// Perturbation is normal * fMagnitude * f( (r*r)/(fRadius*fRadius) ).
	// f(r/R) will start at a peak of 1 (at r=0) and fall to 0 as r goes to R. The
	// slope at 0 and 1 will be 0.
	// The perturbation needs to be applied in code so the normals can be accumulated.
	float fRadius, fRadius2, fOORadius2;
	float fMagnitude;	// wrt unit sphere
	D3DVECTOR vPosition;

	int   facesOfInterest;		// bitfield indicating the three faces (0,1,2,4,5) <-> (-x,-y,-z,+x,+y,+z) the blob points most toward


	// returns true if it initialized a new Bloblet
	bool create(float cur_time, VBloblet* p_bloblet);	// randomly creates a blob bump
	bool update(float elapsed_time, float dt, VBloblet* p_bloblet);

protected:

	// Positioning data.
	D3DVECTOR vDirection;	// normalized
	
	float fStartTime;
	float fTimeMul;

	float fMaxMagnitude;

	VBloblet* pMyBloblet;
	bool bStillAttachedToBloblet;

	void recalculateFacesOfInterest();
};




   

class VBlob
{
protected:
    LPDIRECT3DVERTEXBUFFER8 m_pBlobletVB;		// VBlobConstantVertex, for the emerging blobs, lower tesselation
    LPDIRECT3DINDEXBUFFER8  m_pBlobletIB;
	
	LPDIRECT3DVERTEXBUFFER8 pHaloQuadVB;

    LPDIRECT3DVERTEXBUFFER8 m_pBlobVBConst;		// VBlobConstantVertex
    LPDIRECT3DVERTEXBUFFER8 m_pBlobVBChangingR;	// VBlobChangingVertex (rendering version) (swapped in render)
    LPDIRECT3DVERTEXBUFFER8 m_pBlobVBChangingU;	// VBlobChangingVertex (updating version)
    LPDIRECT3DINDEXBUFFER8  m_pBlobIB;
	D3DVECTOR*				m_pUnitSphereNormals;
    DWORD					m_dwNumVertices, m_dwNumBlobletVertices;
    DWORD					m_dwNumIndices,  m_dwNumBlobletIndices;
	int						m_NumVertsPerFace;

    DWORD                   m_dwVShaderBlob, m_dwVShaderBloblet;
    DWORD					m_dwPShaderBlob, m_dwPShaderBloblet;



	D3DVECTOR4				m_BlobColor;


	D3DVECTOR				m_Pos;		// position of center
	D3DVECTOR				m_Scale;
	FLOAT					m_fRadius;


	// BlobBumps work in unit-sphere space.
	enum { MAX_BLOBBUMPS = 32 };
	VBlobBump				m_BlobBumps[MAX_BLOBBUMPS];
	int						m_NumBlobBumps;

	enum { MAX_BLOBLETS = 8 };
	VBloblet				m_Bloblets[MAX_BLOBLETS];
	int						m_NumBloblets;



	static QRand			m_QRand;

	// Creates a VBlobConstantVertex vertex buffer. Creates WORD index buffer.
	static bool				generateUnitSphere(
											int resolution,
											LPDIRECT3DVERTEXBUFFER8* pp_vb,
											LPDIRECT3DINDEXBUFFER8* pp_ib,
											D3DVECTOR** pp_us,
											DWORD* num_verts, DWORD* num_indices);

	void					prepareChangingVertices();
	void					zeroChangingVertices();	// zeros bumps in m_pBlobVBChangingU
	inline void				swapChangingVertices()
	{
		LPDIRECT3DVERTEXBUFFER8 temp = m_pBlobVBChangingR;
		m_pBlobVBChangingR = m_pBlobVBChangingU;
		m_pBlobVBChangingU = temp;
	}



public:
	void Init();
	void UnInit()
    {
        int i;

        for (i = 0; i < MAX_BLOBBUMPS; i++)
        {
            m_BlobBumps[i].UnInit();
        }

        for (i = 0; i < MAX_BLOBLETS; i++)
        {
            m_Bloblets[i].UnInit();
        }

        destroy();
    }

	void create();
	void destroy();

	void render();
	void advanceTime(float fElapsedTime, float fDt);

	void restart();


	float getRadius() const { return m_fRadius; }
	const D3DVECTOR& getCenter() const { return m_Pos; }


	void getLightForPosition(D3DVECTOR* p_light_pos, float* p_intensity, D3DVECTOR position);



	static inline float fRand01();
	static inline float fRand11();
};

extern VBlob* gpVBlob;



#define LLI_RAND_MAX  0x00010000
#define LLI_RAND_MASK 0x0000FFFF

float VBlob::fRand01()
{
	static float mul = 1.0f / ((float)LLI_RAND_MAX);
	return ((float)(m_QRand.Rand()&LLI_RAND_MASK)) * mul;
}

float VBlob::fRand11()
{
	static float mul = 2.0f / ((float)LLI_RAND_MAX);
	return (((float)(m_QRand.Rand()&LLI_RAND_MASK)) * mul) - 1.0f;
}



#endif // VBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // Inherited members from XINPUT_GAMEPAD
	//
    // WORD    wButtons;
    // BYTE    bAnalogButtons[8];
    // SHORT   sThumbLX;
    // SHORT   sThumbLY;
    // SHORT   sThumbRX;
    // SHORT   sThumbRY;

    // Thumb stick values in range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // Buttons pressed since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

	// Rumble properties
	XINPUT_RUMBLE	Rumble;
	XINPUT_FEEDBACK	Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The first controller used by the player or the controller on the
//       lowest numbered slot. NULL if no controllers inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController();




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button or thumbstick depressed on the given controller
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\tex_gen.h ===
//
//	bs_texgen.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __TEX_GEN_H__
#define __TEX_GEN_H__


LPDIRECT3DTEXTURE8 CreateIntensityTexture(
							int   size,
							bool  b_convert_to_normal_map = false,
							float f_height_scale		  = 1.f/512.f,
							int   noise					  = 1024,
							int   seed				      = 0,
							int   clr_mask				  = 0x00ffffff,
							int   intensity_seed          = 255,
							bool  b_use_intensity_seed    = false,
							DWORD intensity_max           = 255,
							int   negative_prob           = 50
							);

void CreateIntensityTexture_8Bit(
							LPDIRECT3DTEXTURE8 ppTextures[],
							int   num,
							int   size,
							int   noise,
							int   seed,
							int   intensity_seed,
							int   intensity_max
							);



LPDIRECT3DTEXTURE8 CreateGlowTexture(int width,int height,int colorScale,int noise,int seed);
LPDIRECT3DTEXTURE8 CreateGradientTexture(DWORD dwWidth,DWORD dwHeight,DWORD dwClrStart,DWORD dwClrEnd);
LPDIRECT3DCUBETEXTURE8 CreateNormalizationCubeMap(DWORD dwSize);
LPDIRECT3DCUBETEXTURE8 CreateStaticReflectionCubeMap(DWORD dwSize);
LPDIRECT3DTEXTURE8 CreateHighlightTexture(int size,int power,
										  bool b_falloff_alpha, 
										  float f_linear_w, float f_cos_w);

int						GetNumberOfIndicesForTristripMesh(
												int x_quads,
												int y_quads,
												bool b_d_tap_1=false,
												bool b_d_tap_2=false
											);
int						CreateTristripForMesh(	WORD* p_index_buffer,
												int x_quads,			// number of quad columns
												int y_quads,			// number of quad rows
												bool b_double_tap_first=false,
												bool b_double_tap_last=false,
												int start_index = 0,	// starting index of lower-left corner
												int vstride = 0,		// vertex difference between rows
												int hstride = 0			// vertex difference between columns
											);	// returns number of indices added
LPDIRECT3DINDEXBUFFER8	CreateTristripForMesh(int x_quads, int y_quads, int* p_num_indices);



#endif	//__TEX_GEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\tex_gen.cpp ===
//
//	tex_gen.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "tex_gen.h"
#include "xbs_app.h"
#include "qrand.h"


#ifndef STARTUPANIMATION
#define ALLOC_TEX_MEM(nb) MemAlloc(nb)
#define FREE_TEX_MEM(pb)  MemFree(pb) 
#else
#define ALLOC_TEX_MEM(nb) MemAllocContiguous(nb,D3DTEXTURE_ALIGNMENT)
#define FREE_TEX_MEM(pb)  MemFreeContiguous(pb)
#endif


inline DWORD GetMaxMipCountFromSize(DWORD size )
{
	DWORD c = 0;
	
	while(size >>= 1) 
		++c;
	
	return c;
}

inline D3DCOLOR VectorToRGBA( const D3DVECTOR* v)
{
    D3DCOLOR color;

    FLOAT r = ( ( v->x + 1.0f ) * 127.5f );
    FLOAT g = ( ( v->y + 1.0f ) * 127.5f );
    FLOAT b = ( ( v->z + 1.0f ) * 127.5f );
    FLOAT a = ( 255.0f);

    __asm
    {
        cvttss2si edx, a       
        cvttss2si ecx, r       
        cvttss2si ebx, g       
        cvttss2si eax, b       
        shl ebx, 8             
        or  eax, ebx           
        shl ecx, 16            
        or  eax, ecx           
        shl edx, 24            
        or  eax, edx           
        mov color, eax       
    }

    return color;
}

LPDIRECT3DTEXTURE8 CreateHighlightTexture(int size,int power,bool b_falloff_alpha, float f_linear_w, float f_cos_w)
{
	IDirect3DTexture8 *pTexture;
	gpd3dDev->CreateTexture( size,size,1,0,D3DFMT_A8R8G8B8,NULL,&pTexture );

	D3DSURFACE_DESC desc;
	pTexture->GetLevelDesc(0,&desc);

	D3DLOCKED_RECT rc;
	pTexture->LockRect(0,&rc,NULL,0);
	int tmp = 4096/size;
	float	ooRadius = 1.0f/(float)(size/2);
	int cntrx = (size-1) / 2;
	int cntry = (size-1) / 2;

	unsigned int *pData;
	pData = (unsigned int *)rc.pBits;

	DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*size*size);

	unsigned char cosTable[257];
	for (int i=0; i < 256; i++)
	{
		float Cos,Sin;
		SinCos((float)i/256.f,&Sin,&Cos);
		for (int k = power; k; --k)
			Cos *=Cos;
		float f_sum = 255.f * (Cos * f_cos_w + (float(256-i) / 256.f) * f_linear_w);

		__asm 
		{
			cvttss2si eax, f_sum
			mov		ebx,i
			mov	cosTable[ebx],al
		}
	}

	for (int y=0; y < size; y++)
	{
		unsigned int *pPixel = (unsigned int *)pSourceBits + y*size;
		for (int x=0; x < y; x++)
		{
			float f_dist = fast_sqrt((float)((x-cntrx)*(x-cntrx) + (y-cntry)*(y-cntry))) * ooRadius;
			if (f_dist < 1.f)
			{
				unsigned int c;
				float indexShift = f_dist * 256.f;
				__asm 
				{
					cvttss2si ebx, indexShift;
					movzx	  eax, byte ptr cosTable[ebx]
					mov		  c,eax
				}

				unsigned char a = b_falloff_alpha ? c : 255;

				DWORD P = c | c<<8 | c<<16 | a<<24;
				*pPixel++ = P;
			} 
			else 
			{
				unsigned char a = b_falloff_alpha ? 0 : 0xff000000;
				*pPixel++ = a;
			}
		}
	}
		
	XGSwizzleRect(pSourceBits,
				  0,
				  NULL,
				  rc.pBits,
				  size,
				  size,
				  NULL,
				 sizeof(DWORD));
	pTexture->UnlockRect(0);

	FREE_TEX_MEM(pSourceBits);

	return pTexture;	
}


LPDIRECT3DTEXTURE8 CreateGlowTexture(int width,int height,int colorScale,int noise,int seed)
{
	IDirect3DTexture8 *pTexture;
	int mipLevels = max(GetMaxMipCountFromSize(width),GetMaxMipCountFromSize(height));
	gpd3dDev->CreateTexture(
		width,
		height,
		mipLevels,			
		0,					
		D3DFMT_A8R8G8B8,	
		D3DPOOL_MANAGED,	
		&pTexture);

	for (int i=0; i < mipLevels; i++)
	{
		D3DSURFACE_DESC desc;
		pTexture->GetLevelDesc(i,&desc);

		D3DLOCKED_RECT rc;
		pTexture->LockRect(i,&rc,NULL,0);
		int sWidth = width >> i;
		int tmp = 4096/sWidth;
		int sHeight = height >> i;
		int scale=1;	
		while (tmp!=1) {
			scale++;
			tmp=tmp>>1;
		}
		int cntrx = (sWidth-1) / 2;
		int cntry = (sHeight-1) / 2;

		unsigned int *pData;
		pData = (unsigned int *)rc.pBits;

		DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*sWidth*sHeight);

		unsigned int *pPixel = (unsigned int *)pSourceBits;

		for (int y=0; y < sHeight; y++)
		{
			for (int x=0; x < sWidth; x++)
			{
				_asm
				{
					mov		ecx,scale
					mov		eax,x
					mov		ebx,y
					sub		eax,cntrx
					sub		ebx,cntry
					sal		eax,cl
					imul	eax
					sal		ebx,cl
					xchg	eax,ebx
					mov		edi,pPixel
					imul	eax
					mov		edx,4096*4096
					add		ebx,eax
					sub		edx,ebx
					jnc		noOverflow1
					xor		edx,edx
noOverflow1:		mov		ebx,edx
					mov		eax,ebx
					mul		noise
					mov		ecx,seed
					mov		eax,edx
					mov		edx,ecx
					rcl		ecx,13
					sub		edx,11
					sub		ecx,edx
					mov		seed,ecx
					mul		ecx
					shl		edx,15
					sub		ebx,edx	
					jge		bxOk1
					xor		ebx,ebx
					
bxOk1:				and		ebx,0x1ff0000
					rcl		ebx,8
					sbb		ebx,0
					mov		eax,ebx
					shr		eax,24
					mul		al
					mul		eax
					shr		eax,16
					mul		eax
					shr		eax,16

					and		eax,0xff00
					mov		ecx,eax
					shr		ecx,8
					or		ecx,eax
					mov		eax,ecx
					shl		ecx,16
					or		ecx,eax

					mov		[edi],ecx
					add		edi,4
					mov		pPixel,edi
				}
			}
		}		

		XGSwizzleRect(pSourceBits,
					  0,
					  NULL,
					  rc.pBits,
					  sWidth,
					  sHeight,
					  NULL,
					  sizeof(DWORD));
		pTexture->UnlockRect(i);
	
		FREE_TEX_MEM(pSourceBits);
	}
	return pTexture;
}

LPDIRECT3DTEXTURE8 CreateGradientTexture( DWORD dwWidth,    DWORD dwHeight,
										  DWORD dwClrStart, DWORD dwClrEnd)
{
	LPDIRECT3DTEXTURE8 pTex = NULL;
	gpd3dDev->CreateTexture( dwWidth, dwHeight, 1, 0, D3DFMT_A8R8G8B8, NULL, &pTex );

	DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*dwWidth*dwHeight);

	D3DCOLORVALUE cv_start,cv_end;

	cv_start.a = ((float)(dwClrStart>>24))/255.f;
	cv_start.r = ((float)((dwClrStart>>16)&0xff))/255.f;
	cv_start.g = ((float)((dwClrStart>>8)&0xff))/255.f;
	cv_start.b = ((float)(dwClrStart&0xff))/255.f;

	cv_end.a = ((float)(dwClrEnd>>24))/255.f;
	cv_end.r = ((float)((dwClrEnd>>16)&0xff))/255.f;
	cv_end.g = ((float)((dwClrEnd>>8)&0xff))/255.f;
	cv_end.b = ((float)(dwClrEnd&0xff))/255.f;

	float del = 1.f/((float)(dwHeight-1));

	for(DWORD r = 0; r < dwHeight; r++)
	{
		float t = del * ((float)r);

		D3DCOLOR color;

		FLOAT _r = (cv_start.r * (1.f-t) + cv_end.r * t) * 255.f;
		FLOAT _g = (cv_start.g * (1.f-t) + cv_end.g * t) * 255.f;
		FLOAT _b = (cv_start.b * (1.f-t) + cv_end.b * t) * 255.f;
		FLOAT _a = (cv_start.a * (1.f-t) + cv_end.a * t) * 255.f;

		__asm
		{
			cvttss2si edx, _a       
			cvttss2si ecx, _r       
			cvttss2si ebx, _g       
			cvttss2si eax, _b       
			shl ebx, 8             
			or  eax, ebx           
			shl ecx, 16            
			or  eax, ecx           
			shl edx, 24            
			or  eax, edx           
			mov color, eax       
		}

		DWORD *ppix = pSourceBits + r * dwWidth;
		for(DWORD x = 0; x < dwWidth; x++)
		{
			*ppix++ = color;
		}
	};

	D3DLOCKED_RECT rc;
	pTex->LockRect(0,&rc,NULL,0);

	XGSwizzleRect(pSourceBits,
				  0,
				  NULL,
				  rc.pBits,
				  dwWidth,
				  dwHeight,
				  NULL,
				  sizeof(DWORD));

	FREE_TEX_MEM(pSourceBits);

	pTex->UnlockRect(0);
	return pTex;
}

LPDIRECT3DTEXTURE8 CreateIntensityTexture(
							int           size,
							bool          b_convert_to_normal_map,
							float         f_height_scale,
							int           noise,
							int           seed,
							int           clr_mask,
							int           intensity_seed,
							bool          b_use_intensity_seed,
							DWORD         intensity_max,
							int			  negative_prob
							)
{
	LPDIRECT3DTEXTURE8 pTex;
	gpd3dDev->CreateTexture(size,size,1,0,D3DFMT_A8R8G8B8,D3DPOOL_MANAGED,&pTex);
	
	D3DLOCKED_RECT rc;
	pTex->LockRect(0,&rc,NULL,0);

	DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*size*size);

	DWORD *pPixel = pSourceBits;
	memset(pPixel,0,sizeof(DWORD)*size*size);
	
	QRand rng;
    rng.Init(seed);

	DWORD i = (b_use_intensity_seed) ? intensity_seed : rng.Rand(intensity_max);
	*pPixel = (i<<16)|(i<<8)|(i);

	int curSize    = size>>1;
	int curX       = curSize;
	int curY       = curSize;
	int curNoise   = noise>>1;
	int curStep    = size;

	bool bSquare      = true;
	bool bSecondPass  = false;
	
	while(curSize > 0)
	{
		int lx = curX - curSize;
		int rx = curX + curSize;
		int ly = curY - curSize;
		int uy = curY + curSize;

		if(lx < 0)      lx += size;
		if(rx >= size) rx -= size;
		if(ly < 0)      ly += size;
		if(uy >= size) uy -= size;

		if(bSquare)
		{
			DWORD crnSW = *(pPixel + size*ly + lx);
			DWORD crnSE = *(pPixel + size*ly + rx);
			DWORD crnNW = *(pPixel + size*uy + lx);
			DWORD crnNE = *(pPixel + size*uy + rx);

			DWORD dwI = ((crnSW&0xff) + (crnSE&0xff) + (crnNW&0xff) + (crnNE&0xff) ) >> 2;
			
			if(rng.Rand(100) > negative_prob)
			{
				dwI += rng.Rand(curNoise);
				if(dwI > intensity_max) 
					dwI = intensity_max;
			}
			else
			{
				dwI -= rng.Rand(curNoise);
				if(dwI > 255) 
					dwI = 0;
			}
			

			*(pPixel + size*curY + curX) = (dwI<<16)|(dwI<<8)|(dwI);

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					curX = curSize;
					curY = 0;
					bSquare = false;
					continue;	
				}
				curX = curSize;
			}
		}
		else
		{
			DWORD crnN = *(pPixel + size*uy   + curX);
			DWORD crnS = *(pPixel + size*ly   + curX);
			DWORD crnW = *(pPixel + size*curY + lx);
			DWORD crnE = *(pPixel + size*curY + rx);

			DWORD dwI = ((crnN&0xff) + (crnS&0xff) + (crnE&0xff) + (crnW&0xff)) >> 2;
			
			if(rng.Rand(100) > negative_prob)
			{
				dwI += rng.Rand(curNoise);
				if(dwI > intensity_max) 
					dwI = intensity_max;
			}
			else
			{
				dwI -= rng.Rand(curNoise);
				if(dwI > 255) 
					dwI = 0;
			}


			*(pPixel + size*curY + curX) = (dwI<<16)|(dwI<<8)|(dwI);

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					if(bSecondPass)
					{
						curStep = curSize;
						curSize  >>= 1;
						curNoise >>= 1;
						curX = curSize;
						curY = curSize;
						bSquare = true;	
					}
					else
					{
						curX = 0;
						curY = curSize;
					}
					bSecondPass = !bSecondPass;
					continue;
				}

				curX = bSecondPass ? 0 : curSize;
			}	
		}
	}

	DWORD *pTooFar = pPixel + size*size;
	while(pPixel != pTooFar)
	{
		*pPixel = (((*pPixel)&0xff)<<24) | ((*pPixel)&clr_mask);
        pPixel++;
	}
	if(b_convert_to_normal_map)
	{
		for( int y=0; y<size; y++ )
		{
			DWORD *prow0 = pSourceBits + size*y;
			DWORD *prow1;
            if (y < size-1)
                prow1 = pSourceBits + size*(y+1);
            else
                prow1 = pSourceBits + size*y;

//			if(prow1 >= pTooFar)
//				prow1 = pTooFar;

			for( int x = 0; x < size; x++ )
			{
				DWORD* p00 = prow0 + x;
				DWORD* p10;
                if (x < size-1)
                    p10 = prow0 + x + 1;
                else
                    p10 = prow0 + x;

//				if(p10 >= pTooFar)
//					p10 = pTooFar;

				DWORD* p01 = prow1 + x;

				FLOAT fHeight00 = (FLOAT)(((*p00)&0x00ff0000)>>16) * f_height_scale;
				FLOAT fHeight10 = (FLOAT)(((*p10)&0x00ff0000)>>16) * f_height_scale;
				FLOAT fHeight01 = (FLOAT)(((*p01)&0x00ff0000)>>16) * f_height_scale;

				D3DVECTOR vPoint00;
				Set(&vPoint00, x+0.0f, y+0.0f, fHeight00 );

				D3DVECTOR vPoint10;
				Set(&vPoint10,x+0.1f, y+0.0f, fHeight10 );

				D3DVECTOR vPoint01;
				Set(&vPoint01, x+0.0f, y+0.1f, fHeight01 );
				
				D3DVECTOR v10;
				Sub(vPoint10,vPoint00,&v10);
				
				D3DVECTOR v01;
				Sub(vPoint01,vPoint00,&v01);

				D3DVECTOR v;
				Cross(v10, v01, &v);
				Normalize(&v);

				*p00 = VectorToRGBA( &v );
			}
		}
	}

	XGSwizzleRect(pSourceBits,
				  0,
				  NULL,
				  rc.pBits,
				  size,
				  size,
				  NULL,
				  sizeof(DWORD));

	FREE_TEX_MEM(pSourceBits);

	pTex->UnlockRect(0);

	return pTex;
}

void CreateIntensityTexture_8Bit(
							LPDIRECT3DTEXTURE8 ppTextures[],
							int   num,
							int   size,
							int   noise,
							int   seed,
							int   intensity_seed,
							int   intensity_max
							)
{
#define MAX_TEXTURES (3)
	if (num > MAX_TEXTURES) return;
	D3DLOCKED_RECT rcs[MAX_TEXTURES];

	int tex_size = size*size;

	int i;
	for (i=0; i<num; i++)
	{
		gpd3dDev->CreateTexture(size,size,1,0,D3DFMT_A8,D3DPOOL_MANAGED,&ppTextures[i]);
		ppTextures[i]->LockRect(0,&rcs[i],NULL,0);
	}
	
	BYTE *pSourceBits = (BYTE *)ALLOC_TEX_MEM(sizeof(BYTE)*size*size * num);
	// byte = pSourceBits[tex_num*tex_size + y*size + x];


	BYTE *pPixel = pSourceBits;
	memset(pPixel,0,sizeof(BYTE)*tex_size*num);
	
	QRand rng;
    rng.Init(seed);

	*pPixel = (BYTE)intensity_seed;

	int curSize    = size>>1;
	int curX       = curSize;
	int curY       = curSize;
	int curNoise   = noise>>1;
	int curStep    = size;

	bool bSquare      = true;
	bool bSecondPass  = false;
	
	while(curSize > 0)
	{
		int lx = curX - curSize;
		int rx = curX + curSize;
		int ly = curY - curSize;
		int uy = curY + curSize;

		if(lx < 0)      lx += size;
		if(rx >= size) rx -= size;
		if(ly < 0)      ly += size;
		if(uy >= size) uy -= size;

		if(bSquare)
		{
			for (i=0; i<num; i++)
			{
				int crnSW = *(pPixel + tex_size * i + size*ly + lx);
				int crnSE = *(pPixel + tex_size * i + size*ly + rx);
				int crnNW = *(pPixel + tex_size * i + size*uy + lx);
				int crnNE = *(pPixel + tex_size * i + size*uy + rx);

				int dwI = (crnSW + crnSE + crnNW + crnNE) >> 2;
				
				dwI += rng.Rand(curNoise*2) - curNoise;

				*(pPixel + tex_size * i + size*curY + curX) = (BYTE) (max(0, min(intensity_max, dwI)));
			}

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					curX = curSize;
					curY = 0;
					bSquare = false;
					continue;	
				}
				curX = curSize;
			}
		}
		else
		{
			for (i=0; i<num; i++)
			{
				int crnN = *(pPixel + tex_size * i + size*uy   + curX);
				int crnS = *(pPixel + tex_size * i + size*ly   + curX);
				int crnW = *(pPixel + tex_size * i + size*curY + lx);
				int crnE = *(pPixel + tex_size * i + size*curY + rx);

				int dwI = ((crnN&0xff) + (crnS&0xff) + (crnE&0xff) + (crnW&0xff)) >> 2;

				dwI += rng.Rand(curNoise*2) - curNoise;

				*(pPixel + tex_size * i + size*curY + curX) = (BYTE) (max(0, min(intensity_max, dwI)));
			}

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					if(bSecondPass)
					{
						curStep = curSize;
						curSize  >>= 1;
						curNoise >>= 1;
						curX = curSize;
						curY = curSize;
						bSquare = true;	
					}
					else
					{
						curX = 0;
						curY = curSize;
					}
					bSecondPass = !bSecondPass;
					continue;
				}

				curX = bSecondPass ? 0 : curSize;
			}	
		}
	}

	for (i=0; i<num; i++)
	{
		XGSwizzleRect(pSourceBits,
					  0,
					  NULL,
					  rcs[i].pBits,
					  size,
					  size,
					  NULL,
					  sizeof(BYTE));
		ppTextures[i]->UnlockRect(0);
	}

	FREE_TEX_MEM(pSourceBits);
}





LPDIRECT3DCUBETEXTURE8 CreateNormalizationCubeMap(DWORD dwSize)
{
	LPDIRECT3DCUBETEXTURE8 pCubeMap;     
    gpd3dDev->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &pCubeMap );

	DWORD * pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*dwSize*dwSize);

    for( DWORD i=0; i<6; i++ )
    {
        LPDIRECT3DSURFACE8 pCubeMapFace;
        pCubeMap->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );
        DWORD*      pPixel = pSourceBits;
        D3DVECTOR   n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

				Normalize(&n);
                *pPixel++ = VectorToRGBA( &n );
            }
        }
        
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();
        pCubeMapFace->Release();
    }
    
	FREE_TEX_MEM(pSourceBits);

    return pCubeMap;
}


LPDIRECT3DCUBETEXTURE8 CreateStaticReflectionCubeMap( DWORD dwSize )
{
	Camera old_camera = gApp.theCamera;

	LPDIRECT3DCUBETEXTURE8 pCubeMap;

	gpd3dDev->CreateCubeTexture(dwSize,1,D3DUSAGE_RENDERTARGET,D3DFMT_A8R8G8B8,NULL,&pCubeMap);
	
	LPDIRECT3DSURFACE8 pOldRT,pOldZ;
	gpd3dDev->GetRenderTarget(&pOldRT);
	gpd3dDev->GetDepthStencilSurface(&pOldZ);

	LPDIRECT3DSURFACE8 pNewZ;
	gpd3dDev->CreateDepthStencilSurface(dwSize,dwSize,D3DFMT_LIN_D24S8,
										D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,
										&pNewZ);

	D3DMATRIX oldProjMat = gApp.theCamera.matProj;
	D3DMATRIX oldViewMat = gApp.theCamera.matWTC;

	gApp.theCamera.setProjection(Pi/2.f,1.f,0.1f,400.f);
	
	D3DVECTOR pos;
	Set(&pos,0.f,0.f,0.f);

	for(DWORD dwFace = 0; dwFace < 6; dwFace++)
	{
		LPDIRECT3DSURFACE8 pNewRT;
		pCubeMap->GetCubeMapSurface( (D3DCUBEMAP_FACES)dwFace, 0, &pNewRT );
		
		gpd3dDev->SetRenderTarget(pNewRT,pNewZ);
		
		if( gpd3dDev->BeginScene() == D3D_OK )
		{
			gpd3dDev->Clear(0,NULL,
							D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
							0xff000000,
							1.f,
							0 );

			D3DMATRIX viewMat;
			SetCubeMapView( dwFace, pos, &viewMat );

			gApp.theCamera.setWTC(viewMat);
			gApp.sceneGeom.advanceTime(SCENE_ANIM_START_TIME + SCENE_ANIM_LEN,0.f);
			gApp.sceneGeom.render(false,false);

			pNewRT->Release();

			gpd3dDev->EndScene();
		}
	}

	gpd3dDev->SetRenderTarget(pOldRT,pOldZ);
	
	pOldRT->Release();
	pOldZ->Release();
	pNewZ->Release();

	gApp.theCamera = old_camera;

	return pCubeMap;
}

int GetNumberOfIndicesForTristripMesh(int x_quads, int y_quads, bool b_d_tap_1, bool b_d_tap_2)
{
	if (x_quads <= 14)
	{
		// Single stack is sufficient.
		// Each mesh is composed of x_quads*2 + 1 priming vertices,
		// and for each row there are (x_quads+1)*2 + 2 CR vertices, minus one on the last row.
		return	((b_d_tap_1) ? 1 : 0) +
				x_quads*2 + 1 +
				y_quads*( 2*(x_quads+1) + 2) - 1 +
				((b_d_tap_2) ? 1 : 0);
	}

	return
		GetNumberOfIndicesForTristripMesh(        14, y_quads, b_d_tap_1, true) +
		GetNumberOfIndicesForTristripMesh(x_quads-14, y_quads, true, b_d_tap_2);
}


// returns number of indices added
int CreateTristripForMesh(	WORD* p_index_buffer,
							int x_quads,			// number of quad columns
							int y_quads,			// number of quad rows
							bool b_double_tap_first,
							bool b_double_tap_last,
							int start_index,		// starting index of lower-left corner
							int vstride,			// vertex difference between rows
							int hstride				// vertex difference between columns
							)
{
	if (!vstride) vstride = x_quads+1;
	if (!hstride) hstride = 1;

	if (x_quads > 14)
	{
		int num = 0;
		num += CreateTristripForMesh(&p_index_buffer[num],         14, y_quads, b_double_tap_first, true, start_index           , vstride, hstride);
		num += CreateTristripForMesh(&p_index_buffer[num], x_quads-14, y_quads, true,  b_double_tap_last, start_index+14*hstride, vstride, hstride);
		return num;
	}

	int num = 0;

	if (b_double_tap_first) p_index_buffer[num++] = (WORD) (start_index);
	p_index_buffer[num++] = (WORD) (start_index);

	int i;
	for (i=1; i<=x_quads; i++)
	{
		p_index_buffer[num++] = (WORD) (start_index + i*hstride);
		p_index_buffer[num++] = (WORD) (start_index + i*hstride);
	}

	for (int j=0; j<y_quads; j++)
	{
		p_index_buffer[num++] = (WORD) (start_index + j*vstride);				// double tap beginning of line
		for (int i=0; i<=x_quads; i++)
		{
			p_index_buffer[num++] = (WORD) (start_index + j*vstride + i*hstride);
			p_index_buffer[num++] = (WORD) (start_index + (j+1)*vstride + i*hstride);
		}
		if (j<y_quads-1) p_index_buffer[num++] = (WORD) (start_index + (j+1)*vstride + x_quads*hstride);	// double tap end of line
	}

	if (b_double_tap_last) p_index_buffer[num++] = (WORD) (start_index + y_quads*vstride + x_quads*hstride);

	return num;
}


LPDIRECT3DINDEXBUFFER8 CreateTristripForMesh(int x_quads, int y_quads, int* p_num_indices)
{
	LPDIRECT3DINDEXBUFFER8 p_ib;
	int dummy;
	if (!p_num_indices) p_num_indices = &dummy;
	*p_num_indices = GetNumberOfIndicesForTristripMesh(x_quads, y_quads);
	gpd3dDev->CreateIndexBuffer(
		*p_num_indices * sizeof(WORD),
		D3DUSAGE_WRITEONLY,
		D3DFMT_INDEX16,
		D3DPOOL_DEFAULT,
		&p_ib
		);

	WORD* p_indices;
	p_ib->Lock(0, 0, (BYTE**)&p_indices, 0);
	CreateTristripForMesh(p_indices, x_quads, y_quads);
	p_ib->Unlock();	
	return p_ib;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\xbs_math.h ===
//
//	xbs_math.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __XBS_MATH_H__
#define __XBS_MATH_H__

struct D3DVECTOR4 : public _D3DVECTOR
{
	float w;
};

const float Pi = 3.1415926535897932384626433832795028841971693993751058209f;
const float DegreeToRad = 0.017453292519943295769236907684883f; // (Pi / 180)
const float RadToDegree = 57.295779513082320876798154814114f; // (180 / Pi)

inline void SetLookAt(const D3DVECTOR &cam, const D3DVECTOR &look, const D3DVECTOR &up, D3DMATRIX *pres);
inline void SetProjection(float fov,float aspect, float near_plane, float far_plane, D3DMATRIX *pres);
inline void SetInverse(const D3DMATRIX &mat, D3DMATRIX *pres);
inline void SetTranspose(const D3DMATRIX &mat, D3DMATRIX *pres);
inline void SetIdentity(D3DMATRIX *pres);
inline void SetXRotation(float r,D3DMATRIX *pres);
inline void SetYRotation(float r,D3DMATRIX *pres);
inline void SetZRotation(float r,D3DMATRIX *pres);
inline void SetXYZRotation(float x,float y,float z, D3DMATRIX *pres);
inline void SetRotationFromLHQuat(const D3DVECTOR4 &quat,D3DMATRIX *pres); 
inline void SetRotationFromRHQuat(const D3DVECTOR4 &quat,D3DMATRIX *pres); 
inline void SetScale(float x,float y,float z,D3DMATRIX *pres);
inline void SetCubeMapView(DWORD dwFace, const D3DVECTOR &pos,D3DMATRIX *pres);

inline void TransformPoint(const D3DVECTOR &pt,const D3DMATRIX &mat, D3DVECTOR *pres);
inline void TransformVector(const D3DVECTOR &v,const D3DMATRIX &mat, D3DVECTOR *pres);
inline void TransformPoint(const D3DVECTOR4 &pt,const D3DMATRIX &mat, D3DVECTOR4 *pres);


inline void MulMats(const D3DMATRIX &a, const D3DMATRIX &b,D3DMATRIX *pres);
inline void ConcatMats(const D3DMATRIX &a, const D3DMATRIX &b, D3DMATRIX *pres);

inline float Dot(const D3DVECTOR &a, const D3DVECTOR &b);
inline float Length2(const D3DVECTOR &v);
inline float Length(const D3DVECTOR &v);
inline float Distance2(const D3DVECTOR &lhs, const D3DVECTOR &rhs);
inline float Distance(const D3DVECTOR &lhs, const D3DVECTOR &rhs);
inline void  Normalize(D3DVECTOR *pres);
inline void  Cross(const D3DVECTOR &a, const D3DVECTOR &b, D3DVECTOR *pres);
inline void  Scale(D3DVECTOR *pres,float s);
inline void  Set(D3DVECTOR *pres,float x,float y,float z);
inline void  Set(D3DVECTOR4 *pres,float x,float y,float z,float w);
inline void  Sub(const D3DVECTOR &lhs, const D3DVECTOR &rhs, D3DVECTOR *pres);
inline void  Add(const D3DVECTOR &a, const D3DVECTOR &b, D3DVECTOR *pres);
inline void  SetQuatFromAxis(const D3DVECTOR &axis, float angle,D3DVECTOR4 *pres);

inline float DotQuats(const D3DVECTOR4 &q0,const D3DVECTOR4 &q1);
inline void  SlerpQuats(const D3DVECTOR4 &q0,const D3DVECTOR4 &q1,float t,D3DVECTOR4 *pres);
inline void  NormalizeQuat(D3DVECTOR4 *pres);

inline bool  IsEq(float a,float b);
inline bool  PtsEq(const D3DVECTOR &a,const D3DVECTOR &b);

inline void  AddScaled(D3DVECTOR* ptarget, const D3DVECTOR& src, float scale);
inline float QuickLength(const D3DVECTOR& vec);
inline void  QuickNormalize(D3DVECTOR* p_vec);	// left unchanged if the length is already small


inline void SinCos(const float &a, float *ps, float *pc);
inline float AngleFromSinCos(const float &s, const float &c);


inline void bs_swap(float& a, float& b);
inline void bs_swap(int& a, int& b);

inline float Square(float a) { return a*a; }


#include "xbs_math_inl.h"


#endif // __XBS_MATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "defines.h"
#ifdef INCLUDE_INPUT

#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.25

// Threshold for analog buttons
#define XBINPUT_BUTTONTHRESHOLD 1

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            pGamepads[i].wButtons          = xiState.Gamepad.wButtons;
            pGamepads[i].bAnalogButtons[0] = xiState.Gamepad.bAnalogButtons[0];
            pGamepads[i].bAnalogButtons[1] = xiState.Gamepad.bAnalogButtons[1];
            pGamepads[i].bAnalogButtons[2] = xiState.Gamepad.bAnalogButtons[2];
            pGamepads[i].bAnalogButtons[3] = xiState.Gamepad.bAnalogButtons[3];
            pGamepads[i].bAnalogButtons[4] = xiState.Gamepad.bAnalogButtons[4];
            pGamepads[i].bAnalogButtons[5] = xiState.Gamepad.bAnalogButtons[5];
            pGamepads[i].bAnalogButtons[6] = xiState.Gamepad.bAnalogButtons[6];
            pGamepads[i].bAnalogButtons[7] = xiState.Gamepad.bAnalogButtons[7];
            pGamepads[i].sThumbLX          = xiState.Gamepad.sThumbLX;
            pGamepads[i].sThumbLY          = xiState.Gamepad.sThumbLY;
            pGamepads[i].sThumbRX          = xiState.Gamepad.sThumbRX;
            pGamepads[i].sThumbRY          = xiState.Gamepad.sThumbRY;

            // Put Xbox device input for the gamepad into our custom format
            pGamepads[i].fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX1) < XBINPUT_DEADZONE )
                pGamepads[i].fX1 = 0.0f;

            pGamepads[i].fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY1) < XBINPUT_DEADZONE )
                pGamepads[i].fY1 = 0.0f;

            pGamepads[i].fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX2) < XBINPUT_DEADZONE )
                pGamepads[i].fX2 = 0.0f;

            pGamepads[i].fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY2) < XBINPUT_DEADZONE ) 
                pGamepads[i].fY2 = 0.0f;

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed since the last
            // call. Here, we considered an analog button pressed (a boolean 
            // condition) if that value is >= the threshold.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] >= XBINPUT_BUTTONTHRESHOLD );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}



//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( XBInput_IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 >  XBINPUT_DEADZONE ||
        pGamePad->fX1 < -XBINPUT_DEADZONE ||
        pGamePad->fY1 >  XBINPUT_DEADZONE ||
        pGamePad->fY1 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    if( pGamePad->fX2 >  XBINPUT_DEADZONE ||
        pGamePad->fX2 < -XBINPUT_DEADZONE ||
        pGamePad->fY2 >  XBINPUT_DEADZONE ||
        pGamePad->fY2 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    // Nothing active
    return FALSE;
}

#endif // INCLUDE_INPUT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\xbs_app.cpp ===
//
//	xbs_app.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "xbs_app.h"
#include "xbs_math.h"
#include "tex_gen.h"
#include "renderer.h"

#ifndef XMTA_TEST
#ifndef XSS_TEST
#ifndef _DEBUG
#define BOOTSOUND 1
#endif
#endif
#endif

#ifdef BOOTSOUND
#include "bootsound.h"
#endif // BOOTSOUND

#ifdef STARTUPANIMATION
#include "mslogo.h"
extern "C" {
#include "av.h"
#include "ke.h"
}
#endif // STARTUPANIMATION

#ifdef XSS_TEST

#include "xtestlib.h"

BOOL WINAPI Ani_Main(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved);
void WINAPI Ani_StartTest(HANDLE hLog);
void WINAPI Ani_EndTest(void);

#pragma data_seg(EXPORT_SECTION_NAME)
extern EXP_TABLE_ENTRY Ani_ExportTableEntry[];
__EXTRN_C EXP_TABLE_DIRECTORY Ani_ExportTableDirectory = {
    "bootanim",
    Ani_ExportTableEntry
};
#pragma data_seg()

__EXTRN_C EXP_TABLE_ENTRY Ani_ExportTableEntry[] = {
    { "StartTest", (PROC)Ani_StartTest },
    { "EndTest",   (PROC)Ani_EndTest },
    { "DllMain",   (PROC)Ani_Main },
    { NULL, NULL }
};

#endif // XSS_TEST

#ifdef _DEBUG
int gcMemAllocs = 0;
#endif // _DEBUG

unsigned long g_NVCLKSpeed = 200;

#ifdef STARTUPANIMATION
extern "C" BOOL g_bShortVersion;
#else
BOOL g_bShortVersion = FALSE;
#endif

#ifndef STARTUPANIMATION
int g_TimeRecId = 0;
#define BEGIN_TIME gApp.startTimeRec(g_TimeRecId);
#define END_TIME gApp.endTimeRec(g_TimeRecId++);
#else
#define BEGIN_TIME
#define END_TIME
#endif

extern "C" {
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );
 
     
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );

     
    VOID
    WINAPI
    KeStallExecutionProcessor (
        IN ULONG MicroSeconds
        );
    
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
{
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
}
 
DWORD ReadSMC(unsigned char addr)
{
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
}

//#define NULL_THE_HARDWARE

#ifndef FINAL_BUILD
const int FRAMECOUNT_PERIOD = 0;	// in milliseconds
#endif

#ifdef STARTUPANIMATION
namespace D3DK
{

void MemFree(void* pv)
{
    ::MemFree(pv);
}

void* MemAlloc(ULONG cBytes)
{
    return ::MemAlloc(cBytes);
}

void* MemAllocNoZero(ULONG cBytes)
{
    return ::MemAllocNoZero(cBytes);
}

}
#endif // STARTUPANIMATION

#ifdef XSS_TEST

///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI Ani_Main(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
void WINAPI Ani_EndTest(void) {
}

#endif

XBoxStartupApp gApp;

#define NUM_APP_SPEEDS 3
///////////////////////////////////////////////////////////////////////////////
#ifdef STARTUPANIMATION
extern "C"
void AnipRunAnimation()
#else // STARTUPANIMATION
#ifdef XMTA_TEST
extern "C" HRESULT Grafx_StartupAnimation_TestMain(PGFXTEST_RESULTS pgtr)
#else
#ifdef XSS_TEST
void WINAPI Ani_StartTest(HANDLE hLog)
#else
void _cdecl main()
#endif // XSS_TEST
#endif // XMTA_TEST
#endif // STARTUPANIMATION
{
#ifdef XMTA_TEST
    GFXTEST_RESULTS gtr;
#endif

#ifdef XSS_TEST

    HANDLE hMutex;

    // If any other Direct3D test is running, block until it is finished
    hMutex = CreateMutex(NULL, FALSE, "XBox Direct3D Test");
    if (!hMutex) {
        OutputDebugString(TEXT("CreateMutex failed"));
        return;
    }

    if (WaitForSingleObject(hMutex, INFINITE) != WAIT_OBJECT_0) {
        OutputDebugString(TEXT("The test mutex was abandoned"));
        CloseHandle(hMutex);
        return;
    }

    OutputDebugString(TEXT("GRAPHICS: Entering Xbox startup animation test\r\n"));

#endif

#if BOOTSOUND
    LPDIRECTSOUND pDSound;

    //
    // reset the ACI, clamp audio
    //
    
    WriteSMC(0x0B,0x01);

    DirectSoundCreate( NULL, &pDSound, NULL );
#endif

    memset(&gApp, 0, sizeof(XBoxStartupApp));

#ifdef _DEBUG
    gcMemAllocs = 0;
#endif // _DEBUG

#ifndef STARTUPANIMATION
    g_bShortVersion = FALSE;
#endif

#ifndef STARTUPANIMATION
    g_TimeRecId = 0;
#endif

#ifndef XMTA_TEST
    gApp.Construct();
#else
    gApp.Construct(&gtr);
#endif

	if(!gApp.init(640,480))
	{
#ifndef STARTUPANIMATION
		OutputDebugString("Failed to Initalize\n");
#else // STARTUPANIMATION
        return;
#endif // STARTUPANIMATION
	}

    //
    // unclamp audio
    //

#if BOOTSOUND
    pDSound->Release();
    WriteSMC(0x0B,0x00);
#endif

	gApp.run();
	gApp.shutdown();

#ifdef _DEBUG
    // Make sure all allocations are gone!

#ifdef STARTUPANIMATION
    if (gcMemAllocsContiguous != 0)
    {
        __asm int 3;
    }
#endif // STARTUPANIMATION

    if (gcMemAllocs != 0)
    {
        __asm int 3;
    }
#endif // _DEBUG

#ifndef XMTA_TEST
#ifdef XSS_TEST
    OutputDebugString(TEXT("GRAPHICS: Leaving Xbox startup animation test\r\n"));
    ReleaseMutex(hMutex);
    CloseHandle(hMutex);
#else
#ifndef GENERATE_CHECKSUMS
    XLaunchNewImage("d:\\bootscreen.xbe", NULL);
#endif
#endif
#else // XMTA_TEST
    if (pgtr) {
        memcpy(pgtr, &gtr, sizeof(GFXTEST_RESULTS));
    }
    return gtr.hr;
#endif
}
///////////////////////////////////////////////////////////////////////////////
#ifndef XMTA_TEST
void XBoxStartupApp::Construct()
#else
void XBoxStartupApp::Construct(PGFXTEST_RESULTS pgfxResults)
#endif
{
#ifdef STARTUPANIMATION
    ULONG AvInfo;
    AvSendTVEncoderOption(NULL, AV_QUERY_AV_CAPABILITIES, 0, &AvInfo); 
    if (AvInfo & AV_FLAGS_WIDESCREEN)
    {
        bWideScreen = true;
    }
    else
    {
        bWideScreen = false;
    }
#else // STARTUPANIMATION
	bWideScreen = false;
#endif // STARTUPANIMATION

#ifdef _SHIELD
    shieldMgr.Init();
#endif
    greenFog.Init();

#if 0
    LARGE_INTEGER li;
    KeQuerySystemTime(&li);
    qrand.Init(li.LowPart);
#else
    qrand.Init();
#endif

    theRenderer.Init();
    theCamera.Init();
    vblob.Init();
    camController.Init();

#ifdef STARTUPANIMATION
    bLoop    = false;
#else

#ifndef FINAL_BUILD
	bLoop    = true;
#else 
	bLoop    = false;
#endif

#endif // STARTUPANIMATION

	bPaused  = false;
	bActive  = false;

	bCameraUnderControl = true;
	bUserControlledIntensity = false;

	appSpeedId = 0;
	
	fIIDT = 0.0f;
	fSmoothedBlobIntensity = fBlobIntensity = fBaseBlobIntensity = DEMO_START_INTENSITY;
    if (g_bShortVersion)
    {
        fTimeElapsed = 7.5f;
    }
    else
    {
	    fTimeElapsed = 0.0f;
    }


	bSceneShadowsOn = true;
	bFogOn = true;

#ifdef INCLUDE_INPUT
	dwNumInputDeviceTypes = 0;
    inputDeviceTypes = NULL;
#endif // INCLUDE_INPUT

	fCamRad = 90.f;
	fCamTheta = Pi;
	fCamPhi = 0.f;

 	if (bCameraUnderControl)
	{
		bs_swap(fCamRad, fSavedCamRad);
		bs_swap(fCamTheta, fSavedCamTheta);
		bs_swap(fCamPhi, fSavedCamPhi);
	}


	float fTest = 1.35f;
	int z = (int)(fTest * 2.f);

	ZeroMemory(&blobLight,sizeof(blobLight));
	Set( (D3DVECTOR4 *)&blobLight.Position, 0.f, 0.f,0.f );
	Set( (D3DVECTOR4 *)&blobLight.Ambient,0.0f,0.0f,0.0f,1.f );
	Set( (D3DVECTOR4 *)&blobLight.Diffuse,0.13f,0.13f,0.13f,1.f );
	Set( (D3DVECTOR4 *)&blobLight.Specular,1.f,1.f,1.f,1.f );
	blobLight.Attenuation0 = 1.f;
	blobLight.Attenuation1 = 0.001f;
	blobLight.Attenuation2 = 0.001f;

	ZeroMemory(&moodLight,sizeof(moodLight));
	Set( (D3DVECTOR4 *)&moodLight.Position, 0.f, -40.f,30.f );
	Set( (D3DVECTOR4 *)&moodLight.Ambient,0.f,0.f,0.f,1.f );
	Set( (D3DVECTOR4 *)&moodLight.Diffuse,0.25f,0.25f,0.25f,1.f );
	Set( (D3DVECTOR4 *)&moodLight.Specular,0.75f,0.75f,0.75f,1.f );
	moodLight.Attenuation0 = 1.f;
	moodLight.Attenuation1 = 0.001f;
	moodLight.Attenuation2 = 0.001f;

	pNormalCubeMapLoRes = NULL;
	pNormalCubeMapHiRes = NULL;

	pRoughBumpMap = NULL;

	pStaticReflectionCubeMap = NULL;
	pGlowMap = NULL;


#ifdef INCLUDE_PLACEMENT_DOODAD	
	bPositionLookatMode = false;
	Set(&ptLookatPosition, 0.0f, 0.0f, 0.0f);
	placementDoodad.Init();
#endif

#ifdef XMTA_TEST
    pgtr = pgfxResults;
    pgtr->hr = D3D_OK;
    pgtr->uFrame = (UINT)-1;
    for (UINT i = 0; i < 3; i++) {
        pgtr->dwCRCResult[0] = 0;
        pgtr->dwCRCExpected[0] = 0;
    }
#ifndef HADWARE_CHECKSUM
    pgtr->bHardwareChecksum = false;
#else
    pgtr->bHardwareChecksum = true;
#endif
#endif

#ifndef HADWARE_CHECKSUM
    // Initialize the CRC table
    DWORD dwCRC, i, j;
    for (i = 0; i < 256; i++) {
        dwCRC = i;
        for (j = 0; j < 8; j++) {
            dwCRC = (dwCRC & 1) ? ((dwCRC >> 1) ^ 0xEDB88320L) : (dwCRC >> 1);
        }
        m_dwCRCTable[i] = dwCRC;
    }
#endif

#ifdef GENERATE_CHECKSUMS
    DWORD dwWritten;
    hChecksumFile = CreateFile(TEXT("t:\\checksum.log"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    WriteFile(hChecksumFile, &dwWritten, sizeof(DWORD), &dwWritten, NULL);
#else
    pdwChecksums = (LPDWORD)XLoadSection("checksum.log");
//    dwChecksumSize = XGetSectionSize(XGetSectionHandle("checksum.log"));
    uNumRefChecksums = *(UINT*)pdwChecksums;
    pdwChecksums++;
#endif
    uNumScreenChecksums = 0;
}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::Destruct()
{
#ifdef _SHIELD
    shieldMgr.UnInit();
#endif
    greenFog.UnInit();
    theRenderer.UnInit();
    theCamera.UnInit();
    vblob.UnInit();
    camController.UnInit();
#ifdef INCLUDE_PLACEMENT_DOODAD
	placementDoodad.UnInit();
#endif
}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::pause()
{
	bPaused = !bPaused;
}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::activate()
{
	bActive = !bActive;
}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::advanceTime(float dt,float cam_dt)
{
	if (dt > 1.0f) dt = 0.001f;	// cap after a breakpoint
	fTimeElapsed += dt;


	if(!bUserControlledIntensity)
	{
		if (fTimeElapsed < BLOB_ZERO_INTENSE_END_TIME)
		{
			fBaseBlobIntensity = 0.0f;
		}
		else
		{
			float t = (fTimeElapsed - BLOB_ZERO_INTENSE_END_TIME) * OO_MAX_INTENSITY_DELTA;
			t = 0.5f * t*t + 0.5f * t;
			fBaseBlobIntensity = DEMO_START_INTENSITY + t * (1.0f - DEMO_START_INTENSITY);
		}


		float pulses = sumIntensityPulses(fTimeElapsed);

		fBlobIntensity = fBaseBlobIntensity + pulses;

		float s = 0.5f*dt;
		fSmoothedBlobIntensity = (1.0f - s) * fSmoothedBlobIntensity + s * fBlobIntensity;

		fIIDT += dt * fBlobIntensity;
	}

#ifdef INCLUDE_INPUT
	else
	{
		// check for ramp up / down of blob intensity.
		static const float f_int_vel = 2.f;

		if( defaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER])
		{
			float fval = ((float)defaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER]) / 255.0f;
			fBlobIntensity -= (f_int_vel * cam_dt * fval);
			fBlobIntensity = max(0.f,fBlobIntensity);
		}

		if( defaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
		{
			float fval = ((float)defaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER]) / 255.0f;
			fBlobIntensity += (f_int_vel * cam_dt * fval);
			fBlobIntensity = min(4.f,fBlobIntensity);
		}
	}
	static const float lin_vel = 100.0f;
	static const float rot_vel = Pi*0.5f;

	if (!bCameraUnderControl)
	{
#ifdef INCLUDE_PLACEMENT_DOODAD	
		if( bPositionLookatMode )
		{
			const float move_vel = 0.6f;
			D3DVECTOR cam_pos;
			theCamera.getCameraPos(&cam_pos);
			float doodad_rad = Distance(ptLookatPosition, cam_pos);
			float move_right = defaultGamepad.fX1 * move_vel * cam_dt * doodad_rad;
			float move_up    = defaultGamepad.fY1 * move_vel * cam_dt * doodad_rad;

			float z_delta = 0.0f;
			float z_mul = 0.6f;
			if (bPaused)
			{
				float dead_banded = defaultGamepad.fY2;
				if (dead_banded < 0.0f)	dead_banded = min(0.0f, dead_banded + 0.3f);
				else					dead_banded = max(0.0f, dead_banded - 0.3f);
				z_delta += dead_banded * z_mul * cam_dt * doodad_rad;
			}
			else
			{
				z_delta += defaultGamepad.fY2 * z_mul * cam_dt * doodad_rad;
			}

			D3DVECTOR right_dir = *((D3DVECTOR*)(&theCamera.matCTW._11));
			D3DVECTOR up_dir    = *((D3DVECTOR*)(&theCamera.matCTW._21));
			D3DVECTOR z_dir     = *((D3DVECTOR*)(&theCamera.matCTW._31));

			// Moves around in plane, rather than in screen space.
			Set(&z_dir, 0.0f, 0.0f, 1.0f);
			Cross(z_dir, right_dir, &up_dir);


			AddScaled(&ptLookatPosition, right_dir, move_right);
			AddScaled(&ptLookatPosition, up_dir, move_up);
			AddScaled(&ptLookatPosition, z_dir, z_delta);
		}
		else
#endif
		{
			fCamTheta += defaultGamepad.fX1 * rot_vel * cam_dt;
			fCamPhi += defaultGamepad.fY1 * rot_vel * cam_dt;

			if (bPaused)
			{
				float dead_banded = defaultGamepad.fY2;
				if (dead_banded < 0.0f)	dead_banded = min(0.0f, dead_banded + 0.5f);
				else					dead_banded = max(0.0f, dead_banded - 0.5f);
				fCamRad -= dead_banded * lin_vel * cam_dt;
			}
			else
			{
				fCamRad -= defaultGamepad.fY2 * lin_vel * cam_dt;
			}
		}
	}

	if( defaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
	{
		bFogOn = !bFogOn;	
	}

	if( defaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
	{
		bSceneShadowsOn = !bSceneShadowsOn;
	}

	if( defaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
	{
		if(++appSpeedId >= NUM_APP_SPEEDS)
		{
			appSpeedId = 0;
			bPaused = false;
		}
		else if(appSpeedId == NUM_APP_SPEEDS - 1)
			pause();
	}
	
	// Trace out the current camera position as a frogcam array entry.
	if( defaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
	{
		camController.buttonPressed();
	}

	if( defaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
	{
		bCameraUnderControl = !bCameraUnderControl;
		bs_swap(fCamRad, fSavedCamRad);
		bs_swap(fCamTheta, fSavedCamTheta);
		bs_swap(fCamPhi, fSavedCamPhi);
	}

	if( defaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
	{
		// Toggle blob intensity mode.
		bUserControlledIntensity = !bUserControlledIntensity;
	}



#ifdef INCLUDE_PLACEMENT_DOODAD	
	if( defaultGamepad.wPressedButtons & XINPUT_GAMEPAD_LEFT_THUMB )
	{
		bPositionLookatMode = !bPositionLookatMode;
	}
#endif



	if(bPaused)
	{
		float f_time_vel = 0.02f;
		float f_jog_time = defaultGamepad.fX2 * f_time_vel;
		if (fast_fabs(defaultGamepad.fX2) > 0.9f) f_jog_time *= 3.0f;

		fTimeElapsed += f_jog_time;
		fJogDeltaTime += f_jog_time;
		if(fTimeElapsed < 0.f)
		{
			fJogDeltaTime += 0.0f - fTimeElapsed;
			fTimeElapsed = 0.0f;
		}
		if(fTimeElapsed > DEMO_TOTAL_TIME )
		{
			fJogDeltaTime += (DEMO_TOTAL_TIME - 0.0001f) - fTimeElapsed;
			fTimeElapsed = DEMO_TOTAL_TIME - 0.0001f; 
		}
	}


#endif // INCLUDE_INPUT

	if(fTimeElapsed >= DEMO_TOTAL_TIME)
	{
		if(!bLoop)
		{
			return;
		}
		else
		{
#ifdef BOOTSOUND
		    // start boot sound again with animation restart
            put_fifo(1);
#endif
			fIIDT = 0.0f;
			
			if(!bUserControlledIntensity)
				fSmoothedBlobIntensity = fBlobIntensity = fBaseBlobIntensity = DEMO_START_INTENSITY;

            if (g_bShortVersion)
            {
                fTimeElapsed = 7.5f;
            }
            else
            {
	            fTimeElapsed = 0.0f;
            }
            
			if(!bUserControlledIntensity)
			{
				initIntensityPulses();
				vblob.restart();
#ifdef _SHIELD
				shieldMgr.restart();
#endif
				greenFog.restart();
				camController.pickPath(-1);
			}
		}
	}

	if (!bCameraUnderControl)
	{
		if(fCamPhi > Pi*0.5f) fCamPhi = Pi*0.5f;
		if(fCamPhi < -Pi*0.5f) fCamPhi = -Pi*0.5f;
		fCamRad = max(fCamRad,10.f);
	}

	// I need camera stuff here so that the fog renders at the new viewpoint.
	D3DVECTOR pos,look,up;
	D3DMATRIX matRot,matX,matZ;
	SetXRotation(fCamPhi,&matX);
	SetZRotation(fCamTheta,&matZ);
	MulMats(matX,matZ, &matRot);
	
	D3DVECTOR tmp;
	Set(&tmp,0.f,fCamRad,-10.f);
	Set(&look,0.f,0.f,0.f);
	Set(&up,0.f,0.f,1.f);


	bRenderGeom = true;
	bRenderSlash = false;

	Set(&look,0.f,0.f,0.f);
	Set(&up,0.f,0.f,1.f);

	if (bCameraUnderControl)
	{
		float fCamTime = (fTimeElapsed * fTimeElapsed / 6.0f)*.8f;
		fCamTime = fCamTime + .2f*(fTimeElapsed * fast_sin(min(3.14159265354f/2.f,fTimeElapsed * .2833f)));
		camController.getPosition(fCamTime, &pos, &look, &bRenderGeom, &bRenderSlash);

		// Need to set cam rad, theta, and phi so the fog looks right.
		fCamRad = Length(pos);
		float oo_rad = 1.0f / fCamRad;
		fCamPhi = fast_asin(pos.z * oo_rad);
		oo_rad = 1.0f / fast_sqrt(Square(pos.x) + Square(pos.y));
		// Avoid the poles!
		float old_theta = fCamTheta;
		fCamTheta = AngleFromSinCos(oo_rad * pos.y, oo_rad * pos.x);

		if ((fast_fabs(old_theta) < 1000.0f) && (fast_fabs(fCamTheta - old_theta) > Pi))
		{
			// Must rewrap, so that the fog doesn't skip.
			while (old_theta - Pi > fCamTheta) fCamTheta += 2.0f * Pi;
			while (old_theta + Pi < fCamTheta) fCamTheta -= 2.0f * Pi;
		}
	}
	else
	{
		D3DMATRIX matRot,matX,matZ;
		SetXRotation(fCamPhi,&matX);
		SetZRotation(fCamTheta,&matZ);
		MulMats(matX,matZ, &matRot);
		
		D3DVECTOR tmp;
		Set(&tmp,0.f,fCamRad,-10.f);

		TransformVector(tmp,matRot,&pos);


#ifdef INCLUDE_PLACEMENT_DOODAD	
		look = ptLookatPosition;
		Add(ptLookatPosition, pos, &pos);
#endif
	}

	theCamera.lookAt(pos,look,up);
	fCamRadBlob = Distance(vblob.getCenter(), pos);

	if (bRenderGeom)
	{
		sceneGeom.advanceTime(fTimeElapsed, dt);
		vblob.advanceTime(fTimeElapsed, dt);

		if(bSceneShadowsOn) 
			sceneGeom.updateShadows();
#ifdef _SHIELD	
		if(!bUserControlledIntensity)
			shieldMgr.advanceTime(fTimeElapsed, dt);
#endif

		if(bFogOn)
			greenFog.advanceTime(fTimeElapsed, dt);
	}
	
	if (bRenderSlash)
	{
		logoGeom.advanceTime(fTimeElapsed, dt);	
	}

}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::drawFrame()
{

	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
						0xff000000,
						1.f,
						0 );
		if (bRenderGeom)
		{
			if (getBlobIntensity() > 0.0f)
			{
				sceneGeom.render(bSceneShadowsOn,true);
			}
#ifdef _SHIELD
			shieldMgr.render(true);
#endif
			if (fTimeElapsed >= BLOB_STATIC_END_TIME) vblob.render();
#ifdef _SHIELD
			shieldMgr.render(false);
#endif


#ifdef INCLUDE_PLACEMENT_DOODAD	
			if (bPositionLookatMode)
			{
				placementDoodad.render(&ptLookatPosition, &theCamera.matWTC, &theCamera.matProj);
			}
#endif

		}

		bool b_render_fog = (bRenderGeom && bFogOn && ((getBlobIntensity() > 0.0f) || (fTimeElapsed < BLOB_STATIC_END_TIME)));
		
		if (bRenderSlash)
		{
			if (b_render_fog || bRenderGeom)
			{
				gpd3dDev->Clear(0,NULL,
								D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER,
								0xff000000,
								1.0f,
								0 );
			}
			
			const D3DMATRIX& xf_slash = camController.getSlashTransform();
			logoGeom.render(xf_slash);
		}

		if (b_render_fog)
		{
			greenFog.render(bRenderSlash);
		}

		
		gpd3dDev->EndScene();
		gpd3dDev->Present(NULL,NULL,NULL,NULL);

        verifyScreenChecksum();
	}
}

///////////////////////////////////////////////////////////////////////////////
bool XBoxStartupApp::init(int width,int height)
{
	fIIDT = 0.0f;
	fSmoothedBlobIntensity = fBlobIntensity = fBaseBlobIntensity = DEMO_START_INTENSITY;
	initIntensityPulses();

	nWidth  = width;
	nHeight = height; 
		
	BEGIN_TIME;
	theRenderer.init(nWidth,nHeight);
	END_TIME;

	BEGIN_TIME;
	pNormalCubeMapHiRes = CreateNormalizationCubeMap(128);
	END_TIME;
	
	BEGIN_TIME;
	pNormalCubeMapLoRes = CreateNormalizationCubeMap(64);
	END_TIME;
	
	BEGIN_TIME;
	pRoughBumpMap = CreateIntensityTexture(128,true,1.f/512.f,512);
	END_TIME;

	BEGIN_TIME;
	pGlowMap = CreateGlowTexture(256,256,0xffffffff,0,12345);
	END_TIME;

	DWORD dwBumpDecl[] =
    {
        D3DVSD_STREAM( 0 ),
		D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),

		D3DVSD_STREAM( 1 ),
		D3DVSD_REG( 1, D3DVSDT_FLOAT2 ),
		D3DVSD_REG( 2, D3DVSDT_FLOAT3 ),     
		D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),     
		D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), 
		D3DVSD_END()
    };

	DWORD dwPhongDecl[] =
    {
        D3DVSD_STREAM( 0 ),
		D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),

		D3DVSD_STREAM( 1 ),
		D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),     
		D3DVSD_REG( 2, D3DVSDT_FLOAT3 ),     
		D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), 
		D3DVSD_END()
    };

	DWORD dwDepthDecl[] = 
	{
		D3DVSD_STREAM( 0 ),
		
		D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),
		
		D3DVSD_END()
	};

	BEGIN_TIME;
#ifndef BINARY_RESOURCE
	dwVShader[st_Phong] = gApp.loadVertexShader("d:\\shaders\\scene_phong.xvu",dwPhongDecl);
	dwPShader[st_Phong] = gApp.loadPixelShader ("d:\\shaders\\scene_phong.xpu");

	dwVShader[st_Bump] = gApp.loadVertexShader("d:\\shaders\\scene_bump.xvu",dwBumpDecl);
	dwPShader[st_Bump] = gApp.loadPixelShader ("d:\\shaders\\scene_bump.xpu");

	dwVShader[st_Depth] = gApp.loadVertexShader("d:\\shaders\\scene_zr.xvu",dwDepthDecl);
	dwPShader[st_Depth] = gApp.loadPixelShader ("d:\\shaders\\scene_zr.xpu");
#else // BINARY_RESOURCE
	dwVShader[st_Phong] = gApp.loadVertexShader(g_scene_phong_xvu,dwPhongDecl);
	dwPShader[st_Phong] = gApp.loadPixelShader (g_scene_phong_xpu);

	dwVShader[st_Bump] = gApp.loadVertexShader(g_scene_bump_xvu,dwBumpDecl);
	dwPShader[st_Bump] = gApp.loadPixelShader (g_scene_bump_xpu);

	dwVShader[st_Depth] = gApp.loadVertexShader(g_scene_zr_xvu,dwDepthDecl);
	dwPShader[st_Depth] = gApp.loadPixelShader (g_scene_zr_xpu);
#endif // BINARY_RESOURCE
	END_TIME;

    // Set the camera up, the fog will want the correct start position.
	D3DVECTOR pos,look,up;
	D3DMATRIX matRot,matX,matZ;
	SetXRotation(fCamPhi,&matX);
	SetZRotation(fCamTheta,&matZ);
	MulMats(matX,matZ, &matRot);
	
	D3DVECTOR tmp;
	Set(&tmp,0.f,fCamRad,-10.f);

	TransformVector(tmp,matRot,&pos);

	Set(&look,0.f,0.f,0.f);
	Set(&up,0.f,0.f,1.f);

	theCamera.lookAt(pos,look,up);

	float f_aspect = (bWideScreen) ? 9.f/16.f : 3.f/4.f;
	theCamera.setProjection(Pi/4.f, f_aspect, 0.4f, 800.0f);

	BEGIN_TIME;
	sceneGeom.create();
	END_TIME;

	BEGIN_TIME;
	logoGeom.create();
	END_TIME;

	BEGIN_TIME;
	vblob.create();
	END_TIME;

	BEGIN_TIME;
#ifdef _SHIELD
	shieldMgr.create();
#endif
	END_TIME;

#ifdef INCLUDE_PLACEMENT_DOODAD
	BEGIN_TIME;
	placementDoodad.create();
	END_TIME;
#endif

	BEGIN_TIME;
	greenFog.create();
	END_TIME;

	BEGIN_TIME;
	pStaticReflectionCubeMap = CreateStaticReflectionCubeMap(256);
	END_TIME;

#ifdef INCLUDE_INPUT
#ifndef XSS_TEST
    XInitDevices( dwNumInputDeviceTypes, inputDeviceTypes );
#endif
    XBInput_CreateGamepads( &pGamepad ); 
#endif // INCLUDE_INPUT

#ifndef STARTUPANIMATION
	dwLastFramecountTick = dwLastTick = GetTickCount();
#else // STARTUPANIMATION
	dwLastFramecountTick = dwLastTick = NtGetTickCount();
#endif // STARTUPANIMATION

#ifndef FINAL_BUILD
	numFrames = 0;
	numFramesTooSlow = 0;
	fSlowestFrame = 0.0f;
	fFastestFrame = 100.0f;
#endif

	
#ifndef STARTUPANIMATION
	float f_total_time = 0.f;
	for(int i = 0; i < g_TimeRecId; i++)
		f_total_time += fInitTimes[i];

#if DBG
	char buf[256];
	sprintf(buf,"Init time: %ff seconds\n",f_total_time);
	OutputDebugString(buf);
#endif

#endif

	return true;
}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::shutdown()
{
	sceneGeom.destroy();
	logoGeom.destroy();
	vblob.destroy();
#ifdef _SHIELD
	shieldMgr.destroy();
#endif
#ifdef INCLUDE_PLACEMENT_DOODAD
	placementDoodad.destroy();
#endif
	greenFog.destroy();

	pNormalCubeMapLoRes->Release();
	pNormalCubeMapHiRes->Release();

	pStaticReflectionCubeMap->Release();

	pRoughBumpMap->Release();

	pGlowMap->Release();

	gpd3dDev->DeleteVertexShader(dwVShader[st_Phong]);
	gpd3dDev->DeleteVertexShader(dwVShader[st_Bump]);
	gpd3dDev->DeleteVertexShader(dwVShader[st_Depth]);
	gpd3dDev->DeletePixelShader(dwPShader[st_Phong]);
	gpd3dDev->DeletePixelShader(dwPShader[st_Bump]);
	gpd3dDev->DeletePixelShader(dwPShader[st_Depth]);

#ifdef STARTUPANIMATION
    WaitOnMicrosoftLogo();
#endif // STARTUPANIMATION

	theRenderer.shutdown();
	bActive = false;

#ifdef GENERATE_CHECKSUMS
    DWORD dwWritten;
    SetFilePointer(hChecksumFile, 0, NULL, FILE_BEGIN);
    WriteFile(hChecksumFile, &uNumScreenChecksums, sizeof(DWORD), &dwWritten, NULL);
    CloseHandle(hChecksumFile);
#else
    XFreeSection("checksum.log");
#endif
}

#ifdef HARDWARE_CHECKSUM

DWORD g_DoChecksum; 
DWORD g_Channel; 
DWORD g_Value[3]; 

//------------------------------------------------------------------------------ 
// Callback used to calculate the checksum for the current display.  This must
// be passed to D3DDevice_SetVerticalBlankCallback once before
// D3DTest_ScreenChecksum is called.

extern "C"
void __cdecl Ani_ChecksumCallback(
    DWORD dwContext)
{ 
    if (g_DoChecksum) 
    { 
        if (g_Channel > 0) 
        { 
            g_Value[g_Channel - 1] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF; 
            if (g_Value[g_Channel - 1] == 0xFFFFFF) {
                g_Channel--;
            }
        } 

        if (g_Channel < 3) 
        { 
            *(volatile DWORD *)0xFD680844 = 0x411 | (g_Channel << 8); 
            *(volatile DWORD *)0xFD680844 = 0x410 | (g_Channel << 8); 

            g_Channel++; 
        } 
        else 
        { 
            g_Channel = 0; 
            g_DoChecksum = 0; 
        } 
    } 
} 

//------------------------------------------------------------------------------ 
// Calculates the frame's checksum. 

extern "C"
void Ani_GetScreenChecksum(DWORD *pdwRed, DWORD* pdwGreen, DWORD* pdwBlue)
{ 
    g_DoChecksum = 1; 

    while (g_DoChecksum) 
    { 
        D3DDevice_BlockUntilVerticalBlank(); 
    } 

    *pdwRed   = g_Value[0]; 
    *pdwGreen = g_Value[1]; 
    *pdwBlue  = g_Value[2]; 
}

#endif

#ifdef HARDWARE_CHECKSUM

///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::verifyScreenChecksum()
{
    DWORD dwColor[3];
    D3DDevice_BlockUntilVerticalBlank();
    Ani_GetScreenChecksum(&dwColor[0], &dwColor[1], &dwColor[2]);

#ifdef GENERATE_CHECKSUMS
    DWORD dwWritten;
    WriteFile(hChecksumFile, dwColor, 3 * sizeof(DWORD), &dwWritten, NULL);
#else
    if (uNumScreenChecksums < uNumRefChecksums) {
        if ((dwColor[0] & 0xFFFFFF) != (pdwChecksums[0] & 0xFFFFFF) ||
            (dwColor[1] & 0xFFFFFF) != (pdwChecksums[1] & 0xFFFFFF) ||
            (dwColor[2] & 0xFFFFFF) != (pdwChecksums[2] & 0xFFFFFF))
        {
            char szOut[512];
            UINT i;
            wsprintf(szOut, "ERROR: Screen checksum mismatch on frame %d - "
                     "Actual: [0x%06X, 0x%06X, 0x%06X]; "
                     "Expected: [0x%06X, 0x%06X, 0x%06X]\r\n", 
                     uNumScreenChecksums, dwColor[0] & 0xFFFFFF, 
                     dwColor[1] & 0xFFFFFF, dwColor[2] & 0xFFFFFF, 
                     pdwChecksums[0] & 0xFFFFFF, pdwChecksums[1] & 0xFFFFFF, 
                     pdwChecksums[2] & 0xFFFFFF);
            OutputDebugString(szOut);
#ifdef XMTA_TEST
            if (pgtr->hr == D3D_OK) {
                pgtr->hr = E_FAIL;
                pgtr->uFrame = uNumScreenChecksums;
                for (i = 0; i < 3; i++) {
                    pgtr->dwCRCResult[0] = dwColor[0] & 0xFFFFFF;
                    pgtr->dwCRCExpected[0] = pdwChecksums[0] & 0xFFFFFF;
                }
                pgtr->bHardwareChecksum = true;
            }
#else
            OutputDebugString(TEXT("BOOTSCREEN: Screen checksum mismatch\r\n"));
            __asm int 3;
#endif
        }
        pdwChecksums += 3;
    }
    else {
        char szOut[512];
        wsprintf(szOut, "WARNING: Frame %d cannot be verified\r\n", uNumScreenChecksums);
        OutputDebugString(szOut);
    }
#endif
    uNumScreenChecksums++;
}

#else

///////////////////////////////////////////////////////////////////////////////
DWORD XBoxStartupApp::ComputeSurfaceCRC32(LPDIRECT3DSURFACE8 pd3ds) {

    D3DSURFACE_DESC d3dsd;
    D3DLOCKED_RECT  d3dlr;
    DWORD           dwCRC = 0;
    LPBYTE          pbData;
    UINT            i, j, k;
    HRESULT         hr;

    hr = pd3ds->GetDesc(&d3dsd);
    if (FAILED(hr)) {
        return 0;
    }

    hr = pd3ds->LockRect(&d3dlr, NULL, 0);
    if (FAILED(hr)) {
        return 0;
    }

    switch (d3dsd.Format) {

        case D3DFMT_LIN_R5G6B5: {
            DWORD  dwPixel;
            LPWORD pwPixel = (LPWORD)d3dlr.pBits;
            for (i = 0; i < d3dsd.Height; i++) {
                for (j = 0; j < d3dsd.Width; j++) {
                    dwPixel = (pwPixel[j] & 0xF800) << 8 |
                              (pwPixel[j] & 0x07E0) << 5 |
                              (pwPixel[j] & 0x001F) << 3;
                    pbData = (LPBYTE)&dwPixel;
                    for (k = 0; k < 3; k++) {
                        dwCRC = m_dwCRCTable[(dwCRC ^ pbData[k]) & 0xFF] ^ (dwCRC >> 8);
                    }
                }
                pwPixel += d3dlr.Pitch >> 1;
            }
            break;
        }

        case D3DFMT_LIN_X1R5G5B5: {
            DWORD  dwPixel;
            LPWORD pwPixel = (LPWORD)d3dlr.pBits;
            for (i = 0; i < d3dsd.Height; i++) {
                for (j = 0; j < d3dsd.Width; j++) {
                    dwPixel = (pwPixel[j] & 0x7C00) << 9 |
                              (pwPixel[j] & 0x03E0) << 6 |
                              (pwPixel[j] & 0x001F) << 3;
                    pbData = (LPBYTE)&dwPixel;
                    for (k = 0; k < 3; k++) {
                        dwCRC = m_dwCRCTable[(dwCRC ^ pbData[k]) & 0xFF] ^ (dwCRC >> 8);
                    }
                }
                pwPixel += d3dlr.Pitch >> 1;
            }
            break;
        }

        case D3DFMT_LIN_A1R5G5B5: {
            DWORD  dwPixel;
            LPWORD pwPixel = (LPWORD)d3dlr.pBits;
            for (i = 0; i < d3dsd.Height; i++) {
                for (j = 0; j < d3dsd.Width; j++) {
                    dwPixel = (pwPixel[j] & 0x8000) << 16 |
                              (pwPixel[j] & 0x7C00) << 9 |
                              (pwPixel[j] & 0x03E0) << 6 |
                              (pwPixel[j] & 0x001F) << 3;
                    pbData = (LPBYTE)&dwPixel;
                    for (k = 0; k < 4; k++) {
                        dwCRC = m_dwCRCTable[(dwCRC ^ pbData[k]) & 0xFF] ^ (dwCRC >> 8);
                    }
                }
                pwPixel += d3dlr.Pitch >> 1;
            }
            break;
        }

        case D3DFMT_LIN_X8R8G8B8: {
            LPDWORD pdwPixel = (LPDWORD)d3dlr.pBits;
            for (i = 0; i < d3dsd.Height; i++) {
                for (j = 0; j < d3dsd.Width; j++) {
                    pbData = (LPBYTE)&pdwPixel[j];
                    for (k = 0; k < 3; k++) {
                        dwCRC = m_dwCRCTable[(dwCRC ^ pbData[k]) & 0xFF] ^ (dwCRC >> 8);
                    }
                }
                pdwPixel += d3dlr.Pitch >> 2;
            }
            break;
        }

        case D3DFMT_LIN_D24S8:
        case D3DFMT_LIN_A8R8G8B8: {
            LPDWORD pdwPixel = (LPDWORD)d3dlr.pBits;
            for (i = 0; i < d3dsd.Height; i++) {
                for (j = 0; j < d3dsd.Width; j++) {
                    pbData = (LPBYTE)&pdwPixel[j];
                    for (k = 0; k < 4; k++) {
                        dwCRC = m_dwCRCTable[(dwCRC ^ pbData[k]) & 0xFF] ^ (dwCRC >> 8);
                    }
                }
                pdwPixel += d3dlr.Pitch >> 2;
            }
            break;
        }
    }

    pd3ds->UnlockRect();

    return dwCRC;
}

///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::verifyScreenChecksum()
{
    LPDIRECT3DSURFACE8 pd3ds;
    DWORD dwCRC;

    gpd3dDev->GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pd3ds);
    dwCRC = ComputeSurfaceCRC32(pd3ds);
    pd3ds->Release();

#ifdef GENERATE_CHECKSUMS
    DWORD dwWritten;
    WriteFile(hChecksumFile, &dwCRC, sizeof(DWORD), &dwWritten, NULL);
#else
    if (uNumScreenChecksums < uNumRefChecksums) {
        if (dwCRC != *pdwChecksums) {
            char szOut[512];
            wsprintf(szOut, "ERROR: Screen checksum mismatch on frame %d - "
                     "Actual: [0x%08X]; "
                     "Expected: [0x%08X]\r\n", 
                     uNumScreenChecksums, dwCRC, 
                     *pdwChecksums);
            OutputDebugString(szOut);
#ifdef XMTA_TEST
            if (pgtr->hr == D3D_OK) {
                pgtr->hr = E_FAIL;
                pgtr->uFrame = uNumScreenChecksums;
                pgtr->dwCRCResult[0] = dwCRC;
                pgtr->dwCRCExpected[0] = *pdwChecksums;
                pgtr->bHardwareChecksum = false;
            }
#else
            OutputDebugString(TEXT("BOOTSCREEN: Screen checksum mismatch\r\n"));
            __asm int 3;
#endif
        }
        ++pdwChecksums;
    }
    else {
        char szOut[512];
        wsprintf(szOut, "WARNING: Frame %d cannot be verified\r\n", uNumScreenChecksums);
        OutputDebugString(szOut);
    }
#endif
    uNumScreenChecksums++;
}

#endif

///////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
#include <d3d8perf.h>
#endif
extern "C" BOOL D3D__NullHardware;
///////////////////////////////////////////////////////////////////////////////


int XBoxStartupApp::run()
{
#ifdef _DEBUG
//D3DPERF_SetShowFrameRateInterval(10000);
#endif
#ifdef NULL_THE_HARDWARE
	D3D__NullHardware = TRUE;			// Set to true to test CPU framerate, no graphics operation will stall.
#endif

#ifdef BOOTSOUND
    //
    // start the boot sound
    //
    if (!g_bShortVersion)
    {
        BootSound_Start();
    }
#endif // BOOTSOUND

	for(;fTimeElapsed < DEMO_TOTAL_TIME;)
	{
		process();
	}

#ifdef BOOTSOUND
    if (!g_bShortVersion)
    {
        BootSound_Stop();
    }
#endif // BOOTSOUND

	return 0;
}
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::process()
{
#ifdef INCLUDE_INPUT
	processInput();
#endif // INCLUDE_INPUT

#ifndef STARTUPANIMATION
	DWORD time = GetTickCount();
#else // STARTUPANIMATION
	DWORD time = NtGetTickCount();
#endif // STARTUPANIMATION


//	float fseconds_elapsed = ((float)(abs(dwLastTick - time))) * 0.001f;
    float fseconds_elapsed = 0.0333333f;//0.016667f;
	const float f_app_time_muls[NUM_APP_SPEEDS] = {1.f,0.5f,0.f};
	float last_jogdt = fJogDeltaTime;
	fJogDeltaTime = 0.0f;
	advanceTime(fseconds_elapsed * f_app_time_muls[appSpeedId] + last_jogdt, fseconds_elapsed);	

	drawFrame();


#ifndef FINAL_BUILD
	numFrames++;
	fSlowestFrame = max(fSlowestFrame, fseconds_elapsed);
	fFastestFrame = min(fFastestFrame, fseconds_elapsed);
	if (fseconds_elapsed > 1.0f / 30.0f) numFramesTooSlow++;

	if (FRAMECOUNT_PERIOD && (time > dwLastFramecountTick + FRAMECOUNT_PERIOD))
	{
		// Trace out the fps count.
		float fps = 1000.0f * ((float)numFrames) / ((float)(time-dwLastFramecountTick));

		char buf[512];
		sprintf(buf, "%6.2f fps, over %6.3fs [%6.3fs <-> %6.3fs], %3d of %3d frames were too slow.\n",
			fps, ((float)(time-dwLastFramecountTick))/1000.0f,
			fFastestFrame, fSlowestFrame, numFramesTooSlow, numFrames);
		OutputDebugString(buf);

		dwLastFramecountTick = time;
		numFrames = 0;
		numFramesTooSlow = 0;
		fSlowestFrame = 0.0f;
		fFastestFrame = 100.0f;
	}
#endif // FINAL_BUILD


	dwLastTick = time;
}

#ifndef BINARY_RESOURCE
///////////////////////////////////////////////////////////////////////////////
DWORD XBoxStartupApp::loadVertexShader(const TCHAR *pname,const DWORD *pdwDecl)
{
    HANDLE hFile = CreateFile( pname, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );

    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = (BYTE*)MemAlloc(sizeof(BYTE)*(dwSize+4));
    ZeroMemory( pData, dwSize+4 );

    DWORD dwBytesRead;
    ReadFile(hFile,pData,dwSize,&dwBytesRead,NULL);

	DWORD dwVertexShader;
    gpd3dDev->CreateVertexShader( pdwDecl, (const DWORD*)pData,&dwVertexShader, 0 );

    CloseHandle( hFile );
    MemFree(pData);
	
	return dwVertexShader;
}
///////////////////////////////////////////////////////////////////////////////
DWORD XBoxStartupApp::loadPixelShader(const TCHAR *pName)
{
	HANDLE hFile = CreateFile( pName, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
  
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

	DWORD dwPixelShader;
    gpd3dDev->CreatePixelShader( &(psdf.Psd), &dwPixelShader );

	return dwPixelShader;
}
#else // BINARY_RESOURCE
///////////////////////////////////////////////////////////////////////////////
DWORD XBoxStartupApp::loadVertexShader(const BYTE *pb,const DWORD *pdwDecl)
{
	DWORD dwVertexShader;
    gpd3dDev->CreateVertexShader( pdwDecl, (const DWORD*)pb,&dwVertexShader, 0 );
	return dwVertexShader;
}
///////////////////////////////////////////////////////////////////////////////
DWORD XBoxStartupApp::loadPixelShader(const BYTE *pb)
{
    D3DPIXELSHADERDEF_FILE *ppsdf = (D3DPIXELSHADERDEF_FILE*)pb;
	DWORD dwPixelShader;
    gpd3dDev->CreatePixelShader( &ppsdf->Psd, &dwPixelShader );
	return dwPixelShader;
}
#endif // BINARY_RESOURCE

#ifdef INCLUDE_INPUT
///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::processInput()
{
	XBInput_GetInput( pGamepad );
    ZeroMemory( &defaultGamepad, sizeof(defaultGamepad) );
    for( DWORD i=0; i<4; i++ )
    {
		if( pGamepad[i].hDevice )
        {
			defaultGamepad.sThumbLX += pGamepad[i].sThumbLX;
            defaultGamepad.sThumbLY += pGamepad[i].sThumbLY;
            defaultGamepad.sThumbRX += pGamepad[i].sThumbRX;
            defaultGamepad.sThumbRY += pGamepad[i].sThumbRY;
            defaultGamepad.fX1      += pGamepad[i].fX1;
            defaultGamepad.fY1      += pGamepad[i].fY1;
            defaultGamepad.fX2      += pGamepad[i].fX2;
            defaultGamepad.fY2      += pGamepad[i].fY2;
            defaultGamepad.wButtons        |= pGamepad[i].wButtons;
            defaultGamepad.wPressedButtons |= pGamepad[i].wPressedButtons;
            defaultGamepad.wLastButtons    |= pGamepad[i].wLastButtons;

            for( DWORD b=0; b<8; b++ )
            {
				defaultGamepad.bAnalogButtons[b]        |= pGamepad[i].bAnalogButtons[b];
                defaultGamepad.bPressedAnalogButtons[b] |= pGamepad[i].bPressedAnalogButtons[b];
                defaultGamepad.bLastAnalogButtons[b]    |= pGamepad[i].bLastAnalogButtons[b];
            }
        }
	}
}
#endif // INCLUDE_INPUT

///////////////////////////////////////////////////////////////////////////////
void XBoxStartupApp::initIntensityPulses()
{
//MTS	char buf[512];
//MTS	sprintf(buf, "Intesity pulses:\n");
//MTS	OutputDebugString(buf);
	for (int i=0; i<NUM_PULSES; i++)
	{
		// x=center time, y=time radius of effect, z=intensity
		vPulses[i].x = ((float)(i+1))/((float)(NUM_PULSES+1)) + fRand11() * 0.03f;
		vPulses[i].x = 1.0f - (0.5f*Square(vPulses[i].x) + 0.5f*vPulses[i].x);

		float temp = Square(1.2f - vPulses[i].x) * (gApp.fRand01() + 2.0f) * 0.05f;
        vPulses[i].y = max(0.1f, temp);
		vPulses[i].z = (vPulses[i].x + 0.5f) * (gApp.fRand01() + 1.0f) * 0.2f;

		vPulses[i].x = vPulses[i].x * BLOB_PULSE_ELAPSED + BLOB_PULSE_START;
		vPulses[i].x = max(vPulses[i].x, BLOB_PULSE_START + vPulses[i].y);
//MTS		sprintf(buf, "    %f, %f, %f\n", vPulses[i].x, vPulses[i].y, vPulses[i].z);
//MTS		OutputDebugString(buf);
	}
	vPulses[NUM_PULSES-1].x = BLOB_PULSE_START + vPulses[NUM_PULSES-1].y;
	vPulses[NUM_PULSES-1].z *= 3.0f;
//MTS	vPulses[NUM_PULSES-1].x = -10.0f;
}
///////////////////////////////////////////////////////////////////////////////
float XBoxStartupApp::sumIntensityPulses(float et)
{
	float sum = 0.0f;
	for (int i=0; i<NUM_PULSES; i++)
	{
		// x=center time, y=time radius of effect, z=intensity
		float fdt = fast_fabs(et-vPulses[i].x);
		if (fdt > vPulses[i].y) continue;

		float s,c;
		SinCos(fdt * 0.5f * Pi / vPulses[i].y,&s,&c);
		sum += vPulses[i].z * c;
	}
//MTS	char buf[512];
//MTS	sprintf(buf, "Elapsed time = %f, pulse sum = %f, total sum = %f\n", et, sum, sum + fBaseBlobIntensity);
//MTS	OutputDebugString(buf);
	return sum;
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\tm_pixels.h ===
///////////////////////////////////////////////////////////////////////////////
//
// tm.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __tm_h__
#define __tm_h__

DWORD tm_pixels[256] =
{
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0xff152305,0xff1e3207,0xff1e3207,0xff1e3207,0xff1e3207,0xff1e3207,0x0,0xff152305,0xff1e3207,0x0,0x0,0x0,0xff0e1703,0xff1e3207,0xff070c02,0x0,
	0xff518814,0xff6fbb1b,0xff6fbb1b,0xff6fbb1b,0xff6fbb1b,0xff6fbb1b,0x0,0xff6fbb1b,0xff6fbb1b,0xff152305,0x0,0x0,0xff4a7d12,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff6fbb1b,0xff3c640f,0x0,0xff070c02,0xff6fbb1b,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff5a9716,0xff61a318,0x0,0xff2c4a0b,0xff5a9716,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff68af19,0xff0e1703,0xff437010,0xff33560c,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff437010,0xff33560c,0xff68af19,0xff152305,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff2c4a0b,0xff6fbb1b,0xff61a318,0x0,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff070c02,0xff6fbb1b,0xff3c640f,0x0,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff0e1703,0xff152305,0x0,0x0,0x0,0xff152305,0xff0e1703,0x0,0xff152305,0xff070c02,0x0,0xff1e3207,0xff070c02,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};

#endif // ___h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\VBlob.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: VBlob.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "VBlob.h"
#include "tex_gen.h"
///////////////////////////////////////////////////////////////////////////////
const float MIN_SPAWN_MAGN =		(0.5f);
#define BLOBLET_DIM			(8)
#define BLOB_DIM			(32)
///////////////////////////////////////////////////////////////////////////////
QRand VBlob::m_QRand;
VBlob* gpVBlob;
///////////////////////////////////////////////////////////////////////////////
void VBlob::Init()
{
    int i;

    for (i = 0; i < MAX_BLOBBUMPS; i++)
    {
        m_BlobBumps[i].Init();
    }

    for (i = 0; i < MAX_BLOBLETS; i++)
    {
        m_Bloblets[i].Init();
    }

    m_QRand.Init();

	m_pBlobletVB = m_pBlobVBConst = m_pBlobVBChangingR = m_pBlobVBChangingU = NULL;
	m_pBlobletIB = m_pBlobIB = NULL;
	m_pUnitSphereNormals = NULL;
    m_dwNumBlobletVertices = m_dwNumBlobletIndices = m_NumVertsPerFace = m_dwNumVertices = m_dwNumIndices = 0;
    m_dwVShaderBlob = m_dwVShaderBloblet = 0;
    m_dwPShaderBlob = m_dwPShaderBloblet = 0;
	m_NumBlobBumps = m_NumBloblets = 0;
	Set(&m_BlobColor, 0.25f, 1.0f, 0.15f, 1.0f);
	Set(&m_Pos, 0.0f, 0.0f, 0.0f);
	Set(&m_Scale, 1.0f, 1.0f, 1.0f);
	m_fRadius = 2.3f;
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::create()
{
	gpVBlob = this;

	gpd3dDev->CreateVertexBuffer(4 * sizeof(float)*5, 0, 0, 0, &pHaloQuadVB);


//MTS	generateUnitSphere(2, &m_pBlobletVB, &m_pBlobletIB, NULL, &m_dwNumBlobletVertices, &m_dwNumBlobletIndices);
	generateUnitSphere(BLOBLET_DIM, &m_pBlobletVB, &m_pBlobletIB, NULL, &m_dwNumBlobletVertices, &m_dwNumBlobletIndices);

	generateUnitSphere(BLOB_DIM, &m_pBlobVBConst, &m_pBlobIB, &m_pUnitSphereNormals, &m_dwNumVertices, &m_dwNumIndices);
	gpd3dDev->CreateVertexBuffer(m_dwNumVertices * sizeof(VBlobChangingVertex), 0, 0, 0, &m_pBlobVBChangingR);
	gpd3dDev->CreateVertexBuffer(m_dwNumVertices * sizeof(VBlobChangingVertex), 0, 0, 0, &m_pBlobVBChangingU);
	m_NumVertsPerFace = m_dwNumVertices / 6;

	restart();

	// Initialize the pixel shaders.
    if( m_dwPShaderBlob )
    {
        gpd3dDev->DeletePixelShader( m_dwPShaderBlob );
        m_dwPShaderBlob = 0;
    }
#ifndef BINARY_RESOURCE
	m_dwPShaderBlob = gApp.loadPixelShader("D:\\Shaders\\VBlob.xpu");
#else // BINARY_RESOURCE
	m_dwPShaderBlob = gApp.loadPixelShader(g_vblob_xpu);
#endif // BINARY_RESOURCE

    if( m_dwPShaderBloblet )
    {
        gpd3dDev->DeletePixelShader( m_dwPShaderBloblet );
        m_dwPShaderBloblet = 0;
    }
#ifndef BINARY_RESOURCE
	m_dwPShaderBloblet = gApp.loadPixelShader("D:\\Shaders\\VBloblet.xpu");
#else // BINARY_RESOURCE
	m_dwPShaderBloblet = gApp.loadPixelShader(g_vbloblet_xpu);
#endif // BINARY_RESOURCE

	// Initialize the vertex shaders.
    DWORD dwBlobShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // unit sphere normal
        D3DVSD_STREAM( 1 ),
        D3DVSD_REG( 1, D3DVSDT_FLOAT4 ),    // vertex normal, w is displacement
        D3DVSD_END()
    };
	if (m_dwVShaderBlob)
	{
		gpd3dDev->DeleteVertexShader( m_dwVShaderBlob );
		m_dwVShaderBlob = 0;
	}
#ifndef BINARY_RESOURCE
	m_dwVShaderBlob    = gApp.loadVertexShader("D:\\Shaders\\VBlob.xvu",    dwBlobShaderVertexDecl);
#else // BINARY_RESOURCE
	m_dwVShaderBlob    = gApp.loadVertexShader(g_vblob_xvu,    dwBlobShaderVertexDecl);
#endif // BINARY_RESOURCE

    DWORD dwBlobletShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // unit sphere normal
        D3DVSD_END()
    };
	if (m_dwVShaderBloblet)
	{
		gpd3dDev->DeleteVertexShader( m_dwVShaderBloblet );
		m_dwVShaderBloblet = 0;
	}
#ifndef BINARY_RESOURCE
	m_dwVShaderBloblet = gApp.loadVertexShader("D:\\Shaders\\VBloblet.xvu", dwBlobletShaderVertexDecl);
#else // BINARY_RESOURCE
	m_dwVShaderBloblet = gApp.loadVertexShader(g_vbloblet_xvu, dwBlobletShaderVertexDecl);
#endif // BINARY_RESOURCE
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::destroy()
{
	m_pBlobletVB->Release();
	m_pBlobletIB->Release();
	m_pBlobVBConst->Release();
	m_pBlobVBChangingR->Release();
	m_pBlobVBChangingU->Release();
	m_pBlobIB->Release();
	MemFree(m_pUnitSphereNormals);

	pHaloQuadVB->Release();

    if (m_dwPShaderBlob) gpd3dDev->DeletePixelShader(m_dwPShaderBlob);
    if (m_dwPShaderBloblet) gpd3dDev->DeletePixelShader(m_dwPShaderBloblet);
	if (m_dwVShaderBlob) gpd3dDev->DeleteVertexShader(m_dwVShaderBlob);
	if (m_dwVShaderBloblet)	gpd3dDev->DeleteVertexShader(m_dwVShaderBloblet);

	m_pBlobletVB = NULL;
	m_pBlobletIB = NULL;
	m_pBlobVBConst = NULL;
	m_pBlobVBChangingU = m_pBlobVBChangingR = NULL;
	m_pBlobIB = NULL;
	m_pUnitSphereNormals = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::render()
{
    // Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,  TRUE );

    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

    gpd3dDev->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );

		// Render halo after blob, but before bloblets.
	gpd3dDev->SetVertexShader(D3DFVF_XYZ|D3DFVF_TEX1);
	gpd3dDev->SetPixelShader(NULL);

	D3DMATRIX id_mat;
	SetIdentity(&id_mat);
	gpd3dDev->SetTransform(D3DTS_WORLD,&id_mat);
	gpd3dDev->SetTransform(D3DTS_VIEW,&gApp.theCamera.matWTC);
	gpd3dDev->SetTransform(D3DTS_PROJECTION,&gApp.theCamera.matProj);

	gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_MODULATE);
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TFACTOR);
	gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_SELECTARG1);
	gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TFACTOR);
	gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);

	float cur_rad = m_fRadius * (1.0f + 1.3f * fast_sqrt(gApp.getPulseIntensity()));

	DWORD dw_alpha;
	float f_alpha = min(gApp.getBlobIntensity(),1.f) * 255.f;
	
	__asm
    {
        cvttss2si eax, f_alpha
        shl eax,24
		mov dw_alpha,eax
    };

	DWORD dw_tf = 0x00a0ff40 | dw_alpha;
	
	gpd3dDev->SetRenderState( D3DRS_TEXTUREFACTOR,dw_tf);
	gpd3dDev->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ONE );
	gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

	gpd3dDev->SetTexture(0,gApp.pGlowMap);
	
	struct _decalvert
	{
		D3DVECTOR p;
		float u,v;
	};

	_decalvert * phalo_verts = NULL;
	pHaloQuadVB->Lock(0,sizeof(_decalvert) * 4, (BYTE **)&phalo_verts,NULL);

	float f_rad = cur_rad * 5.2f;

	D3DMATRIX & ctw = gApp.theCamera.matCTW;
	Sub(*(D3DVECTOR *)&ctw._21,*(D3DVECTOR *)&ctw._11,&phalo_verts[0].p);
	Scale(&phalo_verts[0].p,f_rad);
	phalo_verts[0].u = 0.f;
	phalo_verts[0].v = 1.f;

	Add(*(D3DVECTOR *)&ctw._21,*(D3DVECTOR *)&ctw._11,&phalo_verts[1].p);
	Scale(&phalo_verts[1].p,f_rad);
	phalo_verts[1].u = 1.f;
	phalo_verts[1].v = 1.f;

	Sub(*(D3DVECTOR *)&ctw._11,*(D3DVECTOR *)&ctw._21,&phalo_verts[2].p);
	Scale(&phalo_verts[2].p,f_rad);
	phalo_verts[2].u = 1.f;
	phalo_verts[2].v = 0.f;

	Set(&phalo_verts[3].p,-ctw._11-ctw._21,-ctw._12-ctw._22,-ctw._13-ctw._23);
	Scale(&phalo_verts[3].p,f_rad);
	phalo_verts[3].u = 0.f;
	phalo_verts[3].v = 0.f;

	pHaloQuadVB->Unlock();
	
	gpd3dDev->SetStreamSource( 0, pHaloQuadVB, sizeof(_decalvert));
	gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN,0,2);

	// Restore state
	gpd3dDev->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

//MTS    gpd3dDev->SetRenderState( D3DRS_FILLMODE,         D3DFILL_WIREFRAME );

    gpd3dDev->SetTexture( 0, gApp.pNormalCubeMapLoRes );
    gpd3dDev->SetTexture( 1, gApp.pNormalCubeMapLoRes );


    gpd3dDev->SetVertexShader( m_dwVShaderBlob );
    gpd3dDev->SetPixelShader(  m_dwPShaderBlob );



    // Note: when passing matrices to a vertex shader, we transpose them, since
    // matrix multiplies are done with dot product operations on the matrix rows.
	D3DMATRIX matFinal,matTmp;
	MulMats(gApp.theCamera.matWTC,gApp.theCamera.matProj,&matTmp);
	SetTranspose(matTmp,&matFinal);
	gpd3dDev->SetVertexShaderConstant(4,(CONST void *)&matFinal,4);




	//; Expected vertex shaders constants
	//;    c0-c3    = Transpose of world matrix
	//;    c4-c7    = Transpose of view*projection matrix
	//;    c8       = some constants, x=0, y=1, z=2, w=0.5
	//;    c9       = eye location
	//;    c10      = blob scaling
	//;    c11      = 1/ blob scaling
	//;    c12      = blob center
	D3DVECTOR4 val[5];


	// Constants
	Set(&val[0], 0.0f, 1.0f, 2.0f, 0.5f);

	// Eye position
	gApp.theCamera.getCameraPos(&val[1]);

	// Scaling
	Set(&val[2], cur_rad*m_Scale.x, cur_rad*m_Scale.y, cur_rad*m_Scale.z, 1.0f);


	// 1 / blob scaling
	val[3].x = 1.0f / val[2].x;
	val[3].y = 1.0f / val[2].y;
	val[3].z = 1.0f / val[2].z;
	
	// Blob center.
//MTS	float f_jitter_mag = (gApp.getElapsedTime() - BLOB_JITTER_START) * OO_BLOB_JITTER_DELTA;
//MTS	f_jitter_mag *= f_jitter_mag;
//MTS	float cOffsets[3] = { 0.2f, 0.7f, 4.2f };
//MTS	float cScales[3]  = { 20.0f, 28.0f, 44.0f };
	D3DVECTOR4 cur_pos;
//MTS	cur_pos.x = m_Pos.x + f_jitter_mag * sinf((gApp.getElapsedTime() - cOffsets[0])*cScales[0]);
//MTS	cur_pos.y = m_Pos.y + f_jitter_mag * sinf((gApp.getElapsedTime() - cOffsets[1])*cScales[1]);
//MTS	cur_pos.z = m_Pos.z + f_jitter_mag * sinf((gApp.getElapsedTime() - cOffsets[2])*cScales[2]);
	cur_pos.x = m_Pos.x;
	cur_pos.y = m_Pos.y;
	cur_pos.z = m_Pos.z;
	cur_pos.w = 0.0f;
	Set(&val[4], cur_pos.x, cur_pos.y, cur_pos.z, 0.0f);


	gpd3dDev->SetVertexShaderConstant( 8, &val, 5 );


	// Make the object to World transform. Transpose it.
    D3DMATRIX matT, mat;

	SetIdentity( &mat );
	mat.m[0][0] = m_Scale.x * cur_rad;
	mat.m[1][1] = m_Scale.y * cur_rad;
	mat.m[2][2] = m_Scale.z * cur_rad;
	mat.m[3][0] = cur_pos.x;
	mat.m[3][1] = cur_pos.y;
	mat.m[3][2] = cur_pos.z;

	SetTranspose( mat, &matT );
    gpd3dDev->SetVertexShaderConstant( 0, &matT, 4 );


	// Expected pixel shader constants
	//; c0          = base blob color
	//; c1          = ambient color

	// Blob color
	val[0] = m_BlobColor;
	float f_color_intensity = BLOB_BASE_INTENSITY + 4.0f * (1.2f * gApp.getBaseBlobIntensity() + 0.8f * gApp.getPulseIntensity() );
//MTS	f_color_intensity *= min(1.0f, gApp.getElapsedTime() * OO_BLOB_STATIC_END_TIME);
	f_color_intensity *= min(1.0f, gApp.getElapsedTime() * 4.0f);
	Scale(&val[0], f_color_intensity);

	// Ambient light
	val[1] = m_BlobColor;
	Scale(&val[1], 0.0f);


	gpd3dDev->SetPixelShaderConstant( 0, &val[0], 2 );



	gpd3dDev->SetIndices( m_pBlobIB, 0 );
    gpd3dDev->SetStreamSource( 0, m_pBlobVBConst,    sizeof(VBlobConstantVertex) );

	// Get the Update vertex buffer and use it to render.
	swapChangingVertices();
    gpd3dDev->SetStreamSource( 1, m_pBlobVBChangingR, sizeof(VBlobChangingVertex) );

    gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumVertices,  0, m_dwNumIndices-2 );




	// Render the bloblets.

    gpd3dDev->SetVertexShader( m_dwVShaderBloblet );
    gpd3dDev->SetPixelShader(  m_dwPShaderBloblet );

	gpd3dDev->SetVertexShaderConstant(4,(CONST void *)&matFinal,4);

	// Constants
	Set(&val[0], 0.0f, 1.0f, 2.0f, 0.5f);

	// Eye position
	gApp.theCamera.getCameraPos(&val[1]);

	gpd3dDev->SetVertexShaderConstant( 8, &val, 2 );


	// Bloblet color
	val[0] = m_BlobColor;
	Scale(&val[0], 0.3f * gApp.getBlobIntensity());

	// Ambient light
	val[1] = m_BlobColor;
	Scale(&val[1], 0.2f);


	Set(&val[2], 2.0f, 2.0f, 2.0f, 2.0f);
	// 1/val is the level of brightness that is full alpha

	gpd3dDev->SetPixelShaderConstant( 0, &val, 3 );



	gpd3dDev->SetIndices( m_pBlobletIB, 0 );
    gpd3dDev->SetStreamSource( 0, m_pBlobletVB,    sizeof(VBlobConstantVertex) );


	for (int i=0; i<m_NumBloblets; i++)
	{
		//;    c9       = eye location
		//;    c10      = blob center
		//;    c11      = direction of scaling
		//;    c12      = scaling perpendicular to direction
		//;    c13      = parallel minus perpendicular scaling multiplied by scaling direction

		VBloblet* p_bloblet = &m_Bloblets[i];

		// Bloblet center.
		Set(&val[0], p_bloblet->vPosition.x, p_bloblet->vPosition.y, p_bloblet->vPosition.z, 0.0f);

		// Direction of scaling.
		Set(&val[1], p_bloblet->vDirection.x, p_bloblet->vDirection.y, p_bloblet->vDirection.z, 1.0f);

		// Scaling perpendicular to direction
		float fval = p_bloblet->fRadius / fast_sqrt(p_bloblet->fWobble);
		Set(&val[2], fval, fval, fval, 1.0f);

		// Parallel minus perpendicular scaling multiplied by scaling direction
		fval = p_bloblet->fRadius * p_bloblet->fWobble - fval;
		Set(&val[3], fval*p_bloblet->vDirection.x, fval*p_bloblet->vDirection.y, fval*p_bloblet->vDirection.z, 1.0f);

		
		gpd3dDev->SetVertexShaderConstant( 10, &val, 4 );


		gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumBlobletVertices,  0, m_dwNumBlobletIndices-2 );
	}

    // Restore the state
    gpd3dDev->SetPixelShader(  NULL );
    gpd3dDev->SetVertexShader( NULL );

	gpd3dDev->SetTexture(0, NULL);
	gpd3dDev->SetTexture(1, NULL);

	gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::zeroChangingVertices()
{
	VBlobChangingVertex* p_verts;
	const D3DVECTOR* p_us_normals = m_pUnitSphereNormals;
	m_pBlobVBChangingU->Lock(0, 0, (BYTE**)&p_verts, 0);	// D3DLOCK_DISCARD not on XBox!

	for (int face=0; face<6; face++)
	{
		for (int i=0; i<m_NumVertsPerFace; i++, p_verts++, p_us_normals++)
		{
			p_verts->normal.x = p_us_normals->x;
			p_verts->normal.y = p_us_normals->y;
			p_verts->normal.z = p_us_normals->z;
			p_verts->normal.w = 1.0f;
		}
	}

	m_pBlobVBChangingU->Unlock();
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::prepareChangingVertices()
{
	VBlobChangingVertex* p_verts;
	const D3DVECTOR* p_us_normals = m_pUnitSphereNormals;
	m_pBlobVBChangingU->Lock(0, 0, (BYTE**)&p_verts, 0);	// D3DLOCK_DISCARD not on XBox!


/*
	// For spiky blobs mark 2.
	const float cA = 1.0f;
	const float cB = 0.1f;
	const float cD = 1.0f / ( (1.0f/cB) - (1.0f / (cA+cB)) );
	const float cE = cA / cD;
	const float cF = cB / cD;
	const float cG = - cD / (cA+cB);

	float sd_frac = max(1.0f, gApp.getElapsedTime() / 6.0f);
	float bd_frac = 1.0f - sd_frac;
*/


	for (int face=0; face<6; face++)
	{
		const VBlobBump* vp_blobs_of_interest[MAX_BLOBBUMPS];
		int i;
		int num_boi = 0;
		for (i=0; i<m_NumBlobBumps; i++)
		{
			if (m_BlobBumps[i].facesOfInterest & (1<<face))
			{
				vp_blobs_of_interest[num_boi++] = &m_BlobBumps[i];
			}
		}

		for (int i=0; i<m_NumVertsPerFace; i++, p_verts++)
		{
			const D3DVECTOR& us_normal = *(p_us_normals++);
			D3DVECTOR4& accum_normal = p_verts->normal;
//MTS			D3DVECTOR4 accum_normal;
			Set(&accum_normal, us_normal.x, us_normal.y, us_normal.z, 0.0f);
			for (int j=num_boi-1; j>=0; j--)
			{
				const VBlobBump* p_blob = vp_blobs_of_interest[j];
				D3DVECTOR delta;
				Sub(us_normal, p_blob->vPosition, &delta);
//MTS				float dist2 = Length2(delta);
				float dist2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;
//MTS				float dist2 = Distance2(us_normal, p_blob->vPosition);
				if (dist2 < p_blob->fRadius2)
				{
//MTS					if ((p_blob->facesOfInterest & (1<<face)) == 0)
//MTS					{
//MTS						int a = 0;
//MTS					}

					float dist2_mo = dist2 * p_blob->fOORadius2 - 1.0f;


					float displacement = m_fRadius*p_blob->fMagnitude * dist2_mo*dist2_mo;
/*
					// Spiky blob bumps mark 2.
					float bumpy_displacement = m_fRadius*p_blob->fMagnitude * dist2_mo*dist2_mo;
					float spiky_displacement = m_fRadius * p_blob->fMagnitude * ( 1.0f / (cE*dist2*p_blob->fOORadius2 + cF) + cG );
					spiky_displacement *= 1.3f;

					float displacement = bd_frac*bumpy_displacement + sd_frac*spiky_displacement;
*/

					float perturb_amount = -4.0f * p_blob->fMagnitude * p_blob->fOORadius2 * dist2_mo;


					// lnorm = us_normal + perturb_amount*(us_normal - p_blob->vPosition)
					// This should make it faster, but VTune suggests it doesn't. Maybe in Release...
//MTS					D3DVECTOR lnorm;
//MTS					float oppa = 1.0f + perturb_amount;
//MTS					lnorm.x = us_normal.x * oppa - perturb_amount * p_blob->vPosition.x;
//MTS					lnorm.y = us_normal.y * oppa - perturb_amount * p_blob->vPosition.y;
//MTS					lnorm.z = us_normal.z * oppa - perturb_amount * p_blob->vPosition.z;

					D3DVECTOR lnorm = us_normal;
//MTS					Set(&lnorm, 0.0f, 0.0f, 0.0f);

//MTS					D3DVECTOR delta;
//MTS					Sub(us_normal, p_blob->vPosition, &delta);
					AddScaled(&lnorm, delta, perturb_amount);
					QuickNormalize(&lnorm);

					accum_normal.x += lnorm.x;
					accum_normal.y += lnorm.y;
					accum_normal.z += lnorm.z;
					accum_normal.w += displacement;
				}
			}
			p_verts->normal = accum_normal;
		}
	}

	m_pBlobVBChangingU->Unlock();
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::advanceTime(float fElapsedTime, float fDt)
{
	if (fElapsedTime < BLOB_STATIC_END_TIME)
	{
		if (fElapsedTime - fDt > BLOB_STATIC_END_TIME)
		{
			zeroChangingVertices();
			swapChangingVertices();
			zeroChangingVertices();
		}
		return;
	}

	for (int i=0; i<m_NumBloblets; i++)
	{
		if (!m_Bloblets[i].update(fElapsedTime, fDt))
		{
//MTS			m_Bloblets[i] = m_Bloblets[--m_NumBloblets];
//MTS			i--;
			// better notify the bump that owned it...
		}
	}

	for (int i=0; i<m_NumBlobBumps; i++)
	{
		if (m_BlobBumps[i].update(
				fElapsedTime,
				fDt,
				(m_NumBloblets<MAX_BLOBLETS) ? &m_Bloblets[m_NumBloblets] : NULL)
				)
		{
			m_NumBloblets++;
		}
	}

//MTS	m_pBlobVBChangingU->BlockUntilNotBusy();	// this causes it to block here, rather than in prepareChangingVertices
	prepareChangingVertices();
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::restart()
{
	m_NumBloblets = 0;
	m_NumBlobBumps = 0;

	while (m_NumBlobBumps<MAX_BLOBBUMPS)
	{
		if (m_BlobBumps[m_NumBlobBumps++].create(
			-0.3f,
			(m_NumBloblets < MAX_BLOBLETS) ? &m_Bloblets[m_NumBloblets] : NULL
			))	// pass negative time so the blobs get a head start
		{
			m_NumBloblets++;
		}
	}

	zeroChangingVertices();
	swapChangingVertices();
	zeroChangingVertices();
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::getLightForPosition(D3DVECTOR* p_light_pos, float* p_intensity, D3DVECTOR position)
{
	float total_weights = 0.0f;
	D3DVECTOR av_pos;
	float av_intensity = 0.0f;
	Set(&av_pos, 0.0f, 0.0f, 0.0f);

	float light_intensity = gApp.getBlobIntensity();

	{
		float dist2 = Distance2(position, m_Pos);
		float dist4 = dist2 * dist2;
		float weight = 1.0f / dist2;

		av_intensity += 4.0f * light_intensity * weight;
		AddScaled(&av_pos, m_Pos, weight);
		total_weights += weight;
	}

	for (int i=0; i<m_NumBloblets; i++)
	{
		float dist2 = Distance2(position, m_Bloblets[i].vPosition);
		float dist4 = dist2 * dist2;
		float weight = 1.0f / dist2;

		av_intensity += light_intensity * weight;
		AddScaled(&av_pos, m_Bloblets[i].vPosition, weight);
		total_weights += weight;
	}

	float oo_total_weights = 1.0f / total_weights;
	Set(p_light_pos, oo_total_weights * av_pos.x, oo_total_weights * av_pos.y, oo_total_weights * av_pos.z);
	*p_intensity = oo_total_weights * av_intensity;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool VBlob::generateUnitSphere(	int resolution,
								LPDIRECT3DVERTEXBUFFER8* pp_vb,
								LPDIRECT3DINDEXBUFFER8* pp_ib,
								D3DVECTOR** pp_us,
								DWORD* num_verts, DWORD* num_indices)
{
	int subdiv = max(1, resolution / 2);
	float f_division_step = 2.0f / ((float)subdiv);

	*num_verts = 6*(subdiv+1)*(subdiv+1);
	*num_indices = 6*GetNumberOfIndicesForTristripMesh(subdiv,subdiv) + 2*5;	// 5 double-taps


	gpd3dDev->CreateVertexBuffer( *num_verts * sizeof(VBlobConstantVertex), 0, 0, 0, pp_vb);
	gpd3dDev->CreateIndexBuffer(  *num_indices * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, pp_ib);
	if (pp_us) *pp_us = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(*num_verts));


	VBlobConstantVertex* p_verts;
	WORD* p_indices;

	(*pp_vb)->Lock(0, 0, (BYTE**)&p_verts, 0);
	(*pp_ib)->Lock(0, 0, (BYTE**)&p_indices, 0);
	D3DVECTOR* p_us = ((pp_us) ? *pp_us : NULL);



	// Create vertices.
	VBlobConstantVertex* p_vert = &p_verts[0];
	for (int k=0; k<6; k++)
	{
		for (int j=0; j<=subdiv; j++)
		{
			for (int i=0; i<=subdiv; i++)
			{
				D3DVECTOR& pos = p_vert->unit_sphere_normal;

				float fu = ((i==subdiv) ? +1.0f : (-1.0f + f_division_step * ((float)i)));
				float fv = ((j==subdiv) ? +1.0f : (-1.0f + f_division_step * ((float)j)));
				switch(k)
				{
					case 0: Set(&pos, -1.0f, -fu, +fv); break;
					case 1: Set(&pos, +fv, -1.0f, -fu); break;
					case 2: Set(&pos, -fu, +fv, -1.0f); break;
					case 3: Set(&pos, +1.0f, +fu, +fv); break;
					case 4: Set(&pos, +fv, +1.0f, +fu); break;
					case 5: Set(&pos, +fu, +fv, +1.0f); break;
				}

				Normalize(&pos);
				if (p_us)
				{
					*p_us = pos;
					p_us++;
				}
				p_vert++;
			}
		}
	}


	// Create indices.
	int j = 0;
	for (int i=0; i<6; i++)
	{
		j += CreateTristripForMesh(&p_indices[j], subdiv, subdiv, (i>0), (i<5), i*(subdiv+1)*(subdiv+1));
	}

	(*pp_ib)->Unlock();
	(*pp_vb)->Unlock();

	return true;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void VBlobBump::Init()
{
	pMyBloblet = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void VBlobBump::UnInit()
{
}
///////////////////////////////////////////////////////////////////////////////
// randomly creates a blob bump
bool VBlobBump::create(float cur_time, VBloblet* p_bloblet)
{
	if (cur_time < 0.0f) pMyBloblet = NULL;

	vDirection.x = VBlob::fRand11();
	vDirection.y = VBlob::fRand11();
	vDirection.z = VBlob::fRand11();


	if (Length2(vDirection) < 0.001f)
	{
		vDirection.x = VBlob::fRand11();
		vDirection.y = VBlob::fRand11();
		vDirection.z = 1.0f;
	}

	Set(&vPosition, 0.0f, 0.0f, 0.0f);

	QuickNormalize(&vDirection);

	float time_prog = max(0.0f, (cur_time-BLOB_STATIC_END_TIME) * OO_MAX_INTENSITY_DELTA);
	float rad_mag_rand = VBlob::fRand01();

	fRadius = rad_mag_rand * 0.4f + 0.4f;
	fRadius2 = fRadius*fRadius;
	fOORadius2 = 1.0f / fRadius2;
	fMagnitude = 0.0f;

	recalculateFacesOfInterest();


	fStartTime = cur_time + 0.4f * VBlob::fRand01();

	fMaxMagnitude = (1.0f - rad_mag_rand) * 0.5f + 0.2f;
	fMaxMagnitude *= 0.5f + 0.5f * time_prog;

	if (!pMyBloblet) pMyBloblet = p_bloblet;
	if (pMyBloblet)
	{
		// Paired with a bloblet.
		float f_main_rad = gpVBlob->getRadius();
		pMyBloblet->fRadius = (VBlob::fRand01()+1.0f) * 0.25f * f_main_rad * fRadius;
		pMyBloblet->vDirection = vDirection;

		pMyBloblet->fMaxDist = f_main_rad * (5.0f + VBlob::fRand11() * 2.0f);
		pMyBloblet->fMaxDist *= 0.6f;

		pMyBloblet->fStartTime = (cur_time<-1.0f) ? -VBlob::fRand01() * 0.3f : cur_time;

		float period = 0.8f + 0.3f * VBlob::fRand01();
		period *= 1.0f / 0.6f;
		pMyBloblet->fTimeMultiple = 2.0f * Pi / period;

		pMyBloblet->fWobble = 1.2f;
		pMyBloblet->fWobbleDirection = 0.0f;

		bStillAttachedToBloblet = (cur_time-fStartTime < 0.4f*period);


		// Set my properties from the bloblet.
		pMyBloblet->update(cur_time, 0.0f);
		update(cur_time, 0.0f, NULL);
	}
	else
	{
		// Not paired with a bloblet.
		float sequence_len = fMaxMagnitude * 0.3f + VBlob::fRand01() * 0.3f;
		fTimeMul = Pi / sequence_len;
		fTimeMul *= time_prog*0.2f + 0.8f;

		if (cur_time < -1.0f) fStartTime = -VBlob::fRand01() * Pi / fTimeMul;
	}

	return (pMyBloblet!=NULL);
}
///////////////////////////////////////////////////////////////////////////////
// returns true if it initialized a new Bloblet
bool VBlobBump::update(float elapsed_time, float dt, VBloblet* p_bloblet)
{
	if (pMyBloblet)
	{
		float f_b_mag = (fast_fabs(pMyBloblet->fCurDist) + pMyBloblet->fRadius) / gpVBlob->getRadius();
		fMagnitude = min( 2.0f, max(0.0f, f_b_mag - 1.0f) );
		if (bStillAttachedToBloblet)
		{
			if (fMagnitude > 0.8f)
			{
				// Lost attachment
				bStillAttachedToBloblet = false;
//MTS				fMaxMagnitude = max(0.0f, fMagnitude - 2.0f * pMyBloblet->fRadius / gpVBlob->getRadius());
				fMaxMagnitude = fMagnitude;
				float sequence_len = 0.3f * fMagnitude;
				fTimeMul = 2.0f * Pi / sequence_len;
				fStartTime = elapsed_time - 0.25f * sequence_len;
				pMyBloblet->fWobble = max(0.6f, min(0.8f, fMagnitude-0.5f));	// more wobble when there is less energy
				pMyBloblet->fWobbleDirection = 0.0f;
			}
			else
			{
				// Still attached.
				if ( (Dot(vDirection, pMyBloblet->vDirection) < 0.0f) != pMyBloblet->bFarSide)
				{
					// Must reverse direction.
					Scale(&vDirection, -1.0f);
					vPosition = vDirection;
					recalculateFacesOfInterest();
				}
				return false;
			}
		}

		// May have just lost attachment.
		if (!bStillAttachedToBloblet)
		{
			if (f_b_mag < 0.9f)
			{
				// Blob is inside sphere, reattach.
				bStillAttachedToBloblet = true;
			}
		}
	}

	float t = (elapsed_time - fStartTime) * fTimeMul;
	if (t>Pi)
	{
		if (pMyBloblet==NULL)
		{
			return create(elapsed_time, p_bloblet);
		}
		fMagnitude = 0.0f;
		return false;
	}
	if (t<0.0f) return false;

	float sin_val = fast_sin(t);
	fMagnitude = fMaxMagnitude * sin_val;
//MTS	vPosition.x = vDirection.x * sin_val;
//MTS	vPosition.y = vDirection.y * sin_val;
//MTS	vPosition.z = vDirection.z * sin_val;
	vPosition = vDirection;
	recalculateFacesOfInterest();

//MTS	if ((bNotYetSpawned) && (t > 0.5f * Pi) && (p_bloblet))
//MTS	{
//MTS		bNotYetSpawned = false;
//MTS
//MTS		float f_main_rad = gpVBlob->getRadius();
//MTS		p_bloblet->fRadius = 0.7f * f_main_rad * fRadius;
//MTS
//MTS		float displ = f_main_rad * (1.0f + fMagnitude) - p_bloblet->fRadius;
//MTS		p_bloblet->vPosition = gpVBlob->getCenter();
//MTS		p_bloblet->vPosition.x += vDirection.x * displ;
//MTS		p_bloblet->vPosition.y += vDirection.y * displ;
//MTS		p_bloblet->vPosition.z += vDirection.z * displ;
//MTS
//MTS
//MTS
//MTS
//MTS
//MTS		float vel = f_main_rad * (fMagnitude-MIN_SPAWN_MAGN) * 100.0f + 20.0f;
//MTS		p_bloblet->vVelocity.x = vDirection.x * vel;
//MTS		p_bloblet->vVelocity.y = vDirection.y * vel;
//MTS		p_bloblet->vVelocity.z = vDirection.z * vel;
//MTS
//MTS		p_bloblet->vAttachedTo = gpVBlob->getCenter();
//MTS
//MTS
//MTS		// Set up a spring as per 2001.05.01 of my notes.
//MTS
//MTS		// Use a spring model for now. Period is 2*Pi/sqrt(k/m), so k/m = (2*Pi/period)^2
//MTS		float sequence_time_mul = 5.0f;
//MTS		p_bloblet->fRestoreForceConstant = 2.0f * Pi / (sequence_time_mul*(elapsed_time - fStartTime));
//MTS		p_bloblet->fRestoreForceConstant *= p_bloblet->fRestoreForceConstant;
//MTS
//MTS		p_bloblet->fEndDist2 = f_main_rad - p_bloblet->fRadius;
//MTS		p_bloblet->fEndDist2 *= p_bloblet->fEndDist2;
//MTS
//MTS		return true;
//MTS	}

	return false;
}
///////////////////////////////////////////////////////////////////////////////
void VBlobBump::recalculateFacesOfInterest()
{
	// Bitfield indicating the faces (0,1,2,4,5) <-> (-x,-y,-z,+x,+y,+z) the blob points most be checked with.
	facesOfInterest =	((vDirection.x - fRadius < -0.57735f) ? 0x0001 : 0) +
						((vDirection.y - fRadius < -0.57735f) ? 0x0002 : 0) +
						((vDirection.z - fRadius < -0.57735f) ? 0x0004 : 0) +
						((vDirection.x + fRadius > +0.57735f) ? 0x0008 : 0) +
						((vDirection.y + fRadius > +0.57735f) ? 0x0010 : 0) +
						((vDirection.z + fRadius > +0.57735f) ? 0x0020 : 0) ;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
const float WOBBLE_ACCEL =		(1000.0f);
// returns false if it should be deleted
bool VBloblet::update(float elapsed_time, float dt)
{
	fWobble = min(2.0f, max(0.5f, fWobble + fWobbleDirection * dt));
	if (fWobbleDirection > 0.0f)
	{
		if ((fWobble < 0.95f) || (fWobble > 1.0f))
		{
			fWobbleDirection -= (fWobble-1.0f) * dt * WOBBLE_ACCEL;
		}
	}
	else
	{
		if ((fWobble < 1.0f) || (fWobble > 1.05f))
		{
			fWobbleDirection -= (fWobble-1.0f) * dt * WOBBLE_ACCEL;
		}
	}



	float time_prog = max(0.0f, (elapsed_time-BLOB_STATIC_END_TIME) * OO_MAX_INTENSITY_DELTA);

	float t = fTimeMultiple * (elapsed_time - fStartTime);
	t *= 1.4f * (1.0f + elapsed_time / 10.0f);	// speed up over time

	float s = fast_sin(t);

	float sm = fast_fabs(s);
	sm = 1.0f - (1.0f-sm)*fast_sqrt(1.0f-sm);
	s = (s>0.0f) ? sm : -sm;

	fCurDist = fMaxDist * s * time_prog;
	bFarSide = (fCurDist<0.0f);

	vPosition = gpVBlob->getCenter();
	AddScaled(&vPosition, vDirection, fCurDist);

	return (fast_fabs(fCurDist) + fRadius < gpVBlob->getRadius() * 0.5f);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\analogcolors.cpp ===
// Analogcolors
//
// Get the analog color linearity data from the HDVMU

#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "..\..\statkeys.h"
#include "xgrafx.h"
#include "hdvmudefs.h"


BOOL CXModuleGrafx::HDTVTestGetAnalogColors()
{
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost = 0;
	int iError;
	HDVMU_SETUP_INFO setup;
	
#ifdef _DEBUG
	static int dacTestCount;
	dacTestCount++;
	ReportDebug(DEBUG_LEVEL1, _T("HDTV DAC Test - Loop %d"), dacTestCount);
#endif
	
	//Init the contents to zero.
	memset(&setup, 0, sizeof(setup));
	
	//Determine which Standard to use.
	if(!wcsicmp(m_HDTVmode, L"480p"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_480 << 3);
	else if(!wcsicmp(m_HDTVmode, L"720p"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_720 << 3);
	else if(!wcsicmp(m_HDTVmode, L"1080i"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_1080 << 3);
	else
	{
		err_BADPARAMETER( m_modeString, L"hdtv_mode" );
		return FALSE;
	}

	//Set the message variables equal to values obtained from ini file.
	setup.wPixelThreshold = m_wPixelThreshold;
	setup.wHSyncThreshold = m_wHSyncThreshold;
	setup.wVSyncThreshold = m_wVSyncThreshold;
	setup.wStartLine = m_wStartLine;
	setup.wNumLines = m_wNumLines;
	setup.wNumSamples = m_wNumSamples;
	setup.hDelay = m_hDelay;
	setup.Interlaced = m_bInterlaced;
		
	ReportDebug(DEBUG_LEVEL1, _T("SetupData: pixelthresh=%hu, hsyncthresh=%hu, vsyncthresh=%hu\n"),
								m_wPixelThreshold, m_wHSyncThreshold, m_wVSyncThreshold);

	ReportDebug(DEBUG_LEVEL1, _T("DAC_Data: StartLine=%hu, NumLines=%hu, Samples=%hu, hDelay=%d, interlaced=%d\n"),
								m_wStartLine, m_wNumLines, m_wNumSamples, m_hDelay, m_bInterlaced);
	
	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_HDVMU_GET_ANALOG_COLORS, (char *)&setup, sizeof(setup), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, 180)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			if (err_HostResponseError(m_modeString, dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				return FALSE;
		}
		else
		{
			// Process a communication error
			if (err_HostCommunicationError(m_modeString, iError))
			  return FALSE;
		}
	}
	else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
	{
		// The response buffer is NULL - we are expecting a pointer to some data, uh-oh.
		if (err_HostResponseBufferIsNull(m_modeString))
			return FALSE;
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		pColorData = (COLOR_SAMPLE *) new COLOR_SAMPLE[m_wNumLines];
		memcpy(pColorData, (COLOR_SAMPLE *)CHR.pvBufferFromHost, (sizeof(COLOR_SAMPLE) * m_wNumLines));
		
		/*
		for(int line=0; line < m_wNumLines; line++)
		{
			ReportDebug(DEBUG_LEVEL1, _T("Received DAC Data: Line=%d, GY=%lu, Pr=%lu, Pb=%lu\n"),
										line,
										pColorData[line].green,
										pColorData[line].red,
										pColorData[line].blue);
		}
		*/
	}
	return TRUE;
}


// **************************************************************************************
// **************************************************************************************
//	CXModuleGrafx::HDTVTestCheckAnalogColorsData()
//
//	Abstract:  Samples RGB data for each color according to user defined parameters.
//
// **************************************************************************************
// **************************************************************************************
BOOL CXModuleGrafx::HDTVTestCheckAnalogColorsData()
{
	//double mVscale = m_vmu.getColorMVperBit(); COLOR_MV_PER_BIT (2500.0/4095.0) - from VMU code
	int GYStartLine, BPbStartLine, RPrStartLine;
	int GYEndLine, BPbEndLine, RPrEndLine;
	WORD GYLinearMax, GYLinearMin;
	WORD BPbLinearMax, BPbLinearMin;
	WORD RPrLinearMax, RPrLinearMin;
	WORD measuredValue;
	double expectedValue;
	BOOL b_validLineData = FALSE;
	BOOL okay = FALSE;
	int loop;	
	
	//Init some local variables...
	GYStartLine = BPbStartLine = RPrStartLine = 0;
	GYLinearMax = GYLinearMin = 0;
	BPbLinearMax = BPbLinearMin = 0;
	RPrLinearMax = RPrLinearMin = 0;
	expectedValue = measuredValue = 0;
		
	//Check to see if the parameters from the ini file are valid.
	if(m_wLinearTolerance == -1)
		err_BADPARAMETER( m_modeString, L"dac_tolerance");

	if(m_GY_LowerThreshold == -1)
		err_BADPARAMETER( m_modeString, L"gy_lower");

	if(m_BPb_LowerThreshold == -1)
		err_BADPARAMETER( m_modeString, L"bpb_lower");

	if(m_RPr_LowerThreshold == -1)
		err_BADPARAMETER( m_modeString, L"rpr_lower");

	if(m_GY_UpperThreshold == -1)
		err_BADPARAMETER( m_modeString, L"gy_upper");

	if(m_BPb_UpperThreshold == -1)
		err_BADPARAMETER( m_modeString, L"bpb_upper");
	
	if(m_RPr_UpperThreshold == -1)
		err_BADPARAMETER( m_modeString, L"rpr_upper");
	
	//Attempt to get the data as many times as allowed.
	//Sometimes the count could be bad because of unexpected noise.
	for(int i = 0; i < m_testRetries; i++)
	{
		//Clear the contents of the data struct before each try.
		//memset(ColorData, 0, sizeof(ColorData));

		if(!HDTVTestGetAnalogColors())
		{
			okay = FALSE;
			goto dac_exit;
		}
		//The test image consists of 4 regions.  The topmost region contains lines made of blue with the last
		//10 pixels of each line colored yellow.  This region is to help the DVMU to figure out that it has 
		//left porch space and entered active video.
		//
		//The second region contains data for the G/Y signal.  This is a 128 step gradient shade from
		//full WHITE to BLACK.
		//
		//The third region contains data for the R/Pr signal.  This is a 128 step gradient shade from
		//full RED to CYAN.
		//
		//the fourth region contains data for the B/Pb signal.  This is a 128 step gradient shade from
		//full BLUE to YELLOW.

		//Now search through the lines of data to find where the first region
		//that contains the white data starts.

		GYEndLine = BPbEndLine = RPrEndLine = 0;
		
		for(int lineData=0; lineData < m_wNumLines; lineData++)
		{
			if( pColorData[lineData].green > m_GY_LowerThreshold &&
				pColorData[lineData].green < m_GY_UpperThreshold)
			{
				//The white data was found - proceede...
				b_validLineData = TRUE;
				GYStartLine = lineData;
				GYLinearMax = pColorData[GYStartLine].green;
				GYLinearMin = pColorData[GYStartLine + 127].green;
				
				if(!wcsicmp(m_HDTVmode, L"480p"))
					ReportStatistic(HDTV_480P_Y_DAC_FULLSCALE,_T("%hu"),GYLinearMax);
				else if(!wcsicmp(m_HDTVmode, L"720p"))
					ReportStatistic(HDTV_720P_Y_DAC_FULLSCALE,_T("%hu"),GYLinearMax);
				else
					ReportStatistic(HDTV_1080I_Y_DAC_FULLSCALE,_T("%hu"),GYLinearMax);

				RPrStartLine = lineData + 128;
				RPrLinearMax = pColorData[RPrStartLine].red;
				RPrLinearMin = pColorData[RPrStartLine + 127].red;
				
				if(!wcsicmp(m_HDTVmode, L"480p"))
					ReportStatistic(HDTV_480P_PR_DAC_FULLSCALE,_T("%hu"),RPrLinearMax);
				else if(!wcsicmp(m_HDTVmode, L"720p"))
					ReportStatistic(HDTV_720P_PR_DAC_FULLSCALE,_T("%hu"),RPrLinearMax);
				else
					ReportStatistic(HDTV_1080I_PR_DAC_FULLSCALE,_T("%hu"),RPrLinearMax);
				
				if( RPrLinearMax > m_RPr_UpperThreshold ||
					RPrLinearMax < m_RPr_LowerThreshold)
				{
					//Bad signal - fail.
					//ReportStatistic (_T("xxxykkkjj"), _T("%s"), m_cfgDevice);
					_stprintf(m_errorMsg, _T("RPr FullScale signal out of spec: Meas=%hu, High=%hu, Low=%hu."),
											RPrLinearMax, m_RPr_UpperThreshold, m_RPr_LowerThreshold);
					err_HDVMUBadDAC(m_modeString, m_errorMsg);
					okay = FALSE;
					goto dac_exit;

				}
								
				BPbStartLine = lineData + 256;
				BPbLinearMax = pColorData[BPbStartLine].blue;
				BPbLinearMin = pColorData[BPbStartLine + 127].blue;

				if(!wcsicmp(m_HDTVmode, L"480p"))
					ReportStatistic(HDTV_480P_PB_DAC_FULLSCALE,_T("%hu"),BPbLinearMax);
				else if(!wcsicmp(m_HDTVmode, L"720p"))
					ReportStatistic(HDTV_720P_PB_DAC_FULLSCALE,_T("%hu"),BPbLinearMax);
				else
					ReportStatistic(HDTV_1080I_PB_DAC_FULLSCALE,_T("%hu"),BPbLinearMax);

				//Check to see if the other signals are within expected tolerances.
				if( BPbLinearMax > m_BPb_UpperThreshold ||
					BPbLinearMax < m_BPb_LowerThreshold)
				{
					//Bad signal - fail.
					_stprintf(m_errorMsg, _T("BPb FullScale signal out of spec: Meas=%hu, High=%hu, Low=%hu."),
											BPbLinearMax, m_BPb_UpperThreshold, m_BPb_LowerThreshold);
					err_HDVMUBadDAC(m_modeString, m_errorMsg);
					okay = FALSE;
					goto dac_exit;

				}

				
				//Determine what the actual range of steps are for each color signal.
				//Ideally, there would be 128 steps, but testing has shown that the BPb and RPr signals
				//roll off to zero around 123 steps or so.  Not doing this will introduce an error of at
				//least 40 to 60 dac counts as the lower end is reached.

				//If there are more than 18 end counts that are zero, then there is probably some kind
				//of bias problem.  Report this as an error.
				//Find the end of the GY signal.
				for(loop=128; loop > 100; loop--)
				{	
					if(pColorData[GYStartLine + (loop-1)].green > 0)
					{
						GYEndLine = loop;
						break;
					}
				}

				//Check to see if still zero - this means an "18 count" violation has occurred.
				if(GYEndLine == 0)
				{
					err_HDVMUBadDAC(m_modeString, L"GY Signal has more than 18 counts with ZERO value.");
					okay = FALSE;
					goto dac_exit;
				}
				
				//Find the end of the BPb signal.
				for(loop=128; loop > 100; loop--)
				{	
					if(pColorData[BPbStartLine + (loop-1)].blue > 0)
					{
						BPbEndLine = loop;
						break;
					}
				}

				//Check to see if still zero - this means an "18 count" violation has occurred.
				if(BPbEndLine == 0)
				{
					err_HDVMUBadDAC(m_modeString, L"BPb Signal has more than 18 counts with ZERO value.");
					okay = FALSE;
					goto dac_exit;
				}
				
				//Find the end of the RPr signal.
				for(loop=128; loop > 100; loop--)
				{	
					if(pColorData[RPrStartLine + (loop-1)].red > 0)
					{
						RPrEndLine = loop;
						break;
					}
				}
				
				//Check to see if any are still zero - this means an "18 count" violation has occurred.
				if(RPrEndLine == 0)
				{
					err_HDVMUBadDAC(m_modeString, L"RPr Signal has more than 18 counts with ZERO value.");
					okay = FALSE;
					goto dac_exit;
				}

				//Report out the calculated expected values
				ReportDebug(DEBUG_LEVEL2, L"GYMax=%hu, GYMin=%hu, EndLine=%hu, Step=%.2f",
							GYLinearMax, GYLinearMin, GYEndLine,
							(float)(GYLinearMax - GYLinearMin) / (float)GYEndLine);
				
				ReportDebug(DEBUG_LEVEL2, L"RPrMax=%hu, RPrMin=%hu, EndLine=%hu, Step=%.2f",
							RPrLinearMax, RPrLinearMin, RPrEndLine,
							(float)(RPrLinearMax - RPrLinearMin) / (float)RPrEndLine);
				
				ReportDebug(DEBUG_LEVEL2, L"BPbMax=%hu, BPbMin=%hu, EndLine=%hu, Step=%.2f",
							BPbLinearMax, BPbLinearMin, BPbEndLine,
							(float)(BPbLinearMax - BPbLinearMin) / (float)BPbEndLine);

				break;
			}
		}

		if(!b_validLineData)
		{
			//Error - unable to detect start of white color data!
			err_HDVMUBadDAC(m_modeString, L"Unable to detect valid start of WHITE color data for measurement.");
			okay = FALSE;
			goto dac_exit;
		}

		//The next 384 lines should be the linear transitions for each of the 3 regions.
		//Calc the expected and measured value arrays.
		//Check to see if the value is in spec.
		for(loop=0; loop < GYEndLine; loop++)
		{
			//Check the GY values
			
			expectedValue = (double)GYLinearMax - ( ((double)(GYLinearMax - GYLinearMin) / (float)GYEndLine) * (double)loop);
			measuredValue = pColorData[GYStartLine + loop].green;
			ReportDebug(DEBUG_LEVEL2, L"Line %d, GY Exp=%.2f, Meas=%hu", loop, expectedValue, measuredValue);
			if( (measuredValue > ((WORD)expectedValue + m_wLinearTolerance)) ||
				(measuredValue < ((WORD)expectedValue - m_wLinearTolerance)) )
			{
				//Fail - value out of spec.
				_stprintf(m_errorMsg, _T("GY Linearity signal out of spec: Line=%d, Meas=%hu, High=%hu, Low=%hu."),
											GYStartLine + loop,
											measuredValue,
											(WORD)expectedValue + m_wLinearTolerance,
											(WORD)expectedValue - m_wLinearTolerance);
				err_HDVMUBadDAC(m_modeString, m_errorMsg);
				okay = FALSE;
				goto dac_exit;
			}
			
		}	
			
			
		for(loop=0; loop < BPbEndLine; loop++)
		{
			//Check the BPb values 
			expectedValue = (double)BPbLinearMax - ( ((double)(BPbLinearMax - BPbLinearMin) / (float)BPbEndLine) * (double)loop);
			measuredValue = pColorData[BPbStartLine + loop].blue;
			ReportDebug(DEBUG_LEVEL2, L"Line %d, BPb Exp=%.2f, Meas=%hu", loop, expectedValue, measuredValue);
			if( (measuredValue > ((WORD)expectedValue + m_wLinearTolerance)) ||
				(measuredValue < ((WORD)expectedValue - m_wLinearTolerance)) )
			{
				//Fail - value out of spec.
				_stprintf(m_errorMsg, _T("BPb Linearity signal out of spec: Line=%d, Meas=%hu, High=%hu, Low=%hu."),
											BPbStartLine + loop,
											measuredValue,
											(WORD)expectedValue + m_wLinearTolerance,
											(WORD)expectedValue - m_wLinearTolerance);
				err_HDVMUBadDAC(m_modeString, m_errorMsg);
				okay = FALSE;
				goto dac_exit;
			}
		}

		for(loop=0; loop < RPrEndLine; loop++)
		{
			//Check the Rpr values.
			expectedValue = (double)RPrLinearMax - ( ((double)(RPrLinearMax - RPrLinearMin) / (float)RPrEndLine) * (double)loop);
			measuredValue = pColorData[RPrStartLine + loop].red;
			ReportDebug(DEBUG_LEVEL2, L"Line %d, RPr Exp=%.2f, Meas=%hu", loop, expectedValue, measuredValue);
			if( (measuredValue > ((WORD)expectedValue + m_wLinearTolerance)) ||
				(measuredValue < ((WORD)expectedValue - m_wLinearTolerance)) )
			{
				//Fail - value out of spec.
				_stprintf(m_errorMsg, _T("RPr Linearity signal out of spec: Line=%d, Meas=%hu, High=%hu, Low=%hu."),
											RPrStartLine + loop,
											measuredValue,
											(WORD)expectedValue + m_wLinearTolerance,
											(WORD)expectedValue - m_wLinearTolerance);
				err_HDVMUBadDAC(m_modeString, m_errorMsg);
				okay = FALSE;
				goto dac_exit;
			}
		}
		
		//If we make it out of the above loop, the linearity check has passed for all signals.
		
	}//end for retries
	
	okay = TRUE;

dac_exit:
	if (pColorData) delete pColorData;

	return okay;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\xbs_app.h ===
//
//	xbox_app.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __XBOX_APP_H__
#define __XBOX_APP_H__

#include "renderer.h"
#include "camera.h"
#include "scene_renderer.h"
#include "logo_renderer.h"
#include "VBlob.h"
#include "Shield.h"
#include "GreenFog.h"
#include "qrand.h"
#include "CamControl.h"
#include "PlacementDoodad.h"
#ifdef XMTA_TEST
#include "gfxtest.h"
#endif

//#define GENERATE_CHECKSUMS
//#define HARDWARE_CHECKSUM

#ifdef INCLUDE_INPUT
#include "XBInput.h"
#endif // INCLUDE_INPUT



#include "defines.h"

#ifdef XSS_TEST
#define MemAlloc(x) MemAlloc_(x)
#define MemFree(x) MemFree_(x)
#endif



///////////////////////////////////////////////////////////////////////////////
class XBoxStartupApp
{
private:
	
	int				nWidth;
	int				nHeight;


	bool			bPaused;
	bool			bActive;
	bool			bLoop;
	bool			bCameraUnderControl;
	bool			bUserControlledIntensity;
	bool			bRenderGeom;
	bool			bRenderSlash;

	float			fTimeElapsed;
	float			fJogDeltaTime;
	float			fIIDT;
	float			fBaseBlobIntensity;
	float			fBlobIntensity;
	float			fSmoothedBlobIntensity;

	DWORD			dwLastTick;
	DWORD			dwLastFramecountTick;
#ifndef FINAL_BUILD
	int				numFrames, numFramesTooSlow;
	float			fFastestFrame, fSlowestFrame;
#endif


	enum { NUM_PULSES = 12 };
	D3DVECTOR		vPulses[NUM_PULSES];	// x=center time, y=time radius of effect, z=intensity
	void			initIntensityPulses();
	float			sumIntensityPulses(float et);


	void					process();
	void					drawFrame();

	// we still want to move around when paused.
	void					advanceTime(float dt, float cam_dt);

	ShieldMgr				shieldMgr;
	LogoRenderer			logoGeom;
	

	QRand					qrand;

#ifdef INCLUDE_INPUT
    XDEVICE_PREALLOC_TYPE  * inputDeviceTypes;
    DWORD                    dwNumInputDeviceTypes;
    XBGAMEPAD              * pGamepad;
	XBGAMEPAD                defaultGamepad;

	void processInput();
#endif // INCLUDE_INPUT

	float					 fCamRad,	fSavedCamRad;
	float					 fCamTheta,	fSavedCamTheta;
	float					 fCamPhi,	fSavedCamPhi;
	float					 fCamRadBlob;

#ifdef INCLUDE_PLACEMENT_DOODAD	
	bool					bPositionLookatMode;
	D3DVECTOR				ptLookatPosition;
	PlacementDoodad			placementDoodad;
public:
	const D3DVECTOR&		getLookatPoint()	const	{ return ptLookatPosition; }
protected:
#endif


public:

#ifndef STARTUPANIMATION
	float fInitTimes[64];	
	void startTimeRec(int i) { fInitTimes[i] = ((float)GetTickCount()) * 0.001f; }
	void endTimeRec(int i)   { fInitTimes[i] = (((float)GetTickCount()) * 0.001f) - fInitTimes[i]; }

#endif // STARTUPANIMATION

	Renderer				theRenderer;
	Camera					theCamera;
	
	D3DLIGHT8               blobLight;
	D3DLIGHT8               moodLight;

	LPDIRECT3DCUBETEXTURE8	pNormalCubeMapLoRes;
	LPDIRECT3DCUBETEXTURE8  pNormalCubeMapHiRes;

	LPDIRECT3DCUBETEXTURE8  pStaticReflectionCubeMap;
	LPDIRECT3DTEXTURE8      pRoughBumpMap;

	LPDIRECT3DTEXTURE8      pGlowMap;

	DWORD					dwPShader[st_NoTypes];
	DWORD					dwVShader[st_NoTypes];

	SceneRenderer           sceneGeom;
	VBlob					vblob;
	CameraController		camController;
	GreenFog				greenFog;

	int						nBootCount;

	int						appSpeedId;
	bool					bSceneShadowsOn;
	bool					bFogOn;
	bool				    bWideScreen;

#ifdef XMTA_TEST
    PGFXTEST_RESULTS        pgtr;
#endif

#ifndef HADWARE_CHECKSUM
    DWORD                   m_dwCRCTable[256];
#endif
#ifdef GENERATE_CHECKSUMS
    HANDLE                  hChecksumFile;
#else
    LPDWORD                 pdwChecksums;
    UINT                    uNumRefChecksums;
#endif
    UINT                    uNumScreenChecksums;

#ifndef XMTA_TEST
	void Construct();
#else
    void Construct(PGFXTEST_RESULTS pgfxResults);
#endif
	void Destruct();

	bool	init(int width,int height);
	void	shutdown();
	int		run();
	void	pause();
	void	activate();

    void    verifyScreenChecksum();

#ifndef BINARY_RESOURCE
	DWORD   loadVertexShader(const TCHAR *pName,const DWORD *pdwDecl);
	DWORD   loadPixelShader(const TCHAR *pName);
#else // BINARY_RESOURCE
	DWORD   loadVertexShader(const BYTE *pb,const DWORD *pdwDecl);
	DWORD   loadPixelShader(const BYTE *pb);
#endif // BINARY_RESOURCE

	float			getElapsedTime()			const	{ return fTimeElapsed; }
	float			getBaseBlobIntensity()		const	{ return fBaseBlobIntensity; }
	float			getBlobIntensity()			const	{ return fBlobIntensity; }
	float			getPulseIntensity()			const	{ return fBlobIntensity - fBaseBlobIntensity; }
	float			getSmoothedBlobIntensity()	const	{ return fSmoothedBlobIntensity; }
	float			getIIDT()					const	{ return fIIDT; } // IIDT is integration of (intensity * dt)

	
	float			getCameraRadiusFromBlob()	const { return fCamRadBlob; }
	float			getCameraRadius()	const	{ return fCamRad; }
	float			getCameraTheta()	const	{ return fCamTheta; }
	float			getCameraPhi()		const	{ return fCamPhi; }

	ShieldMgr*		getShieldMgr()				{ return &shieldMgr; }

	inline float	fRand01();
	inline float	fRand11();
	inline int		rand() { return qrand.Rand(); }

#ifndef HADWARE_CHECKSUM
    DWORD           ComputeSurfaceCRC32(LPDIRECT3DSURFACE8 pd3ds);
#endif
};
///////////////////////////////////////////////////////////////////////////////
#define XBSA_RAND_MAX  0x00010000
#define XBSA_RAND_MASK 0x0000FFFF
inline float XBoxStartupApp::fRand01()
{
	static float mul = 1.0f / ((float)XBSA_RAND_MAX);
	return ((float)(qrand.Rand()&XBSA_RAND_MASK)) * mul;
}
inline float XBoxStartupApp::fRand11()
{
	static float mul = 2.0f / ((float)XBSA_RAND_MAX);
	return (((float)(qrand.Rand()&XBSA_RAND_MASK)) * mul) - 1.0f;
}
///////////////////////////////////////////////////////////////////////////////

extern XBoxStartupApp gApp;

#endif // __XBOX_APP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\crc32.h ===
/*******************************************************************************
 *
 * Title: crc32.h
 *
 * Abstract: 32 bit CRC calculator.
 *
 ******************************************************************************/

#ifndef _CRC32_H
#define _CRC32_H

#define INITIAL_CRC32     0xffffffff

#ifdef __cplusplus
extern "C" {
#endif

unsigned long updateCRC32(unsigned char *pByte, int numBytes, unsigned long crc);

#ifdef __cplusplus
}
#endif

#endif  /* _CRC32_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\ani2\xbs_math_inl.h ===
//
//	xbs_math_inl.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __XBS_MATH_INL_H__
#define __XBS_MATH_INL_H__

#include "fastmath.h"

///////////////////////////////////////////////////////////////////////////////
inline void SetLookAt(const D3DVECTOR &cam, const D3DVECTOR &look, const D3DVECTOR &up, D3DMATRIX *pres)
{	
	D3DVECTOR zAxis = look;
	zAxis.x -= cam.x;
	zAxis.y -= cam.y;
	zAxis.z -= cam.z;
	
	Normalize(&zAxis);

	D3DVECTOR xAxis;
	Cross(zAxis,up,&xAxis);

	Normalize(&xAxis);

	D3DVECTOR yAxis;
	Cross(xAxis,zAxis,&yAxis);

	pres->_11 = xAxis.x;
	pres->_12 = yAxis.x;
	pres->_13 = zAxis.x;
	pres->_14 = 0.f;
	pres->_21 = xAxis.y;
	pres->_22 = yAxis.y;
	pres->_23 = zAxis.y;
	pres->_24 = 0.f;
	pres->_31 = xAxis.z;
	pres->_32 = yAxis.z;
	pres->_33 = zAxis.z;
	pres->_34 = 0.f;
	pres->_41 = pres->_42 = pres->_43 = 0.f;
	pres->_44 = 1.f;

	D3DVECTOR inv_cam;
	inv_cam.x = -cam.x;
	inv_cam.y = -cam.y;
	inv_cam.z = -cam.z;

	D3DVECTOR r_inv_cam;
	TransformVector(inv_cam,*pres,&r_inv_cam);

	pres->_41 = r_inv_cam.x;
	pres->_42 = r_inv_cam.y;
	pres->_43 = r_inv_cam.z;
}
///////////////////////////////////////////////////////////////////////////////
void SetProjection(float fov,float aspect,float near_plane,float far_plane,D3DMATRIX *pres)
{
	float fov2 = fov * .5f;
	float c,s,ct;
	SinCos(fov2, &s, &c);
	ct = c / s;

    float w = aspect * ct;
    float h = ct;
    float Q = far_plane / (far_plane - near_plane);

	pres->_11 = w;
	pres->_12 = 0.f;
	pres->_13 = 0.f;
	pres->_14 = 0.f;
	pres->_21 = 0.f;
	pres->_22 = h;
	pres->_23 = 0.f;
	pres->_24 = 0.f;
	pres->_31 = 0.f;
	pres->_32 = 0.f;
	pres->_33 = Q;
	pres->_34 = 1.f;
	pres->_41 = 0.f;
	pres->_42 = 0.f;
	pres->_43 = -Q * near_plane;
	pres->_44 = 0.f;
}
///////////////////////////////////////////////////////////////////////////////
inline void SetInverse(const D3DMATRIX &mat, D3DMATRIX *pres)
{
	pres->_11 = mat._11;
	pres->_12 = mat._21;
	pres->_13 = mat._31;
	pres->_14 = 0.f;
	
	pres->_21 = mat._12;
	pres->_22 = mat._22;
	pres->_23 = mat._32;
	pres->_24 = 0.f;

	pres->_31 = mat._13;
	pres->_32 = mat._23;
	pres->_33 = mat._33;
	pres->_34 = 0.f;

	D3DVECTOR inv_trans;
	inv_trans.x = -mat._41;
	inv_trans.y = -mat._42;
	inv_trans.z = -mat._43;

	D3DVECTOR r_inv_trans;
	TransformVector(inv_trans,*pres,&r_inv_trans);

	pres->_41 = r_inv_trans.x;
	pres->_42 = r_inv_trans.y;
	pres->_43 = r_inv_trans.z;
	pres->_44 = 1.f;
}
///////////////////////////////////////////////////////////////////////////////
inline void SetTranspose(const D3DMATRIX &mat, D3DMATRIX *pres)
{
	pres->_11 = mat._11;
	pres->_12 = mat._21;
	pres->_13 = mat._31;
	pres->_14 = mat._41;

	pres->_21 = mat._12;
	pres->_22 = mat._22;
	pres->_23 = mat._32;
	pres->_24 = mat._42;

	pres->_31 = mat._13;
	pres->_32 = mat._23;
	pres->_33 = mat._33;
	pres->_34 = mat._43;

	pres->_41 = mat._14;
	pres->_42 = mat._24;
	pres->_43 = mat._34;
	pres->_44 = mat._44;
}
///////////////////////////////////////////////////////////////////////////////
inline void SetIdentity(D3DMATRIX *pres)
{
	pres->_11 = pres->_22 = pres->_33 = pres->_44 = 1.f;
	pres->_12 = pres->_13 = pres->_14 = 
	pres->_21 = pres->_23 = pres->_24 = 
	pres->_31 = pres->_32 = pres->_34 = 
	pres->_41 = pres->_42 = pres->_43 = 0.f;
}
///////////////////////////////////////////////////////////////////////////////
inline void SetXRotation(float r,D3DMATRIX *pres)
{
	float s,c;
	SinCos(r,&s,&c);

	pres->_11 = 1.f;
	pres->_12 = 0.f;
	pres->_13 = 0.f;
	pres->_14 = 0.f;
	pres->_21 = 0.f;
	pres->_22 = c;
	pres->_23 = s;
	pres->_24 = 0.f;
	pres->_31 = 0.f;
	pres->_32 = -s;
	pres->_33 = c;
	pres->_34 = 0.f;
	pres->_41 = pres->_42 = pres->_43 = 0.f;
	pres->_44 = 1.f; 
}
///////////////////////////////////////////////////////////////////////////////
inline void SetYRotation(float r,D3DMATRIX *pres)
{
	float s,c;
	SinCos(r,&s,&c);

	pres->_11 = c;
	pres->_12 = 0.f;
	pres->_13 = s;
	pres->_14 = 0.f;
	pres->_21 = 0.f;
	pres->_22 = 1.f;
	pres->_23 = 0.f;
	pres->_24 = 0.f;
	pres->_31 = -s;
	pres->_32 = 0.f;
	pres->_33 = c;
	pres->_34 = 0.f;
	pres->_41 = pres->_42 = pres->_43 = 0.f;
	pres->_44 = 1.f; 
}
///////////////////////////////////////////////////////////////////////////////
inline void SetZRotation(float r,D3DMATRIX *pres)
{
	float s,c;
	SinCos(r,&s,&c);

	pres->_11 = c;
	pres->_12 = s;
	pres->_13 = 0.f;
	pres->_14 = 0.f;
	pres->_21 = -s;
	pres->_22 = c;
	pres->_23 = 0;
	pres->_24 = 0.f;
	pres->_31 = 0.f;
	pres->_32 = 0.f;
	pres->_33 = 1;
	pres->_34 = 0.f;
	pres->_41 = pres->_42 = pres->_43 = 0.f;
	pres->_44 = 1.f; 
}
///////////////////////////////////////////////////////////////////////////////
inline void SetXYZRotation(float x,float y,float z, D3DMATRIX *pres)
{
	D3DMATRIX matx;
	SetXRotation(x,&matx);

	D3DMATRIX maty;
	SetYRotation(y,&maty);

	D3DMATRIX matxy;
	MulMats(matx,maty,&matxy);

	D3DMATRIX matz;
	SetZRotation(z,&matz);

	MulMats(matz,matxy,pres);
}
///////////////////////////////////////////////////////////////////////////////
inline void SetRotationFromRHQuat(const D3DVECTOR4 &q,D3DMATRIX *pres)
{
	pres->_11 = q.w*q.w + q.x*q.x - q.y*q.y - q.z*q.z;
	pres->_12 = 2.f*q.x*q.y + 2.f*q.w*q.z;
	pres->_13 = 2.f*q.x*q.z - 2.f*q.w*q.y;
	pres->_14 = 0.f;

	pres->_21 = 2.f*q.x*q.y - 2.f*q.w*q.z;
	pres->_22 = q.w*q.w - q.x*q.x + q.y*q.y - q.z*q.z;
	pres->_23 = 2.f*q.y*q.z + 2.f*q.w*q.x;
	pres->_24 = 0.f;

	pres->_31 = 2.f*q.x*q.z + 2.f*q.w*q.y;
	pres->_32 = 2.f*q.y*q.z - 2.f*q.w*q.x;
	pres->_33 = q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z;
	pres->_34 = 0.f;
	
	pres->_41 = pres->_42 = pres->_43 = 0.f;
	pres->_44 = 1.f;
}
///////////////////////////////////////////////////////////////////////////////
inline void SetRotationFromLHQuat(const D3DVECTOR4 &q,D3DMATRIX *pres)
{
	pres->_11 = q.w*q.w + q.x*q.x - q.y*q.y - q.z*q.z;
	pres->_21 = 2.f*q.x*q.y + 2.f*q.w*q.z;
	pres->_31 = 2.f*q.x*q.z - 2.f*q.w*q.y;
	pres->_41 = 0.f;

	pres->_12 = 2.f*q.x*q.y - 2.f*q.w*q.z;
	pres->_22 = q.w*q.w - q.x*q.x + q.y*q.y - q.z*q.z;
	pres->_32 = 2.f*q.y*q.z + 2.f*q.w*q.x;
	pres->_42 = 0.f;

	pres->_13 = 2.f*q.x*q.z + 2.f*q.w*q.y;
	pres->_23 = 2.f*q.y*q.z - 2.f*q.w*q.x;
	pres->_33 = q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z;
	pres->_43 = 0.f;
	
	pres->_14 = pres->_24 = pres->_34 = 0.f;
	pres->_44 = 1.f;
}
///////////////////////////////////////////////////////////////////////////////
inline void TransformPoint(const D3DVECTOR &pt,const D3DMATRIX &mat, D3DVECTOR *pres)
{
	pres->x = pt.x * mat._11 + pt.y * mat._21 + pt.z * mat._31 + mat._41;
	pres->y = pt.x * mat._12 + pt.y * mat._22 + pt.z * mat._32 + mat._42;
	pres->z = pt.x * mat._13 + pt.y * mat._23 + pt.z * mat._33 + mat._43; 
}
///////////////////////////////////////////////////////////////////////////////
inline void TransformVector(const D3DVECTOR &v,const D3DMATRIX &mat, D3DVECTOR *pres)
{
	pres->x = v.x * mat._11 + v.y * mat._21 + v.z * mat._31;
	pres->y = v.x * mat._12 + v.y * mat._22 + v.z * mat._32;
	pres->z = v.x * mat._13 + v.y * mat._23 + v.z * mat._33; 
}
///////////////////////////////////////////////////////////////////////////////
inline void TransformPoint(const D3DVECTOR4 &pt,const D3DMATRIX &mat, D3DVECTOR4 *pres)
{
	pres->x = pt.x * mat._11 + pt.y * mat._21 + pt.z * mat._31 + pt.w * mat._41;
	pres->y = pt.x * mat._12 + pt.y * mat._22 + pt.z * mat._32 + pt.w * mat._42;
	pres->z = pt.x * mat._13 + pt.y * mat._23 + pt.z * mat._33 + pt.w * mat._43; 
	pres->w = pt.x * mat._14 + pt.y * mat._24 + pt.z * mat._34 + pt.w * mat._44; 
}
///////////////////////////////////////////////////////////////////////////////
inline void MulMats(const D3DMATRIX &a, const D3DMATRIX &b,D3DMATRIX *pres)
{
	pres->_11 = a._11*b._11 + a._12*b._21 + a._13*b._31 + a._14*b._41;
	pres->_12 = a._11*b._12 + a._12*b._22 + a._13*b._32 + a._14*b._42;
	pres->_13 = a._11*b._13 + a._12*b._23 + a._13*b._33 + a._14*b._43;
	pres->_14 = a._11*b._14 + a._12*b._24 + a._13*b._34 + a._14*b._44;

	pres->_21 = a._21*b._11 + a._22*b._21 + a._23*b._31 + a._24*b._41;
	pres->_22 = a._21*b._12 + a._22*b._22 + a._23*b._32 + a._24*b._42;
	pres->_23 = a._21*b._13 + a._22*b._23 + a._23*b._33 + a._24*b._43;
	pres->_24 = a._21*b._14 + a._22*b._24 + a._23*b._34 + a._24*b._44;

	pres->_31 = a._31*b._11 + a._32*b._21 + a._33*b._31 + a._34*b._41;
	pres->_32 = a._31*b._12 + a._32*b._22 + a._33*b._32 + a._34*b._42;
	pres->_33 = a._31*b._13 + a._32*b._23 + a._33*b._33 + a._34*b._43;
	pres->_34 = a._31*b._14 + a._32*b._24 + a._33*b._34 + a._34*b._44;

	pres->_41 = a._41*b._11 + a._42*b._21 + a._43*b._31 + a._44*b._41;
	pres->_42 = a._41*b._12 + a._42*b._22 + a._43*b._32 + a._44*b._42;
	pres->_43 = a._41*b._13 + a._42*b._23 + a._43*b._33 + a._44*b._43;
	pres->_44 = a._41*b._14 + a._42*b._24 + a._43*b._34 + a._44*b._44;
}
///////////////////////////////////////////////////////////////////////////////
inline void SetScale(float x,float y,float z,D3DMATRIX *pres)
{
	pres->_11 = x;
	pres->_22 = y;
	pres->_33 = z;
	
	pres->_12 = pres->_13 = pres->_14 = 
	pres->_21 = pres->_23 = pres->_24 = 
	pres->_31 = pres->_32 = pres->_34 = 
	pres->_41 = pres->_42 = pres->_43 = 0.f;

	pres->_44 = 1.f;
}

///////////////////////////////////////////////////////////////////////////////
inline void SetCubeMapView(DWORD dwFace, const D3DVECTOR &pos,D3DMATRIX *pres)
{
    D3DVECTOR look,up;
	
    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            Set(&look,1.f,0.f,0.f);
			Set(&up,0.f,1.f,0.f);
            break;

        case D3DCUBEMAP_FACE_NEGATIVE_X:
            Set(&look,-1.f,0.f,0.f);
			Set(&up,0.f,1.f,0.f);
            break;

        case D3DCUBEMAP_FACE_POSITIVE_Y:
			Set(&look,0.f,1.f,0.f);
			Set(&up,0.f,0.f,-1.f);
            break;

        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            Set(&look,0.f,-1.f,0.f);
			Set(&up,0.f,0.f,1.f);
            break;

        case D3DCUBEMAP_FACE_POSITIVE_Z:
            Set(&look,0.f,0.f,1.f);
			Set(&up,0.f,1.f,0.f);
            break;

        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            Set(&look,0.f,0.f,-1.f);
			Set(&up,0.f,1.f,0.f);
            break;
    }

	D3DVECTOR lookat;
	Add(pos,look,&lookat);

    SetLookAt( pos, lookat, up, pres );
}
///////////////////////////////////////////////////////////////////////////////
inline void ConcatMats(const D3DMATRIX &a, const D3DMATRIX &b, D3DMATRIX *pres)
{
	MulMats(a,b,pres);

	TransformVector(*((const D3DVECTOR *)(&a._41)),b,(D3DVECTOR *)&pres->_41);

	pres->_41 += b._41; pres->_42 += b._42; pres->_43 += b._43;
	
	pres->_14 = pres->_24 = pres->_34 = 0.f;
	pres->_44 = 1.f;
}
///////////////////////////////////////////////////////////////////////////////
inline float Dot(const D3DVECTOR &a, const D3DVECTOR &b)
{
	return a.x*b.x + a.y*b.y + a.z*b.z;
}
///////////////////////////////////////////////////////////////////////////////
inline float Length2(const D3DVECTOR &v)
{
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
///////////////////////////////////////////////////////////////////////////////
inline float Length(const D3DVECTOR &v)
{
	return fast_sqrt(Length2(v));
}
///////////////////////////////////////////////////////////////////////////////
inline float Distance2(const D3DVECTOR &lhs, const D3DVECTOR &rhs)
{
	float dx = lhs.x - rhs.x;
	float dy = lhs.y - rhs.y;
	float dz = lhs.z - rhs.z;
	return dx*dx + dy*dy + dz*dz;
}
///////////////////////////////////////////////////////////////////////////////
inline float Distance(const D3DVECTOR &lhs, const D3DVECTOR &rhs)
{
	return fast_sqrt(Distance2(lhs, rhs));
}
///////////////////////////////////////////////////////////////////////////////
inline void Normalize(D3DVECTOR *pres)
{
	float fooLen = 1.f/Length(*pres);
	pres->x *= fooLen;
	pres->y *= fooLen;
	pres->z *= fooLen;
}
///////////////////////////////////////////////////////////////////////////////
inline void Cross(const D3DVECTOR &a, const D3DVECTOR &b, D3DVECTOR *pres)
{
	pres->x = a.y*b.z - a.z*b.y;
	pres->y = a.z*b.x - a.x*b.z;
	pres->z = a.x*b.y - a.y*b.x;
}
///////////////////////////////////////////////////////////////////////////////
inline void  Scale(D3DVECTOR *pres,float s)
{
	pres->x *= s; pres->y *= s; pres->z *= s;
}
///////////////////////////////////////////////////////////////////////////////
inline void  Set(D3DVECTOR *pres,float x,float y,float z)
{
	pres->x = x; pres->y = y; pres->z = z;
}
///////////////////////////////////////////////////////////////////////////////
inline void  Set(D3DVECTOR4 *pres,float x,float y,float z,float w)
{
	pres->x = x; pres->y = y; pres->z = z; pres->w = w;
}
///////////////////////////////////////////////////////////////////////////////
inline void  Sub(const D3DVECTOR &lhs, const D3DVECTOR &rhs, D3DVECTOR *pres)
{
	pres->x = lhs.x - rhs.x;
	pres->y = lhs.y - rhs.y;
	pres->z = lhs.z - rhs.z;
}
///////////////////////////////////////////////////////////////////////////////
inline void  SetQuatFromAxis(const D3DVECTOR &axis, float angle,D3DVECTOR4 *pres)
{
	float s,c;
	SinCos(angle*0.5f,&s,&c);
	
	pres->x = axis.x * s;
	pres->y = axis.y * s;
	pres->z = axis.z * s;
	pres->w = c;
}
///////////////////////////////////////////////////////////////////////////////
inline void  NormalizeQuat(D3DVECTOR4 *pres)
{
	float len2 = DotQuats(*pres,*pres);
	if(len2 != 0.f)
	{
		float oo_len = 1.f/fast_sqrt(len2);
		pres->x *= oo_len;
		pres->y *= oo_len;
		pres->z *= oo_len;
		pres->w *= oo_len;
	}
}
///////////////////////////////////////////////////////////////////////////////
inline float DotQuats(const D3DVECTOR4 &q0,const D3DVECTOR4 &q1)
{
	return q0.x * q1.x + q0.y * q1.y + q0.z * q1.z + q0.w * q1.w;
}
///////////////////////////////////////////////////////////////////////////////
inline void  SlerpQuats(const D3DVECTOR4 &q0,const D3DVECTOR4 &q1,float t,D3DVECTOR4 *pres)
{
	float dp = DotQuats(q0,q1);

	D3DVECTOR4 _q1 = q1;
	if(dp < 0.f)
	{
		_q1.x = -q1.x;
		_q1.y = -q1.y;
		_q1.z = -q1.z;
		_q1.w = -q1.w;
		dp = -dp;
	}
	
	if(IsEq(dp,1.f))
	{
		pres->x = q0.x * (1.f - t) + _q1.x * t;
		pres->y = q0.y * (1.f - t) + _q1.y * t;
		pres->z = q0.z * (1.f - t) + _q1.z * t;
		pres->w = q0.w * (1.f - t) + _q1.w * t;
	}
	else
	{
		float angle = fast_acos(dp);
		float t0 = fast_sin(angle*(1.f-t));
		float t1 = fast_sin(angle*t);
		
		pres->x = q0.x * t0 + _q1.x * t1;
		pres->y = q0.y * t0 + _q1.y * t1;
		pres->z = q0.z * t0 + _q1.z * t1;
		pres->w = q0.w * t0 + _q1.w * t1;

		float oo_sin_theta = 1.f/fast_sin(angle);

		pres->x *= oo_sin_theta;
		pres->y *= oo_sin_theta;
		pres->z *= oo_sin_theta;
		pres->w *= oo_sin_theta;
	}
}
///////////////////////////////////////////////////////////////////////////////
inline bool  IsEq(float a,float b)
{
	return fast_fabs(a-b) <= 0.00001f;
}
///////////////////////////////////////////////////////////////////////////////
inline bool  PtsEq(const D3DVECTOR &a,const D3DVECTOR &b)
{
	return IsEq(a.x,b.x) && IsEq(a.y,b.y) && IsEq(a.z,b.z);
}
///////////////////////////////////////////////////////////////////////////////
inline void  AddScaled(D3DVECTOR* ptarget, const D3DVECTOR& src, float scale)
{
	ptarget->x += src.x * scale;
	ptarget->y += src.y * scale;
	ptarget->z += src.z * scale;
}
///////////////////////////////////////////////////////////////////////////////
inline float  QuickLength(const D3DVECTOR& vec)
{
	float h = (float) fabs(vec.x);
	float m = (float) fabs(vec.y);
	float l = (float) fabs(vec.z);
	float t;
	if (m>h) { t = m; m = h; h = t; }
	if (l>m) { t = l; l = m; m = t; }
	if (m>h) { t = m; m = h; h = t; }
	return (1.043388475f * (h + 0.34375f * m + 0.25f * l));
}
///////////////////////////////////////////////////////////////////////////////
inline void  QuickNormalize(D3DVECTOR* p_vec)
{
	float qlen = QuickLength(*p_vec);
	if (qlen < 0.000001f) return;
	float oo_qlen = 1.0f / qlen;
	Scale(p_vec, oo_qlen);
}
///////////////////////////////////////////////////////////////////////////////
inline void  Add(const D3DVECTOR &a, const D3DVECTOR &b, D3DVECTOR *pres)
{
	pres->x = a.x + b.x;
	pres->y = a.y + b.y;
	pres->z = a.z + b.z;
}
///////////////////////////////////////////////////////////////////////////////
inline void SinCos(const float &a, float *ps, float *pc)
{
	_asm
	{
		mov eax,[a]
		fld dword ptr[eax]
		fsincos
		mov ebx,[pc]
		mov ecx,[ps]
		fstp dword ptr[ebx]
		fstp dword ptr[ecx]
	}
}

const float F_0 = 0.0f;

///////////////////////////////////////////////////////////////////////////////
inline float AngleFromSinCos(const float &s, const float &c)
{
	// Calculates the angle that produces a given sin and cosine.
	// This is a special case of atan2.
	//
	// Returns a value in (-Pi, Pi/2]

	if (s <= -1) return -Pi / 2;
	if (s >= 1)  return Pi / 2;
	if (c <= -1) return Pi;
	if (c >= 1)  return F_0;

	// Use either asin or acos, depending on what we think will have the
	// best numerical performance.
	float a;
	if (s < .1f && s > -.1f)
	{
		a = (float) fast_asin(s);
		if (c < 0) 
		{
			a = (float) Pi - a;
			if (a > Pi) a -= 2 * Pi;
		}
	}
	else
	{
		a = (float) fast_acos(c);
		if (s < 0) a = (float) - a;
	}

	return a;
}
///////////////////////////////////////////////////////////////////////////////
inline void bs_swap(float& a, float& b)
{
	float tmp = a;
	a = b;
	b = tmp;
}
///////////////////////////////////////////////////////////////////////////////
inline void bs_swap(int& a, int& b)
{
	int tmp = a;
	a = b;
	b = tmp;
}
///////////////////////////////////////////////////////////////////////////////
#endif // __XBS_MATH_INL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\ani.cpp ===
//-----------------------------------------------------------------------------
//
// ani.cpp - Startup animation test
//
// Member of:  Grafx Module for xmta test executive.
//
//-----------------------------------------------------------------------------
#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"
#include "..\gfxtest.h"

//******************************************************************
// Title: Ani
//
// Abstract: Verifies the video output of the Xbox startup animation
//
//******************************************************************
IMPLEMENT_TESTLOCKED(Grafx, Ani, 5)
{
    GFXTEST_RESULTS gtr = {0};

   // Grafx_StartupAnimation_TestMain(&gtr);

    if (FAILED(gtr.hr)) {
        if (gtr.dwCRCResult[0] != gtr.dwCRCExpected[0]) {
    		ReportDebug(DEBUG_LEVEL1, _T("Frame buffer CRC mismatch on frame %d\n"), gtr.uFrame);
            err_BADCRC(_T("640x480"), gtr.dwCRCResult[0], gtr.dwCRCExpected[0], L"Final composite CRC.");
        }
        else {
            ReportD3DError(gtr.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\3dsurface.cpp ===
//-----------------------------------------------------------------------------
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//
// 3dsurface.cpp - Graphics test (3DSurface) used to stress the video memory
//					functions of the graphics system.
//
// Member of:  Grafx Module for xmta test executive.
//
//-----------------------------------------------------------------------------
#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"


#define D3DFVF_PROJTEXVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)
#define FRAME_MOVES 150 //Number of frame moves to perform for each scene rendered.
#define SURFTEST_MAX_SCENES 9

//******************************************************************
// Title: Vidmemory
//
// Abstract: Renders a 3D scene to a surface and performs various 
//				memory transfer operations beetween multiple surfaces
//				to stress the video memory systems.
//
//******************************************************************
IMPLEMENT_TESTLOCKED (Grafx, 3DSurface, 1)
{
	DWORD crc = DEFAULT_CRC;//Default seed for crc calculations.
	D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );

//#ifdef _DEBUG
	static int surfaceTestCount;
	surfaceTestCount++;
	ReportDebug(DEBUG_LEVEL1,_T("Surface Test - Loop %d"), surfaceTestCount);
//#endif

	if (CheckAbort (HERE)){ MainCleanup(); return;};
	
	
	//Check value of required parameters before proceeding.
	if(m_testScenes > SURFTEST_MAX_SCENES)
	{	//Error - invalid number of scenes for this test.
		err_BADPARAMETER( m_modeString, L"scenes");
		MainCleanup();
		return;
	}
	
	if(m_expectedCRC == 0xffffffff)
	{
		err_BADPARAMETER( m_modeString, L"crc" );
		MainCleanup();
		return;
	}
	
	if (CheckAbort (HERE)){ MainCleanup(); return;};
	//Check for an initialized D3D Device.
	if(g_pd3dDevice == NULL)
	{
		//Error - the global device was not created successfully
		//or has become lost or invalid.
		err_NODIRECT3D(m_modeString);
		MainCleanup();
		return;
	}
	
	// Initialize the app's device-dependant objects
    if(!SurfTestInitDisplayObjects() )
	{	//Fatal error - exit the grafx test.
		MainCleanup();
		return;
	}

	if (CheckAbort (HERE)){ MainCleanup(); return;};
	for(int loop=0; loop < m_testScenes; loop++)
	{
		//Stress the 3D rendering engine
		for(int innerLoop = 0; innerLoop < FRAME_MOVES; innerLoop++)
		{	// Frame move the scene
			if(!SurfTestFrameMove(&matWorld))
			{	//Fatal error - exit test.
				MainCleanup();
				return;
			}
			// Render the scene
			SurfTestRender( loop);
			// Show the frame on the primary surface.
			g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
			g_pd3dDevice->SetTexture( 1, NULL );//Release the texture or else a resource leak will happen.
		}

		if(m_hardwareCRC)
			crc = GetDisplayBufferCRC();
		else
			crc = SurfTestCalcCRC(crc);
		//Output the measured crc for each scene.
		ReportDebug(DEBUG_LEVEL1, _T("Surface CRC (loop %d) = 0x%x\n"), loop+1, crc);
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}
	
	
	ReportDebug(DEBUG_LEVEL1, _T("CRC value to insert into the ini file for the expected test value: = 0x%x\n"), crc);
	if(crc != m_expectedCRC)
	{	//Non-Fatal error, so check status of continue on error flag.
		err_BADCRC(m_modeString, crc, m_expectedCRC, L"");
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}

	//Cleanup
	MainCleanup();
}



//-----------------------------------------------------------------------------
// Name: InitDisplayObjects()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::SurfTestInitDisplayObjects()
{
    //Params for Vidmemory test.
	m_pSpotLightTexture = NULL;

    m_vTexEyePt    = D3DXVECTOR3(-2.0f, -2.0f, -7.0f );
    m_vTexLookatPt = D3DXVECTOR3( 0.0f,  0.0f,  0.0f );

	// Cube vertices
    m_vCube[ 0].p = D3DXVECTOR3( 3.0f, 3.0f,-3.0f); m_vCube[ 0].color = 0xff0080ff;
    m_vCube[ 1].p = D3DXVECTOR3(-3.0f, 3.0f,-3.0f); m_vCube[ 1].color = 0xff0080ff;
    m_vCube[ 2].p = D3DXVECTOR3(-3.0f, 3.0f, 3.0f); m_vCube[ 2].color = 0xff0080ff;
    m_vCube[ 3].p = D3DXVECTOR3( 3.0f, 3.0f, 3.0f); m_vCube[ 3].color = 0xff0080ff;
    m_vCube[ 4].p = D3DXVECTOR3( 3.0f, 3.0f,-3.0f); m_vCube[ 4].color = 0xff0080ff;
    m_vCube[ 5].p = D3DXVECTOR3(-3.0f, 3.0f, 3.0f); m_vCube[ 5].color = 0xff0080ff;

    m_vCube[ 6].p = D3DXVECTOR3(-3.0f,-3.0f,-3.0f); m_vCube[ 6].color = 0xffff00ff;
    m_vCube[ 7].p = D3DXVECTOR3( 3.0f,-3.0f,-3.0f); m_vCube[ 7].color = 0xffff00ff;
    m_vCube[ 8].p = D3DXVECTOR3( 3.0f,-3.0f, 3.0f); m_vCube[ 8].color = 0xffff00ff;
    m_vCube[ 9].p = D3DXVECTOR3(-3.0f,-3.0f, 3.0f); m_vCube[ 9].color = 0xffff00ff;
    m_vCube[10].p = D3DXVECTOR3(-3.0f,-3.0f,-3.0f); m_vCube[10].color = 0xffff00ff;
    m_vCube[11].p = D3DXVECTOR3( 3.0f,-3.0f, 3.0f); m_vCube[11].color = 0xffff00ff;

    m_vCube[12].p = D3DXVECTOR3( 3.0f,-3.0f,-3.0f); m_vCube[12].color = 0xff00ff00;
    m_vCube[13].p = D3DXVECTOR3( 3.0f, 3.0f,-3.0f); m_vCube[13].color = 0xff00ff00;
    m_vCube[14].p = D3DXVECTOR3( 3.0f, 3.0f, 3.0f); m_vCube[14].color = 0xff00ff00;
    m_vCube[15].p = D3DXVECTOR3( 3.0f,-3.0f, 3.0f); m_vCube[15].color = 0xff00ff00;
    m_vCube[16].p = D3DXVECTOR3( 3.0f,-3.0f,-3.0f); m_vCube[16].color = 0xff00ff00;
    m_vCube[17].p = D3DXVECTOR3( 3.0f, 3.0f, 3.0f); m_vCube[17].color = 0xff00ff00;

    m_vCube[18].p = D3DXVECTOR3(-3.0f, 3.0f,-3.0f); m_vCube[18].color = 0xff808000;
    m_vCube[19].p = D3DXVECTOR3(-3.0f,-3.0f,-3.0f); m_vCube[19].color = 0xff808000;
    m_vCube[20].p = D3DXVECTOR3(-3.0f,-3.0f, 3.0f); m_vCube[20].color = 0xff808000;
    m_vCube[21].p = D3DXVECTOR3(-3.0f, 3.0f, 3.0f); m_vCube[21].color = 0xff808000;
    m_vCube[22].p = D3DXVECTOR3(-3.0f, 3.0f,-3.0f); m_vCube[22].color = 0xff808000;
    m_vCube[23].p = D3DXVECTOR3(-3.0f,-3.0f, 3.0f); m_vCube[23].color = 0xff808000;

    m_vCube[24].p = D3DXVECTOR3( 3.0f,-3.0f,-3.0f); m_vCube[24].color = 0xff0000ff;
    m_vCube[25].p = D3DXVECTOR3(-3.0f,-3.0f,-3.0f); m_vCube[25].color = 0xff0000ff;
    m_vCube[26].p = D3DXVECTOR3(-3.0f, 3.0f,-3.0f); m_vCube[26].color = 0xff0000ff;
    m_vCube[27].p = D3DXVECTOR3( 3.0f, 3.0f,-3.0f); m_vCube[27].color = 0xff0000ff;
    m_vCube[28].p = D3DXVECTOR3( 3.0f,-3.0f,-3.0f); m_vCube[28].color = 0xff0000ff;
    m_vCube[29].p = D3DXVECTOR3(-3.0f, 3.0f,-3.0f); m_vCube[29].color = 0xff0000ff;

    m_vCube[30].p = D3DXVECTOR3(-3.0f,-3.0f, 3.0f); m_vCube[30].color = 0xffff0000;
    m_vCube[31].p = D3DXVECTOR3( 3.0f,-3.0f, 3.0f); m_vCube[31].color = 0xffff0000;
    m_vCube[32].p = D3DXVECTOR3( 3.0f, 3.0f, 3.0f); m_vCube[32].color = 0xffff0000;
    m_vCube[33].p = D3DXVECTOR3(-3.0f, 3.0f, 3.0f); m_vCube[33].color = 0xffff0000;
    m_vCube[34].p = D3DXVECTOR3(-3.0f,-3.0f, 3.0f); m_vCube[34].color = 0xffff0000;
    m_vCube[35].p = D3DXVECTOR3( 3.0f, 3.0f, 3.0f); m_vCube[35].color = 0xffff0000;
	  
	//Init the line vertex data.
	m_lineVertex[0].x = 0.0f;
	m_lineVertex[0].y = 0.0f;
	m_lineVertex[0].z = 0.0f;
	m_lineVertex[0].color = 0xffffffff;
	
	m_lineVertex[1].x = 0.75f;
	m_lineVertex[1].y = 0.75f;
	m_lineVertex[1].z = 0.75f;
	m_lineVertex[1].color = 0xffffffff;

	m_lineVertex[2].x = 0.0f;
	m_lineVertex[2].y = 0.0f;
	m_lineVertex[2].z = 0.0f;
	m_lineVertex[2].color = 0xffffffff;

	m_lineVertex[3].x = -0.5f;
	m_lineVertex[3].y = 0.5f;
	m_lineVertex[3].z = 0.5f;
	m_lineVertex[3].color = 0xffffffff;

	m_lineVertex[4].x = 0.0f;
	m_lineVertex[4].y = 0.0f;
	m_lineVertex[4].z = 0.0f;
	m_lineVertex[4].color = 0xffffffff;

	m_lineVertex[5].x = 0.5f;
	m_lineVertex[5].y = -0.5f;
	m_lineVertex[5].z = 0.5f;
	m_lineVertex[5].color = 0xffffffff;

	m_lineVertex[6].x = 0.0f;
	m_lineVertex[6].y = 0.0f;
	m_lineVertex[6].z = 0.0f;
	m_lineVertex[6].color = 0xffffffff;

	m_lineVertex[7].x = -0.5f;
	m_lineVertex[7].y = -0.5f;
	m_lineVertex[7].z = 0.5f;
	m_lineVertex[7].color = 0xffffffff;


	// Set the view matrix
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-15.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXMATRIX  matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &D3DXVECTOR3(0.0f,1.0f,0.0f) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Set up a point light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_POINT, 0.0f, 0.0f, -10.0f );
    light.Attenuation0 = 0.0f;
    light.Attenuation1 = 0.0f;
    light.Attenuation2 = 1.0f;
	g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00333333 );
	
	// Set a default white material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    g_pd3dDevice->SetMaterial( &mtrl );

    if(!CreateSpotLightTexture(TRUE))
		return FALSE;//Fatal error - exit the test.

    return TRUE;
}

//-----------------------------------------------------------------------------
// Name: CreateSpotLightTexture()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::CreateSpotLightTexture( BOOL bBorder )
{
    HRESULT hr;
	
	// Release the old texture
    SAFE_RELEASE( m_pSpotLightTexture );

	// Create a new texture
    hr = g_pd3dDevice->CreateTexture( 128, 128, 1, 0, D3DFMT_X8R8G8B8, 
			                        D3DPOOL_DEFAULT, &m_pSpotLightTexture );
	if(hr != D3D_OK)
	{	//Fatal error - exit grafx test.
		ReportD3DError(hr);
		return FALSE;
	}
    	
	//Locking the area provides a pointer to the start of the data.
	D3DLOCKED_RECT lock;
 	if((hr = m_pSpotLightTexture->LockRect(0, &lock, NULL, 0L)) != D3D_OK)
	{	//Fatal error - exit grafx test.
		ReportD3DError(hr);
		return FALSE;
	}

	D3DSURFACE_DESC desc;
    m_pSpotLightTexture->GetLevelDesc( 0, &desc );
    DWORD* pBits    = (DWORD*)lock.pBits;
    DWORD* pLine    = (DWORD*)lock.pBits;
    DWORD  dwStride = lock.Pitch / sizeof(DWORD);

    // Generate the spotlight tex
    for( DWORD y = 0; y < 128; y++ )
    {
        for( DWORD x = 0; x < 128; x++ )
        {
            FLOAT dx = ( 64.0f - x + 0.5f ) / 64.0f;
            FLOAT dy = ( 64.0f - y + 0.5f ) / 64.0f;
            FLOAT r  = cosf( sqrtf( dx*dx + dy*dy ) * D3DX_PI / 2.0f );
            r = (r > 0.0f) ? r*r : 0.0f;
            int c = (int)min((r*r + 0.15f) * 0xff, 0xff);

            pLine[x] = 0xff000000 + 0x00010101*c;
        }

        pLine += dwStride;
    }
    if( bBorder )
    {
        // Draw border around spotlight texture
        DWORD* pLineX1 = (DWORD*)pBits + dwStride;
        DWORD* pLineX2 = (DWORD*)pBits + dwStride * (128 - 2);
        DWORD* pLineY1 = (DWORD*)pBits + 1;
        DWORD* pLineY2 = (DWORD*)pBits + dwStride - 2;

        for( DWORD x = 0; x < 128; x++ )
        {
            if( x != 0 && x != 127 )
            {
                *pLineX1 = *pLineX2 = 0xffffffff;
                *pLineY1 = *pLineY2 = 0xffffffff;
            }

            pLineX1 += 1;
            pLineX2 += 1;
            pLineY1 += dwStride;
            pLineY2 += dwStride;
        }
    }

    // Unlock the map so it can be used
    XBUtil_SwizzleTexture2D( &lock, &desc );
	if((hr = m_pSpotLightTexture->UnlockRect(0)) != D3D_OK)
	{	//Fatal error - exit grafx test.
		ReportD3DError(hr);
		return FALSE;
	}

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ShowTexture()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::ShowTexture( LPDIRECT3DTEXTURE8 pTexture )
{
    D3DSURFACE_DESC d3dsd;
    pTexture->GetLevelDesc( 0, &d3dsd );

    struct SPRITEVERTEX
    {
        FLOAT sx, sy, sz, rhw;
        FLOAT tu, tv;
    };
    
    SPRITEVERTEX vSprite[4] =
    {
        {        0.0f,               0.0f,         0.99f, 1.0f, 0.0f, 0.0f },
        { (FLOAT)d3dsd.Width,        0.0f,         0.99f, 1.0f, 1.0f, 0.0f },
        { (FLOAT)d3dsd.Width, (FLOAT)d3dsd.Height, 0.99f, 1.0f, 1.0f, 1.0f },
        {        0.0f,        (FLOAT)d3dsd.Height, 0.99f, 1.0f, 0.0f, 1.0f },
    };

    // Set state
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,  D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,    D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,    D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    // Display the sprite
    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN, 2, vSprite, sizeof(SPRITEVERTEX) );
}




//-----------------------------------------------------------------------------
// Name: CalculateTexProjMatrix()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::CalculateTexProjMatrix()
{
	// Get the current view matrix
    D3DXMATRIX matView, matInvView;
    g_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
    D3DXMatrixInverse( &matInvView,  NULL, &matView );

    // Compute view matrix
    D3DXMATRIX matTexView;
    D3DXMatrixLookAtLH( &matTexView, &m_vTexEyePt, &m_vTexLookatPt, &D3DXVECTOR3(0.0f,1.0f,0.0f) );
    
    // Compute projection matrix
    D3DXMATRIX matTexProj;
    D3DXMatrixPerspectiveFovLH( &matTexProj, D3DX_PI/6, 1.0f, 1.0f, 200.0f );

    D3DXMATRIX matScale;
    D3DXMatrixIdentity( &matScale );
    matScale._11 = 0.5f;
    matScale._22 = 0.5f;

    D3DXMATRIX matBias;
    D3DXMatrixIdentity( &matBias );
    matBias._31 = 0.5f;
    matBias._32 = 0.5f;

    D3DXMatrixIdentity( &m_matTexProj );
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matInvView ); // Transform cameraspaceposition to worldspace
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matTexView ); // Transform to worldspace
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matTexProj ); // Situate verts relative to projector's view
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matScale );   // Scale and bias to map the near clipping plane to texcoords
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matBias );    // Scale and bias to map the near clipping plane to texcoords

    // Convert from homogeneous texmap coords to worldspace
    D3DXMATRIX matInvTexView, matInvTexProj;
    D3DXMatrixInverse( &matInvTexView, NULL, &matTexView );
    D3DXMatrixInverse( &matInvTexProj, NULL, &matTexProj );          

    for( int i = 0; i < 8; i++ )
    {
        D3DXVECTOR4 vT( 0.0f, 0.0f, 0.0f, 1.0f );
        vT.x = (i%2) * ( i&0x2 ? -1.0f : 1.0f );
        vT.y = (i%2) * ( i&0x4 ? -1.0f : 1.0f );
        vT.z = (i%2) * ( 1.0f );

        D3DXVec4Transform( &vT, &vT, &matInvTexProj );
        D3DXVec4Transform( &vT, &vT, &matInvTexView );

        m_lineVertex[i].x = vT.x / vT.w;
        m_lineVertex[i].y = vT.y / vT.w;
        m_lineVertex[i].z = vT.z / vT.w;
    }
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::SurfTestFrameMove(D3DXMATRIX* pMatWorld)
{
	HRESULT hr;
    D3DXMATRIX matRotate;
	
	//Rotate the cube on the x & y axis.
	FLOAT fXRotate = 0.03f;
    FLOAT fYRotate = 0.02f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    D3DXMatrixMultiply( pMatWorld, pMatWorld, &matRotate );
    if((hr = g_pd3dDevice->SetTransform( D3DTS_WORLD, pMatWorld )) != D3D_OK)
	{	//Fatal error - exit test.
		ReportDebug(DEBUG_LEVEL1, _T("3DSURFACE.CPP - Failed to setTransform in FrameMove()!"));
		//OutputDebugString( _T("3DSURFACE.CPP - Failed to setTransform in FrameMove()!"));
		ReportD3DError(hr);
		return FALSE;
	}
    
	//Move the eye point that projects the light onto the cube.
	m_vTexEyePt.x += 0.005f;
    m_vTexEyePt.y += 0.006f;

	//Keep the projected spotlight texture over the surface fo the cube.
	m_vTexLookatPt.x += 0.003f;
    m_vTexLookatPt.y += 0.003f;

    // Recalculate our texture projection matrix
    CalculateTexProjMatrix();

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::SurfTestRender(int scene)
{
	
	// Begin the scene
    g_pd3dDevice->BeginScene();
	
	g_pd3dDevice->Clear( 0, NULL,
						D3DCLEAR_TARGET|D3DCLEAR_TARGET_R|D3DCLEAR_TARGET_G|D3DCLEAR_TARGET_G|
						D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
	
	
	DisplayGradientBackground(scene);
		
	// Set default render states
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
		
	//Set lighting params
	g_pd3dDevice->SetTexture( 1, m_pSpotLightTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_ADD );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

	// Set up texture and states to draw the projected spotlight
    g_pd3dDevice->SetTransform( D3DTS_TEXTURE1, &m_matTexProj );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_PROJECTED | D3DTTFF_COUNT3 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX,         D3DTSS_TCI_CAMERASPACEPOSITION );

    // Draw the cube
    g_pd3dDevice->SetVertexShader( D3DFVF_PROJTEXVERTEX );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 12, 
                                   m_vCube, sizeof(PROJTEXVERTEX) );
	
    // Draw texture projection frustrum
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_DIFFUSE );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 4, m_lineVertex, sizeof(m_lineVertex[0]) );

    // End the scene.
    g_pd3dDevice->EndScene();
}


DWORD CXModuleGrafx::SurfTestCalcCRC(DWORD crc)
{
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LPDIRECT3DSURFACE8 lpd3dSurface = NULL;
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	int bytesPerLine;
	
	if((hr = g_pd3dDevice->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &lpd3dSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("3DSURFACE.CPP - Failed to GetFrontBuffer() for CRC calc!\n"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			MainCleanup();
			return 0;
		}
	}
	if((hr = lpd3dSurface->LockRect( &pLockedRect, NULL, NULL )) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("3DSURFACE.CPP - Failed to LockRect() for CRC calc!\n"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			MainCleanup();
			return 0;
		}
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	
	crc = UpdateImageRectCRC(m_dwDisplayHeight, pBits, pitch, bytesPerLine);
	
	//Unlock and release the surface.
	lpd3dSurface->UnlockRect();
	SAFE_RELEASE(lpd3dSurface);

	return crc;
}


//-----------------------------------------------------------------------------
// Name: DisplayGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXModuleGrafx::DisplayGradientBackground( int scene)
{
    DWORD bgColor[] = 
	{
		0xFFFF0000, 0xFF00FFFF, 0xFF00FF00, 0xFFFF00FF,
		0xFFFFFF00, 0xFF0000FF, 0xFFFFFFFF, 0xFF000000,
		0xFFFF00FF, 0xFF0000FF
	};

	// First time around, allocate a vertex buffer
    if( m_pBackgroundVB == NULL )
	{
        g_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &m_pBackgroundVB );
	}

	struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
	BACKGROUNDVERTEX* v;
	m_pBackgroundVB->Lock( 0, 0, (BYTE**)&v, 0L);
	v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = bgColor[scene];
	v[1].p = D3DXVECTOR4( (float)m_dwDisplayWidth,   0, 1.0f, 1.0f ); v[1].color = bgColor[scene];
	v[2].p = D3DXVECTOR4(   0, (float)m_dwDisplayHeight, 1.0f, 1.0f ); v[2].color = bgColor[scene+1];
	v[3].p = D3DXVECTOR4( (float)m_dwDisplayWidth, (float)m_dwDisplayHeight, 1.0f, 1.0f ); v[3].color = bgColor[scene+1];
	m_pBackgroundVB->Unlock();
	
    // Set states
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    g_pd3dDevice->SetStreamSource( 0, m_pBackgroundVB, 5*sizeof(FLOAT) );

    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

	// Clear the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );
	
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\crc32.c ===
/*******************************************************************************
 *
 * Title: crc32.c
 *
 * Abstract: 32 bit CRC calculator.
 *
 ******************************************************************************/

static const unsigned long crctab[256] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

/*******************************************************************************
 * Title:    updateCRC32()
 * Abstract: Update the crc for numBytes of data starting at *pByte.
 ******************************************************************************/
unsigned long updateCRC32(unsigned char *pByte, int numBytes, unsigned long crc)
{
	while (numBytes--)
		crc = crctab[(crc ^ *pByte++) & 0x0ff] ^ (crc >> 8);
	return crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\hdtv.cpp ===
//-----------------------------------------------------------------------------
// File: hdtv.cpp
//
// Desc: 
//
// Copyright (c) 2000 Intel Corp. All rights reserved.
//-----------------------------------------------------------------------------
#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"

// A structure for our custom vertex type
struct HDTV_CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex
    DWORD color;        // The vertex color
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_HDTV_CUSTOMVERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)
//Some defines for the tests.
#define HDTV_TIMINGS	0x0001
#define HDTV_PIXELS		0x0002
#define HDTV_DAC		0x0004
#define HDTV_TRILEVEL	0x0008

#define HDTV_DAC_LINES	384



//******************************************************************
// Title: HDTV Test
//
// Abstract: Generate a series of HDTV test patterns.  The output
//			signal will be analyzed by the HDVMU device attached to the 
//			host tester, and communications will take place via a small
//			interface app that will relay info between the DVMU and XBOX app.
//
//******************************************************************
IMPLEMENT_TESTLOCKED (Grafx, HDTV, 4)
{
	WORD tests = 0;

	if (CheckAbort (HERE)){ MainCleanup(); return;};
	
	if( m_HDTVTestPattern == NULL)
	{
		err_BADPARAMETER( m_modeString, L"test");
		MainCleanup();
		return;
	}
	
	ReportDebug(DEBUG_LEVEL1, _T("HDTV.CPP - Test Pattern = %s\n"), m_HDTVTestPattern);

	if(!wcsicmp(m_HDTVTestPattern, L"all"))//Do all tests.
		tests = (tests | HDTV_TIMINGS | HDTV_PIXELS | HDTV_DAC | HDTV_TRILEVEL);
	
	else if(!wcsicmp(m_HDTVTestPattern, L"pixels"))//Do the pixel count test.
		tests = tests | HDTV_PIXELS;

	else if(!wcsicmp(m_HDTVTestPattern, L"timings"))//Do the timings test.
		tests = tests | HDTV_TIMINGS;

	else if(!wcsicmp(m_HDTVTestPattern, L"dac"))//Do the DAC (analog colors) test.
		tests = tests | HDTV_DAC;

	else if(!wcsicmp(m_HDTVTestPattern, L"tlsp"))//Do the trilevel sync test.
		tests = tests | HDTV_TRILEVEL;

	if(!wcsicmp(m_HDTVmode, L"1080i"))
		m_bInterlaced = TRUE;
	else
		m_bInterlaced = FALSE;

	
	//Init the vertex buffer to be used for rendering.
	m_pHDTVPatternVB = NULL;
			
	if(g_pd3dDevice == NULL)
	{
		//Error - the global device was not created successfully
		//or has become lost or invalid.
		err_NODIRECT3D(m_modeString);
		MainCleanup();
		return;
	}

	if (CheckAbort (HERE)){ MainCleanup(); return;};
	if(tests & HDTV_PIXELS)//Do the pixel count test.
	{
		
		//if( m_PixelCountPattern == 0)
		//{
		//	err_BADPARAMETER( m_modeString, L"pattern");
		//	MainCleanup();
		//	return;
		//}
		
		if(!HDTVTestInitPixelCountPattern(m_PixelCountPattern) )
		{	//Fatal error - exit the grafx test.
			MainCleanup();
			return;
		}
		// Render the scene
		HDTVTestPixelCountRender();
		if(m_secondsToDisplay)
			Sleep(m_secondsToDisplay);	
		HDTVTestCheckPixelcountData();
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}

	
	SAFE_RELEASE(m_pHDTVPatternVB);
	m_pHDTVPatternVB = NULL;

	if(tests & HDTV_DAC)
	{
		HDTVTestInitDacPattern();
		HDTVTestAnalogColorsRender();
		if(m_secondsToDisplay)
			Sleep(m_secondsToDisplay);
		HDTVTestCheckAnalogColorsData();
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}

	
	SAFE_RELEASE(m_pHDTVPatternVB);
	m_pHDTVPatternVB = NULL;

	if(tests & HDTV_TIMINGS)//Do the timings test.
	{
		// Render the scene
		HDTVTestBackgroundRender(0,0,255);
		if(m_secondsToDisplay)
			Sleep(m_secondsToDisplay);
		HDTVTestCheckTimingsData();
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}

	SAFE_RELEASE(m_pHDTVPatternVB);
	m_pHDTVPatternVB = NULL;

	if(tests & HDTV_TRILEVEL)//Do the trilevel sync test.
	{
		// Render the scene
		HDTVTestBackgroundRender(255,255,255);
		if(m_secondsToDisplay)
			Sleep(m_secondsToDisplay);
		HDTVTestCheckTrilevelSyncData();
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}

	//Cleanup
	SAFE_RELEASE(m_pHDTVPatternVB);
	SAFE_DELETE(m_pHDTVPatternVB);
	MainCleanup();
}



//-----------------------------------------------------------------------------
// Name: InitPixelCountPattern()
// Desc: Creates a vertex buffer and fills it with our vertices. The vertex
//       buffer is basically just a chuck of memory that holds vertices. After
//       creating it, we must Lock()/Unlock() it to fill it. For indices, D3D
//       also uses index buffers. The special thing about vertex and index
//       buffers is that the ycan be created in device memory, allowing some
//       cards to process them in hardware, resulting in a dramatic
//       performance gain.
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::HDTVTestInitPixelCountPattern(int pattern)
{
    BOOL result;


	switch(pattern)
	{
		case 1:	result = HDTVTestPixelPattern01();	break;

		case 2:	result = HDTVTestPixelPattern02();	break;

		case 3:	result = HDTVTestPixelPattern03();	break;

		case 4:	result = HDTVTestPixelPattern04();	break;

		case 5:	result = HDTVTestPixelPattern05();	break;

		case 6:	result = HDTVTestPixelPattern06();	break;

		case 7:	result = HDTVTestPixelPattern07();	break;

		case 8:	result = HDTVTestPixelPattern08();	break;

		case 9:	result = HDTVTestPixelPattern09();	break;

		case 10: result = HDTVTestPixelPattern10();	break;

		case 11: result = HDTVTestPixelPattern11();	break;

		case 12: result = HDTVTestPixelPattern12();	break;

		case 13: result = HDTVTestPixelPattern13();	break;

		case 14: result = HDTVTestPixelPattern14();	break;

		default:
			result = FALSE;
			break;	
	}
	
    return result;
}


//---------------------------------------------
//Pattern01 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 green on, 1 black for remaining top half of screen
//	Alternating 1 black, 1 red on for second half of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern01()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, fifthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 2.0f);
	else
		firstRow  =  (height / 2.0f) - 1.0f;
	secondRow = height - 2;
	thirdRow =  height;
	fourthRow = height;
	fifthRow =  height;
	

	m_PatternSections = 2;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
	  
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	//Draw the Red pixel row
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
		}
    }

	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


//---------------------------------------------
//Pattern02 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 green on, 2 black for remaining top half of screen
//	Alternating 2 black, 2 red on for second half of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern02()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, fifthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 2.0f);
	else
		firstRow  =  (height / 2.0f) - 1.0f;
	secondRow = height - 2;
	thirdRow =  height;
	fourthRow = height;
	fifthRow =  height;
	

	m_PatternSections = 2;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	
	//Draw the Red pixel row
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
		}
    }


	
	  // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


//---------------------------------------------
//Pattern03 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 white on, 1 black for remaining top 1/4 of screen
//	Alternating 1 blue on, 1 yellow on for second 1/4 of screen
//	Alternating 1 red on, 1 cyan on for third 1/4 of screen.
//	Alternating 1 green on, 1 black for 1/4 of the bottom 1/4 of screen.
//	Alternating 1 blue one, 1 black for 
//	Alternating 1 red on, 1 black for 
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern03()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, fifthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.
	


	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 4.0f);
	else
		firstRow  =  (height / 4.0f) - 1.0f;
	secondRow = ((height / 4.0f) * 2.0f)  - 1.0f;
	thirdRow =  ((height / 4.0f) * 3.0f)  - 1.0f;
	fourthRow = ((height / 4.0f) * 3.25f)  - 1.0f;
	fifthRow =  ((height / 4.0f) * 3.60f)  - 1.0f;
	
	m_PatternSections = 6;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	// Initialize 2 vertices for each line.
	//The order is as follows:
	//For the Red/Green pixels:  white, black
	//For the Green pixels:  red, red, cyan, cyan
	//For the Blue pixels:  blue, blue, yellow, yellow
	
	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	//Draw the white/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//white line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffffff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffffff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	
	//Draw the blue/yellow rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//yellow line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffff00;
    		vert++;
		}
    }


	//Draw the red/cyan rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//cyan line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ffff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ffff;
    		vert++;
		}
    }


	//Draw the green/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	//Draw the red/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	//Draw the blue/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = height-1;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = height-1;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


//---------------------------------------------
//Pattern04 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 white on, 2 black for remaining top 1/4 of screen
//	Alternating 2 blue on, 2 yellow on for second 1/4 of screen
//	Alternating 2 red on, 2 cyan on for third 1/4 of screen.
//	Alternating 2 green on, 2 black for .25 of the bottom 1/4 of screen.
//	Alternating 2 blue one, 2 black for .60 of the bottom 1/4 of screen
//	Alternating 2 red on, 2 black   for .15 of the bottom 1/4 of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern04()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, fifthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.
	


	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 4.0f);
	else
		firstRow  =  (height / 4.0f) - 1.0f;
	secondRow = ((height / 4.0f) * 2.0f)  - 1.0f;
	thirdRow =  ((height / 4.0f) * 3.0f)  - 1.0f;
	fourthRow = ((height / 4.0f) * 3.25f)  - 1.0f;
	fifthRow =  ((height / 4.0f) * 3.60f)  - 1.0f;
	
	m_PatternSections = 6;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	// Initialize 2 vertices for each line.
	//The order is as follows:
	//For the Red/Green pixels:  white, black
	//For the Green pixels:  red, red, cyan, cyan
	//For the Blue pixels:  blue, blue, yellow, yellow
	
	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	//Draw the white/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//white line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffffff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffffff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//white line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffffff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffffff;
    		vert++;
			column++;
		}

		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	
	//Draw the blue/yellow rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}

		if(column < width)
		{	//yellow line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffff00;
    		vert++;
			column++;
		}

		if(column < width)
		{	//yellow line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffffff00;
    		vert++;
		}
    }


	//Draw the red/cyan rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}

		if(column < width)
		{	//cyan line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ffff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ffff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//cyan line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ffff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ffff;
    		vert++;
		}
    }


	//Draw the green/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}

		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	//Draw the red/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}

		
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	//Draw the blue/black rows
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = height-1;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = height-1;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}

		
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = height-1;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = height-1;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}





//---------------------------------------------
//Pattern05 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 red on, 1 black for remaining height of screen
//
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern05()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow = 0.0f, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  height;
	else
		firstRow  =  height - 1.0f;
	

	m_PatternSections = 1;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
	  
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


//---------------------------------------------
//Pattern06 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 red on, 2 black for remaining height of screen
//
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern06()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow = 0.0f, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  height;
	else
		firstRow  =  height - 1.0f;
	

	m_PatternSections = 1;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
	  
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


//---------------------------------------------
//Pattern07 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 green on, 1 black for remaining height of screen
//
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern07()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow = 0.0f, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  height;
	else
		firstRow  =  height - 1.0f;
	

	m_PatternSections = 1;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
	  
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


//---------------------------------------------
//Pattern08 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 green on, 1 black for remaining height of screen
//
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern08()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow = 0.0f, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  height;
	else
		firstRow  =  height - 1.0f;
	

	m_PatternSections = 1;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
	  
		
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}



//---------------------------------------------
//Pattern09 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 green on, 1 black for remaining height of screen
//
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern09()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow = 0.0f, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  height;
	else
		firstRow  =  height - 1.0f;
	

	m_PatternSections = 1;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
	  
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}



//---------------------------------------------
//Pattern10 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 1 green on, 1 black for remaining height of screen
//
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern10()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow = 0.0f, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  height;
	else
		firstRow  =  height - 1.0f;
	

	m_PatternSections = 1;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];
	//g_Vertices = new HDTV_CUSTOMVERTEX [height * 2];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
		if(column < width)
		{	//blue line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
    		vert++;
			column++;
		}
	  
		
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	
	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}



//---------------------------------------------
//Pattern11 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 green on, 2 light black for remaining top half of screen
//	Alternating 2 light black, 2 red on for second half of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern11()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 4.0f);
	else
		firstRow  =  (height / 4.0f) - 1.0f;

	secondRow = ((height / 4.0f) * 2.0f)  - 1.0f;
	thirdRow =  ((height / 4.0f) * 3.0f)  - 1.0f;
	fourthRow = height - 2.0f;
	


	m_PatternSections = 4;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{
			//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			column++;
		}
		if(column < width)
		{
			//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
		}
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			column++;
		}
    }

	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}



//---------------------------------------------
//Pattern12 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 green on, 2 light black for remaining top half of screen
//	Alternating 2 light black, 2 red on for second half of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern12()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, fifthRow, sixthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 6.0f);
	else
		firstRow  =  (height / 6.0f) - 1.0f;

	secondRow = ((height / 6.0f) * 2.0f)  - 1.0f;
	thirdRow =  ((height / 6.0f) * 3.0f)  - 1.0f;
	fourthRow = ((height / 6.0f) * 4.0f)  - 1.0f;
	fifthRow  = ((height / 6.0f) * 5.0f)  - 1.0f;
	sixthRow  = height - 2.0f;
	


	m_PatternSections = 6;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			column++;
		}
		if(column < width)
		{
			//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
		}
    }

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{
			//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;
			column++;
		}
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }




	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
		}
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = sixthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = sixthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fifthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = sixthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff000000;
			vert++;
		}
    }
	
	  // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}



//---------------------------------------------
//Pattern13 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 green on, 2 light black for remaining top half of screen
//	Alternating 2 light black, 2 red on for second half of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern13()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, fourthRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 4.0f);
	else
		firstRow  =  (height / 4.0f) - 1.0f;

	secondRow = ((height / 4.0f) * 2.0f)  - 1.0f;
	thirdRow =  ((height / 4.0f) * 3.0f)  - 1.0f;
	fourthRow = height - 2.0f;
	


	m_PatternSections = 4;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		
		if(column < width)
		{
			//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;
		}
    }

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff00ff00;
    		vert++;
			column++;
		}
		if(column < width)
		{
			//green line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;
		}
    }

	
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
    		vert++;
			column++;
		}
		
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;
		}
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff505050;
    		vert++;
			column++;
		}
		if(column < width)
		{	//red line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = fourthRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xffff0000;
			vert++;
		}
    }
	
	  // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}



//---------------------------------------------
//Pattern14 is defined as follows:
//
//	Two full horizontal lines of blue
//	Alternating 2 green on, 2 light black for remaining top half of screen
//	Alternating 2 light black, 2 red on for second half of screen
//---------------------------------------------
BOOL CXModuleGrafx::HDTVTestPixelPattern14()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, height = 0.0f;
	BOOL bInterlaced = FALSE;
	

	//Check to see if we are in 1080i interlaced mode.
	if( (m_HDTVmode != NULL) && (!wcsicmp(m_HDTVmode, L"1080i")) )
		bInterlaced = TRUE;
	else
		bInterlaced = FALSE;


	width = (int)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	startLine = 0.0f;
	if(bInterlaced)
		firstRow  =  (height / 3.0f);
	else
		firstRow  =  (height / 3.0f) - 1.0f;

	secondRow = ((height / 3.0f) * 2.0f)  - 1.0f;
	thirdRow =  height - 1.0f;
	


	m_PatternSections = 3;
	g_Vertices = new HDTV_CUSTOMVERTEX [(m_PatternSections * width * 2)+4];

	//Draw a blue line across the top of the image to key the color counting engine.
	if(bInterlaced)
	{
		startLine = 14.0f;//5 for HDTV monitor, 14 for VGA
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 12.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 13.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = 0xff0000ff;
		vert++;
	}
	
	else
	{
		startLine = 2.0f;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 0.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
		g_Vertices[vert].x = 0.0f;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
		vert++;		
		g_Vertices[vert].x = (float)width;
		g_Vertices[vert].y = 1.0f;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = 0xff0000ff;
   		vert++;
	}
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red to black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(255,0,0);
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(127,0,0);
    		vert++;
		}
		
    }

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green to black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,255,0);
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,127,0);
    		vert++;
		}
    }

	
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue to black line
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,255);
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,127);
    		vert++;
		}
    }

	
	  // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( ((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, (((m_PatternSections * width * 2)+4)*sizeof(HDTV_CUSTOMVERTEX) ));
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}






//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::HDTVTestPixelCountRender()
{
	//HRESULT hr;
	//LPDIRECT3DSURFACE8 pBackBuffer;

	// Clear the backbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
	
	// Begin the scene
    g_pd3dDevice->BeginScene();

    if(m_bBitmapFromFile)
	{
		HDTVTestGetBitmapFromHost();
		/*
		g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
		hr = D3DXLoadSurfaceFromFile( pBackBuffer,
											NULL,
											NULL,
											"d:\\pattern.bmp",
											NULL,
											D3DX_FILTER_NONE,
											0,
											NULL );
		SAFE_RELEASE(pBackBuffer);
		*/

	}
	else
	{
		//Draw the lines for the pixel count
		g_pd3dDevice->SetStreamSource( 0, m_pHDTVPatternVB, sizeof(HDTV_CUSTOMVERTEX) );
		g_pd3dDevice->SetVertexShader( D3DFVF_HDTV_CUSTOMVERTEX );
		g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, ((int)m_dwDisplayWidth * m_PatternSections) + 2);
	}
	
	// End the scene
    g_pd3dDevice->EndScene();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}


VOID CXModuleGrafx::HDTVTestGetBitmapFromHost()
{
	DWORD dwActualBytesReceived = 0, dwErrorCodeFromHost = 0;
	int iError;
	DWORD *pdwReturnedBuffer = NULL;

	{
		CHostResponse CHR;
		
		if ((iError = g_host.iSendHost(MID_GET_FILE, (char *)&m_BitmapFileName[0], (_tcslen(m_BitmapFileName) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, 180)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(m_modeString, dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(m_modeString, iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_HostCommunicationError(m_modeString, iError))
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			HRESULT hr;
			LPDIRECT3DSURFACE8 pBackBuffer;
			g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
			
			pdwReturnedBuffer = (DWORD *)CHR.pvBufferFromHost;

			/*
			D3DXLoadSurfaceFromFileInMemory( LPDIRECT3DSURFACE8 pDestSurface,
											  CONST PALETTEENTRY* pDestPalette,
											  CONST RECT* pDestRect,
											  LPCVOID pSrcData,
											  UINT SrcData,
											  CONST RECT* pSrcRect,
											  DWORD Filter,
											  D3DCOLOR ColorKey,
											  D3DXIMAGE_INFO* pSrcInfo);*/

			hr = D3DXLoadSurfaceFromFileInMemory( pBackBuffer,
												  NULL,
												  NULL,
												  pdwReturnedBuffer,
												  dwActualBytesReceived,
												  NULL,
												  D3DX_FILTER_NONE,
												  0,
												  NULL);

			SAFE_RELEASE(pBackBuffer);



			/*
			HANDLE hFile = CreateFile( "z:\\pattern.bmp",
										GENERIC_WRITE,
										FILE_SHARE_WRITE,
										NULL,
										CREATE_ALWAYS,
										0,
										NULL );
			
			
			
			WriteFile(hFile,
						pdwReturnedBuffer,
						dwActualBytesReceived,
						&dwBytesWritten,
						NULL);
			ReportWarning(L"bytes received-written = %lu %lu\n", dwActualBytesReceived, dwBytesWritten);
			CloseHandle(hFile);
			*/
		}
	}

}

//-----------------------------------------------------------------------------
// Name: InitDacPattern()
// Desc: Creates a vertex buffer and fills it with our vertices. The vertex
//       buffer is basically just a chuck of memory that holds vertices. After
//       creating it, we must Lock()/Unlock() it to fill it. For indices, D3D
//       also uses index buffers. The special thing about vertex and index
//       buffers is that the ycan be created in device memory, allowing some
//       cards to process them in hardware, resulting in a dramatic
//       performance gain.
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::HDTVTestInitDacPattern()
{
    
	HDTV_CUSTOMVERTEX* g_Vertices;
	int vert, blueLines, currentLine, loop = 0;
	float firstRow, secondRow, width, height = 0.0f;
	int r, g, b=0;


	width = (float)m_dwDisplayWidth;
	height = (float)m_dwDisplayHeight; //Make an easier variable to use.

	firstRow  = (height / 3.0f) - 1.0f;
	secondRow = ((height / 3.0f) * 2.0f) - 1.0f;
	blueLines = (m_bInterlaced)? 30 : 15;
	m_totalDacLines = HDTV_DAC_LINES + (blueLines * 2);


	g_Vertices = new HDTV_CUSTOMVERTEX [m_totalDacLines * 2];

	
	ReportDebug(DEBUG_LEVEL1, L"BlueLines=%d, Interlaced=%d",blueLines, m_bInterlaced);
	
	// Initialize 2 vertices for each line.
	currentLine = 0;
	vert=0;
	for(loop=0; loop < blueLines; loop++)
    {
		//Draw the BLUE section of the first lines.
		g_Vertices[vert].x = 0.0f;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,255) ;
		vert++;		
		g_Vertices[vert].x = width - 10.0f;		g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,255) ;
    	vert++;

		//Draw the YELLOW section of the first lines.
		g_Vertices[vert].x = width-10.0f;		g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(255,255,0) ;
		vert++;		
		g_Vertices[vert].x = width;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(255,255,0) ;
    	vert++;
		currentLine++;
	}
			
	ReportDebug(DEBUG_LEVEL1, L"CurrentLine=%d before white starts to draw.\n",currentLine);	
	//Now draw the Y gradient.
	//Start with WHITE and fade to BLACK.
	r=g=b=255;
	for(loop=0; loop < 128; loop++)
    {
		g_Vertices[vert].x = 0.0f;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(r,g,b) ;
		vert++;		
		g_Vertices[vert].x = width;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(r,g,b) ;
    	vert++;
		
		r=g=b-=2;
		if(r <=0)
			r=g=b=0;
		
		currentLine++;
	}		
	


	//Now draw the RPr gradient.
	//Start with RED and fade to CYAN.
	r=255;
	g=b=0;
	for(loop=0; loop < 128; loop++)
    {
		g_Vertices[vert].x = 0.0f;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(r,g,b) ;
		vert++;		
		g_Vertices[vert].x = width;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(r,g,b) ;
    	vert++;
		
		r-=2;

		g=b+=2;

		currentLine++;
	}		
			
	//Now draw the BPb gradient.
	//Start with BLUE and fade to YELLOW.
	b=255;
	r=g=0;
	for(loop=0; loop < 128; loop++)
    {
		g_Vertices[vert].x = 0.0f;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(r,g,b) ;
		vert++;		
		g_Vertices[vert].x = width;				g_Vertices[vert].y = (float)currentLine;
		g_Vertices[vert].z = 0.0f;				g_Vertices[vert].rhw = 1.0f;
		g_Vertices[vert].color = D3DCOLOR_XRGB(r,g,b) ;
    	vert++;
		
		b-=2;

		r=g+=2;

		currentLine++;
	}		
			

	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( m_totalDacLines*2*sizeof(HDTV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_HDTV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pHDTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	HDTV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pHDTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}

    memcpy( pVertices, g_Vertices, m_totalDacLines*2*sizeof(HDTV_CUSTOMVERTEX) );
    m_pHDTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);

    return TRUE;
}





//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::HDTVTestAnalogColorsRender()
{
    ReportDebug(DEBUG_LEVEL1, L"HDTV.CPP - Attempting to Render the AnalogColors scene...");
	
	// Clear the backbuffer to a blue color
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
		
    // Begin the scene
    g_pd3dDevice->BeginScene();

    //Draw the lines for the dac pattern
	g_pd3dDevice->SetStreamSource( 0, m_pHDTVPatternVB, sizeof(HDTV_CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_HDTV_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, m_totalDacLines);
	
	// End the scene
    g_pd3dDevice->EndScene();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}
	
	  
//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::HDTVTestBackgroundRender(int r, int g, int b)
{
	// Clear the backbuffer to a blue color
    g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(r,g,b), 1.0f, 0L );

	// Begin the scene
    g_pd3dDevice->BeginScene();

	// End the scene
    g_pd3dDevice->EndScene();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\pixelcounts.cpp ===
// Pixelcounts
//
// Get the pixel count data from the HDVMU

#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "..\..\statkeys.h"
#include "xgrafx.h"
#include "hdvmudefs.h"


BOOL CXModuleGrafx::HDTVTestGetPixelcounts(struct GET_ANALOG_PIXEL_COUNT_DATA *pReturnedData)
{
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost = 0;
	int iError;
	GET_ANALOG_PIXEL_COUNT_DATA *pData = NULL;
	HDVMU_SETUP_INFO setup;

#ifdef _DEBUG
	static int pixelTestCount;
	pixelTestCount++;
	ReportDebug(DEBUG_LEVEL1, _T("HDTV Pixel Count Test - Loop %d"), pixelTestCount);
#endif

	//Init the contents to zero.
	memset(&setup, 0, sizeof(setup));
	
	//Determine which Standard to use.
	//Determine which Standard to use.
	if(!wcsicmp(m_HDTVmode, L"480p"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_480 << 3);
	else if(!wcsicmp(m_HDTVmode, L"720p"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_720 << 3);
	else if(!wcsicmp(m_HDTVmode, L"1080i"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_1080 << 3);
	else
	{
		err_BADPARAMETER( m_modeString, L"hdtv_mode" );
		return FALSE;
	}

	//Set the message variables equal to values obtained from ini file.
	setup.wPixelThreshold = m_wPixelThreshold;
	setup.wHSyncThreshold = m_wHSyncThreshold;
	setup.wVSyncThreshold = m_wVSyncThreshold;
		
	ReportDebug(DEBUG_LEVEL1, _T("SetupData: pixelthresh=%lu, hsyncthresh=%lu, vsyncthresh=%lu"),
								m_wPixelThreshold, m_wHSyncThreshold, m_wVSyncThreshold);
	
	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_HDVMU_GET_PIXELCOUNT, (char *)&setup, sizeof(setup), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, 180)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			if (err_HostResponseError(m_modeString, dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				return FALSE;
		}
		else
		{
			// Process a communication error
			if (err_HostCommunicationError(m_modeString, iError))
			  return FALSE;
		}
	}
	else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
	{
		// The response buffer is NULL - we are expecting a pointer to some data, uh-oh.
		if (err_HostResponseBufferIsNull(m_modeString))
			return FALSE;
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		// Analyze the response data from the host
		pData = (GET_ANALOG_PIXEL_COUNT_DATA *)CHR.pvBufferFromHost;
		memcpy(pReturnedData, pData, sizeof(struct GET_ANALOG_PIXEL_COUNT_DATA));
	}
	return TRUE;
}


BOOL CXModuleGrafx::HDTVTestCheckPixelcountData()
{
	struct GET_ANALOG_PIXEL_COUNT_DATA data;
	DWORD gAvg, rAvg, bAvg;
	DWORD diff;
	BOOL pass;
	
	//Init variables.
	gAvg = rAvg = bAvg = 0;
	diff = 0;
	pass = TRUE;
	//Attempt to get the pixel counts as many times as allowed.
	//Sometimes the count could be bad because of unexpected noise.
	for(int i = 0; i < m_testRetries; i++)
	{
		//If we failed the pixelcount test on the first try, it was tested at the 
		//threshold specified in the ini file.  Some systems may have slightly different
		//levels for optimal threshold settings.  If the retries are set to greater than one,
		//then step through the range of valid thresholds to see if we can get a good value.
		//Report out the final threshold level as a stat for data tracking.
		if(i > 0)
		{
			if(i%2)
			{
				//Even value - make it a positive addition to range
				m_wPixelThreshold = m_wPixelThreshold + (WORD)(m_wThresholdRangeStep * i);
			}
			else
			{
				//Odd value - make it a negative addition to range
				m_wPixelThreshold = m_wPixelThreshold - (WORD)(m_wThresholdRangeStep * i);
			}
		}
		
		//Clear the contents of the data struct before each try.
		memset(&data, 0, sizeof(data));

		if(!HDTVTestGetPixelcounts( &data))
			return FALSE;
		
		ReportDebug(DEBUG_LEVEL1, _T("PixelData from CheckData(): Status=%d, G1=%lu, G2=%lu, R1=%lu, R2=%lu, B1=%lu, B2=%lu\n"),
									data.status,
									data.greenPixels[0], data.greenPixels[1],
									data.redPixels[0], data.redPixels[1],
									data.bluePixels[0], data.bluePixels[1]);
				
		//Calc the average values
		gAvg = (data.greenPixels[0] + data.greenPixels[1]) >> 1;
		rAvg = (data.redPixels[0] + data.redPixels[1]) >> 1;
		bAvg = (data.bluePixels[0] + data.bluePixels[1]) >> 1;

		ReportDebug(DEBUG_LEVEL1, _T("Pixel Avgs, Attempt %d: G=%lu, R=%lu, B=%lu, Thresh=%hu\n"),i+1, gAvg, rAvg, bAvg, m_wPixelThreshold);

		pass = TRUE;
		if ((gAvg  == m_dwExpectedGreenCount) && (rAvg == m_dwExpectedRedCount) && (bAvg == m_dwExpectedBlueCount))
			break;//return TRUE;//Couonts exactly as expected - pass and move on.
			
		// Fail if any counts are outside of tolerance
		
		diff = (gAvg > m_dwExpectedGreenCount)? (gAvg - m_dwExpectedGreenCount):(m_dwExpectedGreenCount - gAvg);
		if (diff > m_dwTolerance)
			pass = FALSE;
	
		diff = (rAvg > m_dwExpectedRedCount)? (rAvg - m_dwExpectedRedCount):(m_dwExpectedRedCount - rAvg);
		if (diff > m_dwTolerance)
			pass = FALSE;
		
		diff = (bAvg > m_dwExpectedBlueCount)? (bAvg - m_dwExpectedBlueCount):(m_dwExpectedBlueCount - bAvg);
		if (diff > m_dwTolerance)
			pass = FALSE;

		if(pass)
			break;//return TRUE;
	}
	
	//Report out the final values...
	if(!wcsicmp(m_HDTVmode, L"480p"))
	{
		ReportStatistic(HDTV_480P_G_PIXELCOUNT,_T("%lu"),gAvg);
		ReportStatistic(HDTV_480P_R_PIXELCOUNT,_T("%lu"),rAvg);
		ReportStatistic(HDTV_480P_B_PIXELCOUNT,_T("%lu"),bAvg);
		ReportStatistic(HDTV_480P_PIXEL_THRESHOLD,_T("%hu"),m_wPixelThreshold);
		
	}
	else if(!wcsicmp(m_HDTVmode, L"720p"))
	{
		ReportStatistic(HDTV_720P_G_PIXELCOUNT,_T("%lu"),gAvg);
		ReportStatistic(HDTV_720P_R_PIXELCOUNT,_T("%lu"),rAvg);
		ReportStatistic(HDTV_720P_B_PIXELCOUNT,_T("%lu"),bAvg);
		ReportStatistic(HDTV_720P_PIXEL_THRESHOLD,_T("%hu"),m_wPixelThreshold);
	}
	else
	{
		ReportStatistic(HDTV_1080I_G_PIXELCOUNT,_T("%lu"),gAvg);
		ReportStatistic(HDTV_1080I_R_PIXELCOUNT,_T("%lu"),rAvg);
		ReportStatistic(HDTV_1080I_B_PIXELCOUNT,_T("%lu"),bAvg);
		ReportStatistic(HDTV_1080I_PIXEL_THRESHOLD,_T("%hu"),m_wPixelThreshold);
	}
	
	if(pass)
		return TRUE;
	
	//Determine what value was out of spec and report the informtation to the error stream.
	//This data will be determined from the last set of data that was collected.
	//diff = (gAvg > m_dwExpectedYCount)? (gAvg - m_dwExpectedYCount):(m_dwExpectedYCount - gAvg);
	//diff = (greenAvg[i] > m_dwGreenCount)? (greenAvg[i] - m_dwGreenCount):(m_dwGreenCount - greenAvg[i]);
	//diff = (blueAvg[i] > m_dwBlueCount)? (blueAvg[i] - m_dwBlueCount):(m_dwBlueCount - blueAvg[i]);
	if( (diff = (gAvg > m_dwExpectedGreenCount)? (gAvg - m_dwExpectedGreenCount):(m_dwExpectedGreenCount - gAvg)) > m_dwTolerance)
	{
		_stprintf( m_errorMsg, _T("Failed Green Counts: Expected=%lu, Measured=%lu, Difference=%lu, Tolerance=%lu"),
													m_dwExpectedGreenCount,
													gAvg,
													diff,
													m_dwTolerance);
	}
	else if( (diff = (rAvg > m_dwExpectedRedCount)? (rAvg - m_dwExpectedRedCount):(m_dwExpectedRedCount - rAvg)) > m_dwTolerance)
	{
		_stprintf( m_errorMsg, _T("Failed Red Counts: Expected=%lu, Measured=%lu, Difference=%lu, Tolerance=%lu"),
													m_dwExpectedRedCount,
													rAvg,
													diff,
													m_dwTolerance);
	}
	else if( (diff = (bAvg > m_dwExpectedBlueCount)? (bAvg - m_dwExpectedBlueCount):(m_dwExpectedBlueCount - bAvg)) > m_dwTolerance)
	{
		_stprintf( m_errorMsg, _T("Failed Blue Counts: Expected=%lu, Measured=%lu, Difference=%lu, Tolerance=%lu"),
													m_dwExpectedBlueCount,
													bAvg,
													diff,
													m_dwTolerance);
	}

	err_HDVMUBadPixelCount( m_modeString, m_errorMsg);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\rand32.h ===
/*******************************************************************************
 *
 * Title: rand32.h
 *
 * Abstract: 32 bit random number generator.
 *
 * INTEL CONFIDENTIAL
 * (c) Copyright 1999 Intel Corp. All rights reserved.
 ******************************************************************************/

#ifndef _RAND32_H
#define _RAND32_H

//Disable futile warnings...
#pragma warning (disable:4706)//assignment within conditional expressions.

class CRand32 {
public:
    CRand32();// {}
    ~CRand32();// {}

	void seed(unsigned long seed = 0x8a2d91f5);
    unsigned long number();
    void fillBuffer(unsigned long *start_address, int count);
    void fillBuffer(unsigned char *start_address, int count);
};

#endif  /* _RAND32_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\rand32.cpp ===
/*******************************************************************************
 *
 * Title: rand32.c
 *
 * Abstract: 32 bit random number generator.
 *
 * INTEL CONFIDENTIAL
 * (c) Copyright 1999 Intel Corp. All rights reserved.
 ******************************************************************************/

#include <stdlib.h>
#include "rand32.h"


CRand32::CRand32()
{
	//Do nothing...
}

CRand32::~CRand32()
{
	//Do nothing...
}


void CRand32::seed(unsigned long seed)
{
	srand(seed);
}



unsigned long CRand32::number()
{
	return ((unsigned long)rand() << 17) ^ ((unsigned long)rand() << 6) ^ (unsigned long)rand();
}


void CRand32::fillBuffer(unsigned long *start_address, int count)
{
	if (count <= 0) return;

    while (count--) *start_address++ =  ((unsigned long)rand() << 17) ^ ((unsigned long)rand() << 6) ^ (unsigned long)rand();
}


void CRand32::fillBuffer(unsigned char *start_address, int count)
{
	int byteCount;
	unsigned long rn;

	//Avoid warnings.
	byteCount	= 0;
	rn			= 0;
	
	if (count <= 0) return;
	// Be sure start_address is DWORD aligned
	if (byteCount = ((int)start_address & 3)) {
		rn = number();
		byteCount = 4 - byteCount;
		if (byteCount > count) byteCount = count;
		while (byteCount--) {
			*start_address++ = (unsigned char)rn;
			rn >>= 8;
			count--;
		}
	}

	// In case there are any trailing bytes
	if (byteCount = (count & 3)) rn = number();

	// Fill DWORD aligned part of buffer
	count >>= 2;
	fillBuffer((unsigned long *)start_address, count);

	// Fill trailing bytes
	start_address += count << 2;
	while (byteCount--) {
		*start_address++ = (unsigned char)rn;
		rn >>= 8;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\hdvmudefs.h ===
// Header for structs used for HDVMU communications.

#pragma warning (disable:4200)//Zero-sized array in structs

//BYTE align the data.
#pragma pack(1)

#ifndef _HDVMU_DEFINES_H_
#define _HDVMU_DEFINES_H_

/* Type definitions */
typedef unsigned char	DVMU_BYTE;   // Must be unsigned 8 bit 
typedef unsigned short	DVMU_WORD;   // Must be unsigned 16 bit 
typedef unsigned long	DVMU_DWORD;  // Must be unsigned 32 bit 
typedef short			DVMU_SHORT;  // Must be signed 16 bit 
typedef long			DVMU_LONG;   // Must be signed 32 bit 
typedef BOOL			DVMU_BOOL;

/* Defines */
#define DVMU_SUCCESS 1
#define DVMU_FAILED	0

#define DIGITAL 0
#define ANALOG 1
// SELECT MONITOR SOURCE DEFINES
#define DVI_DIGITAL 0
#define DVI_ANALOG 1
#define VGA 2
#define AUTOMATIC 3

//HDTV mode and Standard Defines
#define HDTV_MODE_RGB					0x0
#define HDTV_MODE_YPRPB					0x1
#define HDTV_MODE_NONINVERT_TRILEVEL	0x2
#define HDTV_MODE_INVERTED_TRILEVEL		0x3

#define HDTV_STD_1080					0x0
#define HDTV_STD_720					0x1
#define HDTV_STD_480					0x2

// SET_SYNC_POLARITY_DEFINES

#define HSYNC_POS_VSYNC_POS  0
#define HSYNC_POS_VSYNC_NEG  1
#define HSYNC_NEG_VSYNC_POS  2
#define HSYNC_NEG_VSYNC_NEG  3

#define HSYNC_NEG 1
#define VSYNC_NEG 2

// SET_2_BITS_CLOCK defines
#define ONE_BIT_PER_CLOCK  0
#define TWO_BITS_PER_CLOCK 0x80

#define MAX_EDID_BUFFER_SIZE 256
// defines the DVMU function codes

// USB standard requests
#define GET_DESCRIPTOR		0x06
#define SET_ADDRESS			0x05
#define SET_CONFIGURATION	0x09

// Vendor Specific Reqeusts
#define UPDATE_FIRMWARE					0x20
#define UPDATE_FPGA						0x21
#define CONNECT_DVI						0x22
#define DISCONNECT_DVI					0x23
#define SET_EDID						0x24
#define SELECT_MONITOR_SOURCE			0x25
#define SET_SYNC_THRESHOLD				0x26
#define SET_COLOR_THRESHOLD				0x27
#define GET_FIRMWARE_REVISION			0x28
#define GET_HARDWARE_REVISION			0x29
#define GET_EDID						0x2A
#define GET_DIGITAL_PIXEL_CLOCK			0x2B
#define GET_TIMINGS						0x2C
#define GET_ANALOG_PIXEL_COUNTS			0x2D
#define GET_DIGITAL_CRC					0x2E
#define GET_ANALOG_COLORS				0x2F
#define SETUP_FOR_ANALOG_DATA			0x2F
#define SEND_ANALOG_COLOR_DATA			0x30
#define GET_UPDATE_STATUS				0x31
#define SET_SYNC_POLARITY				0x32
#define SET_2_BITS_PER_CLOCK			0x33
#define REINITIALIZE_FPGAS				0x34
#define SELECT_HDTV_MODE_AND_STANDARD	0x35


struct HDVMU_SETUP_INFO
{
	int  hSyncPolarity;
	int  vSyncPolarity;
	int  Interlaced;
	WORD wPixelThreshold;
	WORD wHSyncThreshold;
	WORD wVSyncThreshold;
	WORD wStartLine;
	WORD wNumLines;
	WORD wNumSamples;
	BYTE hDelay;
	BYTE Mode;
};


struct GET_TIMINGS_CMD
{
	BYTE function;
	BYTE source;
};

struct TIMINGS_DATA  // for use in calling DLL timings function
{
	BYTE vFrontPorch;
	BYTE vBackPorch;
	WORD vSyncLow;
	WORD vSyncHigh;
	WORD hBackPorch;
	WORD hFrontPorch;
	WORD hSyncLow;
	WORD hSyncHigh;
};

struct GET_TIMINGS_DATA  // for use in calling driver function
{
	BYTE status;
	struct TIMINGS_DATA TimingData1;
	struct TIMINGS_DATA TimingData2;
};

struct GET_DIGITAL_PIXEL_CLOCK_DATA
{
	BYTE status;
	DWORD count;
};

struct GET_ANALOG_PIXEL_COUNT_DATA {
	BYTE status;
	DWORD redPixels[2];
	DWORD greenPixels[2];
	DWORD bluePixels[2];
};

struct SET_EDID_CMD
{
	BYTE function;
	BYTE target;
	WORD BufSize;
	BYTE EDIDInfo[];
};

struct GET_EDID_CMD
{
	BYTE function;
	BYTE target;
};

struct GET_EDID_DATA
{
	BYTE status;
	BYTE EDIDInfo[];
};

struct GET_CRC_DATA
{
	BYTE status;
	DWORD crc;
};

struct REVISION_DATA
{
	BYTE status;
	char revision[8];
};

struct SYNC_THRESHOLD_CMD
{
	BYTE function;
	WORD vertical;
	WORD horizontal;
};

struct COLOR_THRESHOLD_CMD
{
	BYTE function;
	WORD upper;
	WORD lower;
};

struct STATUS_DATA
{
	BYTE status;
	WORD UpdateStatus;
};

struct SYNC_POLARITY_CMD
{
	BYTE function;
	BYTE Polarity;
};

struct TWO_BITS_PER_CLK_CMD
{
	BYTE function;
	BYTE TwoBitsPerClock;
};

struct MONITOR_SRC_CMD
{
	BYTE function;
	BYTE Source;
};

struct HDTV_MODE_N_STD_CMD
{
	BYTE function;
	BYTE ModeStd;
};

struct UPDATE_FIRMWARE_CMD
{
	BYTE function;
	WORD CheckSum;  // checksum of code file
	WORD CodeLen;	// total length of code
	WORD PacketLen; // length of code packet (usually 64 bytes, remainder at end could be less)
	char Packet[64];
};

struct COLOR_SAMPLE
{
	WORD red;	// the buffer this points to should be numlines big
	WORD green; // the buffer this points to should be numlines numlines
	WORD blue; // the buffer this points to should be numlines big
		
};

struct COLOR_SAMPLE_CMD
{
	BYTE function;
	BOOL interlaced;
	BYTE hdelay; 	  // Delay from the horizontal sync in clock counts. A value of 0 means don't sample
	WORD StartLine;  // what line of the frame the sample starts on
	WORD numberOflines;  // how many lines after verticalDelay to measure
	WORD numberOfSamples; // the number of times to measure each pixel. The samples are averaged
};

struct COLOR_SAMPLE_DATA
{
	BYTE status;
	struct COLOR_SAMPLE ColorData[];
};

#pragma pack()

#endif// _HDVMU_DEFINES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\shapes.cpp ===
//-------------------------------------------------------------
//
// Shapes.Cpp - Test module to stress the polygon fill rate for
//				various shapes using random sizes and depths.
//
//-------------------------------------------------------------
#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"


// Our custom FVF, which describes our custom vertex structure
//NOTE:  The maximum number of vertices that the current hardware can support
// at once is 0xffff (65,535), which equals 21,845 triangles.

#define D3DFVF_SHAPES_TEST_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)
#define NUM_COLORS 32

//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
//Lookup table for colors to be selected at random for creating shapes.
DWORD shapeColor[] = 
{
	0xFFFFFFFF, 0xFF000000, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFF00FF, 0xFF00FFFF, 0xFFFFFF00,
	0xFF0F0F0F, 0xFF6F6F6F, 0xFFFF6F6F, 0xFFFF6F00,	0xFF606F00, 0xFFFF666F, 0xFF663F6F, 0xFFFFFF66,
	0xFF6666ff, 0xFF4F9F2F, 0xFF8F4F0F, 0xFF0F3FcF,	0xFF0F7FdF, 0xFFaF4F8F, 0xFFeF006F, 0xFF1F11F0,
	0xFF054F1F, 0xFF3F4F5F, 0xFF5F4F3F, 0xFF1F6F9F,	0xFF9F1F6F, 0xFF4F8F1F, 0xFF5F1F9F, 0xFFdFbFaF
};


//******************************************************************
// Title: Shapes
//
// Abstract: Renders a 3D scene comprised of random sizes of triangles
//				and rectangles filled with various colors.  Will stress
//				fill rate and ability to calc projections, intercepts,
//				and depths through a variety of angles.
//
//******************************************************************
IMPLEMENT_TESTLOCKED (Grafx, Shapes, 3)
{
	DWORD crc = DEFAULT_CRC;//Default seed for crc calculations.

//#ifdef _DEBUG
	static int shapesTestCount;
	shapesTestCount++;
	ReportDebug(DEBUG_LEVEL1, _T("Shapes Test - Loop %d"), shapesTestCount);
//#endif
	
	if (CheckAbort (HERE)){ MainCleanup(); return;};
	
	if(m_expectedCRC == 0xffffffff)
	{
		err_BADPARAMETER( m_modeString, L"crc" );
		MainCleanup();
		return;
	}
	
	if(m_testScenes < 1 || m_testScenes > 20)
	{
		err_BADPARAMETER( m_modeString, L"scenes" );
		MainCleanup();
		return;
	}
		
	if (CheckAbort (HERE)){ MainCleanup(); return;};
	//Check for an initialized D3D Device.
	if(g_pd3dDevice == NULL)
	{
		//Error - the global device was not created successfully
		//or has become lost or invalid.
		err_NODIRECT3D(m_modeString);
		MainCleanup();
		return;
	}
	
	// Initialize the app's device-dependant objects
    if(!ShapeTestInitD3D() )
	{	//Fatal error - exit the grafx test.
		MainCleanup();
		return;
	}

    //Initialize geometric shapes.
	if(!ShapeTestInitGeometry() )
	{	//Fatal error - exit the grafx test.
		MainCleanup();
		return;
	}

	if (CheckAbort (HERE)){ MainCleanup(); return;};
	for(int loop=0; loop < m_testScenes; loop++)
	{
		float rotateAngle = 0.0f;
		rotateAngle = 0.30f * (float)loop;
		
		for(float loop2=0.0; loop2 < 0.30f; loop2+= 0.0025f)
		{	
			// Render the scene
			ShapeTestRender(rotateAngle + loop2);
			// Show the frame on the primary surface.
			g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
		}		
		if(m_hardwareCRC)
			crc = GetDisplayBufferCRC();
		else
			crc = ShapeTestCalcCRC(crc);
		//Output the measured crc for each scene.
		ReportDebug(DEBUG_LEVEL1, _T("Surface CRC (loop %d) = 0x%x\n"), loop+1, crc);
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}
	
	ReportDebug(DEBUG_LEVEL1, _T("CRC value to insert into the ini file for the expected test value: = 0x%x\n"), crc);
	if(crc != m_expectedCRC)
	{	//Non-Fatal error, so check status of continue on error flag.
		err_BADCRC(m_modeString, crc, m_expectedCRC, L"");
		if (CheckAbort (HERE)){ MainCleanup(); return;};
	}

	//Cleanup
	MainCleanup();
}


//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::ShapeTestInitD3D()
{
   
    // Turn off culling, so we see the front and back of the triangle
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Turn off D3D lighting, since we are providing our own vertex colors
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: Creates the scene geometry
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::ShapeTestInitGeometry()
{
	HRESULT hr;
	
	//Create some vertices to use for drawing the shapes.
	m_pTriangles  = new SHAPES_TEST_CUSTOMVERTEX [m_numTriangles * 3];
	m_pTriangles2  = new SHAPES_TEST_CUSTOMVERTEX [m_numTriangles * 3];
	m_pTriangles3  = new SHAPES_TEST_CUSTOMVERTEX [m_numTriangles * 3];
	
	ShapeTestInitTriangles();
	
	// Create the vertex buffer.
    if((hr = g_pd3dDevice->CreateVertexBuffer( m_numTriangles*3*sizeof(SHAPES_TEST_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_SHAPES_TEST_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to CreateVertexBuffer for trinagles in InitGeometry()!"));
		ReportD3DError(hr);
		return FALSE;
	}
	
	// Fill the vertex buffer.
    SHAPES_TEST_CUSTOMVERTEX* pVertices;
    if((hr = m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 )) != D3D_OK)
	{
        ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to LockVertexBuffer for triangles in InitGeometry()!"));
		ReportD3DError(hr);
		return FALSE;
	}

    memcpy( pVertices, m_pTriangles, m_numTriangles*3*sizeof(SHAPES_TEST_CUSTOMVERTEX) );
    m_pVB->Unlock();


    
	// Create the second vertex buffer.
    if((hr = g_pd3dDevice->CreateVertexBuffer( m_numTriangles*3*sizeof(SHAPES_TEST_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_SHAPES_TEST_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB2 )) != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to CreateVertexBuffer for trinagles in InitGeometry()!"));
		ReportD3DError(hr);
		return FALSE;
	}
	
	// Fill the vertex buffer.
    SHAPES_TEST_CUSTOMVERTEX* pVertices2;
    if((hr = m_pVB2->Lock( 0, 0, (BYTE**)&pVertices2, 0 )) != D3D_OK)
	{
        ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to LockVertexBuffer for triangles in InitGeometry()!"));
		ReportD3DError(hr);
		return FALSE;
	}

    memcpy( pVertices2, m_pTriangles2, m_numTriangles*3*sizeof(SHAPES_TEST_CUSTOMVERTEX) );
    m_pVB2->Unlock();




	// Create the third vertex buffer.
    if((hr = g_pd3dDevice->CreateVertexBuffer( m_numTriangles*3*sizeof(SHAPES_TEST_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_SHAPES_TEST_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB3 )) != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to CreateVertexBuffer for trinagles in InitGeometry()!"));
		ReportD3DError(hr);
		return FALSE;
	}
	
	// Fill the vertex buffer.
    SHAPES_TEST_CUSTOMVERTEX* pVertices3;
    if((hr = m_pVB3->Lock( 0, 0, (BYTE**)&pVertices3, 0 )) != D3D_OK)
	{
        ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to LockVertexBuffer for triangles in InitGeometry()!"));
		ReportD3DError(hr);
		return FALSE;
	}

    memcpy( pVertices3, m_pTriangles3, m_numTriangles*3*sizeof(SHAPES_TEST_CUSTOMVERTEX) );
    m_pVB3->Unlock();
	
	return TRUE;
}




//-----------------------------------------------------------------------------
// Name: SetupMatrices()
// Desc: Sets up the world, view, and projection transform matrices.
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::ShapeTestSetupMatrices(float angle)
{
    // For our world matrix, we will just rotate the object about the y-axis.
    D3DXMATRIX matWorld1;
    D3DXMatrixRotationY( &matWorld1, angle );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld1 );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. Here, we set the
    // eye five units back along the z-axis and up three units, look at the
    // origin, and define "up" to be in the y-direction.
    D3DXMATRIX matView1;
    D3DXMatrixLookAtLH( &matView1, &D3DXVECTOR3( 0.0f, 3.0f,-5.0f ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView1 );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj1;
    D3DXMatrixPerspectiveFovLH( &matProj1, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj1 );
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID CXModuleGrafx::ShapeTestRender(float angle)
{
		
	g_pd3dDevice->Clear( 0, NULL,
						D3DCLEAR_TARGET|D3DCLEAR_TARGET_R|D3DCLEAR_TARGET_G|D3DCLEAR_TARGET_G|
						D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,85,170), 1.0f, 0 );
		// Begin the scene
	g_pd3dDevice->BeginScene();
	
	// Setup the world, view, and projection matrices
	ShapeTestSetupMatrices(angle);
	
	// Render the vertex buffer contents for triangles
	g_pd3dDevice->SetTexture( 0, NULL );
	g_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(SHAPES_TEST_CUSTOMVERTEX) );
	g_pd3dDevice->SetVertexShader( D3DFVF_SHAPES_TEST_CUSTOMVERTEX );
	g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, m_numTriangles );
	

	// Render the vertex buffer contents for triangles
	g_pd3dDevice->SetTexture( 0, NULL );
	g_pd3dDevice->SetStreamSource( 0, m_pVB2, sizeof(SHAPES_TEST_CUSTOMVERTEX) );
	g_pd3dDevice->SetVertexShader( D3DFVF_SHAPES_TEST_CUSTOMVERTEX );
	g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, m_numTriangles );

	
	// Render the vertex buffer contents for triangles
	g_pd3dDevice->SetTexture( 0, NULL );
	g_pd3dDevice->SetStreamSource( 0, m_pVB3, sizeof(SHAPES_TEST_CUSTOMVERTEX) );
	g_pd3dDevice->SetVertexShader( D3DFVF_SHAPES_TEST_CUSTOMVERTEX );
	g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, m_numTriangles );
	

	// End the scene
	g_pd3dDevice->EndScene();
}


DWORD CXModuleGrafx::ShapeTestCalcCRC(DWORD crc)
{
	
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LPDIRECT3DSURFACE8 lpd3dSurface = NULL;
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	int bytesPerLine;
	
	//Get the contents of the FRONT BUFFER - this checks that the data we rendered to the 
	//back buffer was correctly blted to the display.
	//if((hr = g_pd3dDevice->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &lpd3dSurface)) != D3D_OK)
	
	//Flip the primary surface to the back buffer.
	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	if((hr = g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpd3dSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to GetFrontBuffer() for CRC calc!"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			MainCleanup();
			return 0;
		}
	}
	if((hr = lpd3dSurface->LockRect( &pLockedRect, NULL, NULL )) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("SHAPES.CPP - Failed to LockRect() for CRC calc!"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			MainCleanup();
			return 0;
		}
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	
	crc = UpdateImageRectCRC(m_dwDisplayHeight, pBits, pitch, bytesPerLine);
	//Unlock and release the surface.
	lpd3dSurface->UnlockRect();
	SAFE_RELEASE(lpd3dSurface);

	return crc;
}



VOID CXModuleGrafx::ShapeTestInitTriangles()
{
	int total = 0;
	int loop = 0;
	
	srand(1);
	
	
	
	for(loop = 0; loop < m_numTriangles; loop++)
	{
		m_pTriangles[total].x = (8 * ((float)rand()/RAND_MAX) - 4);
		m_pTriangles[total].y = (8 * ((float)rand()/RAND_MAX) - 4);
		m_pTriangles[total].z = (6 * ((float)rand()/RAND_MAX) - 3);
		m_pTriangles[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;
		
		m_pTriangles[total].x = m_pTriangles[total-1].x + (0.45f * ((float)rand()/RAND_MAX) - 0.225f);
		m_pTriangles[total].y = m_pTriangles[total-1].y - (0.45f * ((float)rand()/RAND_MAX) - 0.225f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles[total].z = m_pTriangles[total-1].z - (0.45f * ((float)rand()/RAND_MAX) - 0.225f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;

		m_pTriangles[total].x = m_pTriangles[total-1].x - (0.25f * ((float)rand()/RAND_MAX) - 0.125f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles[total].y = m_pTriangles[total-1].y - (0.25f * ((float)rand()/RAND_MAX) - 0.125f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles[total].z = m_pTriangles[total-1].z + (0.25f * ((float)rand()/RAND_MAX) - 0.125f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;
	}
    

	total = 0;
	srand(2);
	for(loop = 0; loop < m_numTriangles; loop++)
	{
		m_pTriangles2[total].x = (8 * ((float)rand()/RAND_MAX) - 4);
		m_pTriangles2[total].y = (8 * ((float)rand()/RAND_MAX) - 4);
		m_pTriangles2[total].z = (6 * ((float)rand()/RAND_MAX) - 3);
		m_pTriangles2[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;
		
		m_pTriangles2[total].x = m_pTriangles2[total-1].x + (0.4f * ((float)rand()/RAND_MAX) - 0.2f);
		m_pTriangles2[total].y = m_pTriangles2[total-1].y - (0.4f * ((float)rand()/RAND_MAX) - 0.2f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles2[total].z = m_pTriangles2[total-1].z - (0.4f * ((float)rand()/RAND_MAX) - 0.2f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles2[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;

		m_pTriangles2[total].x = m_pTriangles2[total-1].x - (0.2f * ((float)rand()/RAND_MAX) - 0.1f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles2[total].y = m_pTriangles2[total-1].y - (0.2f * ((float)rand()/RAND_MAX) - 0.1f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles2[total].z = m_pTriangles2[total-1].z + (0.2f * ((float)rand()/RAND_MAX) - 0.1f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles2[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;
	}

	
	total = 0;
	srand(3);
	for(loop = 0; loop < m_numTriangles; loop++)
	{
		m_pTriangles3[total].x = (8 * ((float)rand()/RAND_MAX) - 4);
		m_pTriangles3[total].y = (8 * ((float)rand()/RAND_MAX) - 4);
		m_pTriangles3[total].z = (6 * ((float)rand()/RAND_MAX) - 3);
		m_pTriangles3[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;
		
		m_pTriangles3[total].x = m_pTriangles3[total-1].x + (0.3f * ((float)rand()/RAND_MAX) - 0.15f);
		m_pTriangles3[total].y = m_pTriangles3[total-1].y - (0.3f * ((float)rand()/RAND_MAX) - 0.15f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles3[total].z = m_pTriangles3[total-1].z - (0.3f * ((float)rand()/RAND_MAX) - 0.15f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles3[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;

		m_pTriangles3[total].x = m_pTriangles3[total-1].x - (0.1f * ((float)rand()/RAND_MAX) - 0.05f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles3[total].y = m_pTriangles3[total-1].y - (0.1f * ((float)rand()/RAND_MAX) - 0.05f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles3[total].z = m_pTriangles3[total-1].z + (0.1f * ((float)rand()/RAND_MAX) - 0.05f);//(1 * ((float)rand()/RAND_MAX) - 0.5f);
		m_pTriangles3[total].color = shapeColor[(int)(NUM_COLORS * (float)rand()/RAND_MAX)];
		total++;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\timings.cpp ===
// Timings
//
// Get the timing data from the HDVMU

#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "..\..\statkeys.h"
#include "xgrafx.h"
#include "hdvmudefs.h"


BOOL CXModuleGrafx::HDTVTestGetTimings(struct GET_TIMINGS_DATA *pReturnedData)
{
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost = 0;
	int iError;
	GET_TIMINGS_DATA *pData = NULL;
	HDVMU_SETUP_INFO setup;

#ifdef _DEBUG
	static int timingsTestCount;
	timingsTestCount++;
	ReportDebug(DEBUG_LEVEL1, _T("HDTV Timings Test - Loop %d"), timingsTestCount);
#endif

	//Init the contents to zero.
	memset(&setup, 0, sizeof(setup));
	
	//Determine which Standard to use.
	if(!wcsicmp(m_HDTVmode, L"480p"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_480 << 3);
	else if(!wcsicmp(m_HDTVmode, L"720p"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_720 << 3);
	else if(!wcsicmp(m_HDTVmode, L"1080i"))
		setup.Mode = (BYTE)HDTV_MODE_RGB | ((BYTE)HDTV_STD_1080 << 3);
	else
	{
		err_BADPARAMETER( m_modeString, L"hdtv_mode" );
		return FALSE;
	}

	//Set the message variables equal to values obtained from ini file.
	setup.wPixelThreshold = m_wPixelThreshold;
	setup.wHSyncThreshold = m_wHSyncThreshold;
	setup.wVSyncThreshold = m_wVSyncThreshold;
		
	ReportDebug(DEBUG_LEVEL1, _T("SetupData: pixelthresh=%lu, hsyncthresh=%lu, vsyncthresh=%lu"),
								m_wPixelThreshold, m_wHSyncThreshold, m_wVSyncThreshold);
	
	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_HDVMU_GET_TIMINGS, (char *)&setup, sizeof(setup), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, 180)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			if (err_HostResponseError(m_modeString, dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				return FALSE;
		}
		else
		{
			// Process a communication error
			if (err_HostCommunicationError(m_modeString, iError))
			  return FALSE;
		}
	}
	else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
	{
		// The response buffer is NULL - we are expecting a pointer to some data, uh-oh.
		if (err_HostResponseBufferIsNull(m_modeString))
			return FALSE;
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		// Analyze the response data from the host
		pData = (GET_TIMINGS_DATA *)CHR.pvBufferFromHost;
		
		/*
		_stprintf(m_debugMsg, _T("Horiz. Timings 1st Field (clock counts): hsh=%lu, hsl=%lu, hfp=%lu, hbp=%lu\n"),
				pData->TimingData1.hSyncHigh,
				pData->TimingData1.hSyncLow,
				pData->TimingData1.hFrontPorch,
				pData->TimingData1.hBackPorch);
		OutputDebugString( m_debugMsg);
	
		_stprintf(m_debugMsg, _T("Vert. Timings 1st Field (clock counts): vsh=%lu, vsl=%lu, vfp=%lu, vbp=%lu\n"),
				pData->TimingData1.vSyncHigh,
				pData->TimingData1.vSyncLow,
				pData->TimingData1.vFrontPorch,
				pData->TimingData1.vBackPorch);
		OutputDebugString( m_debugMsg);

		_stprintf(m_debugMsg, L"Vert. Timings 2nd Field (clock counts): vfp=%lu, vbp=%lu\n",
				pData->TimingData2.vFrontPorch,
				pData->TimingData2.vBackPorch);
		OutputDebugString( m_debugMsg);
		*/

		memcpy(pReturnedData, pData, sizeof(struct GET_TIMINGS_DATA));

	}
	return TRUE;
}


BOOL CXModuleGrafx::HDTVTestCheckTimingsData()
{
	struct GET_TIMINGS_DATA data;
	BOOL pass;

	
	//Check to see if the spec values are valid.
	if(m_VertFrontPorch1 == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Vertical Front Porch Field1 (vfp1)");
	}
	if(m_VertBackPorch1 == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Vertical Back Porch Field1 (vbp1)");
	}
	if(m_VertFrontPorch2 == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Vertical Front Porch Field2 (vfp2)");
	}
	if(m_VertBackPorch2 == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Vertical Back Porch Field2 (vfp1)");
	}
	if(m_wVertSyncLow == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Vertical Sync Low (vsl)");
	}
	if(m_wVertSyncHigh == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Vertical Sync High (vsh)");
	}
	if(m_wHorizBackPorch == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Horiz Back Porch (hbp)");
	}
	if(m_wHorizFrontPorch == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Horiz Front Porch (hfp)");
	}
	if(m_wHorizSyncLow == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Horiz Sync Low (hsl)");
	}
	if(m_wHorizSyncHigh == -1)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"Horiz Sync High (hsh)");
	}
	

	ReportDebug(DEBUG_LEVEL1, _T("Timing Specs from INI file:\n"));
	ReportDebug(DEBUG_LEVEL1, _T("Horiz. Spec Timings 1st Field (clock counts): hsh=%lu, hsl=%lu, hfp=%lu, hbp=%lu\n"),
				m_wHorizSyncHigh,
				m_wHorizSyncLow,
				m_wHorizFrontPorch,
				m_wHorizBackPorch);

	ReportDebug(DEBUG_LEVEL1, _T("Vert. Spec Timings 1st Field (clock counts): vsh=%lu, vsl=%lu, vfp=%lu, vbp=%lu\n"),
			m_wVertSyncHigh,
			m_wVertSyncLow,
			m_VertFrontPorch1,
			m_VertBackPorch1);
	
	//Attempt to get the timings as many times as allowed.
	//Sometimes the count could be bad because of unexpected noise.
	for(int i = 0; i < m_testRetries; i++)
	{
		//Clear the contents of the data struct before each try.
		memset(&data, 0, sizeof(data));

		if(!HDTVTestGetTimings( &data))
			return FALSE;
		
		if(!wcsicmp(m_HDTVmode, L"480p"))
		{
			ReportStatistic(HDTV_480P_TIMINGS_HSYNC_HIGH,_T("%lu"), data.TimingData1.hSyncHigh);
			ReportStatistic(HDTV_480P_TIMINGS_HSYNC_LOW,_T("%lu"), data.TimingData1.hSyncLow);
			ReportStatistic(HDTV_480P_TIMINGS_HFPORCH,_T("%lu"), data.TimingData1.hFrontPorch);
			ReportStatistic(HDTV_480P_TIMINGS_HBPORCH,_T("%lu"), data.TimingData1.hBackPorch);
	
			ReportStatistic(HDTV_480P_TIMINGS_VSYNC_HIGH,_T("%lu"), data.TimingData1.vSyncHigh);
			ReportStatistic(HDTV_480P_TIMINGS_VSYNC_LOW,_T("%lu"), data.TimingData1.vSyncLow);
			ReportStatistic(HDTV_480P_TIMINGS_VFPORCH,_T("%d"), data.TimingData1.vFrontPorch);
			ReportStatistic(HDTV_480P_TIMINGS_VBPORCH,_T("%d"), data.TimingData1.vBackPorch);
		}
		else if(!wcsicmp(m_HDTVmode, L"720p"))
		{
			ReportStatistic(HDTV_720P_TIMINGS_HSYNC_HIGH,_T("%lu"), data.TimingData1.hSyncHigh);
			ReportStatistic(HDTV_720P_TIMINGS_HSYNC_LOW,_T("%lu"), data.TimingData1.hSyncLow);
			ReportStatistic(HDTV_720P_TIMINGS_HFPORCH,_T("%lu"), data.TimingData1.hFrontPorch);
			ReportStatistic(HDTV_720P_TIMINGS_HBPORCH,_T("%lu"), data.TimingData1.hBackPorch);
	
			ReportStatistic(HDTV_720P_TIMINGS_VSYNC_HIGH,_T("%lu"), data.TimingData1.vSyncHigh);
			ReportStatistic(HDTV_720P_TIMINGS_VSYNC_LOW,_T("%lu"), data.TimingData1.vSyncLow);
			ReportStatistic(HDTV_720P_TIMINGS_VFPORCH,_T("%d"), data.TimingData1.vFrontPorch);
			ReportStatistic(HDTV_720P_TIMINGS_VBPORCH,_T("%d"), data.TimingData1.vBackPorch);
		}
		else
		{
			ReportStatistic(HDTV_1080I_TIMINGS_HSYNC_HIGH,_T("%lu"), data.TimingData1.hSyncHigh);
			ReportStatistic(HDTV_1080I_TIMINGS_HSYNC_LOW,_T("%lu"), data.TimingData1.hSyncLow);
			ReportStatistic(HDTV_1080I_TIMINGS_HFPORCH,_T("%lu"), data.TimingData1.hFrontPorch);
			ReportStatistic(HDTV_1080I_TIMINGS_HBPORCH,_T("%lu"), data.TimingData1.hBackPorch);
	
			ReportStatistic(HDTV_1080I_TIMINGS_VSYNC_HIGH,_T("%lu"), data.TimingData1.vSyncHigh);
			ReportStatistic(HDTV_1080I_TIMINGS_VSYNC_LOW,_T("%lu"), data.TimingData1.vSyncLow);
			ReportStatistic(HDTV_1080I_TIMINGS_VFPORCH,_T("%d"), data.TimingData1.vFrontPorch);
			ReportStatistic(HDTV_1080I_TIMINGS_VBPORCH,_T("%d"), data.TimingData1.vBackPorch);
		}

		pass = HDTVTestCheckMeasuredTimings(FALSE, &data);

		if(pass)
			return TRUE;
	}
	
	//Determine what value was out of spec and report the informtation to the error stream.
	//This data will be determined from the last set of data that was collected.
	HDTVTestCheckMeasuredTimings(TRUE, &data);

	return FALSE;
}


// **************************************************************************************
// **************************************************************************************
// CdvmuGui::CheckMeasuredTimings(struct timings *specs, struct timings *measured)
//
// Abstract:  Pass a struct with the timing specs and a struct with the measured values
//			and compare the contents.
// **************************************************************************************
// **************************************************************************************
BOOL CXModuleGrafx::HDTVTestCheckMeasuredTimings(bool reportError, struct GET_TIMINGS_DATA *data)
{
	
	//Check the Horizontal values.
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.hSyncHigh, m_wHorizSyncHigh, m_dwTolerance, L"Horiz Sync High"))
		return FALSE;
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.hSyncLow, m_wHorizSyncLow, m_dwTolerance, L"Horiz Sync Low"))
		return FALSE;
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.hFrontPorch, m_wHorizFrontPorch, m_dwTolerance, L"Horiz Front Porch"))
		return FALSE;
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.hBackPorch, m_wHorizBackPorch, m_dwTolerance, L"Horiz Back Porch"))
		return FALSE;
		
	//vertical values
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.vSyncHigh, m_wVertSyncHigh, m_dwTolerance, L"Vert Sync High"))
		return FALSE;
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.vSyncLow, m_wVertSyncLow, m_dwTolerance, L"Vert Sync Low"))
		return FALSE;
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.vFrontPorch, (WORD)m_VertFrontPorch1, m_dwTolerance, L"Vert Front Proch Field1"))
		return FALSE;
	if(!HDTVTestCheckTimingResult(reportError, data->TimingData1.vBackPorch, (WORD)m_VertBackPorch1, m_dwTolerance, L"Vert Back Porch Field1"))
		return FALSE;
	
	if(m_bInterlaced)
	{
		//Check second field porch values for interlaced video.
		if(!HDTVTestCheckTimingResult(reportError, data->TimingData2.vBackPorch, (WORD)m_VertBackPorch2, m_dwTolerance, L"Vert Back Porch Field2"))
			return FALSE;
		if(!HDTVTestCheckTimingResult(reportError, data->TimingData2.vBackPorch, (WORD)m_VertBackPorch2, m_dwTolerance, L"Vert Back Porch Field2"))
			return FALSE;
	}

	return TRUE;
}



// **************************************************************************************
// **************************************************************************************
// CdvmuGui::CheckTimingResult(unsigned short val, unsigned short ref, unsigned short tol, const char *msg)
//
// Abstract: Evaluate the measured value against the reference value accounting for tolerances.
//
// **************************************************************************************
// **************************************************************************************
BOOL CXModuleGrafx::HDTVTestCheckTimingResult(bool reportError, WORD val, WORD ref, DWORD tol, TCHAR *msg)
{
	
	
	if( (val > (ref+(WORD)tol )) || (val < (ref-(WORD)tol)) )
	{
		if(reportError)
		{
			_stprintf(m_errorMsg, _T("Failed %s test: Expected=%hu, Measured=%hu, Tolerance=%lu"), msg, ref, val, tol);
			err_HDVMUBadTiming(m_modeString, m_errorMsg);
		}
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\trilevel_sync.cpp ===
// Trilevel Sync Test
//
// Get the trilevel sync data from the HDVMU

#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"
#include "hdvmudefs.h"


BOOL CXModuleGrafx::HDTVTestGetTrilevelSync()
{
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost = 0;
	int iError;
	HDVMU_SETUP_INFO setup;
	
#ifdef _DEBUG
	static int syncTestCount;
	syncTestCount++;
	ReportDebug(DEBUG_LEVEL1, _T("HDTV TriLevel Sync Test - Loop %d"), syncTestCount);
#endif

	//Init the contents to zero.
	memset(&setup, 0, sizeof(setup));
	
	//Determine which Standard to use.
	if(!wcsicmp(m_HDTVmode, L"480p"))
	{
		setup.Interlaced = 0;
		if(m_syncMode == 2)
			setup.Mode = (BYTE)HDTV_MODE_NONINVERT_TRILEVEL | ((BYTE)HDTV_STD_480 << 3);
		else
		{
			MainCleanup();
			return err_BADPARAMETER( m_modeString, L"TriLevel Sync Mode (sync_mode)");
		}
	}
	else if(!wcsicmp(m_HDTVmode, L"720p"))
	{
		setup.Interlaced = 0;
		if(m_syncMode == 2)
			setup.Mode = (BYTE)HDTV_MODE_NONINVERT_TRILEVEL | ((BYTE)HDTV_STD_720 << 3);
		else if(m_syncMode == 3)
			setup.Mode = (BYTE)HDTV_MODE_INVERTED_TRILEVEL | ((BYTE)HDTV_STD_720 << 3);
		else
		{
			MainCleanup();
			return err_BADPARAMETER( m_modeString, L"TriLevel Sync Mode (sync_mode)");
		}
	}
	else if(!wcsicmp(m_HDTVmode, L"1080i"))
	{
		setup.Interlaced = 1;
		if(m_syncMode == 2)
			setup.Mode = (BYTE)HDTV_MODE_NONINVERT_TRILEVEL | ((BYTE)HDTV_STD_1080 << 3);
		else if(m_syncMode == 3)
			setup.Mode = (BYTE)HDTV_MODE_INVERTED_TRILEVEL | ((BYTE)HDTV_STD_1080 << 3);
		else
		{
			MainCleanup();
			return err_BADPARAMETER( m_modeString, L"TriLevel Sync Mode (sync_mode)");
		}
	}
	else
	{
		err_BADPARAMETER( m_modeString, L"hdtv_mode" );
		return FALSE;
	}

	//Set the message variables equal to values obtained from ini file.
	setup.wPixelThreshold = m_wPixelThreshold;
	setup.wHSyncThreshold = m_wHSyncThreshold;
	setup.wVSyncThreshold = m_wVSyncThreshold;
	setup.hSyncPolarity = 0;
	setup.vSyncPolarity = 1;
	setup.wStartLine = m_wStartLine;
	setup.wNumLines = m_wNumLines;
	setup.wNumSamples = m_wNumSamples;
	setup.hDelay = m_hDelay;
		
	
	
	ReportDebug(DEBUG_LEVEL1, _T("SetupData: pixelthresh=%hu, hsyncthresh=%hu, vsyncthresh=%hu, hsyncpol=%d, vsyncpol=%d\n"),
								m_wPixelThreshold, m_wHSyncThreshold, m_wVSyncThreshold, setup.hSyncPolarity, setup.vSyncPolarity);
	
	ReportDebug(DEBUG_LEVEL1, _T("DAC_Data: StartLine=%hu, NumLines=%hu, Samples=%hu, hDelay=%d\n"),
								m_wStartLine, m_wNumLines, m_wNumSamples, m_hDelay);
	
	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_HDVMU_GET_ANALOG_COLORS, (char *)&setup, sizeof(setup), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, 180)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			if (err_HostResponseError(m_modeString, dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				return FALSE;
		}
		else
		{
			// Process a communication error
			if (err_HostCommunicationError(m_modeString, iError))
				return FALSE;
		}
	}
	else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
	{
		// The response buffer is NULL - we are expecting a pointer to some data, uh-oh.
		if (err_HostResponseBufferIsNull(m_modeString))
			return FALSE;
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		pColorData = (COLOR_SAMPLE *) new COLOR_SAMPLE[m_wNumLines];
		memcpy(pColorData, (COLOR_SAMPLE *)CHR.pvBufferFromHost, (sizeof(COLOR_SAMPLE) * m_wNumLines));
		
		//The trilevel sync test only gets one line of data for each measurement.
		ReportDebug(DEBUG_LEVEL1, _T("Received DAC Data: Line=1, GY=%lu, Pr=%lu, Pb=%lu\n"),
										pColorData[0].green,
										pColorData[0].red,
										pColorData[0].blue);
	}
	return TRUE;
}


// **************************************************************************************
// **************************************************************************************
//	CXModuleGrafx::HDTVTestCheckTrilevelSyncData()
//
//	Abstract:  Samples RGB data for each color according to user defined parameters.
//
// **************************************************************************************
// **************************************************************************************
BOOL CXModuleGrafx::HDTVTestCheckTrilevelSyncData()
{
	WORD wSyncLevel = 0;
	BOOL okay = FALSE;
	
	//Attempt to get the measurement as many times as allowed.
	//Sometimes the value could be bad because of unexpected noise.
	
	//Verify some of the required parameters before proceeding.
	if(m_syncMode < 2 || m_syncMode > 3)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"TriLevel Sync Mode (sync_mode)");
	}
	if(m_syncType == NULL)
	{
		MainCleanup();
		return err_BADPARAMETER( m_modeString, L"TriLevel Sync Type (sync_type)");
	}
	
	for(int i = 0; i < m_testRetries; i++)
	{
		if(!HDTVTestGetTrilevelSync())
		{
			okay = FALSE;
			goto sync_exit;
		}
		
		wSyncLevel = pColorData[0].green;
		ReportDebug(DEBUG_LEVEL1, _T("SyncLevel=%hu\n"), wSyncLevel);

		if((!wcsicmp(m_HDTVmode, L"480p")) && m_syncMode == 2 && (!wcsicmp(m_syncType, L"leading")) )
			ReportStatistic(_T("HDTV_480P_TRILEVEL_SYNC_MODE2_LEADING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"480p")) && m_syncMode == 2 && (!wcsicmp(m_syncType, L"trailing")) )
			ReportStatistic(_T("HDTV_480P_TRILEVEL_SYNC_MODE2_TRAILING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"720p")) && m_syncMode == 3 && (!wcsicmp(m_syncType, L"leading")) )
			ReportStatistic(_T("HDTV_720P_TRILEVEL_SYNC_MODE3_LEADING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"720p")) && m_syncMode == 2 && (!wcsicmp(m_syncType, L"leading")) )
			ReportStatistic(_T("HDTV_720P_TRILEVEL_SYNC_MODE2_LEADING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"720p")) && m_syncMode == 2 && (!wcsicmp(m_syncType, L"trailing")) )
			ReportStatistic(_T("HDTV_720P_TRILEVEL_SYNC_MODE2_TRAILING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"1080i")) && m_syncMode == 3 && (!wcsicmp(m_syncType, L"leading")) )
			ReportStatistic(_T("HDTV_1080I_TRILEVEL_SYNC_MODE3_LEADING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"1080i")) && m_syncMode == 2 && (!wcsicmp(m_syncType, L"leading")) )
			ReportStatistic(_T("HDTV_1080I_TRILEVEL_SYNC_MODE2_LEADING"),_T("%hu"),wSyncLevel);
		else if((!wcsicmp(m_HDTVmode, L"1080i")) && m_syncMode == 2 && (!wcsicmp(m_syncType, L"trailing")) )
			ReportStatistic(_T("HDTV_1080I_TRILEVEL_SYNC_MODE2_TRAILING"),_T("%hu"),wSyncLevel);

		if( wSyncLevel > m_GY_UpperThreshold)
		{
			//Error - out of spec on high range check.
			_stprintf(m_errorMsg, _T("(%s)Exceeds High Spec: Spec=%hu, Measured=%hu\n"), m_syncType, m_GY_UpperThreshold, wSyncLevel);
			err_HDVMUBadTrilevelSync(m_modeString, m_errorMsg);
			goto sync_exit;
		}
		
		if( wSyncLevel < m_GY_LowerThreshold)
		{
			//Error - out of spec on low range check.
			_stprintf(m_errorMsg, _T("(%s)Exceeds Low Spec: Spec=%hu, Measured=%hu\n"), m_syncType, m_GY_LowerThreshold, wSyncLevel);
			err_HDVMUBadTrilevelSync(m_modeString, m_errorMsg);
			goto sync_exit;
		}
		
	}//end for retries
	
	
	okay = TRUE;

sync_exit:
	if (pColorData) delete pColorData;

	return okay;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\vidmemory.cpp ===
//-----------------------------------------------------------------------------
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//
// vidmemory.cpp - Graphics test (Vidmemory) used to stress the video memory
//					functions of the graphics system.
//
// Member of:  Grafx Module for xmta test executive.
//
//-----------------------------------------------------------------------------
#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"
#include "rand32.h"

#define DEFAULT_RAND_SEED 0x6f39f1e5;
#define VIDMEM_MAX_SCENES 3

//******************************************************************
// Title: Vidmemory
//
// Abstract: Renders a 3D scene to a surface and performs various 
//				memory transfer operations beetween multiple surfaces
//				to stress the video memory systems.
//
//******************************************************************
IMPLEMENT_TESTLOCKED (Grafx, Vidmemory, 2)
{
	DWORD  crc, crc2;
	int numSurfaces = 0;
	
//#ifdef _DEBUG
	static int vidmemTestCount;
	vidmemTestCount++;
	ReportDebug(DEBUG_LEVEL1, _T("VideoMemory Test - Loop %d"), vidmemTestCount);
//#endif

			
	if (CheckAbort (HERE)) { MainCleanup(); return;}
	//Check for an initialized D3D Device.
	if(g_pd3dDevice == NULL)
	{
		//Error - the global device was not created successfully
		//or has become lost or invalid.
		err_NODIRECT3D(m_modeString);
		MainCleanup();
		return;
	}
	
	if(m_testScenes > VIDMEM_MAX_SCENES)
	{	//Error - invalid number of scenes for this test.
		err_BADPARAMETER( m_modeString, L"scenes");
		MainCleanup();
		return;
	}
		
	if(m_expectedCRC == 0xffffffff)
	{
		err_BADPARAMETER( m_modeString, L"crc" );
		MainCleanup();
		return;
	}

	if(m_mbytesTested < 2 || m_mbytesTested > 60)
	{
		err_BADPARAMETER( m_modeString, L"mbytes_tested");
		MainCleanup();
		return;
	}
	else//Make the value entered a 'megabyte' value
		m_mbytesTested *=1000000;
	
	if (CheckAbort (HERE)) { MainCleanup(); return;}	
	//Create additional surfaces to copy rendered image to.
	//This will stress the bit-blting processes and help verify as much video memory as possible.
	numSurfaces = VidmemInitSurfaces();
	if(numSurfaces == 0)
		return;//Fatal error - exit test.

	//Init the crc's to default values.
	crc = crc2 = 0x00000001;
	
	ReportDebug(DEBUG_LEVEL1, _T("Scenes to Render = %d\n"), m_testScenes);
	for(int loop=0; loop<m_testScenes; loop++)
	{
		if (CheckAbort (HERE)) { MainCleanup(); return;}
				
		//Render a scene based on loop count.
		if(!VidmemRender(loop))
		{	//Fatal error - exit test.
			MainCleanup();
			return;
		}
		
		//Present to force contents to frame buffer, then get the CRC.
		g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
		
		
		//*** This section commented out 7/5/2001 to allow parallel test execution - DJM.
		//if(m_hardwareCRC)
		//	crc = GetDisplayBufferCRC();
		//else
		//	crc = VidmemCalcCRC();
		//Output the measured crc for each scene.
		//ReportDebug(DEBUG_LEVEL1, _T("Starting CRC (loop %d) = 0x%x\n"), loop+1, crc);
		
		
		//Copy the contents of the first surface through all of the new surfaces.
		if(!CopySurfaces(numSurfaces))
		{	//Fatal error - exit test.
			OutputDebugString(_T("VIDMEMORY.CPP - Failed to CopySurfaces() from main test function!"));
			return;
		}
		
		//Output the final copied image to the screen.
		//To do this, copy the image info the the back buffer and then perform a present() to flip
		// the contents to the display.
		
		
		//Get the CRC value from the final surface.
		if(m_hardwareCRC)
			crc2 = GetDisplayBufferCRC();
		else
			crc2 = VidmemCalcCRC(m_pD3Ds[numSurfaces-1]);
		
		ReportDebug(DEBUG_LEVEL1, _T("Ending CRC after %d surface blts (loop %d) = 0x%x\n"), numSurfaces, loop+1, crc2);
		
		//Multiply the individual CRC's to generate a dependant composite CRC value.
		crc *= crc2;
		ReportDebug(DEBUG_LEVEL1, _T("Ending composite CRC (loop %d) = 0x%x\n"), loop+1, crc);
		
	}
		
	ReportDebug(DEBUG_LEVEL1, _T("CRC value to insert into the ini file for the expected test value: = 0x%x\n"), crc);
	if(crc != m_expectedCRC)
	{
		err_BADCRC(m_modeString, crc, m_expectedCRC, L"Final composite CRC.");
		if (CheckAbort (HERE)) { MainCleanup(); return;}
	}
	
	//Cleanup
	MainCleanup();

}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::VidmemRender(int mode)
{
	DWORD randSeed;

	// Clear the viewport
    switch(mode)
	{
		case 0: //Fill with gray - will fill with random noise later.
			g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00808080, 1.0f, 0L );
			break;
		
		case 1: //Fill with all white to drive data lines all high (1's)
			g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00FFFFFF, 1.0f, 0L );
			break;

		case 2: //Fill with all black to drive data lines all low (0's).
			g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );
			break;
	}
    
	//Default seed for randowm number generator.
	//Use a different seed for each mode to help eliminate false measurements.
	randSeed =  DEFAULT_RAND_SEED;
	//randSeed = randSeed * (DWORD)mode;

	// Begin the scene
    g_pd3dDevice->BeginScene();
    
	//Fill the background with suedo-randow noise based off of a known seed generated pattern.
	if(mode == 0)
	{
		if(!FillRand(randSeed))
			return FALSE;
	}

    // End the scene.
    g_pd3dDevice->EndScene();
    return TRUE;
}


DWORD CXModuleGrafx::VidmemCalcCRC()
{
	
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	LPDIRECT3DSURFACE8 lpSurface = NULL;
	int bytesPerLine;
	D3DSURFACE_DESC surfDesc;
	DWORD calcedCRC = 0;
	
	lpSurface = NULL;
	
	ReportDebug(DEBUG_LEVEL2, _T("Calculating CRC by obtaining front buffer\n"));
	
	//Since we have already presented the contents of the back buffer, we need
	//to get our data from the front buffer, hence the first argument of a -1. 
	if((hr = g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("3DSURFACE.CPP - Failed to GetFrontBuffer() for CRC calc!\n"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpSurface);
			MainCleanup();
			return 0;
		}
	}
	
	lpSurface->GetDesc( &surfDesc);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d bytes large\n"), surfDesc.Size);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d pixels wide and %d pixels high\n"), surfDesc.Width, surfDesc.Height);
	
	//Lock the rect to get pointer to starting address.
	hr = lpSurface->LockRect( &pLockedRect, NULL, NULL );
	if(hr != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed to LockRect() for surface CRC calc!\n"));
		ReportD3DError(hr);
		return 0;
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	//bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) ) >> 3;
	calcedCRC = UpdateImageRectCRC(m_dwDisplayHeight, pBits, pitch, bytesPerLine);
		
	//Unlock the locked surface.
	lpSurface->UnlockRect();
	SAFE_RELEASE(lpSurface);

	return calcedCRC;
}



DWORD CXModuleGrafx::VidmemCalcCRC(LPDIRECT3DSURFACE8 lpSurface)
{
	
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	int bytesPerLine;
	D3DSURFACE_DESC surfDesc;
	DWORD calcedCRC = 0;
	
	  
	ReportDebug(DEBUG_LEVEL2, _T("Calculatiing CRC with surface as argument\n"));

	lpSurface->GetDesc( &surfDesc);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d bytes large\n"), surfDesc.Size);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d pixels wide and %d pixels high\n"), surfDesc.Width, surfDesc.Height);
	
	//Lock the rect to get pointer to starting address.
	hr = lpSurface->LockRect( &pLockedRect, NULL, NULL );
	if(hr != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed to LockRect() for surface CRC calc!\n"));
		ReportD3DError(hr);
		return 0;
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	//bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) ) >> 3;
	ReportDebug(DEBUG_LEVEL1, _T("pitch= %d, bpl=%d\n"), pitch, bytesPerLine);
	calcedCRC = UpdateImageRectCRC(m_dwDisplayHeight, pBits, pitch, bytesPerLine);
		
	//Unlock the locked surface.
	lpSurface->UnlockRect();

	return calcedCRC;
}


//----------------------------------------------------------
//
// VidMemInitSurfaces()
//
//----------------------------------------------------------
int CXModuleGrafx::VidmemInitSurfaces()
{
	HRESULT hr;
	DWORD surfaceSize;
	MEMORYSTATUS stat;
	D3DSURFACE_DESC surfDesc;
    LPDIRECT3DSURFACE8 pBackBuffer;


	surfaceSize = 0;
	pBackBuffer = NULL;
	
	// Get render target surface desc
    g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );
    pBackBuffer->GetDesc( &surfDesc);
	SAFE_RELEASE(pBackBuffer);

	ReportDebug(DEBUG_LEVEL2, _T("Size of reference surface from descrip struct = %d\n"), surfDesc.Size);
	//Get size of reference surface.
	surfaceSize = surfDesc.Size;
	
	GlobalMemoryStatus (&stat);
		
	if(m_mbytesTested > stat.dwAvailPhys)
	{
		ReportWarning( _T("The amount of memory specified to test exceeds\n the amount of available free memory.\nA safe amount will be calculated to use.\n"));
		m_newSurfaces = (stat.dwAvailPhys / surfaceSize);
		if(m_newSurfaces > MAX_SURFACES)
		{
			//WARNING - more room for surfaces available than expected.
			//Report a warning that the number being used is less than the max available.
			ReportDebug(BIT0, _T("Using MAX_SURFACES value even though more memory may be available.\n"));
			m_newSurfaces = MAX_SURFACES;
		}
		ReportDebug(BIT0, _T("The following calculated safe\nvalues will be used for the test:\n"));
		ReportDebug(BIT0, _T("Surfaces=%d, Total memory tested=%lu bytes.\n"), m_newSurfaces, m_newSurfaces*surfaceSize);
	}
	else
	{
		m_newSurfaces = (m_mbytesTested / surfaceSize);
		if(m_newSurfaces > MAX_SURFACES)
		{
			//WARNING - more room for surfaces available than expected.
			//Report a warning that the number being used is less than the max available.
			ReportDebug(BIT0, _T("Using MAX_SURFACES value even though more memory may be available.\n"));
			m_newSurfaces = MAX_SURFACES;
		}
		ReportDebug(DEBUG_LEVEL1, _T("Surfaces=%d, Total memory tested=%lu bytes.\n"), m_newSurfaces, m_newSurfaces*surfaceSize);
		
	}
	
	//Create as many new surfaces as possible.
	//For now we will ignore any remainder resulting from the division
	//since this is a unified memory architecture.  The regular system 
	//memory tests will cover any memory we may miss here.
	//Create the surfaces required for the test.
	m_pD3Ds = new LPDIRECT3DSURFACE8 [m_newSurfaces];
	for(int i = 0; i < m_newSurfaces; i++)
	{
		m_pD3Ds[i] = NULL;
		if((hr = g_pd3dDevice->CreateImageSurface(	m_dwDisplayWidth,
													m_dwDisplayHeight,
													m_BackBufferFormat,
													&m_pD3Ds[i])) != D3D_OK)
		{
			//Error creating a surface
			ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed creating new surfaces!\n"));
			ReportD3DError(hr);
			return 0;
		}

		m_pD3Ds[i]->GetDesc( &surfDesc);
		ReportDebug(DEBUG_LEVEL2, _T("Surface %d is %d bytes large\n"), i, surfDesc.Size);
		ReportDebug(DEBUG_LEVEL2, _T("Surface %d is %d pixels wide and %d pixels high\n"), i, surfDesc.Width, surfDesc.Height);
		
		GlobalMemoryStatus (&stat);
		ReportDebug(DEBUG_LEVEL2, _T("There are %lu TOTAL bytes of physical memory.\n"), stat.dwTotalPhys);
		ReportDebug(DEBUG_LEVEL2, _T("There are %lu FREE bytes of physical memory.\n"), stat.dwAvailPhys);
		ReportDebug(DEBUG_LEVEL2, _T("%.2f percent of memory is available.\n"), ((float)stat.dwAvailPhys/(float)stat.dwTotalPhys)*100.0f);
	}
	
	return m_newSurfaces;
}


BOOL CXModuleGrafx::CopySurfaces(int numSurfaces)
{
	HRESULT hr;
	LPDIRECT3DSURFACE8 pFrontBuffer;
	LPDIRECT3DSURFACE8 pBackBuffer;

    
	//Flip the front buffer to the back buffer.
	
	//This get the originally rendered contents back into a buffer we can safely manipulate.
	//g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	g_pd3dDevice->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
	
	//XGWriteSurfaceToFile( IDirect3DSurface8* pSurf, const char* cPath);
//	XGWriteSurfaceToFile( pFrontBuffer, "d:\\surface.bmp");
	
	//Copy the backbuffer surface contents into the first new surface
	hr = g_pd3dDevice->CopyRects(pFrontBuffer, NULL, 0, m_pD3Ds[0], NULL);
	if(hr != D3D_OK)
	{	//Fatal error - exit test.
		SAFE_RELEASE(pFrontBuffer);
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed trying to perform first copySurfaces() for test!\n"));
		ReportD3DError(hr);
		MainCleanup();
		return FALSE;
	}

	//Present again so we don't have a distorted display.
	//g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	//Save the contents of this surface to compare to the original.
//	XGWriteSurfaceToFile( m_pD3Ds[0], "d:\\copied_surface.bmp");

	if (CheckAbort (HERE)) { MainCleanup(); return FALSE;}

	for(int i = 0; i < numSurfaces-1; i++)
	{
		hr = g_pd3dDevice->CopyRects(m_pD3Ds[i], NULL, 0, m_pD3Ds[i+1], NULL);
		if(hr != D3D_OK)
		{
			ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed trying to perform subsequent copySurfaces() for test!\n"));
			ReportD3DError(hr);
			if (CheckAbort (HERE)) { MainCleanup(); return FALSE;}
		}
		ReportDebug(DEBUG_LEVEL2, _T("VIDMEMORY.CPP - Copied surface %d to surface %d successfully!\n"), i, i+1);
	}

//	XGWriteSurfaceToFile( m_pD3Ds[numSurfaces-1], "d:\\final_copied_surface.bmp");
	
	g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
	//Copy the final surface contents into the backbuffer so we can present it to the display buffer.
	hr = g_pd3dDevice->CopyRects(m_pD3Ds[numSurfaces-1], NULL, 0, pBackBuffer, NULL);
	if(hr != D3D_OK)
	{	//Fatal error - exit test.
		SAFE_RELEASE(pBackBuffer);
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed trying to copySurfaces() from final copied surface to backBuffer!\n"));
		ReportD3DError(hr);
		MainCleanup();
		return FALSE;
	}
	
	//Present the contents to the display buffer so we can get a CRC check.
	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	  
	SAFE_RELEASE(pBackBuffer);
	SAFE_RELEASE(pFrontBuffer);

	return TRUE;
}


BOOL CXModuleGrafx::FillRand(DWORD seed)
{
	// Fill the rectangle in the image with random data based on seed
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	LPDIRECT3DSURFACE8 lpd3dSurface;
	int bytesPerLine;
	CRand32 rand;
	
	lpd3dSurface = NULL;
	
	if((hr = g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpd3dSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY.CPP - Failed to GetBackBuffer() for FillRand()!"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			MainCleanup();
			return 0;
		}
	}
	
	hr = lpd3dSurface->LockRect( &pLockedRect, NULL, NULL);
	if(hr != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	//bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) ) >> 3;
	
	rand.seed(seed);

	// Fill each line with random data, masking the first and last bytes as needed
	for (LONG line=0; line<(LONG)m_dwDisplayHeight; line++)
	{
		rand.fillBuffer(pBits, bytesPerLine);
		pBits += pitch;
	}

	lpd3dSurface->UnlockRect();
	SAFE_RELEASE(lpd3dSurface);
		
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xhard_disk\xdvd.cpp ===
#undef XHD_TAG
#define XHD_MAIN
#include "xdisk.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\vidmemory_patterns.cpp ===
//-----------------------------------------------------------------------------
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//
// vidmemory.cpp - Graphics test (Vidmemory) used to stress the video memory
//					functions of the graphics system.
//
// Member of:  Grafx Module for xmta test executive.
//
//-----------------------------------------------------------------------------
#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"
//#include "rand32.h"

#define DEFAULT_RAND_SEED 0x6f39f1e5;
//#define VIDMEM_MAX_SCENES 3

//******************************************************************
// Title: Vidmemory
//
// Abstract: Renders a 3D scene to a surface and performs various 
//				memory transfer operations beetween multiple surfaces
//				to stress the video memory systems.
//
//******************************************************************
IMPLEMENT_TESTLOCKED (Grafx, Vidmemory_patterns, 5)
{
	DWORD  crc, crc2;
	int numSurfaces = 0;
	
	if (CheckAbort (HERE)) { MainCleanup(); return;}
	//Check for an initialized D3D Device.
	if(g_pd3dDevice == NULL)
	{
		//Error - the global device was not created successfully
		//or has become lost or invalid.
		err_NODIRECT3D(m_modeString);
		MainCleanup();
		return;
	}
			
	if(m_expectedCRC == 0xffffffff)
	{
		err_BADPARAMETER( m_modeString, L"crc" );
		MainCleanup();
		return;
	}

	if(m_mbytesTested < 2 || m_mbytesTested > 60)
	{
		err_BADPARAMETER( m_modeString, L"mbytes_tested");
		MainCleanup();
		return;
	}
	else//Make the value entered a 'megabyte' value
		m_mbytesTested *=1000000;
	
	if (CheckAbort (HERE)) { MainCleanup(); return;}	
	
	
	ReportWarning(L"Bit pattern used=0x%x", m_vidmemPattern);
	
	//Create additional surfaces to copy rendered image to.
	//This will stress the bit-blting processes and help verify as much video memory as possible.
	numSurfaces = VidmemPatternInitSurfaces();
	if(numSurfaces == 0)
		return;//Fatal error - exit test.

	//Init the crc's to default values.
	crc = crc2 = 0x00000001;
	
	if (CheckAbort (HERE)) { MainCleanup(); return;}
			
	//Render a scene based on loop count.
	if(!VidmemPatternRender())
	{	//Fatal error - exit test.
		MainCleanup();
		return;
	}
	
	//Present to force contents to frame buffer, then get the CRC.
	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	
	if(m_secondsToDisplay)
		Sleep(m_secondsToDisplay);	
	
	
	//*** This section commented out 7/5/2001 to allow parallel test execution - DJM.
	/*	
	if(m_hardwareCRC)
		crc = GetDisplayBufferCRC();
	else
		crc = VidmemPatternCalcCRC();
	//Output the measured crc for each scene.
	ReportDebug(DEBUG_LEVEL1, _T("Starting CRC = 0x%x\n"), crc);
	
	if(crc != m_expectedCRC)
	{
		err_BADCRC(m_modeString, crc, m_expectedCRC, L"Starting CRC.");
		if (CheckAbort (HERE)) { MainCleanup(); return;}
	}
	*/
	
	//Copy the contents of the first surface through all of the new surfaces.
	if(!VidmemPatternCopySurfaces(numSurfaces))
	{	//Fatal error - exit test.
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERN.CPP - Failed to CopySurfaces() from main test function!"));
		return;
	}
	
	//Output the final copied image to the screen.
	//To do this, copy the image info the the back buffer and then perform a present() to flip
	// the contents to the display.
	
	
	//Get the CRC value from the final surface.
	if(m_hardwareCRC)
		crc2 = GetDisplayBufferCRC();
	else
		crc2 = VidmemPatternCalcCRC(m_pD3Ds[numSurfaces-1]);
	
	ReportDebug(DEBUG_LEVEL1, _T("Ending CRC after %d surface blts = 0x%x\n"), numSurfaces, crc2);
	
	ReportDebug(DEBUG_LEVEL1, _T("If this was done on known good hardware, \nthe CRC value to insert into the ini file for the expected test value: = 0x%x\n"), crc2);
	if(crc2 != m_expectedCRC)
	{
		err_BADCRC(m_modeString, crc2, m_expectedCRC, L"Final CRC.");
		if (CheckAbort (HERE)) { MainCleanup(); return;}
	}
	
	//Cleanup
	MainCleanup();

}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
BOOL CXModuleGrafx::VidmemPatternRender()
{

	g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0xFF000000, 1.0f, 0L );
    
	//Default seed for randowm number generator.
	//Use a different seed for each mode to help eliminate false measurements.

	// Begin the scene
    g_pd3dDevice->BeginScene();
    
	//Fill the background with suedo-randow noise based off of a known seed generated pattern.
	if(!FillSurfaceWithPattern(m_vidmemPattern))
		return FALSE;

    // End the scene.
    g_pd3dDevice->EndScene();
    return TRUE;
}


DWORD CXModuleGrafx::VidmemPatternCalcCRC()
{
	
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	LPDIRECT3DSURFACE8 lpSurface = NULL;
	int bytesPerLine;
	D3DSURFACE_DESC surfDesc;
	DWORD calcedCRC = 0;
	
	lpSurface = NULL;
	
	ReportDebug(DEBUG_LEVEL2, _T("Calculating CRC by obtaining front buffer\n"));
	
	//Since we have already presented the contents of the back buffer, we need
	//to get our data from the front buffer, hence the first argument of a -1. 
	if((hr = g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEM_PATTERN.CPP - Failed to GetFrontBuffer() for CRC calc!\n"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpSurface);
			MainCleanup();
			return 0;
		}
	}
	
	lpSurface->GetDesc( &surfDesc);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d bytes large\n"), surfDesc.Size);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d pixels wide and %d pixels high\n"), surfDesc.Width, surfDesc.Height);
	
	//Lock the rect to get pointer to starting address.
	hr = lpSurface->LockRect( &pLockedRect, NULL, NULL );
	if(hr != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERN.CPP - Failed to LockRect() for surface CRC calc!\n"));
		ReportD3DError(hr);
		return 0;
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	//bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) ) >> 3;
	calcedCRC = UpdateImageRectCRC(m_dwDisplayHeight, pBits, pitch, bytesPerLine);
		
	//Unlock the locked surface.
	lpSurface->UnlockRect();
	SAFE_RELEASE(lpSurface);

	return calcedCRC;
}



DWORD CXModuleGrafx::VidmemPatternCalcCRC(LPDIRECT3DSURFACE8 lpSurface)
{
	
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	int bytesPerLine;
	D3DSURFACE_DESC surfDesc;
	DWORD calcedCRC = 0;
	
	  
	ReportDebug(DEBUG_LEVEL2, _T("Calculatiing CRC with surface as argument\n"));

	lpSurface->GetDesc( &surfDesc);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d bytes large\n"), surfDesc.Size);
	ReportDebug(DEBUG_LEVEL2, _T("Surface in CRC is %d pixels wide and %d pixels high\n"), surfDesc.Width, surfDesc.Height);
	
	//Lock the rect to get pointer to starting address.
	hr = lpSurface->LockRect( &pLockedRect, NULL, NULL );
	if(hr != D3D_OK)
	{
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERN.CPP - Failed to LockRect() for surface CRC calc!\n"));
		ReportD3DError(hr);
		return 0;
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	//bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) ) >> 3;
	ReportDebug(DEBUG_LEVEL1, _T("pitch= %d, bpl=%d\n"), pitch, bytesPerLine);
	calcedCRC = UpdateImageRectCRC(m_dwDisplayHeight, pBits, pitch, bytesPerLine);
		
	//Unlock the locked surface.
	lpSurface->UnlockRect();

	return calcedCRC;
}


//----------------------------------------------------------
//
// VidMemInitSurfaces()
//
//----------------------------------------------------------
int CXModuleGrafx::VidmemPatternInitSurfaces()
{
	HRESULT hr;
	DWORD surfaceSize;
	MEMORYSTATUS stat;
	D3DSURFACE_DESC surfDesc;
    LPDIRECT3DSURFACE8 pBackBuffer;


	surfaceSize = 0;
	pBackBuffer = NULL;
	
	// Get render target surface desc
    g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );
    pBackBuffer->GetDesc( &surfDesc);
	SAFE_RELEASE(pBackBuffer);

	ReportDebug(DEBUG_LEVEL2, _T("Size of reference surface from descrip struct = %d\n"), surfDesc.Size);
	//Get size of reference surface.
	surfaceSize = surfDesc.Size;
	
	GlobalMemoryStatus (&stat);
		
	if(m_mbytesTested > stat.dwAvailPhys)
	{
		ReportWarning( _T("The amount of memory specified to test exceeds\n the amount of available free memory.\nA safe amount will be calculated to use.\n"));
		m_newSurfaces = (stat.dwAvailPhys / surfaceSize);
		if(m_newSurfaces > MAX_SURFACES)
		{
			//WARNING - more room for surfaces available than expected.
			//Report a warning that the number being used is less than the max available.
			ReportDebug(BIT0, _T("Using MAX_SURFACES value even though more memory may be available.\n"));
			m_newSurfaces = MAX_SURFACES;
		}
		ReportDebug(BIT0, _T("The following calculated safe\nvalues will be used for the test:\n"));
		ReportDebug(BIT0, _T("Surfaces=%d, Total memory tested=%lu bytes.\n"), m_newSurfaces, m_newSurfaces*surfaceSize);
	}
	else
	{
		m_newSurfaces = (m_mbytesTested / surfaceSize);
		if(m_newSurfaces > MAX_SURFACES)
		{
			//WARNING - more room for surfaces available than expected.
			//Report a warning that the number being used is less than the max available.
			ReportDebug(BIT0, _T("Using MAX_SURFACES value even though more memory may be available.\n"));
			m_newSurfaces = MAX_SURFACES;
		}
		ReportDebug(DEBUG_LEVEL1, _T("Surfaces=%d, Total memory tested=%lu bytes.\n"), m_newSurfaces, m_newSurfaces*surfaceSize);
		
	}
	
	//Create as many new surfaces as possible.
	//For now we will ignore any remainder resulting from the division
	//since this is a unified memory architecture.  The regular system 
	//memory tests will cover any memory we may miss here.
	//Create the surfaces required for the test.
	m_pD3Ds = new LPDIRECT3DSURFACE8 [m_newSurfaces];
	for(int i = 0; i < m_newSurfaces; i++)
	{
		m_pD3Ds[i] = NULL;
		if((hr = g_pd3dDevice->CreateImageSurface(	m_dwDisplayWidth,
													m_dwDisplayHeight,
													m_BackBufferFormat,
													&m_pD3Ds[i])) != D3D_OK)
		{
			//Error creating a surface
			ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERN.CPP - Failed creating new surfaces!\n"));
			ReportD3DError(hr);
			return 0;
		}

		m_pD3Ds[i]->GetDesc( &surfDesc);
		ReportDebug(DEBUG_LEVEL2, _T("Surface %d is %d bytes large\n"), i, surfDesc.Size);
		ReportDebug(DEBUG_LEVEL2, _T("Surface %d is %d pixels wide and %d pixels high\n"), i, surfDesc.Width, surfDesc.Height);
		
		GlobalMemoryStatus (&stat);
		ReportDebug(DEBUG_LEVEL2, _T("There are %lu TOTAL bytes of physical memory.\n"), stat.dwTotalPhys);
		ReportDebug(DEBUG_LEVEL2, _T("There are %lu FREE bytes of physical memory.\n"), stat.dwAvailPhys);
		ReportDebug(DEBUG_LEVEL2, _T("%.2f percent of memory is available.\n"), ((float)stat.dwAvailPhys/(float)stat.dwTotalPhys)*100.0f);
	}
	
	return m_newSurfaces;
}


BOOL CXModuleGrafx::VidmemPatternCopySurfaces(int numSurfaces)
{
	HRESULT hr;
	LPDIRECT3DSURFACE8 pFrontBuffer;
	LPDIRECT3DSURFACE8 pBackBuffer;

    
	//Flip the front buffer to the back buffer.
	
	//This get the originally rendered contents back into a buffer we can safely manipulate.
	//g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	g_pd3dDevice->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
	
	//XGWriteSurfaceToFile( IDirect3DSurface8* pSurf, const char* cPath);
	XGWriteSurfaceToFile( pFrontBuffer, "z:\\surface.bmp");
	
	//Copy the backbuffer surface contents into the first new surface
	hr = g_pd3dDevice->CopyRects(pFrontBuffer, NULL, 0, m_pD3Ds[0], NULL);
	if(hr != D3D_OK)
	{	//Fatal error - exit test.
		SAFE_RELEASE(pFrontBuffer);
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERN.CPP - Failed trying to perform first copySurfaces() for test!\n"));
		ReportD3DError(hr);
		MainCleanup();
		return FALSE;
	}

	//Present again so we don't have a distorted display.
	//g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	//Save the contents of this surface to compare to the original.
	XGWriteSurfaceToFile( m_pD3Ds[0], "z:\\copied_surface.bmp");

	if (CheckAbort (HERE)) { MainCleanup(); return FALSE;}

	for(int i = 0; i < numSurfaces-1; i++)
	{
		hr = g_pd3dDevice->CopyRects(m_pD3Ds[i], NULL, 0, m_pD3Ds[i+1], NULL);
		if(hr != D3D_OK)
		{
			ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERNS.CPP - Failed trying to perform subsequent copySurfaces() for test!\n"));
			ReportD3DError(hr);
			if (CheckAbort (HERE)) { MainCleanup(); return FALSE;}
		}
		ReportDebug(DEBUG_LEVEL2, _T("VIDMEMORY_PATTERNS.CPP - Copied surface %d to surface %d successfully!\n"), i, i+1);
	}

//	XGWriteSurfaceToFile( m_pD3Ds[numSurfaces-1], "d:\\final_copied_surface.bmp");
	
	g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
	//Copy the final surface contents into the backbuffer so we can present it to the display buffer.
	hr = g_pd3dDevice->CopyRects(m_pD3Ds[numSurfaces-1], NULL, 0, pBackBuffer, NULL);
	if(hr != D3D_OK)
	{	//Fatal error - exit test.
		SAFE_RELEASE(pBackBuffer);
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERNS.CPP - Failed trying to copySurfaces() from final copied surface to backBuffer!\n"));
		ReportD3DError(hr);
		MainCleanup();
		return FALSE;
	}
	
	//Present the contents to the display buffer so we can get a CRC check.
	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	  
	SAFE_RELEASE(pBackBuffer);
	SAFE_RELEASE(pFrontBuffer);

	return TRUE;
}



//******************************************************
//
// This function fills the display surface with a WORD bit pattern defined as
// a parameter from the INI file.
//
//******************************************************
BOOL CXModuleGrafx::FillSurfaceWithPattern(BYTE pattern)
{
	// Fill the rectangle in the image with random data based on seed
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	LPDIRECT3DSURFACE8 lpd3dSurface;
	int bytesPerLine;
//	CRand32 rand;
	
	lpd3dSurface = NULL;
	
	if((hr = g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpd3dSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(DEBUG_LEVEL1, _T("VIDMEMORY_PATTERN.CPP - Failed to GetBackBuffer() for FillRand()!"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			MainCleanup();
			return 0;
		}
	}
	
	hr = lpd3dSurface->LockRect( &pLockedRect, NULL, NULL);
	if(hr != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}
	pBits = (BYTE *)pLockedRect.pBits;
	pitch = pLockedRect.Pitch;
	bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) + 7) >> 3;
	//bytesPerLine = ((m_bpp * (m_dwDisplayWidth)) ) >> 3;
	
	//rand.seed(seed);

	// Fill each line with random data, masking the first and last bytes as needed
	for (LONG line=0; line<(LONG)m_dwDisplayHeight; line++)
	{
		FillBuffer(pBits, bytesPerLine, pattern);
		pBits += pitch;
	}

	lpd3dSurface->UnlockRect();
	SAFE_RELEASE(lpd3dSurface);
		
	return TRUE;
}



//Fills in the DWORD aligned part of the buffer.
void CXModuleGrafx::FillBuffer(unsigned long *start_address, int count, unsigned char pattern)
{
	unsigned long data = 0, temp = 0;
	
	if (count <= 0) return;

	temp=(unsigned long)pattern;

	data = data | (pattern<<24);
	data = data | (pattern<<16);
	data = data | (pattern<<8);
	data = data | pattern;

	while (count--)
	{
		*start_address++ =  data;
		//*start_address++ =  ((unsigned long)pattern << 17) ^ ((unsigned long)pattern << 6) ^ (unsigned long)pattern;
	}
}


void CXModuleGrafx::FillBuffer(unsigned char *start_address, int count, unsigned char pattern)
{
	int byteCount;

	//Avoid warnings.
	byteCount	= 0;
	
	if (count <= 0) return;
	// Be sure start_address is DWORD aligned
	if (byteCount = ((int)start_address & 3))
	{
		byteCount = 4 - byteCount;
		if (byteCount > count) byteCount = count;
		while (byteCount--)
		{
			*start_address++ = pattern;
			count--;
		}
	}

	// Fill DWORD aligned part of buffer
	count >>= 2;
	FillBuffer((unsigned long *)start_address, count, pattern);

	// Fill trailing bytes
	start_address += count << 2;
	while (byteCount--)
	{
		*start_address++ = pattern;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\xgrafx.h ===
//-----------------------------------------------------------------------------
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//
// xgrafx.h - Graphics testing module for xmta.
//
//-----------------------------------------------------------------------------
#ifndef _XGRAFX_H_
#define _XGRAFX_H_

#include "..\..\parameter.h"
#include "XBUtil.h"
#include <xgraphics.h>

//Disable futile warnings...
#pragma warning (disable:4238)//non-standard extensions
#pragma warning (disable:4245)//type conversion for GetBackBuffer() with -1 as argument.

//Debug levels for message output.
#define DEBUG_LEVEL1 0x1		//High level, few messages
#define DEBUG_LEVEL2 0x2		//Moderate level, more messages
#define DEBUG_LEVEL3 0x4		//Low Level, very detailed, lots of messages
#define MAX_SURFACES 49			//Max number of surafces that can safely be created.
#define DEFAULT_CRC  0x8a2d91f5	//Default starting CRC value.

#define MAX_VIDMODES     9		//Max number of video modes to be tested.


#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif


// A structure for our custom vertex type
struct SHAPES_TEST_CUSTOMVERTEX
{
    FLOAT x, y, z;      // The untransformed, 3D position for the vertex
    DWORD color;        // The vertex color
};

//Struct for the projected vertex.
struct PROJTEXVERTEX
{
    D3DXVECTOR3 p;
    D3DCOLOR    color;
};

// projection frustrum
struct LINEVERTEX
{
    FLOAT x, y, z;
    DWORD color;
};


extern "C"
{
void __cdecl D3DTest_ChecksumCallback(DWORD Frame);

void __stdcall D3DTest_GetScreenChecksum( DWORD *pRed, DWORD *pGreen, DWORD *pBlue);

}



class CXModuleGrafx : public CTestObj
{
public:
	DECLARE_XMTAMODULE (CXModuleGrafx, "grafx", MODNUM_GRAFX);


protected:	
    //-----------------------------------
	//Parameters used by all grafx tests.
	//-----------------------------------
	D3DPRESENT_PARAMETERS	m_d3dpp;
	DWORD					m_dwDisplayWidth;
    DWORD					m_dwDisplayHeight;
    D3DFORMAT				m_DepthBufferFormat; // Format used to create depthbuffer
    D3DFORMAT				m_BackBufferFormat;  // Format used to create depthbuffer
	int						m_vidMode;
	int						m_bpp;
	DWORD					m_expectedCRC;
	int						m_testScenes;
	TCHAR					m_debugMsg[128]; //Used to output debug message strings
	TCHAR					m_errorMsg[128]; 
	static int				m_surfaceTestCount;
	static int				m_vidmemTestCount;
	static int				m_shapesTestCount;
	BOOL					m_hardwareCRC;
	TCHAR					m_modeString[64];


	virtual bool InitializeParameters();
//	BOOL	InitializeDisplay(int mode);
	DWORD   UpdateImageRectCRC(LONG height, BYTE *pBits, LONG pitch, int bytesPerLine);
	DWORD	GetDisplayBufferCRC();
	VOID	ReportD3DError(DWORD error);
	VOID	MainCleanup();

	
	//-------------------------------------
	//Paremeters used by the 3DSurface Test
	//-------------------------------------
	WORD                m_wIndex[32];					//Triangle light index data
	LPDIRECT3DTEXTURE8  m_pSpotLightTexture;			//procedurally generated spotlight texture
	D3DXMATRIX          m_matTexProj;					//texture projection matrix
	D3DXVECTOR3         m_vTexEyePt;					//texture eye pt.
	D3DXVECTOR3         m_vTexLookatPt;					//texture lookat pt.
	LPDIRECT3DVERTEXBUFFER8 m_pBackgroundVB;	
	PROJTEXVERTEX       m_vCube[36];
	LINEVERTEX			m_lineVertex[8];

	BOOL	SurfTestInitDisplayObjects();
	BOOL	SurfTestFrameMove(D3DXMATRIX* pMatWorld);
    VOID	SurfTestRender(int scene);
	DWORD   SurfTestCalcCRC(DWORD crc);
	BOOL	CreateSpotLightTexture(BOOL bBorder);
	VOID	ShowTexture( LPDIRECT3DTEXTURE8 pTexture );
	VOID	CalculateTexProjMatrix();
	HRESULT DisplayGradientBackground(int scene);

	//-------------------------------------
	//Paremeters used by the Vidmemory Test
	//-------------------------------------
	//LPDIRECT3DSURFACE8  m_pD3DsVidMemory;
	LPDIRECT3DSURFACE8	m_pBackBuffer;  
	LPDIRECT3DSURFACE8*	m_pD3Ds;		//Surfaces to be used to copy to.
	int					m_newSurfaces;
	DWORD				m_mbytesTested;
	
    BOOL	VidmemRender(int mode);
	DWORD   VidmemCalcCRC();
	DWORD   VidmemCalcCRC(LPDIRECT3DSURFACE8 lpd3dsurface);
	int		VidmemInitSurfaces();
	BOOL	CopySurfaces(int numSurfaces);
	BOOL	FillRand(DWORD seed);


	//---------------------------------------------
	//Paremeters used by the Vidmemory Pattern Test
	//---------------------------------------------
	BYTE	m_vidmemPattern;//Bit pattern used to fill surface.
	
	BOOL	VidmemPatternRender();
	DWORD   VidmemPatternCalcCRC();
	DWORD   VidmemPatternCalcCRC(LPDIRECT3DSURFACE8 lpd3dsurface);
	int		VidmemPatternInitSurfaces();
	BOOL	VidmemPatternCopySurfaces(int numSurfaces);
	BOOL	FillSurfaceWithPattern(BYTE pattern);
	void	FillBuffer(unsigned long *start_address, int count, unsigned char pattern);
	void	FillBuffer(unsigned char *start_address, int count, unsigned char pattern);


	//-------------------------------------
	//Paremeters used by the Shapes Test
	//-------------------------------------
	LPDIRECT3DVERTEXBUFFER8		m_pVB; // Buffer to hold triangle vertices
	LPDIRECT3DVERTEXBUFFER8		m_pVB2; // Buffer to hold triangle vertices
	LPDIRECT3DVERTEXBUFFER8		m_pVB3; // Buffer to hold triangle vertices
	SHAPES_TEST_CUSTOMVERTEX*	m_pTriangles;
	SHAPES_TEST_CUSTOMVERTEX*	m_pTriangles2;
	SHAPES_TEST_CUSTOMVERTEX*	m_pTriangles3;
	int							m_numTriangles;
	
	BOOL	ShapeTestInitD3D();
	VOID	ShapeTestRender(float angle);
	DWORD	ShapeTestCalcCRC(DWORD crc);
	BOOL	ShapeTestInitGeometry();
	VOID	ShapeTestSetupMatrices(float angle);
	VOID	ShapeTestInitTriangles();
	
	//-------------------------------------
	//Paremeters used by the HDTV Test
	//-------------------------------------
	LPDIRECT3DVERTEXBUFFER8 m_pHDTVPatternVB; // Buffer to hold vertices
	LPCTSTR m_HDTVTestPattern;
	LPCTSTR m_HDTVmode;
	DWORD	m_dwTolerance;
	int		m_testRetries;
	int		m_secondsToDisplay;
	
	WORD	m_wPixelThreshold, m_wThresholdRangeStep, m_wHSyncThreshold, m_wVSyncThreshold;
	DWORD	m_dwExpectedGreenCount, m_dwExpectedRedCount, m_dwExpectedBlueCount;
	int		m_PixelCountPattern, m_PatternSections;
	BOOL	m_bBitmapFromFile;
	TCHAR	m_BitmapFileName[64];
	
	BYTE	m_VertFrontPorch1, m_VertBackPorch1, m_VertFrontPorch2, m_VertBackPorch2;
	WORD	m_wVertSyncLow, m_wVertSyncHigh;
	WORD	m_wHorizBackPorch, m_wHorizFrontPorch;
	WORD	m_wHorizSyncLow, m_wHorizSyncHigh;
	
	
	//DAC parameters
	WORD	m_wStartLine, m_wNumLines, m_wNumSamples;
	BYTE	m_hDelay;
	BOOL	m_bInterlaced;
	WORD	m_GY_LowerThreshold, m_BPb_LowerThreshold, m_RPr_LowerThreshold;
	WORD	m_GY_UpperThreshold, m_BPb_UpperThreshold, m_RPr_UpperThreshold;
	WORD	m_wLinearTolerance;
	int		m_totalDacLines;
	struct COLOR_SAMPLE *pColorData;

	//TriLevel Sync parameters
	int		m_syncMode;
	LPCTSTR m_syncType;

	
	BOOL	HDTVTestInitPixelCountPattern(int pattern);
	VOID	HDTVTestGetBitmapFromHost();
	BOOL	HDTVTestPixelPattern01();
	BOOL	HDTVTestPixelPattern02();
	BOOL	HDTVTestPixelPattern03();
	BOOL	HDTVTestPixelPattern04();
	BOOL	HDTVTestPixelPattern05();
	BOOL	HDTVTestPixelPattern06();
	BOOL	HDTVTestPixelPattern07();
	BOOL	HDTVTestPixelPattern08();
	BOOL	HDTVTestPixelPattern09();
	BOOL	HDTVTestPixelPattern10();
	BOOL	HDTVTestPixelPattern11();
	BOOL	HDTVTestPixelPattern12();
	BOOL	HDTVTestPixelPattern13();
	BOOL	HDTVTestPixelPattern14();
	VOID	HDTVTestPixelCountRender();
	BOOL	HDTVTestGetPixelcounts(struct GET_ANALOG_PIXEL_COUNT_DATA *pReturnedData);
	BOOL    HDTVTestCheckPixelcountData();
	BOOL	HDTVTestInitDacPattern();
	VOID	HDTVTestAnalogColorsRender();
	VOID	HDTVTestBackgroundRender(int r, int g, int b);
	BOOL	HDTVTestGetTimings(struct GET_TIMINGS_DATA *pReturnedData);
	BOOL	HDTVTestCheckTimingsData();
	BOOL	HDTVTestCheckMeasuredTimings(bool reportError, struct GET_TIMINGS_DATA *data);
	BOOL	HDTVTestCheckTimingResult(bool reportError, WORD val, WORD ref, DWORD tol, TCHAR *msg);
	BOOL	HDTVTestGetAnalogColors();
	BOOL	HDTVTestCheckAnalogColorsData();
	BOOL	HDTVTestGetTrilevelSync();
	BOOL	HDTVTestCheckTrilevelSyncData();

	//---------------------------------------
	// Error messages declared here
	//(Note: 0x000 - 0x00f reserved for XMTA)
	//---------------------------------------
	bool err_BADPARAMETER (LPCTSTR mode, LPCTSTR s1)
	{
		ReportError (0x090, L"(%s) Failed to find or invalid value for configuration parameter \"%s\"\nThis configuration parameter doesn't exist or is invalid", mode, s1); return (CheckAbort (HERE));
	}
	bool err_NODIRECT3D (LPCTSTR mode)
	{
		ReportError (0x091, L"(%s)Failed to create the Direct3D Device - check for proper DirectX runtime installation.", mode); return (CheckAbort (HERE));
	}
	bool err_NOCREATEWINDOW (LPCTSTR mode)
	{
		ReportError (0x092, L"(%s)Failed to create the primary window to render to."); return (CheckAbort (HERE));
	}
	bool err_BADVIDEOMODE (int mode)
	{
		ReportError (0x093, L"The videomode selected (mode=%d) does not exist.\n Check the 'videomode' parameter in the ini file.", mode); return (CheckAbort (HERE));
	}
	bool err_BADCRC (LPCTSTR mode, DWORD dwCalc, DWORD dwExpect, LPCTSTR s1)
	{
		ReportError (0x094, L"(%s)The CRC calculated (0x%x) did not match the expected value (0x%x) - %s", mode, dwCalc, dwExpect, s1); return (CheckAbort (HERE));
	}
	bool err_NOCREATESURFACE (LPCTSTR mode, LPCTSTR s1)
	{
		ReportError (0x095, L"(%s)Failed to create a D3D Surface - (%s)", mode, s1); return (CheckAbort (HERE));
	}
	bool err_HostCommunicationError (LPCTSTR mode, int i1)
	{
		ReportError (0x096, L"(%s)iSendHost communication routine returned an error code of 0x%x", mode, i1); return (CheckAbort (HERE)); 
	}
	bool err_HostResponseBufferIsNull (LPCTSTR mode)
	{
		ReportError (0x097, L"(%s)The response buffer received from the host command is empty", mode); return (CheckAbort (HERE)); 
	}
	bool err_BufferContentsMismatch (LPCTSTR s1, LPCTSTR s2)
	{
		ReportError (0x098, L"Echo mismatch!  Sent string does not match response string.\nSent string: %s\nResponse string: %s", s1, s2); return (CheckAbort (HERE)); 
	}
	bool err_HDVMUBadPixelCount (LPCTSTR mode, LPCTSTR s1)
	{
		ReportError (0x099, L"(%s)HDVMU Pixelcount Error - %s", mode, s1); return (CheckAbort (HERE)); 
	}
	bool err_HDVMUBadTiming (LPCTSTR mode, LPCTSTR s1)
	{
		ReportError (0x09A, L"(%s)HDVMU Timings Error - %s", mode, s1); return (CheckAbort (HERE));
	}
	bool err_HDVMUBadDAC (LPCTSTR mode, LPCTSTR s1)
	{
		ReportError (0x09B, L"(%s)HDVMU DAC Error - %s", mode, s1); return (CheckAbort (HERE));
	}
	bool err_HDVMUBadTrilevelSync (LPCTSTR mode, LPCTSTR s1)
	{
		ReportError (0x09C, L"(%s)HDVMU TrilevelSync Error - %s", mode, s1); return (CheckAbort (HERE));
	}
	bool err_HostResponseError (LPCTSTR mode, DWORD dwErrorCodeFromHost, LPCTSTR s1)
	{
		ReportError ((unsigned short)dwErrorCodeFromHost, L"(%s)The host responded with the following error message:\n%s", mode, s1); return (CheckAbort (HERE)); 
	}
	//Default message for general DirectX API error.
	bool err_DIRECTX_API (LPCTSTR mode, HRESULT hr, LPCTSTR s1) //Default DirectX API error message
	{
		ReportError (0x09F, L"(%s)A DirectX API returned error 0x%08lx (%s).", mode, hr, s1 ); return (CheckAbort (HERE));
	}
	

};

#endif //_XGRAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xhard_disk\xdisk.cpp ===
#ifdef XHD_MAIN
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// Title: xHardDisk
//
// History:
//
// 02/13/01 V0.01 BLI Just started working on the test module
/*
// Including these definitions here for quick reference.
D: The DVD Player. On the development console only, if the title is launched from the hard disk, D:\ will be mapped to the directory that the title was launched from, rather than being mapped to the DVD player. 
E: This drive does not actually exist on the console. It is used solely by the Xbox Development Kit as the drive where development titles are copied to the Xbox development console for execution. 
F: The title's user data on the MU located in the top slot of port 0. 
G: The title's user data on the MU located in the bottom slot of port 0. 
H: The title's user data on the MU located in the top slot of port 1. 
I: The title's user data on the MU located in the bottom slot of port 1. 
J: The title's user data on the MU located in the top slot of port 2. 
K: The title's user data on the MU located in the bottom slot of port 2. 
L: The title's user data on the MU located in the top slot of port 3. 
M: The title's user data on the MU located in the bottom slot of port 3. 
S: On the development console only, the root directory of the persistent data region, under which each title's specific persistent data directory resides. 
T: The title's persistent data region. 
U: The title's user data region on the hard disk. 
V: On the development console only, the root directory of the user data region, under which each title's specific user data directory resides. 
W: Used to map another title's user data region (from disk or an MU). 
X: Used to map another title's persistent data region. 
Y: Unused 
Z: The title's utility data region. 
*/

#include "..\stdafx.h"
#include "..\testobj.h"
#include "..\statkeys.h"
#include "xhard_disk.h"

#ifdef XHD_TAG
IMPLEMENT_MODULEUNLOCKED (CXModuleHardDisk);
#else
IMPLEMENT_MODULEUNLOCKED (CXModuleDVD);
#endif

// HardDisk test number definitions
#define FREE_SPACE_RANDOM_WRC           1
#define PHYSICAL_DEVICE_SEQUENTIAL_READ 2
#define FILE_SYSTEM_CHECKSUM            3
#define FILE_SEQUENTIAL_READ            4
#define DVD_RANDOM_READ                 5

#ifdef XHD_TAG
bool CXModuleHardDisk::InitializeParameters ()
#else
bool CXModuleDVD::InitializeParameters ()
#endif
{
	wchar_t wszTempString[256];
	DWORD i, j;
	LPCTSTR pwszTemp = NULL;

	m_pdwDVDChecksumAllowed = NULL;
	m_dwNumOfDVDChecksums = 0;
	m_pdwCDChecksumAllowed = NULL;
	m_dwNumOfCDChecksums = 0;
	m_pdwChecksumAllowed = NULL;
	m_pwszChecksumPath = NULL;
	m_dwNumOfChecksums = 0;
	m_pdwChecksumSectorStart = NULL;
	m_pdwChecksumSectorEnd = NULL;
	m_dwNumOfChecksumSectorRanges = 0;

	if (!CTestObj::InitializeParameters ())
		return false;

	// Get MinTestTime parameter
	m_dwMinTestTime = (DWORD)GetCfgUint (L"MinTestTime", 0);

	// Get MaxTestTime parameter
	m_dwMaxTestTime = (DWORD)GetCfgUint (L"MaxTestTime", 0xFFFFFFFF);

	// Get LoopCount parameter
	m_dwMaxLoops = (DWORD)GetCfgUint (L"LoopCount", 100);

	// Get MutexTimeout parameter
	m_dwMutexTimeout = (DWORD)GetCfgUint (L"MutexTimeout", 180000); // Number of milliseconds to wait for a mutex

	// Get BufferSize parameter
	m_dwBufferSize = (DWORD)GetCfgUint (L"BufferSize", 65536); // Number of bytes in the buffer

	// Get DriveLetter parameter
	pwszTemp = GetCfgString (L"DriveLetter", L"D");
	if ((towupper(*pwszTemp) < L'A') || (toupper(*pwszTemp) > L'Z'))
	{
		err_BADPARAMETER(L"DriveLetter");
		return false;
	}
	else
	{
		m_chDriveLetter[0] = towupper(*pwszTemp);
		m_chDriveLetter[1] = 0;
	}

	// Get FileName parameter
	m_wszFileName = GetCfgString (L"FileName", L"XMTA_HD_TEMP_FILE");

	// Get FreeSpace parameter
	pwszTemp = GetCfgString (L"FreeSpace", L"90.0");
	m_dblFreeSpacePercent = wcstod(pwszTemp, NULL);
	if ((m_dblFreeSpacePercent < 0) || (m_dblFreeSpacePercent > 100))
	{
		err_BADPARAMETER(L"FreeSpace");
		return false;
	}

	// Get DriveNumber parameter
	m_dwDriveNumber = (DWORD)GetCfgUint (L"DriveNumber", 0);

	// Get DVDChecksumAllowed[] parameter list
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"DVDChecksumAllowed[%2.2lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	m_dwNumOfDVDChecksums = i;
	if (i > 0)
	{
		if ((m_pdwDVDChecksumAllowed = new DWORD[i]) == NULL)
		{
			err_RE_OUT_OF_MEMORY_P1(i*sizeof(DWORD));
			return false;
		}
		for (j = 0; j < i; j++) // Now get the checksum values
		{
			swprintf(wszTempString, L"DVDChecksumAllowed[%2.2lu]", j);
			m_pdwDVDChecksumAllowed[j] = (DWORD)GetCfgUint (wszTempString, 0);
		}
	}
	
	// Get CDChecksumAllowed[] parameter list
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"CDChecksumAllowed[%2.2lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	m_dwNumOfCDChecksums = i;
	if (i > 0)
	{
		if ((m_pdwCDChecksumAllowed = new DWORD[i]) == NULL)
		{
			err_RE_OUT_OF_MEMORY_P1(i*sizeof(DWORD));
			return false;
		}
		for (j = 0; j < i; j++) // Now get the checksum values
		{
			swprintf(wszTempString, L"CDChecksumAllowed[%2.2lu]", j);
			m_pdwCDChecksumAllowed[j] = (DWORD)GetCfgUint (wszTempString, 0);
		}
	}

	// Get RandomSeed parameter
	m_dwRandomSeed = (DWORD)GetCfgUint (L"RandomSeed", 0);

	// Get NumberOfLoopsBetweenSpinDowns parameter
	m_dwNumberOfLoopsBetweenSpinDowns = (DWORD)GetCfgUint (L"NumberOfLoopsBetweenSpinDowns", 0);

	// Get SpinDownDelay parameter
	m_dwSpinDownDelay = (DWORD)GetCfgUint (L"SpinDownDelay", 0);
	

	// Get ChecksumAllowed[] parameter list
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"ChecksumAllowed[%2.2lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	m_dwNumOfChecksums = i;
	if (i > 0)
	{
		if ((m_pdwChecksumAllowed = new DWORD[i]) == NULL)
		{
			err_RE_OUT_OF_MEMORY_P1(i*sizeof(DWORD));
			return false;
		}
		for (j = 0; j < i; j++) // Now get the checksum values
		{
			swprintf(wszTempString, L"ChecksumAllowed[%2.2lu]", j);
			m_pdwChecksumAllowed[j] = (DWORD)GetCfgUint (wszTempString, 0);
		}
	}

	// Get ChecksumPath[] parameter array
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"ChecksumPath[%2.2lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	if (i > 0)
	{
		if ((m_pwszChecksumPath = new wchar_t *[i+1]) == NULL)
		{
			err_RE_OUT_OF_MEMORY_P1((i+1)*sizeof(wchar_t *));
			return false;
		}
		for (j = 0; j < i+1; j++) // Set the array of pointers to NULL to start
			m_pwszChecksumPath[j] = NULL;
		for (j = 0; j < i; j++) // Now get the path values
		{
			swprintf(wszTempString, L"ChecksumPath[%2.2lu]", j);
			m_pwszChecksumPath[j] = (wchar_t *)GetCfgString (wszTempString, NULL);
		}
//		for (j = 0; j < i; j++)
//		{
//			ReportDebug(BIT0, L"Path is %s", m_pwszChecksumPath[j]);
//		}
	}

	// Get ChecksumSectorStart[], ChecksumSectorEnd[] parameter array pairs
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"ChecksumSectorStart[%2.2lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	m_dwNumOfChecksumSectorRanges = i;
	if (i > 0)
	{
		if ((m_pdwChecksumSectorStart = new DWORD[i]) == NULL)
		{
			err_RE_OUT_OF_MEMORY_P1(i*sizeof(DWORD));
			return false;
		}
		if ((m_pdwChecksumSectorEnd = new DWORD[i]) == NULL)
		{
			err_RE_OUT_OF_MEMORY_P1(i*sizeof(DWORD));
			return false;
		}
		for (j = 0; j < i; j++) // Now get the list of start sectors
		{
			swprintf(wszTempString, L"ChecksumSectorStart[%2.2lu]", j);
			m_pdwChecksumSectorStart[j] = (DWORD)GetCfgUint (wszTempString, 0);
		}
		for (j = 0; j < i; j++) // Now get the list of end sectors
		{
			swprintf(wszTempString, L"ChecksumSectorEnd[%2.2lu]", j);
			m_pdwChecksumSectorEnd[j] = (DWORD)GetCfgUint (wszTempString, m_pdwChecksumSectorStart[j]);
			if (m_pdwChecksumSectorEnd[j] < m_pdwChecksumSectorStart[j]) // Make sure that the end sector is not less than the start sector
				m_pdwChecksumSectorEnd[j] = m_pdwChecksumSectorStart[j];
		}
	}

	// Get StartPercent parameter
	pwszTemp = GetCfgString (L"StartPercent", L"0.0");
	m_dblStartPercent = wcstod(pwszTemp, NULL);
	if ((m_dblStartPercent < 0) || (m_dblStartPercent > 100))
	{
		err_BADPARAMETER(L"StartPercent");
		return false;
	}

	// Get EndPercent parameter
	pwszTemp = GetCfgString (L"EndPercent", L"100.0");
	m_dblEndPercent = wcstod(pwszTemp, NULL);
	if ((m_dblEndPercent < 0) || (m_dblEndPercent > 100))
	{
		err_BADPARAMETER(L"EndPercent");
		return false;
	}

	if(m_dblStartPercent > m_dblEndPercent)
	{
		err_RE_START_END_PERCENTAGE_P2(m_dblStartPercent, m_dblEndPercent);
		return false;
	}		

	return true;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vInitializeTestVariables()
#else
void CXModuleDVD::vInitializeTestVariables()
#endif
{
	// Initialize some globals here
	m_hDevice = INVALID_HANDLE;
	m_hXMTAHardDiskMutex = (HANDLE) -1;
	m_pdwBuffer1 = NULL;
	m_pdwBuffer2 = NULL;
	m_pdwMapArray = NULL;
	m_szFilePath[0] = 0;
	hDir = INVALID_HANDLE_VALUE;
	LARGE_INTEGER liLocalTSC;

	_asm
	{
		rdtsc
		mov liLocalTSC.LowPart, eax       ; Preserve the Least Significant 32 bits
		mov liLocalTSC.HighPart, edx      ; Preserve the Most Significant 32 bits
	}

	m_dwlStartTime = liLocalTSC.QuadPart/gi64CPUSpeed;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vCleanup()
#else
void CXModuleDVD::vCleanup()
#endif
{
	if (hDir != INVALID_HANDLE_VALUE)
	{
		FindClose(hDir);
	}
	if (m_pdwMapArray != NULL)
	{
		delete [] m_pdwMapArray;
		m_pdwMapArray = NULL;
	}
	if (m_pdwBuffer1 != NULL)
	{
		delete [] m_pdwBuffer1;
		m_pdwBuffer1 = NULL;
	}
	if (m_pdwBuffer2 != NULL)
	{
		delete [] m_pdwBuffer2;
		m_pdwBuffer2 = NULL;
	}

	vReleasePossessionOfHardDiskResources();
	if (m_hDevice != INVALID_HANDLE)
	{
		CloseHandle(m_hDevice);
		m_hDevice = INVALID_HANDLE;
	}
}

// m_hXMTAHardDiskMutex is a stack-based parameter so it is different for each
// executing thread (each test).  In this way, different tests can use this parameter
// to reference different named mutexes at the same time (such as a mutex for a drive C test
// and a mutex for a drive d test at the same time) that don't collide.
// On exit, m_hXMTAHardDiskMutex is either -1 or a true mutex handle
#ifdef XHD_TAG
bool CXModuleHardDisk::bGetPossessionOfHardDiskResources (char *MutexName)
#else
bool CXModuleDVD::bGetPossessionOfHardDiskResources (char *MutexName)
#endif
{
	DWORD x;
	int onesecond = 1000;

	if (m_hXMTAHardDiskMutex != (HANDLE) -1) // We already have mutex possession, so free it up before continuing
		vReleasePossessionOfHardDiskResources();
	m_hXMTAHardDiskMutex = CreateMutexA (NULL, FALSE, MutexName);
	if (m_hXMTAHardDiskMutex == NULL) // NULL?, don't even try accessing
	{
		m_hXMTAHardDiskMutex = (HANDLE) -1;
		err_MutexHandle(MutexName);
		return (false);
	}
	for (x = 0; x < (m_dwMutexTimeout/(DWORD)onesecond); x++)
	{
		if (WaitForSingleObject(m_hXMTAHardDiskMutex, onesecond) == WAIT_OBJECT_0)
			return (true);
		if (CheckAbort(HERE))
		{
			vReleasePossessionOfHardDiskResources();
			return (false);
		}
	}
	vReleasePossessionOfHardDiskResources();
	err_MutexTimeout(MutexName);
	return (false);
}

#ifdef XHD_TAG
void CXModuleHardDisk::vReleasePossessionOfHardDiskResources ()
#else
void CXModuleDVD::vReleasePossessionOfHardDiskResources ()
#endif
{
	if (m_hXMTAHardDiskMutex != (HANDLE) -1)
	{
		ReleaseMutex (m_hXMTAHardDiskMutex);
		CloseHandle (m_hXMTAHardDiskMutex);
		m_hXMTAHardDiskMutex = (HANDLE) -1;
	}
}

#ifdef XHD_TAG
void CXModuleHardDisk::vCompareTestTime()
#else
void CXModuleDVD::vCompareTestTime()
#endif
{
	TCHAR tcStatString[100];
	LARGE_INTEGER liLocalTSC;
	DWORDLONG dwlEndTime;

	_asm
	{
		rdtsc
		mov liLocalTSC.LowPart, eax       ; Preserve the Least Significant 32 bits
		mov liLocalTSC.HighPart, edx      ; Preserve the Most Significant 32 bits
	}

	dwlEndTime = liLocalTSC.QuadPart/gi64CPUSpeed;
	_stprintf(tcStatString, _T("%s %s %lu"), HD_TEST_TIME, _T("Test"), (DWORD)GetTestNumber());
	ReportStatistic(tcStatString, _T("%lu"), (DWORD)(dwlEndTime-m_dwlStartTime));
	if ((dwlEndTime-m_dwlStartTime) > (DWORDLONG)m_dwMaxTestTime)
	{
		if (err_TEST_TIME_TOO_LONG((DWORD)(dwlEndTime-m_dwlStartTime), m_dwMaxTestTime))
		return;
	}
	else if ((dwlEndTime-m_dwlStartTime) < (DWORDLONG)m_dwMinTestTime)
	{
		if (err_TEST_TIME_TOO_SHORT((DWORD)(dwlEndTime-m_dwlStartTime), m_dwMinTestTime))
		return;
	}
}

//******************************************************************
// Title: free_space_random_wrc
//
// Abstract: Create a large file on the hard drive and perform a random
//           write-read-compare test within the file
//
// Uses config parameters:
//           LoopCount
//           MutexTimeout
//           BufferSize
//           DriveLetter
//           FileName
//           FreeSpace
//******************************************************************
#ifdef XHD_TAG
IMPLEMENT_TESTUNLOCKED (HardDisk, free_space_random_wrc, FREE_SPACE_RANDOM_WRC)
#else
IMPLEMENT_TESTUNLOCKED (DVD, free_space_random_wrc, FREE_SPACE_RANDOM_WRC)
#endif
{
//	#ifdef _DEBUG
		static int qqFreeSpaceRandomWRC;
		qqFreeSpaceRandomWRC++;
		ReportDebug(BIT0, _T("FreeSpaceRandomWRC Test - Loop %d"), qqFreeSpaceRandomWRC);
//	#endif
	vInitializeTestVariables();
	vFreeSpaceRandomWRC();
	vCompareTestTime();
	vCleanup();
	return;
}

//******************************************************************
// Title: physical_device_sequential_read
//
// Abstract: Read every sector of a physical drive and ensure there are
//           no read errors.
//
// Uses config parameters:
//           BufferSize
//           DriveNumber
//           StartPercent
//           EndPercent
//******************************************************************
#ifdef XHD_TAG
IMPLEMENT_TESTUNLOCKED (HardDisk, physical_device_sequential_read, PHYSICAL_DEVICE_SEQUENTIAL_READ)
#else
IMPLEMENT_TESTUNLOCKED (DVD, physical_device_sequential_read, PHYSICAL_DEVICE_SEQUENTIAL_READ)
#endif
{
//	#ifdef _DEBUG
		static int qqPhysicalDeviceSequentialRead;
		qqPhysicalDeviceSequentialRead++;
		ReportDebug(BIT0, _T("PhysicalDeviceSequentialRead Test - Loop %d"), qqPhysicalDeviceSequentialRead);
//	#endif
	vInitializeTestVariables();
	vPhysicalDeviceSequentialRead();
	vCompareTestTime();
	vCleanup();
	return;
}

//******************************************************************
// Title: file_system_checksum
//
// Abstract: Calculates the checksum of the contents of all files in and the
//           names of all files and directories in specified paths.
//
// Uses config parameters:
//           ChecksumAllowed[XX]
//           ChecksumPath[XX]
//******************************************************************
#ifdef XHD_TAG
IMPLEMENT_TESTUNLOCKED (HardDisk, file_system_checksum, FILE_SYSTEM_CHECKSUM)
#else
IMPLEMENT_TESTUNLOCKED (DVD, file_system_checksum, FILE_SYSTEM_CHECKSUM)
#endif
{
//	#ifdef _DEBUG
		static int qqFileSystemChecksum;
		qqFileSystemChecksum++;
		ReportDebug(BIT0, _T("FileSystemChecksum Test - Loop %d"), qqFileSystemChecksum);
//	#endif
	vInitializeTestVariables();
	vPerformChecksum();
	vCompareTestTime();
	vCleanup();
	return;
}

//******************************************************************
// Title: file_read
//
// Abstract: Reads and discards the contents from a specified file.
//
// Uses config parameters:
//           BufferSize
//           DriveLetter
//           FileName
//******************************************************************
#ifdef XHD_TAG
IMPLEMENT_TESTUNLOCKED (HardDisk, file_sequential_read, FILE_SEQUENTIAL_READ)
#else
IMPLEMENT_TESTUNLOCKED (DVD, file_sequential_read, FILE_SEQUENTIAL_READ)
#endif
{
//	#ifdef _DEBUG
		static int qqFileSequentialRead;
		qqFileSequentialRead++;
		ReportDebug(BIT0, _T("FileSequentialRead Test - Loop %d"), qqFileSequentialRead);
//	#endif
	vInitializeTestVariables();
	vFileSequentialRead();
	vCompareTestTime();
	vCleanup();
	return;
}

//******************************************************************
// Title: file_read
//
// Abstract: Reads and discards the contents from a specified file.
//
// Uses config parameters:
//           BufferSize
//           DriveLetter
//           FileName
//******************************************************************
#ifdef XHD_TAG
IMPLEMENT_TESTUNLOCKED (HardDisk, dvd_file_sequential_read, FILE_SEQUENTIAL_READ)
#else
IMPLEMENT_TESTUNLOCKED (DVD, dvd_file_sequential_read, FILE_SEQUENTIAL_READ)
#endif
{
//	#ifdef _DEBUG
		static int qqdvdFileSequentialRead;
		qqdvdFileSequentialRead++;
		ReportDebug(BIT0, _T("DVDFileSequentialRead Test - Loop %d"), qqdvdFileSequentialRead);
//	#endif
	vInitializeTestVariables();
	vFileSequentialRead();
	vCompareTestTime();
	vCleanup();
	return;
}

//******************************************************************
// Title: dvd_random_read
//
// Abstract: Randomly read regions within the valid data space of the DVD
//           and checksum the contents read
//
// Uses config parameters:
//           LoopCount
//           BufferSize
//           DriveLetter
//           DVDChecksumAllowed[]
//           CDChecksumAllowed[]
//           RandomSeed
//           NumberOfLoopsBetweenSpinDowns
//           SpinDownDelay
//******************************************************************
#ifdef XHD_TAG
IMPLEMENT_TESTUNLOCKED (HardDisk, dvd_random_read, DVD_RANDOM_READ)
#else
IMPLEMENT_TESTUNLOCKED (DVD, dvd_random_read, DVD_RANDOM_READ)
#endif
{
//	#ifdef _DEBUG
		static int qqDVDRandomRead;
		qqDVDRandomRead++;
		ReportDebug(BIT0, _T("DVDRandomRead Test - Loop %d"), qqDVDRandomRead);
//	#endif
	vInitializeTestVariables();
	vDVDRandomRead();
	vCompareTestTime();
	vCleanup();
	return;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vDVDRandomRead ()
#else
void CXModuleDVD::vDVDRandomRead ()
#endif
{
	DWORD         nBlocks, n, dwMapSize, dwChecksum = 0, dwKeepAlive = 0;
	DWORD         cdwLength, nReads, dwSpinDownCounter = 0;
	UINT          nReadsNeeded,theseed,uiRandScratch;
	DWORD         i, dwTestLoops, dwNumberOfLoopsBetweenSpinDowns, dwKeepAliveMax;
	bool          bDVD;
	DWORDLONG qwDisturbanceStart, qwDisturbanceEnd;
	DWORD dwBlockLow, dwBlockHigh, dwTotalDisturbanceBlocks = 0, dwTotalDisturbanceSectors = 0;
	typedef	struct {DWORD dwStartSector; DWORD dwEndSector;} DVD_DISTURBANCE_REGION;
/*	DVD_DISTURBANCE_REGION DisturbanceRegion[] =   {{0x00A8D2, 0x00B8D1}, // XM2 DVD mapping
													{0x02FDBE, 0x030DBD},
													{0x07B3EF, 0x07C3EE},
													{0x0A0623, 0x0A1622},
													{0x0D6C06, 0x0D7C05},
													{0x0FCE77, 0x0FDE76},
													{0x133A4C, 0x134A4B},
													{0x159D59, 0x15AD58},
													{0x1C08E2, 0x1C18E1},
													{0x20BF12, 0x20CF11},
													{0x230D44, 0x231D43},
													{0x25493F, 0x25593E},
													{0x28CF5B, 0x28DF5A},
													{0x2B1B51, 0x2B2B50},
													{0x2E8E17, 0x2E9E16},
													{0x333531, 0x334530}

													{0x00BCAF, 0x00CCAE}, // XM3 DVD mapping
													{0x030B1B, 0x031B1A},
													{0x0563FB, 0x0573FA},
													{0x07B7CF, 0x07C7CE},
													{0x09F82A, 0x0A0829},
													{0x0C5CE3, 0x0C6CE2},
													{0x0EA890, 0x0EB88F},
													{0x10E684, 0x10F683},
													{0x1C0FF5, 0x1C1FF4},
													{0x1E573E, 0x1E673D},
													{0x20BCD3, 0x20CCD2},
													{0x2301AB, 0x2311AA},
													{0x254606, 0x255605},
													{0x279F33, 0x27AF32},
													{0x29F2D7, 0x2A02D6},
													{0x333AA8, 0x334AA7}
	
	};
*/
	DVD_DISTURBANCE_REGION DisturbanceRegion[] =   {{0x00A8D2, 0x00B8D1}, // Combined XM2/XM3 DVD mapping
													{0x00BCAF, 0x00CCAE},
													{0x02FDBE, 0x031B1A},
													{0x0563FB, 0x0573FA},
													{0x07B3EF, 0x07C7CE},
													{0x09F82A, 0x0A1622},
													{0x0C5CE3, 0x0C6CE2},
													{0x0D6C06, 0x0D7C05},
													{0x0EA890, 0x0EB88F},
													{0x0FCE77, 0x0FDE76},
													{0x10E684, 0x10F683},
													{0x133A4C, 0x134A4B},
													{0x159D59, 0x15AD58},
													{0x1C08E2, 0x1C1FF4},
													{0x1E573E, 0x1E673D},
													{0x20BCD3, 0x20CF11},
													{0x2301AB, 0x231D43},
													{0x254606, 0x25593E},
													{0x279F33, 0x27AF32},
													{0x28CF5B, 0x28DF5A},
													{0x29F2D7, 0x2A02D6},
													{0x2B1B51, 0x2B2B50},
													{0x2E8E17, 0x2E9E16},
													{0x333531, 0x334AA7}
	};

	if(!PhysicalDeviceOpen(false, true))
		return;

	if (m_qwDeviceSize > 1073741824)
	{
		bDVD = true;
		dwTestLoops = m_dwMaxLoops;
		dwKeepAliveMax = 20;
		dwNumberOfLoopsBetweenSpinDowns = m_dwNumberOfLoopsBetweenSpinDowns;
	}
	else // CD
	{
		bDVD = false;
		dwTestLoops = m_dwMaxLoops/3;  // CDs are over 3 times slower than DVDs
		dwKeepAliveMax = 7;
		dwNumberOfLoopsBetweenSpinDowns = m_dwNumberOfLoopsBetweenSpinDowns/3;
	}

	cdwLength = m_dwBufferSize / 4;  // Number of DWORDs in the buffer
	// This is OK as long as the hard drive is < 2048 GB
	nBlocks  = (DWORD)(m_qwDeviceSize / m_dwBufferSize);

	if(nBlocks < 2)
	{
		err_NO_BLOCKS_TO_TEST();
		return;
	}

	if (m_pdwBuffer2 != NULL) // If for some reason this is not NULL, delete the old buffer
		delete [] m_pdwBuffer2;
	if ((m_pdwBuffer2 = new DWORD[cdwLength]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1(m_dwBufferSize);
		return;
	}

	if (dwTestLoops < nBlocks/2) // Determine the required number of entries in the m_MapArray
		dwMapSize = dwTestLoops;
	else
		dwMapSize = nBlocks; // Make this nBlocks instead of nBlocks/2 beause we are also setting aside blocks that overlap disturbance regions on the disk

	// Get a rough count of how many blocks are consumed by disturbances
	dwTotalDisturbanceSectors = 0;
	if (bDVD)
	{
		for (i = 0; i < sizeof(DisturbanceRegion)/sizeof(DVD_DISTURBANCE_REGION); i++)
		{
			dwTotalDisturbanceSectors = dwTotalDisturbanceSectors + (DisturbanceRegion[i].dwEndSector - DisturbanceRegion[i].dwStartSector) + 1;
		}
		dwTotalDisturbanceBlocks = (DWORD)(((DWORDLONG)dwTotalDisturbanceSectors * (DWORDLONG)m_dwBytesPerSector)/(DWORDLONG)m_dwBufferSize);
		dwTotalDisturbanceBlocks = dwTotalDisturbanceBlocks + sizeof(DisturbanceRegion)/sizeof(DVD_DISTURBANCE_REGION);
	}

	if (m_pdwMapArray != NULL) // If for some reason this is not NULL, delete the old buffer
		delete [] m_pdwMapArray;
	if ((m_pdwMapArray = new DWORD[dwMapSize+dwTotalDisturbanceBlocks]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1((dwMapSize+dwTotalDisturbanceBlocks)*sizeof(DWORD));
		return;
	}
	// 0xFFFFFFFF will indicate that an array element is empty
	memset(m_pdwMapArray, 0xFF, (dwMapSize+dwTotalDisturbanceBlocks)*sizeof(DWORD));

	vNewSeed(&theseed); // Get a new seed value based on the current time
	if (m_dwRandomSeed != 0) // Use the specified seed if not equal to zero
		theseed = m_dwRandomSeed;
	uiRandScratch = theseed;

/*
	// A debug routine that reads every sector on the device and displays whether they are good or bad
	ReportDebug(BIT0, L"0x000000 Start good");
	bool bGood = true;
	for (n = 0; n < nBlocks; n++)
	{
		if(LocalRead((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer2,m_dwBufferSize))
		{
			if (!bGood)
			{
				ReportDebug(BIT0, L"0x%6.6lx End bad", n-1);
				ReportDebug(BIT0, L"0x%6.6lx Start good", n);
				bGood = true;
			}
		}
		else
		{
			if (bGood)
			{
				ReportDebug(BIT0, L"0x%6.6lx End good", n-1);
				ReportDebug(BIT0, L"0x%6.6lx Start bad", n);
				bGood = false;
			}
		}
	}

return;
*/
	dwTotalDisturbanceBlocks = 0;
	if (bDVD)
	{
		for (i = 0; i < sizeof(DisturbanceRegion)/sizeof(DVD_DISTURBANCE_REGION); i++)
		{
			qwDisturbanceStart = (DWORDLONG)DisturbanceRegion[i].dwStartSector * (DWORDLONG)m_dwBytesPerSector;
			qwDisturbanceEnd = ((DWORDLONG)(DisturbanceRegion[i].dwEndSector + 1) * (DWORDLONG)m_dwBytesPerSector) - (DWORDLONG)1;
			dwBlockLow = (DWORD)(qwDisturbanceStart/m_dwBufferSize);
			dwBlockHigh = (DWORD)(qwDisturbanceEnd/m_dwBufferSize);
			// Map the blocks as unusable.  Assume that no two disturbance regions overlapp each other
			for (n = dwBlockLow; n <= dwBlockHigh; n++)
			{
				vSet(m_pdwMapArray, n);
				dwTotalDisturbanceBlocks++;
			}
		}
	}
	ReportDebug(BIT0, L"%lu test blocks consumed by media disturbances", dwTotalDisturbanceBlocks); // A keep-alive message
	if (CheckAbort(HERE))
		return;
	nReadsNeeded = 0;
	for(nReads = 0; nReads <= dwTestLoops && !CheckAbort(HERE); )
	{
		if ((dwTestLoops - nReads) > (nBlocks / 2))
		{
			nReadsNeeded = nBlocks / 2;
			nReads = nReads + nBlocks / 2;
		}
		else
		{
			nReadsNeeded = dwTestLoops - nReads;
			nReads = dwTestLoops;
		}

		for(UINT count = 0; count < nReadsNeeded && !CheckAbort(HERE); count++)
		{
			do {
				n = random(&uiRandScratch) % nBlocks;
			} while(bLookup(m_pdwMapArray, n));
			vSet(m_pdwMapArray, n);

			if(LocalRead((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer2,m_dwBufferSize))
			{
//				ReportDebug(BIT0, L"Read sector %lu contains");
				// Add the checksum
				for(DWORD i = 0; i < cdwLength; i++)
				{
//					ReportDebug(BIT0, L"%8.8lx", m_pdwBuffer2[i]);
					dwChecksum = dwChecksum + m_pdwBuffer2[i];
				}
			}
			dwKeepAlive++;
			if (dwKeepAlive == dwKeepAliveMax)
			{
				ReportDebug(BIT0, L"reading offset %I64u", (DWORDLONG)n * (DWORDLONG)m_dwBufferSize);
				dwKeepAlive = 0;
			}
			dwSpinDownCounter = dwSpinDownCounter + 1;
			if (dwSpinDownCounter == dwNumberOfLoopsBetweenSpinDowns)
			{
				if (m_dwSpinDownDelay != 0)
				{
					DWORD m;
					for (m = 0; m < m_dwSpinDownDelay/10; m++)
					{
						Sleep(10000);
						ReportDebug(BIT0, L"DVD spinning down");
						if (CheckAbort(HERE))
							break;
					}
					Sleep((m_dwSpinDownDelay - (m*10)) * 1000);
				}
				dwSpinDownCounter = 0;
			}
		}

		if(nReads == dwTestLoops)
			nReads++;
		else
		{
			memset(&m_pdwMapArray[dwTotalDisturbanceBlocks], 0xFF, (dwMapSize)*sizeof(DWORD)); // Don't overwrite disturbance regions info
			nReadsNeeded = 0;
			theseed = random(&uiRandScratch); // Get a new seed based on the next random number
			uiRandScratch = theseed;
		}
	}
	if (!CheckAbort(HERE))
	{
		if (bDVD)
		{
			// Only compare checksums if the number of checksums is greater than 1, or if there is a single checksum that is not 0, or if a random seed was specified
			if ((m_dwNumOfDVDChecksums != 0) && (m_dwRandomSeed != 0))
			{
				if ((m_dwNumOfDVDChecksums > 1) || (m_pdwDVDChecksumAllowed[0] != 0))
				{
					for (i = 0; i < m_dwNumOfDVDChecksums; i++)
					{
						if (m_pdwDVDChecksumAllowed[i] == dwChecksum)
							break;
					}
					if (i == m_dwNumOfDVDChecksums)
					{
						err_CHECKSUM_BAD_P1(dwChecksum);
						return;
					}
				}
			}
		}
		else // CD
		{
			// Only compare checksums if the number of checksums is greater than 1, or if there is a single checksum that is not 0, or if a random seed was specified
			if ((m_dwNumOfCDChecksums != 0) && (m_dwRandomSeed != 0))
			{
				if ((m_dwNumOfCDChecksums > 1) || (m_pdwCDChecksumAllowed[0] != 0))
				{
					for (i = 0; i < m_dwNumOfCDChecksums; i++)
					{
						if (m_pdwCDChecksumAllowed[i] == dwChecksum)
							break;
					}
					if (i == m_dwNumOfCDChecksums)
					{
						err_CHECKSUM_BAD_P1(dwChecksum);
						return;
					}
				}
			}
		}
	}

	return;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vFreeSpaceRandomWRC ()
#else
void CXModuleDVD::vFreeSpaceRandomWRC ()
#endif
{
	DWORD         nBlocks, n, dwMapSize;
	DWORD         cdwLength, nWrites;
	UINT          nReadsNeeded,theseed,uiRandScratch;

	if(!FreeSpaceDeviceOpen())
		return;

	cdwLength = m_dwBufferSize / 4;  // Number of DWORDs in the buffer
	// This is OK as long as the hard drive is < 2048 GB
	nBlocks  = (DWORD)(m_qwDeviceSize / m_dwBufferSize);

	if(nBlocks < 2)
	{
		err_NO_BLOCKS_TO_TEST();
		return;
	}

	// Force a write to actually commit the disk storage.
/*
	BYTE buf[512];
	for(DWORDLONG idx = 0; idx < m_qwDeviceSize && !CheckAbort(HERE); idx += m_dwBufferSize)
	{
		Write(idx,buf,512);
	}
	if(CheckAbort(HERE))
		return;
*/

	if (m_pdwBuffer1 != NULL) // If for some reason this is not NULL, delete the old buffer
		delete [] m_pdwBuffer1;
	if ((m_pdwBuffer1 = new DWORD[cdwLength]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1(m_dwBufferSize);
		return;
	}

	if (m_pdwBuffer2 != NULL) // If for some reason this is not NULL, delete the old buffer
		delete [] m_pdwBuffer2;
	if ((m_pdwBuffer2 = new DWORD[cdwLength]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1(m_dwBufferSize);
		return;
	}

	if (m_dwMaxLoops < nBlocks/2) // Determine the required number of entries in the m_MapArray
		dwMapSize = m_dwMaxLoops;
	else
		dwMapSize = nBlocks/2;

	if (m_pdwMapArray != NULL) // If for some reason this is not NULL, delete the old buffer
		delete [] m_pdwMapArray;
	if ((m_pdwMapArray = new DWORD[dwMapSize]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1(dwMapSize);
		return;
	}
	// 0xFFFFFFFF will indicate that an array element is empty
	memset(m_pdwMapArray, 0xFF, dwMapSize*sizeof(DWORD));

	vNewSeed(&theseed); // Get a new seed value based on the current time
	uiRandScratch = theseed;

	nReadsNeeded = 0;
	for(nWrites = 0; nWrites <= m_dwMaxLoops && !CheckAbort(HERE); )
	{
		if(nReadsNeeded < nBlocks / 2 && nWrites != m_dwMaxLoops)
		{
			do {
				n = random(&uiRandScratch) % nBlocks;
			} while(bLookup(m_pdwMapArray, n));

			vSet(m_pdwMapArray, n);

			for(DWORD i = 0; i < cdwLength; i++)
				m_pdwBuffer1[i] = random(&uiRandScratch);

//ReportDebug(BIT0, L"write block %ld\n", n);

			LocalWrite((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer1,m_dwBufferSize);
			nWrites++;
			nReadsNeeded++;
		}
		else
		{
			uiRandScratch = theseed; // Re-seed the random number generator
			memset(m_pdwMapArray, 0xFF, dwMapSize*sizeof(DWORD));

			for(UINT count = 0; count < nReadsNeeded && !CheckAbort(HERE); count++)
			{
				do {
					n = random(&uiRandScratch) % nBlocks;
				} while(bLookup(m_pdwMapArray, n));

				vSet(m_pdwMapArray, n);

				for(DWORD i = 0; i < cdwLength; i++)
					m_pdwBuffer1[i] = random(&uiRandScratch);

//ReportDebug(BIT0, L"read block %ld\n", n);

				if(LocalRead((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer2,m_dwBufferSize))
				{
					// Compare the buffers as DWORDs
					for(DWORD i = 0; i < cdwLength; i++)
					{
						if(m_pdwBuffer1[i] != m_pdwBuffer2[i])
						{
							DWORDLONG offset = (DWORDLONG)n * (DWORDLONG)m_dwBufferSize + (DWORDLONG)i * 4;
							err_RE_COMPAREBUF_P3(offset, m_pdwBuffer1[i], m_pdwBuffer2[i]);
							break;
						}
					}
				}

			}

			if(nWrites == m_dwMaxLoops)
				nWrites++;
			else
			{
				memset(m_pdwMapArray, 0xFF, dwMapSize*sizeof(DWORD));
				nReadsNeeded = 0;
				vNewSeed(&theseed); // Get a new seed value based on the current time
				uiRandScratch = theseed;
			}
		}
	}

	return;

}

// This "device" creates a file that uses up 90% (overridable) of the remaining
// free space on a drive, allowing read/write testing of the free space on a device.
#ifdef XHD_TAG
bool CXModuleHardDisk::FreeSpaceDeviceOpen()
#else
bool CXModuleDVD::FreeSpaceDeviceOpen()
#endif
{
	BOOL fWrite;
	char MutexName[] = "DiskdrvX";
	char szRootPathName[5];
	LARGE_INTEGER eof;
	DWORD dwBytesPerSector;


	// FreeSpace testing always needs write testing, because it has to
	// create the temporary file, even during read testing.
	fWrite = true;

	sprintf(m_szFilePath, "%S:\\%S", m_chDriveLetter, m_wszFileName);

	m_hDevice = CreateFileA(
		m_szFilePath,
		GENERIC_READ | (fWrite ? GENERIC_WRITE : 0),
		0,
		NULL,
		CREATE_ALWAYS, //TRUNCATE_EXISTING,
		FILE_FLAG_NO_BUFFERING | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_WRITE_THROUGH,
		NULL); 

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		err_OPEN_FILE_P1L(m_szFilePath);
		return false;
	}

	MutexName[strlen(MutexName)-1] = m_szFilePath[0]; // Make the drive letter correct

	// Get access to the mutex for this drive
	if (!bGetPossessionOfHardDiskResources(MutexName))
		return false; // Didn't get mutex access in time

	sprintf(szRootPathName, "%S:\\", m_chDriveLetter);

#if defined( _XBOX ) 
	ULARGE_INTEGER uliFreeBytesAvailable, uliTotalNumberOfBytes;
	if (!GetDiskFreeSpaceExA(
		szRootPathName,
		&uliFreeBytesAvailable,
		&uliTotalNumberOfBytes,
		NULL))
	{
		err_COULDNT_DETERMINE_FREE_SPACE(m_chDriveLetter);
		return false;
	}

	m_qwDeviceSize  = uliFreeBytesAvailable.QuadPart;
	dwBytesPerSector = XGetDiskSectorSizeA(szRootPathName);
#else // Win32
	DWORD dwSectorsPerCluster;
	DWORD dwNumberOfFreeClusters,dwTotalNumberOfClusters;

	GetDiskFreeSpaceA(
		szRootPathName,
		&dwSectorsPerCluster,
		&dwBytesPerSector,
		&dwNumberOfFreeClusters,
		&dwTotalNumberOfClusters);

	m_qwDeviceSize  = (DWORDLONG)dwNumberOfFreeClusters;
	m_qwDeviceSize *= (DWORDLONG)dwSectorsPerCluster;
	m_qwDeviceSize *= (DWORDLONG)dwBytesPerSector;
#endif
	m_qwDeviceSize  = (DWORDLONG)((LONGLONG)m_qwDeviceSize * m_dblFreeSpacePercent / 100.0);
	m_qwDeviceSize -= m_qwDeviceSize % dwBytesPerSector;
	m_dwBufferSize -= m_dwBufferSize % dwBytesPerSector;

	eof.QuadPart = m_qwDeviceSize;

	DWORD result = SetFilePointer(m_hDevice,eof.LowPart,&eof.HighPart,FILE_BEGIN);
	DWORD result2 = GetLastError();

	if((result == 0xFFFFFFFF) && (result2 != NO_ERROR))
	{
		err_RE_EXTEND_FILE_P1L(m_qwDeviceSize);
		return false;
	}

	// Extend the EOF position.
	// For some reason in the March XDK, we can't set the end of file beyond 4 GB.
	// This is interesting because the SetFilePointer works above 4GB.
	if(!SetEndOfFile(m_hDevice))
	{
//		DWORD dwErr = GetLastError();
		err_RE_EXTEND_FILE_P1L(m_qwDeviceSize);
		return false;
	}

	// Clean up the resources we used here
	vReleasePossessionOfHardDiskResources();

	return true;
}

// This opens an existing file for reading.
#ifdef XHD_TAG
bool CXModuleHardDisk::FileReadDeviceOpen()
#else
bool CXModuleDVD::FileReadDeviceOpen()
#endif
{
	BOOL fWrite;
//	char MutexName[] = "DiskdrvX";
	char szRootPathName[5];
	LARGE_INTEGER liFileSize;
	DWORD dwBytesPerSector;


	// FreeSpace testing always needs write testing, because it has to
	// create the temporary file, even during read testing.
	fWrite = false;

	sprintf(m_szFilePath, "%S:\\%S", m_chDriveLetter, m_wszFileName);

	m_hDevice = CreateFileA(
		m_szFilePath,
		GENERIC_READ | (fWrite ? GENERIC_WRITE : 0),
		0,
		NULL,
		OPEN_EXISTING, //TRUNCATE_EXISTING,
		FILE_FLAG_NO_BUFFERING,
		NULL); 

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		err_OPEN_FILE_P1L(m_szFilePath);
		return false;
	}

//	MutexName[strlen(MutexName)-1] = m_szFilePath[0]; // Make the drive letter correct

	// Get access to the mutex for this drive
//	if (!bGetPossessionOfHardDiskResources(MutexName))
//		return false; // Didn't get mutex access in time

	sprintf(szRootPathName, "%S:\\", m_chDriveLetter);

#if defined( _XBOX )
/*
	ULARGE_INTEGER uliFreeBytesAvailable, uliTotalNumberOfBytes;
	if (!GetDiskFreeSpaceExA(
		szRootPathName,
		&uliFreeBytesAvailable,
		&uliTotalNumberOfBytes,
		NULL))
	{
		err_COULDNT_DETERMINE_FREE_SPACE(m_chDriveLetter);
		return false;
	}
	

	m_qwDeviceSize  = uliFreeBytesAvailable.QuadPart;
*/
	dwBytesPerSector = XGetDiskSectorSizeA(szRootPathName);
#else // Win32
	DWORD dwSectorsPerCluster;
	DWORD dwNumberOfFreeClusters,dwTotalNumberOfClusters;

	GetDiskFreeSpaceA(
		szRootPathName,
		&dwSectorsPerCluster,
		&dwBytesPerSector,
		&dwNumberOfFreeClusters,
		&dwTotalNumberOfClusters);
/*
	m_qwDeviceSize  = (DWORDLONG)dwNumberOfFreeClusters;
	m_qwDeviceSize *= (DWORDLONG)dwSectorsPerCluster;
	m_qwDeviceSize *= (DWORDLONG)dwBytesPerSector;
*/
#endif

	if (!GetFileSizeEx(m_hDevice, &liFileSize))
	{
		err_COULDNT_DETERMINE_FILE_SIZE(m_szFilePath);
		return false;
	}
	m_qwDeviceSize  = liFileSize.QuadPart;
	m_qwDeviceSize -= m_qwDeviceSize % dwBytesPerSector;
	m_dwBufferSize -= m_dwBufferSize % dwBytesPerSector;
/*
	eof.QuadPart = m_qwDeviceSize;

	DWORD result = SetFilePointer(m_hDevice,eof.LowPart,&eof.HighPart,FILE_BEGIN);
	DWORD result2 = GetLastError();

	if((result == 0xFFFFFFFF) && (result2 != NO_ERROR))
	{
		err_RE_EXTEND_FILE_P1L(m_qwDeviceSize);
		return false;
	}

	// Extend the EOF position.
	// For some reason in the March XDK, we can't set the end of file beyond 4 GB.
	// This is interesting because the SetFilePointer works above 4GB.
	if(!SetEndOfFile(m_hDevice))
	{
//		DWORD dwErr = GetLastError();
		err_RE_EXTEND_FILE_P1L(m_qwDeviceSize);
		return false;
	}

	// Clean up the resources we used here
//	vReleasePossessionOfHardDiskResources();
*/
	return true;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vPhysicalDeviceSequentialRead ()
#else
void CXModuleDVD::vPhysicalDeviceSequentialRead ()
#endif
{
	DWORD cbRemain;
	DWORDLONG nBlocks,nStartBlock,nEndBlock, n;
	LPBYTE lpBuffer;
	DWORD i;

	if(!PhysicalDeviceOpen(false, false))
		return;

	// This is OK as long as the hard drive is < 2048 GB
	nBlocks  = (DWORD)(m_qwDeviceSize / m_dwBufferSize);
	cbRemain = (DWORD)(m_qwDeviceSize % m_dwBufferSize);
	if(nBlocks == 0)
	{
		err_NO_BLOCKS_TO_TEST();
		return;
	}

	nStartBlock = (DWORDLONG)(((LONGLONG)nBlocks - 1) * m_dblStartPercent / 100.0);
	nEndBlock   = (DWORDLONG)(((LONGLONG)nBlocks - 1) * m_dblEndPercent / 100.0);

	ReportDebug(BIT0, L"Starting Percentage = %lg\n"
		L"Ending Percentage = %lg\n"
		L"Total Blocks = %I64d\n"
		L"Starting Block = %I64d\n"
		L"Ending Block = %I64d",
		m_dblStartPercent,
		m_dblEndPercent,
		nBlocks,
		nStartBlock,
		nEndBlock);


	// Change nBlocks to represent actual number of blocks we will test for progress computation.
	nBlocks = (nEndBlock - nStartBlock) + 1;

	if ((m_pdwBuffer1 = new DWORD[m_dwBufferSize/4]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1(m_dwBufferSize);
		return;
	}
	lpBuffer = (BYTE *)m_pdwBuffer1; // We use this buffer as a BYTE pointer

	i = 0;
	for(n = nStartBlock; n <= nEndBlock && !CheckAbort(HERE); n++)
	{
		LocalRead((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer1,m_dwBufferSize);
		i++;
		if (i == 200)
		{
			ReportDebug(BIT0, L"reading offset %I64u", (DWORDLONG)n * (DWORDLONG)m_dwBufferSize);
			i = 0;
		}
	}
	
	if((cbRemain != 0) && !CheckAbort(HERE))
		LocalRead((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer1,cbRemain);
}

#ifdef XHD_TAG
bool CXModuleHardDisk::PhysicalDeviceOpen(bool fWrite, bool bDVD)
#else
bool CXModuleDVD::PhysicalDeviceOpen(bool fWrite, bool bDVD)
#endif
{
	DWORD cb;
	OBJECT_ATTRIBUTES ObjAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS NtStatus;
	OBJECT_STRING ObjString;
	char szRootPathName[5];

	if (bDVD)
	{
		sprintf(m_szFilePath, "cdrom0:");
		m_hDevice = CreateFileA(
			m_szFilePath,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING, //TRUNCATE_EXISTING,
			FILE_FLAG_NO_BUFFERING,
			NULL); 

		if (m_hDevice == INVALID_HANDLE_VALUE)
		{
			err_OPEN_FILE_P1L(m_szFilePath);
			return false;
		}

		sprintf(szRootPathName, "%S:\\", m_chDriveLetter);
		m_dwBytesPerSector = XGetDiskSectorSizeA(szRootPathName);
		ULARGE_INTEGER uliFreeBytesAvailable, uliTotalNumberOfBytes;
		if (!GetDiskFreeSpaceExA(
			szRootPathName,
			&uliFreeBytesAvailable,
			&uliTotalNumberOfBytes,
			NULL))
		{
			err_COULDNT_DETERMINE_FREE_SPACE(m_chDriveLetter);
			return false;
		}
		m_qwDeviceSize = uliTotalNumberOfBytes.QuadPart;
		m_qwDeviceSize -= m_qwDeviceSize % m_dwBytesPerSector;
		m_dwBufferSize -= m_dwBufferSize % m_dwBytesPerSector;
	}
	else // Hard disk
	{
		sprintf(m_szFilePath, "\\Device\\Harddisk0\\partition%lu", m_dwDriveNumber);

		ObjString.Length = (USHORT)strlen(m_szFilePath);
		ObjString.MaximumLength = ObjString.Length + 1;
		ObjString.Buffer = m_szFilePath;

		ObjAttributes.RootDirectory = NULL;
		ObjAttributes.ObjectName = &ObjString;
		ObjAttributes.Attributes = OBJ_CASE_INSENSITIVE;

		m_hDevice = INVALID_HANDLE_VALUE;
		NtStatus = NtOpenFile(
			&m_hDevice,
			SYNCHRONIZE | FILE_READ_DATA | (fWrite ? FILE_WRITE_DATA : 0),
			&ObjAttributes,
			&IoStatusBlock,
			0,
			FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING); 

		if (NtStatus != STATUS_SUCCESS)
		{
			err_OPEN_DEVICE_P1L(m_szFilePath);
			return false;
		}

		if(!DeviceIoControl(
			m_hDevice,
			IOCTL_DISK_GET_DRIVE_GEOMETRY,
			NULL,
			0,
			&m_Geometry,
			sizeof(m_Geometry),
			&cb,
			NULL))
		{
			err_RE_DRIVE_GEOMETRY_P1L(m_szFilePath, GetLastError());
			return false;
		}

		m_qwDeviceSize =
			m_Geometry.BytesPerSector    *
			m_Geometry.SectorsPerTrack   *
			m_Geometry.TracksPerCylinder *
			m_Geometry.Cylinders.QuadPart;

		m_dwBufferSize -= m_dwBufferSize % m_Geometry.BytesPerSector;
		m_dwBytesPerSector = m_Geometry.BytesPerSector;
	}

	ReportDebug(BIT0, L"DeviceSize = %I64d bytes", m_qwDeviceSize);

	return true;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vFileSequentialRead ()
#else
void CXModuleDVD::vFileSequentialRead ()
#endif
{
	DWORD         nBlocks, n;
	DWORD         cdwLength;

	if(!FileReadDeviceOpen())
		return;

	cdwLength = m_dwBufferSize / 4;  // Number of DWORDs in the buffer
	// This is OK as long as the hard drive is < 2048 GB
	nBlocks  = (DWORD)(m_qwDeviceSize / m_dwBufferSize);

	if(nBlocks < 2)
	{
		err_NO_BLOCKS_TO_TEST();
		return;
	}


	if (m_pdwBuffer1 != NULL) // If for some reason this is not NULL, delete the old buffer
		delete [] m_pdwBuffer1;
	if ((m_pdwBuffer1 = new DWORD[cdwLength]) == NULL)
	{
		err_RE_OUT_OF_MEMORY_P1(m_dwBufferSize);
		return;
	}

	for(n = 0; n <= nBlocks && !CheckAbort(HERE); n++)
	{
		if(LocalRead((DWORDLONG)n * (DWORDLONG)m_dwBufferSize,m_pdwBuffer1,m_dwBufferSize))
		{
			// Don't do anything with the data right now, we just want to read
		}
		else
			break;
	}
	// We aren't going to worry about reading the last partial block because
	// it should only be a small fraction of the large size of the files that
	// this test is intended to read.

	return;

}

////////////////////////////////////////////////////////////////////////////////
// qwPosition and cbLength must be multiples of the sector size of the device.
// m_szFilePath must be defined for error reporting
#ifdef XHD_TAG
bool CXModuleHardDisk::LocalWrite(LONGLONG qwPosition,LPVOID lpBuffer,DWORD cbLength)
#else
bool CXModuleDVD::LocalWrite(LONGLONG qwPosition,LPVOID lpBuffer,DWORD cbLength)
#endif
{
	DWORD cb;

	LARGE_INTEGER qwOffset;
	LARGE_INTEGER qwSave;
	DWORD dwLastError;

	qwOffset.QuadPart = qwPosition;
	qwSave.QuadPart = qwPosition;

	qwOffset.LowPart =
		SetFilePointer(m_hDevice,qwOffset.LowPart,&qwOffset.HighPart,FILE_BEGIN);

//	if((qwSave.QuadPart != qwOffset.QuadPart) || (GetLastError() != NO_ERROR))
	if ((qwOffset.LowPart == INVALID_SET_FILE_POINTER) && ((dwLastError = GetLastError()) != NO_ERROR))
	{
		err_RE_SET_FILE_POINTER((DWORDLONG)qwSave.QuadPart, dwLastError);
		return false;
	}

	if(!WriteFile(
		m_hDevice,
		lpBuffer,
		cbLength,
		&cb,
		NULL))
	{
		err_RE_WRITE_LOGICAL_P3L((m_szFilePath[0] != 0) ? m_szFilePath : "Unknown", cbLength, (DWORDLONG)qwPosition);
		return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////
// qwPosition and cbLength must be multiples of the sector size of the device.
// m_szFilePath must be defined for error reporting
#ifdef XHD_TAG
bool CXModuleHardDisk::LocalRead(LONGLONG qwPosition,LPVOID lpBuffer,DWORD cbLength)
#else
bool CXModuleDVD::LocalRead(LONGLONG qwPosition,LPVOID lpBuffer,DWORD cbLength)
#endif
{
	DWORD cb;

	LARGE_INTEGER qwOffset;
	LARGE_INTEGER qwSave;
	DWORD dwLastError;

	qwOffset.QuadPart = qwPosition;
	qwSave.QuadPart = qwPosition;

	qwOffset.LowPart =
		SetFilePointer(m_hDevice,qwOffset.LowPart,&qwOffset.HighPart,FILE_BEGIN);

//	if((qwSave.QuadPart != qwOffset.QuadPart) || (dwLastError = GetLastError() != NO_ERROR))
	if ((qwOffset.LowPart == INVALID_SET_FILE_POINTER) && ((dwLastError = GetLastError()) != NO_ERROR))
	{
		err_RE_SET_FILE_POINTER((DWORDLONG)qwSave.QuadPart, dwLastError);
		return false;
	}

	if(!ReadFile(
		m_hDevice,
		lpBuffer,
		cbLength,
		&cb,
		NULL))
	{
		err_RE_READ_LOGICAL_P4L((m_szFilePath[0] != 0) ? m_szFilePath : "Unknown", cbLength, (DWORDLONG)qwPosition, GetLastError());
		return false;
	}

	return true;
}

#ifdef XHD_TAG
void CXModuleHardDisk::vNewSeed(UINT *pSeed)
#else
void CXModuleDVD::vNewSeed(UINT *pSeed)
#endif
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	GetSystemTime(&systimeSeed);
	SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
	*pSeed = (UINT)filetimeSeed.dwLowDateTime;

	return;
}

#ifdef XHD_TAG
DWORD CXModuleHardDisk::random(UINT *pScratch)
#else
DWORD CXModuleDVD::random(UINT *pScratch)
#endif
{
	DWORD ret;
	ret  = (*pScratch = *pScratch * 214013L + 2531011L) >> 16;
	ret |= (*pScratch = *pScratch * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}

// pArray must contain 0xFFFFFFFF as its list terminator
#ifdef XHD_TAG
bool CXModuleHardDisk::bLookup(DWORD *pArray, DWORD dwValue)
#else
bool CXModuleDVD::bLookup(DWORD *pArray, DWORD dwValue)
#endif
{
	DWORD i = 0;

	// Find either the next empty location in the list, or the first instance of this dwValue
	while ((pArray[i] != 0xFFFFFFFF) && (pArray[i] != dwValue))
		i++;
	if (pArray[i] == 0xFFFFFFFF)
		return false;
	else
		return true;
}

// pArray must contain 0xFFFFFFFF as its list terminator
#ifdef XHD_TAG
void CXModuleHardDisk::vSet(DWORD *pArray, DWORD dwValue)
#else
void CXModuleDVD::vSet(DWORD *pArray, DWORD dwValue)
#endif
{
	DWORD i = 0;

	// Find either the next empty location in the list, or the first instance of this dwValue
	while ((pArray[i] != 0xFFFFFFFF) && (pArray[i] != dwValue))
		i++;
	if (pArray[i] == 0xFFFFFFFF)
		pArray[i] = dwValue;
}

// This function will checksum the contents and names of all files listed
// in configuration parameters.  This does NOT recurse into subdirectories,
// so all subdirectories that need to be checksummed should be included in
// the parameter list.
// The function will also checksum specified ranges of Logical Blocks on the media
// and combine the checksum with any checksum calculated from the file checksumming
// portion of the function.

#ifdef XHD_TAG
void CXModuleHardDisk::vPerformChecksum ()
{
	bool bChecksumDVD = false;
#else
void CXModuleDVD::vPerformChecksum ()
{
	bool bChecksumDVD = true;
#endif
	#define READ_BUFFER_SIZE 524288 // Half a MB should be good to start with
	WIN32_FIND_DATA FindFileData;
	BOOL bFileResult;
	DWORD dwChecksum = 0;
	DWORD dwFileAttributes, dwFileSize, dwReadThisTime, dwBytesRead, dwBytesReadSoFar;
	HANDLE hFile;
	char *pcDataBuffer;
	DWORD i, dwLastError;
	DWORD dwTotalRangeSize, dwNumBytesToRead;
	DWORDLONG dwlOffsetToRead;
	char szWildcard[MAX_PATH];
	char szFullPath[MAX_PATH];
	wchar_t wszTempString[256];
	LPCTSTR pwszTemp = NULL;

	if ((pcDataBuffer = new char[READ_BUFFER_SIZE]) == NULL)
	{
		// Return a memory allocation error
		err_RE_OUT_OF_MEMORY_P1(READ_BUFFER_SIZE);
		return;
	}
	if (m_pwszChecksumPath != NULL)
	{
		i = 0;
		while (m_pwszChecksumPath[i] != NULL)
		{
			sprintf(szWildcard, "%S\\*", m_pwszChecksumPath[i]);

			if ((hDir = FindFirstFileA(szWildcard, &FindFileData)) == INVALID_HANDLE_VALUE)
			{
				dwLastError = GetLastError();
				if (err_RE_FILE_NOT_FOUND_P2(szWildcard, dwLastError))
				{
					delete [] pcDataBuffer;
					return;
				}
			}
			else
			{
				do {
//					ReportDebug(BIT0, L"Checksum is: 0x%8.8lx", dwChecksum);
					sprintf(szFullPath, "%S\\%s", m_pwszChecksumPath[i], FindFileData.cFileName);
					// Add the name of the file or directory to the checksum
					vAddToChecksum(szFullPath, strlen(szFullPath), &dwChecksum);
					// Check to see if this is a file or directory
					if ((dwFileAttributes = GetFileAttributes(szFullPath)) != (DWORD)(-1))
					{
						if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) // This is not a directory
						{
							ReportDebug(BIT0, L"Found file %S", szFullPath);
							// Now open the file for reading
							hFile = CreateFileA (szFullPath,
								GENERIC_READ, //|GENERIC_WRITE,
								0, NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL);
							if (hFile != INVALID_HANDLE_VALUE)
							{
								if ((dwFileSize = GetFileSize (hFile, NULL)) != -1) // Don't worry about files larger than 4 GB
								{
//									ReportDebug(BIT0, L"%S is %lu bytes", szFullPath, dwFileSize);
									dwBytesReadSoFar = 0;
									while (dwFileSize > 0)
									{
										if (dwFileSize > READ_BUFFER_SIZE)
											dwReadThisTime = READ_BUFFER_SIZE;
										else
											dwReadThisTime = dwFileSize;
										if (ReadFile (hFile, pcDataBuffer, dwReadThisTime, &dwBytesRead, NULL))
										{
											// Add the read data to the checksum
											vAddToChecksum(pcDataBuffer, dwReadThisTime, &dwChecksum);
										}
										else
										{
											err_RE_READ_LOGICAL_P4L(szFullPath, dwReadThisTime, (DWORDLONG)dwBytesReadSoFar, GetLastError());
											CloseHandle(hFile);
											FindClose(hDir);
											delete [] pcDataBuffer;
											return;
										}
										dwFileSize = dwFileSize - dwBytesRead;
										dwBytesReadSoFar = dwBytesReadSoFar + dwBytesRead;
									}
								}
								else // Could not get the file size
								{
									err_COULDNT_DETERMINE_FILE_SIZE(szFullPath);
									CloseHandle(hFile);
									FindClose(hDir);
									delete [] pcDataBuffer;
									return;
								}
								CloseHandle(hFile); // Close out the handle
							}
							else  // We were not able to open the file
							{
								err_OPEN_DEVICE_P1L(szFullPath);
								FindClose(hDir);
								delete [] pcDataBuffer;
								return;
							}
						}
						else // This is a directory
						{
							ReportDebug(BIT0, L"Found directory %S", szFullPath);
						}
					}
					else // Error getting file attributes
					{
						err_GETTING_FILE_ATTRIBUTES_P2(szFullPath);
						FindClose(hDir);
						delete [] pcDataBuffer;
						return;
					}
				}while ((bFileResult = FindNextFile(hDir, &FindFileData)) == TRUE);
				if ((dwLastError = GetLastError()) != ERROR_NO_MORE_FILES) // Some error happened looking for files in this directory
				{
					if (err_FILE_ENUMERATION_P2(szWildcard, dwLastError))
					{
						FindClose(hDir);
						delete [] pcDataBuffer;
						return;
					}
				}
			}
			FindClose(hDir);
			i++;
		}
	}
	// Now checksum the logical blocks, if any, that were specified
	if (m_dwNumOfChecksumSectorRanges > 0)
	{
		if(!PhysicalDeviceOpen(false, bChecksumDVD))
		{
			delete [] pcDataBuffer;
			return;
		}
		for (i = 0; i < m_dwNumOfChecksumSectorRanges; i++)
		{
			dwlOffsetToRead = (DWORDLONG)m_pdwChecksumSectorStart[i] * (DWORDLONG)m_dwBytesPerSector;
			dwTotalRangeSize = ((m_pdwChecksumSectorEnd[i] - m_pdwChecksumSectorStart[i]) + 1) * m_dwBytesPerSector;
			while (dwTotalRangeSize > 0)
			{
				dwNumBytesToRead = dwTotalRangeSize;
				if (dwTotalRangeSize > READ_BUFFER_SIZE)
					dwNumBytesToRead = READ_BUFFER_SIZE;
				ReportDebug(BIT0, L"Starting sector 0x%lx, reading 0x%lx sectors", (DWORD)(dwlOffsetToRead/(DWORDLONG)m_dwBytesPerSector), (DWORD)(dwNumBytesToRead/(DWORDLONG)m_dwBytesPerSector));
				if(LocalRead(dwlOffsetToRead,pcDataBuffer,dwNumBytesToRead))
				{
					vAddToChecksum(pcDataBuffer, dwNumBytesToRead, &dwChecksum);
				}
				else // Read error
				{
					delete [] pcDataBuffer;
					return;
				}
				dwTotalRangeSize = dwTotalRangeSize - dwNumBytesToRead;
				dwlOffsetToRead = dwlOffsetToRead + (DWORDLONG)dwNumBytesToRead;
			}
		}
	}

	delete [] pcDataBuffer;

	// Now compare the checksum with the valid, expected checksums
	if (m_dwNumOfChecksums != 0)
	{
		if (m_pdwChecksumAllowed != NULL)
		{
			if (m_pdwChecksumAllowed[0] != 0) // The first checksum of 0 is a special case that indicates not to do a checksum comparison
			{
				for (i = 0; i < m_dwNumOfChecksums; i++)
				{
					if (m_pdwChecksumAllowed[i] == dwChecksum)
					{


						swprintf(wszTempString, L"ChecksumKernelRevisionAllowed[%2.2lu]", i);
						if ((pwszTemp = GetCfgString (wszTempString, NULL)) != NULL)
						{
							#define OS_VERSION_SIZE           20
							wchar_t XBoxOSVersion[OS_VERSION_SIZE+1];

							// Now get the actual revision information from the Kernel
							memset(XBoxOSVersion, 0, sizeof(XBoxOSVersion)); // Clear out the buffer first
							_snwprintf(XBoxOSVersion, sizeof(XBoxOSVersion)/sizeof(wchar_t), L"%d.%02d.%d.%02d", XboxKrnlVersion->Major, XboxKrnlVersion->Minor, XboxKrnlVersion->Build, (XboxKrnlVersion->Qfe & 0x7FFF));
							if(wcsicmp(pwszTemp, XBoxOSVersion) != 0) // Strings do not match
							{
								err_WRONG_CHECKSUM_FOR_KERNEL_P3(dwChecksum, pwszTemp, XBoxOSVersion);
								return;
							}
						}
						break;

					}
				}
				if (i == m_dwNumOfChecksums)
				{
					err_CHECKSUM_BAD_P1(dwChecksum);
					return;
				}
			}
		}
	}
}

// Add all DWORDs in the buffer passed in.  All dwLengthToAdd
// bytes are added, even if the total is not an even number of DWORDs
#ifdef XHD_TAG
void CXModuleHardDisk::vAddToChecksum (char *cStringToAdd, DWORD dwLengthToAdd, DWORD *pdwChecksum)
#else
void CXModuleDVD::vAddToChecksum (char *cStringToAdd, DWORD dwLengthToAdd, DWORD *pdwChecksum)
#endif
{
	DWORD i, dwRemainder, dwRemValue;
	DWORD *pdwLocal = (DWORD *)cStringToAdd;

//	ReportDebug(BIT0, _T("Adding a buffer of %lu bytes to the checksum"), dwLengthToAdd);
	// This will add all but the last fractional DWORD
	for (i = 0; i < dwLengthToAdd/sizeof(DWORD); i++)
	{
		*pdwChecksum = *pdwChecksum + pdwLocal[i];
	}
	dwRemainder = dwLengthToAdd - (i*sizeof(DWORD));
	if (dwRemainder > 0)
	{
		dwRemValue = 0;
		memcpy(&dwRemValue, &pdwLocal[i], dwRemainder);
		*pdwChecksum = *pdwChecksum + dwRemValue;
	}
}
#endif // XHD_MAIN
#undef XHD_MAIN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\xgrafx.cpp ===
//-----------------------------------------------------------------------------
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// xgrafx.cpp - Graphics testing module for xmta.
//
//-----------------------------------------------------------------------------

#include "..\..\stdafx.h"
#include "..\..\testobj.h"
#include "xgrafx.h"
#include "crc32.h"
//********************************************************
//Some special code for performing the hardware CRC check.
//
DWORD g_DoChecksum = 0;
DWORD g_Channel = 0;
DWORD g_Value[3];


void __cdecl ChecksumCallback(DWORD Frame)
{
	if(g_DoChecksum)
	{
		if(g_Channel > 0)
		{
			//OutputDebugString(L"Local CRC callback");
			g_Value[g_Channel - 1] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF;
		}

		if(g_Channel < 3)
		{
			*(volatile DWORD *)0xFD680844 = 0x411 | (g_Channel << 8);
			*(volatile DWORD *)0xFD680844 = 0x410 | (g_Channel << 8);

			g_Channel++;
		}
		else
		{
			g_Channel = 0;
			g_DoChecksum = 0;
		}
	}
}


/*
void __cdecl ChecksumCallback(DWORD Frame)
{
	if(g_DoChecksum)
	{
		if(g_Channel < 3)
		{
			//OutputDebugString(L"Local CRC callback");
			g_Value[g_Channel ] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF;
		}

		if(g_Channel > 0)
		{
			*(volatile DWORD *)0xFD680844 = 0x411 | ((g_Channel-1) << 8);
			*(volatile DWORD *)0xFD680844 = 0x410 | ((g_Channel-1) << 8);

			g_Channel--;
		}
		else
		{
			g_Channel = 3;
			g_DoChecksum = 0;
		}
	}
}
*/


void GetScreenChecksum(DWORD *pRed, DWORD *pGreen, DWORD *pBlue)
{
	g_Value[0] = g_Value[1] = g_Value[2] = 0;
	g_DoChecksum = 1;
	g_Channel = 0;

	D3DDevice_BlockUntilVerticalBlank();
	
	g_DoChecksum = 1;
	g_Channel = 0;

	while(g_DoChecksum)
	{
		D3DDevice_BlockUntilVerticalBlank();
	}
	
	*pRed	= g_Value[0];
	*pGreen	= g_Value[1];
	*pBlue	= g_Value[2];
}



IMPLEMENT_MODULELOCKED (CXModuleGrafx);

bool CXModuleGrafx::InitializeParameters ()
{
	if (!CTestObj::InitializeParameters ())
		return false;

	//Init params before attempting to retrieve.
	//Params for all tests
	m_pBackBuffer       = NULL;
    m_BackBufferFormat  = g_d3dpp.BackBufferFormat;
    m_DepthBufferFormat = g_d3dpp.AutoDepthStencilFormat;
	m_hardwareCRC = GetCfgInt( L"hardware_crc", 1);

	//Params for 3DSurface Test
	m_pBackgroundVB		= NULL;
	m_pSpotLightTexture = NULL;
	m_dwDisplayWidth    = g_d3dpp.BackBufferWidth;
    m_dwDisplayHeight   = g_d3dpp.BackBufferHeight;
	_stprintf(m_modeString, _T("%lux%lu"), m_dwDisplayWidth, m_dwDisplayHeight);
	m_bpp				= 32;
	


	//Params for vidmemory test
	m_pD3Ds = NULL;
	m_newSurfaces = 0;
	
	//Params for shapes test
	m_pVB = NULL;
	m_pVB2 = NULL;
	m_pVB3 = NULL;
	m_pTriangles = NULL;
	m_pTriangles2 = NULL;
	m_pTriangles3 = NULL;

	m_numTriangles = 0;

	if (CheckAbort (HERE)) return true;

	//Params required for all tests.
	m_expectedCRC = GetCfgUint( L"crc", 0xffffffff);
	m_testScenes = GetCfgInt( L"scenes", 1);
		
	//Video memory test
	m_mbytesTested = GetCfgUint( L"mbytes_tested", 32);

	//Video memory patern test
	m_vidmemPattern = (unsigned char)GetCfgInt( L"bit_pattern", 0xAA);
		
	//Params for Shapes test
	m_numTriangles = GetCfgInt(L"triangles", 21800);
		
	
	//---------------------------
	// ** Params for HDTV Test **
	//
	//Global params.
	m_HDTVTestPattern = GetCfgString( L"test", NULL);

	m_HDTVmode = GetCfgString( L"hdtv_mode", NULL);
	m_wPixelThreshold = (WORD)GetCfgUint( L"pixel_thresh", 0);
	m_wThresholdRangeStep = (WORD)GetCfgUint( L"range_step", 10);
	m_wHSyncThreshold = (WORD)GetCfgUint( L"hsync_thresh", 0);
	m_wVSyncThreshold = (WORD)GetCfgUint( L"vsync_thresh", 0);
	m_dwTolerance = GetCfgUint( L"tol", 0);
	m_testRetries = GetCfgInt( L"retries", 1);
	m_secondsToDisplay = 1000 * (GetCfgInt( L"std", 0));

	//Pixelcount test params.
	m_dwExpectedGreenCount = GetCfgUint( L"green", 0);
	m_dwExpectedRedCount = GetCfgUint( L"red", 0);
	m_dwExpectedBlueCount = GetCfgUint( L"blue", 0);
	m_PixelCountPattern = GetCfgInt( L"pattern", 2);
	m_bBitmapFromFile = GetCfgInt(L"bitmap_from_file", 0);
	_stprintf(m_BitmapFileName, _T("%s_pattern.bmp"),m_modeString);
	
	//Timings test params.
	m_VertFrontPorch1 = (BYTE)GetCfgInt( L"vfp1", -1);
	m_VertBackPorch1 = (BYTE)GetCfgInt( L"vbp1", -1);
	m_VertFrontPorch2 = (BYTE)GetCfgInt( L"vfp2", -1);
	m_VertBackPorch2 = (BYTE)GetCfgInt( L"vbp2", -1);
	m_wVertSyncLow = (WORD)GetCfgUint( L"vsl", -1);
	m_wVertSyncHigh = (WORD)GetCfgUint( L"vsh", -1);
	m_wHorizBackPorch = (WORD)GetCfgUint( L"hbp", -1);
	m_wHorizFrontPorch = (WORD)GetCfgUint( L"hfp", -1);
	m_wHorizSyncLow = (WORD)GetCfgUint( L"hsl", -1);
	m_wHorizSyncHigh = (WORD)GetCfgUint( L"hsh", -1);
	
	//AnalogColors test params.
	m_wNumLines = (WORD)GetCfgUint( L"lines", -1);
	m_wNumSamples = (WORD)GetCfgUint( L"samples", -1);
	m_wStartLine = (WORD)GetCfgUint( L"start_line", -1);
	m_hDelay = (BYTE)GetCfgInt( L"h_delay", -1);
	m_wLinearTolerance = (WORD)GetCfgUint( L"dac_tolerance", -1);
	m_GY_LowerThreshold = (WORD)GetCfgUint( L"gy_lower", -1);
	m_BPb_LowerThreshold = (WORD)GetCfgUint( L"bpb_lower", -1);
	m_RPr_LowerThreshold = (WORD)GetCfgUint( L"rpr_lower", -1);
	m_GY_UpperThreshold = (WORD)GetCfgUint( L"gy_upper", -1);
	m_BPb_UpperThreshold = (WORD)GetCfgUint( L"bpb_upper", -1);
	m_RPr_UpperThreshold = (WORD)GetCfgUint( L"rpr_upper", -1);
	
	//TriLevel Sync parameters
	m_syncMode = GetCfgInt(L"sync_mode", -1);
	m_syncType = GetCfgString( L"sync_type", NULL);
		
	//pColorData is used by both the DAC and TriLevel tests.
	pColorData = NULL;

		
	if(m_hardwareCRC)//Use hardware CRC.
	{
		ReportDebug(DEBUG_LEVEL1, L"Test will use HARDWARE CRC calculations.\n");
		D3DDevice_SetVerticalBlankCallback(ChecksumCallback);
		//D3DDevice_SetVerticalBlankCallback(D3DTest_ChecksumCallback);
	}

    return TRUE;
}


DWORD CXModuleGrafx::UpdateImageRectCRC(LONG height, BYTE *pBits, LONG pitch, int bytesPerLine)
{
	// Update the CRC with pixel data using the provided memory parameters
	DWORD crc = DEFAULT_CRC;
	LONG line;
	
	for (line=0; line<height; line++) {
		crc = ::updateCRC32(pBits, bytesPerLine, crc);
		pBits += pitch;
		ReportDebug(DEBUG_LEVEL2, _T("Line%d, CRC=0x%x\n"),line, crc);
	}
	
	return crc;
}

DWORD CXModuleGrafx::GetDisplayBufferCRC()
{
	// Update the CRC with pixel data using the provided memory parameters
	DWORD dwRed = 0;
	DWORD dwGreen = 0;
	DWORD dwBlue = 0;
	DWORD dwCompositeCRC = 0;

	//D3DTest_GetScreenChecksum(&dwRed, &dwGreen, &dwBlue);
	GetScreenChecksum(&dwRed, &dwGreen, &dwBlue);
	dwCompositeCRC = dwRed*dwGreen*dwBlue;
	
	ReportDebug(DEBUG_LEVEL1, _T("HardwareCRC: Red=0x%x, Green=0x%x, Blue=0x%x\n"),dwRed, dwGreen, dwBlue);
	ReportDebug(DEBUG_LEVEL1, _T("Composite HardwareCRC=0x%x\n"), dwCompositeCRC);
	
	return dwCompositeCRC;
}

VOID CXModuleGrafx::ReportD3DError(DWORD error)
{

	switch(error)
	{
		case D3D_OK:
			err_DIRECTX_API (m_modeString, error, L"D3D_OK - No error occurred");
			break;

		case D3DERR_CONFLICTINGRENDERSTATE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_CONFLICTINGRENDERSTATE - Currently set render states can't be used together");
			break;

		case D3DERR_CONFLICTINGTEXTUREFILTER:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_CONFLICTINGTEXTUREFILTER - Current texture filters can't be used together");
			break;

		case D3DERR_CONFLICTINGTEXTUREPALETTE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_CONFLICTINGTEXTUREPALETTE - Current textures can't be used simultaneously");
			break;

		case D3DERR_DEVICELOST:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_DEVICELOST - Device is lost and can't be restored, so rendering is not possible");
			break;

		case D3DERR_DEVICENOTRESET:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_DEVICENOTRESET - Device cannot be reset");
			break;

		case D3DERR_DRIVERINTERNALERROR:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_DRIVERINTERNALERROR - Internal driver error");
			break;

		case D3DERR_INVALIDCALL:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_INVALIDCALL - The method call is invalid. For example, a method's parameter may have an invalid value");
			break;

		case D3DERR_INVALIDDEVICE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_INVALIDDEVICE - The requested device type is not valid");
			break;

		case D3DERR_MOREDATA:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_MOREDATA - There is more data available than the specified buffer size can hold");
			break;

		case D3DERR_NOTAVAILABLE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_NOTAVAILABLE - This device does not support the queried technique");
			break;

		case D3DERR_NOTFOUND:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_NOTFOUND - The requested item was not found");
			break;

		case D3DERR_OUTOFVIDEOMEMORY:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_OUTOFVIDEOMEMORY - Direct3D does not have enough display memory to perform the operation");
			break;

		case D3DERR_TOOMANYOPERATIONS:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_TOOMANYOPERATIONS - Application is requesting more texture-filtering operations than the device supports");
			break;

		case D3DERR_UNSUPPORTEDALPHAARG:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDALPHAARG - Device does not support a specified texture-blending argument for the alpha channel");
			break;

		case D3DERR_UNSUPPORTEDALPHAOPERATION:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDALPHAOPERATION - Device does not support a specified texture-blending operation for the alpha channel");
			break;

		case D3DERR_UNSUPPORTEDCOLORARG:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDCOLORARG - Device does not support a specified texture-blending argument for color values");
			break;

		case D3DERR_UNSUPPORTEDCOLOROPERATION:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDCOLOROPERATION - Device does not support a specified texture-blending operation for color values");
			break;

		case D3DERR_UNSUPPORTEDFACTORVALUE:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDFACTORVALUE - Device does not support the specified texture factor value");
			break;

		case D3DERR_UNSUPPORTEDTEXTUREFILTER:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_UNSUPPORTEDTEXTUREFILTER - Device does not support the specified texture filter");
			break;

		case D3DERR_WRONGTEXTUREFORMAT:
			err_DIRECTX_API (m_modeString, error, L"D3DERR_WRONGTEXTUREFORMAT - Pixel format of the texture surface is not valid");
			break;

		case E_FAIL:
			err_DIRECTX_API (m_modeString, error, L"E_FAIL - An undetermined error occurred inside the Direct3D subsystem");
			break;

		case E_INVALIDARG:
			err_DIRECTX_API (m_modeString, error, L"E_INVALIDARG - An invalid parameter was passed to the returning function");
			break;

//		case E_INVALIDCALL:
//			err_DIRECTX_API (error, L"E_INVALIDCALL - The method call is invalid. For example, a method's parameter may have an invalid value.");
//			break;

		case E_OUTOFMEMORY:
			err_DIRECTX_API (m_modeString, error, L"E_OUTOFMEMORY - Direct3D could not allocate sufficient memory to complete the call");
			break;
	}

}


VOID CXModuleGrafx::MainCleanup()
{  //Called befor exiting under any condition.

	//Release all additional surfaces that may have been created.
	for(int i = 0; i < m_newSurfaces; i++)
	{
		SAFE_RELEASE(m_pD3Ds[i]);
	}

	SAFE_DELETE_ARRAY(m_pD3Ds);
	SAFE_DELETE_ARRAY(m_pTriangles);
	SAFE_DELETE_ARRAY(m_pTriangles2);
	SAFE_DELETE_ARRAY(m_pTriangles3);
	SAFE_RELEASE(m_pBackgroundVB);
	SAFE_RELEASE( m_pVB);
	SAFE_RELEASE( m_pVB2);
	SAFE_RELEASE( m_pVB3);
	SAFE_RELEASE( m_pBackBuffer);
	SAFE_RELEASE( m_pSpotLightTexture);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xhard_disk\xhard_disk.cpp ===
#define XHD_TAG
#define XHD_MAIN
#include "xdisk.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\XbUtil.Cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( lock.pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    pSurface->UnlockRect();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 5, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 6 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xgrafx\xgrafx\XbUtil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>

#pragma warning (disable:4100)//type conversion for GetBackBuffer() with -1 as argument.


//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xlan\xlan.h ===
#pragma once
#define QWORD _int64

// Disable the compiler warning for a non threatening condition.
// C4512: unable to generate an assignment operator for the given class. 

#pragma warning (disable:4512)
#include "..\parameter.h"

// Naming of class test and module classes.
// 
// module class: CXModule<module>
// test class:   CXModule<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//
#define LAN_MODNUM   16

#define NO_FLAGS_SET 0
#define PORT (u_short)  44966
#define DATASIZE 1024

class CXModuleLAN : public CTestObj
{
public: 
	// Get module number from numbers.h
	// If this is a new module, add the number to the file.
	//
	DECLARE_XMTAMODULE (CXModuleLAN, "LAN", LAN_MODNUM);

	virtual bool InitializeParameters ();
//	virtual ~CXModuleLAN();

protected:
	wchar_t * TestNamePtr;
	void MessageLog( char *);
	void SendPattern();
	BOOL RecvPattern( BOOL ErrorsOn, char WaitTime);
	void NoisePattern();
	void OFFONPattern();
	void RandomPattern();
	char SendBuffer[DATASIZE];
	char RecvBuffer[DATASIZE];
	SOCKET destSocket;
	WSADATA Data;
	SOCKADDR_IN destSockAddr;
	unsigned char Code;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xlan\xlan.cpp ===
// (c) Copyright 2001 Intel Corp. All rights reserved.
//
// Title: xlan  
//
// History:
//
// 8/20/2001 V1.00 SSS Release V1.00.
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-2001 Intel Corp. All rights reserved.
// Disable the compiler warning for a non threatening condition.
// C4512: unable to generate an assignment operator for the given class. 
// version number

#pragma comment(exestr,"version_number=1.00.0.010")
#include "..\stdafx.h"
#include "..\testobj.h"
#include <winsockx.h>
#include "..\host.h"
#include "xlan.h"

IMPLEMENT_MODULEUNLOCKED (CXModuleLAN);

bool CXModuleLAN::InitializeParameters ()
{
	// Call the base class.  This is REQUIRED

	if (!CTestObj::InitializeParameters ())
		return false;

	return true;
}


IMPLEMENT_TESTUNLOCKED (LAN, UDPResponder, 1)
{
	TCHAR StrOutput[512];
	wchar_t TestName[] = L"UDPResponder";
	int Status;
	int enable = 1;
	int iError;
	DWORD x;
	DWORD ConnectTries;
	
	try 
	{
		// clear the error code
		Code = 0;
		_stprintf(StrOutput,_T("in code\n"));
		OutputDebugString(StrOutput);
		TestNamePtr = TestName;

	// start the UDP responder app on the host

	if ((iError = g_host.iSendHost(MID_UDP_RESPONDER, NULL, 0)) != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		ReportError(1,L"iSendHostError, Code = %x",iError);
		return;
	}


  // initialize the Windows Socket DLL 
  Status=WSAStartup(MAKEWORD(1, 1), &Data);
  if (Status != 0)
  {
    ReportDebug(2,L"ERROR: WSAStartup unsuccessful");
	exit(1);

  }

  // specify the IP address 
  destSockAddr.sin_addr.s_addr=
    htonl(INADDR_BROADCAST);
  // specify the port portion of the address 
  destSockAddr.sin_port=htons(PORT);
  // specify the address family as Internet 
  destSockAddr.sin_family=AF_INET;

  // create a socket 
  destSocket=socket(AF_INET, SOCK_DGRAM, 0);
  if (destSocket == INVALID_SOCKET)
  {
    ReportError(1,L"ERROR: socket unsuccessful");
    Status=WSACleanup();
    if (Status == SOCKET_ERROR)
	{
      ReportError(1,L"ERROR: WSACleanup unsuccessful");
	}
    return;
  }

  // permit broadcasting on the socket 
  Status=setsockopt(destSocket, SOL_SOCKET,
	  SO_BROADCAST, (char *) &enable,
      sizeof(enable));
  if (Status != 0)
	  ReportError(1,L"ERROR: setsockopt unsuccessful");
  
  //Poll for a responce from the responder
  
  	if((ConnectTries = GetCfgUint(L"ConenctTries",1)) == 0)
	{
		ReportError(0x10,L"ConnectTries config param missing");
		return;
	}

  for(x=0;x<ConnectTries;x++)
  {
	  SendBuffer[0] = 0x69;
	  SendPattern();
	  // look for responce, no errors 1 second delay
	  RecvPattern(0,1);
	  if( RecvBuffer[0] == 0x69)
		  break;
	  // wait a second before trying again
	  Sleep(1000); 
  }
  
	// send and recv the test pattern
	NoisePattern();

	Status=closesocket(destSocket);
	if (Status == SOCKET_ERROR)
	{
		ReportError(1,L"ERROR: closesocket unsuccessful");
	}
	Status=WSACleanup();
	if (Status == SOCKET_ERROR)
	{
		ReportError(1,L"ERROR: WSACleanup unsuccessful");
	}

	}
	catch (CXmtaException &e)
	{
		// error already reported
		if (Code == 99) 
			return;
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}

void CXModuleLAN::SendPattern()
{
	int numsnt;
	int Status;
	ReportDebug(2,L"Sending...");
    numsnt=sendto(destSocket, SendBuffer,
      DATASIZE, NO_FLAGS_SET,
      (LPSOCKADDR) &destSockAddr,
        sizeof(destSockAddr));
    if (numsnt != DATASIZE)
    {
      ReportError(1,L"ERROR: sendto unsuccessful");
      Status=closesocket(destSocket);
      if (Status == SOCKET_ERROR)
        ReportError(1,L"ERROR: closesocket unsuccessful");
      Status=WSACleanup();
      if (Status == SOCKET_ERROR)
        ReportError(1,L"ERROR: WSACleanup unsuccessful");
    }
}

BOOL CXModuleLAN::RecvPattern( BOOL ErrorsOn, char LookTime)
{
	TIMEVAL WaitTime = {1,0}; // wait 270 seconds before error
	FD_SET FDReadSocket;
	FD_SET FDWriteSocket;
	int Status;
	int numrcv;

	FD_ZERO(&FDWriteSocket);
	FD_ZERO(&FDReadSocket);
	FD_SET(destSocket,&FDReadSocket);
	ReportDebug(2,L"Receiving...");

		Status = select(0,&FDReadSocket,&FDWriteSocket,&FDWriteSocket,&WaitTime);
		if(Status == 0)
		{
			if(ErrorsOn)
				ReportError(0x11,L"rec time expired\n");
			return 0;
		}


		// get the data from the socket
		numrcv=recvfrom(destSocket, RecvBuffer, DATASIZE,
			NO_FLAGS_SET, NULL, NULL);
		if (numrcv == SOCKET_ERROR)
		{
			ReportError(0x12,L"ERROR: UDP recvfrom host unsuccessful");
			Status=closesocket(destSocket);
			if (Status == SOCKET_ERROR)
			{
				ReportError(0x13,L"ERROR: closesocket unsuccessful");
			}
			Status=WSACleanup();
			if (Status == SOCKET_ERROR)
			{
				ReportError(0x14,L"ERROR: WSACleanup unsuccessful");
			}
			return 0;
		}
		return 1;
}

void CXModuleLAN::NoisePattern()
{
	DWORD DataHigh,DataLow;
	int bPatterns = 0;
	DWORD NoiseData =  0x00010001;
	int x;
	DWORD dwExpectedLoss;
	DWORD PacketLoss = 0;
	DWORD Loops,y;
	BYTE Checksum;
	
	if((Loops = GetCfgUint(L"Loops",1)) == 0)
	{
		ReportError(0x10,L"LAN Loops config param missing");
		return;
	}
	for(y=0;y<Loops;y++)
	{
		ReportDebug(4,L"Loop %x",y);
		for(bPatterns = 0; bPatterns<32; bPatterns++)
		{
			if (bPatterns < 16)
			{
				DataLow =  0xFFFFFFFF & ~(NoiseData << bPatterns);
				DataHigh = ~DataLow;
			}
			// 0111, 1011, 1101, 1110
			else
			{
				DataHigh =  0xFFFFFFFF & ~(NoiseData << bPatterns);
				DataLow = ~DataHigh;	
			}
			for(x=0;x<DATASIZE;x=x+8)
			{
				*((DWORD *)(SendBuffer+x)) = DataLow;
				*((DWORD *)(SendBuffer+x+4)) = DataHigh;
			}
			ReportDebug(2,L"Pattern x =%x Data = %8.8X %8.8X\n",bPatterns,*((DWORD *)(SendBuffer+x)),*((DWORD *)(SendBuffer+x+4)) );
			SendBuffer[2] = (BYTE)bPatterns; 
			SendBuffer[0] = 0;
			for(x=0;x<DATASIZE;x++)
			{
				SendBuffer[0] = SendBuffer[0] + SendBuffer[x];
			}
			ReportDebug(2,L"Checksum on outgoing %x",SendBuffer[0]);
			SendPattern();
			// clear recv buffer
			if(RecvPattern(0,5) == 0) // check for recv eror, message already printed
			{
				ReportDebug(0,L"A packet %x was lost",bPatterns);
				PacketLoss++;
				continue;
			}
			Checksum = 0;
			for(x=1;x<DATASIZE;x++)
			{
				Checksum = RecvBuffer[x] + Checksum;
			}
			if((BYTE)Checksum != (BYTE)RecvBuffer[0])
			{
				ReportError(1,L"LAN data checksum error Exp = 0x%2.2x Rec = 0x%2.2x Pattern = %8.8X",(BYTE)RecvBuffer[0],Checksum,*((DWORD *)(RecvBuffer+8)));
				break;
			}
			
		}
	}
	if((dwExpectedLoss =GetCfgUint(L"PacketLoss",0)) == 0)
	{
		ReportError(0x10,L"Lan PackLoss config param missing");
		return;
	}
	//scale by the amount sent
	if( (PacketLoss/Loops) > dwExpectedLoss)
	{
		ReportError(1,L"To many packets lost!  exp < %x rec = %x",dwExpectedLoss, PacketLoss);
	}
	
	// send a 42 to the host tester to tell it to exit
	ReportDebug(2,L"Send done code to responder");
	SendBuffer[0] = 0x42;
	SendPattern();
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xhard_disk\xhard_disk.h ===
// xHard_Disk.h - Hard Disk test

#if !defined(_XHARD_DISK_H_)
#define _XHARD_DISK_H_

// supress futile warnings about assignment operators
#pragma warning (disable:4512)

#include "..\parameter.h"


#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif

#define XHARD_DISK_MODNUM   14
#define XDVD_MODNUM   17


extern "C"
{
typedef struct _XBOX_KRNL_VERSION {
    USHORT Major;
    USHORT Minor;
    USHORT Build;
    USHORT Qfe;
} XBOX_KRNL_VERSION, *PXBOX_KRNL_VERSION;

extern const PXBOX_KRNL_VERSION XboxKrnlVersion;
} // end extern "C"

// These are a bunch of OS defines that allow us to access the hard drive at the physical level
// ********************************************************************************
// ********************************************************************************
// ********************************************************************************
#define InitializeObjectAttributes(p, n, a, r, s){\
	(p)->RootDirectory = r;   \
	(p)->Attributes = a;      \
	(p)->ObjectName = n;      \
	}

typedef struct _LSA_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

#ifndef _NTDEF_
typedef LSA_STRING STRING, *PSTRING ;
#endif

typedef STRING OBJECT_STRING;
typedef PSTRING POBJECT_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	HANDLE RootDirectory;
	POBJECT_STRING ObjectName;
	ULONG Attributes;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

// NTSTATUS
//
typedef LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.


// Other defines for accessing Nt kernal drive routines
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth
#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define SYNCHRONIZE                      (0x00100000L)
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008
#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define OBJ_CASE_INSENSITIVE                    0x00000040L

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
 
//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

// begin_ntddk begin_wdm begin_nthal
//
// Define the base asynchronous I/O argument types
//
typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID Pointer;
	};

	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
#define NTSYSCALLAPI DECLSPEC_IMPORT

extern "C"
{
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess, // SYNCHRONIZE | FILE_READ_DATA
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess, // 0
    IN ULONG OpenOptions // FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING
    );
}

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#define FILE_DEVICE_DISK                0x00000007
#define IOCTL_DISK_BASE                 FILE_DEVICE_DISK
#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0
#define IOCTL_DISK_GET_DRIVE_GEOMETRY   CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia,             // Fixed hard disk media
    F3_120M_512,            // 3.5", 120M Floppy
    F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    F8_256_128              // 8",     256KB,  128 bytes/sector
} MEDIA_TYPE, *PMEDIA_TYPE;

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    DWORD TracksPerCylinder;
    DWORD SectorsPerTrack;
    DWORD BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;

// ********************************************************************************
// ********************************************************************************
// ********************************************************************************


// Naming of class test and module classes.
// 
// module class: CX<module>
// test class:   CX<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//
#ifdef XHD_TAG
class CXModuleHardDisk : public CTestObj
{
public:
	DECLARE_XMTAMODULE (CXModuleHardDisk, "HardDisk", XHARD_DISK_MODNUM);  //(module name, module number)
#else
class CXModuleDVD : public CTestObj
{
public:
	DECLARE_XMTAMODULE (CXModuleDVD, "DVD", XDVD_MODNUM);  //(module name, module number)
#endif

protected:
	// Error messages declared here ...
	//(Note: 0x000 - 0x00f reserved for XMTA)
	//

	// Error routines return true if the calling routine should abort, and false otherwise
	bool err_BADPARAMETER (LPCTSTR s1)
	{
		ReportError (0x010, L"Configuration parameter \"%s\" doesn't exist or is invalid", s1); return (CheckAbort (HERE));
	}
	bool err_OPEN_FILE_P1L (char *s1)
	{
		ReportError (0x011, L"Failed to open the file \"%S\" that is needed to perform the drive test", s1); return (CheckAbort (HERE));
	}
	bool err_MutexHandle (char *s1)
	{
		ReportError (0x012,L"Could not get a handle for mutex %S ", s1); return (CheckAbort (HERE));
	}
	bool err_MutexTimeout (char *s1)
	{
		ReportError (0x013,L"Resource conflict, timed out waiting for mutex %S", s1); return (CheckAbort (HERE));
	}
	bool err_COULDNT_DETERMINE_FREE_SPACE (LPCTSTR s1)
	{
		ReportError (0x014, L"Could not determine how much free space is available on drive \"%s\"", s1); return (CheckAbort (HERE));
	}
	bool err_RE_EXTEND_FILE_P1L (DWORDLONG dwl1)
	{
		ReportError (0x015, L"Failed to extend free space file size to %I64u bytes.", dwl1); return (CheckAbort (HERE));
	}
	bool err_NO_BLOCKS_TO_TEST ()
	{
		ReportError (0x016, L"No blocks to test!  Reduce the BufferSize parameter to create more blocks."); return (CheckAbort (HERE));
	}
	bool err_RE_OUT_OF_MEMORY_P1 (DWORD dw1)
	{
		ReportError (0x017, L"Out-of-memory error.  Could not allocate %d bytes of memory.", dw1); return (CheckAbort (HERE));
	}
	bool err_RE_COMPAREBUF_P3 (DWORDLONG dwl1, DWORD dw1, DWORD dw2)
	{
		ReportError (0x018, L"Data miscompare @ device offset %I64u.\nExpected:0x%08X   Received:0x%08X", dwl1, dw1, dw2); return (CheckAbort (HERE));
	}
	bool err_RE_SET_FILE_POINTER (DWORDLONG dwl1, DWORD dw1)
	{
		ReportError (0x019, L"Failed to set file to offset %I64u.  GetLastError() returned %lu", dwl1, dw1); return (CheckAbort (HERE));
	}
	bool err_RE_WRITE_LOGICAL_P3L (char *cp1, DWORD dw1, DWORDLONG dwl1)
	{
		ReportError (0x01A, L"Error writing device \"%S\".\nCould not write %lu bytes to offset %I64u.", cp1, dw1, dwl1); return (CheckAbort (HERE));
	}
	bool err_RE_READ_LOGICAL_P4L (char *cp1, DWORD dw1, DWORDLONG dwl1, DWORD dw2)
	{
		ReportError (0x01B, L"Error reading device \"%S\".\nCould not read %u bytes from offset %I64u.  GetLastError() returned %lu", cp1, dw1, dwl1, dw2); return (CheckAbort (HERE));
	}
	bool err_OPEN_DEVICE_P1L (char *s1)
	{
		ReportError (0x01C, L"Failed to open device \"%S\" that is needed to perform this test", s1); return (CheckAbort (HERE));
	}
	bool err_RE_FILE_NOT_FOUND_P2 (char *s1, DWORD dw1)
	{
		ReportError (0x01D, L"No files found of type \"%S\", GetLastError() returned 0x%8.8lx", s1, dw1); return (CheckAbort (HERE));
	}
	bool err_RE_START_END_PERCENTAGE_P2 (double dbl1, double dbl2)
	{
		ReportError (0x01E, L"Starting percentage must be less than ending percentage.\nStarting Percentage = %lg   Ending Percentage = %lg", dbl1, dbl2); return (CheckAbort (HERE));
	}
	bool err_RE_DRIVE_GEOMETRY_P1L (char *s1, DWORD dw1)
	{
		ReportError (0x01F, L"GetDriveGeometry() failed for device \"%S\", GetLastError() returned 0x%8.8lx", s1, dw1); return (CheckAbort (HERE));
	}
	bool err_COULDNT_DETERMINE_FILE_SIZE (char *s1)
	{
		ReportError (0x020, L"Could not determine the size of file \"%S\"", s1); return (CheckAbort (HERE));
	}
	bool err_FILE_ENUMERATION_P2 (char *s1, DWORD dw1)
	{
		ReportError (0x021, L"An error happened while trying to find files of the type \"%S\", GetLastError() returned 0x%8.8lx", s1, dw1); return (CheckAbort (HERE));
	}
	bool err_GETTING_FILE_ATTRIBUTES_P2 (char *s1)
	{
		ReportError (0x022, L"Could not determine the attributes of file \"%S\"", s1); return (CheckAbort (HERE));
	}
	bool err_NOTHING_TO_CHECKSUM ()
	{
		ReportError (0x023, L"No files or directories were specified to checksum"); return (CheckAbort (HERE));
	}
	bool err_NO_CHECKSUMS ()
	{
		ReportError (0x024, L"No checksum values were specified"); return (CheckAbort (HERE));
	}
	bool err_CHECKSUM_BAD_P1 (DWORD dw1)
	{
		ReportError (0x025, L"The computed checksum 0x%8.8lx is not in the list of valid checksums", dw1); return (CheckAbort (HERE));
	}
	bool err_TEST_TIME_TOO_LONG (DWORD dw1, DWORD dw2)
	{
		ReportError (0x026, L"The test took %lu seconds to complete, which is longer than the maximum allowed time of %lu seconds", dw1, dw2); return (CheckAbort (HERE));
	}
	bool err_TEST_TIME_TOO_SHORT (DWORD dw1, DWORD dw2)
	{
		ReportError (0x027, L"The test took %lu seconds to complete, which is shorter than the minimum allowed time of %lu seconds", dw1, dw2); return (CheckAbort (HERE));
	}
	bool err_WRONG_CHECKSUM_FOR_KERNEL_P3 (DWORD dw1, LPCTSTR s1, LPCTSTR s2)
	{
		ReportError (0x028, L"The computed checksum 0x%8.8lx is valid for kernel %s, not kernel %s", dw1, s1, s2); return (CheckAbort (HERE));
	}



	// Parameters declared here ...
	//
	wchar_t m_chDriveLetter[2];
	DWORD m_dwDriveNumber;
	DWORD m_dwRandomSeed;
	DWORD m_dwNumberOfLoopsBetweenSpinDowns;
	DWORD m_dwSpinDownDelay;
	double m_dblFreeSpacePercent;
	double m_dblStartPercent, m_dblEndPercent;
	DWORD m_dwMaxLoops;
	DWORD m_dwMutexTimeout;
	LPCTSTR m_wszFileName;
	char m_szFilePath[MAX_PATH];
	HANDLE m_hDevice;
	HANDLE m_hXMTAHardDiskMutex;
	DWORDLONG m_qwDeviceSize;
	DWORD m_dwBufferSize;
	DISK_GEOMETRY m_Geometry;
	DWORD m_dwBytesPerSector;
	LPDWORD m_pdwBuffer1, m_pdwBuffer2, m_pdwMapArray;
	DWORD m_dwNumOfChecksums;
	DWORD *m_pdwChecksumAllowed;
	wchar_t **m_pwszChecksumPath;
	DWORD m_dwNumOfDVDChecksums;
	DWORD *m_pdwDVDChecksumAllowed;
	DWORD m_dwNumOfCDChecksums;
	DWORD *m_pdwCDChecksumAllowed;
	DWORD m_dwNumOfChecksumSectorRanges;
	DWORD *m_pdwChecksumSectorStart;
	DWORD *m_pdwChecksumSectorEnd;
	DWORD m_dwMinTestTime;
	DWORD m_dwMaxTestTime;
	DWORDLONG m_dwlStartTime;
	HANDLE hDir;

	virtual bool InitializeParameters ();
public:
	// Common functions go here.  Put any functions that need 
	// to be global to the tests in the module class
	//
#ifdef XHD_TAG
	virtual ~CXModuleHardDisk () // Destructor
#else
	virtual ~CXModuleDVD () // Destructor
#endif
	{
		if (m_pdwDVDChecksumAllowed != NULL)
		{
			delete [] m_pdwDVDChecksumAllowed;
			m_pdwDVDChecksumAllowed = NULL;
		}
		if (m_pdwCDChecksumAllowed != NULL)
		{
			delete [] m_pdwCDChecksumAllowed;
			m_pdwCDChecksumAllowed = NULL;
		}
		if (m_pdwChecksumAllowed != NULL)
		{
			delete [] m_pdwChecksumAllowed;
			m_pdwChecksumAllowed = NULL;
		}
		if (m_pwszChecksumPath != NULL)
		{
			delete [] m_pwszChecksumPath;
			m_pwszChecksumPath = NULL;
		}
		if (m_pdwChecksumSectorStart != NULL)
		{
			delete [] m_pdwChecksumSectorStart;
			m_pdwChecksumSectorStart = NULL;
		}
		if (m_pdwChecksumSectorEnd != NULL)
		{
			delete [] m_pdwChecksumSectorEnd;
			m_pdwChecksumSectorEnd = NULL;
		}
	}
	void vInitializeTestVariables ();
	void vCleanup();
	bool bGetPossessionOfHardDiskResources (char *MutexName);
	void vReleasePossessionOfHardDiskResources ();
	void vCompareTestTime();
	void vDVDRandomRead();
	void vFreeSpaceRandomWRC();
	bool FreeSpaceDeviceOpen();
	bool FileReadDeviceOpen();
	void vPhysicalDeviceSequentialRead ();
	bool PhysicalDeviceOpen(bool fWrite, bool bDVD);
	void vFileSequentialRead();
	bool LocalWrite(LONGLONG qwPosition,LPVOID lpBuffer,DWORD cbLength);
	bool LocalRead(LONGLONG qwPosition,LPVOID lpBuffer,DWORD cbLength);
	void vNewSeed(UINT *pSeed);
	DWORD random(UINT *pScratch);
	bool bLookup(DWORD *pArray, DWORD dwValue);
	void vSet(DWORD *pArray, DWORD dwValue);
	void vPerformChecksum ();
	void vAddToChecksum (char *cStringToAdd, DWORD dwLengthToAdd, DWORD *pdwChecksum);
};

#endif // _XHARD_DISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmemory\memutils.cpp ===
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-2000 Intel Corp. All rights reserved.
//
#include "..\stdafx.h"
//
// Used by the MFC framework to help find memory leaks.
//
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#pragma warning(disable:4035)	// no return value


//******************************************************************************
// Function name	: AsmDwordMemCmp
// Description	    : Compares two buffers for equality.  Maintains possible
//                    misalignment of buffers.
// Return type		: LPDWORD - virtual address of failing DWORD in destination buffer.
// Argument         : LPVOID pDst   - destination buffer
// Argument         : LPVOID pSrc   - source buffer
// Argument         : DWORD  dwLen  - length of buffers.
//******************************************************************************
LPDWORD AsmDwordMemCmp(LPVOID pDst,LPVOID pSrc,DWORD dwLen)
{
#if defined(WIN64)
	LPDWORD s = (LPDWORD)pSrc;
	LPDWORD d = (LPDWORD)pDst;

	while(dwLen--)
		if(*s++ != *d++)
			return --d;

	return NULL;
#else
	_asm
	{
			pushfd
			cld
			mov		edi,pDst
			mov		esi,pSrc
			mov		ecx,dwLen
	repe	cmpsd
			jne		failed		
			mov		edi,4	// return zero if successful
failed:		sub		edi,4	// edi contains 4 (success) or failing address + 4
			mov		eax,edi
			popfd
	}
#endif
}


//******************************************************************************
// Function name	: AsmWordMemCmp
// Description	    : Compares two buffers for equality.  Maintains possible
//                    misalignment of buffers.
// Return type		: LPWORD - virtual address of failing WORD in destination buffer.
// Argument         : LPVOID pDst   - destination buffer
// Argument         : LPVOID pSrc   - source buffer
// Argument         : DWORD  dwLen  - length of buffers.
//******************************************************************************
LPWORD AsmWordMemCmp(LPVOID pDst,LPVOID pSrc,DWORD dwLen)
{
#if defined(WIN64)
	LPWORD s = (LPWORD)pSrc;
	LPWORD d = (LPWORD)pDst;

	while(dwLen--)
		if(*s++ != *d++)
			return --d;

	return NULL;
#else
	_asm
	{
			pushfd
			cld
			mov		edi,pDst
			mov		esi,pSrc
			mov		ecx,dwLen
	repe	cmpsw
			jne		failed		
			mov		edi,2	// return zero if successful
failed:		sub		edi,2	// edi contains 2 (success) or failing address + 2
			mov		eax,edi
			popfd
	}
#endif
}


//******************************************************************************
// Function name	: AsmByteMemCmp
// Description	    : Compares two buffers for equality.
// Return type		: LPWORD - virtual address of failing BYTE in destination buffer.
// Argument         : LPVOID pDst   - destination buffer
// Argument         : LPVOID pSrc   - source buffer
// Argument         : DWORD  dwLen  - length of buffers.
//******************************************************************************
LPBYTE AsmByteMemCmp(LPVOID pDst,LPVOID pSrc,DWORD dwLen)
{
#if defined(WIN64)
	LPBYTE s = (LPBYTE)pSrc;
	LPBYTE d = (LPBYTE)pDst;

	while(dwLen--)
		if(*s++ != *d++)
			return --d;

	return NULL;
#else
	_asm
	{
			pushfd
			cld
			mov		edi,pDst
			mov		esi,pSrc
			mov		ecx,dwLen
	repe	cmpsb
			jne		failed		
			mov		edi,1	// return zero if successful
failed:		sub		edi,1	// edi contains 4 (success) or failing address + 1
			mov		eax,edi
			popfd
	}
#endif
}
#pragma warning(default:4035)	// no return value


//******************************************************************************
// Function name	: AsmDwordMemMov
// Description	    : Copies source buffer to destination in DWORDs.  Maintains
//                    possible misalignment of buffers during transfer.
// Return type		: void
// Argument         : LPVOID pDst   - destination buffer
// Argument         : LPVOID pSrc   - source buffer
// Argument         : DWORD  dwLen  - length of buffers.
//******************************************************************************
void AsmDwordMemMov(LPVOID pDst,LPVOID pSrc,DWORD dwLen)
{
#if defined(WIN64)
	LPDWORD s = (LPDWORD)pSrc;
	LPDWORD d = (LPDWORD)pDst;

	while(dwLen--)
		*d++ = *s++;
#else
	_asm
	{
		pushfd
		mov  edi,pDst
		mov  esi,pSrc
		mov  ecx,dwLen
		cld
		rep  movsd
		popfd
	}
#endif
}


//******************************************************************************
// Function name	: AsmWordMemMov
// Description	    : Copies source buffer to destination in WORDs.  Maintains
//                    possible misalignment of buffers during transfer.
// Return type		: void
// Argument         : LPVOID pDst   - destination buffer
// Argument         : LPVOID pSrc   - source buffer
// Argument         : DWORD  dwLen  - length of buffers.
//******************************************************************************
void AsmWordMemMov(LPVOID pDst,LPVOID pSrc,DWORD dwLen)
{
#if defined(WIN64)
	LPWORD s = (LPWORD)pSrc;
	LPWORD d = (LPWORD)pDst;

	while(dwLen--)
		*d++ = *s++;
#else
	_asm
	{
		pushfd
		mov  edi,pDst
		mov  esi,pSrc
		mov  ecx,dwLen
		cld
		rep  movsw
		popfd
	}
#endif
}


//******************************************************************************
// Function name	: AsmByteMemMov
// Description	    : Copies source buffer to destination in BYTEs.
// Return type		: void
// Argument         : LPVOID pDst   - destination buffer
// Argument         : LPVOID pSrc   - source buffer
// Argument         : DWORD  dwLen  - length of buffers.
//******************************************************************************
void AsmByteMemMov(LPVOID pDst,LPVOID pSrc,DWORD dwLen)
{
#if defined(WIN64)
	LPBYTE s = (LPBYTE)pSrc;
	LPBYTE d = (LPBYTE)pDst;

	while(dwLen--)
		*d++ = *s++;
#else
	_asm
	{
		pushfd
		mov  edi,pDst
		mov  esi,pSrc
		mov  ecx,dwLen
		cld
		rep  movsb
		popfd
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmemory\memutils.h ===
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-1999 Intel Corp. All rights reserved.
//
#pragma once

LPDWORD AsmDwordMemCmp(LPVOID dst,LPVOID src,DWORD len);
LPWORD  AsmWordMemCmp (LPVOID dst,LPVOID src,DWORD len);
LPBYTE  AsmByteMemCmp (LPVOID dst,LPVOID src,DWORD len);
void    AsmDwordMemMov(LPVOID dst,LPVOID src,DWORD len);
void    AsmWordMemMov (LPVOID dst,LPVOID src,DWORD len);
void    AsmByteMemMov (LPVOID dst,LPVOID src,DWORD len);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmemory\xmemory.h ===
// memory.h - Memory test module

#pragma once
#define QWORD _int64

// Disable the compiler warning for a non threatening condition.
// C4512: unable to generate an assignment operator for the given class. 
#pragma warning (disable:4512)
#include "..\parameter.h"

// Naming of class test and module classes.
// 
// module class: CXModule<module>
// test class:   CXModule<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//
#define MEMORY_MODNUM   10
class CXModuleMemory : public CTestObj
{
public: 
	// Get module number from numbers.h
	// If this is a new module, add the number to the file.
	//
	DECLARE_XMTAMODULE (CXModuleMemory, "memory", MEMORY_MODNUM);

	virtual bool InitializeParameters ();
	virtual ~CXModuleMemory();
	// for access by stress object
	DWORD		random();
	DWORD holdrand;
	friend class stress;
	protected:

	void DecodeFailingLocation(WORD ECode,LPDWORD qwAddress, QWORD qwExp, QWORD qwRec, BYTE Size, CHAR * MsgPtr);
	// Critical section to make the DevStat function thread-safe.
	CRITICAL_SECTION g_critDevStat;

	// Example Error messages ...
	// (Note: 0x000 - 0x00f reserved for XMTA)
	//
	void ReportDeviceNotFoundAt (UINT addr)
	{
		ReportError (0x010, _T("Device Not found at address 0x%x\n"), addr);
	}
	void ThrowDeviceNotResponding (LPCTSTR string)
	{
		throw CXmtaException (0x011, _T("Device not responding: %s\n"), string);
	}
	void ReportRequiredParameter (LPCTSTR string)
	{
		ReportError (0x012, _T("Required parameter \"%s\" not found.\n"), string);
	}

	// Example parameters ...
	//
	int m_cfgCount;
	UINT m_cfgAddress;
	LPCTSTR m_cfgDevice;
	int m_cfgLevel;
	LPCTSTR m_cfgMessage;

protected:
	
	/////////////////////////////////////////////////////////////////////////////
	
	
	BOOL	g_fFaultInject;
	LPDWORD g_pMemmap;
	HANDLE	   g_hMemoryMutex;
	DWORD GlobalSeed;

	wchar_t * TestNamePtr;
	typedef struct tagTHREADPARAMS
	{
		int    ProcNumber;			// The processor running this thread.
		LPVOID pTestParameters;		// The parameters for this thread.
		LPVOID pMemory;				// The preallocated and locked memory buffer to test.
	} THREADPARAMS,*LPTHREADPARAMS;
	
	typedef struct tagTESTCONDITIONS
	{
		DWORD_PTR MemorySize;	// Amount of memory to test.
		DWORD_PTR BlockSize;	// Some tests set up a block of memory and fill the test window with it.
		DWORD_PTR WindowSize;	// This much memory is written before being read back.
	} TESTCONDITIONS,*LPTESTCONDITIONS;
	
#ifdef _XBOX
typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX,  *LPMEMORYSTATUSEX;
#endif
	
	void   DisplayMemoryStatus();
	void   MemorySizeCheck();
	void   MemorySlidingOnesAndZeros();
	void   MemoryRandomData();
	void   MemoryAddressPatterns();
	void   MemoryMixedOps();
	void   MemoryRandomDwordOps();
	void   MemoryTransfer();
	void   CacheSlidingOnesAndZeros();
	void   CacheRandomData();
	void   CacheAddressPatterns();
	void   CacheMixedOps();
	void   CacheRandomDwordOps();
	void   WindowedCacheRandomDwordOps();
	void   WindowedCacheMixedOps();
	void   WindowedCacheRandomData();
	void   WindowedCacheUniqueness();
	void   RambusDeviceSuround();
	void   RambusDeviceStride();
	void   RambusBusNoise();
	void   RambusBus32KStride();
	void   RambusBusPowersof2();
	void   RambusBusWriteOrder();
	void   RambusBusAlternatingAddress();
	void   QWORDBusNoise();
	void   CachePerformance();
	void   MemoryPerformance();
	void   DDR32KStride();
	void   DDRBusPowersof2();
	void   DDRMemoryBanks();
	void   DDRDeviceStride();
	void   DDRBusNoise();
	
	
	DWORD	RambusCell(LPTHREADPARAMS pThreadParams);
	DWORD	AlternatingPatterns(LPTHREADPARAMS pThreadParams);
	DWORD	BusNoise(LPTHREADPARAMS pThreadParams);
	DWORD	Memory32K(LPTHREADPARAMS pThreadParams);
	DWORD	Powersof2(LPTHREADPARAMS pThreadParams);
	DWORD	WriteOrder(LPTHREADPARAMS pThreadParams);
	DWORD	AlternatingAddress(LPTHREADPARAMS pThreadParams);
	DWORD	QWORDNoise(LPTHREADPARAMS pThreadParams);
	DWORD	DPowersof2(LPTHREADPARAMS pThreadParams, DWORD dwStrideStart,DWORD dwStrideEnd);
	DWORD	DMemoryBanks(LPTHREADPARAMS pThreadParams);
	DWORD	DDeviceStride(LPTHREADPARAMS pThreadParams);
	DWORD	DBusNoise(LPTHREADPARAMS pThreadParams);
	
	DWORD  SlidingOnesAndZeros        (LPTHREADPARAMS pThreadParams);
	DWORD  RandomData                 (LPTHREADPARAMS pThreadParams);
	DWORD  AddressPatterns            (LPTHREADPARAMS pThreadParams);
	DWORD  MixedOpsMixAlignRandomOrder(LPTHREADPARAMS pThreadParams);
	DWORD  DwordRandomOrder           (LPTHREADPARAMS pThreadParams);
	
	LPVOID AllocateMemory(PSIZE_T MemorySize,bool fForce,bool fNoCache,DWORD nThreads);
	LPVOID AllocateMemoryAWE(PSIZE_T pMemorySize,bool fForce,bool fNoCache,DWORD nThreads);
	LPVOID AllocateMemoryOld(PSIZE_T pMemorySize,bool fForce,bool fNoCache,DWORD nThreads);
	void   FreeMemory(LPVOID pMem,SIZE_T MemorySize);
	
	SIZE_T    EstimateAvailableMemory(SIZE_T Request);
	DWORDLONG GetPhysicalMemorySize();
	SIZE_T    GetLargestVirtualBufferSize();
	
	void      seed(DWORD seed);
	void      SetRandomSeed();
	DWORD     GetRandomSeed();
	void      ReSeed(int offset);
	SIZE_T    ParameterMemorySize();
	DWORD     ParameterCacheSize();
	bool      ParameterSwitch(LPCTSTR szName);
	int       GetCpuId(DWORD cmd,DWORD regs[4]);
	bool      GetCpuCacheInfo(LPDWORD pdwSize);
	bool      MMXCheck();
	bool      SafeGlobalMemoryStatusEx(LPMEMORYSTATUSEX p);
	PVOID	  AbortMemPtr; 

	void TestPerformance(_int64 count);

	//
	// Error Definitions messages
	//
	void errInvalidTestNumber()
	{
		ReportError(0x00,L"Invalid test number.");
	}
	void errNotSupported()
	{
		ReportError(0x01,L"Background tests have been retired and are no longer supported.\n"
			L"Please remove them from the package file.");
	}
	void errTempPath(DWORD dw1)  
	{
		ReportError(0x02,L"A temporary directory is not defined for this system.  Set the\n"
			L"TMP and TEMP environment variables or the TempDrive test parameter.  Last Error =%X", dw1);
		
	}
	void errTempFile(DWORD dw1)
	{
		ReportError(0x03,L"Error trying to create a temporary file.  Last Error =%X",dw1);
	}
	void errUserTempFileS(DWORD dw1,char * lpcStr1)
	{
		ReportError(0x04,L"Error creating temp file %s. Last Error =%x"
			,lpcStr1,dw1);
		
	}
	void errMemorySizeLL(DWORD dw1,DWORD dw2)
	{
		ReportError(0x05,L"Memory size miscompare.\n"
			L"Expected: %luMB   Received: %luMB"
			,dw1,dw2);
	}
	void errOutOfMemoryQ(QWORD qw1)
	{
		ReportError(0x06,L"Could not allocate %I64u bytes for a buffer.  Out of memory or allocation too large.\n"
			L"Each memory test removes \"MemorySizeMB\" megabytes of memory from the memory pool.\n"
			L"If memory tests are running in parallel their \"MemorySizeMB\", when added, cannot\n"
			L"exceed the total physical memory available to the operating system.\n"
			L"Also try running fewer tests at the same time or increasing the page file size.\n"
			L"If looping on tests in WIN98 SE a small, permanent memory leak in the OS occurs\n"
			L"each time a test is executed and will eventually cause this error."
			,qw1);
		
	}

	void errWriteFile(DWORD dw1)
	{
		ReportError(0x09,L"WriteFile() failed. Last Error = %X",dw1);
	}
	void errReadFile(DWORD dw1)
	{
		ReportError(0x0A,L"ReadFile() failed. Last Error = %X", dw1);
	}
	void errTestThreadTimeout()
	{
		ReportError(0x0D,L"The wait for a test thread failed.");
	}
	void errLogOverflowQ(QWORD qw1)
	{
		ReportError(0x00E,L"Testing log overflow at index %I64Xh (software bug)."
			,qw1);
	}
	void errGetPwsSize(DWORD dw1)
	{
		ReportError(0x0F,L"Failed to determine the process working set size. Last error =%X",dw1);
	}
	void errSetPwsSizeHigherQ(DWORD dw1,QWORD qw1)
	{
		ReportError(0x10,L"Failed to increase the minimum and maximum working set size for this process by %I64Xh bytes.\n"
			L"The system is out of memory.  If memory tests are running in parallel make sure their combined\n"
			L"\"MemorySizeMB\" parameters do not exceed the physical memory available to the operating system.\n"
			L"Last Error = %X"
			,qw1,dw1);
		// 0x011 NOT USED
	}
	void errVirtualAllocQ(DWORD dw1,QWORD qw1)
	{
		ReportError(0x12,L"Failed to allocate %I64Xh bytes of virtual memory. Last Error = %X",
			qw1,dw1);
	}
	void errVirtualLockQ(DWORD dw1, QWORD qw1)
	{
		ReportError(0x13,L"Failed to lock %I64Xh bytes of virtual memory into physical memory. Last Error =%X"
			,qw1,dw1);
	}
	void errVirtualFreeQ(DWORD dw1,QWORD qw1)
	{
		ReportError(0x014,L"Failed to free %I64Xh bytes of virtual memory. Last error = %x."
			,qw1, dw1);
	}
	void errOutOfMemory()
	{
		ReportError(0x15,L"All memory is reserved in the system.  Each memory test removes \"MemorySizeMB\" megabytes of memory\n"
			L"from the memory pool.  If memory tests are running in parallel their \"MemorySizeMB\", when added,\n"
			L"cannot exceed the total physical memory available to the operating system.  Also try running fewer\n"
			L"tests at the same time or increasing the page file size. If looping on tests in WIN98 SE a small,\n"
			L"permanent memory leak in the OS occurs each time a test is executed and will eventually cause this error.");
	}
	
	void errRamDiskWriteQL(QWORD qw1,DWORD dw1)
	{
		ReportError(0x17,L"An error occurred writing address %09I64Xh (%ld bytes)."
			,qw1,dw1);
	}
	void errRamDiskReadQL(QWORD qw1,DWORD dw1)
	{
		ReportError(0x18,L"An error occurred reading address %09I64Xh (%ld bytes)."
			,qw1,dw1);
	}
	void errRamDiskMiscompareQLL(QWORD qw1,DWORD dw1,DWORD dw2)
	{
		ReportError(0x19,L"Data miscompare reading address %09I64Xh.\n"
			L"Expected: %08lXh   Received: %08lXh"
			,qw1,dw1,dw2);
	}
	void errRamDiskMiscompareRndQLLL(QWORD qw1,DWORD dw1,DWORD dw2,DWORD dw3)
	{
		ReportError(0x1A,L"Data miscompare reading address %09I64Xh.\n"
			L"Expected: %08lXh   Received: %08lXh   Random Seed=%08lXh"
			,qw1,dw1,dw2,dw3);
	}
	void errVlmMemorySizeLL(DWORD dw1,DWORD dw2)
	{
		ReportError(0x1B,L"Non-NT accessible memory size miscompare.\n"
			L"Expected: %luMB   Received: %luMB"
			,dw1,dw2);
	}
	void errMMX()
	{
		ReportError(0x1F,L"This test requires MMX. MMX is not present!");
	}
	// 0x20 NOT USED
	void errMissingParameterS(LPCTSTR lpStr)
	{
		ReportError(0x21,L"Required parameter \"%s\" was not found.",lpStr);
	}
	void errPerProblemSIII(LPCTSTR lpStr,DWORD MBSec,DWORD LCL,DWORD UCL)
	{
		ReportError(0x22,L"%s performance out of range, Measured = %dMB/Sec LCL = %d UCL = %d",lpStr, MBSec, LCL, UCL);
	}

	//******************************************************************************
	// This block of stuff allows us to dynamically load the WMTAFUNC helper DLL
	// and retrieve the virtual-physical address converter.
	//******************************************************************************
	bool      InitAddressConversions();
	DWORD_PTR GetPhysicalAddress(PVOID virtaddr);
	
	#define WMTAFUNC_DWORD_VERSION  0x300
	
	typedef LARGE_INTEGER PHYSICAL_ADDRESS,*LPPHYSICAL_ADDRESS;
	
	typedef struct tagWMINFO
	{
		DWORD nLength;
		DWORD dwDllVersion;
		DWORD dwDriverVersion;
	} WMINFO,*PWMINFO;
	
	typedef bool (APIENTRY *LPGETWMTAFUNCINFO)(PWMINFO pInfo);
	typedef bool (APIENTRY *LPGETPHYSICALADDRESS)(PVOID VirtAddr,LPPHYSICAL_ADDRESS pPhysAddr);
	
	LPGETWMTAFUNCINFO    wmGetWmtafuncInfo;
	LPGETPHYSICALADDRESS wmGetPhysicalAddress;
	
	//******************************************************************************
	// Function name	: Progress
	// Description	    : Sends a progress message only if different from the last one.
	// Return type		: inline void 
	// Argument         : int nPercent
	//******************************************************************************
	inline void Progress(int nPercent)
	{
		static nProgLast = 0;
		
		if(nProgLast != nPercent)
		{
			//fol		wt_progress(nPercent);
			nProgLast = nPercent;
		}
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmemory\stress.cpp ===
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-2000 Intel Corp. All rights reserved.
//
// turn off the you may not inited with warning
#pragma warning( disable : 4701 )
#pragma warning( disable : 4800 )

#include "..\stdafx.h"
#include "..\testobj.h"
#include "memutils.h"
#include "xmemory.h"
#include "stress.h"




//__declspec(thread)*/ DWORD_PTR stress::m_curbot,stress::m_curtop;

//******************************************************************************
// Function name	: stress::stress
// Description	    : Allocates the buffers for the read and write logs and
//                    the buffer for the bitmapped accessed list.
// Return type		: void 
// Argument         : SIZE_T BlockSize - the size of the memory for which to
//                                       generate the list.
//******************************************************************************
stress::stress(SIZE_T BlockSize, CXModuleMemory * hCXMemparmam)
{
	// 
	hCXMem = hCXMemparmam; 
	m_nTestSize        = BlockSize;
	m_nMaxTransferSize = m_nTestSize / 0x200;
	m_nLogSize         = (m_nTestSize / m_nMaxTransferSize) * 3 * 6 * sizeof(SIZE_T) / 4;
	
	// The bit mapped allocation array
	m_pdwUsed  = new DWORD[m_nTestSize / 32];
	
	if(m_pdwUsed == NULL)
	{
		hCXMem->errOutOfMemoryQ(sizeof(DWORD) * m_nTestSize / 32);
		// exit
		throw CXmtaException(99,NULL);
	}
	
	//The log of read and write locations and sizes
	m_pWriteLog = new log[m_nLogSize];
	
	if (m_pWriteLog == NULL)
	{
/* fol		errOutOfMemoryQ.Report(sizeof(log) * m_nLogSize);
		wt_done();*/
	}
	
	m_pReadLog = new log[m_nLogSize];
	
	if (m_pReadLog == NULL)
	{
		hCXMem->errOutOfMemoryQ(sizeof(log) * m_nLogSize);
		// exit
		throw CXmtaException(99,NULL);
	}
}


//******************************************************************************
// Function name	: stress::~stress
// Description	    : Deletes the buffers allocated by the constructor.
// Return type		: void
//******************************************************************************
stress::~stress()
{
	delete [] m_pdwUsed;
	delete [] m_pWriteLog;
	delete [] m_pReadLog;
}


//******************************************************************************
// Function name	: stress::build_read_log
// Description	    : Sets up to build the read log.
// Return type		: void 
//******************************************************************************
void stress::build_read_log()
{
	build_log(m_pReadLog);
}


//******************************************************************************
// Function name	: stress::build_write_log
// Description	    : Sets up to build the write log.
// Return type		: void 
//******************************************************************************
void stress::build_write_log()
{
	build_log(m_pWriteLog);
}


//******************************************************************************
// Function name	: stress::build_log
// Description	    : builds a list of addresses and sizes that completely
//                    cover an amount of memory (m_nTestSize).
// Return type		: void 
// Argument         : log* pLog - either m_pReadLog or m_pWriteLog.
//******************************************************************************
void stress::build_log(log* pLog)
{
	DWORD_PTR loc,size,index;

	// init the bit arrays to 0.  Each bit indicates whether a particular byte
	// in the test block has been addressed yet.
	ZeroMemory(m_pdwUsed,m_nTestSize / 8);
	
	// Initialize the static thread-safe variables to mark the window in the
	// m_pdwUsed array where unused addresses can be found.  This speeds up the
	// search for unused addresses when there aren't many left.
	m_curtop = m_nTestSize;
	m_curbot = 0;

	// build the read log of where we are going to read
	for(index = 0; index < m_nLogSize; index++)
	{
		// returns an address and size and marks them as used in the bit array.
		if(get_location(&loc,&size))
		{
			pLog[index].address = loc;
			pLog[index].size    = size;
		}
		else
			break;
	}

	// Keep alive.
	hCXMem->ReportDebug(1,L"test");
	hCXMem->CheckAbort(0);

	// The log varies in size.  An amount of memory much bigger than the
	// average log size was allocated by InitStress, but just in case...
	if(index == m_nLogSize)
	{
		hCXMem->errLogOverflowQ(index);
		// exit
		throw CXmtaException(99,NULL);
	}
	
	// end the log with an entry of size 0
	// The SMP tests could miss this since type don't look at every array entry,
	// NT supports up to 32 processors so we'll put 32 terminators.
	for(DWORD_PTR i = 0; i < 32; i++)
		pLog[index++].size = 0;

#if defined(_DEBUG)
	// This algorithm verifies that the generated log
	// accesses every bit of the m_pUsed array uniquely.
	
	// First, check that all bits of the m_pUsed array are on
	// after log generation, then zero them.
	LPDWORD end = m_pdwUsed + m_nTestSize / 32;
	for(LPDWORD x = m_pdwUsed; x < end; x++)
		ASSERT(*x == 0xFFFFFFFF);
	ZeroMemory(m_pdwUsed,m_nTestSize / 8);

	// Now walk the log.  For each address and size, verify
	// that all bits are off, then set them using a different
	// algorithm that get_location() uses.
	for(i = 0; pLog[i].size; i++)
	{
		DWORD_PTR size = pLog[i].size;
		DWORD_PTR addr = pLog[i].address;
		
		// determine the starting and ending dword and bit in the bit array
		// for the above address and size.
		LPDWORD pmindword = m_pdwUsed + addr / 32;
		DWORD   minbit    = (DWORD)(addr % 32);
		LPDWORD pmaxdword = m_pdwUsed + (addr + size - 1) / 32;
		DWORD   maxbit    = (DWORD)((addr + size - 1) % 32);

		// Compute the bits that must be set in the first dword and set them.
		DWORD bits = size > 32 ? 32 : size;
		DWORD mask = (0xFFFFFFFF >> (32-bits)) << minbit;
		ASSERT((*pmindword & mask) == 0);
		*pmindword |= mask;

		// if the first dword is the last dword, we are done with this address/size.
		if(pmaxdword == pmindword) continue;

		// Compute the bits that must be set in the last dword and set them.
		mask = 0xFFFFFFFF >> (31-maxbit);
		ASSERT((*pmaxdword & mask) == 0);
		*pmaxdword |= mask;

		// Turn on the bits in all the intermediate dwords.
		for(x = pmindword + 1; x < pmaxdword; x++)
		{
			ASSERT(*x == 0);
			*x = 0xFFFFFFFF;
		}
	}
	
	// Finally, verify all bits are on in the m_pUsed array again.
	for(x = m_pdwUsed; x < end; x++)
		ASSERT(*x == 0xFFFFFFFF);
#endif
}


//******************************************************************************
// Function name	: stress::StressWrite
// Description	    : Iterate through the write log and perform a write from the
//                    source to the destination buffer at each address and size
//                    specified.  On IA-32, this algorithm is meant to test the
//                    hardware byte-swapping capability of the processors.  On
//                    IA-32, perform DWORD writes if the size is divisible
//                    by four, WORD if by two, BYTE otherwise.  For IA-64, this
//                    algorithm simply mixes BYTE, WORD, and DWORD accesses, but
//                    makes sure the addresses are data-aligned.
// Return type		: void 
// Argument         : LPBYTE pSrcBuf  - source data buffer
// Argument         : LPBYTE pDestBuf - destination data buffer
//******************************************************************************
void stress::StressWrite(LPBYTE pSrcBuf,LPBYTE pDestBuf)
{
	DWORD_PTR index = 0,loc,size;
	
#ifdef _WIN64
	// The write log addresses must be multiplied by four to get DWORD-aligned
	// addresses.  Size is in DWORDs, so for BYTE and WORD modes the size of
	// the move must be multiplied.
	for(;;)
	{
		loc   = m_pWriteLog[index].address * 4;
		size  = m_pWriteLog[index].size;

		// check for end-of-log
		if(size == 0) 
			break;

		switch(random() % 3)
		{	
		case  0:  AsmDwordMemMov(pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		case  1:  AsmWordMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 2);  break;
		default:  AsmByteMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 4);  break;
		} 

		index++;
	}
#else
	// For IA-32, the write log addresses are fine and the size is in bytes, so it must
	// be divided for WORD and DWORD moves.
	for(;;)
	{
		loc   = m_pWriteLog[index].address;
		size  = m_pWriteLog[index].size;

		// check for end-of-log
		if(size == 0) 
			break;

		switch(size % 4)
		{	
		case  0:  AsmDwordMemMov(pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 4);  break;
		case  2:  AsmWordMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 2);  break;
		default:  AsmByteMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		} 

		index++;
	}
#endif
}


//******************************************************************************
// Function name	: stress::StressRead
// Description	    : Iterate through the read log reading and comparing the
//                    destination buffer to the source buffer at each address and
//                    size specified.  Perform DWORD writes if the size is
//                    divisible by four, WORD if by two, BYTE otherwise.
// Return type		: LPBYTE          - the virtual address of a failure in the
//                                      destination buffer or NULL if no failure occurred.
// Argument         : LPBYTE pSrcBuf  - the source buffer.
// Argument         : LPBYTE pDestBuf - the destination buffer.
//******************************************************************************
LPBYTE stress::StressRead(LPBYTE pSrcBuf,LPBYTE pDestBuf)
{
	DWORD_PTR  index = 0,loc,size;
	LPVOID pVirt;

#ifdef _WIN64
	// The read log addresses must be multiplied by four to get DWORD-aligned
	// addresses.  Size is in DWORDs, so for BYTE and WORD modes the size of
	// the compare must be multiplied.
	for(;;)
	{
		loc   = m_pReadLog[index].address * 4;
		size  = m_pReadLog[index].size;

		// check for end-of-log
		if(size == 0) 
			return 0;

		switch(random() % 3)
		{
		case  0:  pVirt = AsmDwordMemCmp(pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		case  1:  pVirt = AsmWordMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 2);  break;	
		default:  pVirt = AsmByteMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 4);  break;
		} 
		
		if(pVirt)
			return (LPBYTE)pVirt;

		index++;
	}
#else
	// For IA-32, the read log addresses are fine and the size is in bytes, so it must
	// be divided for WORD and DWORD compares.
	for(;;)
	{
		loc   = m_pReadLog[index].address;
		size  = m_pReadLog[index].size;

		// check for end-of-log
		if(size == 0) 
			return 0;

		switch(size % 4)
		{
		case  0:  pVirt = AsmDwordMemCmp(pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 4);  break;
		case  2:  pVirt = AsmWordMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 2);  break;	
		default:  pVirt = AsmByteMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		} 
		
		if(pVirt)
			return (LPBYTE)pVirt;

		index++;
	}
#endif
}


//******************************************************************************
// Function name	: stress::StressWriteDword
// Description	    : Iterate through the write log and perform a write from the
//                    source to the destination buffer at each address and size
//                    specified.  Size is in DWORDs and performs DWORD writes only.
// Return type		: void 
// Argument         : LPBYTE pSrcBuf
// Argument         : LPBYTE pDestBuf
//******************************************************************************
void stress::StressWriteDword(LPBYTE pSrcBuf,LPBYTE pDestBuf)
{
	DWORD_PTR index = 0,loc,size;
	
	for(;;)
	{
		loc  = m_pWriteLog[index].address;
		size = m_pWriteLog[index].size;

		// check for end-of-log
		if(size == 0) 
			break;

		loc *= 4;  // build_log() assumes byte addresses, convert to dword addresses
		AsmDwordMemMov(pDestBuf + loc,pSrcBuf + loc,(DWORD)size);
		index++;
	}
}


//******************************************************************************
// Function name	: stress::StressReadDword
// Description	    : Iterate through the read log reading and comparing the
//                    destination buffer to the source buffer at each address and
//                    size specified.  Size is in DWORDs and performs DWORD reads only.
// Return type		: LPBYTE          - the virtual address of a failure in the
//                                      destination buffer or NULL if no failure occurred.
// Argument         : LPBYTE pSrcBuf  - the source buffer.
// Argument         : LPBYTE pDestBuf - the destination buffer.
//******************************************************************************
LPBYTE stress::StressReadDword(LPBYTE pSrcBuf,LPBYTE pDestBuf)
{
	DWORD_PTR   index = 0,loc,size;
	LPDWORD pdwVirt;

	for(;;)
	{
		loc  = m_pReadLog[index].address;
		size = m_pReadLog[index].size;
		
		// check for end-of-log
		if(size == 0) 
			return 0;
		
		loc *= 4;  // build_log() assumes byte addresses, convert to dword addresses
		
		pdwVirt = AsmDwordMemCmp(pDestBuf + loc,pSrcBuf + loc,(DWORD)size);
	
		if(pdwVirt)
			return (LPBYTE)pdwVirt;

		index++;
	}
}



//******************************************************************************
// Function name	: stress::StressStrideWrite
// Description	    : Iterate through the write log starting at offset and perform
//                    a write from the source to the destination buffer at every
//                    nth address and size specified by stride.  Perform DWORD
//                    writes if the size is divisible by four, WORD if by two,
//                    BYTE otherwise.
// Return type		: void 
// Argument         : DWORD  index    - starting log index
// Argument         : DWORD  stride   - specifies writing every nth address in the log.
// Argument         : LPBYTE pSrcBuf  - the source buffer.
// Argument         : LPBYTE pDestBuf - the destination buffer.
//******************************************************************************
void stress::StressStrideWrite(DWORD index,DWORD stride,LPBYTE pSrcBuf,LPBYTE pDestBuf)
{
	DWORD_PTR loc,size;
	
#ifdef _WIN64
	// The write log addresses must be multiplied by four to get DWORD-aligned
	// addresses.  Size is in DWORDs, so for BYTE and WORD modes the size of
	// the move must be multiplied.
	for(;;)
	{
		loc   = m_pWriteLog[index].address * 4;
		size  = m_pWriteLog[index].size;

		// check for end-of-log.
		if(size == 0)
			break;
 		
		switch(random() % 3)
		{	
		case  0:  AsmDwordMemMov(pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		case  1:  AsmWordMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 2);  break;
		default:  AsmByteMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 4);  break;
		} 

		index += stride;
	}
#else
	// For IA-32, the write log addresses are fine and the size is in bytes, so it must
	// be divided for WORD and DWORD moves.
	for(;;)
	{
		loc   = m_pWriteLog[index].address;
		size  = m_pWriteLog[index].size;

		// check for end-of-log.
		if(size == 0)
			break;
 		
		switch(size % 4)
		{	
		case  0:  AsmDwordMemMov(pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 4);  break;
		case  2:  AsmWordMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 2);  break;
		default:  AsmByteMemMov (pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		} 

		index += stride;
	}
#endif
}

//******************************************************************************
// Function name	: stress::StressStrideRead
// Description	    : Iterate through the read log starting at offset reading and
//                    comparing the destination buffer to the source buffer at
//                    every nth address and size specified by stride.  Perform
//                    DWORD writes if the size is divisible by four, WORD if by
//                    two, BYTE otherwise.
// Return type		: LPBYTE 
// Argument         : DWORD  index    - starting log index
// Argument         : DWORD  stride   - specifies reading every nth address in the log.
// Argument         : LPBYTE pSrcBuf  - the source buffer.
// Argument         : LPBYTE pDestBuf - the destination buffer.
//******************************************************************************
LPBYTE stress::StressStrideRead(DWORD index,DWORD stride,LPBYTE pSrcBuf,LPBYTE pDestBuf)
{
	DWORD_PTR loc,size;
	LPVOID    pVirt;

#ifdef _WIN64
	// The read log addresses must be multiplied by four to get DWORD-aligned
	// addresses.  Size is in DWORDs, so for BYTE and WORD modes the size of
	// the compare must be multiplied.
	for(;;)
	{
		loc   = m_pReadLog[index].address * 4;
		size  = m_pReadLog[index].size;
		
		// check for end-of-log.
		if(size == 0)
			return 0;
		
		switch(size % 4)
		{
 		case  0:  pVirt = AsmDwordMemCmp(pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
 		case  2:  pVirt = AsmWordMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 2);  break;
		default:  pVirt = AsmByteMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size * 4);  break;
		} 

		if(pVirt)
			return (LPBYTE)pVirt;

		index += stride;
	}
#else
	// For IA-32, the read log addresses are fine and the size is in bytes, so it must
	// be divided for WORD and DWORD compares.
	for(;;)
	{
		loc   = m_pReadLog[index].address;
		size  = m_pReadLog[index].size;
		
		// check for end-of-log.
		if(size == 0)
			return 0;
		
		switch(size % 4)
		{
 		case  0:  pVirt = AsmDwordMemCmp(pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 4);  break;
 		case  2:  pVirt = AsmWordMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size / 2);  break;
		default:  pVirt = AsmByteMemCmp (pDestBuf + loc,pSrcBuf + loc,(DWORD)size);      break;
		} 

		if(pVirt)
			return (LPBYTE)pVirt;

		index += stride;
	}
#endif
}


//******************************************************************************
// Function name	: stress::get_location
// Description	    : Uses the bitmap array to determine randomly-sized contiguous
//                    area and return its address.  The bitmap array is updated
//                    to mark the area as used. 
// Return type		: bool - TRUE if a location was found.  FALSE if no more locations free
// Argument         : SIZE_T* pAddr - pointer to the returned address.
// Argument         : SIZE_T* pSize - pointer to the returned size.
//******************************************************************************
bool stress::get_location(SIZE_T* pAddr,SIZE_T* pSize)
{
	DWORD_PTR addr,save,size,max_size;
	bool       fUpDir,fTop,fBottom;
	static    count = 0;

	ASSERT(pAddr != NULL);
	ASSERT(pSize != NULL);

	// Flags that we have iterated to the top and bottom of the address range.
	fTop = fBottom = FALSE;

	// Pick a starting address.  The current top and bottom are static, thread-safe, and
	// initialized in the build_log() function.
	save = addr = hCXMem->random() % (m_curtop - m_curbot) + m_curbot;
	
	// Pick a search direction.
	fUpDir = (bool)(hCXMem->random() % 2);
	
	// Find an unused address or return FALSE when done.
	while(is_used(addr))
	{
		if(fUpDir)
		{
			// check for walking off the top
			if(++addr == m_curtop)
			{
				fTop = TRUE;

				// if the top and bottom were reached, no more addresses.
				if(fBottom)
					return FALSE;

				// reverse direction and start back at the address.
				fUpDir = FALSE;
				addr   = save;
			}
		}
		else
		{
			// check for walking off the bottom
			if(addr-- == m_curbot)
			{
				fBottom = TRUE;

				// if the top and bottom were reached, no more addresses.
				if(fTop)
					return FALSE;

				// reverse direction and start back at the address.
				fUpDir  = TRUE;
				addr    = save;
			}
		}
	}

	// We have an unused starting address in addr now.

	// If the top was hit, make the starting address the current top.
	// Add one to fix a rare case where the bottom could equal the top
	// and cause divide-by-zero when picking the next random address.
	if(fTop)
		m_curtop = addr + 1;

	// If the bottom was hit, make the starting address the current bottom.
	if(fBottom)
		m_curbot = addr;

	ASSERT(addr < m_nTestSize);
	ASSERT(!is_used(addr));
	save = addr;

	// The maximum size of the unused area we will return,
	// We will return less than this if we find a used location in the area.
	max_size  = hCXMem->random() % m_nMaxTransferSize + 1;

	// Continue in the direction the unused address was found.
	// It is likely more unused locations are that way.
	if(fUpDir == TRUE)
	{
		// mark addresses as used until we reach max_size or a used address.
		for(size = 0; size < max_size && addr < m_curtop && !is_used(addr); size++,addr++)
		{
			mark_used(addr);
		}
	}
	else
	{
		bool fStop = FALSE;

		// mark addresses as used until we reach max_size or a used address.
		for(size = 0; size < max_size && !fStop && !is_used(addr); size++,addr--)
		{
			mark_used(addr);

			// addresses are unsigned so handle zero carefully.
			if(addr == m_curbot)
				fStop = TRUE;
		}

		save = addr + 1;
	}

	ASSERT(save >= 0 && save < m_nTestSize);
	ASSERT(save + size <= m_nTestSize);
	*pAddr = save;
	*pSize = size;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmemory\xmemory.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// Title: xmemory  
//
// History:
//
// 11/30/00 V1.00 SSS Release V1.00.
// 
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-2001 Intel Corp. All rights reserved.

// turn off the you may not inited with warning
#pragma warning( disable : 4701 )
#pragma warning( disable : 4800 )

// version number
#pragma comment(exestr,"version_number=1.00.0.010")

#include "..\stdafx.h"
#include "..\testobj.h"
#include "xmemory.h"
#include "stress.h"
#include "memutils.h"


extern "C" { 
	ULONG_PTR
		NTAPI
		MmGetPhysicalAddress(
		IN PVOID BaseAddress
		);
	
}

IMPLEMENT_MODULEUNLOCKED (CXModuleMemory);

bool CXModuleMemory::InitializeParameters ()
{
	// Call the base class.  This is REQUIRED
	//
	
	if (!CTestObj::InitializeParameters ())
		return false;
	GlobalSeed = 0;
	holdrand = 1;
	AbortMemPtr = NULL;
	
	
	// Mutex for memory tests to safely query and allocate memory when running in parallel.
	g_hMemoryMutex = CreateMutex(NULL,FALSE,"WinMTA*Memory*Mutex");
	
	
	// if non-zero, injects errors to test error messages.
	g_fFaultInject = ParameterSwitch(L"FaultInject");
	
	return true;
}


IMPLEMENT_TESTUNLOCKED (Memory, DisplayMemoryStatus, 1)
{
	TCHAR StrOutput[512];
	wchar_t TestName[] = L"DisplayMemoryStatus";
	
	//	#ifdef _DEBUG
	static int MemStat;
	MemStat++;
	ReportDebug(BIT0, _T(" DisplayMemoryStatus Test - Loop %d"), MemStat);
	//	#endif
	
	try 
	{
		_stprintf(StrOutput,_T("in code\n"));
		OutputDebugString(StrOutput);
		TestNamePtr = TestName;
		DisplayMemoryStatus();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, MemorySizeCheck, 2)
{
	//	#ifdef _DEBUG
	static int MemChk;
	MemChk++;
	ReportDebug(BIT0, _T(" MemorySizeCheck Test - Loop %d"), MemChk);
	//	#endif
	
	try 
	{
		MemorySizeCheck();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, MemorySlidingOnesAndZeros, 3)
{
	//	#ifdef _DEBUG
	static int Mem0and1;
	Mem0and1++;
	ReportDebug(BIT0, _T(" MemorySlidingOnesAndZeros Test - Loop %d"), Mem0and1);
	//	#endif
	
	try 
	{
		MemorySlidingOnesAndZeros();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, MemoryRandomData, 4)
{
	//	#ifdef _DEBUG
	static int MemRandom;
	MemRandom++;
	ReportDebug(BIT0, _T(" MemoryRandomData Test - Loop %d"), MemRandom);
	//	#endif
	
	try 
	{
		MemoryRandomData();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, MemoryAddressPatterns, 5)
{
	//	#ifdef _DEBUG
	static int MemAdPat;
	MemAdPat++;
	ReportDebug(BIT0, _T(" MemoryAddressPatterns Test - Loop %d"), MemAdPat);
	//	#endif
	
	try 
	{
		MemoryAddressPatterns();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}

IMPLEMENT_TESTUNLOCKED (Memory, MemoryMixedOps, 6)
{
	//	#ifdef _DEBUG
	static int MemMixOp;
	MemMixOp++;
	ReportDebug(BIT0, _T(" MemoryMixedOps Test - Loop %d"), MemMixOp);
	//	#endif
	
	try 
	{
		MemoryMixedOps();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}

IMPLEMENT_TESTUNLOCKED (Memory, MemoryRandomDwordOps, 7)
{
	//	#ifdef _DEBUG
	static int MemRandWordOp;
	MemRandWordOp++;
	ReportDebug(BIT0, _T(" MemoryRandomDwordOps Test - Loop %d"), MemRandWordOp);
	//	#endif
	
	try 
	{
		MemoryRandomDwordOps();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}

IMPLEMENT_TESTUNLOCKED (Memory, CacheSlidingOnesAndZeros, 8 )
{
	//	#ifdef _DEBUG
	static int Cache0and1;
	Cache0and1++;
	ReportDebug(BIT0, _T(" CacheSlidingOnesAndZeros Test - Loop %d"), Cache0and1);
	//	#endif
	
	try 
	{
		CacheSlidingOnesAndZeros();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, CacheRandomData, 9)
{
	//	#ifdef _DEBUG
	static int CacheRandom;
	CacheRandom++;
	ReportDebug(BIT0, _T(" CacheRandomData Test - Loop %d"), CacheRandom);
	//	#endif
	
	try 
	{
		CacheRandomData();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, CacheAddressPatterns, 10)
{
	//	#ifdef _DEBUG
	static int CacheAdPat;
	CacheAdPat++;
	ReportDebug(BIT0, _T(" CacheAddressPatterns Test - Loop %d"), CacheAdPat);
	//	#endif
	
	try 
	{
		CacheAddressPatterns();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, CacheMixedOps, 11)
{
	//	#ifdef _DEBUG
	static int CacheMixOp;
	CacheMixOp++;
	ReportDebug(BIT0, _T(" CacheMixedOps Test - Loop %d"), CacheMixOp);
	//	#endif
	
	try 
	{
		CacheMixedOps();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, CacheRandomDwordOps, 12)
{
	//	#ifdef _DEBUG
	static int CacheRanDwOp;
	CacheRanDwOp++;
	ReportDebug(BIT0, _T(" CacheRandomDwordOps Test - Loop %d"), CacheRanDwOp);
	//	#endif
	
	try 
	{
		CacheRandomDwordOps();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, WindowedCacheRandomDwordOps, 13)
{
	//	#ifdef _DEBUG
	static int WCacheRanDwOp;
	WCacheRanDwOp++;
	ReportDebug(BIT0, _T(" WindowedCacheRandomDwordOps Test - Loop %d"), WCacheRanDwOp);
	//	#endif
	
	try 
	{
		WindowedCacheRandomDwordOps();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, WindowedCacheMixedOps, 14)
{
	//	#ifdef _DEBUG
	static int WCacheMixOp;
	WCacheMixOp++;
	ReportDebug(BIT0, _T(" WindowedCacheMixedOps Test - Loop %d"), WCacheMixOp);
	//	#endif
	
	try 
	{
		WindowedCacheMixedOps();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, WindowedCacheRandomData, 15)
{
	//	#ifdef _DEBUG
	static int WCacheRandom;
	WCacheRandom++;
	ReportDebug(BIT0, _T(" WindowedCacheRandomData Test - Loop %d"), WCacheRandom);
	//	#endif
	
	try 
	{
		WindowedCacheRandomData();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, WindowedCacheUniqueness, 16)
{
	//	#ifdef _DEBUG
	static int WCacheUniq;
	WCacheUniq++;
	ReportDebug(BIT0, _T(" WindowedCacheUniqueness Test - Loop %d"), WCacheUniq);
	//	#endif
	
	try 
	{
		WindowedCacheUniqueness();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, MemoryTransfer, 17)
{
	//	#ifdef _DEBUG
	static int Memxfer;
	Memxfer++;
	ReportDebug(BIT0, _T(" MemoryTransfer Test - Loop %d"), Memxfer);
	//	#endif
	
	try
	{
		MemoryTransfer();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, QBusNoise, 18)
{
	//	#ifdef _DEBUG
	static int QNoise;
	QNoise++;
	ReportDebug(BIT0, _T(" QBusNoise Test - Loop %d"), QNoise);
	//	#endif
	
	try 
	{
		QWORDBusNoise();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, CachePerformance, 19)
{
	//	#ifdef _DEBUG
	static int CachePerf;
	CachePerf++;
	ReportDebug(BIT0, _T(" CachePerformance Test - Loop %d"), CachePerf);
	//	#endif
	
	try 
	{
		CachePerformance();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, MemoryPerformance, 20)
{
	//	#ifdef _DEBUG
	static int MemPerf;
	MemPerf++;
	ReportDebug(BIT0, _T(" MemoryPerformance Test - Loop %d"), MemPerf);
	//	#endif
	
	try 
	{
		MemoryPerformance();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, DDR32KStride, 21)
{
	//	#ifdef _DEBUG
	static int DDR32KStr;
	DDR32KStr++;
	ReportDebug(BIT0, _T(" DDR32KStride Test - Loop %d"), DDR32KStr);
	//	#endif
	
	try 
	{
		DDR32KStride();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, DDRBusPowersof2, 22)
{
	//	#ifdef _DEBUG
	static int DDRPowof2;
	DDRPowof2++;
	ReportDebug(BIT0, _T(" DDRBusPowersof2 Test - Loop %d"), DDRPowof2);
	//	#endif
	
	try 
	{
		DDRBusPowersof2();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, DDRMemoryBanks, 23)
{
	//	#ifdef _DEBUG
	static int DDRMemBank;
	DDRMemBank++;
	ReportDebug(BIT0, _T(" DDRMemoryBanks Test - Loop %d"), DDRMemBank);
	//	#endif
	
	try 
	{
		DDRMemoryBanks();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknow exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
}
IMPLEMENT_TESTUNLOCKED (Memory, DDRDeviceStride, 24)
{
	//	#ifdef _DEBUG
	static int DDRDevStr;
	DDRDevStr++;
	ReportDebug(BIT0, _T(" DDRDeviceStride Test - Loop %d"), DDRDevStr);
	//	#endif
	
	try 
	{
		DDRDeviceStride();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknown exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}
IMPLEMENT_TESTUNLOCKED (Memory, DDRBusNoise, 25)
{
	//	#ifdef _DEBUG
	static int DDRNoise;
	DDRNoise++;
	ReportDebug(BIT0, _T(" DDRBusNoise Test - Loop %d"), DDRNoise);
	//	#endif
	
	try 
	{
		DDRBusNoise();
	}
	catch (int except)
	{
		// just leaving
		if( except == 99) return;
		ReportDebug(0x999,L"Unknown exception 0x%x",except);
	}
	catch (CXmtaException &e)
	{
		ReportError (e.GetErrorCode (), e.GetMessage ());
	}
	
}

//******************************************************************************
// Function name	: the destructor!
// Description	    : Cleans up an allocations and handles left hanging
// Return type		: none
//******************************************************************************
CXModuleMemory::~CXModuleMemory()
{	
	if(!(g_hMemoryMutex == NULL))
		CloseHandle(g_hMemoryMutex);
}

//******************************************************************************
// Function name	: DisplayMemoryStatus
// Description	    : Display the values in the MEMORYSTATUS structure.
// Return type		: void
//******************************************************************************
void CXModuleMemory::DisplayMemoryStatus()
{
	MEMORYSTATUSEX MemoryStatus;
	VERIFY(SafeGlobalMemoryStatusEx(&MemoryStatus));
	
	ReportDebug(1,
		L"Memory Load: %lu%%\n"
		L"Total Physical: %I64Xh bytes\n"
		L"Available Physical: %I64Xh bytes\n"
		L"Total Page File %I64Xh bytes\n"
		L"Available Page File: %I64Xh bytes\n"
		L"Total Virtual: %I64Xh bytes\n"
		L"Available Virtual: %I64Xh bytes\n"
		L"Available Extended Virtual: %I64Xh bytes\n"
		L"Physical Memory Available to the OS: %I64uMB\n"
		L"Largest Contiguous Virtual Memory Block: %I64uMB",
		MemoryStatus.dwMemoryLoad,
		MemoryStatus.ullTotalPhys,
		MemoryStatus.ullAvailPhys,
		MemoryStatus.ullTotalPageFile,
		MemoryStatus.ullAvailPageFile,
		MemoryStatus.ullTotalVirtual,
		MemoryStatus.ullAvailVirtual,
		MemoryStatus.ullAvailExtendedVirtual,
		(QWORD)GetPhysicalMemorySize() >> 20,
		(QWORD)GetLargestVirtualBufferSize() >> 20);
}


//******************************************************************************
// Function name	: MemorySizeCheck
// Description	    : Verifies that the MemorySizeMB parameter matches the amount
//                    of memory in the system.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemorySizeCheck()
{
	DWORD dwExpectedMB,dwActualMB = (DWORD)(GetPhysicalMemorySize() >> 20);
	
	if((dwExpectedMB =GetCfgUint(L"MemorySizeMB",0)) == 0)
	{
		ReportError(0x10,L"MemorySizeMB missing");
		return;
	}
	if(dwExpectedMB != dwActualMB)
		errMemorySizeLL(dwExpectedMB,dwActualMB);
	
}


//******************************************************************************
// Function name	: MemorySlidingOnesAndZeros
// Description	    : Initializes the parameters for the SlidingOnesAndZeros
//                    test thread for a full memory test using one thread.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemorySlidingOnesAndZeros()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	
	SlidingOnesAndZeros(&ThreadParams);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: CacheSlidingOnesAndZeros
// Description	    : Initializes the parameters for the SlidingOnesAndZeros
//                    test thread for a cache test using one thread per processor.
// Return type		: void
//******************************************************************************
void CXModuleMemory::CacheSlidingOnesAndZeros()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterCacheSize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce = ParameterSwitch(L"Force");
	fNoCache = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	SlidingOnesAndZeros(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
	
}


//******************************************************************************
// Function name	: MemoryRandomData
// Description	    : Initializes the parameters for the RandomData test thread
//                    for a full memory test using one thread.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemoryRandomData()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care;
	ThreadParams.pTestParameters = &parameters;
	
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	
	RandomData(&ThreadParams);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: CacheRandomData
// Description	    : Initializes the parameters for the RandomData test thread
//                    for a cache test using one thread per processor.
// Return type		: void
//******************************************************************************
void CXModuleMemory::CacheRandomData()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterCacheSize();
	ThreadParams.pTestParameters = &parameters;
	fForce = ParameterSwitch(L"Force");
	fNoCache = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	RandomData(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: MemoryAddressPatterns
// Description	    : Initializes the parameters for the AddressPatterns test
//                    thread for a full memory test using one thread.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemoryAddressPatterns()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	
	AddressPatterns(&ThreadParams);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: CacheAddressPatterns
// Description	    : Initializes the parameters for the AddressPatterns test
//                    thread for a cache test using one thread per processor.
// Return type		: void
//******************************************************************************
void CXModuleMemory::CacheAddressPatterns()
{
	//TBD update cache control
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterCacheSize();
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	AddressPatterns(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: MemoryMixedOps
// Description	    : Initializes the parameters for the MixedOpsMixAlignRandomOrder
//                    test thread for a full memory test using one thread.   A
//                    list of non-overlapping byte, word, and dword accesses
//                    (both aligned and unaligned) is generated to completely
//                    access a 4KB block of memory. All of memory is written
//                    4KB at a time using that access list, then read back using
//                    a different 4KB access list.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemoryMixedOps()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	parameters.BlockSize         = 0x1000;
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	
	MixedOpsMixAlignRandomOrder(&ThreadParams);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: MemoryRandomDwordOps
// Description	    : Initializes the parameters for the DwordRandomOrder
//                    test thread for a full memory test using one thread.   A
//                    list of non-overlapping dword accesses is generated to
//                    completely access a 32KB block of memory. All of memory is
//                    written 32KB at a time using that access list, then read
//                    back using a different 32KB access list.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemoryRandomDwordOps()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	parameters.BlockSize         = 0x8000;
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	
	DwordRandomOrder(&ThreadParams);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: CacheMixedOps
// Description	    : Initializes the parameters for the MixedOpsMixAlignRandomOrder
//                    test thread for a cache test using one thread per processor.
//                    A list of non-overlapping byte, word, and dword accesses (both
//                    aligned and unaligned) is generated to completely access
//                    a 4KB block of memory.  A cache-sized block of memory is
//                    written 4KB at a time using that access list, then read
//                    back using a different 4KB access list.
// Return type		: void
//******************************************************************************
void CXModuleMemory::CacheMixedOps()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterCacheSize();
	parameters.BlockSize  = 0x1000;
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	MixedOpsMixAlignRandomOrder(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: CacheRandomDwordOps
// Description	    : Initializes the parameters for the DwordRandomOrder test
//                    thread for a cache test using one thread per processor.
//                    A list of non-overlapping dword accesses is generated to
//                    completely access a 32KB block of memory.  A cache-sized
//                    block of memory is written 32KB at a time using that access
//                    list, then read back using a different 32KB access list.
// Return type		: void
//******************************************************************************
void CXModuleMemory::CacheRandomDwordOps()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterCacheSize();
	parameters.BlockSize  = 0x8000;
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	DwordRandomOrder(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: WindowedCacheRandomData
// Description	    : Initializes the parameters for the RandomData test thread
//                    for a cache test using one thread per processor.  The test
//                    is "windowed" because it divides memory equally between
//                    processors and into cache-sized chunks and runs the cache
//                    test on each chunk.  This will test more tags in the cache.
// Return type		: void
//******************************************************************************
void CXModuleMemory::WindowedCacheRandomData()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize  = ParameterMemorySize();
	parameters.WindowSize  = ParameterCacheSize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	RandomData(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: WindowedCacheMixedOps
// Description	    : Initializes the parameters for the MixedOpsMixAlignRandomOrder
//                    test thread for a cache test using one thread per processor.
//                    The test is "windowed" because it divides memory equally
//                    between processors and into cache-sized chunks and runs the
//                    equivalent of the CacheMixedOps test on each chunk.  This
//                    will test more tags in the cache.
// Return type		: void
//******************************************************************************
void CXModuleMemory::WindowedCacheMixedOps()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterMemorySize();
	parameters.BlockSize  = 0x1000;
	parameters.WindowSize = ParameterCacheSize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	MixedOpsMixAlignRandomOrder(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}


//******************************************************************************
// Function name	: WindowedCacheRandomDwordOps
// Description	    : Initializes the parameters for the DwordRandomOrder test
//                    thread for a cache test using one thread per processor.
//                    The test is "windowed" because it divides memory equally
//                    between processors and into cache-sized chunks and runs the
//                    equivalent of the CacheRandomDwordOps test on each chunk.
//                    This will test more tags in the cache.
// Return type		: void
//******************************************************************************
void CXModuleMemory::WindowedCacheRandomDwordOps()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterMemorySize();
	parameters.BlockSize  = 0x8000;
	parameters.WindowSize = ParameterCacheSize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	DwordRandomOrder(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
	
}

//******************************************************************************
// Function name	: WindowedCacheUniqueness
// Description	    : Initializes the parameters for the MixedOpsMixAlignRandomOrder
//                    test thread for a cache test using one thread per processor.
//                    The test is "windowed" because it divides memory equally
//                    between processors and into cache-sized chunks and runs the
//                    equivalent of the CacheMixedOps test on each chunk.  This
//                    will test more tags in the cache.  This test is the same
//                    as the WindowedCacheMixedOps test except it generates an
//                    access list for a cache-sized block of memory instead of
//                    a 4KB block of memory.
// Return type		: void
//******************************************************************************
void CXModuleMemory::WindowedCacheUniqueness()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	bool           fForce,fNoCache;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize = ParameterMemorySize();
	parameters.WindowSize = ParameterCacheSize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	fForce               = ParameterSwitch(L"Force");
	fNoCache             = ParameterSwitch(L"NoCache");
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,fForce,fNoCache,1);
	MixedOpsMixAlignRandomOrder(&ThreadParams);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
	
}


//******************************************************************************
// Function name	: DDR32KStride
// Description	    : A special case of the powers of 2's test.  Most bang for the
//                  : for the test time buck.  Uses all caches and memory by creating a 
//                  : Write back cascade.
// Return type		: void
//******************************************************************************
void CXModuleMemory::DDR32KStride()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,ParameterSwitch(L"Force"),FALSE,1);
	
	DPowersof2(&ThreadParams,0x8000, 0x8000);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}
//******************************************************************************
// Function name	: DDRDeviceSuround
// Description	    : 
// Return type		: void
//******************************************************************************
void CXModuleMemory::DDRMemoryBanks()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	// Runs with cache off to force writes at time of instruction.
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,ParameterSwitch(L"Force"),FALSE,1);
	
	DPowersof2(&ThreadParams,parameters.MemorySize/2,parameters.MemorySize/4 );
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}
//******************************************************************************
// Function name	: DDRDeviceStride
// Description	    : 
// Return type		: void
//******************************************************************************
void CXModuleMemory::DDRDeviceStride()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	// Runs with cache off to force writes only to device targeted.
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,ParameterSwitch(L"Force"),FALSE,1);
	// the stride is because the device are 4 device 2 banks
	DPowersof2(&ThreadParams,16,16);
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}
//******************************************************************************
// Function name	: DDRBusNoise
// Description	    :
// Return type		: void
//******************************************************************************
void CXModuleMemory::DDRBusNoise()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,ParameterSwitch(L"Force"),FALSE,1);
	
	DPowersof2(&ThreadParams,0x8000, 0x8000);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}
//******************************************************************************
// Function name	: QWORDBusNoise
// Description	    : 
// Return type		: void
//******************************************************************************
void CXModuleMemory::QWORDBusNoise()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	parameters.WindowSize = ParameterCacheSize()/2;
	
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,ParameterSwitch(L"Force"),FALSE,1);
	
	QWORDNoise(&ThreadParams);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}
//******************************************************************************
// Function name	: DDRBusPowerof2
// Description	    : 
// Return type		: void
//******************************************************************************
void CXModuleMemory::DDRBusPowersof2()
{
	TESTCONDITIONS parameters;
	THREADPARAMS   ThreadParams;
	
	// Init the random number generator for this test.
	SetRandomSeed();
	
	ZeroMemory(&parameters,sizeof(parameters));
	parameters.MemorySize        = ParameterMemorySize();
	ThreadParams.ProcNumber      = -1;	// don't care
	ThreadParams.pTestParameters = &parameters;
	
	ThreadParams.pMemory = AllocateMemory(&parameters.MemorySize,ParameterSwitch(L"Force"),FALSE,1);
	
	DPowersof2(&ThreadParams,0x8, 0x10000);
	
	if(ThreadParams.pMemory)
		FreeMemory(ThreadParams.pMemory,parameters.MemorySize);
}

//******************************************************************************
// Function name	: SlidingOnesAndZeros
// Description	    : Shifts a single one and a single zero through every DWORD.
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    The processor number and parameters for the test.
//                    Only the MemorySizeMB parameter is used.
//******************************************************************************
DWORD CXModuleMemory::SlidingOnesAndZeros(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            pattern[2][64];
	DWORD_PTR        offset,MemorySize;
	DWORD            nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPDWORD          pdwVirt;
	LPDWORD          pdwMax,pdwSrc;
	LPTESTCONDITIONS pParameters;
	int i,j;
	BYTE bAbortStatus;
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	fProc0        = (pThreadParams->ProcNumber <= 0);	// Thread running on proc zero?
	
	// Store the sliding ones and zeros pattern in a 64-DWORD array.
	//     pattern[0] pattern[1]
	//  [0] FFFFFFFE   00000001
	//  [1] FFFFFFFD   00000002
	//  [2] FFFFFFFB   00000004
	//  [3] FFFFFFF7   00000008
	//         :          :
	// [28] EFFFFFFF   10000000
	// [29] DFFFFFFF   20000000
	// [30] BFFFFFFF   40000000
	// [31] 7FFFFFFF   80000000
	// [32] FFFFFFFE   00000001
	// [33] FFFFFFFD   00000002
	// [34] FFFFFFFB   00000004
	// [35] FFFFFFF7   00000008
	//         :          :
	// [60] EFFFFFFF   10000000
	// [61] DFFFFFFF   20000000
	// [62] BFFFFFFF   40000000
	// [63] 7FFFFFFF   80000000
	
	for(i = 0; i < 64; i++)
	{
		pattern[1][i] = 1 << (i % 32);
		pattern[0][i] = ~pattern[1][i];
	}
	
	pdwMax = (LPDWORD)pMem + MemorySize / 4;	// end of allocated memory.
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = 64;
	nProgCur = 0;
	
	// Write every DWORD in the allocated memory with every pattern in the pattern array.
	// Writes pattern[0][0]  to pattern[0][31] over and over again, then
	// writes pattern[0][1]  to pattern[0][32] over and over again, then
	// writes pattern[0][2]  to pattern[0][33] over and over again, then
	// writes pattern[0][3]  to pattern[0][34] over and over again, then
	//    :       :          :    :             :   :    :    :      :
	// writes pattern[0][28] to pattern[0][59] over and over again, then
	// writes pattern[0][29] to pattern[0][60] over and over again, then
	// writes pattern[0][30] to pattern[0][61] over and over again, then
	// writes pattern[0][31] to pattern[0][62] over and over again, then
	// Writes pattern[1][0]  to pattern[1][31] over and over again, then
	// writes pattern[1][1]  to pattern[1][32] over and over again, then
	// writes pattern[1][2]  to pattern[1][33] over and over again, then
	// writes pattern[1][3]  to pattern[1][34] over and over again, then
	//    :       :          :    :             :   :    :    :      :
	// writes pattern[1][28] to pattern[1][59] over and over again, then
	// writes pattern[1][29] to pattern[1][60] over and over again, then
	// writes pattern[1][30] to pattern[1][61] over and over again, then
	// writes pattern[1][31] to pattern[1][62] over and over again.
	//
	// This shifts a single zero through every bit of every DWORD in the allocation,
	// then shifts a single one through every bit.  Adjacent DWORDs have adjacent
	// bits set.
	//
	for(i = 0; i < 2; i++)
	{
		for(j = 0; j < 32; j++)
		{
			// Compute start of test pattern.
			pdwSrc = pattern[i] + j;
			ReportDebug(BIT0,L"Slidingones progress %d",((i+1)*(j+1))/64);
			
			// check for abort
			
			bAbortStatus = CheckAbort(L"Error message report");
			if(bAbortStatus == TRUE)
				throw((int)99);
			
			// Step 32-DWORDs at a time through the memory allocation.
			for(LPDWORD pdw = (LPDWORD)pMem; pdw < pdwMax; pdw += 32)
				CopyMemory(pdw,pdwSrc,32 * 4);	// Copy 32 DWORDs from pattern array to memory.
			
			if(g_fFaultInject)
			{
				*(pdwMax - 10) = 0xDEADBEEF;
			}
			//check for abort status
			bAbortStatus = CheckAbort(L"Error message report");
			if(bAbortStatus == TRUE)
				throw((int)99);
			// Step 32-DWORDs at a time through the memory allocation.
			for(pdw = (LPDWORD)pMem; pdw < pdwMax; pdw += 32)
			{
				// Compare 32-DWORDS with the pattern buffer.
				if((pdwVirt = AsmDwordMemCmp(pdw,pdwSrc,32)) != NULL)
				{
					// non-zero pbVirt is the virtual address of a failure.
					offset = pdwVirt - pdw; // dword offset
					DecodeFailingLocation(1,pdwVirt, (QWORD) *(pdwSrc + offset), (QWORD) *pdwVirt, 4, NULL);
				}
			}
			
			if(fProc0)
				Progress(++nProgCur * 100 / nProgMax);
		}
	}
	
	return 0;
}


//******************************************************************************
// Function name	: RandomData
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::RandomData(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            dwValue;
	DWORD_PTR        MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 4;
	if(nProgMax < 4)
		nProgMax = 4;
	nProgCur = 0;
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		// Fill the window with random DWORDs
		ReSeed(pThreadParams->ProcNumber);
		for(LPDWORD pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
			*pdw = random();
		//check for abort status
		bAbortStatus = CheckAbort(L"Error message report");
		if(bAbortStatus == TRUE)
			throw((int)99);
		if(g_fFaultInject)
			*(pdwMax - 1) = 0xDEADBEEF;
		
		if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
			Progress((int)(++nProgCur * 100 / nProgMax));
		
		// Read the DWORDs back and check for errors.
		ReSeed(pThreadParams->ProcNumber);
		for(pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
		{
			dwValue = random();
			if(*pdw != dwValue)
			{
				DecodeFailingLocation(1,pdw, (QWORD) dwValue, (QWORD) *pdw, 4, NULL);
				
				/*				errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pdw,
				(LPBYTE)pdw - pb,
				dwValue,
				*pdw,
				GetRandomSeed(),
				pThreadParams->ProcNumber);*/
			}
		}
		
		if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
			Progress((int)(++nProgCur * 100 / nProgMax));
		
		// Invert the memory.
		ReSeed(pThreadParams->ProcNumber);
		for( pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
			*pdw = ~random();
		
		if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
			Progress((int)(++nProgCur * 100 / nProgMax));
		
		if(g_fFaultInject)
			*(pdwMax - 1) = 0xDEADBEEF;
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
		
		// Check for errors again.
		ReSeed(pThreadParams->ProcNumber);
		for(pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
		{
			dwValue = ~random();
			if(*pdw != dwValue)
			{
				DecodeFailingLocation(1,pdw, (QWORD) dwValue, (QWORD) *pdw, 4, NULL);
				
				/*	errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pdw,
				(LPBYTE)pdw - pb,
				dwValue,
				*pdw,
				GetRandomSeed(),
				pThreadParams->ProcNumber);*/
			}
		}
		
		if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
			Progress((int)(++nProgCur * 100 / nProgMax));
	}
	
	return 0;
}

//******************************************************************************
// Function name	: QWORDNoise
// Description	    : Shifts a single a single zero through every nibble in QWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    The processor number and parameters for the test.
//                    Only the MemorySizeMB parameter is used.
//******************************************************************************
DWORD CXModuleMemory::QWORDNoise(LPTHREADPARAMS pThreadParams)
{
	BOOL             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->MemorySize;
	
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD pdw;
	DWORD dwBlockSize;
	DWORD dwAddress;
	BYTE bPatterns;
	BYTE bStatus;
	QWORD qwLow ;
	QWORD qwHigh;
	QWORD qwData =  0x0001000100010001;
	DWORD dwBusWords =8;
	QWORD exp;
	QWORD rec;
	_int64 TransCount = 0;
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 64; // 8 patterns
	nProgCur = 0;
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize / 2;  //bytes to words - the asm code counts words
		// the pattern is 4 shifts by even and odd
		for(bPatterns = 0; bPatterns<64; bPatterns++)
		{
			if (bPatterns < 32)
			{
				qwLow =  0xFFFFFFFFFFFFFFFF & ~(qwData << bPatterns%4);
				qwHigh = ~qwLow;
			}
			// 0111, 1011, 1101, 1110
			else
			{
				qwHigh =  0xFFFFFFFFFFFFFFFF & ~(qwData << bPatterns%4);
				qwLow = ~qwHigh;
				
			}
			
			TransCount = TransCount + WindowSize * 2; // write read 1 block
			ReportDebug(1,L"Writing\n");
			//check for abort status
			bAbortStatus = CheckAbort(0);
			if(bAbortStatus == TRUE)
				throw((int)99);
			
			__asm {
				emms
					push	eax
					push	ebx
					push	ecx
					push	edx
					push	edi
					push	esi
					mov		ebx, dwBlockSize
					mov		edx, dwBusWords
					movq	mm0,qwLow
					movq	mm1,qwHigh
					mov		edi, pb				// load the starting memory address
loop1:
				movq	[edi], mm0
					add		edi, edx
					movq	[edi], mm1
					add		edi, edx
					sub		ebx,8
					jnz		loop1
					
					pop		esi
					pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
			} 
			
			
			if(g_fFaultInject)
				*(pdwMax - 1) = 0xDEADBEEF;
			// blow the data out to memory with a write back of the cache
			__asm{
				wbinvd
			}
			
			// pre load the cache with data
			__asm {
				emms
					push	eax
					push	ebx
					push	ecx
					push	edx
					push	edi
					push	esi
					mov		ebx, dwBlockSize // the size of the memory block to test in bytes
					mov		esi, 32			 // the stride of the loads by cache line- 32 bytes
					mov		edi, pb			 // load the starting memory address
loop3r:
				mov		eax, [edi]		// load the data in to ax
					add		edi, esi		// inc the memory pointer
					sub		ebx,32			// inc to next cache line
					jnz		loop3r
					
					pop		esi
					pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
			}
			
			
			// do read from cache and compare
			__asm {
				emms
					push	eax
					push	ebx
					push	ecx
					push	edx
					push	edi
					push	esi
					mov		ebx, dwBlockSize
					mov		esi, dwBusWords
					movq	mm2,qwLow			// what to compare
					movq	mm3,qwHigh
					movq	mm4,qwLow			// make a copy for exp pat
					movq	mm5,qwHigh
					
					mov		edi, pb				// load the starting memory address
loop1r:
				movq	mm0, [edi]
					pcmpeqd mm2,mm0				// compare the data with the exp pat.
					psrlq	mm2,16				// shift so we can get both result in the low Dword
					movd	edx,mm2				// move the result to real reg where we can do real compare
					cmp		edx,0FFFFFFFFh
					jne		error1
					movq	mm2,mm4				// fresh data to cmp
					add		edi, esi
					
					movq	mm1, [edi]
					pcmpeqd mm3,mm1				// compare the data with the exp pat.
					psrlq	mm3,16				// shift so we can get both result in the low Dword
					movd	edx,mm3				// move the result to real reg where we can do real compare
					cmp		edx,0FFFFFFFFh
					jne		error2
					movq	mm3,mm5				// fresh data to cmp
					
					add		edi, esi
					sub		ebx,8
					jnz		loop1r
					
					mov		bStatus, 0			// passing status
					jmp		bye
error1:
				mov		bStatus, 1			// error in the low pat
					mov		dwAddress,edi
					movq	rec,mm0
					movq	exp,mm4
					jmp		bye
error2:
				mov		bStatus, 1			// error in the high pat
					mov		dwAddress,edi
					movq	rec,mm1
					movq	exp,mm5
bye:
				pop		esi
					pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
			}
			ReportDebug(2,L"Finished Reading\n");
			
			if (bStatus == 1)
			{
				// This test returns a special error message to flag OQM
				DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
				/*		ReportError(0x88,L"Pattern miscompare at address %ph buffer index %I64uh\n"
				L"Expected value=%016I64Xh   Received value=%016I64Xh\n",
				
				  real ? (LPVOID)real : (LPVOID)dwAddress,
				  (LPBYTE)dwAddress - pb,
				  exp,
				  rec,
				pThreadParams->ProcNumber);*/
			}
			
			if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
				Progress(++nProgCur * 100 / nProgMax);
		} // Patterns
	} // windows
	return 0;
}

//******************************************************************************
// Function name	: RambusCell
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::RambusCell(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD pdw;
	DWORD dwBlockSize;
	DWORD dwAddress;
	BYTE bPatterns;
	BYTE bDevices;
	BYTE bStatus;
	BYTE bBusWords = 4;
	_int64 pat0;
	_int64 pat1;
	_int64 zero	= 0;
	_int64 exp;
	_int64 rec;
	_int64 TransCount = 0;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 16;  // 2 bDevice loops, 4 bPattern loops, 2 Prog calls.
	nProgCur = 0;
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize / 2;
		
		// seq  through all possible rambus device configurations
		for(bDevices = 4; bDevices < 8; bDevices = (BYTE)(bDevices + 2))
		{
			// 4 set of surround patterns
			for(bPatterns = 0; bPatterns<4; bPatterns++)
			{
				if(bPatterns == 0)
				{
					pat0=0xffff000000000000;
					pat1=0xAAAA000000000000;
				}
				if(bPatterns == 1)
				{
					pat0=0xffff000000000000;
					pat1=0x5555000000000000;
				}
				if(bPatterns == 2)
				{
					pat0=0xaaaa000000000000;
					pat1=0xFFFF000000000000;
				}
				if(bPatterns == 3)
				{
					pat0=0x5555000000000000;
					pat1=0xFFFF000000000000;
				}
				if(bPatterns == 4)
				{
					pat0=0x0000000000000000;
					pat1=0xAAAA000000000000;
				}
				if(bPatterns == 5)
				{
					pat0=0x0000000000000000;
					pat1=0x5555000000000000;
				}
				if(bPatterns == 6)
				{
					pat0=0xaaaa000000000000;
					pat1=0x0000000000000000;
				}
				if(bPatterns == 7)
				{
					pat0=0x5555000000000000;
					pat1=0x0000000000000000;
				}
				if(bPatterns == 4)
				{
					pat0=0xffff000000000000;
					pat1=0xAAAA000000000000;
				}
				
				TransCount = TransCount + WindowSize * 2; // write read 1 block
				
				_asm{
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						movq	mm0,zero
						movq	mm1,pat0
						movq	mm2,pat1
						mov     al,bDevices
						mov		ebx, dwBlockSize
						mov		cl, bBusWords
						mov		ch,cl				// load the bus count
						mov		edi, pb				// load the starting memory address
loop0:				mov		ah, al				// reset the device count
loop1:				dec		ebx					// dec the size count
					jz		end					// check to see if all memory done
					psrlq	mm0,16				// move the pat1 into waveform
					por		mm0,mm1
					dec		ch					// dec the bus count
					jnz		nomove				// if bus count is 0 do the move
					movq	[edi], mm0
					mov		ch,cl				// reload the bus count
					add		edi,8				// inc the dest address
nomove:
					dec		ah					// dec the device count
						jnz		loop1
						
						mov		ah, al				//reset the device count
loop2:				dec		ebx
					jz		end
					psrlq	mm0,16				// move the pat1 into waveform
					por		mm0,mm2
					dec		ch					// dec the bus count
					jnz		nomove2				// if bus count is 0 do the move
					movq	[edi], mm0
					mov		ch,cl				// reload the bus count
					add		edi,8				// inc the dest address
nomove2:
					dec		ah					// dec the device count
						jnz		loop2
						jmp		loop0
end:				pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
				}
				//check for abort status
				bAbortStatus = CheckAbort(0);
				if(bAbortStatus == TRUE)
					throw((int)99);
				if(g_fFaultInject)
					*(pdwMax - 3) = 0xDEADBEEF;
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
				
				_asm{
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						movq	mm0,zero
						movq	mm1,pat0
						movq	mm2,pat1
						mov     al,bDevices
						mov		ebx, dwBlockSize
						mov		cl, bBusWords
						mov		ch,cl				// load the bus count
						mov		edi, pb				// load the starting memory address
						movq	mm4, [edi]			// we pre fetch the data way before we need it
loop0r:	mov		ah, al				// reset the device count
loop1r:	dec		ebx					// dec the size count
		jz		endr				// check to see if all memory done
		psrlq	mm0,16				// move the pat1 into waveform
		por		mm0,mm1
		dec		ch					// dec the bus count
		jnz		nomover				// if bus count is 0 do the move
		movq	mm3,mm4				// make a copy of the data so that well will still have the original if there is an error
		mov		ch,cl				// reload the bus count. This is ordered here so in can be same clock
		pcmpeqd mm3,mm0				// compare the pefetched data with the exp pat.
		psrlq	mm3,16				// shift so we can get both result in the low Dword
		movd	edx,mm3				// move the result to real reg where we can do real compare
		cmp		edx,0FFFFFFFFh
		jne		error
		add		edi,8				// inc the dest address
		movq	mm4,[edi]			// we pre fetch the data way before we need it
nomover:
					dec		ah					// dec the device count
						jnz		loop1r
						
						mov		ah, al				//reset the device count
loop2r:				dec		ebx
					jz		endr
					psrlq	mm0,16				// move the pat1 into waveform
					por		mm0,mm2
					dec		ch					// dec the bus count
					jnz		nomove2r			// if bus count is 0 do the move
					movq	mm3,mm4				// make a copy of the data so that well will still have the original if there is an error
					mov		ch,cl				// reload the bus count. This is ordered here so in can be same clock
					pcmpeqd mm3,mm0				// compare the pefetched data with the exp pat.
					psrlq	mm3,16				// shift so we can get both result in the low Dword
					movd	edx,mm3				// move the result to real reg where we can do real compare
					cmp		edx,0FFFFFFFFh
					jne		error
					add		edi,8				// inc the dest address
					movq	mm4, [edi]			// we pre fetch the data way before we need it
nomove2r:
					dec		ah					// dec the device count
						jnz		loop2r
						jmp		loop0r
endr:				mov		bStatus, 0
					jmp		bye
error:				mov		bStatus, 1
					mov		dwAddress,edi
					movq	rec,mm4
					movq	exp,mm0
bye:				pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
				}
				
				
				if (bStatus == 1)
				{
					DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
					/*				errDataMiscomparePQQQI(
					real ? (LPVOID)real : (LPVOID)dwAddress,
					(LPBYTE)dwAddress - pb,
					exp,
					rec,
					pThreadParams->ProcNumber);*/
				}
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
			} // Patterns
		} //devices
	} // windows
	
	return 0;
}
//******************************************************************************
// Function name	: WriteOrder
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::WriteOrder(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD			pdw;
	DWORD			dwBlockSize;
	DWORD			dwAddress;
	DWORD			dwDeviceStride,dwDeviceStride2;
	BYTE			bStatus;
	BYTE			bPatterns;
	WORD			pat0;
	WORD			pat1;
	WORD			exp;
	WORD			rec;
	QWORD			TransCount = 0;
	QWORD			qwWriteOrder0 = 0xFFFFFFFFFFFFFFFF;
	QWORD			qwWriteOrder1 = 0xFFFFFFFFFFFFFFFF;
	QWORD			qwWriteOrder2 = 0xFFFFFFFFFFFFFFFF;
	QWORD			qwWriteOrder3 = 0xFFFFFFFFFFFFFFFF;
	BYTE			bGood,bOrder[32],bRvalue = 0;
	DWORD			dwi,dwj,dwk;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 32; // 4 devices, 4 patterns, 2 calls.
	nProgCur = 0;
	
	ReSeed(pThreadParams->ProcNumber);
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize / 2;  //bytes to words - the asm code counts words
		
		for(dwDeviceStride = 4; dwDeviceStride < 8; dwDeviceStride++) //it must be 32 not 33 because we are using 0xFF to trigger the end of the pattern at we need to leave room for the last 0xFF
		{
			dwBlockSize = (MemorySize / dwDeviceStride - 1) / 2;
			
			// 4 set of surround patterns
			for(bPatterns = 0; bPatterns < 4; bPatterns++)
			{
				// init the byte order array
				for(dwi = 0; dwi < 32; dwi++)
					bOrder[dwi] = 0xFF;
				
				// fill out the byte order array with uniq values are need for the
				// number of devices we are testing
				for(dwj = 0; dwj < dwDeviceStride; dwj++)
				{
					bGood = FALSE;
					while(!bGood)
					{
						bGood = TRUE;
						// Generate a random byte order write
						bRvalue = (BYTE)(random() % dwDeviceStride);
						// Compare this against every other byte order write
						// we have all ready generated
						for(dwk = 0; dwk < dwDeviceStride; dwk++)
						{
							// if is the same keep gen another one
							if(bOrder[dwk] == bRvalue)
							{
								bGood= FALSE;
								break;
							}
						}
					}
					
					bOrder[dwj] = bRvalue;
				}
				
				// convert the order indexes to words
				for(dwj=0; dwj<dwDeviceStride; dwj++)
				{
					if (bOrder[dwj] != 0xFF)
						bOrder[dwj] = (BYTE)(bOrder[dwj]*2);
				}
				
				// load the write write ordering bytes into QWORD for loading
				// into the MMX regs.  Also convert the indexes to words - *2
				for(dwj = 0; dwj < 8; dwj++)
				{
					qwWriteOrder0 = ((qwWriteOrder0 >> 8) & 0x00FFFFFFFFFFFFFF) | (((QWORD)bOrder[dwj]   ) << 56);
					qwWriteOrder1 = ((qwWriteOrder1 >> 8) & 0x00FFFFFFFFFFFFFF) | (((QWORD)bOrder[dwj+8] ) << 56);
					qwWriteOrder2 = ((qwWriteOrder2 >> 8) & 0x00FFFFFFFFFFFFFF) | (((QWORD)bOrder[dwj+16]) << 56);
					qwWriteOrder3 = ((qwWriteOrder3 >> 8) & 0x00FFFFFFFFFFFFFF) | (((QWORD)bOrder[dwj+24]) << 56);
				}
				
				if(bPatterns == 0)
				{
					pat0=0xFFFF;
					pat1=0x0000;
				}
				if(bPatterns == 1)
				{
					pat0=0x0000;
					pat1=0xFFFF;
				}
				if(bPatterns == 2)
				{
					pat0=0xAAAA;
					pat1=0x5555;
				}
				if(bPatterns == 3)
				{
					pat0=0x5555;
					pat1=0xAAAA;
				}
				if(bPatterns > 3)
				{
					pat0=(WORD)random();
					pat1=(WORD)~pat0;
				}
				
				dwDeviceStride2 = dwDeviceStride * 2;
				TransCount = TransCount + WindowSize * 2; // write read 1 block
				
				__asm {
					// mm4 - mm5 Write order bytes
					// mm0 - mm3 Copies write order bytes
					// eax - Data pattern pat0 high 16 bits pat1 low16 bits
					// ebx - max memory address
					// ecx - device order tmp copy
					// edx - Write order index counter
					// ecx - write order address offset
					// edi - Current address
					// esi -
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						push	esi
						movq	mm4,qwWriteOrder0
						movq	mm5,qwWriteOrder1
						movq	mm6,qwWriteOrder2
						movq	mm7,qwWriteOrder3
						mov		ax, pat0
						shl		eax,16
						mov		ax, pat1
						mov		ebx, pbMax
						mov		edi, pb
						mov     esi,dwDeviceStride2
						sub		edi, esi			// correct for first loop
nextstr:
					
					// note this loop is unrolled for speed and to save regs
					// byte 0
					mov		ax, pat0
						shl		eax,16
						mov		ax, pat1
						
						movq	mm0,mm4				// fresh copy of write orders
						movq	mm1,mm5
						movq	mm2,mm6
						movq	mm3,mm7
						add		edi,esi				// inc by the stride
loop0:	//Byte 0
					rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 1
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 2
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 3
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 4
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 7
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 6
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						// byte 7
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						
						movq	mm0,mm1				// shift up the order count
						movq	mm1,mm2
						movq	mm2,mm3
						
						jmp		loop0
end:
						pop		esi
							pop		edi
							pop		edx
							pop		ecx
							pop		ebx
							pop		eax
							emms
				}
				//check for abort status
				bAbortStatus = CheckAbort(0);
				if(bAbortStatus == TRUE)
					throw((int)99);
				(0);
				if(g_fFaultInject)
					*(pdwMax - 1) = 0xDEADBEEF;
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
				
				__asm {
					
					// mm4 - mm5 Write order bytes
					// mm0 - mm3 Copies write order bytes
					// eax - Data pattern pat0 high 16 bits pat1 low16 bits
					// ebx - max memory address
					// ecx - device order tmp copy
					// edx - Write order index counter
					// ecx - write order address offset
					// edi - Current address
					// esi -
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						push	esi
						movq	mm4,qwWriteOrder0
						movq	mm5,qwWriteOrder1
						movq	mm6,qwWriteOrder2
						movq	mm7,qwWriteOrder3
						mov		ax, pat0
						shl		eax,16
						mov		ax, pat1
						mov		ebx, pbMax
						mov		edi, pb
						mov     esi,dwDeviceStride2
						sub		edi, esi			// correct for first loop
nextstrr:
					mov		ax, pat0
						shl		eax,16
						mov		ax, pat1
						
						// note this loop is unrolled for speed and to save regs
						movq	mm0,mm4				// fresh copy of write orders
						movq	mm1,mm5
						movq	mm2,mm6
						movq	mm3,mm7
						add		edi,esi				// inc by the stride
loop0r:	// byte 0
					rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		ax,dx
						jne		error
						
						// byte 1
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						// byte 2
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						// byte 3
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						// byte 4
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						// byte 7
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						// byte 6
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						// byte 7
						rol		eax,16				// shift our data pattern
						movd	ecx,mm0				// get the write order from the mmx reg
						and		ecx, 0x000000FF
						cmp		ecx, 0x000000FF
						je		nextstrr
						add		ecx, edi			// generate the working address
						psrlq	mm0,8				// for next byte n - pilelining for speed
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		dx,ax
						jne		error
						
						movq	mm0,mm1				// shift up the order count
						movq	mm1,mm2
						movq	mm2,mm3
						
						jmp		loop0r
						
endr:
						mov		bStatus, 0			// passing status
							jmp		bye
error:
						mov		bStatus, 1			// error in the low pat
							mov		dwAddress,edi
							mov		rec,dx
							mov		exp,ax
							jmp		bye
							
bye:
						pop		esi
							pop		edi
							pop		edx
							pop		ecx
							pop		ebx
							pop		eax
							emms
				}
				
				if (bStatus == 1)
				{
					DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
					/*					errDataMiscomparePQWWQQQQLI(
					real ? (LPVOID)real : (LPVOID)dwAddress,
					(LPBYTE)dwAddress - pb,
					exp,
					rec,
					qwWriteOrder0,
					qwWriteOrder1,
					qwWriteOrder2,
					qwWriteOrder3,
					GetRandomSeed(),
					pThreadParams->ProcNumber);*/
				}
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
				
			} // Patterns
		} //device stride
	} // windows
	
	return 0;
}

//******************************************************************************
// Function name	: AlternatingAddress
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::AlternatingAddress(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD			pdw;
	DWORD			dwBlockSize;
	DWORD			dwAddress;
	DWORD			dwDeviceStride,dwDeviceStride2;
	BYTE			bStatus;
	BYTE			bPatterns;
	WORD			pat0=0;
	WORD			pat1=0;
	WORD			exp;
	WORD			rec;
	QWORD			TransCount = 0;
	
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 64; // 8 strides, 4 patterns, 2 calls.
	nProgCur = 0;
	
	ReSeed(pThreadParams->ProcNumber);
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize/2;  //bytes to words - the asm code counts words
		
		for(dwDeviceStride = 1006; dwDeviceStride<1014; dwDeviceStride++) //it must be 32 not 33 because we are using 0xFF to trigger the end of the pattern at we need to leave room for the last 0xFF
		{
			dwBlockSize = (MemorySize/dwDeviceStride-1)/2;
			
			// 4 set of surround patterns
			for(bPatterns = 0; bPatterns<4; bPatterns++)
			{
				if(bPatterns == 0)
				{
					pat0=0xFFFF;
					pat1=0x0000;
				}
				if(bPatterns == 1)
				{
					pat0=0x0000;
					pat1=0xFFFF;
				}
				if(bPatterns == 2)
				{
					pat0=0xAAAA;
					pat1=0x5555;
				}
				if(bPatterns == 3)
				{
					pat0=0x5555;
					pat1=0xAAAA;
				}
				if(bPatterns > 3)
				{
					pat0=(WORD)random();
					pat1=(WORD)~pat0;
				}
				
				dwDeviceStride2 = dwDeviceStride*4;    // 2 word pre stride
				TransCount = TransCount+WindowSize*2; // write read 1 block
				
				_asm{
					
					// mm4 - mm5 Write order bytes
					// mm0 - mm3 Copies write order bytes
					// eax - Data pattern pat0 high 16 bits pat1 low16 bits
					// ebx - max memory address
					// ecx - device order tmp copy
					// edx - Write order index counter
					// ecx - write order address offset
					// edi - Current address
					// esi -
					
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						push	esi
						mov		ax, pat0
						shl		eax,16
						mov		ax, pat1
						mov		ebx, pbMax
						mov		edi, pb
						mov     esi,dwDeviceStride2
						
						
						mov		ax, pat0			// load the high low data pattern into eax
						shl		eax,16
						mov		ax, pat1
						
loop0:				// the low address
					rol		eax,16				// shift our data pattern
						cmp		edi, ebx			// the max address?
						jge		end
						mov		[edi],ax
						
						
						// The high address
						rol		eax,16				// shift our data pattern
						mov		ecx, edi			// generate the working address
						add		ecx, esi
						add		ecx, 2
						cmp		ecx, ebx			// the max address?
						jge		end
						mov		[ecx],ax
						
						add		edi,4				// next address skip the high address written
						
						jmp		loop0
						
end:
					pop		esi
						pop		edi
						pop		edx
						pop		ecx
						pop		ebx
						pop		eax
						emms
				}
				//check for abort status
				bAbortStatus = CheckAbort(0);
				if(bAbortStatus == TRUE)
					throw((int)99);
				
				if(g_fFaultInject)
					*(pdwMax - 1) = 0xDEADBEEF;
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
				
				_asm{
					// mm4 - mm5 Write order bytes
					// mm0 - mm3 Copies write order bytes
					// eax - Data pattern pat0 high 16 bits pat1 low16 bits
					// ebx - max memory address
					// ecx - device order tmp copy
					// edx - Write order index counter
					// ecx - write order address offset
					// edi - Current address
					// esi -
					
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						push	esi
						mov		ax, pat0
						shl		eax,16
						mov		ax, pat1
						mov		ebx, pbMax
						mov		edi, pb
						mov     esi,dwDeviceStride2
						
						
						mov		ax, pat0			// load the high low data pattern into eax
						shl		eax,16
						mov		ax, pat1
						
loop0r:				// the low address
					rol		eax,16				// shift our data pattern
						cmp		edi, ebx			// the max address?
						jge		endr
						mov		dx,[edi]
						cmp		ax,dx
						jne		error
						
						// The high address
						rol		eax,16				// shift our data pattern
						mov		ecx, edi			// generate the working address
						add		ecx, esi
						add		ecx, 2
						cmp		ecx, ebx			// the max address?
						jge		endr
						mov		dx,[ecx]
						cmp		ax,dx
						jne		error
						
						add		edi,4				// next address skip the high address written
						
						jmp		loop0r
						
endr:				mov		bStatus, 0			// passing status
					jmp		bye
error:				mov		bStatus, 1			// error in the low pat
					mov		dwAddress,edi
					mov		rec,dx
					mov		exp,ax
					jmp		bye
					
bye:				pop		esi
					pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
				}
				
				if (bStatus == 1)
				{
					DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
					/*				errDataMiscomparePQWWLI(
					real ? (LPVOID)real : (LPVOID)dwAddress,
					(LPBYTE)dwAddress - pb,
					exp,
					rec,
					GetRandomSeed(),
					pThreadParams->ProcNumber);*/
				}
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
				
			} // Patterns
		} //device stride
	} // windows
	
	return 0;
}
//******************************************************************************
// Function name	: AlternatingPatterns
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::AlternatingPatterns(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	LPDWORD          pdw;
	DWORD            dwBlockSize;
	DWORD            dwAddress;
	DWORD            dwStrideOffset,dwStrideOffset2;
	DWORD            dwDeviceStride,dwDeviceStride2;
	BYTE             bStatus;
	BYTE             bPatterns;
	BYTE             bWaveCount;
	BYTE             bWaveForm;
	BYTE             bShifter;
	QWORD            qwLow;
	QWORD            pat0 = 0;
	QWORD            pat1 = 0;
	QWORD            exp;
	QWORD            rec;
	QWORD            TransCount = 0;
	BYTE bAbortStatus;
	
	pParameters = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize  = pParameters->MemorySize;
	WindowSize  = pParameters->WindowSize;
	fProc0      = (pThreadParams->ProcNumber <= 0);
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 180;	// 5 device, 4+5+6+7+8 strides, 6 patterns.
	nProgCur = 0;
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize/2;  //bytes to words - the asm code counts words
		for(dwDeviceStride = 4; dwDeviceStride<9; dwDeviceStride++)
		{
			for(dwStrideOffset = 0; dwStrideOffset < dwDeviceStride; dwStrideOffset++)
			{
				dwBlockSize = ((MemorySize-dwStrideOffset)/dwDeviceStride-1)/2;
				// 4 set of surround patterns
				for(bPatterns = 0; bPatterns<6; bPatterns++)
				{
					for(bWaveCount = 0; bWaveCount < 2; bWaveCount++)
					{
						if(bWaveCount == 0)
							bWaveForm = 0xAA;
						else
							bWaveForm = 0x55;
						
						if(bPatterns == 0)
						{
							pat0=0xFFFF;
							pat1=0x0000;
						}
						
						if(bPatterns == 1)
						{
							pat0=0x5555;
							pat1=0xAAAA;
						}
						
						if(bPatterns == 3)
						{
							pat0=((_int64)random()) & 0x000000000000FFFF;
							pat1=~pat0 & 0x000000000000FFFF;
						}
						
						if(bPatterns == 4)
						{
							pat0=((_int64)random()) & 0x000000000000FFFF;
							pat1=~pat0 & 0x000000000000FFFF;
						}
						
						if(bPatterns == 5)
						{
							pat0=((_int64)random()) & 0x000000000000FFFF;
							pat1=~pat0 & 0x000000000000FFFF;
						}
						
						qwLow = 0;
						for(bShifter = 0; bShifter < 4; bShifter++)
						{
							// shift the low qword
							qwLow = qwLow << 16;
							
							// add new wave form data
							if (((bWaveForm << bShifter) & 0x80) == 0x80)
								qwLow = qwLow | pat0;
							else
								qwLow = qwLow | pat1;
						}
						
						dwStrideOffset2 = dwStrideOffset * 2;			//scale word vs. bytes;
						dwDeviceStride2 = dwDeviceStride * 2;
						TransCount      = TransCount+WindowSize * 2;	// write read 1 block
						
						_asm{
							emms
								push eax
								push ebx
								push ecx
								push edx
								push edi
								push esi
								movq mm0,qwLow
								mov  ebx,dwBlockSize
								mov  edi,pb              // load the starting memory address
								add  edi,dwStrideOffset2 // offset the pattern start to the selected devices.  We pick on up the missing bits on the wrap.
								mov  esi,dwDeviceStride2 // A 32 bit copy of the number of devices
								
loop0:
							movq [edi],mm0           // write
								add  edi,esi             // inc the dest address by the number of devices on the bus.  This will cause to hit the same devies on the next write
								dec  ebx                 // dec the size count
								jz   end
								jmp  loop0
								
end:
							pop  esi
								pop  edi
								pop  edx
								pop  ecx
								pop  ebx
								pop  eax
								emms
						}
						
						if(g_fFaultInject)
							*(pdwMax - 1) = 0xDEADBEEF;
						
						// keep alive
						//check for abort status
						bAbortStatus = CheckAbort(0);
						if(bAbortStatus == TRUE)
							throw((int)99);
						
						
						_asm{
							emms
								emms
								push    eax
								push    ebx
								push    ecx
								push    edx
								push    edi
								push    esi
								movq    mm2,qwLow
								movq    mm4,qwLow
								mov     ebx, dwBlockSize
								mov     edi, pb             // load the starting memory address
								add     edi,dwStrideOffset2 // offset the pattern start to the selected devices.  We pick on up the missing bits on the wrap.
								mov     esi,dwDeviceStride2 // A 32 bit copy of the number of devices
loop1r:
							movq    mm0, [edi]
								pcmpeqd mm2,mm0             // compare the data with the exp pat.
								psrlq   mm2,16              // shift so we can get both result in the low Dword
								movd    edx,mm2             // move the result to real reg where we can do real compare
								cmp     edx,0FFFFFFFFh
								jne     error1
								movq    mm2,mm4             // fresh data to cmp
								
								add     edi, esi            // Inc address and dec count
								dec     ebx
								jnz     loop1r
								
								mov     bStatus, 0          // passing status
								jmp     bye
error1:
							mov     bStatus, 1          // error in the low pat
								mov     dwAddress,edi
								movq    rec,mm0
								movq    exp,mm4
								jmp     bye
								
bye:
							pop     esi
								pop     edi
								pop     edx
								pop     ecx
								pop     ebx
								pop     eax
								emms
						}
						
						if(bStatus == 1)
						{
							DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
							/*						errDataMiscomparePQQQI(
							real ? (LPVOID)real : (LPVOID)dwAddress,
							(LPBYTE)dwAddress - pb,
							exp,
							rec,
							pThreadParams->ProcNumber);*/
						}
						// keep alive
						//check for abort status
						bAbortStatus = CheckAbort(0);
						if(bAbortStatus == TRUE)
							throw((int)99);
					} // Wave count
					
					if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
						Progress(++nProgCur * 100 / nProgMax);
				} // Patterns
			} //device offset
		} //device stride
	} // windows
	
	return 0;
}

void CXModuleMemory::TestPerformance(_int64 count)
{
	_int64 utime;
	HANDLE hThread;             // specifies the thread of interest
	FILETIME CreationTime;      // when the thread was created
	FILETIME ExitTime;          // when the thread was destroyed
	FILETIME KernelTime;        // time the thread has spent in kernel mode
	FILETIME UserTime;          // time the thread has spent in user mode);
	
	hThread = (HANDLE)GetCurrentThread();
	
	GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
	
	utime = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
	
	ReportDebug(1,L"thread run time %I64dmS, %I64d Megabytes transfered %I64d Megabytes/sec",
		utime/(_int64)10000,
		count/0x100000,
		(count/(utime/(_int64)10000)*1000)/0x100000);
}

#if !defined(WIN64)
//******************************************************************************
// Function name	: BusNoise
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::BusNoise(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD pdw;
	DWORD dwBlockSize;
	DWORD dwAddress;
	BYTE bPatterns;
	BYTE bStatus;
	BYTE bShifter = 0;
	QWORD qwLow, qwHigh;
	BYTE bWaveForm;
	DWORD	dwBusWords =8;
	_int64 pat0 = 0;
	_int64 pat1 = 0;
	_int64 exp;
	_int64 rec;
	_int64 TransCount = 0;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 2*254; // 2*254 patterns * waveforms
	nProgCur = 0;
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize / 2;  //bytes to words - the asm code counts words
		// the pattern is 8 words wides so skew by 8 to get all possible combo's
		for(bPatterns = 0; bPatterns<2; bPatterns++)
		{
			// Code in here to do a more than 2 waveform but for time
			// reasons this is set to 2 now.
			for(bWaveForm = 1; bWaveForm < 255; bWaveForm++)
			{
				if(bPatterns == 0)
				{
					pat0=0xFFFF;
					pat1=0x0000;
				}
				if(bPatterns == 1)
				{
					pat0=0x5555;
					pat1=0xAAAA;
				}
				if(bPatterns == 3)
				{
					pat0=((_int64)random()) & 0x000000000000FFFF;
					pat1=~pat0 & 0x000000000000FFFF;
				}
				if(bPatterns == 4)
				{
					pat0=((_int64)random()) & 0x000000000000FFFF;
					pat1=~pat0 & 0x000000000000FFFF;
				}
				if(bPatterns == 5)
				{
					pat0=((_int64)random()) & 0x000000000000FFFF;
					pat1=~pat0 & 0x000000000000FFFF;
				}
				qwHigh = 0;
				qwLow = 0;
				for(bShifter =0; bShifter <8; bShifter++)
				{
					//shift the high qword
					qwHigh = qwHigh << 16;
					
					// add the low qword carry to the high qword
					qwHigh = qwHigh | ((0xFFFF000000000000 & qwLow)>>48);
					
					// shift the low qword
					qwLow = qwLow << 16;
					
					// add new wave form data
					
					if (((bWaveForm << bShifter) & 0x80) == 0x80)
						qwLow = qwLow | pat0;
					else
						qwLow = qwLow | pat1;
				}
				
				TransCount = TransCount + WindowSize * 2; // write read 1 block
				
				__asm {
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						push	esi
						mov		ebx, dwBlockSize
						mov		edx, dwBusWords
						movq	mm0,qwLow
						movq	mm1,qwHigh
						mov		edi, pb				// load the starting memory address
loop1:
					movq	[edi], mm0
						add		edi, edx
						movq	[edi], mm1
						add		edi, edx
						sub		ebx,8
						jnz		loop1
						
						pop		esi
						pop		edi
						pop		edx
						pop		ecx
						pop		ebx
						pop		eax
						emms
				}
				
				if(g_fFaultInject)
					*(pdwMax - 1) = 0xDEADBEEF;
				
				//check for abort status
				bAbortStatus = CheckAbort(0);
				if(bAbortStatus == TRUE)
					throw((int)99);
				
				__asm {
					emms
						push	eax
						push	ebx
						push	ecx
						push	edx
						push	edi
						push	esi
						mov		ebx, dwBlockSize
						mov		esi, dwBusWords
						movq	mm2,qwLow			// what to compare
						movq	mm3,qwHigh
						movq	mm4,qwLow			// make a copy for exp pat
						movq	mm5,qwHigh
						
						mov		edi, pb				// load the starting memory address
loop1r:
					movq	mm0, [edi]
						pcmpeqd mm2,mm0				// compare the data with the exp pat.
						psrlq	mm2,16				// shift so we can get both result in the low Dword
						movd	edx,mm2				// move the result to real reg where we can do real compare
						cmp		edx,0FFFFFFFFh
						jne		error1
						movq	mm2,mm4				// fresh data to cmp
						add		edi, esi
						
						movq	mm1, [edi]
						pcmpeqd mm3,mm1				// compare the data with the exp pat.
						psrlq	mm3,16				// shift so we can get both result in the low Dword
						movd	edx,mm3				// move the result to real reg where we can do real compare
						cmp		edx,0FFFFFFFFh
						jne		error2
						movq	mm3,mm5				// fresh data to cmp
						
						add		edi, esi
						sub		ebx,8
						jnz		loop1r
						
						mov		bStatus, 0			// passing status
						jmp		bye
error1:
					mov		bStatus, 1			// error in the low pat
						mov		dwAddress,edi
						movq	rec,mm0
						movq	exp,mm5
						jmp		bye
error2:
					mov		bStatus, 1			// error in the high pat
						mov		dwAddress,edi
						movq	rec,mm1
						movq	exp,mm6
bye:
					pop		esi
						pop		edi
						pop		edx
						pop		ecx
						pop		ebx
						pop		eax
						emms
				}
				
				if (bStatus == 1)
				{
					DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
					/*			errDataMiscomparePQQQI(
					real ? (LPVOID)real : (LPVOID)dwAddress,
					(LPBYTE)dwAddress - pb,
					exp,
					rec,
					pThreadParams->ProcNumber);*/
				}
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
			} //waveforms
		} // Patterns
	} // windows
	
	TestPerformance(TransCount);
	
	return 0;
}

//******************************************************************************
// Function name	: Memory32K
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::Memory32K(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD			pdw;
	LPDWORD			dwBlockMax;
	DWORD			dwAddress;
	DWORD			dwDeviceStride;
	BYTE			bStatus;
	BYTE			bPatterns;
	BYTE			bWaveCount;
	BYTE			bWaveForm;
	BYTE			bShifter;
	QWORD			qwLow;
	QWORD			pat0 = 0;
	QWORD			pat1 = 0;
	QWORD			exp;
	QWORD			rec;
	QWORD			TransCount = 0;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 12; // 2 waves, 6 patterns
	nProgCur = 0;
	
	ReSeed(pThreadParams->ProcNumber);
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		
		// 4 set of surround patterns
		for(bPatterns = 0; bPatterns<6; bPatterns++)
		{
			for(bWaveCount = 0; bWaveCount < 2; bWaveCount++)
			{
				if(bWaveCount == 0)
					bWaveForm = 0xAA;
				else
					bWaveForm = 0x55;
				
				if(bPatterns == 0)
				{
					pat0=0xFFFF;
					pat1=0x0000;
				}
				if(bPatterns == 1)
				{
					pat0=0x5555;
					pat1=0xAAAA;
				}
				if(bPatterns == 3)
				{
					pat0=((_int64)random()) & 0x000000000000FFFF;
					pat1=~pat0 & 0x000000000000FFFF;
				}
				if(bPatterns == 4)
				{
					pat0=((_int64)random()) & 0x000000000000FFFF;
					pat1=~pat0 & 0x000000000000FFFF;
				}
				if(bPatterns == 5)
				{
					pat0=((_int64)random()) & 0x000000000000FFFF;
					pat1=~pat0 & 0x000000000000FFFF;
				}
				qwLow = 0;
				for(bShifter =0; bShifter <4; bShifter++)
				{
					// shift the low qword
					qwLow = qwLow << 16;
					
					// add new wave form data
					
					if (((bWaveForm << bShifter) & 0x80) == 0x80)
						qwLow = qwLow | pat0;
					else
						qwLow = qwLow | pat1;
					
				}
				
				for(dwDeviceStride = 0x8000; dwDeviceStride<0x8001; dwDeviceStride++)
				{
					dwBlockMax = pdwMax - 8; // 8 byte writes
					TransCount = TransCount+WindowSize*2; // write read 1 block
					
					_asm{
						//      mm0 - the data pattern
						//		eax	- copy of the starting address pb
						//      ebx - the stopping address
						//		ecx - the offset count
						//		edx
						//		edi - the current address
						//		esi - the stride
						emms
							push	eax
							push	ebx
							push	ecx
							push	edx
							push	edi
							push	esi
							movq	mm0,qwLow
							mov		ebx,dwBlockMax
							mov		eax,pb				// load the starting memory address
							mov     esi,dwDeviceStride	// the access stride
							sub		ecx,ecx				// set starting offsetto 0
							
loop00:
						mov		edi, eax			// load the starting memory address
							add		edi, ecx			// offset it
loop0:
						movq	[edi], mm0			// write
							add		edi,esi				// inc the dest address by the  stride.
							cmp		edi, ebx			// compare the next address with the max address
							jl		loop0				// done if the max address in <= next address
							
							add		ecx,8				// inc the stride offset, 8 byte writes
							cmp		ecx,esi				// compare the stide and the current offset
							jl		loop00				// if the stride is <= to the next offset we are done.
							
							pop		esi
							pop		edi
							pop		edx
							pop		ecx
							pop		ebx
							pop		eax
							emms
					}
					
					if(g_fFaultInject)
						*(pdwMax - 9) = 0xDEADBEEF;
					
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
					
					_asm{
						emms
							emms
							push	eax
							push	ebx
							push	ecx
							push	edx
							push	edi
							push	esi
							movq	mm2,qwLow
							movq	mm4,qwLow
							mov		ebx,dwBlockMax
							mov		eax,pb				// load the starting memory address
							mov     esi,dwDeviceStride	// the access stride
							sub		ecx,ecx				// set starting offsetto 0
loop00r:
						mov		edi, eax			// load the starting memory address
							add		edi, ecx			// offset it
							
loop1r:
						movq	mm0, [edi]
							pcmpeqd mm2,mm0				// compare the data with the exp pat.
							psrlq	mm2,16				// shift so we can get both result in the low Dword
							movd	edx,mm2				// move the result to real reg where we can do real compare
							cmp		edx,0FFFFFFFFh
							jne		error1
							movq	mm2,mm4				// fresh data to cmp
							
							add		edi,esi				// inc the dest address by the  stride.
							cmp		edi, ebx			// compare the next address with the max address
							jl		loop1r				// done if the max address in <= next address
							
							add		ecx,8				// inc the stride offset, 8 byte writes
							cmp		ecx,esi				// compare the stide and the current offset
							jl		loop00r				// if the stride is <= to the next offset we are done.
							
							mov		bStatus, 0			// passing status
							jmp		bye
error1:
						mov		bStatus, 1			// error in the low pat
							mov		dwAddress,edi
							movq	rec,mm0
							movq	exp,mm4
							jmp		bye
bye:
						pop		esi
							pop		edi
							pop		edx
							pop		ecx
							pop		ebx
							pop		eax
							emms
					}
					
					if (bStatus == 1)
					{
						DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
						/*						errDataMiscomparePQQQI(
						real ? (LPVOID)real : (LPVOID)dwAddress,
						(LPBYTE)dwAddress - pb,
						exp,
						rec,
						pThreadParams->ProcNumber);*/
					}
					
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
				} // Patterns
				
				if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
					Progress(++nProgCur * 100 / nProgMax);
				
			} //device offset
		} //device stride
	} // windows
	
	return 0;
}
//******************************************************************************
// Function name	: Powersof2
// Description	    : Writes random DWORDs and their complement to every DWORD
// Return type		: DWORD - Always 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Uses the MemorySize and WindowSize parameters only.
//******************************************************************************
DWORD CXModuleMemory::Powersof2(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD			pdw;
	LPDWORD			dwBlockMax;
	DWORD			dwAddress;
	DWORD			dwDeviceStride;
	BYTE			bStatus;
	BYTE			bPatterns;
	BYTE			bWaveCount;
	BYTE			bWaveForm;
	BYTE			bShifter;
	QWORD			qwLow;
	QWORD			pat0 = 0;
	QWORD			pat1 = 0;
	QWORD			exp;
	QWORD			rec;
	QWORD			TransCount = 0;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 88; // 11 strides, 2 patterns, 2 waves, 2 calls
	nProgCur = 0;
	
	ReSeed(pThreadParams->ProcNumber);
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		for(dwDeviceStride = 0x20; dwDeviceStride<0x10000; dwDeviceStride = dwDeviceStride*2)
		{
			// 2 set of surround patterns.  Code in here for more than that
			// but for time reasons we only running 2 for now
			for(bPatterns = 0; bPatterns<2; bPatterns++)
			{
				for(bWaveCount = 0; bWaveCount < 2; bWaveCount++)
				{
					if(bWaveCount == 0)
						bWaveForm = 0xAA;
					else
						bWaveForm = 0x55;
					
					if(bPatterns == 0)
					{
						pat0=0xFFFF;
						pat1=0x0000;
					}
					if(bPatterns == 1)
					{
						pat0=0x5555;
						pat1=0xAAAA;
					}
					if(bPatterns == 3)
					{
						pat0=((_int64)random()) & 0x000000000000FFFF;
						pat1=~pat0 & 0x000000000000FFFF;
					}
					if(bPatterns == 4)
					{
						pat0=((_int64)random()) & 0x000000000000FFFF;
						pat1=~pat0 & 0x000000000000FFFF;
					}
					if(bPatterns == 5)
					{
						pat0=((_int64)random()) & 0x000000000000FFFF;
						pat1=~pat0 & 0x000000000000FFFF;
					}
					qwLow = 0;
					for(bShifter =0; bShifter <4; bShifter++)
					{
						// shift the low qword
						qwLow = qwLow << 16;
						
						// add new wave form data
						
						if (((bWaveForm << bShifter) & 0x80) == 0x80)
							qwLow = qwLow | pat0;
						else
							qwLow = qwLow | pat1;
						
					}
					
					dwBlockMax = pdwMax - 8; // 8 byte writes
					TransCount = TransCount+WindowSize*2; // write read 1 block
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
					
					_asm{
						//      mm0 - the data pattern
						//		eax	- copy of the starting address pb
						//      ebx - the stopping address
						//		ecx - the offset count
						//		edx
						//		edi - the current address
						//		esi - the stride
						emms
							push	eax
							push	ebx
							push	ecx
							push	edx
							push	edi
							push	esi
							movq	mm0,qwLow
							mov		ebx,dwBlockMax
							mov		eax,pb				// load the starting memory address
							mov     esi,dwDeviceStride	// the access stride
							sub		ecx,ecx				// set starting offsetto 0
							
loop00:
						mov		edi, eax			// load the starting memory address
							add		edi, ecx			// offset it
loop0:
						movq	[edi], mm0			// write
							add		edi,esi				// inc the dest address by the  stride.
							cmp		edi, ebx			// compare the next address with the max address
							jl		loop0				// done if the max address in <= next address
							
							add		ecx,8				// inc the stride offset, 8 byte writes
							cmp		ecx,esi				// compare the stide and the current offset
							jl		loop00				// if the stride is <= to the next offset we are done.
							
							pop		esi
							pop		edi
							pop		edx
							pop		ecx
							pop		ebx
							pop		eax
							emms
					}
					
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
					if(g_fFaultInject)
						*(pdwMax - 9) = 0xDEADBEEF;
					
					if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
						Progress(++nProgCur * 100 / nProgMax);
					
					_asm{
						emms
							emms
							push	eax
							push	ebx
							push	ecx
							push	edx
							push	edi
							push	esi
							movq	mm2,qwLow
							movq	mm4,qwLow
							mov		ebx,dwBlockMax
							mov		eax,pb				// load the starting memory address
							mov     esi,dwDeviceStride	// the access stride
							sub		ecx,ecx				// set starting offsetto 0
loop00r:
						mov		edi, eax			// load the starting memory address
							add		edi, ecx			// offset it
							
loop1r:
						movq	mm0, [edi]
							pcmpeqd mm2,mm0				// compare the data with the exp pat.
							psrlq	mm2,16				// shift so we can get both result in the low Dword
							movd	edx,mm2				// move the result to real reg where we can do real compare
							cmp		edx,0FFFFFFFFh
							jne		error1
							movq	mm2,mm4				// fresh data to cmp
							
							add		edi,esi				// inc the dest address by the  stride.
							cmp		edi, ebx			// compare the next address with the max address
							jl		loop1r				// done if the max address in <= next address
							
							add		ecx,8				// inc the stride offset, 8 byte writes
							cmp		ecx,esi				// compare the stide and the current offset
							jl		loop00r				// if the stride is <= to the next offset we are done.
							
							mov		bStatus, 0			// passing status
							jmp		bye
error1:
						mov		bStatus, 1			// error in the low pat
							mov		dwAddress,edi
							movq	rec,mm0
							movq	exp,mm4
							jmp		bye
bye:
						pop		esi
							pop		edi
							pop		edx
							pop		ecx
							pop		ebx
							pop		eax
							emms
					}
					
					if (bStatus == 1)
					{
						DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
						/*				errDataMiscomparePQQQI(
						real ? (LPVOID)real : (LPVOID)dwAddress,
						(LPBYTE)dwAddress - pb,
						exp,
						rec,
						pThreadParams->ProcNumber);*/
					}
					
					if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
						Progress(++nProgCur * 100 / nProgMax);
					
				} // wave
			} // device pattern
		} // device stride
	} // windows
	
	return 0;
}

#endif	// WIN64

//******************************************************************************
// Function name	: AddressPatterns
// Description	    : Each DWORD is written with its address and its address's
//                    complement to check for uniqueness.
// Return type		: DWORD - Always returns 0.
// Argument         : LPTHREADPARAMS pThreadParams
//                    Only uses the MemorySize parameter.
//******************************************************************************
DWORD CXModuleMemory::AddressPatterns(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD_PTR        MemorySize;
	DWORD            nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize  = pParameters->MemorySize;
	fProc0      = (pThreadParams->ProcNumber <= 0);
	
	// Compute end test address.
	pdwMax = (LPDWORD)pMem + MemorySize / 4;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = 4;
	nProgCur = 0;
	
	// Write each DWORD with its address.
	for(LPDWORD pdw = (LPDWORD)pMem; pdw < pdwMax; pdw++)
		*pdw = (DWORD)(DWORD_PTR)pdw;
	
	
	if(g_fFaultInject)
		*(pdwMax - 1) = 0xDEADBEEF;
	
	if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
		Progress(++nProgCur * 100 / nProgMax);
	
	// Check for errors.
	for(pdw = (LPDWORD)pMem; pdw < pdwMax; pdw++)
	{
		if(*pdw != (DWORD)(DWORD_PTR)pdw)
		{
			DecodeFailingLocation(1,(LPDWORD)pdw, (QWORD) pdw, (QWORD) *pdw, 4, NULL);
			
			/*			errDataMiscomparePQLLI(
			real ? (LPVOID)real : pdw,
			(LPBYTE)pdw - (LPBYTE)pMem,
			(DWORD)(DWORD_PTR)pdw,
			*pdw,
			pThreadParams->ProcNumber);*/
		}
	}
	
	if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
		Progress(++nProgCur * 100 / nProgMax);
	
	// Write each DWORD with its address's complement.
	for(pdw = (LPDWORD)pMem; pdw < pdwMax; pdw++)
		*pdw = ~(DWORD)(DWORD_PTR)pdw;
	
	if(g_fFaultInject)
		*(pdwMax - 1) = 0xDEADBEEF;
	//check for abort status
	bAbortStatus = CheckAbort(0);
	if(bAbortStatus == TRUE)
		throw((int)99);
	
	if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
		Progress(++nProgCur * 100 / nProgMax);
	
	// Check for errors.
	for(pdw = (LPDWORD)pMem; pdw < pdwMax; pdw++)
	{
		if(*pdw != ~(DWORD)(DWORD_PTR)pdw)
		{
			DecodeFailingLocation(1,(LPDWORD)pdw, (QWORD) pdw, (QWORD) *pdw, 4, NULL);
			
			/*			errDataMiscomparePQLLI(
			real ? (LPVOID)real : pdw,
			(LPBYTE)pdw - (LPBYTE)pMem,
			(DWORD)(DWORD_PTR)pdw,
			*pdw,
			pThreadParams->ProcNumber);*/
		}
	}
	
	return 0;
}


//******************************************************************************
// Function name	: MixedOpsMixAlignRandomOrder
// Description	    : Performs random byte, word, and dword accesses to fill and
//                    compare memory a block at a time.  Accesses can be both
//                    aligned and unaligned.
// Return type		: DWORD - Always 0
// Argument         : LPTHREADPARAMS pThreadParams
//                    MemorySize - how much memory to test.
//                    WindowSize - write this much before reading back.
//                    BlockSize  - a non-overlapping list of addresses and sizes
//                                 is generated for this size of memory.  The
//                                 block is filled with random values and written
//                                 to all of memory using the access list.
//******************************************************************************
DWORD CXModuleMemory::MixedOpsMixAlignRandomOrder(LPTHREADPARAMS pThreadParams)
{
	LPTESTCONDITIONS pParameters;
	DWORD_PTR        MemorySize,BlockSize,WindowSize,offset,nProgCur,nProgMax;
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	LPBYTE           pbSrcBlock,pbWinMax,pbBlockMax,pbVirt;
	LPVOID           pMem = pThreadParams->pMemory;
	LPDWORD          pdwMax;
	BYTE bAbortStatus;
	
	pParameters = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize  = pParameters->MemorySize;
	BlockSize   = pParameters->BlockSize;
	WindowSize  = pParameters->WindowSize;
	fProc0      = (pThreadParams->ProcNumber <= 0);
	
	// Seed the thread.  The seed is a fixed difference
	// from the generated by SetRandomSeed().
	ReSeed(pThreadParams->ProcNumber);
	
	// If WindowSize or BlockSize are not specified, use these assumptions.
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	if(BlockSize == 0)
		BlockSize = WindowSize;
	
	// Make WindowSize an even multiple of BlockSize
	// Make MemorySize an even multiple of WindowSize
	WindowSize -= WindowSize % BlockSize;
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbWinMax = (LPBYTE)pMem + MemorySize;
	
	// Allocate a block of memory to fill with a random pattern.
	pbSrcBlock = new BYTE[BlockSize];
	
	if(pbSrcBlock == NULL)
	{
		errOutOfMemoryQ(BlockSize);
		// exit
		throw CXmtaException(99,NULL);
	}
	
	// Create the stress object (allocates buffers for access algorithm)
	// Read and write accesses must be data-aligned on IA-64, so stressobj
	// is built for a smaller memory size and multiplied by 4 later to get
	// DWORD-aligned addresses.
	
	stress stressobj(BlockSize,this);
	
	
	// Compute the end of the test block.
	pdwMax = (LPDWORD)(pbSrcBlock + BlockSize);
	
	// Generate random data in the source buffer.
	for(LPDWORD pdw = (LPDWORD)pbSrcBlock; pdw < pdwMax; pdw++)
		*pdw = random();
	
	// Build the list of write and read accesses.
	stressobj.build_write_log();
	stressobj.build_read_log();
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax  = MemorySize / BlockSize * 4;
	nProgCur  = 0;
	
	// Test a window of memory at a time.
	for(LPBYTE pbWin = (LPBYTE)pMem; pbWin < pbWinMax; pbWin += WindowSize)
	{
		// Compute the end of the test window.
		pbBlockMax = pbWin + WindowSize;
		
		// Use the write list to write the random data buffer a block
		// at a time to the window being tested.
		for(LPBYTE pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			stressobj.StressWrite(pbSrcBlock,pbBlock);
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
		
		if(g_fFaultInject)
			*(LPDWORD)(pbBlockMax - 4) = 0xDEADBEEF;
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
		
		
		// Use the read list to read and compare memory with the data
		// buffer a block at a time across the window being tested.
		for(pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			pbVirt = stressobj.StressRead(pbSrcBlock,pbBlock);
			
			if(pbVirt)
			{
				offset = pbVirt - pbBlock;
				
				// Round down to nearest DWORD address if we are at the end of our buffer
				// so we don't walk off the end.  Recalc the offset if needed.
				if(BlockSize - offset < 4)
				{
					DWORD_PTR tmp = (DWORD_PTR)pbVirt & ~0x3;
					pbVirt        = (LPBYTE)tmp;
					offset        = pbVirt - pbBlock;
				}
				
				DecodeFailingLocation(1,(LPDWORD)pbVirt, (QWORD) *(pbSrcBlock + offset), (QWORD) *pbVirt, 4, NULL);
				
				/*				errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pbVirt,
				offset,
				*(LPDWORD)(pbSrcBlock + offset),
				*(LPDWORD)pbVirt,
				GetRandomSeed(),
				pThreadParams->ProcNumber);*/
			}
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
	}
	
	// Complement the data in th source block so we test all the bits.
	for(pdw = (LPDWORD)pbSrcBlock; pdw < pdwMax; pdw++)
		*pdw = ~*pdw;
	
	// Build different read and write logs.
	stressobj.build_write_log();
	stressobj.build_read_log();
	
	// Test the memory again the same as above.
	for(pbWin = (LPBYTE)pMem; pbWin < pbWinMax; pbWin += WindowSize)
	{
		pbBlockMax = pbWin + WindowSize;
		
		for(LPBYTE pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			stressobj.StressWrite(pbSrcBlock,pbBlock);
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
		
		if(g_fFaultInject)
			*(LPDWORD)(pbBlockMax - 4) = 0xDEADBEEF;
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
		
		for(pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			pbVirt = stressobj.StressRead(pbSrcBlock,pbBlock);
			
			if(pbVirt)
			{
				offset = (DWORD)(pbVirt - pbBlock);
				
				// Round down to nearest DWORD address if we are at the end of our buffer
				// so we don't walk off the end.  Recalc the offset if needed.
				if(BlockSize - offset < 4)
				{
					DWORD_PTR tmp = (DWORD_PTR)pbVirt & ~0x3;
					pbVirt        = (LPBYTE)tmp;
					offset        = pbVirt - pbBlock;
				}
				
				DecodeFailingLocation(1,(LPDWORD)pbVirt, (QWORD) *(pbSrcBlock + offset), (QWORD) *pbVirt, 4, NULL);
				
				/*	errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pbVirt,
				offset,
				*(LPDWORD)(pbSrcBlock + offset),
				*(LPDWORD)pbVirt,
				GetRandomSeed(),
				pThreadParams->ProcNumber);*/
			}
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
	}
	
	delete [] pbSrcBlock;
	return 0;
}


//******************************************************************************
// Function name	: DwordRandomOrder
// Description	    : Performs random dword accesses to fill and compare memory
//                    a block at a time.  Accesses can be both aligned and unaligned.
// Return type		: DWORD - Always 0
// Argument         : LPTHREADPARAMS pThreadParams
//                    MemorySize - how much memory to test.
//                    WindowSize - write this much before reading back.
//                    BlockSize  - a non-overlapping list of addresses and sizes
//                                 is generated for this size of memory.  The
//                                 block is filled with random values and written
//                                 to all of memory using the access list.
//******************************************************************************
DWORD CXModuleMemory::DwordRandomOrder(LPTHREADPARAMS pThreadParams)
{
	LPTESTCONDITIONS pParameters;
	DWORD_PTR        MemorySize,BlockSize,WindowSize,offset;
	DWORD_PTR        nProgCur,nProgMax;
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	LPBYTE           pbSrcBlock,pbWinMax,pbBlockMax,pbVirt;
	LPVOID           pMem = pThreadParams->pMemory;
	LPDWORD          pdwMax;
	BYTE bAbortStatus;
	
	pParameters = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize  = pParameters->MemorySize;
	BlockSize   = pParameters->BlockSize;
	WindowSize  = pParameters->WindowSize;
	fProc0      = (pThreadParams->ProcNumber <= 0);
	
	// Seed the thread.  The seed is a fixed difference
	// from the generated by SetRandomSeed().
	ReSeed(pThreadParams->ProcNumber);
	
	// If WindowSize or BlockSize are not specified, use these assumptions.
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	if(BlockSize == 0)
		BlockSize = WindowSize;
	
	// Make WindowSize an even multiple of BlockSize
	// Make MemorySize an even multiple of WindowSize
	WindowSize -= WindowSize % BlockSize;
	MemorySize -= MemorySize % WindowSize;
	
	// Allocate a block of memory to fill with a random pattern.
	pbSrcBlock = new BYTE[BlockSize];
	
	if(pbSrcBlock == NULL)
	{
		errOutOfMemoryQ(BlockSize);
		// exit
		throw CXmtaException(99,NULL);
	}
	
	// Create the stress object (allocates buffers for access algorithm)
	// Builds a list for DWORD accesses by dividing size by four.
	stress stressobj(BlockSize / 4,this);
	
	// Compute the end of the test block.
	pdwMax = (LPDWORD)(pbSrcBlock + BlockSize);
	
	// Generate random data in the source buffer.
	for(LPDWORD pdw = (LPDWORD)pbSrcBlock; pdw < pdwMax; pdw++)
		*pdw = random();
	
	// Build the list of write and read accesses.
	stressobj.build_write_log();
	stressobj.build_read_log();
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax  = MemorySize / BlockSize * 4;
	nProgCur  = 0;
	
	// Compute end test address.
	pbWinMax = (LPBYTE)pMem + MemorySize;
	
	// Test a window of memory at a time.
	for(LPBYTE pbWin = (LPBYTE)pMem; pbWin < pbWinMax; pbWin += WindowSize)
	{
		// Compute the end of the test window.
		pbBlockMax = pbWin + WindowSize;
		
		// Use the write list to write the random data buffer a block
		// at a time to the window being tested.
		for(LPBYTE pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			stressobj.StressWriteDword(pbSrcBlock,pbBlock);
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
		
		if(g_fFaultInject)
			*(LPDWORD)(pbBlockMax - 4) = 0xDEADBEEF;
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
		
		// Use the read list to read and compare memory with the data
		// buffer a block at a time across the window being tested.
		for(pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			pbVirt = stressobj.StressReadDword(pbSrcBlock,pbBlock);
			
			if(pbVirt)
			{
				offset = pbVirt - pbBlock;
				DecodeFailingLocation(1,(LPDWORD)pbVirt, (QWORD) *(pbSrcBlock + offset), (QWORD) *pbVirt, 4, NULL);
				
				/*				errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pbVirt,
				offset,
				*(LPDWORD)(pbSrcBlock + offset),
				*(LPDWORD)pbVirt,
				GetRandomSeed(),
				pThreadParams->ProcNumber);*/
			}
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
	}
	
	// Complement the data in th source block so we test all the bits.
	for(pdw = (LPDWORD)pbSrcBlock; pdw < pdwMax; pdw++)
		*pdw = ~*pdw;
	
	// Build different read and write logs.
	stressobj.build_write_log();
	stressobj.build_read_log();
	
	// Test the memory again the same as above.
	for(pbWin = (LPBYTE)pMem; pbWin < pbWinMax; pbWin += WindowSize)
	{
		pbBlockMax = pbWin + WindowSize;
		
		for(LPBYTE pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			stressobj.StressWriteDword(pbSrcBlock,pbBlock);
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
		
		if(g_fFaultInject)
			*(LPDWORD)(pbBlockMax - 4) = 0xDEADBEEF;
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
		
		for(pbBlock = pbWin; pbBlock < pbBlockMax; pbBlock += BlockSize)
		{
			pbVirt = stressobj.StressReadDword(pbSrcBlock,pbBlock);
			
			if(pbVirt)
			{
				offset = (DWORD)(pbVirt - pbBlock);
				DecodeFailingLocation(1,(LPDWORD)pbVirt, (QWORD) *(pbSrcBlock + offset), (QWORD) *pbVirt, 4, NULL);
				
				/*				errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pbVirt,
				offset,
				*(LPDWORD)(pbSrcBlock + offset),
				*(LPDWORD)pbVirt,
				GetRandomSeed(),
				pThreadParams->ProcNumber);*/
			}
			
			if(fProc0)
				Progress((int)(++nProgCur * 100 / nProgMax));
		}
	}
	
	delete [] pbSrcBlock;
	return 0;
}


//******************************************************************************
// Function name	: MemoryTransfer
// Description	    : For each 256KB of memory, fill it with a random pattern and
//                    write it do disk, then read it back and verify the pattern
//                    is unchanged.  This can catch failures in the disk controller's
//                    ability to access all locations in memory.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemoryTransfer()
{
/*
#ifdef _XBOX
char          FileName[204] = "mem.dat";
#else
char          FileName[204] = "c:\\tdata\\00000000\MEDIA\\INTEL\\mem.dat";

  #endif
	*/
	//	_TCHAR          TempFilePath[2000];
	//	LPCTSTR			 TempDirStrPtr;		
	DWORD_PTR        MemorySize,WindowSize,nProgCur,nProgMax;
	DWORD            dwValue,dummy;
	LPVOID           pMem;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	HANDLE           hFile;
	BYTE bAbortStatus;
	//	size_t			 length;
	char			 FileString[1024];
	//	LPCSTR			 FileStrPtr;
	LPCTSTR			 FileTStrPtr;
	//	TCHAR StrOutput[512];
	// Init the random number generator for this test.
	SetRandomSeed();
	
	FileTStrPtr = GetCfgString(L"MemoryTransferFile",L"mem.dat");
	if(FileTStrPtr == NULL)
	{
		errMissingParameterS(L"MemoryTransferFile");
		return;
	}
	
	ReportDebug(2,L"Temporary filename = %s\n",FileTStrPtr);
	
	sprintf(FileString,"%S",FileTStrPtr);
	
	// Create temp file with no read/write buffering.
	hFile = CreateFile(
		FileString,
		GENERIC_WRITE | GENERIC_READ,
		0,				// no file sharing.
		NULL,			// default sec.
		CREATE_ALWAYS,
		//		FILE_FLAG_NO_BUFFERING | FILE_FLAG_DELETE_ON_CLOSE,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	
	if(INVALID_HANDLE_VALUE == hFile)
	{
		errUserTempFileS(GetLastError(),(char *)FileString);
		// exit
		return;
	}
	
	// Test available memory in 1MB increments.
	MemorySize = ParameterMemorySize();
	
	// Starting test address.
	pMem = AllocateMemory(&MemorySize,ParameterSwitch(L"Force"),ParameterSwitch(L"NoCache"),1);
	
	// reduced from 0x100000 to prevent problems with windows 2000 not being able to perform operation.
	WindowSize = 0x40000;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 2;
	if(nProgMax < 2)
		nProgMax = 2;
	nProgCur = 0; 
	
	// Test memory 256K at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		ReportDebug(3,L"overhead");
		// Compute the end of the 256kb window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		// Fill the window with random data.
		ReSeed(0);
		for(LPDWORD pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
			*pdw = random();
		
		// Rewind and write 256KB of data to the temp file.
		SetFilePointer(hFile,0,0,FILE_BEGIN);
		
		if(!WriteFile(hFile,pb,(DWORD)WindowSize,&dummy,NULL))
			errWriteFile(GetLastError());
		
		// Flush the data, rewind the file, and read the data back.
		FlushFileBuffers(hFile);
		SetFilePointer(hFile,0,0,FILE_BEGIN);
		
		if(!ReadFile(hFile,pb,(DWORD)WindowSize,&dummy,NULL))
			errReadFile(GetLastError());
		ReportDebug(3,L"writing");
		
		
		if(g_fFaultInject)
			*(pdwMax - 1) = 0xDEADBEEF;
		
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
		
		// Compare the data with the original random pattern.
		ReSeed(0);
		for(pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
		{
			dwValue = random();
			if(*pdw != dwValue)
			{
				DecodeFailingLocation(1,(LPDWORD)pdw, (QWORD) dwValue, (QWORD) *pdw, 4, NULL);
				
				/*		errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pdw,
				(LPBYTE)pdw - pb,
				dwValue,
				*pdw,
				GetRandomSeed(),
				-1);*/
			}
		}
		
		Progress((int)(++nProgCur * 100 / nProgMax));
		
		// Complement the random pattern and test again.
		ReSeed(0);
		for(pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
			*pdw = ~random();
		
		SetFilePointer(hFile,0,0,FILE_BEGIN);
		
		if(!WriteFile(hFile,pb,(DWORD)WindowSize,&dummy,NULL))
			errWriteFile(GetLastError());
		
		FlushFileBuffers(hFile);
		SetFilePointer(hFile,0,0,FILE_BEGIN);
		
		if(!ReadFile(hFile,pb,(DWORD)WindowSize,&dummy,NULL))
			errReadFile(GetLastError());
		
		if(g_fFaultInject)
			*(pdwMax - 1) = 0xDEADBEEF;
		
		ReportDebug(3,L"reading");
		ReSeed(0);
		for(pdw = (LPDWORD)pb; pdw < pdwMax; pdw++)
		{
			dwValue = ~random();
			if(*pdw != dwValue)
			{
				DecodeFailingLocation(1,(LPDWORD)pdw, (QWORD) dwValue, (QWORD) *pdw, 4, NULL);
				
				/*			errRndDataMiscomparePQLLLI(
				real ? (LPVOID)real : pdw,
				(LPBYTE)pdw - pb,
				dwValue,
				*pdw,
				GetRandomSeed(),
				-1);*/
			}
		}
		
		Progress((int)(++nProgCur * 100 / nProgMax));
	}
	CloseHandle(hFile); 
	FreeMemory(pMem,MemorySize);
	DeleteFile(FileString);
	
}
//******************************************************************************
// Function name	: CachePerformace
// Description	    : Benchmarks Cache performance to see if cache is operational
// Return type		: void
//******************************************************************************
void CXModuleMemory::CachePerformance()
{
	_int64 utime,utime1, utime2;
	HANDLE hThread;             // specifies the thread of interest
	FILETIME CreationTime;      // when the thread was created
	FILETIME ExitTime;          // when the thread was destroyed
	FILETIME KernelTime;        // time the thread has spent in kernel mode
	FILETIME UserTime;          // time the thread has spent in user mode);
	bool     fForce = 1,fNoCache = 0;
	DWORD	 MemorySize = 0x1b000;  //110K of cache will be used
	LPVOID	 pMemory;				//pointer to memory allocation for benchmarking
	int		 x;
	DWORD	 QwordCount = 0;
	QWORD	 count = 0;
	bool status;
	DWORD	dwRUCL,dwRLCL,dwWUCL,dwWLCL,MBSec;
	
	//Read Params
	dwRUCL = GetCfgUint(L"CacheReadPerformanceUCL",0);
	if(dwRUCL == 0)
		errMissingParameterS(L"CacheReadPerformaceUCL missing or 0");
	dwRLCL = GetCfgUint(L"CacheReadPerformanceLCL",0);
	if(dwRLCL == 0)
		errMissingParameterS(L"CacheReadPerformaceLCL missing or 0");
	
	//Write Params
	dwWUCL = GetCfgUint(L"CacheWritePerformanceUCL",0);
	if(dwWUCL == 0)
		errMissingParameterS(L"CacheWritePerformaceUCL missing or 0");
	dwWLCL = GetCfgUint(L"CacheWritePerformanceLCL",0);
	if(dwWLCL == 0)
		errMissingParameterS(L"CacheWritePerformaceLCL missing or 0");
	
	pMemory = AllocateMemory(&MemorySize,fForce,fNoCache,1);
	
	hThread = GetCurrentThread();
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
	
#ifdef _XBOX
	utime1 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime1 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif	
	QwordCount = (DWORD)(MemorySize/8); // convert to qword moves
	for(x=1; x<100000;x++)
	{
		//Write test
		_asm{
			EMMS
				PUSH	ECX
				PUSH	EDI
				MOV		ECX, QwordCount
				MOV		EDI, pMemory
loop1:
			MOVQ	[EDI],MM0
				ADD		SI,8
				DEC		ECX
				JNZ		loop1
				POP		EDI
				POP		ECX
				EMMS
				
		}
	}
	count = x*MemorySize;
	
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
#ifdef _XBOX
	utime2 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime2 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif		
	utime = utime2 - utime1;
	ASSERT(utime != 0);	
	MBSec = (DWORD)((count/(utime/(_int64)10000)*1000)/0x100000);	
	ReportDebug(1,L"Cache write performace: %I64dmS, %I64d Megabytes transfered %I64d Megabytes/sec",
		utime/(_int64)10000,
		count/0x100000,
		MBSec);
	ReportStatistic(L"CACHEWP",L"%f",(float)MBSec);
	if((MBSec < dwWLCL) || (MBSec > dwWUCL))
	{
		errPerProblemSIII(L"Cache Write", MBSec, dwWLCL, dwWUCL);
	}
	
	
	//Read Test
	
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
#ifdef _XBOX
	utime1 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime1 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif	
	QwordCount = (DWORD)(MemorySize/8); // convert to qword moves
	for(x=1; x<100000;x++)
	{
		//Write test
		_asm{
			EMMS
				PUSH	ECX
				PUSH	EDI
				MOV		ECX, QwordCount
				MOV		EDI, pMemory
loop2:
			MOVQ	MM0,[EDI]
				ADD		SI,8
				DEC		ECX
				JNZ		loop2
				POP		EDI
				POP		ECX
				EMMS
				
		}
	}
	count = x*MemorySize;
	
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
#ifdef _XBOX
	utime2 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime2 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif	
	utime = utime2 - utime1;
	ASSERT(utime != 0);	
	//MB/sec = bytes in Time /(Time in 100ns * 10000scale to ms *1000scale to sec)/) 1MB
	MBSec = (DWORD)((count/(utime/(_int64)10000)*1000)/0x100000);
	
	ReportDebug(1,L"Cache read performace: %I64dmS, %I64d Megabytes transfered %I64d Megabytes/sec",
		utime/(_int64)10000,
		count/0x100000,
		MBSec);
	ReportStatistic(L"CACHERP",L"%f",(float)MBSec);
	
	if((MBSec < dwRLCL) || (MBSec > dwRUCL))
	{
		errPerProblemSIII(L"Cache Read", MBSec, dwRLCL, dwRUCL);
	}
	FreeMemory(pMemory,MemorySize);
	
}
//******************************************************************************
// Function name	: MemoryPerformance
// Description	    : Benchmarks memory performance to see if memory is operational.
// Return type		: void
//******************************************************************************
void CXModuleMemory::MemoryPerformance()
{
	_int64 utime,utime1, utime2;
	HANDLE hThread;             // specifies the thread of interest
	FILETIME CreationTime;      // when the thread was created
	FILETIME ExitTime;          // when the thread was destroyed
	FILETIME KernelTime;        // time the thread has spent in kernel mode
	FILETIME UserTime;          // time the thread has spent in user mode);
	bool     fForce = 1,fNoCache = 0;
	DWORD	 MemorySize = 0x1400000;  // The amount of memory to benchmark - 20Meg
	LPVOID	 pMemory;				//pointer to memory allocation for benchmarking
	int		 x;
	DWORD	 QwordCount = 0;
	QWORD	 count = 0;
	bool status;
	DWORD	dwRUCL,dwRLCL,dwWUCL,dwWLCL,MBSec;
	
	//Read params
	dwRUCL = GetCfgUint(L"MemoryReadPerformanceUCL",0);
	if(dwRUCL == 0)
		errMissingParameterS(L"MemoryReadPerformanceUCL missing or 0");
	dwRLCL = GetCfgUint(L"MemoryReadPerformanceLCL",0);
	if(dwRLCL == 0)
		errMissingParameterS(L"MemoryReadPerformanceLCL missing or 0");
	
	//Write params
	dwWUCL = GetCfgUint(L"MemoryWritePerformanceUCL",0);
	if(dwWUCL == 0)
		errMissingParameterS(L"MemoryWritePerformanceUCL missing or 0");
	dwWLCL = GetCfgUint(L"MemoryWritePerformanceLCL",0);
	if(dwWLCL == 0)
		errMissingParameterS(L"MemoryWritePerformanceLCL missing or 0");
	
	pMemory = AllocateMemory(&MemorySize,fForce,fNoCache,1);
	
	hThread = GetCurrentThread();
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
#ifdef _XBOX
	utime1 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime1 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif
	QwordCount = (DWORD)(MemorySize/16); // convert to qword moves
	for(x=0; x<10;x++)
	{
		//Write test
		_asm{
			EMMS
				PUSH	ECX
				PUSH	EDI
				MOV		ECX, QwordCount
				MOV		EDI, pMemory
				
loop1:
			MOVAPS	[EDI],XMM0
				ADD		EDI,16
				DEC		ECX
				JNZ		loop1
				POP		EDI
				POP		ECX
				EMMS
				
		}
	}
	count = x*MemorySize;
	
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
#ifdef _XBOX
	utime2 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime2 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif
	
	utime = utime2 - utime1;
	ASSERT(utime != 0);
	MBSec = (DWORD)((count/(utime/(_int64)10000)*1000)/0x100000);
	ReportDebug(1,L"Memory write performace: %I64dmS, %I64d Megabytes transfered %I64d Megabytes/sec",
		utime/(_int64)10000,
		count/0x100000,
		MBSec);
	ReportStatistic(L"MEMORYWP",L"%f",(float)MBSec);
	
	if((MBSec < dwWLCL) || (MBSec > dwWUCL))
	{
		errPerProblemSIII(L"Memory Write", MBSec, dwWLCL, dwWUCL);
	}
	
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
	
	//Read Test
#ifdef _XBOX
	utime1 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime1 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif	
	QwordCount = (DWORD)(MemorySize/16); // convert to qword moves
	for(x=0; x<10;x++)
	{
		_asm{
			EMMS
				PUSH	ECX
				PUSH	EDI
				MOV		ECX, QwordCount
				MOV		EDI, pMemory
				
loop2:
			MOVAPS	XMM0,[EDI]
				ADD		EDI,16
				DEC		ECX
				JNZ		loop2
				POP		EDI
				POP		ECX
				EMMS
				
		}
	}
	count = x*MemorySize;
	
	status = GetThreadTimes(
		hThread,
		&CreationTime,
		&ExitTime,
		&KernelTime,
		&UserTime
		);
	
#ifdef _XBOX
	utime2 = (((_int64)KernelTime.dwHighDateTime <<32) +(_int64)KernelTime.dwLowDateTime);
#else 
	utime2 = (((_int64)UserTime.dwHighDateTime <<32) +(_int64)UserTime.dwLowDateTime);
#endif
	
	utime = utime2 - utime1;
	ASSERT(utime != 0);	
	MBSec = (DWORD)((count/(utime/(_int64)10000)*1000)/0x100000);
	ReportDebug(1,L"Memory read performace: %I64dmS, %I64d Megabytes transfered %I64d Megabytes/sec",
		utime/(_int64)10000,
		count/0x100000,
		MBSec);
	ReportStatistic(L"MEMORYRP",L"%f",(float)MBSec);
	
	if((MBSec < dwRLCL) || (MBSec > dwRUCL))
	{
		errPerProblemSIII(L"Memory Read", MBSec, dwWLCL, dwWUCL);
	}	FreeMemory(pMemory,MemorySize);
}
//******************************************************************************
// Function name	: DPowersof2
// Description	    : 
// Return type		: DWORD - currently not used
//******************************************************************************
DWORD CXModuleMemory::DPowersof2(LPTHREADPARAMS pThreadParams, DWORD StrideStart, DWORD StrideEnd)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPBYTE			 pbFail;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD			pdw;
	DWORD			dwDeviceStride;
	BYTE			bPatterns;
	QWORD			exp=0;
	QWORD			rec=0;
	QWORD			TransCount = 0;
	DWORD			Data;
	DWORD			Address=0,AddressOffset=0;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 88; // 11 strides, 2 patterns, 2 waves, 2 calls
	nProgCur = 0;
	
	ReSeed(pThreadParams->ProcNumber);
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		for(dwDeviceStride = StrideStart; dwDeviceStride<=StrideEnd; dwDeviceStride = dwDeviceStride*2)
		{
			//check for abort status
			bAbortStatus = CheckAbort(0);
			if(bAbortStatus == TRUE)
				throw((int)99);
			
			// 0 and 1 in every cell
			for(bPatterns = 0; bPatterns<2; bPatterns++)
			{
				TransCount = TransCount+MemorySize*2;
				if(bPatterns)
					Data =0xFFFFFFFF;
				else
					Data =0x0;
				// offset for the stride
				for(AddressOffset = 0; AddressOffset < dwDeviceStride; AddressOffset++)
				{
					// The stride
					for(Address = AddressOffset; Address<(DWORD)MemorySize/4; Address=(Address+dwDeviceStride*2))
					{
						pdw[Address] = Data;
						pdw[Address+dwDeviceStride] = ~Data;
					}
				}
				// offset for the stride
				for(AddressOffset = 0; AddressOffset < dwDeviceStride; AddressOffset++)
				{
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
					
					// the stride
					for(Address = 0; Address<(DWORD)MemorySize/4; Address=(Address+dwDeviceStride*2))
					{
						if(pdw[Address] != Data)
						{
							rec = pdw[Address];
							exp = Data;
							pbFail = (LPBYTE)((DWORD)((LPBYTE)&pdw[Address])*4);
							break;
						}
						if(pdw[Address+dwDeviceStride] != ~Data)
						{
							rec = pdw[Address];
							exp = ~Data;
							pbFail = (LPBYTE)((DWORD)((LPBYTE)&pdw[Address])*4);
							break;
						}
					}
				}
				
				// check for error if we did not make to the end of the pattern
				if(Address<(DWORD)MemorySize/4)
				{
					DecodeFailingLocation(1,(LPDWORD)pbFail, (QWORD) exp, (QWORD) rec, 8, NULL);
					/*				errDataMiscomparePQQQI(
					real ? (LPVOID)real : (LPVOID)pbFail,
					Address*4,
					exp,
					rec,
					pThreadParams->ProcNumber); */
					
				}
			} // device pattern
		} // device stride
	} // windows
	
	
	return 0;
}
//******************************************************************************
// Function name	: DMemoryBanks
// Description	    : 
// Return type		: DWORD - currently not used
//******************************************************************************
DWORD CXModuleMemory::DMemoryBanks(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPBYTE			 pbFail;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD			pdw;
	DWORD			dwDeviceStride;
	BYTE			bPatterns;
	QWORD			exp;
	QWORD			rec;
	QWORD			TransCount = 0;
	DWORD			Data;
	DWORD			Address,AddressOffset;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 88; // 11 strides, 2 patterns, 2 waves, 2 calls
	nProgCur = 0;
	
	ReSeed(pThreadParams->ProcNumber);
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		for(dwDeviceStride = 0; dwDeviceStride<=0; dwDeviceStride = dwDeviceStride*2)
		{
			// 0 and 1 in every cell
			for(bPatterns = 0; bPatterns<2; bPatterns++)
			{
				TransCount = TransCount+MemorySize*2;
				if(bPatterns == 0)
					Data = 0xFFFFFFFF;
				if(bPatterns == 1)
					Data =0x0;
				// offset for the stride
				for(AddressOffset = 0; AddressOffset < dwDeviceStride; AddressOffset++)
				{
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
					
					// The stride
					for(Address = AddressOffset; Address<(DWORD)MemorySize/4; Address=(Address+dwDeviceStride*2))
					{
						pdw[Address] = Data;
						pdw[Address+dwDeviceStride] = ~Data;
					}
				}
				// offset for the stride
				for(AddressOffset = 0; AddressOffset < dwDeviceStride; AddressOffset++)
				{
					//check for abort status
					bAbortStatus = CheckAbort(0);
					if(bAbortStatus == TRUE)
						throw((int)99);
					
					// the stride
					for(Address = 0; Address<(DWORD)MemorySize/4; Address=(Address+dwDeviceStride*2))
					{
						if(pdw[Address] != Data)
						{
							rec = pdw[Address];
							exp = Data;
							pbFail = (LPBYTE)((DWORD)((LPBYTE)&pdw[Address])*4);
							break;
						}
						if(pdw[Address+dwDeviceStride] != ~Data)
						{
							rec = pdw[Address];
							exp = ~Data;
							pbFail = (LPBYTE)((DWORD)((LPBYTE)&pdw[Address])*4);
							break;
						}
					}
				}
				// check for error if we did not make to the end of the pattern
				if(Address<(DWORD)MemorySize/4)
				{
					DecodeFailingLocation(1,(LPDWORD)pbFail, (QWORD) exp, (QWORD) rec, 8, NULL);
					/*			errDataMiscomparePQQQI(
					real ? (LPVOID)real : (LPVOID)pbFail,
					Address*4,
					exp,
					rec,
					pThreadParams->ProcNumber);*/
					
				}
			} // device pattern
		} // device stride
	} // windows
	TestPerformance(TransCount);
	
	return 0;
}

//******************************************************************************
// Function name	: DBusNoise
// Description	    : 
// Return type		: DWORD - currently not used
//******************************************************************************
DWORD CXModuleMemory::DBusNoise(LPTHREADPARAMS pThreadParams)
{
	bool             fProc0;	// TRUE if thread sends wt_progress messages.
	DWORD            MemorySize,WindowSize,nProgCur,nProgMax;
	LPVOID           pMem = pThreadParams->pMemory;
	LPBYTE           pbMax;
	LPDWORD          pdwMax;
	LPTESTCONDITIONS pParameters;
	BYTE bAbortStatus;
	
	pParameters   = (LPTESTCONDITIONS)pThreadParams->pTestParameters;
	MemorySize    = pParameters->MemorySize;
	WindowSize    = pParameters->WindowSize;
	fProc0        = (pThreadParams->ProcNumber <= 0);
	
	LPDWORD pdw;
	DWORD dwBlockSize;
	DWORD dwAddress;
	BYTE bPatterns;
	BYTE bStatus;
	QWORD qwLow ;
	QWORD qwHigh;
	QWORD qwData =  0x0001000100010001;
	DWORD dwBusWords =8;
	QWORD exp;
	QWORD rec;
	_int64 TransCount = 0;
	
	if(!MMXCheck())
	{
		errMMX();
		return 0;
	}
	
	if(WindowSize == 0)
		WindowSize = MemorySize;
	
	// MemorySize must be a multiple of WindowSize
	MemorySize -= MemorySize % WindowSize;
	
	// Compute end test address.
	pbMax = (LPBYTE)pMem + MemorySize;
	
	// Compute the number of times the Progress() function will be called
	// in the code below so a percent complete value can be computed.
	nProgMax = MemorySize / WindowSize * 8; // 8 patterns
	nProgCur = 0;
	
	// Walk through memory a window at a time.
	for(LPBYTE pb = (LPBYTE)pMem; pb < pbMax; pb += WindowSize)
	{
		// Compute the end of the window.
		pdwMax = (LPDWORD)pb + WindowSize / 4;
		
		pdw = (LPDWORD)pb;
		dwBlockSize = WindowSize / 2;  //bytes to words - the asm code counts words
		// the pattern is 4 shifts by even and odd
		for(bPatterns = 0; bPatterns<64; bPatterns++)
		{
			if (bPatterns < 32)
			{
				qwLow =  0xFFFFFFFFFFFFFFFF & ~(qwData << bPatterns%4);
				qwHigh = ~qwLow;
			}
			else
			{
				qwHigh =  0xFFFFFFFFFFFFFFFF & ~(qwData << bPatterns%4);
				qwLow = ~qwHigh;
				
			}
			
			TransCount = TransCount + WindowSize * 2; // write read 1 block
			
			__asm {
				emms
					push	eax
					push	ebx
					push	ecx
					push	edx
					push	edi
					push	esi
					mov		ebx, dwBlockSize
					mov		edx, dwBusWords
					movq	mm0,qwLow
					movq	mm1,qwHigh
					mov		edi, pb				// load the starting memory address
loop1:
				movq	[edi], mm0
					add		edi, edx
					movq	[edi], mm1
					add		edi, edx
					sub		ebx,8
					jnz		loop1
					
					pop		esi
					pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
			}
			
			if(g_fFaultInject)
				*(pdwMax - 1) = 0xDEADBEEF;
			
			//check for abort status
			bAbortStatus = CheckAbort(0);
			if(bAbortStatus == TRUE)
				throw((int)99);
			
			__asm {
				emms
					push	eax
					push	ebx
					push	ecx
					push	edx
					push	edi
					push	esi
					mov		ebx, dwBlockSize
					mov		esi, dwBusWords
					movq	mm2,qwLow			// what to compare
					movq	mm3,qwHigh
					movq	mm4,qwLow			// make a copy for exp pat
					movq	mm5,qwHigh
					
					mov		edi, pb				// load the starting memory address
loop1r:
				movq	mm0, [edi]
					pcmpeqd mm2,mm0				// compare the data with the exp pat.
					psrlq	mm2,16				// shift so we can get both result in the low Dword
					movd	edx,mm2				// move the result to real reg where we can do real compare
					cmp		edx,0FFFFFFFFh
					jne		error1
					movq	mm2,mm4				// fresh data to cmp
					add		edi, esi
					
					movq	mm1, [edi]
					pcmpeqd mm3,mm1				// compare the data with the exp pat.
					psrlq	mm3,16				// shift so we can get both result in the low Dword
					movd	edx,mm3				// move the result to real reg where we can do real compare
					cmp		edx,0FFFFFFFFh
					jne		error2
					movq	mm3,mm5				// fresh data to cmp
					
					add		edi, esi
					sub		ebx,8
					jnz		loop1r
					
					mov		bStatus, 0			// passing status
					jmp		bye
error1:
				mov		bStatus, 1			// error in the low pat
					mov		dwAddress,edi
					movq	rec,mm0
					movq	exp,mm4
					jmp		bye
error2:
				mov		bStatus, 1			// error in the high pat
					mov		dwAddress,edi
					movq	rec,mm1
					movq	exp,mm5
bye:
				pop		esi
					pop		edi
					pop		edx
					pop		ecx
					pop		ebx
					pop		eax
					emms
			}
			
			if (bStatus == 1)
			{
				DecodeFailingLocation(1,(LPDWORD)dwAddress, (QWORD) exp, (QWORD) rec, 8, NULL);
				
				/*				ReportError(0x89,L"Pattern miscompare at address %ph buffer index %uh\n"
				L"Expected value=%016I64Xh   Received value=%016I64Xh\n"
				L"Test thread running on processor %d (-1 = not specified)\n"
				L"If MEMMAP.SYS is not installed or this is Win9X the address is VIRTUAL.",real ? (LPVOID)real : (LPVOID)dwAddress,
				(LPBYTE)dwAddress - pb,
				exp,
				rec,
				pThreadParams->ProcNumber);*/
			}
			
			if(fProc0)	// wt_progress messages only sent from the processor 0 thread.
				Progress(++nProgCur * 100 / nProgMax);
		} // Patterns
	} // windows
	return(0);
	
}

//******************************************************************************
// Function name	: GetPhysicalMemorySize
// Description	    : Returns the amount of physical memory installed in the system
//                    as detected by Windows NT.
// Return type		: DWORDLONG - Physical memory in bytes.
//******************************************************************************
DWORDLONG CXModuleMemory::GetPhysicalMemorySize()
{
	MEMORYSTATUSEX ms;
	DWORDLONG      nMem;
	
	SafeGlobalMemoryStatusEx(&ms);
	nMem = ms.ullTotalPhys & 0xFFFFFFFFFFF00000uI64;	// Truncate to an even MB.
	
	if(ms.ullTotalPhys & 0xFFFFF)				// Round up.
		nMem += 0x100000;
	
	return nMem;
}


//******************************************************************************
// Function name	: GetLargestVirtualBufferSize
// Description	    : Determines the largest block of contiguous virtual memory.
//                    Will not be accurate if available physical memory is
//                    less than the largest contiguous block, but we won't need
//                    more than that.
// Return type		: SIZE_T - The size of the block in bytes.
//******************************************************************************
SIZE_T CXModuleMemory::GetLargestVirtualBufferSize()
{
	MEMORYSTATUS ms;
	GlobalMemoryStatus(&ms);
	
	SIZE_T dwSize = ms.dwAvailVirtual & ~(SIZE_T)0xFFFFF;	// Round down to nearest MB.
	LPVOID pMem   = NULL;
	
	// On IA-64 systems this value is HUGE, and we really only need to check
	// if a contiguous virtual buffer the size of available physical memory
	// is present.
	if(dwSize > ms.dwAvailPhys)
		dwSize = ms.dwAvailPhys & ~(SIZE_T)0xFFFFF;	// Round down to nearest MB.
	
	// This routine fudges the number by 16MB in case.
	while(dwSize > 0x1100000 && (pMem = VirtualAlloc(NULL,dwSize,MEM_RESERVE,PAGE_READWRITE)) == NULL)
		dwSize -= 0x100000;
	
	if(pMem)
		VirtualFree(pMem,0,MEM_RELEASE);
	
	dwSize -= 0x1000000;
	
	return dwSize;
}



//******************************************************************************
// Function name	: EstimateAvailableMemory
// Description	    : Reads the MemorySize, Force and Reserved parameters
//                    to determine the amount of memory to be tested.
// Return type		: SIZE_T - Test memory size in bytes.
//******************************************************************************
SIZE_T CXModuleMemory::EstimateAvailableMemory(SIZE_T Request)
{
	MEMORYSTATUSEX ms;
	SIZE_T         Available,Virtual;
	DWORD          Reserved;
	
	ReportDebug(8,L"Requested Physical Memory = %I64Xh (%I64uMB)",(QWORD)Request,(QWORD)Request >> 20);
	
	SafeGlobalMemoryStatusEx(&ms);
	// Cast is OK because the largest contiguous virtual memory we can get will always fit a SIZE_T.
	Available = (SIZE_T)ms.ullAvailPhys;
	ReportDebug(8,L"Available Physical Memory = %I64Xh (%I64uMB)",(QWORD)Available,(QWORD)Available >> 20);
	
	Virtual = GetLargestVirtualBufferSize();
	ReportDebug(8,L"Contiguous Virtual Memory = %I64Xh (%I64uMB)",(QWORD)Virtual,(QWORD)Virtual >> 20);
	if((Reserved =GetCfgUint(L"Reserved",0)) == 0)
		Reserved = 0x200000;	// 2MB by default.
	ReportDebug(9,L"Reserved Physical Memory = %lXh (%luMB)",Reserved,Reserved >> 20);
	
	// Compute lesser of Request, Available less Reserved, and Virtual.
	// Cast is OK because the largest contiguous virtual memory we can get will always fit a SIZE_T.
	if(Available > Reserved)
		Available -= Reserved;
	
	if(Virtual < Available)
		Available = Virtual;
	
	if(Request < Available)
		Available = Request;
	
	if(Available < 0x100000)
		Available = 0x100000;		// Always at least 1MB.
	
	Available &= ~(SIZE_T)0xFFFFF;	// round down to nearest MB.
	
	ReportDebug(8,L"Estimated Test Memory = %I64Xh (%I64uMB)",(QWORD)Available,(QWORD)Available >> 20);
	
	return Available;
}


//******************************************************************************
// Function name : AllocateMemory
// Description   : Allocates the requested memory size.  If Windows NT, it then
//                 increases the minimum and maximum working set size of the
//                 test process by this amount and locks the buffer into memory.
// Return type   : LPVOID              - pointer to allocated memory.
// Argument      : PSIZE_T pMemorySize - [in]How much memory to allocate per thread.
//                                       [out]total memory allocated.
// Argument      : bool fForce         - TRUE if memory can't be downsized.
// Argument      : bool fNoCache       - TRUE if memory should be allocated
//                                       with the PAGE_NOCACHE attribute.
//******************************************************************************
LPVOID CXModuleMemory::AllocateMemory(PSIZE_T pMemorySize,bool fForce,bool fNoCache,DWORD nThreads)
{
	ASSERT(*pMemorySize <= (SIZE_T)-1 / nThreads);
	ASSERT(nThreads > 0);
	ASSERT(pMemorySize != NULL);
	
	SIZE_T OrgSize = *pMemorySize * nThreads;
	LPVOID pMem;
	SIZE_T AdjSize;
	BYTE bAbortStatus;
	
	MEMORYSTATUSEX ms;
	
	SafeGlobalMemoryStatusEx(&ms);
	ReportDebug(2,
		L"Memory Load: %ld%%\n"
		L"Total Physical: %I64Xh bytes\n"
		L"Available Physical: %I64Xh bytes\n"
		L"Total Page File %I64Xh bytes\n"
		L"Available Page File: %I64Xh bytes\n"
		L"Total Virtual: %I64Xh bytes\n"
		L"Available Virtual: %I64Xh bytes\n"
		L"Available Extended Virtual: %I64Xh bytes\n",
		ms.dwMemoryLoad,
		ms.ullTotalPhys,
		ms.ullAvailPhys,
		ms.ullTotalPageFile,
		ms.ullAvailPageFile,
		ms.ullTotalVirtual,
		ms.ullAvailVirtual,
		ms.ullAvailExtendedVirtual);
	
	// This function needs to query and allocate memory, so all
	// memory tests (and other modules that use a lot of memory)
	// need to use this mutex to lock the query/allocate process.
	while(::WaitForSingleObject(g_hMemoryMutex,5000) == WAIT_TIMEOUT)
	{
		//check for abort status
		bAbortStatus = CheckAbort(0);
		if(bAbortStatus == TRUE)
			throw((int)99);
	}
	
	if(fForce)
	{
		// Allocate the exact amount of memory needed.
		if((pMem = VirtualAlloc(NULL,OrgSize,MEM_COMMIT,fNoCache ? PAGE_READWRITE | PAGE_NOCACHE : PAGE_READWRITE)) == NULL)
		{
			errVirtualAllocQ(GetLastError(),OrgSize);
			goto error;
		}
		
		AdjSize = OrgSize;
	}
	else
	{
		// Adjust the memory amount requested based on available memory and virtual address space available.
		AdjSize = EstimateAvailableMemory(OrgSize);
		
		if((pMem = VirtualAlloc(NULL,AdjSize,MEM_COMMIT,fNoCache ? PAGE_READWRITE | PAGE_NOCACHE : PAGE_READWRITE)) == NULL)
		{
			errVirtualAllocQ(GetLastError(),AdjSize);
			goto error;
		}
		
	}
	
	VERIFY(ReleaseMutex(g_hMemoryMutex));
	
	
	ReportDebug(1,L"Test Memory Size = %I64Xh (%I64uMB)",(QWORD)AdjSize,(QWORD)AdjSize >> 20);
	
	*pMemorySize = AdjSize / nThreads;
	
	AbortMemPtr = pMem;
	return pMem;
	
error:
	VERIFY(ReleaseMutex(g_hMemoryMutex));
	// exit
	throw CXmtaException(99,NULL);
	//	return NULL; // not reached
}


//******************************************************************************
// Function name	: FreeMemory
// Description	    : Release the test memory buffer.  If Windows NT, reduce the
//                    process working set size by the MemorySize amount.
// Return type		: void
// Argument         : LPVOID pMem - The starting address of the buffer to release.
// Argument         : SIZE_T MemorySize - Needed only to report an error.
//******************************************************************************
void CXModuleMemory::FreeMemory(LPVOID pMem,SIZE_T MemorySize)
{
	if(!VirtualFree(pMem,0,MEM_RELEASE))
		errVirtualFreeQ(GetLastError(),MemorySize);
	AbortMemPtr = NULL;
}


//******************************************************************************
// Function names   : seed, random
// Description	    : Pair of functions to seed and generate random DWORDs.
//                    Seeding the generator a generating a list of numbers, then
//                    reseeding with the same value and generating the list again
//                    will produce the same list of numbers.  This function is
//                    thread-safe.
// Return type		: DWORD - a 32-bit random number.
// Argument         : seed  - a 32-bit starting point for the generator.
//******************************************************************************


void CXModuleMemory::seed(DWORD seed)
{
	holdrand = seed;
}

DWORD CXModuleMemory::random()
{
	DWORD ret;
	ret  = (holdrand = holdrand * 214013L + 2531011L) >> 16;
	ret |= (holdrand = holdrand * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}


//******************************************************************************
// Function names	: SetRandomSeed, GetRandomSeed, ReSeed
// Description	    : These functions manage the random seed for a particular
//                    test instance.  SetRandomSeed should be called once per
//                    test to initialize the generator and record the initial
//                    seed for the test.  A test can then call ReSeed as many
//                    times as needed to regenerate a list of random numbers.
//                    If a test fails, GetRandomSeed can report the seed to the
//                    user.  A parameter can be set to force a failing test to
//                    execute with the same seed with which it failed.
// Return type		: DWORD - The test seed.
//******************************************************************************

void CXModuleMemory::SetRandomSeed()
{
	ASSERT(GlobalSeed == 0);	// Call only once for process.
	
	// RandomSeed parameter can be used to force the same seed to be used
	// as reported by an error message.
	if((GlobalSeed = GetCfgUint(L"RandomSeed",0))== 0)
		GlobalSeed = (DWORD)time(NULL);
	
	seed(GlobalSeed);
	ReportDebug(1,L"RandomSeed = %Xh",GlobalSeed);
}

DWORD CXModuleMemory::GetRandomSeed()
{
	return GlobalSeed;
}

// offset is used to get a new seed from the original seed.
void CXModuleMemory::ReSeed(int offset)
{
	ASSERT(GlobalSeed != 0);	// Call SetRandomSeed() first.
	seed(GlobalSeed + (DWORD)offset);
}


//******************************************************************************
// Function name	: ParameterMemorySize
// Description	    : Reads the MemorySize parameter and returns its value
//                    rounded down to the nearest MB or 1MB, whichever is greater.
// Return type		: SIZE_T - greater of 0x100000 or MemorySizeMB in bytes.
//******************************************************************************
SIZE_T CXModuleMemory::ParameterMemorySize()
{
	DWORD     dwMemMB;
	DWORDLONG Mem;
	
	if((dwMemMB = GetCfgUint(L"MemorySizeMB",0)) == 0)
	{
		dwMemMB = (DWORD)(GetPhysicalMemorySize() >> 20);
		
		ReportWarning(
			L"MemorySizeMB parameter not found.\n"
			L"Defaulting to detected memory size of %luMB.",
			dwMemMB);
	}
	
	if(dwMemMB == 0)
		dwMemMB = 1;		// Always at least 1MB.
	
	Mem = (DWORDLONG)dwMemMB << 20;
	
	if(Mem > (SIZE_T)-1)
	{
		MEMORYSTATUS ms;
		GlobalMemoryStatus(&ms);
		Mem = GetLargestVirtualBufferSize();
		ReportWarning(
			L"MemorySizeMB parameter too large for this version of NT.\n"
			L"Defaulting to largest contiguous virtual buffer size of %I64uMB.",(QWORD)Mem >> 20);
	}
	
	ReportDebug(1,L"MemorySizeMB = %luMB (%I64Xh)",dwMemMB,Mem);
	return (SIZE_T)Mem;
}


//******************************************************************************
// Function name	: ParameterCacheSize
// Description	    : Returns the value of the CacheSize parameter rounded down
//                    to the nearest power of two.  If not found, it returns
//                    the L2 cache of the processor if it can be found, or 512KB
//                    if it can't be found.
// Return type		: DWORD - The cache size in bytes.
//******************************************************************************
DWORD CXModuleMemory::ParameterCacheSize()
{
	DWORD dwCache;
	
	// Read the CacheSize parameter.
	if((dwCache = GetCfgUint(L"CacheSize",0)) == 0)
	{
		// if no parameter, check the processor for cache (CPUID) or
		// use 512KB if the processor cache cannot be determined.
		if(!GetCpuCacheInfo(&dwCache))
			dwCache = 0x80000;
		
		ReportWarning(
			L"CacheSize parameter not found.\n"
			L"Defaulting to a cache size of %Xh (%uKB).",
			dwCache,dwCache >> 10);
	}
	else
	{
		// Round down to nearest power of two.
		if(dwCache > 0)
		{
			for(DWORD tmp = 0xFFFFFFFF; (~tmp & dwCache) == 0; tmp >>= 1)
				;
			dwCache &= ~tmp;
		}
	}
	
	ReportDebug(1,L"CacheSize = %Xh (%uKB)",dwCache,dwCache >> 10);
	return dwCache;
}


//******************************************************************************
// Function name	: ParameterSwitch
// Description	    : Reads the value of the named Boolean parameter.
// Return type		: bool - TRUE if the named parameter is present and non-zero.
// Argument         : LPCTSTR szName - name of the parameter.
//******************************************************************************
bool CXModuleMemory::ParameterSwitch(LPCTSTR szName)
{
	bool result;
	result = GetCfgBoolean(szName);
	ReportDebug(1,L"%s = %d",szName,result);
	return result;
}


//******************************************************************************
// Function name	: GetCpuCacheInfo
// Description	    : Calls CPUID.  If it supports reporting cache size info,
//                    look for an L2 cache and report its size.
//                    See the CPUID description in the Intel Instruction Set Reference.
//                    See the Processor Specification updates (Pentium III Xeon, etc.)
//                    for additional cache size tokens definitions (0x82,0x84,0x85 so far).
// Return type		: bool - TRUE if CPUID supports cache information reporting.
// Argument         : LPDWORD pdwSize - points to size of L2 cache if TRUE is returned.
//******************************************************************************
#define EFLAGS_ID (1<<21)

bool CXModuleMemory::GetCpuCacheInfo(LPDWORD pdwSize)
{
	DWORD regs[4];
	int   loops;
	
	*pdwSize = 0;
	
	GetCpuId(0,regs);	// Cmd zero returns highest command supported in EAX.
	if(regs[0] < 2)		// index 0=EAX 1=EBX, etc.  Must support 2 for cache types.
		return FALSE;
	
	loops = GetCpuId(2,regs);	// Cmd=2, get cache info.  AL (retval) is number of
	// times GetCpuId must be called to get all info.
	
	while(loops--)
	{
		DWORD type;
		
		// Individual bytes of EAX,EBX,ECX,EDX (regs[0] thru [4]) are cache descriptors.
		for(int i = 0; i < 4; i++)
		{
			// The reg is not valid if bit 31 is not a zero.
			if((regs[i] & (1<<31)) == 0)
			{
				// shift through the four bytes in each reg.
				for(int j = 0; j < 4; j++)
				{
					type = regs[i] & 0xFF;
					switch(type)
					{
					case 0x41:	// 4-way set associative, 128KB L2 cache
					case 0x81:	// not documented, assume 8-way 128KB
						*pdwSize = 0x020000;	// 128KB
						goto done;
					case 0x42:	// 4-way
					case 0x82:	// 8-way
						*pdwSize = 0x040000;	// 256KB
						goto done;
					case 0x43:	// 4-way
					case 0x83:	// not documented, assume 8-way 512KB
						*pdwSize = 0x080000;	// 512KB
						goto done;
					case 0x44:	// 4-way
					case 0x84:	// 8-way
						*pdwSize = 0x100000;	//   1MB
						goto done;
					case 0x45:	// 4-way
					case 0x85:	// 8-way
						*pdwSize = 0x200000;	//   2MB
						goto done;
					}
					
					regs[i] >>= 8;
				}
			}
		}
		
		GetCpuId(2,regs);
	}
	
done:
	return TRUE;
}

//******************************************************************************
// Function name	: GetCpuId
// Description	    : Executes the x86 CPUID instruction with EAX=cmd.
//                    Returns EAX,EBX,ECX,EDX in the regs array.
//                    See the CPUID description in the Intel Instruction Set Reference.
// Return type		: int - The value in AL after CPUID is executed.
//******************************************************************************
int CXModuleMemory::GetCpuId(DWORD cmd,DWORD regs[4])
{
	int retval = 0;
	
#ifdef _WIN64
	cmd;
	regs[0]=0;
#else // _WIN32
	__asm {
		mov eax,cmd
			cpuid
			push ebx
			mov ebx,regs
			mov 0[ebx],eax				// Save EAX,EBX,ECX,EDX in regs array.
			mov byte ptr [retval],al	// return the value in AL.
			pop eax
			mov 4[ebx],eax
			mov 8[ebx],ecx
			mov 12[ebx],edx
	}
#endif // _WIN64
	
	return retval;
}


//******************************************************************************
// Function name	: MMXCheck
// Description	    : Checks for the MMX feature being present
//
// Return type		: BOOL
//******************************************************************************
bool CXModuleMemory::MMXCheck()
{
	
	BYTE MMX;
	
	MMX=0;
	_asm
	{
		push eax
			push edx
			mov		eax,1
			cpuid
			test	edx, 0x800000
			jnz		yesmmx
			jmp		end
yesmmx:	mov		BYTE PTR MMX,1
end:	pop edx
		pop	eax
	}
	return MMX;
	
}


//******************************************************************************
// Function name	: InitAddressConversions
// Description	    : Loads the WinMTA helper DLL and retrieves the function
//                    to resolve virtual addresses into physical addresses.
// Return type		: BOOL
//******************************************************************************
bool CXModuleMemory::InitAddressConversions()
{
	static init = FALSE;
	
	if(init)
		return TRUE;
	
	
	return init;
}

/******************************************************************************
* Function: SafeGlobalMemoryStatusEx
* Purpose:  Safely handles a call to GlobalMemoryStatusEx() on Windows systems
*           that don't support it by filling out the structure on those systems
*           with information from GlobalMemoryStatus().
* Returns:  void
*             
* Argument: MEMORYSTATUSEX* p
*             [in]A pointer to a MEMORYSTATUSEX structure.
*             [out]A pointer to a filled out MEMORYSTATUSEX structure.
******************************************************************************/
bool CXModuleMemory::SafeGlobalMemoryStatusEx(LPMEMORYSTATUSEX p)
{
	
	MEMORYSTATUS ms;
	
	ms.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&ms);
	
	p->dwLength = sizeof(MEMORYSTATUSEX);
	p->dwMemoryLoad = ms.dwMemoryLoad;
	p->ullTotalPhys = ms.dwTotalPhys;
	p->ullAvailPhys = ms.dwAvailPhys;
	p->ullTotalPageFile = ms.dwTotalPageFile;
	p->ullAvailPageFile = ms.dwAvailPageFile;
	p->ullTotalVirtual = ms.dwTotalVirtual;
	p->ullAvailVirtual = ms.dwAvailVirtual;
	p->ullAvailExtendedVirtual = 0;
	
	ASSERT(ms.dwTotalPhys != 0);
	
	return TRUE;
}



//******************************************************************************
// Function name    : DecodeFailingLocation
// Description      : Decodes the virtual address and failing data pattern to a 
//                    to a location on the board and reports the error
// Return type      : void
//******************************************************************************
void CXModuleMemory::DecodeFailingLocation(WORD ECode,LPDWORD dwMemoryAddress, QWORD qwExp, QWORD qwRec, BYTE Size, CHAR * MsgPtr)
{
	DWORD qwAddress;
	BYTE  bFirstBadBit; // first bad bit
	BYTE  bLastBadBit;  // last bad bit
	QWORD qwBadBits;
	BYTE  bBadBitCount;
	QWORD qwFirstBadAddress; //byte address of the first bad bit
	QWORD qwLastBadAddress; // byte address of the last bad bit
	BYTE  x;
	WCHAR DeviceStr[256];
	WCHAR DetailStr[256];
	DWORD Ecode;
	
	//Look up physical address
	qwAddress = MmGetPhysicalAddress((PVOID)dwMemoryAddress);
	
	//Mask for the size
	if(Size == 1)
	{
		qwRec = 0xFF & qwRec;
		qwExp = 0xFF & qwExp;
	}
	if(Size == 2)
	{
		qwRec = 0xFFFF & qwRec;
		qwExp = 0xFFFF & qwExp;
	}
	if(Size == 4)
	{
		qwRec = 0xFFFFFFFF & qwRec;
		qwExp = 0xFFFFFFFF & qwExp;
	}
	
	// Compare exp and rec. If the same soft read error
	// Generate a special error message for this.
	if(qwRec == qwExp)
	{
		if(Size == 1)
			ReportError(0x30,L"Address 0x%8.8x, Pattern 0x%2.2X, Failing pattern can not be determined. Error in NV2A or processor",qwAddress, (WORD)qwRec);
		if(Size == 2)
			ReportError(0x30,L"Address 0x%8.8x, Pattern 0x%4.4X, Failing pattern can not be determined. Error in NV2A or processor",qwAddress, (WORD)qwRec);
		if(Size == 4)
			ReportError(0x30,L"Address 0x%8.8x, Pattern 0x%8.8X, Failing pattern can not be determined. Error in NV2A or processor",qwAddress, (DWORD)qwRec);
		if(Size == 8)
			ReportError(0x30,L"Address 0x%8.8x, Pattern 0x%016I64X, Failing pattern can not be determined. Error in NV2A or processor",qwAddress, (QWORD)qwRec);
		return;
	}
	// generate a error message about the details
	if(Size == 1)
		wsprintf(DetailStr,L"Address 0x%8.8x, Rec 0x%2.2X Exp=0x%2.2X,",qwAddress, (WORD)qwRec, (WORD)qwExp);
	if(Size == 2)
		wsprintf(DetailStr,L"Address 0x%8.8x, Rec 0x%4.4X Exp=0x%4.4X,",qwAddress, (WORD)qwRec, (WORD)qwExp);
	if(Size == 4)
		wsprintf(DetailStr,L"Address 0x%8.8x, Rec 0x%8.8X Exp=0x%8.8X,",qwAddress, (DWORD)qwRec, (DWORD)qwExp);
	if(Size == 8)
		wsprintf(DetailStr,L"Address 0x%8.8x, Rec 0x%016I64X Exp=0x%016I64X,",qwAddress, (QWORD)qwRec, (QWORD)qwExp);
	// Now work on the failing device details
	// Compare exp and rec see how many bits are wrong.
	qwBadBits = qwRec ^ qwExp;
	// find the first bit that is bad
	for(x=0;x<64;x++)
	{
		if(((qwBadBits >>x) & 0x1) == 1)
		{
			// record the first bad bit and it's address
			bFirstBadBit = x;
			qwFirstBadAddress = x/8 + qwAddress;
			break;
		}
	}
	//find the last bad bit and the number of bad bits
	bBadBitCount = 0;
	for(x=0;x<64;x++)
	{
		if(((qwBadBits >>x) & 0x1) == 1)
		{	
			// count the bad bits
			bBadBitCount++;
			// record the last bad bit and it's address
			bLastBadBit = x;
			qwLastBadAddress = x/8 + qwAddress;
		}
	}
	ReportDebug(2,L"\nBit count %d \nFirst bit %d\nLast bit %d \nFirst address 0x%016I64X \nLast address 0x%016I64X\n",
		bBadBitCount,
		bFirstBadBit,
		bLastBadBit,
		qwFirstBadAddress,
		qwLastBadAddress);

	//Single bit error decode the device Multibit error bits on same device 
	if(((qwFirstBadAddress/8) - (qwLastBadAddress/8) == 0))
	{
		// error is in bank A Top, MSB 0
		
		switch (((qwAddress >> 4) & 0x3))
		{
		case 0:
			if(bBadBitCount == 1)
			{
				Ecode = 0x32;
				wcscpy(DeviceStr,L"Error is suspected on device U6N1");
			}
			else
			{
				Ecode = 0x33;
				wcscpy(DeviceStr,L"Error is suspected on device NV2A or U6N1");
			}
			break;
		case 1:
			if(bBadBitCount == 1)
			{
				Ecode = 0x34;
				wcscpy(DeviceStr,L"Error is suspected on device U6D1");
			}
			else
			{
				Ecode = 0x35;
				wcscpy(DeviceStr,L"Error is suspected on device NV2A or U6D1");
			}
			break;
		case 2:
			if(bBadBitCount == 1)
			{
				Ecode = 0x36;
				wcscpy(DeviceStr,L"Error is suspected on device U5F1");
			}
			else
			{
				Ecode = 0x37;
				wcscpy(DeviceStr,L"Error is suspected on device NV2A or U5F1");
			}
			break;
		case 3:
			if(bBadBitCount == 1)
			{
				Ecode = 0x38;
				wcscpy(DeviceStr,L"Error is suspected on device U3T1");
			}
			else
			{
				Ecode = 0x39;
				wcscpy(DeviceStr,L"Error is suspected on device NV2A or U3T1");
			}
			break;
		default:
			ReportError(31,L"Code error in memory test");
		}
	}
	//Multibit error across devices
	if((qwFirstBadAddress/8) - (qwLastBadAddress/8) != 0)
	{
		wcscpy(DeviceStr, L"Error is on multiple memory devices, Suspected part is NV2A");
	}
	ReportError(32,L"%s %s",DetailStr, DeviceStr);
	// check for abort
	BYTE bAbortStatus;
	bAbortStatus = CheckAbort(L"Error message report");
	if(bAbortStatus == TRUE)
	{
		if(AbortMemPtr != NULL)
		{
			FreeMemory(AbortMemPtr,0);
		}
		throw((int)99);
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xrtc\DataBuffer.h ===
class CDataBuffer //: public CObject  
{
public:
	void RotateDown();
	void RotateUp();
	void FillRandom(UINT *uiRandScratch);
	void FillLinear();
	DWORD random(UINT *pScratch);
	UCHAR operator[](int nIndex) {return m_pData[m_uBase + nIndex];}
	operator PUCHAR () {return &m_pData[m_uBase];}
	CDataBuffer(ULONG uSize);
	virtual ~CDataBuffer();

protected:
	PUCHAR m_pData;
	ULONG m_uSize;
	ULONG m_uBase;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xrtc\DataBuffer.cpp ===
#include "..\stdafx.h"
#include "..\testobj.h"
//#include "WinRTC.h"
#include "DataBuffer.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataBuffer::CDataBuffer(ULONG uSize):m_uSize(uSize),m_uBase(0)
{
	//
	// Create a buffer of twice the required size so we can
	// do the Rotate Up/Down manipulations
	//
	m_pData = new UCHAR[2 * uSize];
}

CDataBuffer::~CDataBuffer()
{
	delete m_pData;
}

void CDataBuffer::FillLinear()
{
	for(ULONG i = 0; i < m_uSize; i++)
		m_pData[m_uSize + i] = m_pData[i] = (UCHAR)i;
}

void CDataBuffer::FillRandom(UINT *uiRandScratch)
{
	for(ULONG i = 0; i < m_uSize; i++)
		m_pData[m_uSize + i] = m_pData[i] = (UCHAR)random(uiRandScratch);
}

void CDataBuffer::RotateUp()
{
	if(++m_uBase == m_uSize)
		m_uBase = 0;
}

void CDataBuffer::RotateDown()
{
	if(m_uBase == 0)
		m_uBase = m_uSize;
	m_uBase--;
}

DWORD CDataBuffer::random(UINT *pScratch)
{
	DWORD ret;
	ret  = (*pScratch = *pScratch * 214013L + 2531011L) >> 16;
	ret |= (*pScratch = *pScratch * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xmemory\stress.h ===
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-1999 Intel Corp. All rights reserved.
//
#pragma once
class stress
{
public:
	stress(SIZE_T block_size, CXModuleMemory * hCXMem);
	~stress();
	LPBYTE StressRead      (LPBYTE pSrcBuf,LPBYTE pDestBuf);
	void   StressWrite     (LPBYTE pSrcBuf,LPBYTE pDestBuf);
	void   StressWriteDword(LPBYTE pSrcBuf,LPBYTE pDestBuf);
	LPBYTE StressReadDword (LPBYTE pSrcBuf,LPBYTE pDestBuf);
	void   StressStrideWrite(DWORD index,DWORD stride,LPBYTE pSrcBuf,LPBYTE pDestBuf);
	LPBYTE StressStrideRead (DWORD index,DWORD stride,LPBYTE pSrcBuf,LPBYTE pDestBuf);
	void   build_read_log();
	void   build_write_log();
	SIZE_T get_log_size() const {return m_nLogSize;}
	SIZE_T get_test_size() const {return m_nTestSize;}

	struct log 
	{
		SIZE_T address;
		SIZE_T size;
	};




	const log* get_read_log() const {return m_pReadLog;}
	const log* get_write_log() const {return m_pWriteLog;}

private:
	CXModuleMemory * hCXMem;
	void build_log(log* pLog);
	bool get_location(SIZE_T* pAddr,SIZE_T* pSize);

	// The m_pdwUsed array is initialized by InitStress.

	// Checks if an address is marked as used in the bitmapped array.
	inline bool is_used(SIZE_T addr)
	{
		return (m_pdwUsed[addr / 32] & (1 << (addr % 32))) != 0;
	}

	// Marks an address as used in the bitmapped array.
	inline void mark_used(SIZE_T addr)
	{
		m_pdwUsed[addr / 32] |= 1 << (addr % 32);
	}

	SIZE_T  m_nTestSize;
	SIZE_T  m_nMaxTransferSize;
	SIZE_T  m_nLogSize;
	LPDWORD m_pdwUsed;

	log* m_pReadLog;
	log* m_pWriteLog;

	// These are used by the get_location algorithm to speed it up.
	// They remember the highest and lowest addresses outside of which
	// all the addresses are used.
	/*__declspec(thread) static*/ SIZE_T m_curbot,m_curtop;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xrtc\xrtc.cpp ===
///////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000-2001 Intel Corp. All rights reserved.
//
// Title:  XRTC
//
// History:	
// 
// 11/07/00 V1.00 PHM Original release 
//
///////////////////////////////////////////////////////////////////////////////////


#include "..\stdafx.h"
#include "..\testobj.h"
#include "databuffer.h"
#include "xrtc.h"
#include "rtcioctl.h"

IMPLEMENT_MODULELOCKED (CXModuleRTC);

//const UCHAR CXModuleRTC::DateTimeRegs[] = 
//{RTC_SECONDS,RTC_MINUTES,RTC_HOURS,RTC_DAY,RTC_DATE,RTC_MONTH,RTC_YEAR};

//////////////////////////////////////////////////////////////////////////////////
// Function name	: InitializeParameters
// Description	    : Tries to see if the configuration parameters were defined
//					  or not.
// Return type		: bool 
//////////////////////////////////////////////////////////////////////////////////
bool CXModuleRTC::InitializeParameters ()
{
	if (!CTestObj::InitializeParameters ())
		return false;

//	Initialize();

	if ((iStart = GetCfgInt(_T("start"), -1)) == -1)
		err_BadParameter(L"Start");
		
	if ((iLength = GetCfgInt(_T("length"), -1)) == -1)
		err_BadParameter(L"Length");
		
	if ((iNumPatterns = GetCfgInt(_T("numpatterns"), 0)) == 0)
		err_BadParameter(L"NumPatterns");

	if ((iPpm = GetCfgInt(_T("ppm"), -1)) == -1)
		err_BadParameter(L"Ppm");

	if ((iSeconds = GetCfgInt(_T("seconds"), -1)) == -1)
		err_BadParameter(L"Seconds");

	// debug
//	ReportDebug(BIT0,_T("End of InitialzieParameters.\n"));

	return true;

} // end bool CXModuleRTC::InitializeParameters ()


//////////////////////////////////////////////////////////////////////////////////
// Function name	: ReadRam
// Description	    : Reads the contents of the RTC RAM
// Input			: uStart - start of the RAM. Usually this is 0x0E (14) as the
//					           first 14 bytes of RTC RAM contain the registers 
//							   for date, time and control registers
//					: uLength - Length of the RTC RAM. This could be 128 or 256
//							    bytes
//					: pData - buffer that will read the data from the RTC RAM
// Return type		: bool 
//////////////////////////////////////////////////////////////////////////////////
bool CXModuleRTC::ReadRam(ULONG uStart, ULONG uLength, PUCHAR pData)
{

	ULONG uIndex;
	PUCHAR pVerifyData = new UCHAR[iLength];
	TCHAR StrOutput[512];
	//
	// Verify for a valid range
	//
	if((uLength > RTC_RAM_LEN) || (uStart < RTC_RAM_START)|| (uStart > RTC_RAM_END)
		|| ((uStart + uLength) > (RTC_RAM_END + 1)))
	{
		err_InvalidRange();
		return false;
	}
	
	// debug first 14 bytes (0-13) in CMOS give info about time, date and Status Regs A-D
	/*uStart = 0;
	for(uIndex = 0; uIndex < 14; uIndex++)
	{
		ReportDebug(BIT0,_T("uStart+uIndex = %d\n"), uStart+uIndex);
		pData[uIndex] = RtcHwrReadReg((UCHAR)(uStart + uIndex));
	}
*/
	
	for(uIndex = 0; uIndex < uLength; uIndex++)
		pData[uIndex] = RtcHwrReadReg((UCHAR)(uStart + uIndex));

	// debug
	for(uIndex = 0; uIndex < uLength; uIndex++)
	{
		pVerifyData[uIndex] = RtcHwrReadReg((UCHAR)(uStart + uIndex));
		if(pVerifyData[uIndex] != pData[uIndex])
		{
			_stprintf(StrOutput, _T("error generated so there'll be halt on error.\n"));
			OutputDebugString(StrOutput);
			err_MismatchedRead(uIndex+uStart, pVerifyData[uIndex], pData[uIndex]);
			return false;
		}
	}


	// debug
/*	for(uIndex = 0; uIndex < 14; uIndex++)	
		ReportDebug(BIT0,_T("pData[%0X] = %d\n"), uIndex, pData[uIndex]);
*/
	return true;

} // end void CXModuleRTC::ReadRam(ULONG uStart, ULONG uLength, PUCHAR pData)



//////////////////////////////////////////////////////////////////////////////////
// Function name	: AtomicWriteReadRam
// Description	    : Reads and writes the contents of the RTC RAM
// Input			: uStart - start of the RAM. Usually this is 0x0E (14) as the
//					           first 14 bytes of RTC RAM contain the registers 
//							   for date, time and control registers
//					: uLength - Length of the RTC RAM. This could be 128 or 256
//							    bytes
//					: pWriteData - buffer that contains the data to be written to
//								  the RAM
//					: pReadData - buffer that will read the data from the RTC RAM
// Return type		: void 
//////////////////////////////////////////////////////////////////////////////////
void CXModuleRTC::AtomicWriteReadRam(ULONG uStart, ULONG uLength, PUCHAR pWriteData, PUCHAR pReadData)
{
	//
	// Verify for a valid range
	//
	if((uLength > RTC_RAM_LEN) || (uStart < RTC_RAM_START)|| (uStart > RTC_RAM_END)
		|| ((uStart + uLength) > (RTC_RAM_END + 1)))
	{
		err_InvalidRange();
		return;
	}

	RtcHwrAtomicWriteReadReg(pWriteData, pReadData, uStart, uLength);

} // end void CXModuleRTC::AtomicWriteReadRam(ULONG uStart, ...)



//////////////////////////////////////////////////////////////////////////////////
// Function name	: WriteRam
// Description	    : writes the contents to the RTC RAM
// Input			: uStart - start of the RAM. Usually this is 0x0E (14) as the
//					           first 14 bytes of RTC RAM contain the registers 
//							   for date, time and control registers
//					: uLength - Length of the RTC RAM. This could be 128 or 256
//							    bytes
//					: pData - buffer that contains the data to be written to
//							  the RAM
// Return type		: bool 
//////////////////////////////////////////////////////////////////////////////////
bool CXModuleRTC::WriteRam(ULONG uStart, ULONG uLength, PUCHAR pData)
{
	ULONG uIndex;
	PUCHAR pVerifyData = new UCHAR[iLength];
	TCHAR StrOutput[512];
	
	//
	// Verify for a valid range
	//
	if((uLength > RTC_RAM_LEN) || (uStart < RTC_RAM_START)|| (uStart > RTC_RAM_END)
		|| ((uStart + uLength) > (RTC_RAM_END + 1)))
	{
		err_InvalidRange();
		return false;
	}

	for(uIndex = 0; uIndex < uLength; uIndex++)
		RtcHwrWriteReg((UCHAR)(uStart + uIndex), pData[uIndex]);

	// debug
	for(uIndex = 0; uIndex < uLength; uIndex++)
	{
		pVerifyData[uIndex] = RtcHwrReadReg((UCHAR)(uStart + uIndex));
		if(pVerifyData[uIndex] != pData[uIndex])
		{
			_stprintf(StrOutput, _T("error generated so there'll be halt on error.\n"));
			OutputDebugString(StrOutput);
			err_MismatchedWrite(uIndex+uStart, pVerifyData[uIndex], pData[uIndex]);
			return false;
		}
	}

	return true;
} // end void CXModuleRTC::(ULONG uStart, ULONG uLength, PUCHAR pData)



//////////////////////////////////////////////////////////////////////////////////
// Function name	: RtcHwrReadReg
// Description	    : Reads the contents of the RTC RAM
// Return type		: uchar 
//////////////////////////////////////////////////////////////////////////////////
UCHAR CXModuleRTC::RtcHwrReadReg(IN UCHAR Address)
{
	__asm
	{
		;Stop interrupts to avoid any potential conflict
		cli
		
		;Point to the address
		mov	al,Address
		out	RTC_ADDR_PORT,al

		;Get the data & leave returned value at al
		in	al,RTC_DATA_PORT

		;Safe to allow interrupts now
		sti
	}

} // end UCHAR CXModuleRTC::RtcHwrReadReg(UCHAR Address)



//////////////////////////////////////////////////////////////////////////////////
// Function name	: RtcHwrAtomicWriteReadReg
// Description	    : Reads and writes the contents from/to the RTC RAM
// Return type		: void 
//////////////////////////////////////////////////////////////////////////////////
void CXModuleRTC::RtcHwrAtomicWriteReadReg(PUCHAR pWriteData, PUCHAR pReadData, ULONG uStart, ULONG uLength)
{
		__asm
	{
		;Stop interrupts to make operation atomic
		cli

		;Init write counter & pointers
		mov ecx,uLength
		mov ebx,uStart
		mov edx,pWriteData

WriteLoop:
		;Set-up address
		mov	al,bl
		out	RTC_ADDR_PORT,al

		;Set-up data
		mov	al,[edx]
		out	RTC_DATA_PORT,al

		;Point to next
		inc ebx
		inc edx
		loop WriteLoop

		;Init read counter & pointers
		mov ecx,uLength
		mov ebx,uStart
		mov edx,pReadData

ReadLoop:
		;Set-up address
		mov	al,bl
		out	RTC_ADDR_PORT,al

		;Get data
		in  al,RTC_DATA_PORT
		mov	[edx],al

		;Point to next
		inc ebx
		inc edx
		loop ReadLoop

		;Safe to allow interrupts now
		sti
	}

} // end void CXModuleRTC::RtcHwrAtomicWriteReadReg(PUCHAR pWriteData, ...)




//////////////////////////////////////////////////////////////////////////////////
// Function name	: RtcHwrWriteReg
// Description	    : Writes the contents to the RTC RAM
// Return type		: void 
//////////////////////////////////////////////////////////////////////////////////
void CXModuleRTC::RtcHwrWriteReg(UCHAR Address, UCHAR Data)
{
	__asm
	{
		;Stop interrupts to avoid any potential conflict
		cli
		
		;Point to the address
		mov	al,Address
		out	RTC_ADDR_PORT,al

		;Set the data
		mov	al,Data
		out	RTC_DATA_PORT,al

		;Safe to allow interrupts now
		sti
	}

} // end void CXModuleRTC::RtcHwrWriteReg(UCHAR Address, UCHAR Data)




//////////////////////////////////////////////////////////////////////////////////
// Function name	: CheckInterrupt
// Description	    : Gets the code that indicates the status after generating
//					  interrupt.
// Return type		: ulong
//////////////////////////////////////////////////////////////////////////////////

ULONG CXModuleRTC::CheckInterrupt()
{
	ULONG uCode;

	uCode = RtcHwrCheckInterrupt();

	return uCode;

} // end ULONG CXModuleRTC::CheckInterrupt() 



//////////////////////////////////////////////////////////////////////////////////
// Function name	: RtcHwrCheckInterrupt
// Description	    : Verifies the operation of the RTC Periodic Interrupt
// Return type		: ulong
//////////////////////////////////////////////////////////////////////////////////
ULONG CXModuleRTC::RtcHwrCheckInterrupt()
{
	__asm
	{
		;Stop interrupts for a couple of micro-seconds 
		;it shouldn't cause any performance hit
		cli

		;Preserve Control Register B at bl
		mov		al,RTC_CTRL_REG_B
		out		RTC_ADDR_PORT,al
		in		al,RTC_DATA_PORT
		mov		bl,al

		;Preserve Control Register A at bh
		mov		al,RTC_CTRL_REG_A
		out		RTC_ADDR_PORT,al
		in		al,RTC_DATA_PORT
		mov		bh,al

		;Disable all RTC interrupt sources
		mov		al,RTC_CTRL_REG_B
		out		RTC_ADDR_PORT,al
		mov		al,bl
		and		al,8Fh
		out		RTC_DATA_PORT,al

		;Disable the periodic interrupt
		mov		al,RTC_CTRL_REG_A
		out		RTC_ADDR_PORT,al
		mov		al,bh
		mov		al,20h
		out		RTC_DATA_PORT,al

		;Clear any old pending interrupt
		;Do 3 attempts
		mov		ecx,3
ClearInterrupt1:
		mov		al,RTC_CTRL_REG_C
		out		RTC_ADDR_PORT,al
		in		al,RTC_DATA_PORT

		;Pre-set next error code
		mov		ah,RTC_STATUS_NO_CLEAR

		;Verify that IRQF & PF bits are clear
		mov		al,RTC_CTRL_REG_C
		out		RTC_ADDR_PORT,al
		in		al,RTC_DATA_PORT
		test	al,0C0h
		loopnz	ClearInterrupt1
		jnz		Done

		;Pre-set next error code
		mov		ah,RTC_STATUS_UNEXP_INTR

		;Verify IRQ8 inactive by reading Slave PIC IRR
		mov		al,0Ah
		out		SPIC_CMD_PORT,al
		in		al,SPIC_IRR_PORT
		test	al,01h
		jnz		Done

		;Set-up the periodic rate to 1.953125 ms
		mov		al,RTC_CTRL_REG_A
		out		RTC_ADDR_PORT,al
		mov		al,27h
		out		RTC_DATA_PORT,al

		;Enable the periodic rate interrupt
		mov		al,RTC_CTRL_REG_B
		out		RTC_ADDR_PORT,al
		mov		al,bl
		or		al,40h
		out		RTC_DATA_PORT,al

		;Pre-set next error code
		mov		ah,RTC_STATUS_NO_INTR

		;Wait for IRQ8
		mov		ecx,RTC_INTR_TIMEOUT
WaitInterrupt:
		in		al,SPIC_IRR_PORT
		test	al,01h
		loopz	WaitInterrupt
		jz		Done

		;Pre-set next error code
		mov		ah,RTC_STATUS_NO_SET

		;Verify that both IRQF & PF bits are set
		mov		al,RTC_CTRL_REG_C
		out		RTC_ADDR_PORT,al
		in		al,RTC_DATA_PORT
		and		al,0C0h
		cmp		al,0C0h
		jne		Done

		;Disable all RTC interrupt sources
		mov		al,RTC_CTRL_REG_B
		out		RTC_ADDR_PORT,al
		mov		al,bl
		and		al,8Fh
		out		RTC_DATA_PORT,al

		;Clear interrupt status
		;Do 3 attempts
		mov		ecx,3
ClearInterrupt2:
		mov		al,RTC_CTRL_REG_C
		out		RTC_ADDR_PORT,al
		in		al,RTC_DATA_PORT

		;Pre-set next error code
		mov		ah,RTC_STATUS_NO_CLEAR

		;Verify that IRQF & PF bits are now clear
		in		al,RTC_DATA_PORT
		test	al,0C0h
		loopnz	ClearInterrupt2
		jnz		Done

		;Pre-set next error code
		mov		ah,RTC_STATUS_UNEXP_INTR

		;Verify IRQ8 inactive by reading Slave PIC IRR
		; This may not work right because interrupts are disabled, so the IRR was never cleared
		; from the interrupt that we generated.
;		mov		al,0Ah
;		out		SPIC_CMD_PORT,al
;		in		al,SPIC_IRR_PORT
;		test	al,01h
;		jnz		Done

		;Successful
		mov		ah,RTC_STATUS_SUCCESS

Done:
		;Restore Control Register A from bh
		mov		al,RTC_CTRL_REG_A
		out		RTC_ADDR_PORT,al
		mov		al,bh
		out		RTC_DATA_PORT,al

		;Restore Control Register B from bl
		mov		al,RTC_CTRL_REG_B
		out		RTC_ADDR_PORT,al
		mov		al,bl
		out		RTC_DATA_PORT,al

		;Safe to allow interrupts now
		sti

		;Leave the final result at eax
		movzx	eax,ah
	}

} // end void CXModuleRTC::RtcHwrCheckInterrupt()



//////////////////////////////////////////////////////////////////////////////////
// Function name	: GetCpuSpeed
// Description	    : Get an accurate measurement of the CPU speed.  This should
//					  be the only routine that needs to use the PIT timer within
//					  the RTC module.  All other routines can use the Time Stamp 
//					  Counter (which is much easier to access) after calling this 
//					  routine to determine the CPU speed.
// Return type		: double
//////////////////////////////////////////////////////////////////////////////////
double CXModuleRTC::GetCPUSpeed()
{
	unsigned char nmi_temp_reg;
	DWORD pit_rolls = 0;
	DWORD tsc_ticks = 0;
	DWORD pit_start = 0;
	DWORD pit_end = 0;
	double dblCPUSpeed, dblPitTime;

	__asm
	{
		push eax
		push ebx
		push ecx
		push edx
		push edi
		push esi
		pushf

		cli                 ;  stop interrupts
		// Disable NMIs
		in al, 70h
		mov nmi_temp_reg, al
		or al, 80h
		out 70h, al
		// NMIs are now disabled

		in  al, RTC_PIT_PORT_B_CTRL ; Get Port B control register byte
		and al, 0FCh        ;  mask for Speaker and Timer 2 gate bits
		out RTC_PIT_PORT_B_CTRL, al ;  disable Speaker and Timer 2 gate
		mov al, 0B4h        ; Initialize Timer 2
		out RTC_PIT_TIMER_CTRL, al  ;
		mov al, 0           ; Clear Timer 2 count
		out RTC_PIT_TIMER_2, al     ;
		nop
		out RTC_PIT_TIMER_2, al     ;

		in  al, RTC_PIT_PORT_B_CTRL ; Get Port B control register byte
		or  al, 1           ;  mask for Timer 2 gate enable bit
	 	out RTC_PIT_PORT_B_CTRL, al ;  enable Timer 2 gate (start counting)
		; The timer is now running
		; Do the loop below to ensure we don't read 0000 as our first value
get_tsc_loop0:
		mov AL, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		cmp ax, 8000h
		jbe get_tsc_loop0   ; if the new value is below or equal to 0x8000, continue
		; Now we know the timer has at least rolled over from 0000 to FFFF.
		mov al, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		rdtsc
		mov edi, eax        ; Preserve the Least Significant 32 bits
		mov esi, edx        ; Preserve the Most Significant 32 bits
		mov eax, 0
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		mov pit_start, eax  ; Record the initial PIT value
		; Now wait around for the counter to roll over several times
		mov cl, 19
get_tsc_loop1:
		mov bx, ax
		mov al, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		cmp ax, bx
		jbe get_tsc_loop1   ; if the new value is below or equal to the old value, continue
		inc DWORD PTR pit_rolls  ; Continue doing this until the timer rolls over the correct number of times
		dec cl
		jne get_tsc_loop1
		; Now read the final PIT and TSC values
		mov al, 80h
		out RTC_PIT_TIMER_CTRL, al  ; Latch the count
		rdtsc
		sub edx, esi        ; Calculate the change in high DWORD
		sub eax, edi        ; Calculate the change in low DWORD
		jnc GTD1
		dec edx
GTD1:
		mov tsc_ticks, eax        ; Preserve the low DWORD of CPU counts
		mov eax, 0
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count low byte
		mov ah, al          ;
		in  al, RTC_PIT_TIMER_2     ; Get Timer 2 count high byte
		xchg al, ah         ; Put low and high byte in correct order
		mov pit_end, eax ; Record the final PIT value

		in al, RTC_PIT_PORT_B_CTRL
		and al, 0feh
		out RTC_PIT_PORT_B_CTRL, al ;  disable Timer 2 gate (stop counting)

		// restore NMIs
		mov al, nmi_temp_reg
		out 70h, al
		// NMIs are now restored
		sti                 ; Start Interrupts

		popf
		pop esi
		pop edi
		pop edx
		pop ecx
		pop ebx
		pop eax
	}
	dblPitTime = (double)(pit_rolls-1) * (double)65536;
	dblPitTime = dblPitTime + (double)pit_start + (double)1;
	dblPitTime = dblPitTime + (double)(65536-pit_end);
	dblPitTime = dblPitTime - (double)1;
	dblPitTime = dblPitTime/(double)1125000.0;
	dblCPUSpeed = tsc_ticks/dblPitTime;

	return (dblCPUSpeed);

} // end double CXModuleRTC::GetCPUSpeed()


//////////////////////////////////////////////////////////////////////////////////
// Function name	: bWaitUIPandGetTimesSetTimes
// Description	    : This routine waits for an Update In Progress indication to 
//					  pass and then reads in the Time Stamp Counter and RTC time 
//				      values. If pucRTCWriteValues is not NULL, these values are 
//					  written into the RTC time bytes.
// Input			: pTSCVal - Time stamp counter value
//					: pucRTCReadValues - date and time value read
//					: pucRTCWriteValues - date and time value to be written
// Return type		: bool
//////////////////////////////////////////////////////////////////////////////////
bool CXModuleRTC::bWaitUIPandGetTimesSetTimes(LARGE_INTEGER *pTSCVal, unsigned char *pucRTCReadValues, unsigned char *pucRTCWriteValues)
{
	bool bSuccess = true;
	char cSuccessASM = 0;
	DWORD dwTSCLow, dwTSCHigh;
	unsigned char nmi_temp_reg;

	__asm
	{
		push eax
		push ebx
		push ecx
		push edx
		push edi
		push esi
		pushf

		cli                 ;  stop interrupts
		// Disable NMIs
		in al, 70h
		mov nmi_temp_reg, al
		or al, 80h
		out 70h, al
		// NMIs are now disabled

		mov al, 8Ah
		out RTC_ADDR_PORT, al
		mov edx, 15100000; This is about a 10 second timeout in the XBox Dev system
wuip1:  // Wait for the UIP bit to go high
		in al, RTC_DATA_PORT
		and al, RTC_UIP
		jne wuip2
		dec edx
		jne wuip1
		// Timed out waiting for UIP to go high
		mov cSuccessASM, 1
		jmp wuip_end1
wuip2:  // Wait for the UIP bit to go low
		in al, RTC_DATA_PORT
		and al, RTC_UIP
		je wuip2a
		dec edx
		jne wuip2
		// Timed out waiting for UIP to go high
		mov cSuccessASM, 1
		jmp wuip_end1
wuip2a:
		// The UIP just went low, so read the TSC
		rdtsc
		mov dwTSCLow, eax        ; Preserve the Least Significant 32 bits
		mov dwTSCHigh, edx       ; Preserve the Most Significant 32 bits
		// Now read the 10 time values from the RTC
		mov edx, pucRTCReadValues
		mov ecx, 10
		mov ebx, 80h ; start with RTC address 0 with NMIs disabled
wuip3:
		mov eax, ebx
		out RTC_ADDR_PORT, al
		in al, RTC_DATA_PORT
		mov BYTE PTR [edx], al
		inc ebx
		inc edx
		dec ecx
		jne wuip3
		// Now handle the century byte
;		mov eax, 0B2h
		mov eax, 0FFh
		out RTC_ADDR_PORT, al
		in al, RTC_DATA_PORT
		mov BYTE PTR [edx], al

		// Update the RTC to new time values, if applicable
		cmp pucRTCWriteValues, 0 // Don't update the RTC if no values are specified to write
		je wuip_end1
		mov edx, pucRTCWriteValues
		mov ecx, 10
		mov ebx, 80h ; start with RTC address 0 with NMIs disabled
wuip4:
		mov eax, ebx
		out RTC_ADDR_PORT, al
		mov al, BYTE PTR [edx]
		out RTC_DATA_PORT, al
		inc ebx
		inc edx
		dec ecx
		jne wuip4
		// Now handle the century byte
;		mov eax, 0B2h
		mov eax, 0FFh
		out RTC_ADDR_PORT, al
		mov al, BYTE PTR [edx]
		out RTC_DATA_PORT, al

wuip_end1:
		// restore NMIs
		mov al, nmi_temp_reg
		out 70h, al
		// NMIs are now restored
		sti                 ; Start Interrupts

		popf
		pop esi
		pop edi
		pop edx
		pop ecx
		pop ebx
		pop eax
  }
	if (cSuccessASM != 0) // UIP didn't happen in time
		bSuccess = false;
	pTSCVal->LowPart = dwTSCLow;
	pTSCVal->HighPart = dwTSCHigh;

	return bSuccess;

} // end bool CXModuleRTC::bWaitUIPandGetTimesSetTimes(LARGE_INTEGER *pTSCVal...)




//////////////////////////////////////////////////////////////////////////////////
// Function name	: vFillDateString
// Description	    : This routine displays the day of the week, date and time
// Return type		: bool
//////////////////////////////////////////////////////////////////////////////////
void CXModuleRTC::vFillDateString(LPTSTR pBuffer, unsigned char *pucRTCValues, unsigned short second)
{
	LPCTSTR DayList[] = {_T("Sunday"), _T("Monday"), _T("Tuesday"), _T("Wednesday"),
						      _T("Thursday"), _T("Friday"), _T("Saturday")};
	TCHAR sDay[80];

	if((pucRTCValues[6] >= 0x01)&&(pucRTCValues[6] <= 0x07))
		_tcscpy(sDay,DayList[pucRTCValues[6] - 1]);
	
	else
		_stprintf(sDay, _T("(Invalid Day: %02X)"),pucRTCValues[6]);
	
	_stprintf((LPTSTR)pBuffer, _T("%s, %02X/%02X/%02X%02X, %02X:%02X:%02X"), sDay, (unsigned short)pucRTCValues[8], 
		(unsigned short)pucRTCValues[7], (unsigned short)pucRTCValues[10], (unsigned short)pucRTCValues[9], (unsigned short)pucRTCValues[4], (unsigned short)pucRTCValues[2], (unsigned short)second);
}


/////////////////////////////////////////////////////////////////////////////////
// ACTUAL TESTS
//////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
// Ram Test
//////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_TESTLOCKED (RTC, ramtest, 1)
{
//	#ifdef _DEBUG
		static int Ram;
		Ram++;
		ReportDebug(BIT0,_T("Ram Test - Loop %d"), Ram);
//	#endif

	UINT uiSeed = 0, uiRandScratch = 0;
	if (iStart+iLength > 0x7D) // Avoid CMOS RAM locations 0x7D, 0x7E, and 0x7F
		iLength = 0x7D - iStart;
	// debug
	/*static int x = 1;
	TCHAR StrOutput[512];
	_stprintf(StrOutput, _T("ramtest loopcount = %d\n"), x);
	OutputDebugString(StrOutput);
	x++;*/

	// Init the random number generator
	vNewSeed(&uiSeed);
	if((m_nSeed = GetCfgInt(_T("Seed"), -1)) != -1)
		uiSeed = (UINT)m_nSeed;
	uiRandScratch = uiSeed;
	//bool flag;

	PUCHAR SavedRam = new UCHAR[iLength];

	ReadRam(iStart, iLength, SavedRam);

	// debug
	/*for(int index = 0; index < 10; index++)
	{
		flag = ReadRam(iStart, iLength, SavedRam);
		if(flag == false)
			ReportDebug(BIT0,_T("ReadRam failed\n"));
	}*/
	
	CDataBuffer Pats(iNumPatterns > iLength? iNumPatterns : iLength);
	Pats.FillRandom(&uiRandScratch);

	// debug
	//ReportDebug(BIT0,_T("iNumPatterns = %d, iLength = %d\n"), iNumPatterns, iLength);
	//
	// Create the read buffer
	//
	PUCHAR Read = new UCHAR[iLength];

	//
	// Write/Read/Verify patterns. During each iteration a
	// unique pattern is used for each address.
	//
	for(int i = 0; i < iNumPatterns; i++)
	{
		//
		// Do the block write & read as an atomic operation to avoid
		// any potential conflict with the OS (added on V2.02)
		//
		AtomicWriteReadRam(iStart, iLength, Pats, Read);

		for(int j = 0; j < iLength; j++)
		{
			if (iStart + j < 0x7D) // Look at all 8 bits of the RAM byte
			{
				if(Read[j] != Pats[j])
					err_Ram(iStart + j, Pats[j], Read[j], uiSeed);
			}
/*          Don't even test the last 3 bytes becuase the behavior is strange
			else  // Look at only the lower 6 bits of the RAM byte
			{
				if((Read[j] & 0x3F) != (Pats[j] & 0x3F))
					err_Ram(iStart + j, Pats[j] & 0x3F, Read[j] & 0x3F, uiSeed);
			}
*/
		}

		Pats.RotateUp();
	}

	//
	// Release the read buffer
	//
	delete Read;

	//
	// Restore original RAM contents
	//
	WriteRam(iStart, iLength, SavedRam);

	// debug
	/*for(index = 0; index < 10; index++)
	{
		flag = WriteRam(iStart, iLength, SavedRam);
		if(flag == false)
			ReportDebug(BIT0,_T("WriteRam failed\n"));
	}*/
	delete SavedRam;

} // end IMPLEMENT_TESTLOCKED (RTC, ramtest, 1)



IMPLEMENT_TESTLOCKED (RTC, datetimeaccuracytest, 2)
{
//    #ifdef _DEBUG
		static int DTA;
		DTA++;
		ReportDebug(BIT0,_T("DateTimeAccuracy Test - Loop %d"), DTA);
//	#endif

	// debug
	/*static int x = 1;
	TCHAR StrOutput[512];
	_stprintf(StrOutput, _T("datetimeaccuracytest loopcount = %d\n"), x);
	OutputDebugString(StrOutput);
	x++;*/
	
	unsigned char end_of_year[] = {0x59, 0x00, 0x59, 0x00, 0x23, 0x00, 0x06, 0x31, 0x12, 0x99, 0x19};
    unsigned char start_of_year[] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x01, 0x00, 0x20};
	unsigned char pcInitialTime[11], pcEndTime[11];
	double dblCPUSpeed;
	double dblElapsedTime;
	double dblOneSecondTime, dblPPM;
	LARGE_INTEGER liStartTSC, liEndTSC;
	int i;
	int iElapsedTime;
	bool bCorrectEndTime = true;

	// Get an accurate calculation of the CPU speed
	dblCPUSpeed = GetCPUSpeed();
//ReportDebug(BIT0,L"CPU Speed = %lf\n", dblCPUSpeed);
	// Avoid midnight rollover (makes calculations messy)
	i = 1000; // Ten seconds worth of waiting
	while (i > 0)
	{
		if ((RtcHwrReadReg(4) == 0x23) && (RtcHwrReadReg(2) == 0x59)  && (RtcHwrReadReg(0) > 0x53))
		{
			Sleep(100);
			i--;
		}
		else
			break;
	}

	// Report an error because we timed out waiting for an UIP
	if (!bWaitUIPandGetTimesSetTimes(&liStartTSC, pcInitialTime, end_of_year))
		err_UipTimeout();
	
	Sleep(2300); // Sleep 2 seconds to allow the year to roll over
	//ReportDebug(BIT0,_T("End time = %02lx:%02lx:%02lx\n"), (ULONG)pcInitialTime[4], (ULONG)pcInitialTime[2], (ULONG)pcInitialTime[0]);
	
	// Update the initial time to compensate for the time (normally 3 seconds)
	// that elapses between the read above and the write below.  This could be
	// longer than 3 seconds in some cases, and the RTC clock will get a little off
	pcInitialTime[0] = (unsigned char)(pcInitialTime[0] + 3);
	if ((pcInitialTime[0] & 0xF) > 0x9) // Rolled over the lower seconds digit
	{
		pcInitialTime[0] = (unsigned char)(pcInitialTime[0] + 0x10);
		pcInitialTime[0] = (unsigned char)(pcInitialTime[0] - 0x0a);
	}
	if (pcInitialTime[0] > 0x59) // Rolled over the minute
	{
		pcInitialTime[0] = (unsigned char)(pcInitialTime[0] - 0x60);
		pcInitialTime[2] = (unsigned char)(pcInitialTime[2] + 1);
		if ((pcInitialTime[2] & 0xF) > 0x9) // Rolled over the lower minutes digit
		{
			pcInitialTime[2] = (unsigned char)(pcInitialTime[2] + 0x10);
			pcInitialTime[2] = (unsigned char)(pcInitialTime[2] - 0x0a);
		}
		if (pcInitialTime[2] > 0x59) // Rolled over the hour
		{
			pcInitialTime[2] = (unsigned char)(pcInitialTime[2] - 0x60);
			pcInitialTime[4] = (unsigned char)(pcInitialTime[4] + 1);
			if ((pcInitialTime[4] & 0xF) > 0x9) // Rolled over the lower hours digit
			{
				pcInitialTime[4] = (unsigned char)(pcInitialTime[4] + 0x10);
				pcInitialTime[4] = (unsigned char)(pcInitialTime[4] - 0x0a);
			}
		}
	}
	//ReportDebug(BIT0,_T("End time = %02lx:%02lx:%02lx\n"), (ULONG)pcInitialTime[4], (ULONG)pcInitialTime[2], (ULONG)pcInitialTime[0]);
	// Report an error because we timed out waiting for an UIP
	if (!bWaitUIPandGetTimesSetTimes(&liEndTSC, pcEndTime, pcInitialTime))
		err_UipTimeout();

	// As mentioned above, normally 3 seconds elapses, but sometimes more.
	// Determine how many seconds really elapsed from the TSC readings
	dblElapsedTime = ((double)liEndTSC.QuadPart - (double)liStartTSC.QuadPart)/dblCPUSpeed;
	iElapsedTime = (int)(dblElapsedTime + 0.5); // Round to the nearest second

	//ReportDebug(BIT0,_T("Elapsed time = %lf\n"), dblElapsedTime);

	// We started the seconds RTC count at 59 seconds, so decrement iElapsed Time
	// to compensate
	iElapsedTime = iElapsedTime - 1;
	// Check to make sure the end time matches the expected end time
	for (i = 0; i < sizeof(start_of_year); i++)
	{
		if (i == 0) // Seconds entry
		{
			if (pcEndTime[i] != iElapsedTime)
				bCorrectEndTime = false;
		}
		else // All other entries
		{
			if (pcEndTime[i] != start_of_year[i])
				bCorrectEndTime = false;
		}
	}

	if (!bCorrectEndTime)
	{
		// Report an error because the end time was not right
		TCHAR ExpectedString[80];
		TCHAR ActualString[80];

		vFillDateString(ExpectedString, start_of_year, (unsigned short)iElapsedTime);
		vFillDateString(ActualString, pcEndTime, (unsigned short)pcEndTime[0]);
		err_DateTime(ExpectedString, ActualString);
	}

	// Now compare the RTC time to the TSC.  iElapsedTime will contain the RTC time
	iElapsedTime = (int)(dblElapsedTime + 0.5); // Round to the nearest second

	dblOneSecondTime = dblElapsedTime/(double)iElapsedTime;
	dblPPM = (double)((double)1.0 - dblOneSecondTime) * (double)1000000;
	if (dblPPM < 0)
		dblPPM = 0 - dblPPM;

	ReportStatistic(_T("RTC PPM"), _T("%.3lf"), dblPPM);
	if (dblPPM > (double)iPpm)
		err_Accuracy((double)iPpm, dblPPM);

	 ReportDebug(BIT1, _T("PPM 1 = %lf\n"), dblPPM);
	// ReportDebug(_T("Elapsed Time = %lf\n"), dblElapsedTime);

} // end IMPLEMENT_TESTLOCKED (RTC, dateandtimetest, 2)




IMPLEMENT_TESTLOCKED (RTC, interrupttest, 3)
{
//	#ifdef _DEBUG
		static int Intr;
		Intr++;
		ReportDebug(BIT0,_T("Interrupt Test - Loop %d"), Intr);
//	#endif

	// debug
	/*static int x = 1;
	TCHAR StrOutput[512];
	_stprintf(StrOutput, _T("interrupttest loopcount = %d\n"), x);
	OutputDebugString(StrOutput);
	x++;*/

	// Call CheckInterrupt and report appropriate error messages depending
	// on the RTC status after generating interrupt.
	switch(CheckInterrupt())
	{
	case RTC_STATUS_NO_CLEAR:
		err_StatusNoClear();
		break;
	case RTC_STATUS_NO_SET:
		err_StatusNoSet();
		break;
	case RTC_STATUS_UNEXP_INTR:
		err_UnexpIntr();
		break;
	case RTC_STATUS_NO_INTR:
		err_NoIntr();
		break;
	}

} // end IMPLEMENT_TESTLOCKED (RTC, interrupttest, 3)



// This is a debugging tool. This test will dump the contents of 128 or 256
// bytes of the RTC RAM.
IMPLEMENT_TESTLOCKED (RTC, datetimedumputility, 4)
{
//	#ifdef _DEBUG
		static int RTCDump;
		RTCDump++;
		ReportDebug(BIT0,_T("DateTimeDumpUtility Test - Loop %d"), RTCDump);
//	#endif

	// debug
	/*static int x = 1;
	TCHAR StrOut[512];
	_stprintf(StrOut, _T("rtcdumputility loopcount = %d\n"), x);
	OutputDebugString(StrOut);
	x++;*/

    UCHAR index; // offset into the RTC address range 
    int size;
	//TCHAR StrOutput[512];

    /* initialize parameters */
    index = 0;
   // Read 128 bytes of the RTC data
	// 0x80 = 128
	// 0x100 = 256
    size = 0x80; 

   	ReportDebug(BIT0, _T("DAY OF WEEK: %02X, DATE(mm:dd:yy): %02X:%02X:%02X\n"), RtcHwrReadReg(6), 
				  RtcHwrReadReg(7), RtcHwrReadReg(8), RtcHwrReadReg(9));

	ReportDebug(BIT0, _T("TIME(hh:mm:ss): %02X:%02X:%02X\n"), RtcHwrReadReg(4), RtcHwrReadReg(2), 
				  RtcHwrReadReg(0));
	   
} // end IMPLEMENT_TESTLOCKED (RTC, datetimedumputility, 4)

void CXModuleRTC::vNewSeed(UINT *pSeed)
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	GetSystemTime(&systimeSeed);
	SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
	*pSeed = (UINT)filetimeSeed.dwLowDateTime;

	return;
}

DWORD CXModuleRTC::random(UINT *pScratch)
{
	DWORD ret;
	ret  = (*pScratch = *pScratch * 214013L + 2531011L) >> 16;
	ret |= (*pScratch = *pScratch * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xrtc\rtcioctl.h ===
#ifndef _RTCIOCTL_H

#define _RTCIOCTL_H

/*#ifdef _RTC_DRIVER
#include <devioctl.h>
#else
#include <winioctl.h>
#endif
*/
//
// Driver version number - must be consistent with the driver version resource
//
#define RTC_DRIVER_VERSION_STR		"version_number=1.03"
#define RTC_DRIVER_VERSION_NUM		0x103

//
// IOCTL's
//
#define IOCTL_RTC_WRITE_RAM \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_READ_RAM \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_ATOMIC_WRITE_READ_RAM \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x803,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_SET_DATE_AND_TIME \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x804,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_GET_DATE_AND_TIME \
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x805,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_MEASURE_CYCLE	\
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x806,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_CHECK_INTERRUPT	\
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x807,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_DRIVER_CONFIG	\
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x810,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_RTC_DRIVER_GET_INFO	\
	CTL_CODE(FILE_DEVICE_UNKNOWN,0x811,METHOD_BUFFERED,FILE_ANY_ACCESS)

enum _RTC_STATUS_TAG {RTC_STATUS_SUCCESS,RTC_STATUS_NO_CLEAR,
	RTC_STATUS_NO_SET,RTC_STATUS_UNEXP_INTR,RTC_STATUS_NO_INTR};

//
// Input buffer for IOCTL_RTC_WRITE_RAM & IOCTL_RTC_READ_RAM
//
#pragma warning(disable:4200)

typedef struct {
	ULONG Start;					// starting offset (0x0E - 0x7F)
	ULONG Length;					// number of bytes
	UCHAR Data[];					// input data (if write)
} RTC_RAM_BLOCK,*PRTC_RAM_BLOCK;

#pragma warning(default:4200)

//
// Input buffer for IOCTL_RTC_SET_DATE_AND_TIME
// Output buffer for IOCTL_RTC_GET_DATE_AND_TIME
//
#pragma warning(disable:4201)
typedef union {
	UCHAR Data[7];
	struct {
		USHORT Second;
		USHORT Minute;
		USHORT Hour;
		USHORT DayOfWeek;
		USHORT DayOfMonth;
		USHORT Month;
		USHORT Year;
	};
} RTC_DATE_AND_TIME_BLOCK,*PRTC_DATE_AND_TIME_BLOCK;

#pragma warning(default:4201)
//
// Output buffer for IOCTL_RTC_MEASURE_CYCLE
//
typedef struct {
	ULONG			Reserved;		// for internal driver use
	ULONG			TotalSeconds;	// number of seconds as measured by RTC clock
	LARGE_INTEGER	CpuCycles;		// number of CPU cycles taken
	struct {						// For performance reasons, the driver doesn't
		LARGE_INTEGER CpuCount;		// do floating point operations. The CPU freq
		LARGE_INTEGER TimerCount;	// should be computed by the app as:
		LARGE_INTEGER TimerFreq;	// double CpuFreq = (double)TimerFreq / TimerCount * CpuCount
	} CpuFreq;
} RTC_MEASURE_CYCLE_BLOCK,*PRTC_MEASURE_CYCLE_BLOCK;

//
// Input buffer for IOCTL_RTC_DRIVER_CONFIG
//
typedef struct {
	ULONG				HwrRefTimerId;			// reference hardware timer id
	USHORT				HwrRefTimerPort;		// reference hardware timer port
} RTC_DRIVER_CONFIG_BLOCK,*PRTC_DRIVER_CONFIG_BLOCK;

//
// Output buffer for IOCTL_RTC_DRIVER_GET_INFO
//
#pragma warning(disable:4201)
typedef struct {
	union {
		ULONG	Version;
		struct {
			UCHAR MinorVersion;
			UCHAR MajorVersion;
			USHORT Reserved1;
		};
	};
	UCHAR Reserved2[4];
} RTC_DRIVER_INFO_BLOCK,*PRTC_DRIVER_INFO_BLOCK;
#pragma warning(default:4201)


#endif // _RTCIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xrtc\xrtc.h ===
#ifndef _XRTC_H
#define _XRTC_H

#include "..\parameter.h"
//#include "DateAndTime.h"
#pragma once

#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif

// C4512: unable to generate an assignment operator for the given class. 
#pragma warning (disable:4512)

// Naming of class test and module classes.
// 
// module class: CXModule<module>
// test class:   CXModule<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//


// 
// XUSB Module Number for getting registered with the test executive
//
#define XRTC_MODNUM 5

// Constants needed for accessing the RTC
#define RTC_PIT_TIMER_2 0x042
#define RTC_PIT_TIMER_CTRL 0x43
#define RTC_PIT_PORT_B_CTRL 0x61
#define RTC_UIP 0x80


class CXModuleRTC : public CTestObj
{
public: // Get module number from numbers.h
	DECLARE_XMTAMODULE(CXModuleEval, "rtc", XRTC_MODNUM);

protected:
	// Error messages can be declared here ...
	// (Note: 0x000 - 0x00f reserved for XMTA)
	//
	DWORD err_BadParameter(LPCTSTR s1)
	{
		ReportError(0x010, (_T("Can't find configuration parameter \"%s\"\nThis configuration ")
					 _T("parameter doesn't exist or is invalid")), s1); 
		return FAIL;
	}

	DWORD err_SystemError(DWORD i)
	{
		ReportError(0x011, (_T("System Error. GetLastError() returned %d\n")), i); 
		return FAIL;
	}

	DWORD err_DateTime(LPCTSTR s1, LPCTSTR s2)
	{
		ReportError(0x012, (_T("Incorrect Date/Time: Expected %s, Read %s\n")), s1, s2); 
		return FAIL;
	}
	
	DWORD err_Ram(int i1, int i2, int i3, int i4)
	{
		ReportError(0x013,(_T("Mismatch at Offset 0x%02X, Wrote 0x%02X, Read 0x%02X, Seed %u\n")), i1, i2, i3, i4);
		return FAIL;
	}

	DWORD err_Accuracy(double f1, double f2)
	{
		ReportError(0x014, (_T("Accuracy error: required +\\-%f ppm, measured %f ppm\n")), f1, f2);
		return FAIL;
	}

	DWORD err_StatusNoClear()
	{
		ReportError(0x015, _T("Status flag IRQF not cleared.\n"));
		return FAIL;
	}
	
	DWORD err_StatusNoSet()
	{
		ReportError(0x016, _T("Status flag IRQF not set.\n"));
		return FAIL;
	}
	
	DWORD err_UnexpIntr()
	{
		ReportError(0x017, _T("Signal IRQ8 unexpectedly activated.\n"));
		return FAIL;
	}

	DWORD err_NoIntr()
	{
		ReportError(0x018, _T("Signal IRQ8 not activated.\n"));
		return FAIL;
	}

	DWORD err_InvalidRange()
	{
		ReportError(0x019, _T("Invalid range for Length or Start Parameter(s).\n"));
		return FAIL;
	}

	DWORD err_InvalidParameter()
	{
		ReportError(0x01A, _T("Invalid range for Date or Time Parameter(s).\n"));
		return FAIL;
	}

	//debug
	DWORD err_MismatchedWrite(ULONG u1, int p1, int p2)
	{
		ReportError(0x01B, _T("Mismatched Write: Index = %d, Read = %d, Wrote = %d\n"), u1, p1, p2);
	 	return FAIL;
	}

	DWORD err_MismatchedRead(ULONG u1, int p1, int p2)
	{
		ReportError(0x01C, _T("Mismatched Read: Index = %d, Actual = %d, Read = %d\n"), u1, p1, p2);
	 	return FAIL;
	}

	DWORD err_UipTimeout()
	{
		ReportError(0x01D, _T("Timed out waiting for UIP\n"));
		return FAIL;
	}


	int iStart;
	int iLength;
	int iNumPatterns;
	int iPpm;
	int iSeconds;
	int m_nSeed;
	HANDLE m_hDriver;

	//
// RTC defs
//
#define RTC_ADDR_PORT		0x70
#define RTC_DATA_PORT		0x71
#define RTC_EX_ADDR_PORT	0x72
#define RTC_EX_DATA_PORT	0x73
#define RTC_RAM_LEN			114
#define RTC_RAM_START		14
#define RTC_RAM_END			(RTC_RAM_START + RTC_RAM_LEN - 1)
#define RTC_SECONDS			0x00
#define RTC_MINUTES			0x02
#define RTC_HOURS			0x04
#define RTC_DAY				0x06
#define RTC_DATE			0x07
#define RTC_MONTH			0x08
#define RTC_YEAR			0x09
#define RTC_CTRL_REG_A		0x0A
#define RTC_CTRL_REG_B		0x0B
#define RTC_CTRL_REG_C		0x0C
#define RTC_CTRL_REG_D		0x0D
#define RTC_UIP_MASK		0x80
#define RTC_UIP_TIMEOUT		0x0C000000
#define RTC_INTR_TIMEOUT	0x00C00000
	//
// Slave PIC defs
//
#define SPIC_CMD_PORT		0xA0
#define SPIC_IRR_PORT		0xA0
#define MPIC_CMD_PORT		0x20

//
// An array to conveniently access RTC Date-Time info
//
static const UCHAR DateTimeRegs[];// = {RTC_SECONDS,RTC_MINUTES,RTC_HOURS,RTC_DAY,RTC_DATE,RTC_MONTH,RTC_YEAR};


	virtual bool InitializeParameters ();
//	~CXModuleRTC();

public:
	//
	// Common functions go here.  Put any functions that need 
	// to be global to the tests in the module class
	//
	void InitSeed();
	ULONG CheckInterrupt();
	
	bool ReadRam(ULONG uStart, ULONG uLength, PUCHAR pData);
	void AtomicWriteReadRam(ULONG uStart, ULONG uLength, PUCHAR pWriteData, PUCHAR pReadData);	
	bool WriteRam(ULONG uStart, ULONG uLength, PUCHAR pData);
	
	UCHAR RtcHwrReadReg(UCHAR Address);
	void RtcHwrAtomicWriteReadReg(PUCHAR pWriteData, PUCHAR pReadData, ULONG uStart, ULONG uLength);
	void RtcHwrWriteReg(UCHAR Address, UCHAR Data);

	double GetCPUSpeed();
	bool bWaitUIPandGetTimesSetTimes(LARGE_INTEGER *pTSCVal, unsigned char *pucRTCReadValues, unsigned char *pucRTCWriteValues);
	void vFillDateString(LPTSTR pBuffer, unsigned char *pucRTCValues, unsigned short second);

	ULONG RtcHwrCheckInterrupt();
	void vNewSeed(UINT *pSeed);
	DWORD random(UINT *pScratch);

};


#endif	// _XRTC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xsmc\xsmc.h ===
#ifndef _XSMC_H
#define _XSMC_H

#include "..\parameter.h"

// XSMC Module Number for getting registered with the test executive
#define XSMC_MODNUM 6

#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif

#define REG_TEMP_UTILITY_EVENT_NAME  "XMTA_REG_TEMP_UTILITY_EVENT"
#define DVD_SPIN_DOWN_UTILITY_EVENT_NAME  "XMTA_DVD_SPIN_DOWN_UTILITY_EVENT"


LPCTSTR pwsRevAllowed = _T("RevisionAllowed[%d]");
LPCTSTR pwsRevNotAllowed = _T("RevisionNotAllowed[%d]");
BOOL bErrorFlag = FALSE;
CRITICAL_SECTION SMCRegisterCriticalSection;
BOOL bSMCRegsiterCriticalSectionInitialized = false;

// NTSTATUS
typedef LONG NTSTATUS; 
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#define NTHALAPI     DECLSPEC_IMPORT

// SMBus functions.
extern "C"
{
NTHALAPI
NTSTATUS
NTAPI
HalReadSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN ReadWordValue,
	OUT ULONG *DataValue
	);

#define HalReadSMBusByte(SlaveAddress, CommandCode, DataValue) \
	HalReadSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalReadSMBusWord(SlaveAddress, CommandCode, DataValue) \
	HalReadSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

NTHALAPI
NTSTATUS 
NTAPI
HalWriteSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN WriteWordValue,
	IN ULONG DataValue
	);

#define HalWriteSMBusByte(SlaveAddress, CommandCode, DataValue) \
	HalWriteSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalWriteSMBusWord(SlaveAddress, CommandCode, DataValue) \
	HalWriteSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

} // end extern "C"

class CXModuleSMC : public CTestObj
{
public: // Get module number from numbers.h
	DECLARE_XMTAMODULE(CXModuleEval, "smc", XSMC_MODNUM);

protected:
	// Error messages can be declared here ...
	// (Note: 0x000 - 0x00f reserved for XMTA)
	DWORD err_BadParameter(LPCTSTR s1)
	{
		ReportError(0x010, (_T("Can't find configuration parameter \"%s\"\nThis configuration ")
					 _T("parameter doesn't exist or is invalid")), s1); 
		return FAIL;
	}

	DWORD err_RevisionXor()
	{
		ReportError(0x011, (_T("\"RevisionAllowed[##]\" and \"RevisionNotAllowed[##]\" configuration")
        					_T(" parameters are mutually exclusive. Use one set or the other."))); 
		return FAIL;
	}
	
	DWORD err_RevisionNotAllowed(LPCTSTR s1)
	{
		ReportError(0x12, _T("SMC Revision ID \"%s\" is not allowed."), s1);
		return FAIL;
	}

	DWORD err_Write(LPCTSTR s1, LONG l1)
	{
		ReportError(0x13, _T("Write to SMC %s Register Failed. NTSTATUS = 0x%08lX"), s1, l1);
		return FAIL;
	}

	DWORD err_Read(LPCTSTR s1, LONG l1)
	{
		ReportError(0x14, _T("Read from SMC %s Register Failed. NTSTATUS = 0x%08lX"), s1, l1);
		return FAIL;
	}

	DWORD err_Reset(LONG l1)
	{
		ReportError(0x15, _T("Unable to Reset the System. NTSTATUS = 0x%08lX"), l1);
		return FAIL;
	}

	DWORD err_HostResponseError(DWORD dwErrorCodeFromHost, LPCTSTR s1)
	{
		ReportError ((unsigned short)dwErrorCodeFromHost, _T("The host responded with the following")
					  _T(" error message:\n%s"), s1);
		return FAIL;
	}

	DWORD err_HostCommunicationError(int i1)
	{
		ReportError (0x017, _T("iSendHost communication routine returned an error code of 0x%x"), i1); 
		return FAIL;
	}

	DWORD err_BufferIsEmpty()
	{
		ReportError (0x018, _T("The buffer from the host is empty.")); 
		return FAIL;
	}

	DWORD err_LEDStateFromTIU(LPCTSTR s1)
	{
		ReportError (0x019, _T("Error in getting the LED to %s State."), s1); 
		return FAIL;
	}

	DWORD err_VModeState(LPCTSTR s1)
	{
		ReportError (0x01A, _T("Error in getting the VMode to %s State."), s1); 
		return FAIL;
	}

	DWORD err_AudioClampRelease()
	{
		ReportError (0x01B, _T("Could not release the Audio Clamp.")); 
		return FAIL;
	}

	DWORD err_AudioClamp()
	{
		ReportError (0x01C, _T("Could not clamp the Audio.")); 
		return FAIL;
	}

	DWORD err_AirSensor(int i1, BYTE b1, LPCTSTR s1, BYTE b2, LPCTSTR s2)
	{
		ReportError (0x01D, _T("Fan Speed = %d and Air Sensor = %d(%s). It should have been %d(%s)"), 
					 i1, b1, s1, b2, s2); 
		return FAIL;
	}

	DWORD err_FanVoltLimitBadParameter(LPCTSTR s1, LPCTSTR s2, LPCTSTR s3)
	{
		ReportError (0x01E, _T("Configuration Parameter \"%s\" has a(n) %s limit of %s"), s1, s2, s3); 
		return FAIL;
	}

	DWORD err_FanVoltLimit(float f1, int i1, float f2, float f3)
	{
		ReportError (0x01F, _T("Invalid Voltage of %f for Fan Speed of %d. Lower limit is %f and upper")
					 _T(" limit is %f"), f1, i1, f2, f3); 
		return FAIL;
	}

	DWORD err_CpuJunctionTemp(int i1, int i2, int i3)
	{
		ReportError (0x020, _T("Invalid CPU Junction Temp of %dC. Lower limit is %dC and Upper")
					 _T("limit is %dC"), i1, i2, i3); 
		return FAIL;
	}

	DWORD err_InternalAirTemp(int i1, int i2, int i3)
	{
		ReportError (0x021, _T("Invlaid Internal Air Temp of %dC. Lower limit is %dC and Upper")
					 _T("limit is %dC"), i1, i2, i3); 
		return FAIL;
	} 

	DWORD err_LEDResponse(LPCTSTR s1, LPCTSTR s2)
	{
		ReportError (0x022, _T("Incorrect Response. It should have been %s instead of %s"), s1, s2); 
		return FAIL;
	} 

	DWORD err_NoDVDMediaDetected()
	{
		ReportError (0x023, _T("Media was not detected in the DVD drive")); 
		return FAIL;
	} 

	DWORD err_NoDVDActivityDetected()
	{
		ReportError (0x024, _T("Did not detect a signal on the DVD Activity line")); 
		return FAIL;
	} 

	DWORD err_DVDTrayNotOpen()
	{
		ReportError (0x025, _T("DVD drive did not report a tray open status")); 
		return FAIL;
	} 

	DWORD err_NoDVDMediaNotDetected()
	{
		ReportError (0x026, _T("The DVD trays state was never closed and empty (media not present)")); 
		return FAIL;
	} 
	DWORD err_CreateEventFailed(char *c1)
	{
		ReportError (0x027, _T("Could not create an event named %S")); 
		return FAIL;
	}

	DWORD err_CpuJunctionTempHigh(int i1, int i2)
	{
		ReportError (0x028, _T("Invalid CPU Junction Temp of %dC. Temperature exceeded upper limit of %dC"), i1, i2); 
		return FAIL;
	}

	virtual bool InitializeParameters ();
//	~CXModuleSMC();

	// Four LED states that are tested
	#define Off 0
	#define Green 1
	#define Red 2
	#define Orange 3

	// Video Modes written thru TIU
	#define DISABLE  0 
	#define SDTVNTSC 1
	#define PALRFU   2
	#define SDTVPAL  3
	#define NTSCRFU  4
	#define VGA      5
	#define HDTV     6
	#define SCART    7

	// Video Modes read thru SMC
	#define SMCDISABLE  7
	#define SMCSDTVNTSC 6
	#define SMCPALRFU   5
	#define SMCSDTVPAL  4
	#define SMCNTSCRFU  3
	#define SMCVGA      2
	#define SMCHDTV     1
	#define SMCSCART    0

	// buttons for dialog box for the LEDSystemTest
	#define IDOK        1
	#define IDCANCEL    2


	// Wait for 3 minutes for the host to respond to any communications
	#define HOST_TIMEOUT 180 
	#define MAX_REVISIONS 20
	LPCTSTR pwsAllowed, pwsNotAllowed, pwsAudioClamp;	
	LPCTSTR pwsFan50LL, pwsFan50UL, pwsFan20LL, pwsFan20UL;
	float fFanSpeed50LL, fFanSpeed50UL, fFanSpeed20LL, fFanSpeed20UL;
	UINT uiCpuJunTempLL, uiCpuJunTempUL, uiInternalAirTempLL, uiInternalAirTempUL, uiCpuJunTempCritical;
	DWORD dwRegulatedCPUTemperatureFanOff, dwRegulatedCPUTemperatureFanOn;
	DWORD gdwBootCountGateValue;
	DWORD dwRegulatedTemperatureMinTimeFanSteady;
	DWORD dwRegulatedTemperatureMaxTimeFanSteady;
	DWORD dwRegulatedTemperatureFanSteadyValue;
	DWORD dwLEDSystemTestComplexity;
	DWORD dwDVDMediaDetectTimeout;
	DWORD dwLEDSystemTestTriesAllowed;
	NTSTATUS NtStatus;

public:
	// Common functions go here.  Put any functions that need 
	// to be global to the tests in the module class
	BYTE GetLEDStateFromTIUForBoardTest(int iState);
	BYTE GetLEDStateFromTIUForSystemTest(int iState, bool bVerifyQuestion);
	void PutVModeStateToTIU(int iState);
	float GetFanVoltageFromTIU();
	BYTE GetAirSensorFromTIU();
	DWORD dwLEDSystemTest(DWORD dwLEDSystemTestTriesLeft);
	void vNewSeed(UINT *pSeed);
	DWORD random(UINT *pScratch);
};

#endif	// _XSMC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtool\xtool.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// Title: xTool
//
// History:
//
// 01/24/01 V1.00 BLI Release V1.00.

#include "..\stdafx.h"
#include "..\testobj.h"
#include "..\xboxkeys.h"
#include "..\statkeys.h"
#include "xtool.h"
#ifdef _XBOX
#include "perboxdata.h"

extern "C"
{
#include "av.h"
}
#endif

IMPLEMENT_MODULEUNLOCKED (CXModuleTool);

bool CXModuleTool::InitializeParameters ()
{
	if (!CTestObj::InitializeParameters ())
		return false;

	dwRandomNumberLength = GetCfgUint (L"random_number_length", 32);
	
	//Get the display parameters - there are a lot of them...
	//Get parameters from ini file for tests.
	//Required parameters.
	m_vidMode = GetCfgInt( L"videomode", -1);
	m_TIUStatus = GetCfgString( L"tiu", NULL);
	m_pack = GetCfgString( L"pack", NULL);
	m_standard = GetCfgString( L"standard", NULL);
	//50 or 60 Hz rate must be specified.
	m_flagRefreshRate = GetCfgInt( L"refresh_rate", 0);
	
	//Optional flags.
	m_HDTVmode = GetCfgString( L"hdtv_mode", NULL);
	m_flagWidescreen = GetCfgInt( L"widescreen", 0);
#ifdef _XBOX		
	D3D__AvInfo = 0x00000000;
#endif	
	return true;
}

//******************************************************************
// Title: get_random_number
//
// Abstract: Gets a random number of a specified length from the host
//
// Uses config parameters:
//           random_number_length
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, get_random_number, 1)
{
	CHostResponse CHR;
	DWORD dwActualBytesReceived = 0, dwErrorCodeFromHost = 0;
	int iError;

	// Use the full version of iSendHost because a response is expected
	if ((iError = g_host.iSendHost(MID_XBOX_RANDOM_STRING, (char *)&dwRandomNumberLength, sizeof(DWORD), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				return;
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		if (err_RandomBufferIsEmpty())
			return;
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		if (dwActualBytesReceived != dwRandomNumberLength)
		{
			if (err_RandomBufferIsEmpty())
				return;
		}
		// We received the random number buffer the size that we wanted

		// For now, just display the numbers
		for (DWORD q = 0; q < dwRandomNumberLength; q++)
			ReportDebug(BIT0, L"Byte %2.2lu = 0x%2.2lx\n", q, (DWORD)(*(((BYTE *)CHR.pvBufferFromHost) + q)));
	}
}


//******************************************************************
// Title: set_display_mode
//
// Abstract: Sets the display outmode of the device under test.
//			Also used to send a message to the host to instruct the
//			interface board to change it's output configuration accordingly.
//
// Uses config parameters:
//           
//******************************************************************
IMPLEMENT_TESTLOCKED (Tool, set_display_mode, 2)
{
#ifdef _XBOX
	if(m_vidMode < 0)
	{
		err_BADPARAMETER(L"videomode");
		return;
	}
	if(m_TIUStatus == NULL)
	{
		err_BADPARAMETER(L"tiu");
		return;
	}
	if(m_pack == NULL)
	{
		err_BADPARAMETER(L"pack");
		return;
	}
	//if(m_standard == NULL)
	//{
	//	err_BADPARAMETER(L"standard");
	//	return;
	//}
	//50 or 60 Hz rate must be specified.
	if(m_flagRefreshRate == 0)
	{
		err_BADPARAMETER(L"refresh_rate");
		return;
	}

	//Set the display mode parameters to create the DX8 device/surface interface.
	if(!InitializeDisplaySettings(m_vidMode))
		return;
	
#endif	
}


//******************************************************************
// Title: InitializeDisplaySettings(int mode, int backBufferFormat)
//
// Abstract: Sets the display outmode of the device under test.
//			Also used to send a message to the host to instruct the
//			interface board to change it's output configuration accordingly.
//
// Uses config parameters:
//           
//******************************************************************
#ifdef _XBOX
bool CXModuleTool::InitializeDisplaySettings(int mode)
{
	HRESULT hr;
	
	//Set up the parameters that are global to any setting to be used.
	ZeroMemory( &g_d3dpp, sizeof(g_d3dpp) );
	// Create one backbuffer and a zbuffer
	g_d3dpp.BackBufferCount        = 1;
	g_d3dpp.EnableAutoDepthStencil = TRUE;
	g_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    g_d3dpp.FullScreen_RefreshRateInHz = m_flagRefreshRate;
	g_d3dpp.BackBufferFormat = D3DFMT_LIN_X8R8G8B8;
	g_d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	if(m_HDTVmode != NULL)
	{
		if(!wcsicmp(m_HDTVmode, L"1080i"))
		{
			g_d3dpp.FullScreen_PresentationInterval	= 0;//Zero value needed for 1080i sync issues.
			g_d3dpp.Flags |= D3DPRESENTFLAG_INTERLACED;
		}
		else
		{
			g_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
			g_d3dpp.Flags |= D3DPRESENTFLAG_PROGRESSIVE;
		}
	}
	else
		g_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	g_d3dpp.Flags |= m_flagWidescreen ? D3DPRESENTFLAG_WIDESCREEN : 0;
	g_d3dpp.Flags |= D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
	
	//Clear the AVPACK FLAG settings before resetting the device.
	D3D__AvInfo = 0x00000000;
	AvSendTVEncoderOption(NULL, AV_OPTION_ZERO_MODE, 0, NULL);
	
	switch(mode)
	{
		case 1://640x480 32Bpp (NTSC/PAL)
			g_d3dpp.BackBufferWidth   = 640;
			g_d3dpp.BackBufferHeight  = 480;
			break;

		case 2://704x480 32Bpp (NTSC/PAL)
			g_d3dpp.BackBufferWidth   = 704;
			g_d3dpp.BackBufferHeight  = 480;
			break;

		case 3://720x480 32Bpp (NTSC/PAL/HDTV_480p)
			g_d3dpp.BackBufferWidth   = 720;
			g_d3dpp.BackBufferHeight  = 480;
			break;
				
		case 4://640x576 32Bpp (PAL/SECAM)
			g_d3dpp.BackBufferWidth   = 640;
			g_d3dpp.BackBufferHeight  = 576;
			break;

		case 5://704x576 32Bpp (PAL/SECAM)
			g_d3dpp.BackBufferWidth   = 704;
			g_d3dpp.BackBufferHeight  = 576;
			break;

		case 6://720x576 32Bpp (PAL/SECAM)
			g_d3dpp.BackBufferWidth   = 720;
			g_d3dpp.BackBufferHeight  = 576;
			break;

		case 7://1280x720 32Bpp (HDTV_720p)
			g_d3dpp.BackBufferWidth   = 1280;
			g_d3dpp.BackBufferHeight  = 720;
			break;

		case 8://1920x1080 32Bpp (HDTV_1080i)
			g_d3dpp.BackBufferWidth   = 1920;
			g_d3dpp.BackBufferHeight  = 1080;
			break;

		default:
			//No valid display mode detected - return an error.
			err_SetDisplayMode(L"Invalid display mode specified in mode parameter");
			return FALSE;
			break;
	}


	//Now determine the flag settings for the AV Pack from config parameters.
	//Determine the standard flags to set.
	if(!wcsicmp(m_pack, L"composite"))
	{
		D3D__AvInfo |= AV_PACK_STANDARD;
		m_AVMode = AVMODENTSCCOMP;
	}
	else if(!wcsicmp(m_pack, L"svideo"))
	{
		D3D__AvInfo |= AV_PACK_SVIDEO;
		m_AVMode = AVMODENTSCENH;
	}
	else if(!wcsicmp(m_pack, L"rfu"))
	{
		D3D__AvInfo |= AV_PACK_RFU;
		m_AVMode = AVMODEDISABLE;
	}
	else if(!wcsicmp(m_pack, L"scart"))
	{
		D3D__AvInfo |= AV_PACK_SCART;
		m_AVMode = AVMODESCART;
	}
	else if(!wcsicmp(m_pack, L"hdtv"))
	{
		D3D__AvInfo |= AV_PACK_HDTV;
		m_AVMode = AVMODEHDTV;
	}
	else if(!wcsicmp(m_pack, L"vga"))
	{
		D3D__AvInfo |= AV_PACK_VGA;
		m_AVMode = AVMODEVGA;
	}
	else
	{
		err_BADPARAMETER(L"pack");
		return FALSE;
	}
	
	//Determine the region flags to set.
	if(m_standard != NULL)
	{
		if(!wcsicmp(m_standard, L"ntsc_m"))
			D3D__AvInfo |= AV_STANDARD_NTSC_M;
		else if(!wcsicmp(m_standard, L"ntsc_j"))
			D3D__AvInfo |= AV_STANDARD_NTSC_J;
		else if(!wcsicmp(m_standard, L"pal_i"))
			D3D__AvInfo |= AV_STANDARD_PAL_I;
		else if(!wcsicmp(m_standard, L"pal_m"))
			D3D__AvInfo |= AV_STANDARD_PAL_M;
		else
		{
			err_BADPARAMETER(L"standard");
			return FALSE;
		}
	}
	else
		D3D__AvInfo |= AV_STANDARD_MASK;

	//Determine the refresh rate.
	if(m_flagRefreshRate == 50)
		D3D__AvInfo |= AV_FLAGS_50Hz;
	else if(m_flagRefreshRate == 60)
		D3D__AvInfo |= AV_FLAGS_60Hz;
	else
	{
		err_BADPARAMETER(L"refresh_rate");
		return FALSE;
	}
	
	//Optional parameters.
	//Determine the desired HDTV mode to output.
	if(m_HDTVmode != NULL)//If null, then optional and not needed (unless it was left out by mistake!).
	{
		if(!wcsicmp(m_HDTVmode, L"480p"))
			D3D__AvInfo |= AV_FLAGS_HDTV_480p;
		else if(!wcsicmp(m_HDTVmode, L"720p"))
			D3D__AvInfo |= AV_FLAGS_HDTV_720p;
		else if(!wcsicmp(m_HDTVmode, L"1080i"))
		{
			D3D__AvInfo |= AV_FLAGS_HDTV_1080i;
			D3D__AvInfo |= AV_FLAGS_INTERLACED;
		}
		else
		{
			err_BADPARAMETER(L"hdtv_mode");
			return FALSE;
		}
	}

	//Do we want widescreen unlocked?
	if(m_flagWidescreen)
		D3D__AvInfo |= AV_FLAGS_WIDESCREEN;
	
	
	//If enabled, setup the TIU board for the correct output mode.	
	ReportDebug(0x1, L"TIU Status=%s", m_TIUStatus);
	if(!wcsicmp(m_TIUStatus, L"enabled"))
	{
		if(!InitializeInterfaceBoard(m_AVMode))
			return FALSE;
	}
		

   //OK - now all the required parameters are set to create a device.  Let's call the
	//Reset() function to clear out and create the newly defined DX8 device.
	ReportDebug(0x1, L"Resetting D3D Device...");
	hr = g_pd3dDevice->Reset(&g_d3dpp);
	if(hr != D3D_OK)
	{
		if(hr == D3DERR_INVALIDCALL)
		{
			err_D3DError(L"d3dDevice->Reset() - INVALID CALL: Method parameter may have invalid value.");
			return FALSE;
		}
		else if(hr == D3DERR_OUTOFVIDEOMEMORY)
		{
			err_D3DError(L"d3dDevice->Reset() - OUT_OF_VIDEOMEMORY: Not enough display memory to perform the operation.");
			return FALSE;
		}
		else if(hr == E_OUTOFMEMORY)
		{
			err_D3DError(L"d3dDevice->Reset() - E_OUTOFMEMORY: Could not allocate enough memory to complete the call.");
			return FALSE;
		}
		else
		{
			err_D3DError(L"d3dDevice->Reset() - ERROR: Unknown return value.");
			return FALSE;
		}

	}

	//Output the current display mode flag settings.
	ReportVideoSettings();

	return TRUE;
}
#endif


//******************************************************************
// Title: InitializeInterfaceBoard()
//
// Abstract: Sends a message to the host to set the appropriate output
//			circuits for the required av output mode. 
//
// Uses config parameters:
//
//					pack
//					(i.e. pack=sdtv sets output mode for composite and svideo)         
//******************************************************************
#ifdef _XBOX
bool CXModuleTool::InitializeInterfaceBoard(BYTE avMode)
{
	CHostResponse CHR;
	BYTE *send_buf = NULL;
	DWORD dwBufferToHostLength;
	int iError;
	
	send_buf = &avMode;
	dwBufferToHostLength = 1; //The avmode command is one byte long.

	ReportDebug(0x1, L"Sending message to set the TIU AVmode parameters (mode=%d).\n",avMode);
	// Use the short version of iSendHost because no response is expected
	//if ((iError = g_host.iSendHost(MID_XBOX_SET_VIDEO_MUX, send_buf, dwBufferToHostLength)) != EVERYTHINGS_OK)
	if ((iError = g_host.iSendHost(MID_XBOX_SET_VIDEO_MUX, send_buf, dwBufferToHostLength)) != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		err_HostCommunicationError(iError);
		return FALSE;
	}
	return TRUE;
}
#endif

//******************************************************************
// Title: ReportVideoSettings
//
// Abstract: Outputs the interpreted display mode settings.
//			Useful for debugging graphics and video problems.
//
// Uses config parameters:
//           
//******************************************************************
#ifdef _XBOX
void CXModuleTool::ReportVideoSettings()
{
	//Determine what display mode flags have been set.
	ReportDebug(0x1, L"The DX8 Device has been reset with the following settings:\n");
	ReportDebug(0x1, _T("AV Pack Flag Settings = 0x%x\n"), D3D__AvInfo);
		
	if(!wcsicmp(m_pack, L"composite"))
		ReportDebug(0x1, _T("AV_PACK_STANDARD Flag set TRUE.\n"));
	else if(!wcsicmp(m_pack, L"svideo"))
		ReportDebug(0x1, _T("AV_PACK_SVIDEO Flag set TRUE.\n"));
	else if(!wcsicmp(m_pack, L"rfu"))
		ReportDebug(0x1, _T("AV_PACK_RFU Flag set TRUE.\n"));
	else if(!wcsicmp(m_pack, L"scart"))
		ReportDebug(0x1, _T("AV_PACK_SCART Flag set TRUE.\n"));
	else if(!wcsicmp(m_pack, L"hdtv"))
		ReportDebug(0x1, _T("AV_PACK_HDTV Flag set TRUE.\n"));
	else if(!wcsicmp(m_pack, L"vga"))
		ReportDebug(0x1, _T("AV_PACK_VGA Flag set TRUE.\n"));
	
	if(m_standard != NULL)
	{
		if(!wcsicmp(m_standard, L"ntsc_m"))
			ReportDebug(0x1, _T("AV_STANDARD_NTSC_M Flag set TRUE.\n"));
		else if(!wcsicmp(m_standard, L"ntsc_j"))
			ReportDebug(0x1, _T("AV_STANDARD_NTSC_J Flag set TRUE.\n"));
		else if(!wcsicmp(m_standard, L"pal_i"))
			ReportDebug(0x1, _T("AV_STANDARD_PAL_I Flag set TRUE.\n"));
		else if(!wcsicmp(m_standard, L"pal_m"))
			ReportDebug(0x1, _T("AV_STANDARD_PAL_M Flag set TRUE.\n"));
	}
	if(D3D__AvInfo & AV_FLAGS_HDTV_480p)
		ReportDebug(0x1, _T("AV_FLAGS_HDTV_480p Flag set TRUE.\n"));
	
	if(D3D__AvInfo & AV_FLAGS_HDTV_720p)
		ReportDebug(0x1, _T("AV_FLAGS_HDTV_720p Flag set TRUE.\n"));
	
	if(D3D__AvInfo & AV_FLAGS_HDTV_1080i)
		ReportDebug(0x1, _T("AV_FLAGS_HDTV_1080i Flag set TRUE.\n"));
	
	if(D3D__AvInfo & AV_FLAGS_WIDESCREEN)
		ReportDebug(0x1, _T("AV_FLAGS_WIDESCREEN Flag set TRUE.\n"));
	
	if(D3D__AvInfo & AV_FLAGS_60Hz)
		ReportDebug(0x1, _T("AV_FLAGS_60Hz Flag set TRUE.\n"));

	if(D3D__AvInfo & AV_FLAGS_50Hz)
		ReportDebug(0x1, _T("AV_FLAGS_50Hz Flag set TRUE.\n"));

	//Now output all of the surface description settings.
	ReportDebug(0x1, _T("The display has been set to mode %d (%lu x %lu 32Bpp).\n"),
									m_vidMode,
									g_d3dpp.BackBufferWidth,
									g_d3dpp.BackBufferHeight);

}
#endif

IMPLEMENT_TESTUNLOCKED (Tool, find_free_memory, 3)
{
	BYTE *pByte = NULL;
	DWORD dwSize, dwLastGood, dwIncrement;
	bool bSuccess;


	dwLastGood = 0;
	dwSize = 0x4000000; // 64 MB
	dwIncrement = dwSize/2;

	while (dwIncrement > 0x20)
	{
		bSuccess = false;
		try
		{
			if ((pByte = new BYTE[dwSize]) != NULL)
			{
				ReportDebug(BIT1, L"Allocated %lu bytes, I = %8.8lx", dwSize, dwIncrement);
				bSuccess = true;
			}
			else
			{
				ReportDebug(BIT1, L"Failed to allocate %lu bytes, I = %8.8lx", dwSize, dwIncrement);
			}
		}
		catch (CXmtaException &e)
		{
			UNREFERENCED_PARAMETER(e);
			ReportDebug(BIT1, L"Failed to allocate %lu bytes, I = %8.8lx", dwSize, dwIncrement);
		}
		if (bSuccess)
		{
			memset(pByte, 0x55, dwSize);
			delete [] pByte;
			pByte = NULL;
			dwLastGood = dwSize;
			dwSize = dwSize + dwIncrement;
		}
		else
		{
			dwSize = dwSize - dwIncrement;
		}
		dwIncrement = dwIncrement/2;
	}
	ReportDebug(BIT0, L"Allocated %lu bytes, I = %8.8lx", dwLastGood, dwIncrement);
}

//******************************************************************
// Title: write_per_box_information
//
// Abstract: This utility reads values specific to each XBox from the
//           factory control database, calls a utility on the host computer
//           to generate per-box keys based on this information, records
//           the generated keys back in the factory control database, and
//           calls a function to write per-box data to the eeprom on the XBox.
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, write_per_box_information, 4)
{
#ifdef _XBOX
	#define GAME_REGION_CODE_SIZE      8
	#define TV_REGION_CODE_SIZE        8
	#define MAC_ADDRESS_SIZE          12
	#define SERIAL_NUMBER_SIZE        20
	#define SERIAL_NUMBER_TO_USE_SIZE 12
	#define SMC_REVISION_SIZE          3
	#define OS_VERSION_SIZE           20
	#define HARD_DRIVE_KEY_SIZE       24
	#define RECOVERY_KEY_SIZE          8
	#define ONLINE_KEY_VERSION_SIZE    4
	#define ONLINE_KEY_SIZE          172

	CHostResponse CHR;
	DWORD i, dwActualBytesReceived = 0 , dwErrorCodeFromHost = 0;
	int iError;
	TCHAR XBoxGameRegionCodeLabel[] = XBOX_GAME_REGION_CODE; // Read from host
	TCHAR XBoxTVRegionCodeLabel[] = XBOX_TV_REGION_CODE; // Read from host
	TCHAR XBoxHardDriveKeyLabel[] = XBOX_HARD_DRIVE_KEY; // Written to host
	TCHAR XBoxRecoveryKeyLabel[] = XBOX_RECOVERY_KEY; // Written to host
	TCHAR XBoxOnlineKeyVersionLabel[] = XBOX_ONLINE_KEY_VERSION; // Written to host
	TCHAR XBoxOnlineKeyLabel[] = XBOX_ONLINE_KEY; // Written to host
	TCHAR XBoxOSVersionLabel[] = XBOX_ROM_VERSION; // Written to host
	TCHAR XBoxSMCRevLabel[] = XBOX_SMC_VERSION; // Written to host
	NTSTATUS NtStatus;

	TCHAR XBoxGameRegionCodeResult[GAME_REGION_CODE_SIZE+1];
	DWORD dwXBoxGameRegion = 0;
	TCHAR XBoxTVRegionCodeResult[TV_REGION_CODE_SIZE+1];
	DWORD dwXBoxTVRegion = 0;
	TCHAR XBoxMACAddressResult[MAC_ADDRESS_SIZE+5];
	DWORD dwXBoxMACAddressLow = 0;
	DWORD dwXBoxMACAddressHigh = 0;
	TCHAR XBoxSerialNumberResult[SERIAL_NUMBER_SIZE+1];
	char XBoxSerialNumberToUse[SERIAL_NUMBER_TO_USE_SIZE+1]; // Pointer to the 12 digit number
	char cSMCRev[SMC_REVISION_SIZE+1];
	TCHAR XBoxSMCRev[SMC_REVISION_SIZE+1];
	TCHAR XBoxOSVersion[OS_VERSION_SIZE+1];
	TCHAR XBoxHardDriveKey[HARD_DRIVE_KEY_SIZE+1];
	TCHAR XBoxRecoveryKey[RECOVERY_KEY_SIZE+1];
	DWORD dwXBoxOnlineKeyVersion = 0;
	TCHAR XBoxOnlineKeyVersion[ONLINE_KEY_VERSION_SIZE+1];
	TCHAR XBoxOnlineKey[ONLINE_KEY_SIZE+1];
	DWORD dwXBoxOutputBufferSize = 0;
	BYTE XBoxOutputBuffer[512];
	DWORD dwWritePerResult = S_OK;
	DWORD dwMessageLength;
	TCHAR XBoxReportToHostBuffer[256]; // Should be large enough to contain any key/value pair
	LPCTSTR pwszTemp = NULL;
	bool bVerifyEepromContents = false;
#ifdef  _UNICODE
	bool bUnicode = true;
#else
	bool bUnicode = false;
#endif

	// Before doing anything else, unlock the hard drive.  Don't mind any errors
	// because they are normal if the drive was not locked in the first place
	UnlockXboxHardDrive (NULL, 0);

	// Get the Game Region Code
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_FACTORY_GET_VALUE, (char *)&XBoxGameRegionCodeLabel[0], (_tcslen(XBoxGameRegionCodeLabel) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoGameRegionCode())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			// Process the string here.  Report an error if it is too big or cannot be converted
			if (dwActualBytesReceived > sizeof(XBoxGameRegionCodeResult))
			{
				err_GameRegionCodeTooLarge();
				return;
			}
			memset(XBoxGameRegionCodeResult, 0, sizeof(XBoxGameRegionCodeResult)); // Clear out the buffer first
			_tcsncpy(XBoxGameRegionCodeResult, (TCHAR *)CHR.pvBufferFromHost, (sizeof(XBoxGameRegionCodeResult)/sizeof(TCHAR)) - 1);
			if ((dwXBoxGameRegion = _tcstoul(XBoxGameRegionCodeResult, 0, 16)) == 0)
			{
				if (err_GameRegionInvalid(XBoxGameRegionCodeResult))
					return;

			}
			ReportDebug(BIT0, _T("Game region found: %8.8lx"), dwXBoxGameRegion);
		}
	}

	// Get the TV Region Code
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_FACTORY_GET_VALUE, (char *)&XBoxTVRegionCodeLabel[0], (_tcslen(XBoxTVRegionCodeLabel) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoTVRegionCode())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			// Process the string here.  Report an error if it is too big or cannot be converted
			if (dwActualBytesReceived > sizeof(XBoxTVRegionCodeResult))
			{
				err_TVRegionCodeTooLarge();
				return;
			}
			memset(XBoxTVRegionCodeResult, 0, sizeof(XBoxTVRegionCodeResult)); // Clear out the buffer first
			_tcsncpy(XBoxTVRegionCodeResult, (TCHAR *)CHR.pvBufferFromHost, (sizeof(XBoxTVRegionCodeResult)/sizeof(TCHAR)) - 1);
			if ((dwXBoxTVRegion = _tcstoul(XBoxTVRegionCodeResult, 0, 16)) == 0)
			{
				if (err_TVRegionInvalid(XBoxTVRegionCodeResult))
					return;

			}
			ReportDebug(BIT0, _T("TV region found: %8.8lx"), dwXBoxTVRegion);

		}
	}

	// Get the MAC address
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_GET_MAC_ADDRESSES, NULL, 0, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoMACAddress())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			// Process the string here.  Report an error if it is too big or cannot be converted
			if (dwActualBytesReceived > sizeof(XBoxMACAddressResult))
			{
				err_MACAddressTooLarge();
				return;
			}
			memset(XBoxMACAddressResult, 0, sizeof(XBoxMACAddressResult)); // Clear out the buffer first
			_tcsncpy(XBoxMACAddressResult, (TCHAR *)CHR.pvBufferFromHost, 4);
			if ((dwXBoxMACAddressHigh = _tcstoul(XBoxMACAddressResult, 0, 16)) == 0)
			{
				memset(XBoxMACAddressResult, 0, sizeof(XBoxMACAddressResult)); // Clear out the buffer first
				_tcsncpy(XBoxMACAddressResult, (TCHAR *)CHR.pvBufferFromHost, 12);
				if (err_MACAddressInvalid(XBoxMACAddressResult))
					return;

			}
			memset(XBoxMACAddressResult, 0, sizeof(XBoxMACAddressResult)); // Clear out the buffer first
			_tcsncpy(XBoxMACAddressResult, &((TCHAR *)CHR.pvBufferFromHost)[4], 8);
			if ((dwXBoxMACAddressLow = _tcstoul(XBoxMACAddressResult, 0, 16)) == 0)
			{
				memset(XBoxMACAddressResult, 0, sizeof(XBoxMACAddressResult)); // Clear out the buffer first
				_tcsncpy(XBoxMACAddressResult, (TCHAR *)CHR.pvBufferFromHost, 12);
				if (err_MACAddressInvalid(XBoxMACAddressResult))
					return;

			}
			ReportDebug(BIT0, _T("MAC Address found: %4.4lx%8.8lx"), dwXBoxMACAddressHigh, dwXBoxMACAddressLow);
		}
	}

	// Get the serial number
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_GET_SERIAL_NUMBER, NULL, 0, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoSerialNumber())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			// Process the string here.  Report an error if it is too big or cannot be converted
			if (dwActualBytesReceived > sizeof(XBoxSerialNumberResult))
			{
				err_SerialNumberTooLarge();
				return;
			}
			memset(XBoxSerialNumberResult, 0, sizeof(XBoxSerialNumberResult)); // Clear out the buffer first
			_tcsncpy(XBoxSerialNumberResult, (TCHAR *)CHR.pvBufferFromHost, (sizeof(XBoxSerialNumberResult)/sizeof(TCHAR)) - 1);
			// Need to strip the serial number down to 12 characters from 20 before using it
			if (bUnicode)
			{
				sprintf(XBoxSerialNumberToUse, "%S", &XBoxSerialNumberResult[_tcslen(XBoxSerialNumberResult)-12]);
				ReportDebug(BIT0, _T("MB Serial Number found: %S"), XBoxSerialNumberToUse);
			}
			else
			{
				sprintf(XBoxSerialNumberToUse, "%s", &XBoxSerialNumberResult[_tcslen(XBoxSerialNumberResult)-12]);
				ReportDebug(BIT0, _T("Serial Number found: %s"), XBoxSerialNumberToUse);
			}
		}
	}

	// Get the OS version
	{
		memset(XBoxOSVersion, 0, sizeof(XBoxOSVersion)); // Clear out the buffer first
		_sntprintf(XBoxOSVersion, sizeof(XBoxOSVersion)/sizeof(TCHAR), _T("%d.%02d.%d.%02d"), XboxKrnlVersion->Major, XboxKrnlVersion->Minor, XboxKrnlVersion->Build, (XboxKrnlVersion->Qfe & 0x7FFF));

		ReportDebug(BIT0, _T("OS Version found: %s"), XBoxOSVersion);
	}

	// Get the SMC revision
	{
		ULONG uDataValue;
		// Write to the register first to reset it 
		for(i = 0; i < 3; i++)
		{			
			if ((NtStatus = HalWriteSMBusValue(0x20, 0x01, FALSE, 0x00)) != STATUS_SUCCESS)
			{
				if(err_SMCWrite(_T("Firmware Revision"), NtStatus))
					return;
			}
		}

		// Get the actual SMC Firmware Revision ID from the SMC Revision Register
		// The Rev ID is 3 bytes long (e.g. B1C, A4E)
		for(i = 0; i < 3; i++)
		{			
			if ((NtStatus = HalReadSMBusValue(0x20, 0x01, FALSE, &uDataValue)) != STATUS_SUCCESS)
			{
				if(err_SMCRead(_T("Firmware Revision"), NtStatus))
					return;
			}

			// Store the value in a char array so that it can be used as a string
			cSMCRev[i] = (char)uDataValue;
		} // end for(i = 0; i < 3; i++)

		// Terminate with Null
		cSMCRev[3] = '\0';
		if (bUnicode)
			_stprintf(XBoxSMCRev, _T("%S"), cSMCRev);
		else
			_stprintf(XBoxSMCRev, _T("%s"), cSMCRev);

		ReportDebug(BIT0, _T("SMC Revision found: %s"), XBoxSMCRev);
	}

	// Now that we are done querying values, lets have GenPerBoxData() do its job
	{
		CHostResponse CHR;
		char cMessage[64]; // Buffer in which to store the message for the host
		char *pcReturnedVals;

		*((DWORD *)&(cMessage[0])) = dwXBoxGameRegion;
		*((DWORD *)&(cMessage[4])) = dwXBoxTVRegion;
		*((BYTE *)&(cMessage[8])) = (BYTE)((dwXBoxMACAddressHigh >> 24) & 0xFF);
		*((BYTE *)&(cMessage[9])) = (BYTE)((dwXBoxMACAddressHigh >> 16) & 0xFF);
		*((BYTE *)&(cMessage[10])) = (BYTE)((dwXBoxMACAddressHigh >> 8) & 0xFF);
		*((BYTE *)&(cMessage[11])) = (BYTE)((dwXBoxMACAddressHigh) & 0xFF);
		*((BYTE *)&(cMessage[12])) = (BYTE)((dwXBoxMACAddressLow >> 24) & 0xFF);
		*((BYTE *)&(cMessage[13])) = (BYTE)((dwXBoxMACAddressLow >> 16) & 0xFF);
		*((BYTE *)&(cMessage[14])) = (BYTE)((dwXBoxMACAddressLow >> 8) & 0xFF);
		*((BYTE *)&(cMessage[15])) = (BYTE)((dwXBoxMACAddressLow) & 0xFF);
		memcpy(&cMessage[16], XBoxSerialNumberToUse, 13);

		if ((iError = g_host.iSendHost(MID_GENPERBOXDATA, cMessage, 29, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoGenPerBoxDataResponse())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			// Process the returned data here.
			// Start with the Hard Drive Key
			pcReturnedVals = (char *)CHR.pvBufferFromHost;
			if (strlen(pcReturnedVals) + 1 > sizeof(XBoxHardDriveKey)/sizeof(TCHAR))
			{
				err_HardDriveKeyTooLarge();
				return;
			}
			if (bUnicode)
				_stprintf(XBoxHardDriveKey, _T("%S"), pcReturnedVals);
			else
				_stprintf(XBoxHardDriveKey, _T("%s"), pcReturnedVals);
			pcReturnedVals = pcReturnedVals + strlen(pcReturnedVals) + 1; // Point to the next entry in the returned buffer

			// Now read the Recovery Key
			if (strlen(pcReturnedVals) + 1 > sizeof(XBoxRecoveryKey)/sizeof(TCHAR))
			{
				err_RecoveryKeyTooLarge();
				return;
			}
			if (bUnicode)
				_stprintf(XBoxRecoveryKey, _T("%S"), pcReturnedVals);
			else
				_stprintf(XBoxRecoveryKey, _T("%s"), pcReturnedVals);
			pcReturnedVals = pcReturnedVals + strlen(pcReturnedVals) + 1; // Point to the next entry in the returned buffer
			
			// Now read the Online Key Version
			dwXBoxOnlineKeyVersion = *((DWORD *)pcReturnedVals);
			_stprintf(XBoxOnlineKeyVersion, _T("%4.4lx"), dwXBoxOnlineKeyVersion & 0xFFFF);
			pcReturnedVals = pcReturnedVals + sizeof(DWORD); // Point to the next entry in the returned buffer
			
			// Now read the Online Key
			if (strlen(pcReturnedVals) + 1 > sizeof(XBoxOnlineKey)/sizeof(TCHAR))
			{
				err_OnlineKeyTooLarge();
				return;
			}
			if (bUnicode)
				_stprintf(XBoxOnlineKey, _T("%S"), pcReturnedVals);
			else
				_stprintf(XBoxOnlineKey, _T("%s"), pcReturnedVals);
			pcReturnedVals = pcReturnedVals + strlen(pcReturnedVals) + 1; // Point to the next entry in the returned buffer

			// Now read the Output Buffer Size
			dwXBoxOutputBufferSize = *((DWORD *)pcReturnedVals);
			pcReturnedVals = pcReturnedVals + sizeof(DWORD); // Point to the next entry in the returned buffer
			
			// Now read the Output Buffer contents
			if (dwXBoxOutputBufferSize > sizeof(XBoxOutputBuffer))
			{
				err_OutputBufferTooLarge();
				return;
			}
			memcpy(XBoxOutputBuffer, pcReturnedVals, dwXBoxOutputBufferSize);
			pcReturnedVals = pcReturnedVals + dwXBoxOutputBufferSize; // Point to the next entry in the returned buffer

			ReportDebug(BIT0, _T("Hard Drive Key found: %s"), XBoxHardDriveKey);
			ReportDebug(BIT0, _T("Recovery Key found: %s"), XBoxRecoveryKey);
			ReportDebug(BIT0, _T("Online key version found: %s"), XBoxOnlineKeyVersion);
			ReportDebug(BIT0, _T("Online Key found: %s"), XBoxOnlineKey);
			ReportDebug(BIT0, _T("Output buffer size found: %lx"), dwXBoxOutputBufferSize);
		}
	}

	// Write the proper data to the eeprom

	if ((dwWritePerResult = WritePerBoxData(XBoxOutputBuffer, dwXBoxOutputBufferSize)) != S_OK)
	{
		if (dwWritePerResult == NTE_BAD_LEN)
		{
			if (err_WritePerBadLength())
				return;
		}
		else if (dwWritePerResult == NTE_BAD_DATA)
		{
			if (err_WritePerBadData())
				return;
		}
		else if (dwWritePerResult == E_FAIL)
		{
			if (err_WritePerBadAccess())
				return;
		}
		else if (dwWritePerResult == NTE_NO_KEY)
		{
			if (err_WritePerBadKey())
				return;
		}
		else
		{
			if (err_WritePerUnknown())
				return;
		}
	}

	// Pad any remaining space of the keys with spaces (at Microsoft's request)
	for (i = _tcslen(XBoxHardDriveKey); i < HARD_DRIVE_KEY_SIZE; i++)
	{
		XBoxHardDriveKey[i] = ' '; // Pad the end of the string with spaces
	}
	XBoxHardDriveKey[i] = '\0'; // Null terminate

	for (i = _tcslen(XBoxRecoveryKey); i < RECOVERY_KEY_SIZE; i++)
	{
		XBoxRecoveryKey[i] = ' '; // Pad the end of the string with spaces
	}
	XBoxRecoveryKey[i] = '\0'; // Null terminate

	for (i = _tcslen(XBoxOnlineKey); i < ONLINE_KEY_SIZE; i++)
	{
		XBoxOnlineKey[i] = ' '; // Pad the end of the string with spaces
	}
	XBoxOnlineKey[i] = '\0'; // Null terminate

	for (i = _tcslen(XBoxOSVersion); i < OS_VERSION_SIZE; i++)
	{
		XBoxOSVersion[i] = ' '; // Pad the end of the string with spaces
	}
	XBoxOSVersion[i] = '\0'; // Null terminate

	// Now report the data values back to the host so that they can be stored in the database
	// Report the Hard Drive Key
	{
		dwMessageLength = (_tcslen(XBoxHardDriveKeyLabel) + _tcslen(XBoxHardDriveKey) + 2) * sizeof(TCHAR);
		if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
		{
			if (err_MessageTooLarge(dwMessageLength))
				return;
		}
		else
		{
			memcpy(&XBoxReportToHostBuffer[0], XBoxHardDriveKeyLabel, (_tcslen(XBoxHardDriveKeyLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
			memcpy(&XBoxReportToHostBuffer[_tcslen(XBoxHardDriveKeyLabel) + 1], XBoxHardDriveKey, (_tcslen(XBoxHardDriveKey) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
		}
		if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	// Report the Recovery Key
	{
		dwMessageLength = (_tcslen(XBoxRecoveryKeyLabel) + _tcslen(XBoxRecoveryKey) + 2) * sizeof(TCHAR);
		if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
		{
			if (err_MessageTooLarge(dwMessageLength))
				return;
		}
		else
		{
			memcpy(&XBoxReportToHostBuffer[0], XBoxRecoveryKeyLabel, (_tcslen(XBoxRecoveryKeyLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
			memcpy(&XBoxReportToHostBuffer[_tcslen(XBoxRecoveryKeyLabel) + 1], XBoxRecoveryKey, (_tcslen(XBoxRecoveryKey) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
		}
		if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	// Report the Online Key Version
	{
		dwMessageLength = (_tcslen(XBoxOnlineKeyVersionLabel) + _tcslen(XBoxOnlineKeyVersion) + 2) * sizeof(TCHAR);
		if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
		{
			if (err_MessageTooLarge(dwMessageLength))
				return;
		}
		else
		{
			memcpy(&XBoxReportToHostBuffer[0], XBoxOnlineKeyVersionLabel, (_tcslen(XBoxOnlineKeyVersionLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
			memcpy(&XBoxReportToHostBuffer[_tcslen(XBoxOnlineKeyVersionLabel) + 1], XBoxOnlineKeyVersion, (_tcslen(XBoxOnlineKeyVersion) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
		}
		if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	// Report the Online Key
	{
		dwMessageLength = (_tcslen(XBoxOnlineKeyLabel) + _tcslen(XBoxOnlineKey) + 2) * sizeof(TCHAR);
		if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
		{
			if (err_MessageTooLarge(dwMessageLength))
				return;
		}
		else
		{
			memcpy(&XBoxReportToHostBuffer[0], XBoxOnlineKeyLabel, (_tcslen(XBoxOnlineKeyLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
			memcpy(&XBoxReportToHostBuffer[_tcslen(XBoxOnlineKeyLabel) + 1], XBoxOnlineKey, (_tcslen(XBoxOnlineKey) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
		}
		if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	// Report the OS Version
	{
		dwMessageLength = (_tcslen(XBoxOSVersionLabel) + _tcslen(XBoxOSVersion) + 2) * sizeof(TCHAR);
		if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
		{
			if (err_MessageTooLarge(dwMessageLength))
				return;
		}
		else
		{
			memcpy(&XBoxReportToHostBuffer[0], XBoxOSVersionLabel, (_tcslen(XBoxOSVersionLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
			memcpy(&XBoxReportToHostBuffer[_tcslen(XBoxOSVersionLabel) + 1], XBoxOSVersion, (_tcslen(XBoxOSVersion) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
		}
		if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	// Report the SMC Revision
	{
		dwMessageLength = (_tcslen(XBoxSMCRevLabel) + _tcslen(XBoxSMCRev) + 2) * sizeof(TCHAR);
		if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
		{
			if (err_MessageTooLarge(dwMessageLength))
				return;
		}
		else
		{
			memcpy(&XBoxReportToHostBuffer[0], XBoxSMCRevLabel, (_tcslen(XBoxSMCRevLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
			memcpy(&XBoxReportToHostBuffer[_tcslen(XBoxSMCRevLabel) + 1], XBoxSMCRev, (_tcslen(XBoxSMCRev) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
		}
		if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}

	bVerifyEepromContents = false;
	if ((pwszTemp = GetCfgString (_T("VerifyEepromContents"), NULL)) != NULL)
	{
		if (_tcsicmp(pwszTemp, _T("true")) == 0)
			bVerifyEepromContents = true;
	}
	// Make sure that the serial number and MAC address were really written correctly.
	if (bVerifyEepromContents)
	{
		char LocalSerialNumber[13];
		BYTE LocalMACAddress[6];
		WORD wLocalMACAddressHigh;
		DWORD dwLocalMACAddressLow;
		ULONG Size, Type, Error;

		// Check the serial number
		Error = XQueryValue(0x100, &Type, LocalSerialNumber, sizeof LocalSerialNumber, &Size);
		if(Error != NO_ERROR)
		{
			if (err_NoEepromSerialNumber())
				return;
		}
		else // Do the comparison
		{
			LocalSerialNumber[12] = 0;
			ReportDebug(BIT0, _T("MB Serial Number from eeprom: %S"), LocalSerialNumber);
			if (stricmp(XBoxSerialNumberToUse, LocalSerialNumber) != 0)
			{
				// Report a mismatch
				if (err_SerialNumberMismatch(XBoxSerialNumberToUse, LocalSerialNumber))
					return;
			}
		}
		// Check the MAC address
		Error = XQueryValue(0x101, &Type, LocalMACAddress, sizeof LocalMACAddress, &Size);
		if(Error != NO_ERROR)
		{
			if (err_NoMACAddress())
				return;
		}
		else // Do the comparison
		{
			wLocalMACAddressHigh = ((WORD)LocalMACAddress[0] << 8) | (WORD)LocalMACAddress[1];
			dwLocalMACAddressLow = ((DWORD)LocalMACAddress[2] << 24) | ((DWORD)LocalMACAddress[3] << 16) | ((DWORD)LocalMACAddress[4] << 8) | (DWORD)LocalMACAddress[5];
			ReportDebug(BIT0, _T("MAC Address found from eeprom: %4.4lx%8.8lx"), (DWORD)wLocalMACAddressHigh, dwLocalMACAddressLow);
			if ((dwLocalMACAddressLow != dwXBoxMACAddressLow) || ((DWORD)wLocalMACAddressHigh != dwXBoxMACAddressHigh))
			{
				// Report a mismatch
				if (err_MACAddressMismatch(dwXBoxMACAddressHigh, dwXBoxMACAddressLow, (DWORD)wLocalMACAddressHigh, dwLocalMACAddressLow))
					return;
			}
		}
	}

#endif
}

//******************************************************************
// Title: verify_per_box_information
//
// Abstract: This utility checks the eeprom on the XBox to make sure it contains
//           valid data, and then disables the manufacturing region so that the
//           XBox can no longer boot from the manufacturing boot CD/DVD.
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, verify_per_box_information, 5)
{
#ifdef _XBOX
	DWORD dwVerifyPerResult = S_OK;

	// Verify the eeprom data and lock the hard drive
	if ((dwVerifyPerResult = VerifyPerBoxData()) != S_OK)
	{
		if (dwVerifyPerResult == NTE_BAD_DATA)
		{
			if (err_WritePerBadData())
				return;
		}
		else if (dwVerifyPerResult == E_FAIL)
		{
			if (err_VerifyPerBadAccess())
				return;
		}
		else if (dwVerifyPerResult == NTE_NO_KEY)
		{
			if (err_VerifyPerBadKey())
				return;
		}
		else
		{
			if (err_VerifyPerUnknown())
				return;
		}
	}
#endif
}

//******************************************************************
// Title: report_xmta_versions_and_checksums
//
// Abstract: This utility reports the versions and chechecksums of
//           the XMTA test executive and the XMTA configuration files
//           (xmta.ini and xmta2.ini)
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, report_xmta_versions_and_checksums, 6)
{
	DWORD dwActualBytesReceived = 0, dwErrorCodeFromHost = 0;
	int iError;
	TCHAR XMTAXBOXName[] = _T("xmtaxbox.xbe");
	TCHAR XMTAININame1[] = _T("xmta.ini");
	TCHAR XMTAININame2[] = _T("xmta2.ini");
	TCHAR XMTAXBOXVersionLabel[] = XMTA_SOFTWARE_REV; // Written to host
	TCHAR INIVersionLabel[] = XMTA_SOFTWARE_CFG; // Written to host
	DWORD dwXMTAChecksum = 0;
	DWORD dwINIChecksum = 0;
	DWORD i;
	DWORD *pdwReturnedBuffer = NULL;
	DWORD dwRemainder, dwRemValue;
	DWORD dwMessageLength;
	TCHAR XMTAXBOXVersion[31];
	TCHAR INIVersion[31];
	TCHAR XBoxReportToHostBuffer[100]; // Should be large enough to contain these key/value pairs

	// Get the XMTAXBOX.XBE file and checksum it
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_GET_FILE, (char *)&XMTAXBOXName[0], (_tcslen(XMTAXBOXName) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoFileReturned(XMTAXBOXName))
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			dwXMTAChecksum = dwActualBytesReceived;
			pdwReturnedBuffer = (DWORD *)CHR.pvBufferFromHost;
			for (i = 0; i < dwActualBytesReceived/sizeof(DWORD); i++)
			{
				dwXMTAChecksum = dwXMTAChecksum + pdwReturnedBuffer[i];
			}
			dwRemainder = dwActualBytesReceived - (i*sizeof(DWORD));
			if (dwRemainder > 0)
			{
				dwRemValue = 0;
				memcpy(&dwRemValue, &pdwReturnedBuffer[i], dwRemainder);
				dwXMTAChecksum = dwXMTAChecksum + dwRemValue;
			}
		}
	}

	// Get the XMTA.INI file and checksum it
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_GET_FILE, (char *)&XMTAININame1[0], (_tcslen(XMTAININame1) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoFileReturned(XMTAININame1))
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			dwINIChecksum = dwActualBytesReceived;
			pdwReturnedBuffer = (DWORD *)CHR.pvBufferFromHost;
			for (i = 0; i < dwActualBytesReceived/sizeof(DWORD); i++)
			{
				dwINIChecksum = dwINIChecksum + pdwReturnedBuffer[i];
			}
			dwRemainder = dwActualBytesReceived - (i*sizeof(DWORD));
			if (dwRemainder > 0)
			{
				dwRemValue = 0;
				memcpy(&dwRemValue, &pdwReturnedBuffer[i], dwRemainder);
				dwINIChecksum = dwINIChecksum + dwRemValue;
			}
		}
	}

	// Get the XMTA2.INI file and checksum it; don't error if the file does not exist
	{
		CHostResponse CHR;
		if ((iError = g_host.iSendHost(MID_GET_FILE, (char *)&XMTAININame2[0], (_tcslen(XMTAININame2) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Don't care if XMTA2.INI doesn't exist
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// Don't care if XMTA2.INI doesn't exist
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			dwINIChecksum = dwActualBytesReceived;
			pdwReturnedBuffer = (DWORD *)CHR.pvBufferFromHost;
			for (i = 0; i < dwActualBytesReceived/sizeof(DWORD); i++)
			{
				dwINIChecksum = dwINIChecksum + pdwReturnedBuffer[i];
			}
			dwRemainder = dwActualBytesReceived - (i*sizeof(DWORD));
			if (dwRemainder > 0)
			{
				dwRemValue = 0;
				memcpy(&dwRemValue, &pdwReturnedBuffer[i], dwRemainder);
				dwINIChecksum = dwINIChecksum + dwRemValue;
			}
		}
	}

	// Now let's create the full version:checksum strings
	m_standard = GetCfgString( L"standard", NULL);
	_sntprintf(XMTAXBOXVersion, (sizeof(XMTAXBOXVersion)/sizeof(TCHAR)) - 1, _T("%s:%8.8lx"), g_tcXMTAVersionNumber, dwXMTAChecksum);
	_sntprintf(INIVersion, (sizeof(INIVersion)/sizeof(TCHAR)) - 1, _T("%s:%8.8lx"), GetCfgString( _T("ini_file_version_number"), _T("0000.0000.0000.0000")), dwINIChecksum);

	ReportDebug(BIT0, _T("XMTA Version:Checksum: %s"), XMTAXBOXVersion);
	ReportDebug(BIT0, _T("INI Version:Checksum: %s"), INIVersion);

	// Report XMTAXBOX version to the host
	dwMessageLength = (_tcslen(XMTAXBOXVersionLabel) + _tcslen(XMTAXBOXVersion) + 2) * sizeof(TCHAR);
	if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
	{
		if (err_MessageTooLarge(dwMessageLength))
			return;
	}
	else
	{
		memcpy(&XBoxReportToHostBuffer[0], XMTAXBOXVersionLabel, (_tcslen(XMTAXBOXVersionLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
		memcpy(&XBoxReportToHostBuffer[_tcslen(XMTAXBOXVersionLabel) + 1], XMTAXBOXVersion, (_tcslen(XMTAXBOXVersion) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
	}
	if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		if (err_HostCommunicationError(iError))
			return;
	}

	// Report XMTA.INI version to the host
	dwMessageLength = (_tcslen(INIVersionLabel) + _tcslen(INIVersion) + 2) * sizeof(TCHAR);
	if (dwMessageLength > sizeof(XBoxReportToHostBuffer))
	{
		if (err_MessageTooLarge(dwMessageLength))
			return;
	}
	else
	{
		memcpy(&XBoxReportToHostBuffer[0], INIVersionLabel, (_tcslen(INIVersionLabel) + 1) * sizeof(TCHAR)); // Copy the label key and the terminator
		memcpy(&XBoxReportToHostBuffer[_tcslen(INIVersionLabel) + 1], INIVersion, (_tcslen(INIVersion) + 1) * sizeof(TCHAR)); // Copy the value and the terminator
	}
	if ((iError = g_host.iSendHost(MID_FACTORY_SET_VALUE, (char *)XBoxReportToHostBuffer, dwMessageLength)) != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		if (err_HostCommunicationError(iError))
			return;
	}

}

//******************************************************************
// Title: delete_file
//
// Abstract: This utility deletes the file specified in the configuration parameter
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, delete_file, 7)
{
	char szFilename[MAX_PATH];
#ifdef  _UNICODE
	bool bUnicode = true;
#else
	bool bUnicode = false;
#endif

	LPCTSTR	tcParameter = GetCfgString( _T("file_to_delete"), NULL);
	
	if (tcParameter != NULL)
	{
		if (bUnicode)
		{
			sprintf(szFilename, "%S", tcParameter);
		}
		else
		{
			sprintf(szFilename, "%s", tcParameter);
		}
		if (!DeleteFileA(szFilename))
		{
			ReportDebug(BIT0, _T("GetLastError reports: %lu"), GetLastError());
		}
	}
}

bool CXModuleTool::bMountUtilityDrive ()
{
#ifdef _XBOX
	BOOL bResult;

	if (GetFileAttributesA("Z:\\") == -1) // Only mount the drive if it is not already mounted (otherwise could hang)
	{
		bResult = XMountUtilityDrive(FALSE);
		if (!bResult)
		{
			if (err_CouldNotMountUtilityDrive(GetLastError()))
				return false;
		}
	}
#endif
	return true;
}

//******************************************************************
// Title: mount_utility_drive
//
// Abstract: This utility mounts the XBOX utility drive (drive Z) for XMTA
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, mount_utility_drive, 8)
{
	bMountUtilityDrive();
}

//******************************************************************
// Title: check_chipset_revisions
//
// Abstract: This utility compares the revisions of the XBox chipset to
//           expected values.
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, check_chipset_revisions, 9)
{
#ifdef _XBOX
	TCHAR RevParamName[80];
	LPCTSTR pwsAllowed, pwsNotAllowed;
	DWORD x;
	int RevRead;

	ReportStatistic(GPU_REVISION, _T("%2.2lx"), (DWORD)XboxHardwareInfo->GpuRevision);
	ReportStatistic(MCP_REVISION, _T("%2.2lx"), (DWORD)XboxHardwareInfo->McpRevision);

	pwsAllowed = GetCfgString(_T("GPURevisionAllowed[0]"), NULL);
	pwsNotAllowed = GetCfgString(_T("GPURevisionNotAllowed[0]"), NULL);

	// The list of allowed and not allowed revisions is mutually exclusive. So the
	// GPURevisionAllowed[0] and GPURevisionNotAllowed[0] parameters both cannot exist.
	if((pwsAllowed != NULL) && (pwsNotAllowed != NULL))
	{
		if (err_GPURevisionXor())
			return;
	}
	// If neither ChipsetRevisionAllowed[#] nor ChipsetRevisionNotAllowed[#] parameters exist,
	// there are no revision restrictions.
	else if((pwsAllowed == NULL) && (pwsNotAllowed == NULL))
	{
		ReportDebug(BIT0,_T("Neither GPURevisionAllowed[#] nor GPURevisionNotAllowed[#] list is specified so passing the test.\n"));
	}
	else
	{
		if (pwsNotAllowed != NULL) // Check the not-allowed list
		{
			for(x=0;x<100;x++)
			{
				_stprintf(RevParamName,_T("GPURevisionNotAllowed[%d]"),x);
				if ((RevRead = GetCfgInt (RevParamName, -1)) == -1)
					break;
				// Now see if this matches the actual revision
				if((DWORD)RevRead == (DWORD)XboxHardwareInfo->GpuRevision)
				{
					if (err_GPURevisionNotAllowed((DWORD)XboxHardwareInfo->GpuRevision))
						return;
					break;
				}
			}
		}
		else // Check the allowed list
		{
			for(x=0;x<100;x++)
			{
				_stprintf(RevParamName,_T("GPURevisionAllowed[%d]"),x);
				if ((RevRead = GetCfgInt (RevParamName, -1)) == -1)
				{
					if (err_GPURevisionNotAllowed((DWORD)XboxHardwareInfo->GpuRevision))
						return;
					break;
				}
				// Now see if this matches the actual revision
				if((DWORD)RevRead == (DWORD)XboxHardwareInfo->GpuRevision)
				{
					break;
				}
			}
		}
	}


	// Do this all over again for the MCP Revision

	pwsAllowed = GetCfgString(_T("MCPRevisionAllowed[0]"), NULL);
	pwsNotAllowed = GetCfgString(_T("MCPRevisionNotAllowed[0]"), NULL);

	// The list of allowed and not allowed revisions is mutually exclusive. So the
	// MCPRevisionAllowed[0] and MCPRevisionNotAllowed[0] parameters both cannot exist.
	if((pwsAllowed != NULL) && (pwsNotAllowed != NULL))
	{
		if (err_MCPRevisionXor())
			return;
	}
	// If neither ChipsetRevisionAllowed[#] nor ChipsetRevisionNotAllowed[#] parameters exist,
	// there are no revision restrictions.
	else if((pwsAllowed == NULL) && (pwsNotAllowed == NULL))
	{
		ReportDebug(BIT0,_T("Neither MCPRevisionAllowed[#] nor MCPRevisionNotAllowed[#] list is specified so passing the test.\n"));
	}
	else
	{
		if (pwsNotAllowed != NULL) // Check the not-allowed list
		{
			for(x=0;x<100;x++)
			{
				_stprintf(RevParamName,_T("MCPRevisionNotAllowed[%d]"),x);
				if ((RevRead = GetCfgInt (RevParamName, -1)) == -1)
					break;
				// Now see if this matches the actual revision
				if((DWORD)RevRead == (DWORD)XboxHardwareInfo->McpRevision)
				{
					if (err_MCPRevisionNotAllowed((DWORD)XboxHardwareInfo->McpRevision))
						return;
					break;
				}
			}
		}
		else // Check the allowed list
		{
			for(x=0;x<100;x++)
			{
				_stprintf(RevParamName,_T("MCPRevisionAllowed[%d]"),x);
				if ((RevRead = GetCfgInt (RevParamName, -1)) == -1)
				{
					if (err_MCPRevisionNotAllowed((DWORD)XboxHardwareInfo->McpRevision))
						return;
					break;
				}
				// Now see if this matches the actual revision
				if((DWORD)RevRead == (DWORD)XboxHardwareInfo->McpRevision)
				{
					break;
				}
			}
		}
	}
#endif
}

//******************************************************************
// Title: mount_dashboard_partition
//
// Abstract: This utility mounts the XBOX dashboard partition as drive Y:
//
// Uses config parameters:
//           none
//******************************************************************
#ifdef _XBOX
// NTSTATUS
typedef LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#define NTHALAPI     DECLSPEC_IMPORT



typedef struct _LSA_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

#ifndef _NTDEF_
typedef LSA_STRING STRING, *PSTRING ;
#endif

typedef STRING OBJECT_STRING;
typedef PSTRING POBJECT_STRING;


extern "C"
{
NTSYSCALLAPI
NTSTATUS
NTAPI
IoCreateSymbolicLink(
	IN POBJECT_STRING SymbolicLinkName,
	IN POBJECT_STRING DeviceName
	);
}
#endif // #ifdef XBOX

bool CXModuleTool::bMountDashboardPartition ()
{
#ifdef _XBOX
    OBJECT_STRING strDosDevice, strPath;
    NTSTATUS status;

	if (GetFileAttributesA("Y:\\") == -1) // Only mount the drive if it is not already mounted (otherwise could hang)
	{
		strDosDevice.Buffer = "\\??\\Y:";
		strDosDevice.Length = (USHORT)strlen(strDosDevice.Buffer);
		strDosDevice.MaximumLength = strDosDevice.Length + 1;

		strPath.Buffer = "\\Device\\Harddisk0\\partition2";
		strPath.Length = (USHORT)strlen(strPath.Buffer);
		strPath.MaximumLength = strPath.Length + 1;

		status = IoCreateSymbolicLink(&strDosDevice, &strPath);
		if (status != STATUS_SUCCESS)
		{
			if (err_CouldNotMountDashboardPartition(GetLastError()))
				return false;
		}
	}
#endif // #ifdef XBOX
	return true;
}


IMPLEMENT_TESTUNLOCKED (Tool, mount_dashboard_partition, 10)
{
	bMountDashboardPartition();
}

//******************************************************************
// Title: unlock_xbox_hard_drive
//
// Abstract: This utility unlocks the hard drive using the Microsoft-supplied API
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, unlock_xbox_hard_drive, 11)
{
#ifdef _XBOX
	UnlockXboxHardDrive (NULL, 0);
#endif // #ifdef XBOX
}

//******************************************************************
// Title: compare_scart_status_voltage
//
// Abstract: This utility compares the voltage of the SCART Status line
//           to a specified upper and lower limit
//
// Uses config parameters:
//           scart_status_lower_limit
//           scart_status_upper_limit
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, compare_scart_status_voltage, 12)
{
	float fStatusVoltage;
	CHostResponse CHR;
	int iError;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	double dblSCARTStatusLowerLimit = 0.0, dblSCARTStatusUpperLimit = 0.0;
	LPCTSTR pwszStringParam;

	if ((pwszStringParam = GetCfgString(_T("scart_status_lower_limit"), NULL)) == NULL)
	{
		if (err_BADPARAMETER(_T("scart_status_lower_limit")))
			return;
	}
	else
	{
		if ((dblSCARTStatusLowerLimit = wcstod(pwszStringParam, NULL)) == 0)
			dblSCARTStatusLowerLimit = 0.0;
	}
	if ((pwszStringParam = GetCfgString(_T("scart_status_upper_limit"), NULL)) == NULL)
	{
		if (err_BADPARAMETER(_T("scart_status_upper_limit")))
			return;
	}
	else
	{
		if ((dblSCARTStatusUpperLimit = wcstod(pwszStringParam, NULL)) == 0)
			dblSCARTStatusUpperLimit = 0.0;
	}

	// Use the full version of iSendHost because a response is expected.
	// No message is sent, only response is received after writing to the Fan Speed register.
	// This message will receive several values, one of which is the STATUS line voltage
	if ((iError = g_host.iSendHost(MID_XBOX_SENSOR_LINES, NULL, NULL, CHR, &dwActualBytesReceived, 
		 &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			return;
		}
		
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			err_HostCommunicationError(iError);
			return;
		}
	}

	// Don't access the response buffer if it is NULL
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived < 19)) 
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		err_SCARTStatusNotReceivedFromHost();
		return;
	} 
	
	else // The response is not NULL, and is not an error message, so process it
	{
		// Copy the data received to a local buffer for processing. The fan voltage is in "float"
		// so copy as many bytes as are represented by a float variable (mostly 4).
		memcpy(&fStatusVoltage, (char *)(CHR.pvBufferFromHost) + 12, sizeof(float));

		fStatusVoltage = fStatusVoltage * 2;  // Multiply by 2 because the TIU board has a divide-by-two resistor netork on this line
		if ((fStatusVoltage < dblSCARTStatusLowerLimit) || (fStatusVoltage > dblSCARTStatusUpperLimit))
		{
			if (err_SCARTStatusWrongVoltage(fStatusVoltage, dblSCARTStatusLowerLimit, dblSCARTStatusUpperLimit))
				return;
		}
	}

	return;
}

//******************************************************************
// Title: compare_dvd_firmware_revision
//
// Abstract: This test compares the DVD firmware revision with expected values
//
// Uses config parameters:
//           DVDRevisionAllowed[X]
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, compare_dvd_firmware_revision, 13)
{
#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#define CTL_CODE(DeviceType, Function, Method, Access) ( \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )

#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_CONTROLLER          0x00000004

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define FILE_ANY_ACCESS                 0

#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER

#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)



#pragma pack(push, 1)

 typedef struct _IDEREGS {
        UCHAR    bFeaturesReg;           // Used for specifying SMART "commands".
        UCHAR    bSectorCountReg;        // IDE sector count register
        UCHAR    bSectorNumberReg;       // IDE sector number register
        UCHAR    bCylLowReg;             // IDE low order cylinder value
        UCHAR    bCylHighReg;            // IDE high order cylinder value
        UCHAR    bDriveHeadReg;          // IDE drive/head register
        UCHAR    bCommandReg;            // Actual IDE command.
        UCHAR    bHostSendsData;         // Non-zero if host sends data to drive
} IDEREGS, *PIDEREGS, *LPIDEREGS;

typedef struct _ATA_PASS_THROUGH {
    IDEREGS IdeReg;
    ULONG   DataBufferSize;             // byte size of DataBuffer[]
    PVOID   DataBuffer;
} ATA_PASS_THROUGH, *PATA_PASS_THROUGH;

typedef struct _IDE_IDENTIFY_DATA {
    USHORT GeneralConfiguration;                // word 0
    USHORT NumberOfCylinders;                   // word 1
    USHORT Reserved1;                           // word 2
    USHORT NumberOfHeads;                       // word 3
    USHORT Reserved2[2];                        // word 4-5
    USHORT NumberOfSectorsPerTrack;             // word 6
    USHORT Reserved3[3];                        // word 7-9
    UCHAR SerialNumber[20];                     // word 10-19
    USHORT Reserved4[3];                        // word 20-22
    UCHAR FirmwareRevision[8];                  // word 23-26
    UCHAR ModelNumber[40];                      // word 27-46
    USHORT MaximumBlockTransfer : 8;            // word 47
    USHORT Reserved5 : 8;
    USHORT Reserved6;                           // word 48
    USHORT Capabilities;                        // word 49
    USHORT Reserved7;                           // word 50
    USHORT Reserved8 : 8;                       // word 51
    USHORT PioCycleTimingMode : 8;
    USHORT Reserved9;                           // word 52
    USHORT TranslationFieldsValid : 3;          // word 53
    USHORT Reserved10 : 13;
    USHORT NumberOfCurrentCylinders;            // word 54
    USHORT NumberOfCurrentHeads;                // word 55
    USHORT CurrentSectorsPerTrack;              // word 56
    ULONG CurrentSectorCapacity;                // word 57-58
    USHORT CurrentMultiSectorSetting;           // word 59
    ULONG UserAddressableSectors;               // word 60-61
    USHORT SingleWordDMASupport : 8;            // word 62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;             // word 63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;                // word 64
    USHORT Reserved11 : 8;
    USHORT MinimumMWXferCycleTime;              // word 65
    USHORT RecommendedMWXferCycleTime;          // word 66
    USHORT MinimumPIOCycleTime;                 // word 67
    USHORT MinimumPIOCycleTimeIORDY;            // word 68
    USHORT Reserved12[11];                      // word 69-79
    USHORT MajorRevision;                       // word 80
    USHORT MinorRevision;                       // word 81
    USHORT Reserved13[6];                       // word 82-87
    USHORT UltraDMASupport : 8;                 // word 88
    USHORT UltraDMAActive : 8;
    USHORT Reserved14[38];                      // word 89-126
    USHORT MediaStatusNotification : 2;         // word 127
    USHORT Reserved15 : 6;
    USHORT DeviceWriteProtect : 1;
    USHORT Reserved16 : 7;
    USHORT SecuritySupported : 1;               // word 128
    USHORT SecurityEnabled : 1;
    USHORT SecurityLocked : 1;
    USHORT SecurityFrozen : 1;
    USHORT SecurityCountExpired : 1;
    USHORT SecurityEraseSupported : 1;
    USHORT Reserved17 : 2;
    USHORT SecurityLevel : 1;
    USHORT Reserved18 : 7;
    USHORT Reserved19[127];                     // word 129-255
} IDE_IDENTIFY_DATA, *PIDE_IDENTIFY_DATA;

#pragma pack(pop)

	unsigned i;
	LPCTSTR pwszTemp = NULL;
	DWORD dwNumOfRevisions;
	wchar_t wszTempString[64];
	HANDLE hDevice = INVALID_HANDLE_VALUE;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;
	char model[64], serial[64], firmware[64];
	wchar_t XBoxDVDVersion[20];

	memset(model, 0, 64);
	memset(serial, 0, 64);
	memset(firmware, 0, 64);

	// Get DVDRevisionAllowed[] parameter list
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"DVDRevisionAllowed[%lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	dwNumOfRevisions = i;

	// Now get the actual revision information from the DVD drive
	hDevice = CreateFileA(
		"cdrom0:",
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_NO_BUFFERING,
		NULL); 

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		err_OPEN_FILE_P1L("cdrom0:");
		return;
	}

	atapt->DataBufferSize = 512;
	atapt->DataBuffer = atapt + 1;

	atapt->IdeReg.bFeaturesReg     = 0;
	atapt->IdeReg.bSectorCountReg  = 0;
	atapt->IdeReg.bSectorNumberReg = 0;
	atapt->IdeReg.bCylLowReg       = 0;
	atapt->IdeReg.bCylHighReg      = 0;
	atapt->IdeReg.bDriveHeadReg    = 0;
	atapt->IdeReg.bHostSendsData   = 0;

	atapt->IdeReg.bCommandReg = 0xA1;

	DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
	CloseHandle(hDevice);
	PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

	for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
	{
		model[i + 0] = IdData->ModelNumber[i + 1];
		model[i + 1] = IdData->ModelNumber[i + 0];
	}
	model[i] = 0;

	for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
	{
		serial[i + 0] = IdData->SerialNumber[i + 1];
		serial[i + 1] = IdData->SerialNumber[i + 0];
	}
	serial[i] = 0;

	for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
	{
		firmware[i + 0] = IdData->FirmwareRevision[i + 1];
		firmware[i + 1] = IdData->FirmwareRevision[i + 0];
	}
	firmware[i] = 0;
	while (i > 0)
	{
		if (firmware[i-1] == ' ')
		{
			firmware[i-1] = 0;
			i--;
		}
		else
			break;
	}
	memset(XBoxDVDVersion, 0, sizeof(XBoxDVDVersion)); // Clear out the buffer first
	_snwprintf(XBoxDVDVersion, sizeof(XBoxDVDVersion)/sizeof(wchar_t), L"%S", firmware);
	ReportDebug(BIT0, L"DVD Firmware rev = %s", XBoxDVDVersion);
	ReportStatistic(DVD_FIRMWARE_REVISION, L"%s", XBoxDVDVersion);
	for (i = 0; i < dwNumOfRevisions; i++)
	{
		swprintf(wszTempString, L"DVDRevisionAllowed[%lu]", i);
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			err_BADPARAMETER(wszTempString);
		else
		{
			if(wcsicmp(pwszTemp, XBoxDVDVersion) == 0) // Strings match
				break;
		}
	}
	if (i == dwNumOfRevisions)
		err_BadDVDRevision(XBoxDVDVersion);

}

//******************************************************************
// Title: compare_kernel_revision
//
// Abstract: This test compares the kernel revision with expected values
//
// Uses config parameters:
//           KernelRevisionAllowed[X]
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, compare_kernel_revision, 14)
{
#ifdef _XBOX
	#define OS_VERSION_SIZE           20
	wchar_t XBoxOSVersion[OS_VERSION_SIZE+1];
	DWORD i;
	LPCTSTR pwszTemp = NULL;
	DWORD dwNumOfRevisions;
	wchar_t wszTempString[64];

	// Get KernelRevisionAllowed[] parameter list
	i = 0;
	for (;;)
	{
		swprintf(wszTempString, L"KernelRevisionAllowed[%lu]", i);
		// Get it as a string so that we can compare it to NULL
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			break;
		i++;
	}
	dwNumOfRevisions = i;

	// Now get the actual revision information from the Kernel
	memset(XBoxOSVersion, 0, sizeof(XBoxOSVersion)); // Clear out the buffer first
	_snwprintf(XBoxOSVersion, sizeof(XBoxOSVersion)/sizeof(wchar_t), L"%d.%02d.%d.%02d", XboxKrnlVersion->Major, XboxKrnlVersion->Minor, XboxKrnlVersion->Build, (XboxKrnlVersion->Qfe & 0x7FFF));
	ReportDebug(BIT0, L"OS Version found: %s", XBoxOSVersion);

	for (i = 0; i < dwNumOfRevisions; i++)
	{
		swprintf(wszTempString, L"KernelRevisionAllowed[%lu]", i);
		if ((pwszTemp = GetCfgString (wszTempString, NULL)) == NULL)
			err_BADPARAMETER(wszTempString);
		else
		{
			if(wcsicmp(pwszTemp, XBoxOSVersion) == 0) // Strings match
				break;
		}
	}
	if (i == dwNumOfRevisions)
		err_BadKernelRevision(XBoxOSVersion);
#endif // #ifdef XBOX
}

#define UEM_MINIMUM_KERNAL_BUILD 4031
//******************************************************************
// Title: set_uem_state
//
// Abstract: This test sets the EUEM reboot behavior to either retry boot
//           on UEM (true), or fail on UEM (false)
//
// Uses config parameters:
//           SetFatalErrorRetryFlag
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, set_uem_state, 15)
{
	LPCTSTR pwszTemp = NULL;
	bool bSetFatalErrorRetryFlag = true;

	// Get the revision information from the Kernel
	if (XboxKrnlVersion->Build >= UEM_MINIMUM_KERNAL_BUILD)
	{
		if ((pwszTemp = GetCfgString (_T("SetFatalErrorRetryFlag"), NULL)) != NULL)
		{
			if (_tcsicmp(pwszTemp, _T("false")) == 0)
				bSetFatalErrorRetryFlag = false;
		}
		if (FAILED(SetFatalErrorRetryFlag(bSetFatalErrorRetryFlag)))
		{
			err_SettingFatalErrorRetryFlag();
			return;
		}
	}
}

//******************************************************************
// Title: clear_uem_error_history
//
// Abstract: This utility clears the UEM error history.  This is run right before the end of XTest
//
// Uses config parameters:
//           None.
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, clear_uem_error_history, 16)
{
	// Get the revision information from the Kernel
	if (XboxKrnlVersion->Build >= UEM_MINIMUM_KERNAL_BUILD)
	{
		if (FAILED(ClearFatalErrorHistory()))
		{
			err_ClearFatalErrorHistory();
			return;
		}
	}
}

//******************************************************************
// Title: check_for_uem_error
//
// Abstract: This test checks for UEM errors and reports any UEM error condition
//
// Uses config parameters:
//           UEMTotalErrorsAllowed
//           UEMCoreDigitalErrorsAllowed
//           UEMBadEepromErrorsAllowed
//           UEMBadRamErrorsAllowed
//           UEMHDDNotLockedErrorsAllowed
//           UEMHDDCannotUnlockErrorsAllowed
//           UEMHDDTimeoutErrorsAllowed
//           UEMHDDNotFoundErrorsAllowed
//           UEMHDDBadConfigErrorsAllowed
//           UEMDVDTimeoutErrorsAllowed
//           UEMDVDNotFoundErrorsAllowed
//           UEMDVDBadConfigErrorsAllowed
//           UEMXBEDashGenericErrorsAllowed
//           UEMXBEDashErrorsAllowed
//           UEMXBEDashSettingsErrorsAllowed
//           UEMXBEDashX2PassErrorsAllowed
//           UEMRebootRoutineErrorsAllowed
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, check_for_uem_error, 17)
{
#define UEMTotalErrors _T("UEMTotalErrors")
#define UEMCoreDigitalError _T("UEMCoreDigitalError")
#define UEMBadEepromError _T("UEMBadEepromError")
#define UEMBadRamError _T("UEMBadRamError")
#define UEMHDDNotLockedError _T("UEMHDDNotLockedError")
#define UEMHDDCannotUnlockError _T("UEMHDDCannotUnlockError")
#define UEMHDDTimeoutError _T("UEMHDDTimeoutError")
#define UEMHDDNotFoundError _T("UEMHDDNotFoundError")
#define UEMHDDBadConfigError _T("UEMHDDBadConfigError")
#define UEMDVDTimeoutError _T("UEMDVDTimeoutError")
#define UEMDVDNotFoundError _T("UEMDVDNotFoundError")
#define UEMDVDBadConfigError _T("UEMDVDBadConfigError")
#define UEMXBEDashGenericError _T("UEMXBEDashGenericError")
#define UEMXBEDashError _T("UEMXBEDashError")
#define UEMXBEDashSettingsError _T("UEMXBEDashSettingsError")
#define UEMXBEDashX2PassError _T("UEMXBEDashX2PassError")
#define UEMRebootRoutineError _T("UEMRebootRoutineError")
#define UEMUnknownError _T("UEMUnknownError")


	TCHAR tszTemp[80];
	LPCTSTR ptszErrorType = NULL;
	DWORD dwFatalErrorCode;
	DWORD dwUEMTotalErrorsAllowed, dwUEMNumSpecificErrorsAllowed;
	DWORD dwUEMTotalErrorCount=0, dwUEMNumSpecificErrorCount=0;
	CHostResponse CHR;
	DWORD dwActualBytesReceived = 0, dwErrorCodeFromHost = 0;
	int iError;
	DWORD dwStandardErrorCode = 0;

	// Get the revision information from the Kernel
	if (XboxKrnlVersion->Build >= UEM_MINIMUM_KERNAL_BUILD)
	{
		if (FAILED(QueryFatalErrorLastCode(&dwFatalErrorCode)))
		{
			err_QueryingFatalErrorCode();
			return;
		}
		if (dwFatalErrorCode != FATAL_ERROR_NONE) // Only perform the rest of the utility is there was an error
		{
			switch(dwFatalErrorCode)
			{
				case FATAL_ERROR_CORE_DIGITAL:
					dwStandardErrorCode = 0x48;
					ptszErrorType = UEMCoreDigitalError;
					break;
				case FATAL_ERROR_BAD_EEPROM:
					dwStandardErrorCode = 0x49;
					ptszErrorType = UEMBadEepromError;
					break;
				case FATAL_ERROR_BAD_RAM:
					dwStandardErrorCode = 0x4A;
					ptszErrorType = UEMBadRamError;
					break;
				case FATAL_ERROR_HDD_NOT_LOCKED:
					dwStandardErrorCode = 0x4B;
					ptszErrorType = UEMHDDNotLockedError;
					break;
				case FATAL_ERROR_HDD_CANNOT_UNLOCK:
					dwStandardErrorCode = 0x4C;
					ptszErrorType = UEMHDDCannotUnlockError;
					break;
				case FATAL_ERROR_HDD_TIMEOUT:
					dwStandardErrorCode = 0x4D;
					ptszErrorType = UEMHDDTimeoutError;
					break;
				case FATAL_ERROR_HDD_NOT_FOUND:
					dwStandardErrorCode = 0x4E;
					ptszErrorType = UEMHDDNotFoundError;
					break;
				case FATAL_ERROR_HDD_BAD_CONFIG:
					dwStandardErrorCode = 0x4F;
					ptszErrorType = UEMHDDBadConfigError;
					break;
				case FATAL_ERROR_DVD_TIMEOUT:
					dwStandardErrorCode = 0x50;
					ptszErrorType = UEMDVDTimeoutError;
					break;
				case FATAL_ERROR_DVD_NOT_FOUND:
					dwStandardErrorCode = 0x51;
					ptszErrorType = UEMDVDNotFoundError;
					break;
				case FATAL_ERROR_DVD_BAD_CONFIG:
					dwStandardErrorCode = 0x52;
					ptszErrorType = UEMDVDBadConfigError;
					break;
				case FATAL_ERROR_XBE_DASH_GENERIC:
					dwStandardErrorCode = 0x53;
					ptszErrorType = UEMXBEDashGenericError;
					break;
				case FATAL_ERROR_XBE_DASH_ERROR:
					dwStandardErrorCode = 0x54;
					ptszErrorType = UEMXBEDashError;
					break;
				case FATAL_ERROR_XBE_DASH_SETTINGS:
					dwStandardErrorCode = 0x55;
					ptszErrorType = UEMXBEDashSettingsError;
					break;
				case FATAL_ERROR_XBE_DASH_X2_PASS:
					dwStandardErrorCode = 0x56;
					ptszErrorType = UEMXBEDashX2PassError;
					break;
				case FATAL_ERROR_REBOOT_ROUTINE:
					dwStandardErrorCode = 0x57;
					ptszErrorType = UEMRebootRoutineError;
					break;
				default:
					dwStandardErrorCode = 0x47;
					ptszErrorType = UEMUnknownError;
					break;
			}
			// Read in the specific and total error config parameter
			dwUEMTotalErrorsAllowed = GetCfgUint (_T("UEMTotalErrorsAllowed"), 0);
			_stprintf(tszTemp, _T("%ssAllowed"), ptszErrorType);
			dwUEMNumSpecificErrorsAllowed = GetCfgUint (tszTemp, 0);

			// Get the total and specific error counts from the host
			// Use the full version of iSendHost because a response is expected
			if ((iError = g_host.iSendHost(MID_GET_NAMED_STATE, (char *)UEMTotalErrors, (_tcslen(UEMTotalErrors) + 1)*sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
			{
				if (dwErrorCodeFromHost != 0)
				{
					// Process error from host
					err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
					return;
				}
				else
				{
					// Process a communication error
					// This test module just reports the number of the communication error that was received
					err_HostCommunicationError(iError);
					return;
				}
			}
			else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived < 4)) // Don't access the response buffer if it is NULL
			{
				// The response buffer is empty, so take appropriate action (like an error message)
				err_NamedStateBufferIsEmpty();
				return;
			}
			else // The response is not NULL, and is not an error message, so process it
			{
				dwUEMTotalErrorCount = *((DWORD *)CHR.pvBufferFromHost);
			}
			// Use the full version of iSendHost because a response is expected
			if ((iError = g_host.iSendHost(MID_GET_NAMED_STATE, (char *)ptszErrorType, (_tcslen(ptszErrorType) + 1)*sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
			{
				if (dwErrorCodeFromHost != 0)
				{
					// Process error from host
					err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
					return;
				}
				else
				{
					// Process a communication error
					// This test module just reports the number of the communication error that was received
					err_HostCommunicationError(iError);
					return;
				}
			}
			else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived < 4)) // Don't access the response buffer if it is NULL
			{
				// The response buffer is empty, so take appropriate action (like an error message)
				err_NamedStateBufferIsEmpty();
				return;
			}
			else // The response is not NULL, and is not an error message, so process it
			{
				dwUEMNumSpecificErrorCount = *((DWORD *)CHR.pvBufferFromHost);
			}

			// Now we know what the current counts are, so increment them and compare them to permitted values
			dwUEMTotalErrorCount ++;
			dwUEMNumSpecificErrorCount ++;
			// ReportStatistics
			_stprintf(tszTemp, _T("%sCount"), ptszErrorType);
			ReportStatistic(tszTemp, _T("%ld"), dwUEMNumSpecificErrorCount);
			ReportStatistic(_T("UEMTotalErrorCount"), _T("%ld"), dwUEMTotalErrorCount);

			if (dwUEMNumSpecificErrorCount > dwUEMNumSpecificErrorsAllowed)
			{
				if (err_UEMTooManyErrors(dwStandardErrorCode, dwUEMNumSpecificErrorCount, dwFatalErrorCode, ptszErrorType))
					return;
			}
			else // Update the count on the test server
			{
				_stprintf(&tszTemp[sizeof(DWORD)/sizeof(TCHAR)], _T("%s"), ptszErrorType);
				*((DWORD *)(&tszTemp[0])) = dwUEMNumSpecificErrorCount;
				// Use the short version of iSendHost because no response is expected
				if ((iError = g_host.iSendHost(MID_SET_NAMED_STATE, (char *)tszTemp, sizeof(DWORD) + (_tcslen(&tszTemp[sizeof(DWORD)/sizeof(TCHAR)]) + 1)*sizeof(TCHAR))) != EVERYTHINGS_OK)
				{
					// Process a communication error
					// This test module just reports the number of the communication error that was received
					if (err_HostCommunicationError(iError))
						return;
				}
			}

			if (dwUEMTotalErrorCount > dwUEMTotalErrorsAllowed)
			{
				if (err_UEMTooManyTotalErrors(dwUEMTotalErrorCount))
					return;
			}
			else // Update the count on the test server
			{
				_stprintf(&tszTemp[sizeof(DWORD)/sizeof(TCHAR)], _T("%s"), UEMTotalErrors);
				*((DWORD *)(&tszTemp[0])) = dwUEMTotalErrorCount;
				// Use the short version of iSendHost because no response is expected
				if ((iError = g_host.iSendHost(MID_SET_NAMED_STATE, (char *)tszTemp, sizeof(DWORD) + (_tcslen(&tszTemp[sizeof(DWORD)/sizeof(TCHAR)]) + 1)*sizeof(TCHAR))) != EVERYTHINGS_OK)
				{
					// Process a communication error
					// This test module just reports the number of the communication error that was received
					if (err_HostCommunicationError(iError))
						return;
				}
			}
		}
	}
}

//******************************************************************
// Title: image_hard_drive
//
// Abstract: This utility places the current software image on the hard drive
//
// Uses config parameters:
//           none
//******************************************************************
IMPLEMENT_TESTUNLOCKED (Tool, image_hard_drive, 18)
{
#define MAXIMUM_FILE_BYTES_PER_REQUEST 30000000
	DWORD dwMaximumFileBytesPerRequest, dwNumberRead, dwNumberWritten, dwActualBytesWritten;
	DWORD dwFileSize = 0;
#ifdef _XBOX
	char ImageFilenameOnXBox[] = "z:\\rawimage";
#else
	char ImageFilenameOnXBox[] = "c:\\rawimage00000000000000000000";
	if (g_host.m_strSerialNumber != NULL)
		sprintf(&ImageFilenameOnXBox[strlen(ImageFilenameOnXBox)-20], "%S", g_host.m_strSerialNumber);
#endif // #ifdef XBOX
	TCHAR szMessage[MAX_PATH + 8];  // Make sure we have enough space for the two DWORDs and the file name in the message
	CHostResponse CHR;
	DWORD dwActualBytesReceived = 0, dwErrorCodeFromHost = 0;
	int iError;
	HANDLE hDevice = INVALID_HANDLE_VALUE; 
	UINT uiSeed=0,uiRandScratch=0;

	LPCTSTR	tcParameter = GetCfgString( _T("image_file"), NULL);
	
	if (tcParameter == NULL) // No file name was specified
	{
		err_NoImageFileSpecified();
		return;
	}

	dwMaximumFileBytesPerRequest = GetCfgUint (L"maximum_file_bytes_per_request", MAXIMUM_FILE_BYTES_PER_REQUEST);

	// Get the size of the file from the test server
	if ((iError = g_host.iSendHost(MID_GET_FILE_SIZE, (char *)&tcParameter[0], (_tcslen(tcParameter) + 1) * sizeof(TCHAR), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				return;
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			if (err_HostCommunicationError(iError))
				return;
		}
	}
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived < 4)) // Don't access the response buffer if it is NULL
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		if (err_NoFileSizeReturned(tcParameter))
			return;
	}
	else // The response is not NULL, and is not an error message, so process it
	{
		dwFileSize = *(DWORD *)CHR.pvBufferFromHost;
		if (dwFileSize == 0)
		{
			err_ImageFileZeroLength(tcParameter);
			return;
		}
	}

	vNewSeed(&uiSeed);
	uiRandScratch=uiSeed;
	// Mount the utility drive if it is not already mounted
	if (!bMountUtilityDrive())
		return;

	// Mount the Dashboard partition if it is not already mounted
	if (!bMountDashboardPartition())
		return;

	// Open the File to write to the hard drive
	hDevice = CreateFileA(
		ImageFilenameOnXBox,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL); 

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		err_OPEN_FILE_P1L(ImageFilenameOnXBox);
		return;
	}

	// Get the file from the test server
	dwNumberRead = 0;
	dwNumberWritten = 0;
	while (dwNumberWritten < dwFileSize)
	{
		*(DWORD *)(&szMessage[0]) = dwNumberRead; // The byte offset
		*(DWORD *)(&szMessage[2]) = dwMaximumFileBytesPerRequest; // The maximum number of bytes to get
		memcpy (&szMessage[4], tcParameter, (_tcslen(tcParameter) + 1) * sizeof(TCHAR));

		if ((iError = g_host.iSendHost(MID_GET_FILE_EX, (char *)&szMessage[0], ((_tcslen(tcParameter) + 1) * sizeof(TCHAR)) + (sizeof(DWORD) * 2), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, TOOL_HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				if ((dwErrorCodeFromHost == 0xf1f) && (dwNumberRead == 0))
				{
					if (CheckAbort(HERE)) // If we haven't started reading the file yet, just exit on an abort gracefully
					{
						CloseHandle(hDevice);
						return;
					}
					else
					{
						Sleep(((random(&uiRandScratch) % 30)+10)*1000);  // Sleep between 10 and 40 seconds
						ReportDebug(BIT0, L"Trying to download the file %s", tcParameter);
						continue;
					}
				}
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
				{
					CloseHandle(hDevice);
					return;
				}
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
				{
					CloseHandle(hDevice);
					return;
				}
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			if (err_NoFileReturned(tcParameter))
			{
				CloseHandle(hDevice);
				return;
			}
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if(!WriteFile(
				hDevice,
				CHR.pvBufferFromHost,
				dwActualBytesReceived,
				&dwActualBytesWritten,
				NULL))
			{
				err_RE_WRITE_LOGICAL_P3L(ImageFilenameOnXBox, dwActualBytesReceived, (DWORDLONG)dwNumberWritten);
				CloseHandle(hDevice);
				return;
			}
//dwActualBytesWritten = dwActualBytesReceived;
			dwNumberRead = dwNumberRead + dwActualBytesReceived;
			dwNumberWritten = dwNumberWritten + dwActualBytesWritten;
			ReportDebug(BIT0, L"Read %lu bytes, Wrote %lu bytes.", dwActualBytesReceived, dwActualBytesWritten);
		}
	}
	CloseHandle(hDevice);  // Make sure the written file is closed

	if (dwNumberWritten != dwFileSize)
	{
		err_ImageFileWrongSize(ImageFilenameOnXBox, dwFileSize, dwNumberWritten);
		return;
	}
	// If we get here, then we wrote the file to the hard drive

}

void CXModuleTool::vNewSeed(UINT *pSeed)
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	GetSystemTime(&systimeSeed);
	SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
	*pSeed = (UINT)filetimeSeed.dwLowDateTime;

	return;
}

DWORD CXModuleTool::random(UINT *pScratch)
{
	DWORD ret;
	ret  = (*pScratch = *pScratch * 214013L + 2531011L) >> 16;
	ret |= (*pScratch = *pScratch * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtool\PerBoxData.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef __PerBoxData__
#define __PerBoxData__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//
// This is executed on the System Integration Test PC
// It generates the keys, the data blob that needs to be sent to WritePerBoxData,
// and the data that needs to be recorded back to the genealogy database.
//
HRESULT WINAPI GeneratePerBoxData (
    IN DWORD GameRegion,
    IN DWORD TVRegion,
    IN LPBYTE pbMACAddress, // 6 bytes
    IN char* pcXboxSerialNumber, // 12 bytes
    OUT char* pcHardDriveKey, // 16 bytes base64 encoded + 1 = 25 bytes
    OUT char* pcRecoveryKey, // 8 bytes
    OUT DWORD* pdwOnlineKeyVersion,
    OUT char* pcOnlineKey, // 128 bytes base64 encoded + 1 = 173 bytes
    OUT LPBYTE pbOutputBuffer,
    IN OUT DWORD* pdwOutputBufferSize
    );

//
// This is executed on the Xbox during System Integration Test
// It will initialize the contents of the EEPROM
//
HRESULT WINAPI WritePerBoxData(
    IN LPBYTE pbInputBuffer,
    IN DWORD dwInputBufferSize
    );

//
// This is executed on the Xbox during Extended Test
// It should be the last thing called before the Xbox leaves the factory
// because it clear the factory bit in the game region and no other
// factory code can be executed on the Xbox anymore.
// This routine will also lock the hard drive.
//
HRESULT WINAPI VerifyPerBoxData ();

//
// This is a generic API to be used by manufacturing/refurbishment code
// to unlock the hard drive. An optional hard drive key can be passed in.
// If it is not supplied, the key in the EEPROM is used.
//
HRESULT WINAPI UnlockXboxHardDrive (
    IN LPBYTE pbHardDriveKey,
    IN DWORD dwHardDriveKeySize
    );


// Define the fatal error codes.  The bitmap of UEMs stored
// in EEPROM starts at HDD_NOT_LOCKED being at bit zero.  
// CORE_DIGITAL and BAD_RAM are values used by the SMC.
//

#define FATAL_ERROR_NONE                0x00
#define FATAL_ERROR_CORE_DIGITAL        0x01
#define FATAL_ERROR_BAD_EEPROM          0x02
#define FATAL_ERROR_UNUSED1             0x03    
#define FATAL_ERROR_BAD_RAM             0x04
#define FATAL_ERROR_HDD_NOT_LOCKED      0x05
#define FATAL_ERROR_HDD_CANNOT_UNLOCK   0x06
#define FATAL_ERROR_HDD_TIMEOUT         0x07
#define FATAL_ERROR_HDD_NOT_FOUND       0x08
#define FATAL_ERROR_HDD_BAD_CONFIG      0x09
#define FATAL_ERROR_DVD_TIMEOUT         0x0A
#define FATAL_ERROR_DVD_NOT_FOUND       0x0B
#define FATAL_ERROR_DVD_BAD_CONFIG      0x0C
#define FATAL_ERROR_XBE_DASH_GENERIC    0x0D
#define FATAL_ERROR_XBE_DASH_ERROR      0x0E
#define FATAL_ERROR_UNUSED2             0x0F
#define FATAL_ERROR_XBE_DASH_SETTINGS   0x10
#define FATAL_ERROR_UNUSED3             0x11
#define FATAL_ERROR_UNUSED4             0x12
#define FATAL_ERROR_UNUSED5             0x13
#define FATAL_ERROR_XBE_DASH_X2_PASS    0x14
#define FATAL_ERROR_REBOOT_ROUTINE      0x15
#define FATAL_ERROR_RESERVED            0xFF

//
// If the system failed to boot immediately before this successful boot, then
// the fatal error code from the last unsuccessful boot can be obtained
// with this API call.  Only true in Manufacturing region.  
//

HRESULT WINAPI QueryFatalErrorLastCode(
    OUT LPDWORD pdwFatalErrorCode
    );

//
// Returns a bitmap where the bits correspond to the fatal error codes.  If
// a fatal error has ever occurred on this system then the corresponding bit 
// will be set in this history DWORD
//
HRESULT WINAPI QueryFatalErrorHistory(
    OUT LPDWORD pdwFatalErrorHistory
    );

//
// Clears the fatal error bitmap which stores the fatal error code.
//
HRESULT WINAPI ClearFatalErrorHistory(
    VOID
    );

//
// In manufacturing region, sets the retry flag for the fatal error (UEM) handling.
// When the flag is TRUE, the system will retry when a fatal error occurs, otherwise
// the UEM is displayed
//
HRESULT WINAPI SetFatalErrorRetryFlag(
    IN BOOL Retry
    );


#ifdef __cplusplus
}
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xsmc\xsmc.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
#include "..\stdafx.h"
#include "..\testobj.h"
#include "..\statkeys.h"
#include "xsmc.h"


//////////////////////////////////////////////////////////////////////////////////
// Function name	: InitializeParameters
// Description	    : Tries to see if the configuration parameters were defined
//					  or not.
// Return type		: bool 
//////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_MODULEUNLOCKED (CXModuleSMC); 

bool CXModuleSMC::InitializeParameters ()
{
	#define DVD_TIMEOUT_BETWEEN_OPERATIONS 25000  // Maximum number of milliseconds to wait between each DVD state

	TCHAR chBuf[80];

	if (!CTestObj::InitializeParameters ())
		return false;

	if (!bSMCRegsiterCriticalSectionInitialized)
	{
		bSMCRegsiterCriticalSectionInitialized = true;
		InitializeCriticalSection(&SMCRegisterCriticalSection);
	}

	// Get a list of Allowed Revision Ids. Default is Null.
	_stprintf(chBuf, pwsRevAllowed, 0);
	pwsAllowed = GetCfgString(chBuf, NULL);

	// Get a list of Not Allowed Revision Ids. Default is Null.
	_stprintf(chBuf, pwsRevNotAllowed, 0);
	pwsNotAllowed = GetCfgString(chBuf, NULL);

	// Get the AudioClamp (Yes/No) Parameter. 
	pwsAudioClamp = GetCfgString(_T("AudioClamp"), NULL);

	// Get the FanSpeedxLL and FanSpeedxUL parameters for the lower and upper limits of
	// the fan voltages, where x = 50, 20 or any other fan speed for which the voltage
	// is verified.
	// Get the param as string and then convert it to double/float.
	pwsFan50LL = GetCfgString(_T("FanSpeed50LL"), _T("0.0"));
	fFanSpeed50LL = (float)wcstod(pwsFan50LL, NULL);
	
	pwsFan50UL = GetCfgString(_T("FanSpeed50UL"), _T("0.2"));
	fFanSpeed50UL = (float)wcstod(pwsFan50UL, NULL);
	
	pwsFan20LL = GetCfgString(_T("FanSpeed20LL"), _T("3.6"));
	fFanSpeed20LL = (float)wcstod(pwsFan20LL, NULL);
	
	pwsFan20UL = GetCfgString(_T("FanSpeed20UL"), _T("3.8"));
	fFanSpeed20UL = (float)wcstod(pwsFan20UL, NULL);

	// Get the cfg parameters for the lower and upper limits of CPU Junction and Internal
	// Air temperatures.
	uiCpuJunTempLL = GetCfgUint(_T("CpuJunctionTempLL"), 0);
	uiCpuJunTempUL = GetCfgUint(_T("CpuJunctionTempUL"), 0);
	uiInternalAirTempLL = GetCfgUint(_T("InternalAirTempLL"), 0);
	uiInternalAirTempUL = GetCfgUint(_T("InternalAirTempUL"), 0);
	uiCpuJunTempCritical = GetCfgUint(_T("CpuJunctionTempCritical"), 100);

	dwRegulatedCPUTemperatureFanOff = (DWORD)GetCfgUint(_T("RegulatedCPUTemperatureFanOff"), 0);
	dwRegulatedCPUTemperatureFanOn = (DWORD)GetCfgUint(_T("RegulatedCPUTemperatureFanOn"), 100);

	dwRegulatedTemperatureMinTimeFanSteady = (DWORD)GetCfgUint(_T("RegulatedTemperatureMinTimeFanSteady"), 0xFFFFFFFF);
	dwRegulatedTemperatureMaxTimeFanSteady = (DWORD)GetCfgUint(_T("RegulatedTemperatureMaxTimeFanSteady"), 0);

	dwRegulatedTemperatureFanSteadyValue = (DWORD)GetCfgUint(_T("RegulatedTemperatureFanSteadyValue"), 0);

	gdwBootCountGateValue = (DWORD)GetCfgUint(_T("RebootGateCount"), 0);

	dwLEDSystemTestComplexity = (DWORD)GetCfgUint(_T("LEDSystemTestComplexity"), 0);

	dwLEDSystemTestTriesAllowed = (DWORD)GetCfgUint(_T("LEDSystemTestRetriesAllowed"), 0);
	dwLEDSystemTestTriesAllowed = dwLEDSystemTestTriesAllowed + 1; // Make this tries instead of retries
	if (dwLEDSystemTestTriesAllowed > 10)
		dwLEDSystemTestTriesAllowed = 10;

	dwDVDMediaDetectTimeout = (DWORD)GetCfgUint(_T("DVDMediaDetectTimeout"), DVD_TIMEOUT_BETWEEN_OPERATIONS/1000);
	dwDVDMediaDetectTimeout = dwDVDMediaDetectTimeout * 1000;

	return true;

} // end bool CXModuleSMC::InitializeParameters ()
  

NTSTATUS WriteSMBusValue(UCHAR SlaveAddress, UCHAR CommandCode, BOOLEAN WriteWordValue, ULONG DataValue)
{
	NTSTATUS NtStatusTemp;

	EnterCriticalSection(&SMCRegisterCriticalSection);
	NtStatusTemp = HalWriteSMBusValue(SlaveAddress, CommandCode, WriteWordValue, DataValue);
	LeaveCriticalSection(&SMCRegisterCriticalSection);
	return NtStatusTemp;
}

NTSTATUS ReadSMBusValue(UCHAR SlaveAddress, UCHAR CommandCode, BOOLEAN ReadWordValue, ULONG *DataValue)
{
	NTSTATUS NtStatusTemp;

	EnterCriticalSection(&SMCRegisterCriticalSection);
	NtStatusTemp = HalReadSMBusValue(SlaveAddress, CommandCode, ReadWordValue, DataValue);
	LeaveCriticalSection(&SMCRegisterCriticalSection);
	return NtStatusTemp;
}

//////////////////////////////////////////////////////////////////////////////////
// Function name	: GetLEDStateFromTIUForBoardTest
// Description	    : Uses MID_XBOX_SENSOR_LINES to read the state/color of the LED
//					  that was changed using the SMC LED State register. Returns 
//					  the LED state that was requested through iState.
// Input			: int iState - Off, Green, Red or Orange LED State to be tested.
// Return type		: BYTE
//////////////////////////////////////////////////////////////////////////////////
BYTE CXModuleSMC::GetLEDStateFromTIUForBoardTest(int iState)
{
	CHostResponse CHR;
	int iError;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	BYTE* bpTemp;
	BYTE  bGreen, bRed;

	// Use the full version of iSendHost because a response is expected.
	// No message is sent, only response is received after writing to the LED state register.
	// This message will receive a number indicating the state of the sensors on the XBOX.
	if ((iError = g_host.iSendHost(MID_XBOX_SENSOR_LINES, NULL, NULL, CHR, &dwActualBytesReceived, 
		 &dwErrorCodeFromHost, HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			bErrorFlag = TRUE;
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			if(CheckAbort(HERE))
				return 0;
		}
		
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			bErrorFlag = TRUE;
			err_HostCommunicationError(iError);
			if(CheckAbort(HERE))
				return 0;
		}
	}

	// Don't access the response buffer if it is NULL
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) 
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		bErrorFlag = TRUE;
		err_BufferIsEmpty();
		if(CheckAbort(HERE))
			return 0;
	}
	
	else // The response is not NULL, and is not an error message, so process it
	{
		// Copy the data received to a local buffer for processing
		bpTemp = (BYTE*)CHR.pvBufferFromHost;  
		
		// Byte 10 in the response field is for Green LED and byte 11 for Red. 
		// 1 = on, 0 = off.
		bGreen = bpTemp[10];
		bRed = bpTemp[11];

		// return the LED state as requested
		switch(iState)
		{
		case Off:
			if((bRed == 0) && (bGreen == 0))
				return 1;
			else
				return 0;

		case Green:
			return bGreen;
		
		case Red:
			return bRed;
			
		case Orange:
			if((bRed == 1) && (bGreen == 1))
				return 1;
			else
				return 0;
		}
	}
 
	// Everything ok
	return 1;

} // end BYTE CXModuleSMC::GetLEDStateFromTIUForBoardTest(int iState)



//////////////////////////////////////////////////////////////////////////////////
// Function name	: GetLEDStateFromTIUForSystemTest
// Description	    : Uses MID_ASK_QUESTION to load the .bmp file for iState LED
//					  and asks the questions and records the response accordingly.
// Return type		: BYTE
//////////////////////////////////////////////////////////////////////////////////
BYTE CXModuleSMC::GetLEDStateFromTIUForSystemTest(int iState, bool bVerifyQuestion)
{
	CHostResponse CHR;
	int iError, iTotal = 0;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	BYTE* bpTemp;
	BYTE  bAnswer;
	char chResponse[256];

	switch(iState)
	{
		// since the strings are unicode, # of bytes to be copied = sizeof string * 2 + 2
		// e.g. sizeof "LEDOff.bmp" = 10. So bytes to be copied = 10 * 2 + 2 = 22
	case 0:
		memcpy(chResponse, _T("LEDOff.bmp"), 22);  // Bitmap file to be loaded in the dialog box
		memcpy(&chResponse[22], _T(""), 2);        // The "extended" file can be .JPG, .AVI or .MPG. Defaults the same as the first file
		memcpy(&chResponse[24], _T("NORMAL_LED_OFF_QUESTION"), 48);  // Text to be prompted with
		if (bVerifyQuestion)
			memcpy(&chResponse[24], _T("VERIFY"), 12);  // Make this the verify version of the question
		memcpy(&chResponse[72], _T("Yes\n"), 10);  // Text for the left button
		memcpy(&chResponse[82], _T("No\n"), 8);   // Text for the right button
		iTotal = 90;
		break;
		
	case 1:
		memcpy(chResponse, _T("LEDGreen.bmp"), 26);
		memcpy(&chResponse[26], _T(""), 2);
		memcpy(&chResponse[28], _T("NORMAL_LED_GREEN_QUESTION"), 52);
		if (bVerifyQuestion)
			memcpy(&chResponse[28], _T("VERIFY"), 12);  // Make this the verify version of the question
		memcpy(&chResponse[80], _T("Yes\n"), 10); 
		memcpy(&chResponse[90], _T("No\n"), 8);  
		iTotal = 98;
		break;

	case 2:
		memcpy(chResponse, _T("LEDRed.bmp"), 22);
		memcpy(&chResponse[22], _T(""), 2);
		memcpy(&chResponse[24], _T("NORMAL_LED_RED_QUESTION"), 48);
		if (bVerifyQuestion)
			memcpy(&chResponse[24], _T("VERIFY"), 12);  // Make this the verify version of the question
		memcpy(&chResponse[72], _T("Yes\n"), 10); 
		memcpy(&chResponse[82], _T("No\n"), 8);  
		iTotal = 90;
		break;

	case 3:
		memcpy(chResponse, _T("LEDOrange.bmp"), 28);
		memcpy(&chResponse[28], _T(""), 2);
		memcpy(&chResponse[30], _T("NORMAL_LED_ORANGE_QUESTION"), 54);
		if (bVerifyQuestion)
			memcpy(&chResponse[30], _T("VERIFY"), 12);  // Make this the verify version of the question
		memcpy(&chResponse[84], _T("Yes\n"), 10); 
		memcpy(&chResponse[94], _T("No\n"), 8);  
		iTotal = 102;
		break;

	} // end switch

if ((iError = g_host.iSendHost(MID_ASK_QUESTION, chResponse, iTotal, CHR, &dwActualBytesReceived, 
		 &dwErrorCodeFromHost, 0x7FFFFFFF)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			bErrorFlag = TRUE;
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			if(CheckAbort(HERE))
				return 0;  
		}
		
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			bErrorFlag = TRUE;
			err_HostCommunicationError(iError);
			if(CheckAbort(HERE))
				return 0;
		}
	}

	// Don't access the response buffer if it is NULL
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) 
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		bErrorFlag = TRUE;
		err_BufferIsEmpty();
		if(CheckAbort(HERE))
			return 0;
	}

	else
	{
		// Copy the data received to a local buffer for processing
		bpTemp = (BYTE*)CHR.pvBufferFromHost; 
		bAnswer = bpTemp[0];

		return bAnswer;
	}

	// An error of some type happened
	return 0;
	
} // end BYTE CXModuleSMC::GetLEDStateFromTIUForSystemTest(int iState)



//////////////////////////////////////////////////////////////////////////////////
// Function name	: GetFanVoltageFromTIU
// Description	    : Uses MID_XBOX_SENSOR_LINES to read the fan volatge that was
//					  changed through the fan speed by using the SMC Fan Speed 
//					  register. 
// Return type		: float
//////////////////////////////////////////////////////////////////////////////////
float CXModuleSMC::GetFanVoltageFromTIU()
{
	float fFanVoltage;
	CHostResponse CHR;
	int iError;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;

	// Use the full version of iSendHost because a response is expected.
	// No message is sent, only response is received after writing to the Fan Speed register.
	// This message will receive a number indicating the state of the Fan Voltage on the XBOX.
	if ((iError = g_host.iSendHost(MID_XBOX_SENSOR_LINES, NULL, NULL, CHR, &dwActualBytesReceived, 
		 &dwErrorCodeFromHost, HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			bErrorFlag = TRUE;
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			if(CheckAbort(HERE))
				return 0.0f;
		}
		
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			bErrorFlag = TRUE;
			err_HostCommunicationError(iError);
			if(CheckAbort(HERE))
				return 0.0f;
		}
	}

	// Don't access the response buffer if it is NULL
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) 
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		bErrorFlag = TRUE;
		err_BufferIsEmpty();
		if(CheckAbort(HERE))
			return 0.0f;
	} 
	
	else // The response is not NULL, and is not an error message, so process it
	{
		// Copy the data received to a local buffer for processing. The fan voltage is in "float"
		// so copy as many bytes as are represented by a float variable (mostly 4).
		memcpy(&fFanVoltage, CHR.pvBufferFromHost, sizeof(float));
		
		// debug
		//ReportDebug(BIT0,_T("fan voltage from TIU = %f\n"), fFanVoltage);
		return fFanVoltage;			
	}

	return 0.0f;

} // end float CXModuleSMC::GetFanVoltageFromTIU()



//////////////////////////////////////////////////////////////////////////////////
// Function name	: GetAirSensorFromTIU
// Description	    : Uses MID_XBOX_SENSOR_LINES to read the Air that was turned
//					  on or off through the fan speed by using the SMC Fan Speed 
//					  register. 
// Return type		: BYTE
//////////////////////////////////////////////////////////////////////////////////
BYTE CXModuleSMC::GetAirSensorFromTIU()
{
	CHostResponse CHR;
	int iError;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	BYTE* bpTemp;
	BYTE  bAirSensor;

	// Use the full version of iSendHost because a response is expected.
	// No message is sent, only response is received after writing to the Fan Speed register.
	// This message will receive a number indicating the state of the Air sensor on the XBOX.
	if ((iError = g_host.iSendHost(MID_XBOX_SENSOR_LINES, NULL, NULL, CHR, &dwActualBytesReceived, 
		 &dwErrorCodeFromHost, HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			bErrorFlag = TRUE;
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			if(CheckAbort(HERE))
				return 0;
		}
		
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			bErrorFlag = TRUE;
			err_HostCommunicationError(iError);
			if(CheckAbort(HERE))
				return 0;
		}
	}

	// Don't access the response buffer if it is NULL
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) 
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		bErrorFlag = TRUE;
		err_BufferIsEmpty();
		if(CheckAbort(HERE))
			return 0;
	}
	
	else // The response is not NULL, and is not an error message, so process it
	{
		// Copy the data received to a local buffer for processing
		bpTemp = (BYTE*)CHR.pvBufferFromHost;  
		
		// Byte 9 in the response field is for for the Fan Air Sensor.
		// 1 = Sensor Off, 0 = Sensor On.
		bAirSensor = bpTemp[9];
		return bAirSensor;
	}

	return 0;
} // end BYTE CXModuleSMC::GetAirSensorFromTIU()



//////////////////////////////////////////////////////////////////////////////////
// Function name	: PutVModeStateToTIU
// Description	    : Uses MID_XBOX_SET_VIDEO_MODE_LINES to write the Video mode
//					  states requested through iState.
// Input			: int iState - Video Mode to be tested: DISABLE , SDTVNTSC,
//					               PALRFU, SDTVPAL, NTSCRFU, VGA, HDTV, SCART   
// Return type		: void
//////////////////////////////////////////////////////////////////////////////////
void CXModuleSMC::PutVModeStateToTIU(int iState)
{
	CHostResponse CHR;
	int iError;
	BYTE bVmode;

	// set the video mode
	switch(iState)
	{
		case DISABLE:
			bVmode = 0;
			break;

		case SDTVNTSC:
			bVmode = 1;
			break;

		case PALRFU:
			bVmode = 2;
			break;

		case SDTVPAL:
			bVmode = 3;
			break;

		case NTSCRFU:
			bVmode = 4;
			break;
		
		case VGA:
			bVmode = 5;
			break;

		case HDTV:
			bVmode = 6;
			break;

		case SCART:
			bVmode = 7;
			break;
	}	

	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent to change the VMode lines
	if ((iError = g_host.iSendHost(MID_XBOX_SET_VIDEO_MODE_LINES, (char *)&bVmode, sizeof(BYTE)))
		 != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		err_HostCommunicationError(iError);
		if(CheckAbort(HERE))
			return;
	}

} // end BYTE CXModuleSMC::PutVModeStateToTIU(int iState)



///////////////////////////////////////////////////////////////////////////////////
// Actual tests
///////////////////////////////////////////////////////////////////////////////////


// This test verifes that the XBOX can switch to different video modes.
IMPLEMENT_TESTUNLOCKED (SMC, VModeTest, 1)
{
	ULONG uDataValue, uSave;
		int iError;

	// Read the original video mode 
	NtStatus = ReadSMBusValue(0x20, 0x04, FALSE, &uSave);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Read(_T("VMode State"), NtStatus);
		return;
	}
	// debug
	//ReportDebug(BIT0,_T("Original VMode = %d\n"), uSave);

	// Change the video mode through the TIU. After a delay of 500ms, read the VMode state 
	// SMC register to verify that the mode changed.

	// Vide Mode = SDTV PAL
	PutVModeStateToTIU(SDTVPAL);
	Sleep(500);	

	NtStatus = ReadSMBusValue(0x20, 0x04, FALSE, &uDataValue);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Read(_T("VMode State"), NtStatus);
		return;
	}

	// Verify that the Vmode state read by the SMC is the same as the state that was set thru TIU
	if(uDataValue != SMCSDTVPAL) 
	{
		err_VModeState(_T("SDTV PAL"));
		return;
	}

	// Vide Mode = HDTV
	PutVModeStateToTIU(HDTV);
	Sleep(500);

	NtStatus = ReadSMBusValue(0x20, 0x04, FALSE, &uDataValue);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Read(_T("VMode State"), NtStatus);
		return;
	}

	// Verify that the Vmode state read by the SMC is the same as the state that was set thru TIU
	if(uDataValue != SMCHDTV)
	{
		err_VModeState(_T("HDTV"));
		return;
	}
	
	// Vide Mode = SDTV NTSC
	PutVModeStateToTIU(SDTVNTSC);
	Sleep(500);
	
	NtStatus = ReadSMBusValue(0x20, 0x04, FALSE, &uDataValue);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Read(_T("VMode State"), NtStatus);
		return;
	}

	// Verify that the Vmode state read by the SMC is the same as the state that was set thru TIU
	if(uDataValue != SMCSDTVNTSC)
	{
		err_VModeState(_T("SDTV NTSC"));
		return; 
	}
	
	// Write back the original video mode
		if ((iError = g_host.iSendHost(MID_XBOX_SET_VIDEO_MODE_LINES, (char *)&uSave, sizeof(BYTE)))
		 != EVERYTHINGS_OK)
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			err_HostCommunicationError(iError);
			return;
		}
	
} // end IMPLEMENT_TESTUNLOCKED (SMC, VModeTest, 1)



// This test verifies that the XBOX can change different LED states - Off, Green, Red, Orange.
IMPLEMENT_TESTUNLOCKED (SMC, LEDBoardTest, 2)
{
	BYTE bResult;
	
	// Set LED to desired behavior
	// Off
	NtStatus = WriteSMBusValue(0x20, 0x08, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED State"), NtStatus);
		return;
	}

	// Set LED Override to use the requested LED Behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

	Sleep(500);
	bResult = GetLEDStateFromTIUForBoardTest(Off);
	if((bErrorFlag == FALSE) && (bResult != 1))
	{
		err_LEDStateFromTIU(_T("Off"));
		return;
	}

	// Reset LED Override to use the default LED behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}


	// Green
	NtStatus = WriteSMBusValue(0x20, 0x08, FALSE, 0x0F);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED State"), NtStatus);
		return;
	}

	// Set LED Override to use the requested LED Behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

	Sleep(500);
	bResult = GetLEDStateFromTIUForBoardTest(Green);
	if((bErrorFlag == FALSE) && (bResult != 1))
	{
		err_LEDStateFromTIU(_T("Green"));
		return;
	}

	// Reset LED Override to use the default LED behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

	// Red
	NtStatus = WriteSMBusValue(0x20, 0x08, FALSE, 0xF0);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED State"), NtStatus);
		return;
	}

	// Set LED Override to use the requested LED Behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

	Sleep(500);
	bResult = GetLEDStateFromTIUForBoardTest(Red);
	if((bErrorFlag == FALSE) && (bResult != 1))
	{
		err_LEDStateFromTIU(_T("Red"));
		return;
	}

	// Reset LED Override to use the default LED behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

	// Orange
	NtStatus = WriteSMBusValue(0x20, 0x08, FALSE, 0xFF);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED State"), NtStatus);
		return;
	}

	// Set LED Override to use the requested LED Behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

	Sleep(500);
	bResult = GetLEDStateFromTIUForBoardTest(Orange);
	if((bErrorFlag == FALSE) && (bResult != 1))
	{
		err_LEDStateFromTIU(_T("Orange"));
		return;
	}

	// Reset LED Override to use the default LED behavior
	NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("LED Override"), NtStatus);
		return;
	}

} // end IMPLEMENT_TESTUNLOCKED (SMC, LEDBoardTest, 2)



// This test verifies that fan speed can be varied and the fan voltage for each speed is
// within its predefined Lower and Upper limits.
//The correct sequence for controlling fan speed, according to the SMC firmware author is:
//1) Write the fan speed you want first to reg 0x06
//2) Now write the fan override bit in reg 0x05
//3) When finished with fan speed clear override bit in reg 0x05
//4) Repeat steps 1 - 3 for each new fan speed.
IMPLEMENT_TESTUNLOCKED (SMC, FanSpeedBoardTest, 3)
{
	float fFanVoltage;

	// Set fan speed to desired speed
	// Max fan speed = 50
	NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x32); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus); 
		return;
	}

	// Set fan Override to use the requested fan speed
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

	Sleep(500);
	fFanVoltage = GetFanVoltageFromTIU();
	
	// Make sure that the fan voltage is within the lower and upper limits
	if((fFanVoltage < fFanSpeed50LL) || (fFanVoltage > fFanSpeed50UL))
	{
		err_FanVoltLimit(fFanVoltage, 50, fFanSpeed50LL, fFanSpeed50UL);
		return;
	}

	// Reset fan override
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

	// fan speed = 20
	NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x14); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus);
		return;
	}

	// Set fan Override to use the requested fan speed
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}
	
	Sleep(500);
	fFanVoltage = GetFanVoltageFromTIU();

	// Make sure that the fan voltage is within the lower and upper limits
	if((fFanVoltage < fFanSpeed20LL) || (fFanVoltage > fFanSpeed20UL)) 
	{
		err_FanVoltLimit(fFanVoltage, 20, fFanSpeed20LL, fFanSpeed20UL);
		return;
	}

	// Reset fan override
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

} // end IMPLEMENT_TESTUNLOCKED (SMC, FanSpeedBoardTest, 3)



// This test verifies that the actual firmware revision read from the SMC Firmware Revision
// register matches(does't match) with the list of allowed(not allowed) Revision IDs. If no
// allowed or not allowed list is specified, it is assumed that any revision read from
// the SMC register is allowed.
IMPLEMENT_TESTUNLOCKED (SMC, RevisionCheckTest, 4)
{
	LPCTSTR pwsRevType, pwsRevCnt[MAX_REVISIONS];
	wchar_t* pwsCfgRev[MAX_REVISIONS];
	TCHAR chBuf[80], chRev[4];
	ULONG uDataValue;
	int i, iCnt, iResult;

	// The list of allowed and not allowed revisions is mutually exclusive. So the
	// RevisionAllowed[##] and RevisionNotAllowed[##] parameters both cannot exist.
	if((pwsAllowed != NULL) && (pwsNotAllowed != NULL))
	{
		err_RevisionXor();
		return;
	}

	// If neither RevisionAllowed[##] nor RevisionNotAllowed[##] parameters exist,
	// there are no revision restrictions.
	if((pwsAllowed == NULL) && (pwsNotAllowed == NULL))
	{
		ReportDebug(BIT0,_T("RevisionAllowed[##] or RevisionNotAllowed[##] list is not specified")
					  _T(" so passing the test.\n"));
		return;
	}

	pwsRevType = pwsRevAllowed; // Default to allowed

	if(pwsNotAllowed != NULL)
		pwsRevType = pwsRevNotAllowed;

	// Write to the register first to reset it 
	for(i = 0; i < 3; i++)
	{			
		NtStatus = WriteSMBusValue(0x20, 0x01, FALSE, 0x00);

		if(NtStatus != STATUS_SUCCESS)
		{
			err_Write(_T("Firmware Revision"), NtStatus);
			return;
		}
	}

	// Get the actual SMC Firmware Revision ID from the SMC Revision Register
	// The Rev ID is 3 bytes long (e.g. B1C, A4E)
	for(i = 0; i < 3; i++)
	{			
		NtStatus = ReadSMBusValue(0x20, 0x01, FALSE, &uDataValue);

		if(NtStatus != STATUS_SUCCESS)
		{
			err_Read(_T("Firmware Revision"), NtStatus);
			return;
		}

		// Store the value in a char array so that it can be used as a string that
		// can be compared with the Rev ID string obtained from the  allowed or not
		// allowed list of Cfg parameters.
		chRev[i] = (TCHAR)uDataValue;
		
		// debug
		//ReportDebug(BIT0,_T("chRev[%d] = %c\n"), i, chRev[i]);
	
	} // end for(i = 0; i < 3; i++)

	// Terminate with Null
	chRev[3] = '\0';

	// Initialize pwsCfgRev 
	for (iCnt = 0; iCnt < MAX_REVISIONS; iCnt++)
		pwsCfgRev[iCnt] = NULL;

	// Get the list of allowed OR not allowed Revisions specified in the Cfg parameters
	for (iCnt = 0; iCnt < MAX_REVISIONS; iCnt++)
	{
		_stprintf(chBuf, pwsRevType, iCnt);
		pwsRevCnt[iCnt] = GetCfgString(chBuf, NULL); 
		
		if(pwsRevCnt[iCnt] == NULL)
			break;
		
		// Convert the string to uppercase as the actual Rev ID will always be upper case
		else
			pwsCfgRev[iCnt] = _tcsupr((wchar_t*)pwsRevCnt[iCnt]);

	} // end for (iCnt = 0; iCnt < MAX_REVISIONS; iCnt++)

	// Compare the Actual Rev Id witht the Rev Id(s) obtained from the allowed OR not allowed
	// list of Cfg parameters
	for (i = 0; i < MAX_REVISIONS; i++)
	{
		if(pwsCfgRev[i] != NULL)
		{
			iResult = _tcscmp(chRev, (LPCTSTR)pwsCfgRev[i]);
			
			// one of the allowed Rev Ids matches with the actual Rev Id
			if(pwsAllowed && (iResult == 0))
				return;

			// One of the not allowed Rev Ids matches with the actual Rev Id so report error
			if(pwsNotAllowed && (iResult == 0))
			{
				err_RevisionNotAllowed(chRev);
				return; 
			}
			
		} // end if(pwsCfgRev[i] != NULL)

	} // end for (i = 0; i < MAX_REVISIONS; i++)

	// The list of allowed Revision Id Cfg parameters did not contain the actual
	// Rev Id that was read from the SMC Revision register so report error
	if(pwsAllowed)
		err_RevisionNotAllowed(chRev);
	
} // end IMPLEMENT_TESTUNLOCKED (SMC, RevisionCheckTest, 4)



// This utility resets the system.
IMPLEMENT_TESTUNLOCKED (SMC, SystemResetUtility, 5)
{
	TCHAR tcBuffer[300]; // Holds data to send to the host in messages
	int iError;
	DWORD dwBufferLength;

	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_TESTEND command for this test
//	_stprintf(tcBuffer, _T("%s.%s"), GetModuleName(), GetTestName());
	_stprintf(tcBuffer, _T("%s"), GetFullName());
	dwBufferLength = (_tcslen(tcBuffer) + 1) * sizeof(TCHAR);
	// Add the 2 DWORDs here (10 and 1)
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 10; // Elapsed time for this test (set to 10 ms)
	dwBufferLength = dwBufferLength + sizeof(DWORD);
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 1; // PASSED indication
	dwBufferLength = dwBufferLength + sizeof(DWORD);

	if ((iError = g_host.iSendHost(MID_UUT_TESTEND, (char *)&tcBuffer[0], dwBufferLength))
		 != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		err_HostCommunicationError(iError);
		if(CheckAbort(HERE))
			return;
	}
	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_RESTARTING command for this test
	if ((iError = g_host.iSendHost(MID_UUT_RESTARTING, NULL, 0))
		 != EVERYTHINGS_OK)
	{
		// The test has officially ended due to the message above, so don't send any more error messages.
		// Restart the unit below and it will fail on the next boot.
	}

	// Reset the system by writing 0x01 to the SMC System Reset Register
	NtStatus = WriteSMBusValue(0x20, 0x02, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		// Again, don't report an error because no one is listening
//		err_Reset(NtStatus);
//		return;
	}
	Sleep(INFINITE);

} // end IMPLEMENT_TESTUNLOCKED (SMC, SystemResetUtility, 5)



DWORD CXModuleSMC::dwLEDSystemTest(DWORD dwLEDSystemTestTriesLeft)
{
#define LED_FAIL 0
#define LED_RETRY 1
#define LED_OK 2
	int ii, iIndex, iLedArray[5], iCount, iIncorrectLED = 0xFF;
	BYTE bResult;
	bool bArrayCount[5], bOff, bRed, bGreen, bOrange, bIncorrect;
	ULONG uLED = 0;
	bool bPreviousResponseWrong = false;
	UINT uiSeed, uiRandScratch;

	// Seed the random number with the tick count which gives the count of system ticks (or 
	// milliseconds) since boot time.
	vNewSeed(&uiSeed);
	uiRandScratch=uiSeed;

	if (dwLEDSystemTestComplexity != 1) // Do the simpler test
	{
		// initialize arrays
		for(ii = 0; ii < 5; ii++)
		{
			iLedArray[ii] = 0xFF; // didn't initialize this to 0, since Off = 0
			bArrayCount[ii] = false; // to track which slot(0..4) in the array is filled 
		}

		// to track which color LED is filled in the array slot
		bOff = false;
		bRed = false;
		bGreen = false;
		bOrange = false;
		
		bIncorrect = false;
		iCount = 0;

		// First randomize the LEDs into an array of 4. eg. Green, Red, Off, Orange OR Red, Off, Green,
		// Orange...
		while(iCount != 4)
		{
			// Get the random number, divide it by 4 and use the remainder (0, 1, 2, 3) to fill up
			// the array for LEDs randomly
			iIndex = random(&uiRandScratch) % 4; 

			// Make sure that there are no collisions so that each location will have a unique
			// LED color (Off, Red, Green Orange)
			// Off
			if((bArrayCount[iIndex] == false) && ((iLedArray[iIndex] != Red) || (iLedArray[iIndex] != Green)||
				(iLedArray[iIndex] != Orange)) && (bOff == false))
			{
				bOff = true;
				bArrayCount[iIndex] = true;
				iLedArray[iIndex] = Off; 
				iCount++;
			}
			
			// Green
			else if((bArrayCount[iIndex] == false) && ((iLedArray[iIndex] != Red) || (iLedArray[iIndex] != Orange) ||
				(iLedArray[iIndex] != Off)) && (bGreen == false))
			{
				bGreen = true;
				bArrayCount[iIndex] = true;
				iLedArray[iIndex] = Green;
				iCount++;
			}

			// Red
			else if((bArrayCount[iIndex] == false) && ((iLedArray[iIndex] != Off) || (iLedArray[iIndex] != Green) ||
				(iLedArray[iIndex] != Orange)) && (bRed == false))
			{
				bRed = true;
				bArrayCount[iIndex] = true;
				iLedArray[iIndex] = Red;
				iCount++;
			}

			// Orange
			else if((bArrayCount[iIndex] == false) && ((iLedArray[iIndex] != Red) || (iLedArray[iIndex] != Green) ||
				(iLedArray[iIndex] != Off)) && (bOrange == false))
			{
				bOrange = true;
				bArrayCount[iIndex] = true;
				iLedArray[iIndex] = Orange;
				iCount++;
			}

		} // end while(iCount != 4)

		// debug
		/*for(ii = 0; ii < 4; ii++)
			ReportDebug(BIT0,_T("iLedArray[%d] = %d\n"), ii, iLedArray[ii]);
		*/

		// Get another random #. Use this as an index into iLedArray such that the content at that
		// index is copied to the last slot of the array. This is done to randomize the operator 
		// response so that an incorrect LED bitmap is shown for iLedArray[iIndex] and a correct
		// bitmap is shown for iLedArray[4] eventhough the actual LED shown on the system will be 
		// correct.
		// e.g. iIndex = 0 and iLedArray[0] = 2. So iLedArray[4] will also be 2. 2 = Red. The system
		//		displays Red LED. However, for iLedArray[0] either Green, Orange or Off LED bitmap 
		//      is shown and asked if it was red (the correct response is "No") and for iLedArray[4] 
		//		Red LED bitmap is shown (the correct response is "Yes").
		//      Next time iIndex could be 2 and so on...
		iIndex = random(&uiRandScratch) % 4;
		
		iLedArray[4] = iLedArray[iIndex];

		// debug
		/*for(ii = 0; ii < 5; ii++)
			ReportDebug(BIT0,_T("iLedArray[%d] = %d\n"), ii, iLedArray[ii]);
		*/

		// Get another random # that is used to randomly load an incorrect .bmp. This is done so that
		// same color .bmp will not be loaded every time.
		do
		{
			iIncorrectLED = random(&uiRandScratch) %4;
		} while(iIncorrectLED == iLedArray[4]);
		
		// Now set the desired LED color, ask the questions and record response
		for(ii = 0; ii < 5; ii++)
		{	
			// 0 = Off = 0x00, 1 = Green = 0x0F, 2 = Red = 0xF0, 3 = Orange = 0xFF
			switch(iLedArray[ii])
			{
				case 0:
					uLED = 0x00;
					break;
				case 1:
					uLED = 0x0F;
					break;
				case 2:
					uLED = 0xF0;
					break;
				case 3:
					uLED = 0xFF;
					break;
			} // end switch

			// Set LED to desired color - Off, Green, Red, Orange
			NtStatus = WriteSMBusValue(0x20, 0x08, FALSE, uLED);
			if(NtStatus != STATUS_SUCCESS)
			{
				err_Write(_T("LED State"), NtStatus);
				return LED_FAIL;
			}

			// Set LED Override to use the requested LED Behavior
			NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x01);
			if(NtStatus != STATUS_SUCCESS)
			{
				err_Write(_T("LED Override"), NtStatus);
				return LED_FAIL;
			}

			Sleep(500);

			// This is to set the LED on the system with the correct color but load up the
			// wrong .bmp file and make sure that the operator answered "No" when asked about
			// the LED color.
			if(ii == iIndex)
			{
				bResult = GetLEDStateFromTIUForSystemTest(iIncorrectLED, bPreviousResponseWrong);		

				if ((bResult == 0) && CheckAbort(HERE))
					break;
				else
				{
					if(bResult != IDCANCEL)
					{
						if (bPreviousResponseWrong || (dwLEDSystemTestTriesLeft <= 1)) // Bad response, and previous response is wrong or there are no more retries
						{
							err_LEDResponse(_T("No"), _T("Yes"));
							return LED_FAIL;
						}
						else // Bad response, but previous response was right and there are retreis left, so ask the question again
						{
							bPreviousResponseWrong = true;
							ii--; // Do this question over again
						}
					}
					else // This was a correct response
					{
						if (bPreviousResponseWrong) // The previous response was wrong, but this one was right, so retry the whole test.
							return LED_RETRY;
					}
				}
			}
			
			// Load the correct .bmp for LED and set the system with the correct LED.
			else
			{
				bResult = GetLEDStateFromTIUForSystemTest(iLedArray[ii], bPreviousResponseWrong);		
			
				if ((bResult == 0) && CheckAbort(HERE))
					break;
				else
				{
					if(bResult != IDOK) // This was an incorrect response
					{
						if (bPreviousResponseWrong || (dwLEDSystemTestTriesLeft <= 1)) // Bad response, and previous response is wrong or there are no more retries
						{
							err_LEDResponse(_T("Yes"), _T("No"));
							return LED_FAIL;
						}
						else // Bad response, but previous response was right and there are retreis left, so ask the question again
						{
							bPreviousResponseWrong = true;
							ii--; // Do this question over again
						}
					}
					else // This was a correct response
					{
						if (bPreviousResponseWrong) // The previous response was wrong, but this one was right, so retry the whole test.
							return LED_RETRY;
					}
				}
			}

			// Reset LED Override to use the default LED behavior
			NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x00);
			if(NtStatus != STATUS_SUCCESS)
			{
				err_Write(_T("LED Override"), NtStatus);
				return LED_FAIL;
			}

		} // end for(ii = 0; ii < 4; ii++)
	}
	else  // Perform the complex version of the test
	{
#define LED_YES 1
#define LED_NO  0
#define LED_NOT_ASSIGNED  100
#define MAX_NUM_QUESTIONS 6
	int iResponseExpected[MAX_NUM_QUESTIONS];
	DWORD dwYesColors[MAX_NUM_QUESTIONS];
	DWORD dwDisplayColor[MAX_NUM_QUESTIONS];
	DWORD dwQuestionColor[MAX_NUM_QUESTIONS];
	DWORD dwColorsUsed[4];
	DWORD dwNoLocation[2];
	DWORD i, j;
	DWORD dwNumQuestions, dwNumNoResponses=0, dwNumColors;
		for (i = 0; i < MAX_NUM_QUESTIONS; i++) // Start out assuming that all responses are supposed to be "Yes"
			iResponseExpected[i] = LED_YES;
		dwNumQuestions = (random(&uiRandScratch) % 2) + 5;  // 5 or 6 questions
		if (dwNumQuestions == 5)
		{
			if ((random(&uiRandScratch) % 5) == 4) // 80% weight on 1 No reponses; 20% weight on 0 No responses
				dwNumNoResponses = 0;
			else
				dwNumNoResponses = 1;
		}
		else
			dwNumNoResponses = (random(&uiRandScratch) % 2) + 1;  // 50% weight on 1 or 2 No responses
//ReportWarning(L"Questions = %lu, Nos = %lu", dwNumQuestions, dwNumNoResponses);
		for (i = 0; i < dwNumNoResponses; i++) // Fill the No response array
		{
			do {
				dwNoLocation[i] = (random(&uiRandScratch) % (3 + dwNumNoResponses));
			} while (iResponseExpected[dwNoLocation[i]] == LED_NO);
			iResponseExpected[dwNoLocation[i]] = LED_NO;
		}
		if (dwNumNoResponses == 2)
		{
			if (dwNoLocation[0] > dwNoLocation[1]) // Put the lower location first
			{
				j = dwNoLocation[0];
				dwNoLocation[0] = dwNoLocation[1];
				dwNoLocation[1] = j;
			}
		}
		// Choose the order of the colors for YES responses
		for (i = 0; i < 4; i++)  // No colors have been selected yet
			dwColorsUsed[i] = LED_NOT_ASSIGNED;
		for (i = 0; i < MAX_NUM_QUESTIONS; i++)
			dwDisplayColor[i] = LED_NOT_ASSIGNED;

		j = 0;
		for (i = 0; i < 4; i++)
		{
			do {
				dwYesColors[i] = (random(&uiRandScratch) % 4);
			} while (dwColorsUsed[dwYesColors[i]] != LED_NOT_ASSIGNED);
			dwColorsUsed[dwYesColors[i]] = 1;
			while (iResponseExpected[j] != LED_YES)
				j++;
			dwDisplayColor[j] = dwYesColors[i];
			j++;
		}
		if ((dwNumQuestions-dwNumNoResponses) == 5) // We need one more Yes color
		{
			dwYesColors[4] = (random(&uiRandScratch) % 4);
			while (iResponseExpected[j] != LED_YES)
				j++;
			dwDisplayColor[j] = dwYesColors[4];
		}
		for (i = 0; i < MAX_NUM_QUESTIONS; i++)  // Make the question and display arrays identical
			dwQuestionColor[i] = dwDisplayColor[i];
		for (i = 0; i < dwNumNoResponses; i++)  // Fill No slots of question array with colors
		{
			for (j = 0; j < 4; j++)  // No colors have been selected yet
				dwColorsUsed[j] = LED_NOT_ASSIGNED;
			for (j = 0; j < dwNoLocation[i]; j++) // Find all Yes colors so far up to this No question
			{
				if (iResponseExpected[j] == LED_YES)
					dwColorsUsed[dwQuestionColor[j]] = 1;
			}
			do {
				dwQuestionColor[j] = (random(&uiRandScratch) % 4);
			} while (dwColorsUsed[dwQuestionColor[j]] != LED_NOT_ASSIGNED);
		}
		// Put colors in the No locations of the display array.  Use colors not yet seen, if possible.
		for (i = 0; i < dwNumNoResponses; i++)  // Fill No slots of display array with colors
		{
			for (j = 0; j < 4; j++)  // No colors have been selected yet
				dwColorsUsed[j] = LED_NOT_ASSIGNED;
			for (j = 0; j < dwNoLocation[i]; j++) // Find all display colors (either yes or no) so far up to this No question
			{
//				if (iResponseExpected[j] == LED_YES)
					dwColorsUsed[dwDisplayColor[j]] = 1;
			}
			dwColorsUsed[dwQuestionColor[dwNoLocation[i]]] = 1; // Don't display the color we ask in the No question!
			dwNumColors = 0;
			for (j = 0; j < 4; j++) // Count how many colors have been used
			{
				if (dwColorsUsed[j] != LED_NOT_ASSIGNED)
					dwNumColors++;
			}
			if (dwNumColors < 4) // There is at least one color that has not been displayed, so find it
			{
				do {
					dwDisplayColor[dwNoLocation[i]] = (random(&uiRandScratch) % 4);
				} while (dwColorsUsed[dwDisplayColor[dwNoLocation[i]]] != LED_NOT_ASSIGNED);
			}
			else // All colors have already been displayed.  Just select a random one that isn't the one being asked in the No question
			{
				for (j = 0; j < 4; j++)  // No colors have been selected yet
					dwColorsUsed[j] = LED_NOT_ASSIGNED;
				dwColorsUsed[dwQuestionColor[dwNoLocation[i]]] = 1; // Don't display the color we ask in the No question!
				do {
					dwDisplayColor[dwNoLocation[i]] = (random(&uiRandScratch) % 4);
				} while (dwColorsUsed[dwDisplayColor[dwNoLocation[i]]] != LED_NOT_ASSIGNED);
			}
		}
//for (i = 0; i < dwNumQuestions; i++)
//ReportWarning(L"Question %lu = %lu, question color %lu display %lu", i, iResponseExpected[i], dwQuestionColor[i], dwDisplayColor[i]);
//for (i = 0; i < dwNumNoResponses; i++)
//ReportWarning(L"No Response %lu location = %lu", i, dwNoLocation[i]);

		// Now set the desired LED color, ask the questions and record response
		for(ii = 0; ii < (int)dwNumQuestions; ii++)
		{	
			// 0 = Off = 0x00, 1 = Green = 0x0F, 2 = Red = 0xF0, 3 = Orange = 0xFF
			switch(dwDisplayColor[ii])
			{
				case 0:
					uLED = 0x00;
					break;
				case 1:
					uLED = 0x0F;
					break;
				case 2:
					uLED = 0xF0;
					break;
				case 3:
					uLED = 0xFF;
					break;
			} // end switch

			// Set LED to desired color - Off, Green, Red, Orange
			NtStatus = WriteSMBusValue(0x20, 0x08, FALSE, uLED);
			if(NtStatus != STATUS_SUCCESS)
			{
				err_Write(_T("LED State"), NtStatus);
				return LED_FAIL;
			}

			// Set LED Override to use the requested LED Behavior
			NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x01);
			if(NtStatus != STATUS_SUCCESS)
			{
				err_Write(_T("LED Override"), NtStatus);
				return LED_FAIL;
			}

			Sleep(500);

			// This is to set the LED on the system with the correct color but load up the
			// wrong .bmp file and make sure that the operator answered "No" when asked about
			// the LED color.
			if(iResponseExpected[ii] == LED_NO)
			{
				bResult = GetLEDStateFromTIUForSystemTest((int)dwQuestionColor[ii], bPreviousResponseWrong);

				if ((bResult == 0) && CheckAbort(HERE))
					break;
				else
				{
					if(bResult != IDCANCEL)
					{
						if (bPreviousResponseWrong || (dwLEDSystemTestTriesLeft <= 1)) // Bad response, and previous response is wrong or there are no more retries
						{
							err_LEDResponse(_T("No"), _T("Yes"));
							return LED_FAIL;
						}
						else // Bad response, but previous response was right and there are retreis left, so ask the question again
						{
							bPreviousResponseWrong = true;
							ii--; // Do this question over again
						}
					}
					else // This was a correct response
					{
						if (bPreviousResponseWrong) // The previous response was wrong, but this one was right, so retry the whole test.
							return LED_RETRY;
					}
				}
			}
			
			// Load the correct .bmp for LED and set the system with the correct LED.
			else
			{
				bResult = GetLEDStateFromTIUForSystemTest((int)dwQuestionColor[ii], bPreviousResponseWrong);
			
				if ((bResult == 0) && CheckAbort(HERE))
					break;
				else
				{
					if(bResult != IDOK) // This was an incorrect response
					{
						if (bPreviousResponseWrong || (dwLEDSystemTestTriesLeft <= 1)) // Bad response, and previous response is wrong or there are no more retries
						{
							err_LEDResponse(_T("Yes"), _T("No"));
							return LED_FAIL;
						}
						else // Bad response, but previous response was right and there are retreis left, so ask the question again
						{
							bPreviousResponseWrong = true;
							ii--; // Do this question over again
						}
					}
					else // This was a correct response
					{
						if (bPreviousResponseWrong) // The previous response was wrong, but this one was right, so retry the whole test.
							return LED_RETRY;
					}
				}
			}

			// Reset LED Override to use the default LED behavior
			NtStatus = WriteSMBusValue(0x20, 0x07, FALSE, 0x00);
			if(NtStatus != STATUS_SUCCESS)
			{
				err_Write(_T("LED Override"), NtStatus);
				return LED_FAIL;
			}

		} // end for(ii = 0; ii < dwNumQuestions; ii++)
	}
	return LED_OK;
}


// This is an interractive test. It arranges the LED colors in a random order in an array of 4. Then 
// picks another random # as an index such that the LED color at that index is also copied to the 
// last slot of an arrayof 5. So there will be 3 unique and two duplicate LEDs. For the unique LEDs, 
// the system turns on that LED color and asks the "correct" question for that color. For the 
// duplicate LEDs, correct quesiton is asked for the last slot (5) and correct LED color is set on
// the system however, "incorrect" question is asked by loading an incorrect .bmp from any of the
// the three unique colors. This is also done by generating another random # so that an incorrect
// LED color .bmp is not loaded all the time.
//
// This test also includes a more random version that is enabled when the
// LEDSystemTestComplexity parameter is set to 1.  This version asks up to 6
// questions and can include up to 2 No reponses.  This version requires more
// operator attention, and guarantees that test operators observe the
// state of the LED for at least 85% of their responses (where only 47% of
// the responses need to be observed with the simpler test).
IMPLEMENT_TESTUNLOCKED (SMC, LEDSystemTest, 6)
{
	DWORD dwResult;
	DWORD dwLEDSystemTestTriesLeft = dwLEDSystemTestTriesAllowed;

	while (dwLEDSystemTestTriesLeft > 0)
	{
		if ((dwResult = dwLEDSystemTest(dwLEDSystemTestTriesLeft)) == LED_FAIL)
			return; // This was a failure that could not be recovered, or all retries are used up
		else if(dwResult == LED_OK) // We passed the entire test
			break;
		dwLEDSystemTestTriesLeft--;
	}
} // end IMPLEMENT_TESTUNLOCKED (SMC, LEDSystemTest, 6)



// This test reads the CPU Junction and Internal Air temps and compares them against their lower
// and upper limits as specified in the cfg params. The purpose of this test is to make sure 
// that the temp sensor is not stuck at one value (at board and system level).
IMPLEMENT_TESTUNLOCKED (SMC, ThermalTest, 7)
{
	ULONG uDataValue;

	// Read the CPU Junction Temp
	NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue); 
	ReportStatistic(CPU_JUNCTION_TEMP, _T("%d"), uDataValue);

	// Compare the CPU Junction Temp with lower and upper limits 
	if((uDataValue < uiCpuJunTempLL) || (uDataValue > uiCpuJunTempUL))
	{
		err_CpuJunctionTemp(uDataValue, uiCpuJunTempLL, uiCpuJunTempUL);
		return;
	}

	// Read the Internal Air Temp
	NtStatus = ReadSMBusValue(0x20, 0x0A, FALSE, &uDataValue);
	ReportStatistic(INTERNAL_AIR_TEMP, _T("%d"), uDataValue);
	
	// Compare the Internal Air Temp with lower and upper limits 
	if((uDataValue < uiInternalAirTempLL) || (uDataValue > uiInternalAirTempUL))
	{
		err_InternalAirTemp(uDataValue, uiInternalAirTempLL, uiInternalAirTempUL);
		return;
	}

} // end IMPLEMENT_TESTUNLOCKED (SMC, ThermalTest, 7)



// This utility clamps and unclamps the audio depending on the AudioClamp
// configuration parameter (yes = clamp audio, no = unclamp audio).
IMPLEMENT_TESTUNLOCKED (SMC, AudioClampUtility, 8)
{
	int iResult;

	// Configuration parameter = "No" implies, release the audio clamp
	if((iResult = _tcsicmp(pwsAudioClamp, _T("No"))) == 0)
	{
		NtStatus = WriteSMBusValue(0x20, 0x0B, FALSE, 0x00);

		if(NtStatus != STATUS_SUCCESS)
		{
			err_AudioClampRelease();
			return;
		}
	}

	// Assume configuration parameter = "Yes" implies, clamp the audio
	else
	{
		NtStatus = WriteSMBusValue(0x20, 0x0B, FALSE, 0x01);

		if(NtStatus != STATUS_SUCCESS)
		{
			err_AudioClamp();
			return;
		}
	}

} // end IMPLEMENT_TESTUNLOCKED (SMC, AudioClampUtility, 8)
 


IMPLEMENT_TESTUNLOCKED (SMC, DVDTrayStatesandEmptyTest, 9)
{
	#define DVD_DELAY_BEWTEEN_POLLS 20  // Number of milliseconds to sleep between polls of SMC registers
	ULONG uDataValue, i, j, NumLoops; 
	bool bJustEjected;
	DWORD dwMediaDetectNumLoops;

	NumLoops = DVD_TIMEOUT_BETWEEN_OPERATIONS/DVD_DELAY_BEWTEEN_POLLS;
	dwMediaDetectNumLoops = dwDVDMediaDetectTimeout/DVD_DELAY_BEWTEEN_POLLS;
	// Wait for detection of media in the DVD drive
	for (i = 0; i < NumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("DVD TrayState"), NtStatus); 
			return;
		}
		if (uDataValue == 0x60)  // Media is detected with the tray closed
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == NumLoops)
	{
		err_NoDVDMediaDetected();
		return;
	}

	// Issue an Eject Command to open the DVD drive
	if ((NtStatus = WriteSMBusValue(0x20, 0x0C, FALSE, 0x00)) != STATUS_SUCCESS)
	{
		err_Write(_T("DVD Tray Operation"), NtStatus); 
		return;
	}
	bJustEjected = TRUE;
	
	// Wait for activity to be indicated
	for (i = 0; i < NumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("DVD TrayState"), NtStatus); 
			return;
		}
		if ((uDataValue & 0x01) == 0x01)  // Activity is indicated by the DVD drive
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == NumLoops)
	{
		err_NoDVDActivityDetected();
		return;
	}

	for (j=5; j > 0; j--) // Keep re-ejecting the tray forever until media is removed
	{
		if (!bJustEjected)
		{
			// Issue an Eject Command to open the DVD drive (again for repeated loops)
			if ((NtStatus = WriteSMBusValue(0x20, 0x0C, FALSE, 0x00)) != STATUS_SUCCESS)
			{
				err_Write(_T("DVD Tray Operation"), NtStatus); 
				return;
			}
		}
		bJustEjected = FALSE;

		// Wait for tray open state to be indicated
		for (i = 0; i < NumLoops; i++)
		{
			if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
			{
				err_Read(_T("DVD TrayState"), NtStatus); 
				return;
			}
			if (uDataValue == 0x10)  // The tray is open
				break;
			Sleep(DVD_DELAY_BEWTEEN_POLLS);
		}
		if (i == NumLoops)
		{
			err_DVDTrayNotOpen();
			return;
		}

		// Wait forever for a state change from Tray Open; send a keep-alive every 5 seconds
		i = 5000/DVD_DELAY_BEWTEEN_POLLS;
		for (;;)
		{
			if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
			{
				err_Read(_T("DVD TrayState"), NtStatus); 
				return;
			}
			if (uDataValue != 0x10)  // The tray is not open
				break;
			if (CheckAbort(HERE))
				return;
			if (--i == 0)
			{
				ReportDebug(BIT0, _T("Waiting for DVD state to change from tray open"));
				i = 5000/DVD_DELAY_BEWTEEN_POLLS;
			}
			Sleep(DVD_DELAY_BEWTEEN_POLLS);
		}

		// Wait for tray closing to be indicated
		for (i = 0; i < NumLoops; i++)
		{
			if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
			{
				err_Read(_T("DVD TrayState"), NtStatus); 
				return;
			}
			if ((uDataValue & 0x70) == 0x50)  // Tray closing is indicated by the DVD drive
				break;
			Sleep(DVD_DELAY_BEWTEEN_POLLS);
		}
		if (i == NumLoops)
		{
			continue;
		}

		// Wait for tray closed media detected or tray closed no media detected state to be indicated
		for (i = 0; i < dwMediaDetectNumLoops; i++)
		{
			if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
			{
				err_Read(_T("DVD TrayState"), NtStatus); 
				return;
			}
			if ((uDataValue == 0x40) || (uDataValue == 0x60)) // The tray is closed
				break;
			Sleep(DVD_DELAY_BEWTEEN_POLLS);
		}
		if (i == dwMediaDetectNumLoops)
		{
			continue;
		}

		if (uDataValue == 0x60) // The media is still in?  Let's debounce this with a no-media detect just to make sure
		{
			// Wait for 1 second for tray closed no media detected state to be indicated
			for (i = 0; i < 1000/DVD_DELAY_BEWTEEN_POLLS; i++)
			{
				if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
				{
					err_Read(_T("DVD TrayState"), NtStatus); 
					return;
				}
				if (uDataValue == 0x40) // The tray is closed and empty
					break;
				Sleep(DVD_DELAY_BEWTEEN_POLLS);
			}
			if (i == 1000/DVD_DELAY_BEWTEEN_POLLS)
			{
				continue;
			}
		}

		// The tray is closed with no media, so exit with a PASS
		break;
	}
	if (j == 0) // We never saw the tray close without media, so fail
		err_NoDVDMediaNotDetected();


// Test shutdown when the door is open
} // end IMPLEMENT_TESTUNLOCKED (SMC, DVDTrayStatesandEmptyTest, 9)



IMPLEMENT_TESTUNLOCKED (SMC, AirSensorCalibrationUtility, 10)
{
	// AirSensor = 1 => Off
	//	         = 0 => On
	BYTE bAirSensor;
	
	// Set fan speed to desired speed
	// Max fan speed = 25
	NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x19); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus); 
		return;
	}

	// Set fan Override to use the requested fan speed
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

	Sleep(500);
	// debug
	//ReportDebug(BIT0,_T("Fan at speed 25\n"));	

	bAirSensor = GetAirSensorFromTIU();
	while(bAirSensor != 0)
	{
		bAirSensor = GetAirSensorFromTIU();
		// debug
		ReportDebug(BIT0,_T("AireSensor = %d, implies its Off\n"), bAirSensor);	
	}

	// debug
	ReportDebug(BIT0,_T("Stop Calibration. AireSensor = %d, implies its On\n"), bAirSensor);	

	// Reset fan override
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

} // end IMPLEMENT_TESTUNLOCKED (SMC, AirSensorCalibrationUtility, 10)



IMPLEMENT_TESTUNLOCKED (SMC, FanSpeedSystemTest, 11)
{
	BYTE bAirSensor;
	
	// Set fan speed to desired speed
	// Fan speed = 0
	NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x00); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus); 
		return;
	}

	// Set fan Override to use the requested fan speed
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

	Sleep(15000);
	bAirSensor = GetAirSensorFromTIU();

	// debug
	ReportDebug(BIT0,_T("Fan at speed 0\n"));	
	if(bAirSensor == 0)
		err_AirSensor(00, bAirSensor, _T("On"), 1, _T("Off"));
	// debug
	//else
	//	ReportDebug(BIT0,_T("AirSensor = %d, Off.\n"), bAirSensor);

	// Reset fan override
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}


	// Max fan speed = 50 
	NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x32); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus); 
		return;
	}

	// Set fan Override to use the requested fan speed
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}

	Sleep(15000);
	bAirSensor = GetAirSensorFromTIU();

	// debug
//	ReportDebug(BIT0,_T("Fan at speed 50\n"));	

	if(bAirSensor == 1)
		err_AirSensor(50, bAirSensor, _T("Off"), 0, _T("On"));
	// debug
	//else
	//	ReportDebug(BIT0,_T("AirSensor = %d, On.\n"), bAirSensor);

	// Reset fan override
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}
	
} // end IMPLEMENT_TESTUNLOCKED (SMC, FanSpeedSystemTest, 11)



// This utility takes the system into thermal overload. This utility shouldn't be used
// with the regular test package. 
// The fan is turned off and the CPU Junction and Internal Air temperatures are read 
// every 5 secs. As soon as the thermal overload condition is reached, the system will 
// automatically flash the LED and turn on the fan to full speed (50).
IMPLEMENT_TESTUNLOCKED (SMC, ThermalOverloadUtility, 12)
{	
	ULONG uDataValue; 
	// Turn the fan off.
	NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x00); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus);  
		return;
	} 

	// Set fan Override to use the requested fan speed
	NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
		return;
	}
 
	Sleep(500);
	
	// Keep on reading the CPU Junction and Internal Air Temperatures every 5 secs.
	// As soon as the system reaches thermal overload, it'll shut down, the fan will
	// turn on to full speed and orange LED will flash. After about a minute, the
	// system will completely shut off.
	for (;;)
	{ 
		NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue); 
		ReportStatistic(CPU_JUNCTION_TEMP, _T("%d"), uDataValue);
		NtStatus = ReadSMBusValue(0x20, 0x0A, FALSE, &uDataValue);
		ReportStatistic(INTERNAL_AIR_TEMP, _T("%d"), uDataValue);
		Sleep(5000);
	}

} // end IMPLEMENT_TESTUNLOCKED (SMC, ThermalOverloadUtility, 12)



// This utility keeps on reading the CPU Junction and Internal Air Temperatures every 5 secs.
IMPLEMENT_TESTUNLOCKED (SMC, ReadTempUtility, 13)
{
	ULONG uDataValue;
 
	// Read the CPU Juntion Temp
	NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue); 
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Read(_T("CPU Juntion Temperature"), NtStatus);
		return;
	}
	ReportStatistic(CPU_JUNCTION_TEMP, _T("%d"), uDataValue);

	// Read the Internal Air Temp
	NtStatus = ReadSMBusValue(0x20, 0x0A, FALSE, &uDataValue);
	if(NtStatus != STATUS_SUCCESS)
	{
		err_Read(_T("Internal Air Temperature"), NtStatus);
		return;
	}
	ReportStatistic(INTERNAL_AIR_TEMP, _T("%d"), uDataValue);
	Sleep(5000);

} // end IMPLEMENT_TESTUNLOCKED (SMC, ReadTempUtility, 13)


// This utility shuts down the system.
IMPLEMENT_TESTUNLOCKED (SMC, SystemShutdownUtility, 14)
{
	TCHAR tcBuffer[300]; // Holds data to send to the host in messages
	int iError;
	DWORD dwBufferLength;

	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_TESTEND command for this test
//	_stprintf(tcBuffer, _T("%s.%s"), GetModuleName(), GetTestName());
	_stprintf(tcBuffer, _T("%s"), GetFullName());
	dwBufferLength = (_tcslen(tcBuffer) + 1) * sizeof(TCHAR);
	// Add the 2 DWORDs here (10 and 1)
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 10; // Elapsed time for this test (set to 10 ms)
	dwBufferLength = dwBufferLength + sizeof(DWORD);
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 1; // PASSED indication
	dwBufferLength = dwBufferLength + sizeof(DWORD);

	if ((iError = g_host.iSendHost(MID_UUT_TESTEND, (char *)&tcBuffer[0], dwBufferLength))
		 != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		err_HostCommunicationError(iError);
		if(CheckAbort(HERE))
			return;
	}
	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_ENDING command for this test
	if ((iError = g_host.iSendHost(MID_UUT_ENDING, NULL, 0))
		 != EVERYTHINGS_OK)
	{
		// The test has officially ended due to the message above, so don't send any more error messages.
		// Restart the unit below and it will fail on the next boot.
	}

	// Shutdown the system by writing 0x80 to the SMC System Reset Register
	NtStatus = WriteSMBusValue(0x20, 0x02, FALSE, 0x80);
	if(NtStatus != STATUS_SUCCESS)
	{
		// Again, don't report an error because no one is listening
//		err_Reset(NtStatus);
//		return;
	}
	Sleep(INFINITE);

} // end IMPLEMENT_TESTUNLOCKED (SMC, SystemShutdownUtility, 14)

// This utility resets the system.
IMPLEMENT_TESTUNLOCKED (SMC, SystemPowerCycleUtility, 15)
{
	TCHAR tcBuffer[300]; // Holds data to send to the host in messages
	int iError;
	DWORD dwBufferLength;

	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_TESTEND command for this test
//	_stprintf(tcBuffer, _T("%s.%s"), GetModuleName(), GetTestName());
	_stprintf(tcBuffer, _T("%s"), GetFullName());
	dwBufferLength = (_tcslen(tcBuffer) + 1) * sizeof(TCHAR);
	// Add the 2 DWORDs here (10 and 1)
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 10; // Elapsed time for this test (set to 10 ms)
	dwBufferLength = dwBufferLength + sizeof(DWORD);
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 1; // PASSED indication
	dwBufferLength = dwBufferLength + sizeof(DWORD);

	if ((iError = g_host.iSendHost(MID_UUT_TESTEND, (char *)&tcBuffer[0], dwBufferLength))
		 != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		err_HostCommunicationError(iError);
		if(CheckAbort(HERE))
			return;
	}
	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_RESTARTING command for this test
	if ((iError = g_host.iSendHost(MID_UUT_RESTARTING, NULL, 0))
		 != EVERYTHINGS_OK)
	{
		// The test has officially ended due to the message above, so don't send any more error messages.
		// Restart the unit below and it will fail on the next boot.
	}

	// Power cycle the system by writing 0x40 to the SMC System Reset Register
	NtStatus = WriteSMBusValue(0x20, 0x02, FALSE, 0x40);
	if(NtStatus != STATUS_SUCCESS)
	{
		// Again, don't report an error because no one is listening
//		err_Reset(NtStatus);
//		return;
	}
	Sleep(INFINITE);

} // end IMPLEMENT_TESTUNLOCKED (SMC, SystemPowerCycleUtility, 15)

IMPLEMENT_TESTUNLOCKED (SMC, RegulateTemperatureUtility, 16)
{
	#define REGULATE_TEMP_UTILITY_WAIT_TIME 5000  // Wait for this many milliseconds between temperature reads
	HANDLE hAbortRegTempUtilityEvent = NULL;
	ULONG uDataValue = 0, uDataValue1 = 0;
	DWORD dwErrorCount = 10;
	DWORD dwCurrentElapsedTime = 0;
	CHostResponse CHR;
	int iError;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	bool bEventSignalled;

	if (dwRegulatedCPUTemperatureFanOff >= dwRegulatedCPUTemperatureFanOn)
	{
		ReportWarning(_T("RegulatedCPUTemperatureFanOff parameter is not less than RegulatedCPUTemperatureFanOn parameter, so aborting utility"));
		return;
	}


	if ((iError = g_host.iSendHost(MID_UUT_GET_ELAPSED_TIME, NULL, NULL, CHR, &dwActualBytesReceived, 
		 &dwErrorCodeFromHost, HOST_TIMEOUT)) != EVERYTHINGS_OK)
	{
		if (dwErrorCodeFromHost != 0)
		{
			// Process error from host
			err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
			return;
		}
		else
		{
			// Process a communication error
			// This test module just reports the number of the communication error that was received
			err_HostCommunicationError(iError);
			return;
		}
	}
	// Don't access the response buffer if it is NULL
	else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived < 4)) 
	{
		// The response buffer is empty, so take appropriate action (like an error message)
		err_BufferIsEmpty();
		return;
	}
	
	else // The response is not NULL, and is not an error message, so process it
	{
		// Copy the data received to a local buffer for processing
		dwCurrentElapsedTime = *(DWORD*)CHR.pvBufferFromHost;  
	}

	// Create a manual-reset event.  Non-signaled to start with
	if ((hAbortRegTempUtilityEvent = CreateEventA(NULL, TRUE, FALSE, REG_TEMP_UTILITY_EVENT_NAME)) == NULL)
	{
		err_CreateEventFailed(REG_TEMP_UTILITY_EVENT_NAME);
		return;
	}

	if ((dwCurrentElapsedTime > dwRegulatedTemperatureMinTimeFanSteady) && (dwCurrentElapsedTime < dwRegulatedTemperatureMaxTimeFanSteady))
	{
		// Fan speed to set
		if ((NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, dwRegulatedTemperatureFanSteadyValue)) != STATUS_SUCCESS)
		{
			err_Write(_T("Fan Speed"), NtStatus); 
		}
		// Set fan Override to use the requested fan speed
		if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01)) != STATUS_SUCCESS)
		{
			err_Write(_T("Fan Override"), NtStatus);
		}

		// Take an initial reading of the CPU temperature
		if ((NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("CPU Juntion Temperature"), NtStatus);
		}

		bEventSignalled = false;
		for(;;)
		{
			if (WaitForSingleObject(hAbortRegTempUtilityEvent, REGULATE_TEMP_UTILITY_WAIT_TIME) != WAIT_TIMEOUT)
			{
				bEventSignalled = true;
				break;
			}
			if (CheckAbort(HERE)) // Keep-alive to XMTA
				break;
			if ((NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue)) != STATUS_SUCCESS)
			{
				err_Read(_T("CPU Juntion Temperature"), NtStatus);
				break;
			}
			if ((NtStatus = ReadSMBusValue(0x20, 0x0A, FALSE, &uDataValue1)) != STATUS_SUCCESS)
			{
				err_Read(_T("Internal air Temperature"), NtStatus);
				break;
			}
			ReportDebug(BIT0,_T("CPU temperature: %lu, internal air: %lu"), uDataValue, uDataValue1); // Keep-alive to UHC
		}

		if (bEventSignalled)
		{
			ReportStatistic(CPU_JUNCTION_TEMP, _T("%d"), uDataValue);
			ReportStatistic(INTERNAL_AIR_TEMP, _T("%d"), uDataValue1);
			// Now compare the temperatures to the acceptable ranges
			if((uDataValue < uiCpuJunTempLL) || (uDataValue > uiCpuJunTempUL))
			{
				err_CpuJunctionTemp(uDataValue, uiCpuJunTempLL, uiCpuJunTempUL);
			}

			// Compare the Internal Air Temp with lower and upper limits 
			if((uDataValue1 < uiInternalAirTempLL) || (uDataValue1 > uiInternalAirTempUL))
			{
				err_InternalAirTemp(uDataValue1, uiInternalAirTempLL, uiInternalAirTempUL);
			}
		}
	}
	else // Regulate the temperature normally
	{
		// Max fan speed = 50 
		if ((NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x32)) != STATUS_SUCCESS)
		{
			err_Write(_T("Fan Speed"), NtStatus); 
		}
		// Set fan Override to use the requested fan speed
		if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01)) != STATUS_SUCCESS)
		{
			err_Write(_T("Fan Override"), NtStatus);
		}

		// Take an initial reading of the CPU temperature
		if ((NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("CPU Juntion Temperature"), NtStatus);
		}
		for(;;)
		{
			// Now wait for the temperature to drop below the off temperature
			while (uDataValue > dwRegulatedCPUTemperatureFanOff)
			{
				if (WaitForSingleObject(hAbortRegTempUtilityEvent, REGULATE_TEMP_UTILITY_WAIT_TIME) != WAIT_TIMEOUT)
					break;
				if (CheckAbort(HERE)) // Keep-alive to XMTA
					break;
				if ((NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue)) != STATUS_SUCCESS)
				{
					err_Read(_T("CPU Juntion Temperature"), NtStatus);
					break;
				}
				if (uDataValue > uiCpuJunTempCritical)
				{
					if (dwErrorCount > 0)
					{
						dwErrorCount--;
						err_CpuJunctionTempHigh(uDataValue, uiCpuJunTempCritical);
					}
				}

				NtStatus = ReadSMBusValue(0x20, 0x0A, FALSE, &uDataValue1);
				ReportDebug(BIT0,_T("CPU temperature = %lu, internal air = %lu"), uDataValue, uDataValue1); // Keep-alive to UHC
			}
			if (uDataValue > dwRegulatedCPUTemperatureFanOff) // Exited for a reason other than temp satisfied
				break;

			// Reset fan override
			if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00)) != STATUS_SUCCESS)
			{
				err_Write(_T("Fan Override"), NtStatus);
				break;
			}
			// Turn fan off
			if ((NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0)) != STATUS_SUCCESS)
			{
				err_Write(_T("Fan Speed"), NtStatus); 
				break;
			}
			// Set fan Override to use the requested fan speed
			if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01)) != STATUS_SUCCESS)
			{
				err_Write(_T("Fan Override"), NtStatus);
				break;
			}
			// Now wait for the temperature to rise above the on temperature
			while (uDataValue < dwRegulatedCPUTemperatureFanOn)
			{
				if (WaitForSingleObject(hAbortRegTempUtilityEvent, REGULATE_TEMP_UTILITY_WAIT_TIME) != WAIT_TIMEOUT)
					break;
				if (CheckAbort(HERE)) // Keep-alive to XMTA
					break;
				if ((NtStatus = ReadSMBusValue(0x20, 0x09, FALSE, &uDataValue)) != STATUS_SUCCESS)
				{
					err_Read(_T("CPU Juntion Temperature"), NtStatus);
					break;
				}
				NtStatus = ReadSMBusValue(0x20, 0x0A, FALSE, &uDataValue1);
				ReportDebug(BIT0,_T("CPU temperature = %lu, internal air = %lu"), uDataValue, uDataValue1); // Keep-alive to UHC
			}
			if (uDataValue < dwRegulatedCPUTemperatureFanOn) // Exited for a reason other than temp satisfied
				break;
			// Reset fan override
			if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00)) != STATUS_SUCCESS)
			{
				err_Write(_T("Fan Override"), NtStatus);
				break;
			}
			// Kick fan on full speed
			if ((NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x32)) != STATUS_SUCCESS)
			{
				err_Write(_T("Fan Speed"), NtStatus); 
				break;
			}
			// Set fan Override to use the requested fan speed
			if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01)) != STATUS_SUCCESS)
			{
				err_Write(_T("Fan Override"), NtStatus);
				break;
			}
		}
	}

	// Reset fan override
	if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x00)) != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
	}
	// Kick fan on full speed
	if ((NtStatus = WriteSMBusValue(0x20, 0x06, FALSE, 0x32)) != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Speed"), NtStatus); 
	}
	// Set fan Override to use the requested fan speed
	if ((NtStatus = WriteSMBusValue(0x20, 0x05, FALSE, 0x01)) != STATUS_SUCCESS)
	{
		err_Write(_T("Fan Override"), NtStatus);
	}

	CloseHandle(hAbortRegTempUtilityEvent);
} // end IMPLEMENT_TESTUNLOCKED (SMC, RegulateTemperatureUtility, 16)

IMPLEMENT_TESTUNLOCKED (SMC, AbortRegulateTemperatureUtility, 17)
{
	HANDLE hAbortRegTempUtilityEvent = NULL;

	// Create a manual-reset event.  Non-signaled to start with
	if ((hAbortRegTempUtilityEvent = CreateEventA(NULL, TRUE, FALSE, REG_TEMP_UTILITY_EVENT_NAME)) == NULL)
	{
		err_CreateEventFailed(REG_TEMP_UTILITY_EVENT_NAME);
		return;
	}

	SetEvent(hAbortRegTempUtilityEvent);

	CloseHandle(hAbortRegTempUtilityEvent);
} // end IMPLEMENT_TESTUNLOCKED (SMC, AbortRegulateTemperatureUtility, 17)

// This utility resets the system if the reboot count is not a multiple of a specified
// configuration parameter.  Otherwise it passes and allows other tests to execute
IMPLEMENT_TESTUNLOCKED (SMC, BootCountGateUtility, 18)
{
	TCHAR tcBuffer[300]; // Holds data to send to the host in messages
	int iError;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	DWORD dwBufferLength, dwBootCountGateValue, dwCurrentBootCount;
	CHostResponse CHR;


	if (gdwBootCountGateValue > 1) // Just PASS this utility if the boot count gate value is not greater than 1
	{
#ifdef RNR_MODE
		dwBootCountGateValue = gdwBootCountGateValue; // There is 1 boot count per test boot: just one for the test
#else
		dwBootCountGateValue = gdwBootCountGateValue*2; // There are 2 boot counts per test boot: one for the DVD, and one for the test
#endif
		// Retrieve the Boot count from the host
		// Use the full version of iSendHost because a response is expected.
		// No message is sent, only response is received after writing to the LED state register.
		// This message will receive a number indicating the state of the sensors on the XBOX.
		if ((iError = g_host.iSendHost(MID_UUT_GET_BOOT_COUNT, NULL, NULL, CHR, &dwActualBytesReceived, 
			 &dwErrorCodeFromHost, HOST_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		// Don't access the response buffer if it is NULL
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived < 4)) 
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_BufferIsEmpty();
			return;
		}
		
		else // The response is not NULL, and is not an error message, so process it
		{
			// Copy the data received to a local buffer for processing
			dwCurrentBootCount = *(DWORD*)CHR.pvBufferFromHost;  
			ReportStatistic(BOOT_COUNT, _T("%ld"), dwCurrentBootCount);
#ifdef RNR_MODE
			dwCurrentBootCount = (dwCurrentBootCount + 1);
#else
			dwCurrentBootCount = (dwCurrentBootCount + 1) & 0xFFFFFFFE;  // Make it an even number
#endif
			if (((dwCurrentBootCount + dwBootCountGateValue) % dwBootCountGateValue) != 0)
			{
				// Use the partial version of iSendHost because a response is not expected
				// No response is received, only message is sent
				// Send MID_UUT_TESTEND command for this test
				_stprintf(tcBuffer, _T("%s"), GetFullName());
				dwBufferLength = (_tcslen(tcBuffer) + 1) * sizeof(TCHAR);
				// Add the 2 DWORDs here (10 and 1)
				*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 10; // Elapsed time for this test (set to 10 ms)
				dwBufferLength = dwBufferLength + sizeof(DWORD);
				*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 1; // PASSED indication
				dwBufferLength = dwBufferLength + sizeof(DWORD);

				if ((iError = g_host.iSendHost(MID_UUT_TESTEND, (char *)&tcBuffer[0], dwBufferLength))
					 != EVERYTHINGS_OK)
				{
					// Process a communication error
					// This test module just reports the number of the communication error that was received
					err_HostCommunicationError(iError);
					if(CheckAbort(HERE))
						return;
				}
				// Use the partial version of iSendHost because a response is not expected
				// No response is received, only message is sent
				// Send MID_UUT_RESTARTING command for this test
				if ((iError = g_host.iSendHost(MID_UUT_RESTARTING, NULL, 0))
					 != EVERYTHINGS_OK)
				{
					// The test has officially ended due to the message above, so don't send any more error messages.
					// Restart the unit below and it will fail on the next boot.
				}

				// Power cycle the system by writing 0x40 to the SMC System Reset Register
				NtStatus = WriteSMBusValue(0x20, 0x02, FALSE, 0x40);
				if(NtStatus != STATUS_SUCCESS)
				{
					// Again, don't report an error because no one is listening
				}
				Sleep(INFINITE);
			}
		}
	}
}

IMPLEMENT_TESTUNLOCKED (SMC, DVDSpinDownUtility, 19)
{
	#define DVD_DELAY_BEWTEEN_POLLS 20  // Number of milliseconds to sleep between polls of SMC registers
	ULONG uDataValue, i, NumLoops; 
	TCHAR tcBuffer[300]; // Holds data to send to the host in messages
	int iError;
	DWORD dwBufferLength;
//	HANDLE hStartDVDSpinDownUtilityEvent = NULL;

	// Create a manual-reset event.  Non-signaled to start with
//	if ((hStartDVDSpinDownUtilityEvent = CreateEventA(NULL, TRUE, FALSE, DVD_SPIN_DOWN_UTILITY_EVENT_NAME)) == NULL)
//	{
//		err_CreateEventFailed(DVD_SPIN_DOWN_UTILITY_EVENT_NAME);
//		return;
//	}

	NumLoops = DVD_TIMEOUT_BETWEEN_OPERATIONS/DVD_DELAY_BEWTEEN_POLLS;
	// Wait for detection of media in the DVD drive
	for (i = 0; i < NumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("DVD TrayState"), NtStatus); 
			return;
		}
		if (uDataValue == 0x60)  // Media is detected with the tray closed
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == NumLoops)
	{
		err_NoDVDMediaDetected();
		return;
	}

	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_TESTEND command for this test
	_stprintf(tcBuffer, _T("%s"), GetFullName());
	dwBufferLength = (_tcslen(tcBuffer) + 1) * sizeof(TCHAR);
	// Add the 2 DWORDs here (10 and 1)
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 10; // Elapsed time for this test (set to 10 ms)
	dwBufferLength = dwBufferLength + sizeof(DWORD);
	*((DWORD *)&(((char *)tcBuffer)[dwBufferLength])) = 1; // PASSED indication
	dwBufferLength = dwBufferLength + sizeof(DWORD);

	if ((iError = g_host.iSendHost(MID_UUT_TESTEND, (char *)&tcBuffer[0], dwBufferLength))
		 != EVERYTHINGS_OK)
	{
		// Process a communication error
		// This test module just reports the number of the communication error that was received
		err_HostCommunicationError(iError);
		if(CheckAbort(HERE))
			return;
	}
	// Use the partial version of iSendHost because a response is not expected
	// No response is received, only message is sent
	// Send MID_UUT_ENDING command for this test
	if ((iError = g_host.iSendHost(MID_UUT_ENDING, NULL, 0))
		 != EVERYTHINGS_OK)
	{
		// The test has officially ended due to the message above, so don't send any more error messages.
		// Restart the unit below and it will fail on the next boot.
	}

	// Issue an Eject Command to