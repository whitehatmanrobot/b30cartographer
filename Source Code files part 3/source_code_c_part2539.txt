ourceArticulation;
        if (pArticulation)
        {
            pArticulation->Init(FALSE);
            HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable, 
                    pdmRegion->ulRegionArtIdx, fNewFormat);

            if (FAILED(hr))
            {
                delete pArticulation;
                return hr;
            }
            m_pArticulation = pArticulation;
            m_pArticulation->AddRef();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}



HRESULT CInstManager::DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat)
                                         
{
    DMUS_INSTRUMENT *pdmInstrument = (DMUS_INSTRUMENT *) pvData;
    CInstrument *pInstrument = new CInstrument;
    if (pInstrument)
    {
        Trace(3,"Downloading instrument %lx\n",pdmInstrument->ulPatch);
        pInstrument->m_dwProgram = pdmInstrument->ulPatch;

        DWORD dwRegionIX = pdmInstrument->ulFirstRegionIdx;
        pdmInstrument->ulFirstRegionIdx = 0; // Clear to avoid loops.
        while (dwRegionIX)
        {
            if (dwRegionIX >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because instrument has error in region list.\n");
                delete pInstrument;
                return DMUS_E_BADINSTRUMENT;
            }
            CSourceRegion *pRegion = new CSourceRegion;
            if (!pRegion)
            {
                delete pInstrument;
                return E_OUTOFMEMORY;
            }
            pInstrument->m_RegionList.AddHead(pRegion);
            HRESULT hr = pRegion->Download(pInfo, pvOffsetTable, &dwRegionIX, fNewFormat);
            if (FAILED(hr))
            {
                delete pInstrument;
                return hr;
            }
            EnterCriticalSection(&m_CriticalSection);
            CWave *pWave = m_WavePool[pRegion->m_Sample.m_wID % WAVE_HASH_SIZE].GetHead();
            for (;pWave;pWave = pWave->GetNext())
            {
                if (pRegion->m_Sample.m_wID == pWave->m_dwID)
                {
                    pRegion->m_Sample.m_pWave = pWave;
                    pWave->AddRef();
                    pRegion->m_Sample.CopyFromWave();
                    break;
                }
            }
            LeaveCriticalSection(&m_CriticalSection);
        }
        if (pdmInstrument->ulGlobalArtIdx)
        {
            if (pdmInstrument->ulGlobalArtIdx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because of out of range articulation chunk.\n");
                delete pInstrument;
                return DMUS_E_BADARTICULATION;
            }

            CSourceArticulation *pArticulation = new CSourceArticulation;
            if (pArticulation)
            {
                pArticulation->Init(FALSE);
                HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable, 
                        pdmInstrument->ulGlobalArtIdx, fNewFormat);
                if (FAILED(hr))
                {
                    delete pArticulation;
                    return hr;
                }
                for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                     pr != NULL;
                     pr = pr->GetNext())
                {
                    if (pr->m_pArticulation == NULL)
                    {
                        pr->m_pArticulation = pArticulation;
                        pArticulation->AddRef();    
                    }
                }
                if (!pArticulation->m_wUsageCount)
                {
                    delete pArticulation;
                }
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                 pr != NULL;
                 pr = pr->GetNext())
            {
                if (pr->m_pArticulation == NULL)
                {
                    Trace(1,"Error: Download failed because region has no articulation.\n");
                    delete pInstrument;
                    return DMUS_E_NOARTICULATION;
                }
            }
        }
        EnterCriticalSection(&m_CriticalSection);
        m_InstrumentList.AddHead(pInstrument);
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pInstrument;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWave(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData)
{
    DMUS_WAVE *pdmWave = (DMUS_WAVE *) pvData; 
    if ((pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_PCM) &&
        (pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_XBOX_ADPCM))
    {
        Trace(1,"Error: Download failed because wave data is not PCM format.\n");
        return DMUS_E_NOTPCM;
    }
    
    if (pdmWave->WaveformatEx.nChannels != 1)
    {
        Trace(1,"Error: Download failed because wave data is not mono.\n");
        return DMUS_E_NOTMONO;
    }

    if (pdmWave->ulWaveDataIdx >= pInfo->dwNumOffsetTableEntries)
    {
        Trace(1,"Error: Download failed because wave data is at invalid location.\n");
        return DMUS_E_BADWAVE;
    }

    CWave *pWave = new CWave;
    if (pWave)
    {   
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *) 
            pvOffsetTable[pdmWave->ulWaveDataIdx];
        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_dwSampleDataSize = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];
        pWave->m_WaveFormat.wfx = pdmWave->WaveformatEx;

        if (pdmWave->WaveformatEx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            pWave->m_WaveFormat.wSamplesPerBlock = 64;
        }
        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        // Track memory usage 
        m_dwSynthMemUse += pWave->m_dwSampleDataSize;  
        Trace(3,"Downloading wave %ld memory usage %ld\n",pInfo->dwDLId,m_dwSynthMemUse);

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::Download(LPHANDLE phDownload, 
                               void * pvData,
                               LPBOOL pbFree)
                               

{
    V_INAME(IDirectMusicSynthX::Download);
    V_BUFPTR_READ(pvData,sizeof(DMUS_DOWNLOADINFO));

    HRESULT hr = DMUS_E_UNKNOWNDOWNLOAD;
    void ** ppvOffsetTable;     // Array of pointers to chunks in data.
    DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *) pvData;
    DMUS_OFFSETTABLE* pOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvData) + sizeof(DMUS_DOWNLOADINFO));
    char *pcData = (char *) pvData;

    V_BUFPTR_READ(pvData,pInfo->cbSize);

    //Code fails if pInfo->dwNumOffsetTableEntries == 0
    //Saninty check here for debug
    assert(pInfo->dwNumOffsetTableEntries);
    
    ppvOffsetTable = new void *[pInfo->dwNumOffsetTableEntries];
    if (ppvOffsetTable) // Create the pointer array and validate.
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < pInfo->dwNumOffsetTableEntries; dwIndex++)
        {
            if (pOffsetTable->ulOffsetTable[dwIndex] >= pInfo->cbSize)
            {
                delete[] ppvOffsetTable;
                Trace(1,"Error: Download failed because of corrupt download tables.\n");
                return DMUS_E_BADOFFSETTABLE;   // Bad!
            }
            ppvOffsetTable[dwIndex] = (void *) &pcData[pOffsetTable->ulOffsetTable[dwIndex]];
        }
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) // Instrument.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],FALSE); 
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) // New instrument format.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],TRUE); 
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE) // Wave.
        {
            *pbFree = FALSE;
            hr = DownloadWave(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
        }
//        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVEARTICULATION) // Wave onshot & streaming 
//        {
//            *pbFree = TRUE;
//            hr = DownloadWaveArticulation(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
//        }
//        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE) // Streaming 
//        {
//            *pbFree = FALSE;
//            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
//        }
//        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_ONESHOTWAVE) // Wave onshot
//        {
//            *pbFree = FALSE;
//            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
//        }

        delete[] ppvOffsetTable;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CInstManager::Unload(HANDLE hDownload,
                             HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                             HANDLE hUserData)

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    CInstrument *pInstrument = m_InstrumentList.GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument == (CInstrument *) hDownload) 
        {
            Trace(3,"Unloading instrument %lx\n",pInstrument->m_dwProgram);
            m_InstrumentList.Remove(pInstrument);
            delete pInstrument;
            LeaveCriticalSection(&m_CriticalSection);
            return S_OK;
        }
    }
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWave *pWave = m_WavePool[dwIndex].GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            if (pWave == (CWave *) hDownload)
            {
                // Track memory usage 
                m_dwSynthMemUse -= pWave->m_dwSampleDataSize;  

                Trace(3,"Unloading wave %ld memory usage %ld\n",pWave->m_dwID,m_dwSynthMemUse);
                m_WavePool[dwIndex].Remove(pWave);

                pWave->m_hUserData = hUserData;
                pWave->m_lpFreeHandle = lpFreeHandle;
                pWave->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
/*    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWaveArt* pWaveArt = m_WaveArtList[dwIndex].GetHead();
        for (;pWaveArt != NULL;pWaveArt = pWaveArt->GetNext())
        {
            if (pWaveArt == (CWaveArt *) hDownload)
            {
                Trace(3,"Unloading wave articulation %ld\n",pWaveArt->m_dwID,m_dwSynthMemUse);
                m_WaveArtList[dwIndex].Remove(pWaveArt);

                pWaveArt->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }*/
    LeaveCriticalSection(&m_CriticalSection);
    Trace(1,"Error: Unload failed - downloaded object not found.\n");
    return E_FAIL;
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

/*CWave * CInstManager::GetWave(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWave *pWave = m_WavePool[dwDLId % WAVE_HASH_SIZE].GetHead();
    for (;pWave;pWave = pWave->GetNext())
    {
        if (dwDLId == pWave->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWave;
}*/

/*CWaveArt *  CInstManager::GetWaveArt(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWaveArt *pWaveArt = m_WaveArtList[dwDLId % WAVEART_HASH_SIZE].GetHead();
    for (;pWaveArt;pWaveArt = pWaveArt->GetNext())
    {
        if (dwDLId == pWaveArt->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWaveArt;
}

HRESULT CInstManager::DownloadWaveArticulation(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData)
{
    DMUS_WAVEARTDL* pWaveArtDl  = (DMUS_WAVEARTDL*)pvData; 
    WAVEFORMATEX *pWaveformatEx = (WAVEFORMATEX *) pvOffsetTable[1]; 
    DWORD *dwDlId = (DWORD*)pvOffsetTable[2]; 
    DWORD i;

    CWaveArt* pWaveArt = new CWaveArt();
    if ( pWaveArt )
    {
        pWaveArt->m_dwID = pInfo->dwDLId;
        pWaveArt->m_WaveArtDl = *pWaveArtDl;;
        pWaveArt->m_WaveformatEx = *pWaveformatEx;
        if (pWaveArt->m_WaveformatEx.nChannels > 1)
        {
            pWaveArt->m_WaveformatEx.nAvgBytesPerSec /= pWaveArt->m_WaveformatEx.nChannels;
            pWaveArt->m_WaveformatEx.nBlockAlign /= pWaveArt->m_WaveformatEx.nChannels;
            pWaveArt->m_WaveformatEx.nChannels = 1;
        }
        if (pWaveformatEx->wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            pWaveArt->m_bSampleType = SFORMAT_ADPCM;
        }
        else if (pWaveformatEx->wBitsPerSample == 8)
        {
            pWaveArt->m_bSampleType = SFORMAT_8;
        }
        else if (pWaveformatEx->wBitsPerSample == 16)
        {
            pWaveArt->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
            delete pWaveArt;
            return DMUS_E_BADWAVE;
        }

        for ( i = 0; i < pWaveArtDl->ulBuffers; i++ )
        {
            // Get wave buffer and fill header with waveformat data
            CWave *pWave = GetWave(dwDlId[i]);
            assert(pWave);
            if (!pWave)
            {
                delete pWaveArt;
                return E_POINTER;
            }
            pWave->m_dwSampleRate = pWaveformatEx->nSamplesPerSec;
            // Reset the sample length so it can be set correctly in the ensuing sample size cases.
            pWave->m_dwSampleLength = pWave->m_dwSampleDataSize;

            if (pWaveformatEx->wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
            {
                // Every 36 bytes is 64 samples. Buffer must be a multiple of 36 bytes or the
                // wave will be garbled on playback when we cross a buffer boundary.
                assert(pWave->m_dwSampleLength / 36 * 36 == pWave->m_dwSampleLength);

                pWave->m_dwSampleLength /= 36;
                pWave->m_dwSampleLength *= 64;  // This forces it to be block aligned.
                pWave->m_bSampleType = SFORMAT_ADPCM;
            }
            else if (pWaveformatEx->wBitsPerSample == 8)
            {
                pWave->m_bSampleType = SFORMAT_8;
            }
            else if (pWaveformatEx->wBitsPerSample == 16)
            {
                pWave->m_dwSampleLength >>= 1;
                pWave->m_bSampleType = SFORMAT_16;
            }
            else
            {
                Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
                delete pWaveArt;
                return DMUS_E_BADWAVE;
            }
#ifdef XBOX
    // We don't add a sample on the end for interpolation on Xbox. The hardware knows what to do.
#else
            pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.

            // Default is to duplicate last sample. This will be overrwritten for
            // streaming waves.
            //
            if (pWave->m_dwSampleLength > 1)
            {
                if (pWave->m_bSampleType == SFORMAT_8)
                {
                    char* pb = (char*)pWave->m_pnWave;
                    pb[pWave->m_dwSampleLength - 1] = pb[pWave->m_dwSampleLength - 2];
                }
                else if (pWave->m_bSampleType == SFORMAT_16)
                {
                    short *pn = pWave->m_pnWave;
                    pn[pWave->m_dwSampleLength - 1] = pn[pWave->m_dwSampleLength - 2];
                }
            }
#endif

            // Create a WaveBuffer listitem and save the wave in and add it to the circular buffer list
            CWaveBuffer* pWavBuf = new CWaveBuffer();
            if ( pWavBuf == NULL )
            {
                delete pWaveArt;
                return E_OUTOFMEMORY;
            }
            pWavBuf->m_pWave = pWave;

            // This Articulation will be handling streaming data 
            if ( pWave->m_bStream )
                pWaveArt->m_bStream = TRUE;

            pWaveArt->m_pWaves.AddTail(pWavBuf);
        }

        EnterCriticalSection(&m_CriticalSection);
        if (pWaveArt)
        {
            CWaveBuffer* pCurrentBuffer = pWaveArt->m_pWaves.GetHead();
            for (; pCurrentBuffer; pCurrentBuffer = pCurrentBuffer->GetNext() )
            {
                if (pCurrentBuffer->m_pWave)
                {
                    pCurrentBuffer->m_pWave->AddRef();
                }
            }
        }
        m_WaveArtList[pWaveArt->m_dwID % WAVEART_HASH_SIZE].AddHead(pWaveArt);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWaveArt;

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWaveRaw(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData)
{
    CWave *pWave = new CWave;
    if (pWave)
    {   
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)pvData;
        Trace(3,"Downloading raw wave data%ld\n",pInfo->dwDLId);

        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_dwSampleDataSize = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];

        if ( pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE )
        {
            pWave->m_bStream = TRUE;
            pWave->m_bValid = TRUE;
        }

        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        m_dwSynthMemUse += pWave->m_dwSampleDataSize; 

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\idmsynth.h ===
// Copyright (c) 1998 Microsoft Corporation
// IDMSynth.h : Declaration of the CDMSynth

#ifndef __DMSYNTH_H_
#define __DMSYNTH_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDMSynth
class ATL_NO_VTABLE CDMSynth : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDMSynth, &CLSID_DMSynth>,
	public IDirectMusicSynth
{
public:
	CDMSynth()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DMSYNTH)

BEGIN_COM_MAP(CDMSynth)
	COM_INTERFACE_ENTRY(IDirectMusicSynth)
END_COM_MAP()

// IDirectMusicSynth
public:
	STDMETHOD(UnloadInstrument)(DWORD dwInstrumentID);
	STDMETHOD(QueryCompactTime)(DWORD* pdwTime);
	STDMETHOD(Compact)();
	STDMETHOD(DownloadInstrument)(DWORD dwInstrumentID, DWORD * pDMInstrument);
	STDMETHOD(UnloadWave)(DWORD dmWaveID);
	STDMETHOD(DownloadWave)(DWORD dmwaveid, DWORD * pdmwave);
};

#endif //__DMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\kernhelp.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
//
#ifndef _KernHelp_
#define _KernHelp_

// Use kernel mutex to implement critical section
//
typedef KMUTEX CRITICAL_SECTION;
typedef CRITICAL_SECTION *LPCRITICAL_SECTION;

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION);

VOID EnterCriticalSection(
    LPCRITICAL_SECTION);

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION);

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION);

// We have very little registry work to do, so just encapsulate the
// entire process
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value);

ULONG GetTheCurrentTime();


#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline void* __cdecl operator new
(
    unsigned int    iSize
)
{
    PVOID result = ExAllocatePoolWithTag(NonPagedPool, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Debug trace facility
//
#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
#define Trace DebugTrace
#else
#define Trace
#endif

// Paramter validation unused
//
#define V_INAME(x)
#define V_BUFPTR_READ(p,cb)


#endif // _KernHelp_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\kernhelp.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// KernHelp.cpp
//
// Wrappers for kernel functions to make synth core cross compilable
//

extern "C" {
#include <ntddk.h>
};

#include "KernHelp.h"

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeInitializeMutex((PKMUTEX)CritSect, 1);
}

VOID EnterCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeWaitForSingleObject((PKMUTEX)CritSect,
                          Executive,
                          KernelMode,
                          FALSE,
                          0);

}

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeReleaseMutex((PKMUTEX)CritSect, FALSE);
}

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    // NOP in kernel
    //
}

// GetRegValueDword
//
// Must be called at passive level
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value)
{
    int                             ReturnValue = 0;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    KEY_VALUE_PARTIAL_INFORMATION   *Information;
    ULONG                           InformationSize;
    UNICODE_STRING                  UnicodeRegPath;
    UNICODE_STRING                  UnicodeValueName;

    RtlInitUnicodeString(&UnicodeRegPath, RegPath);
    RtlInitUnicodeString(&UnicodeValueName, ValueName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRegPath,
                               0,           // Flags
                               NULL,        // Root directory
                               NULL);       // Security descriptor

    Status = ZwOpenKey(&KeyHandle,
                       KEY_QUERY_VALUE,
                       &ObjectAttributes);
    if (Status != STATUS_SUCCESS)
    {
        return 0;
    }

    InformationSize = sizeof(Information) + sizeof(ULONG);
    Information = (KEY_VALUE_PARTIAL_INFORMATION*)ExAllocatePool(PagedPool, InformationSize);
    if (Information == NULL)
    {
        return 0;
    }

    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeValueName,
                             KeyValuePartialInformation,
                             Information,
                             sizeof(Information),
                             &InformationSize);
    if (Status == STATUS_SUCCESS)
    {
        if (Information->Type == REG_DWORD && Information->DataLength == sizeof(ULONG))
        {
            RtlCopyMemory(Value, Information->Data, sizeof(ULONG));
            ReturnValue = 1;
        }
    }                                
                                    
    ExFreePool(Information);
    ZwClose(KeyHandle);

    return ReturnValue;                                
}

ULONG GetTheCurrentTime()
{
    LARGE_INTEGER Time;

    KeQuerySystemTime(&Time);

    return (ULONG)(Time.QuadPart / (10 * 1000));
}

void DebugInit(void)
{
}

void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\midi.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      MIDI.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#endif
 
CMIDIDataList    CMIDIRecorder::m_sFreeList; 
DWORD            CMIDIRecorder::m_sUsageCount = 0;

CMIDIData::CMIDIData() 
{
    m_stTime = 0;
    m_lData = 0;            
}


CMIDIRecorder::CMIDIRecorder()
{
    m_sUsageCount++;
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
}

CMIDIRecorder::~CMIDIRecorder()

{
    ClearMIDI(0x7FFFFFFF);
    m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CMIDIData *pMD;
        while (pMD = m_sFreeList.RemoveHead())
        {
            delete pMD;
        }
    }
}

VREL CMIDIRecorder::m_vrMIDIToVREL[128] = 
{
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};

VREL CMIDIRecorder::m_vrMIDIPercentToVREL[128] = 
{
    -9600, -4207, -3605, -3253, -3003, -2809, -2651, -2517, 
    -2401, -2299, -2207, -2124, -2049, -1979, -1915, -1855, 
    -1799, -1746, -1697, -1650, -1605, -1563, -1522, -1484, 
    -1447, -1411, -1377, -1344, -1313, -1282, -1253, -1224, 
    -1197, -1170, -1144, -1119, -1095, -1071, -1048, -1025, 
    -1003, -982, -961, -940, -920, -901, -882, -863, 
    -845, -827, -809, -792, -775, -759, -742, -726, 
    -711, -695, -680, -665, -651, -636, -622, -608, 
    -595, -581, -568, -555, -542, -529, -517, -505, 
    -492, -480, -469, -457, -445, -434, -423, -412, 
    -401, -390, -379, -369, -359, -348, -338, -328, 
    -318, -308, -299, -289, -280, -270, -261, -252, 
    -243, -234, -225, -216, -207, -198, -190, -181, 
    -173, -165, -156, -148, -140, -132, -124, -116, 
    -109, -101, -93, -86, -78, -71, -63, -56, 
    -49, -42, -34, -27, -20, -13, -6, 0 
};

/*void CMIDIRecorder::Init()
{
        for (nIndex = 1; nIndex < 128; nIndex++)
        {
            double   flTemp;
            flTemp = nIndex;
            flTemp /= 127.0;
            flTemp = pow(flTemp,4.0);
            flTemp = log10(flTemp);
            flTemp *= 1000.0;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
            m_vrMIDIToVREL[nIndex] = (VREL) flTemp;
        }
        Trace(0,"\n");
        m_vrMIDIToVREL[0] = -9600;
        for (nIndex = 1; nIndex < 128; nIndex++)
        {
            double flTemp;
            flTemp = nIndex;
            flTemp /= 127;
            flTemp *= flTemp;
            flTemp = log10(flTemp);
            flTemp *= 1000.0;
            m_vrMIDIPercentToVREL[nIndex] = (VREL) flTemp;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
        }
        m_vrMIDIPercentToVREL[0] = -9600;
}*/

BOOL CMIDIRecorder::FlushMIDI(STIME stTime)
{
    CMIDIData *pMD;
    CMIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            m_sFreeList.Cat(pMD);
            break;
        }
        pLast = pMD;
    }
    return m_EventList.IsEmpty();
}

BOOL CMIDIRecorder::ClearMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            m_sFreeList.AddHead(pMD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}

VREL CMIDIRecorder::VelocityToVolume(WORD nVelocity)

{
    return (m_vrMIDIToVREL[nVelocity]);
}

BOOL CMIDIRecorder::RecordMIDINote(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }
    CMIDIData *pScan = m_EventList.GetHead();
    CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pMD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pMD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pMD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pMD->SetNext(pNext);
                            pScan->SetNext(pMD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
    return (FALSE);
}

BOOL CMIDIRecorder::RecordMIDI(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }
    CMIDIData *pScan = m_EventList.GetHead();
    CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pMD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pMD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    if ((pScan->m_stTime == stTime) && 
                        (pScan->m_lData == lData))
                    {
                        m_sFreeList.AddHead(pMD);
                        break;
                    }
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pMD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pMD->SetNext(pNext);
                            pScan->SetNext(pMD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
/*#ifdef DBG
    static gWarnCount = 0;
    if (!gWarnCount)
    {
        Trace(1,"Warning: MIDI Free event pool empty. This can be caused by time stamping problems, too much MIDI data, or too many PChannels.\n");
        gWarnCount = 100;
    }
    gWarnCount--;
#endif*/
    return (FALSE);
}

long CMIDIRecorder::GetData(STIME stTime)

{
    CMIDIData *pMD = m_EventList.GetHead();
    long lData = m_lCurrentData;
    for (;pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }
    return (lData);
}

BOOL CNoteIn::RecordNote(STIME stTime, CNote * pNote)

{
    long lData = pNote->m_bPart << 16;
    lData |= pNote->m_bKey << 8;
    lData |= pNote->m_bVelocity;
    return (RecordMIDINote(stTime,lData));
}

BOOL CNoteIn::RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData)

{
    long lData = dwPart;
    lData <<= 8;
    lData |= dwCommand;
    lData <<= 8;
    lData |= bData;
    return (RecordMIDINote(stTime,lData));  
}

BOOL CNoteIn::GetNote(STIME stTime, CNote * pNote)

{
    CMIDIData *pMD = m_EventList.GetHead();
    if (pMD != NULL)
    {
        if (pMD->m_stTime <= stTime)
        {
            pNote->m_stTime = pMD->m_stTime;
            pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
            pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
            pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pMD);
            return (TRUE);
        }
    }
    return (FALSE);
}

void CNoteIn::FlushMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.
            pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
        }
    }
}


void CNoteIn::FlushPart(STIME stTime, BYTE bChannel)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (bChannel == (BYTE) (pMD->m_lData >> 16))
            {
                pMD->m_stTime = stTime;     // Play now.
                pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
            }
        }
    }
}

DWORD CModWheelIn::GetModulation(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CPitchBendIn::CPitchBendIn()

{
    m_lCurrentData = 0x2000;    // initially at midpoint, no bend
#ifdef DXAPI
    m_prRange = 200;           // whole tone range by default.
#else
    m_prRange = 8192;           // pitch cents range. This is counting on the performance
                                // layer to manage the default ranges.
#endif
}

// note (davidmay 8/14/96): we don't keep a time-stamped range.
// if people are changing the pitch bend range often, this won't work right,
// but that didn't seem likely enough to warrant a new list.
PREL CPitchBendIn::GetPitch(STIME stTime)

{
    PREL prResult = (PREL) CMIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;  // adjust by current range
    prResult >>= 13;
    return (prResult);
}

CVolumeIn::CVolumeIn()

{
    m_lCurrentData = 100;
}

VREL CVolumeIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CExpressionIn::CExpressionIn()

{
    m_lCurrentData = 127;
}

VREL CExpressionIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CPanIn::CPanIn()

{
    m_lCurrentData = 64;
}

long CPanIn::GetPan(STIME stTime)

{
    long lResult = (long) CMIDIRecorder::GetData(stTime);
    return (lResult);
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

DWORD CPressureIn::GetPressure(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CReverbIn::CReverbIn()

{
    m_lCurrentData = 40;
}

DWORD CReverbIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

DWORD CChorusIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

CCutOffFreqIn::CCutOffFreqIn()
{
    m_lCurrentData = 64;
}

DWORD CCutOffFreqIn::GetFrequency(STIME stTime)
{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\miniport.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// DirectMusic Software Synthesizer
//
#include "common.h"
#include "private.h"
#include "dmusicks.h"


#define STR_MODULENAME "DmSynth: "

#pragma code_seg("PAGE")


// Property handlers
//
NTSTATUS PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthPortParameters(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthMasterClock(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthPortChannelGroups(IN PPCPROPERTY_REQUEST);

NTSTATUS PropertyHandler_DlsDownload(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsUnload(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsCompact(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsAppend(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsVolume(IN PPCPROPERTY_REQUEST);


NTSTATUS PropertyHandler_GetLatency(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_GetLatencyClock(IN PPCPROPERTY_REQUEST);

// CreateMiniportDirectMusic
//
//
NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
)
{
    PAGED_CODE();
    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_TERSE, ("Creating DirectMusic synth miniport"));
    STD_CREATE_BODY(CMiniportDmSynth, Unknown, UnknownOuter, PoolType);
}

STDMETHODIMP CMiniportDmSynth::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportSynthesizer))
    {
        *Object = PVOID(PMINIPORTSYNTHESIZER(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

CMiniportDmSynth::~CMiniportDmSynth()
{
}

STDMETHODIMP CMiniportDmSynth::Init
(
    IN  PUNKNOWN            Unknown OPTIONAL,
    IN  PRESOURCELIST       ResourceList,
    IN  PPORTSYNTHESIZER    Port_,
    OUT PSERVICEGROUP*      ServiceGroup
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CMiniportDmSynth::Init]"));
    ASSERT(ResourceList);
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    
    Port = Port_;
    Port->AddRef();   

    Stream = NULL;
    
    *ServiceGroup = NULL;
    
    return STATUS_SUCCESS; 
}

STDMETHODIMP CMiniportDmSynth::NewStream
(
    OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream_,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   Pin,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CMiniportDmSynth::NewStream]"));
    NTSTATUS nt = STATUS_SUCCESS;

    if (Stream)
    {
        // XXX Multiinstance!!!
        //
        nt = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        CDmSynthStream *Stream = new(PoolType) CDmSynthStream(OuterUnknown);

        if (Stream)
        {
            nt = Stream->Init(this);
            if (NT_SUCCESS(nt))
            {
                Stream->AddRef();
                *Stream_ = PMINIPORTSYNTHESIZERSTREAM(Stream);
            }
            else
            {
                Stream->Release();
                Stream = NULL;
            }
        }
        else
        {
            nt = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    return nt;
}

STDMETHODIMP_(void) CMiniportDmSynth::Service()
{
}

// ==============================================================================
// PinDataRangesStream
// Structures indicating range of valid format values for streaming pins.
// ==============================================================================
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_WAVETABLE),
        0,                                      // Channels
        0,                                      // Notes
        0x0000ffff                              // ChannelMask
    }
};

// ==============================================================================
// PinDataRangePointersStream
// List of pointers to structures indicating range of valid format values
// for streaming pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

#if 0
// ==============================================================================
// PinDataRangesBridge
// Structures indicating range of valid format values for bridge pins.
// ==============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

// ==============================================================================
// PinDataRangePointersBridge
// List of pointers to structures indicating range of valid format values
// for bridge pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};
#endif

// ==============================================================================
// PinDataRangesAudio
// Structures indicating range of valid format values for audio pins.
// ==============================================================================
static
KSDATARANGE_AUDIO PinDataRangesAudio[] =
{
    {
        { sizeof(KSDATARANGE_AUDIO),
          0,
          0,
          0,
          STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
          STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
          STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        2,
        16,
        16,
        22050,
        22050
    }
};

// ==============================================================================
// PinDataRangePointersAudio
// List of pointers to structures indicating range of valid format values
// for audio pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersAudio[] =
{
    (PKSDATARANGE)&PinDataRangesAudio
};

static
PCPROPERTY_ITEM
SynthProperties[] =
{
    ///////////////////////////////////////////////////////////////////
    //
    // Configuration items
    //

    // Global: Synth caps
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_SynthCaps
    },
    
    // Per Stream: Synth port parameters
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_SynthPortParameters
    },

    // Global: Master clock
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_MASTERCLOCK,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_SynthMasterClock
    },

    // Per Stream: Channel groups
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        PropertyHandler_SynthPortChannelGroups
    },

    ///////////////////////////////////////////////////////////////////
    //
    // DLS items
    //

    // Per stream: Download DLS sample
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DOWNLOAD,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_DlsDownload
    },

    // Per stream: Unload DLS sample
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_UNLOAD,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsUnload
    },

    // Global: Compact DLS memory
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_COMPACT,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsCompact
    },

    // Per stream: append
    //                
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_APPEND,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsAppend
    },

    // Per stream: volume
    //                
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsVolume
    },

    ///////////////////////////////////////////////////////////////////
    //
    // Clock items
    //

    // Per stream: Get desired latency
    //
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCY,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_GetLatency
    },

    // Per stream: Get current latency time
    //
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LatencyClock,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_GetLatencyClock
    }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth, SynthProperties);

// ==============================================================================
// MiniportPins
// List of pins.
// ==============================================================================
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL, 
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
#if 0 
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
#else
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAudio),    // DataRangesCount
            PinDataRangePointersAudio,                  // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SOURCE,                 // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
#endif
};

// ==============================================================================
// MiniportNodes
// List of nodes.
// ==============================================================================
#define CONST_PCNODE_DESCRIPTOR(n)			{ 0, NULL, &n, NULL }
#define CONST_PCNODE_DESCRIPTOR_AUTO(n,a)	{ 0, &a, &n, NULL }
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth)
};

// ==============================================================================
// MiniportConnections
// List of connections.
// ==============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    // From node            From pin        To node                 To pin
    //
    { PCFILTER_NODE,        0,              0,                      1 },    // Stream in to synth.
    { 0,                    0,              PCFILTER_NODE,          1 }     // Synth to bridge out.
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR 
MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

STDMETHODIMP CMiniportDmSynth::GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();
    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;
    return STATUS_SUCCESS;
}

STDMETHODIMP CMiniportDmSynth::DataRangeIntersection
(
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat    OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    // XXX ???
    //
    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// CDmSynthStream
//

CDmSynthStream::~CDmSynthStream()
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CDmSynthStream destruct]"));

    if (Miniport)
    {
        Miniport->Stream = NULL;
        Miniport->Release();
    }

    if (Synth)
    {
        delete Synth;
    }

    if (Sink)
    {
        Sink->Release();
    }
}

NTSTATUS CDmSynthStream::Init
(
    CMiniportDmSynth        *Miniport_
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CDmSynthStream::Init]"));
    _DbgPrintF(DEBUGLVL_TERSE, ("Stream IUnkown is %08X", DWORD(PVOID(PUNKNOWN(this)))));

    Miniport = Miniport_;
    Miniport->AddRef();

    Synth = new CSynth;
    if (Synth == NULL)
    {
        Miniport->Release();
        return STATUS_NO_MEMORY;
    }

    Sink = new CSysLink;
    if (Sink == NULL)
    {
        delete Synth;
        Synth = NULL;
        Miniport->Release();
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}

STDMETHODIMP CDmSynthStream::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportSynthesizerStream))
    {
        *Object = PVOID(PMINIPORTSYNTHESIZERSTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

STDMETHODIMP CDmSynthStream::SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[CDmSynthStream::SetState]"));

    NTSTATUS nt = STATUS_SUCCESS;

    // XXX Propogate to activate state
    //
    switch (NewState)
    {
        case KSSTATE_RUN:
            nt = Synth->Activate(PortParams.SampleRate,
                                 PortParams.Stereo ? 2 : 1);
            break;

        case KSSTATE_ACQUIRE:
        case KSSTATE_STOP:
        case KSSTATE_PAUSE:
            nt = Synth->Deactivate();
            break;
    }

    return nt;
}

STDMETHODIMP CDmSynthStream::ConnectOutput
(
    PMXFFILTER ConnectionPoint
)
{
    return STATUS_NOT_IMPLEMENTED;
}

STDMETHODIMP CDmSynthStream::DisconnectOutput
(
    PMXFFILTER ConnectionPoint
)
{
    return STATUS_NOT_IMPLEMENTED;
}

STDMETHODIMP CDmSynthStream::PutMessage
(
    IN  PDMUS_KERNEL_EVENT  Event
)
{
    PBYTE Data = (Event->ByteCount <= sizeof(PBYTE) ? &Event->ActualData.Data[0] : Event->ActualData.DataPtr);

    // This is just MIDI bytes
    //
    return Synth->PlayBuffer(Sink,
                             Event->PresTime100Ns,
                             Data,
                             Event->ByteCount,
                             (ULONG)Event->ChannelGroup);
}

// CDmSynthStream::HandlePortParams
//
// Fix up the port params to include defaults. Cache the params as well
// as passing the updated version back.
//
STDMETHODIMP CDmSynthStream::HandlePortParams
(
    IN      PPCPROPERTY_REQUEST pRequest
)
{
    BOOL ValidParamChanged = FALSE;

    SYNTH_PORTPARAMS *Params = (SYNTH_PORTPARAMS*)pRequest->Value;
    if (pRequest->ValueSize < sizeof(SYNTH_PORTPARAMS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_VOICES))
    {
        Params->Voices = 32;
    }
    else if (Params->Voices > 32)
    {
        Params->Voices = 32;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
    {
        Params->ChannelGroups = 32;
    }
    else if (Params->ChannelGroups > 32)
    {
        Params->ChannelGroups = 32;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_SAMPLERATE))
    {
        Params->SampleRate = 22050;
    }
    else if (Params->SampleRate != 11025 && Params->SampleRate != 22050 && Params->SampleRate != 44100)
    {
        Params->SampleRate = 22050;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_REVERB))
    {
        Params->Reverb = FALSE;
    }
    else if (Params->Reverb)
    {
        Params->Reverb = FALSE;
        ValidParamChanged = TRUE;
    }

    RtlCopyMemory(&PortParams, Params, sizeof(PortParams));    
    
    return ValidParamChanged ? STATUS_NOT_ALL_ASSIGNED : STATUS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
//
// Property dispatchers
//
// XXX All of these need to be connected
//

NTSTATUS PropertyHandler_SynthCaps
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    SYNTHCAPS caps;

    caps.Flags              = SYNTH_PC_DLS | SYNTH_PC_SOFTWARESYNTH;
    caps.MemorySize         = SYNTH_PC_SYSTEMMEMORY;         
    caps.MaxChannelGroups   = 32;
    caps.MaxVoices          = 32;

    pRequest->ValueSize = min(pRequest->ValueSize, sizeof(caps));
    RtlCopyMemory(pRequest->Value, &caps, pRequest->ValueSize);

    return STATUS_SUCCESS;
}

// PropertyHandler_SynthPortParameters
//
NTSTATUS PropertyHandler_SynthPortParameters
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    
    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePortParams(pRequest);
}

// PropertyHandler_SynthMasterClock
//
NTSTATUS PropertyHandler_SynthMasterClock
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    return STATUS_SUCCESS;
}

// PropertyHandler_SynthPortChannelGroups
//
NTSTATUS PropertyHandler_SynthPortChannelGroups
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);

    if (pRequest->ValueSize < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ULONG ChannelGroups = *(PULONG)(pRequest->Value);

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->SetNumChannelGroups(ChannelGroups);
}

// PropertyHandler_DlsDownload
//
NTSTATUS PropertyHandler_DlsDownload
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX Lock down this memory
    //
    // XXX Validate entire buffer size???
    //
    HANDLE DownloadHandle;
    BOOL Free;

    NTSTATUS Status = (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->Download(
        &DownloadHandle,
        pRequest->Value,
        &Free);

    if (SUCCEEDED(Status))
    {
        ASSERT(pRequest->ValueSize >= sizeof(DownloadHandle));
        RtlCopyMemory(pRequest->Value, &DownloadHandle, sizeof(DownloadHandle));
        pRequest->ValueSize = sizeof(DownloadHandle);
    }

    return Status;
}

// PropertyHandler_DlsUnload
//
HRESULT CALLBACK UnloadComplete(HANDLE,HANDLE);

NTSTATUS PropertyHandler_DlsUnload
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);

    if (pRequest->ValueSize < sizeof(HANDLE))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // XXX Need some concurrency control here
    //
    NTSTATUS Status = (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->Unload(
        *(HANDLE*)pRequest->Value,
        UnloadComplete,
        (HANDLE)pRequest);
    
    return STATUS_SUCCESS;
}

HRESULT CALLBACK UnloadComplete(HANDLE WhichDownload, HANDLE CallbackInstance)
{
    PPCPROPERTY_REQUEST pRequest = (PPCPROPERTY_REQUEST)CallbackInstance;
        
    PcCompletePendingPropertyRequest(pRequest, STATUS_SUCCESS);

    return STATUS_SUCCESS;
}

// PropertyHandler_DlsCompact
//
// We don't care
//
NTSTATUS PropertyHandler_DlsCompact
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_DlsAppend
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);

    if (pRequest->ValueSize < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *(PULONG)(pRequest->Value) = 4;
    pRequest->ValueSize = sizeof(ULONG);

    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_DlsVolume
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX *Both* versions of the synth need this
    //
    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_GetLatency
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    if (pRequest->ValueSize < sizeof(ULONGLONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *((PULONGLONG)pRequest->Value) = 0;
    pRequest->ValueSize = sizeof(ULONGLONG);

    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_GetLatencyClock
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX This depends on the synth sink
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\misc.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// Misc.h
//
// functions used in multiple DLL's

#ifndef __MISC_H__
#define __MISC_H__

//LPVOID MemGlobalAllocPtr(UINT uFlags,DWORD dwBytes);
//BOOL MemGlobalFreePtr(LPVOID p);

// memory functions
//HRESULT MemStart();
//void MemEnd();

/*#ifdef _DEBUGMEM
#ifndef new
void* operator new( size_t cb, LPCTSTR pszFileName, WORD wLine );
#define new new( __FILE__, (WORD)__LINE__ )
#endif
#endif*/

#ifdef DBG
#define RELEASE( obj ) ( (obj)->Release(), *((char**)&(obj)) = (char*)0x0bad0bad )
#else
#define RELEASE( obj ) (obj)->Release()
#endif

#ifndef XBOX

BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue);

#endif // ! XBOX

ULONG GetTheCurrentTime();

#endif // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\mixf.cpp ===
//      Mixf.cpp
//      Copyright (c) Microsoft Corporation	1996-1999
//      Filtered Mix Engine

#include "simple.h"
#include <mmsystem.h>
#include "synth.h"

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#pragma message ("Programer note: property hack")
//#define DEBUG_DUMP_FILE

#pragma warning(disable : 4101 4102 4146)  

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#ifdef DEBUG_DUMP_FILE
DWORD dmp_bufsize = 4000000;
DWORD dmp_samplesrecorded;
DWORD dmp_buffercount;
short dmp_soundbuffer[4000000];
#endif
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

DWORD CDigitalAudio::Mix16Filtered(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFFDELTA cfdK,
    COEFFDELTA cfdB1,
    COEFFDELTA cfdB2)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
            cfK       += cfdK;
            cfB1      += cfdB1;
            cfB2      += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		//
        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// >>>> We store the negative of b1 in the table, so we flip the sign again by
		// >>>> adding here
		// >>>> Lookinto simply using a float here, it may just be faster, save a div 
		//
        lM = MulDiv(lM, cfK, (1 << 30))
           + MulDiv(m_lPrevSample, cfB1, (1 << 30))
           - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

		//
		//
		//
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

		//
		//
		//
		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	
			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

#ifdef DEBUG_DUMP_FILE
dmp_soundbuffer[dmp_samplesrecorded] = pBuffer[dwI];
if (dmp_samplesrecorded < dmp_bufsize)
	dmp_samplesrecorded++ ;
#endif

		dwI++;
    }

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;
	m_cfLastK  = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    return (dwI);
}


DWORD CDigitalAudio::Mix16FilteredInterleaved(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFFDELTA cfdK,
    COEFFDELTA cfdB1,
    COEFFDELTA cfdB2)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	dwLength <<= 1;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
            cfK       += cfdK;
            cfB1      += cfdB1;
            cfB2      += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		//
        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// >>>> We store the negative of b1 in the table, so we flip the sign again by
		// >>>> adding here
		// >>>> Lookinto simply using a float here, it may just be faster, save a div 
		//
        lM = MulDiv(lM, cfK, (1 << 30))
           + MulDiv(m_lPrevSample, cfB1, (1 << 30))
           - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

		//
		//
		//
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

		//
		//
		//
		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	
			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				pBuffer++;
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

#ifdef DEBUG_DUMP_FILE
dmp_soundbuffer[dmp_samplesrecorded] = pBuffer[dwI];
if (dmp_samplesrecorded < dmp_bufsize)
	dmp_samplesrecorded++ ;
#endif

		dwI += 2;
    }

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;
	m_cfLastK  = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    return (dwI >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\mixc.cpp ===
//      Mixc.cpp
//      Copyright (c) Microsoft Corporation	1996-1999
//      C version of the Mix Engine

#include "simple.h"
#include <mmsystem.h>
#include "synth.h"

#pragma warning(disable : 4101 4102 4146)  

DWORD CDigitalAudio::Mix16(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		lA = lM;
		lA *= vfLVolume;
		lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

		dwI++;
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::Mix16InterLeaved(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				pBuffer++;
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

		dwI += 2;
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;

    return (dwI >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\mix.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mix.cpp
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

#ifndef XMIX

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

DWORD CDigitalAudio::Mix8(short * pBuffer, 
						  DWORD dwLength, 
						  DWORD dwDeltaPeriod,
						  VFRACT vfDeltaLVolume, 
						  VFRACT vfDeltaRVolume,
					      VFRACT vfLastVolume[],
						  PFRACT pfDeltaPitch, 
						  PFRACT pfSampleLength, 
						  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_  (dead code)

		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;

// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543	

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 5;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1036 : 
; 1037 : 				dwI += 2;
	sub	edx, eax

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:

; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.

overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1041 : 		}
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

    sub	edx, eax
	
    imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 5;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1087 : 		dwI += 2;

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r

no_oflowr:
; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	add	edi, 2
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8(short * pBuffer, 
							  DWORD dwLength,
							  DWORD dwDeltaPeriod,
							  VFRACT vfDeltaVolume,
							  VFRACT vfLastVolume[],
							  PFRACT pfDeltaPitch, 
							  PFRACT pfSampleLength, 
							  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lM = pcWave[dwPosition];
	    lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
		lM *= vfVolume;
		lM >>= 5;

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow code on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif  // _X86_  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:

; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;

; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	mov	ecx, DWORD PTR pfPitch
	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x

no_oflowx:

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod


	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.

overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

	static int _a = 0, _b = 0, _c = 0;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;
#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:

#endif // _X86_  (dead code)
		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]
	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowlx:	
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 13;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1035 : no_oflowrx:
; 1037 : 				dwI += 2;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax
	mov	eax, DWORD PTR pBufX

	imul	esi, edx

	sar	esi, 13					; 0000000dH

	add	WORD PTR [eax+edi*2], si

	mov	esi, DWORD PTR vfRVolume
	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.
overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfLVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1077 : no_oflowl:	
; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 13;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1086 : #endif  /* _ALPHA */
; 1087 : 		dwI += 2;

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r
no_oflowr:

	add	edi, 2

; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}


#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

#ifndef _X86_
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
        // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:
	push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax
	mov	ecx, DWORD PTR pfPitch

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x
no_oflowx:

; 1038 : 			} while (--dwIncDelta);

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfVolume = vfVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod

	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.
overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
; 1077 : no_oflowl:	
; 1087 : 		++dwI;

	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}
	dwI += dwLength;

#endif // _X86_
    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\mmx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mmx.cpp
//      MMX Mix engines for Microsoft synth

/*
Variable useage.

		Variable									register 
		pfSamplePos									eax
		pfPitch										ebx
		dwI											ecx
		dwIncDelta									edx (edx is sometimes a temporary register)
		dwPosition1									esi
		dwPostiion2									edi

		vfRvolume and vfLvolume						mm0		
		vfRVolume, vfLVolume						mm2		

		mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

		// Loop is unrolled once.
		// *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
		// This make the packed mulitply work better later since I keep the sound interpolated
		// wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
		// which is the same as the original code.


		// *2 linear interpolation can be done very quickly with MMX by re-arranging the
		// way that the interpolation is done. Here is code in C that shows the difference.
		// Original C code		
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
		//lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
		//lM2 += pcWave[dwPosition2];

		// Equivalent C Code that can be done with a pmadd
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "debug.h"
#endif

#ifdef XMIX

BOOL MultiMediaInstructionsSupported()
{
    return TRUE;
}

#else // rest of file

typedef unsigned __int64 QWORD;

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8X(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];
		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			//do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;
		
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPoisition2];
		movd	mm6, edi

		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit
					
								// low 4 bytes in mm3
		punpcklwd	mm3, mm6	// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]											
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3
		add		eax, ebx		//pfSamplePos += pfPitch;

		packssdw	mm3, mm2		// words in mm7
								// vfVolume, vfVolume, vfVolume, vfVolume
									
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		pxor	mm7, mm7
								// low four bytes
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

								// 8 bytes after unpakc
		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0 
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix8X(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];

		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			// do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		
					
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPosition2];
		movd	mm6, edi
	
		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit

								// low 4 bytes bytes in mm3
	punpcklwd	mm3, mm6		// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// bytes in mm7
								// pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3

		add		eax, ebx		//pfSamplePos += pfPitch;
	packssdw	mm3, mm2		// words in mm3
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

		pxor	mm7, mm7
								// byte in MMX registers
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.m_vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16X(short * pBuffer, 
								DWORD dwLength,
								DWORD dwDeltaPeriod,
								VFRACT vfDeltaVolume,
							    VFRACT vfLastVolume[],
								PFRACT pfDeltaPitch, 
								PFRACT pfSampleLength, 
								PFRACT pfLoopLength)

{
    DWORD dwI;    
    
    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16X(short * pBuffer, 
							DWORD dwLength, 
							DWORD dwDeltaPeriod,
							VFRACT vfDeltaLVolume, 
							VFRACT vfDeltaRVolume,
						    VFRACT vfLastVolume[],
							PFRACT pfDeltaPitch, 
							PFRACT pfSampleLength, 
							PFRACT pfLoopLength)
{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.vfLastVolume[1], mm2
#endif 
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

static BOOL MMXDisabled()
{
#ifdef XBOX
    return FALSE;
#else // XBOX
    ULONG ulValue = FALSE;

    if (!GetRegValueDword(
            TEXT("Software\\Microsoft\\DirectMusic"),
            TEXT("MMXDisabled"),
            &ulValue))
    {
        return FALSE;
    }

    return (BOOL)ulValue;
#endif // XBOX
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

BOOL MultiMediaInstructionsSupported()
{
    static  BOOL bMultiMediaInstructionsSupported = FALSE;
    static  BOOL bFlagNotSetYet = TRUE;
    
    // No need to keep interogating the CPU after it has been checked the first time
    if (bFlagNotSetYet)
    {
        bFlagNotSetYet = FALSE;         // Don't repeat the check for each call
		if (!MMXDisabled())
		{
			_asm 
			{
				pushfd                      // Store original EFLAGS on stack
				pop     eax                 // Get original EFLAGS in EAX
				mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
				xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
				push    eax                 // Save new EFLAGS value on stack
				popfd                       // Replace current EFLAGS value
				pushfd                      // Store new EFLAGS on stack
				pop     eax                 // Get new EFLAGS in EAX
				xor     eax, ecx            // Can we toggle ID bit?
				jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
				mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
				push	ebx
				CPU_ID                      // Get family/model/stepping/features
				pop		ebx
				test    edx, 0x00800000L    // Check if mmx technology available
				jz      Done                // Jump if no
			}
			// Tests have passed, this machine supports the Intel MultiMedia Instruction Set!
			bMultiMediaInstructionsSupported = TRUE;
Done:
			NULL;
		}
    }

#if DBG
	if ( bMultiMediaInstructionsSupported )
	{
		Trace(2,"MMX - Detected, Enabling MMX mixing\n\r");
	}
	else
	{
		Trace(2,"MMX - Not Detected\n\r");
	}
#endif

    return (bMultiMediaInstructionsSupported);
}    

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\mmdebug.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_

#if defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        #define STATICFN

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        void FAR _cdecl AuxRip(LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        LPCTSTR WINAPI AuxMMErrText(DWORD  mmr);
        int  WINAPI DebugSetOutputLevel (int,int);
        UINT WINAPI AuxFault (DWORD dwFaultMask);

       #if defined DEBUG_RETAIL && !defined DEBUG && !defined _DEBUG
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

        #define FAULT_HERE AuxFault

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

    #else // defined(DEBUG) || defined(_DEBUG)
                      
       #define AuxDebugEx  1 ? (void)0 :
       #define AuxDebugDump(a,b,c)
       #define AuxMMErrText(m)     NULL
       #define AuxRip  1 ? (void)0 :

       #define assert(a)          ((void)0)
       #define assert2(a,b)       ((void)0)
       #define assert3(a,b,c)     ((void)0)
       #define assert4(a,b,c,d)   ((void)0)
       #define assert5(a,b,c,d,e) ((void)0)

       #define FAULT_HERE    1 ? (void)0 :
       #define INLINE_BREAK
       #define DebugSetOutputLevel(i,j)
       #define STATICFN static

   #endif // defined(DEBUG) || defined _DEBUG || defined DEBUG_RETAIL

   #ifndef DPF_CATEGORY
    #define DPF_CATEGORY 0x0100
   #endif

   // translate DPF's only in internal debug builds
   //
   #if defined DEBUG || defined _DEBUG
       #define DUMP(n,a,b) AuxDebugDump (DPF_CATEGORY | (n), a, b)
       #define RIP AuxDebugEx (0, DEBUGLINE), AuxRip
       #define AuxMMR(api,mmr) (mmr) ? AuxDebugEx(1, DEBUGLINE #api " error %d '%s'\r\n", mmr, AuxMMErrText(mmr)) : (int)0
       #define DPF(n,sz) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n")
       #define DPF1(n,sz,a) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a))
       #define DPF2(n,sz,a,b) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b))
       #define DPF3(n,sz,a,b,c) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c))
       #define DPF4(n,sz,a,b,c,d) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d))
       #define DPF5(n,sz,a,b,c,d,e) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(e))
       #define DPF6(n,sz,a,b,c,d,e,f) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f))
       #define DPF7(n,sz,a,b,c,d,e,f,g) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f),(g))
   #else
       #define DUMP(n,a,b)
       #define RIP AuxRip
       #define AuxMMR(api,mmr)
       #define DPF(n,sz)
       #define DPF1(n,sz,a)
       #define DPF2(n,sz,a,b)
       #define DPF3(n,sz,a,b,c)
       #define DPF4(n,sz,a,b,c,d)
       #define DPF5(n,sz,a,b,c,d,e)
       #define DPF6(n,sz,a,b,c,d,e,f)
       #define DPF7(n,sz,a,b,c,d,e,f,g)
   #endif
   
#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>   

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

static struct _mmerrors {
   DWORD    mmr;
   LPCTSTR  psz;
   } aMMErr[] = {
      MMSYSERR_NOERROR      ,"Success",
   #ifdef DEBUG
      MMSYSERR_ERROR        ,"unspecified error",
      MMSYSERR_BADDEVICEID  ,"device ID out of range",
      MMSYSERR_NOTENABLED   ,"driver failed enable",
      MMSYSERR_ALLOCATED    ,"device already allocated",
      MMSYSERR_INVALHANDLE  ,"device handle is invalid",
      MMSYSERR_NODRIVER     ,"no device driver present",
      MMSYSERR_NOMEM        ,"memory allocation error",
      MMSYSERR_NOTSUPPORTED ,"function isn't supported",
      MMSYSERR_BADERRNUM    ,"error value out of range",
      MMSYSERR_INVALFLAG    ,"invalid flag passed",
      MMSYSERR_INVALPARAM   ,"invalid parameter passed",
     #if (WINVER >= 0x0400)
      MMSYSERR_HANDLEBUSY   ,"handle in use by another thread",
      MMSYSERR_INVALIDALIAS ,"specified alias not found",
      MMSYSERR_BADDB        ,"bad registry database",
      MMSYSERR_KEYNOTFOUND  ,"registry key not found",
      MMSYSERR_READERROR    ,"registry read error",
      MMSYSERR_WRITEERROR   ,"registry write error",
      MMSYSERR_DELETEERROR  ,"registry delete error",
      MMSYSERR_VALNOTFOUND  ,"registry value not found",
      MMSYSERR_NODRIVERCB   ,"Never got a 32 bit callback from driver",
     #endif // WINVER >= 0x400

      WAVERR_BADFORMAT      ,"wave:unsupported wave format",
      WAVERR_STILLPLAYING   ,"wave:still something playing",
      WAVERR_UNPREPARED     ,"wave:header not prepared",
      WAVERR_SYNC           ,"wave:device is synchronous",

      MIDIERR_UNPREPARED    ,"midi:header not prepared",
      MIDIERR_STILLPLAYING  ,"midi:still something playing",
      //MIDIERR_NOMAP         ,"midi:no configured instruments",
      MIDIERR_NOTREADY      ,"midi:hardware is still busy",
      MIDIERR_NODEVICE      ,"midi:port no longer connected",
      MIDIERR_INVALIDSETUP  ,"midi:invalid MIF",
      #ifdef CHICAGO
      MIDIERR_BADOPENMODE   ,"midi:operation unsupported w/ open mode",
      #endif

      TIMERR_NOCANDO        ,"timer: request not completed",
      JOYERR_PARMS          ,"joy:bad parameters",
      JOYERR_NOCANDO        ,"joy:request not completed",
      JOYERR_UNPLUGGED      ,"joystick is unplugged",

      MCIERR_INVALID_DEVICE_ID        ,"MCIERR_INVALID_DEVICE_ID",
      MCIERR_UNRECOGNIZED_KEYWORD     ,"MCIERR_UNRECOGNIZED_KEYWORD",
      MCIERR_UNRECOGNIZED_COMMAND     ,"MCIERR_UNRECOGNIZED_COMMAND",
      MCIERR_HARDWARE                 ,"MCIERR_HARDWARE",
      MCIERR_INVALID_DEVICE_NAME      ,"MCIERR_INVALID_DEVICE_NAME",
      MCIERR_OUT_OF_MEMORY            ,"MCIERR_OUT_OF_MEMORY",
      MCIERR_DEVICE_OPEN              ,"MCIERR_DEVICE_OPEN",
      MCIERR_CANNOT_LOAD_DRIVER       ,"MCIERR_CANNOT_LOAD_DRIVER",
      MCIERR_MISSING_COMMAND_STRING   ,"MCIERR_MISSING_COMMAND_STRING",
      MCIERR_PARAM_OVERFLOW           ,"MCIERR_PARAM_OVERFLOW",
      MCIERR_MISSING_STRING_ARGUMENT  ,"MCIERR_MISSING_STRING_ARGUMENT",
      MCIERR_BAD_INTEGER              ,"MCIERR_BAD_INTEGER",
      MCIERR_PARSER_INTERNAL          ,"MCIERR_PARSER_INTERNAL",
      MCIERR_DRIVER_INTERNAL          ,"MCIERR_DRIVER_INTERNAL",
      MCIERR_MISSING_PARAMETER        ,"MCIERR_MISSING_PARAMETER",
      MCIERR_UNSUPPORTED_FUNCTION     ,"MCIERR_UNSUPPORTED_FUNCTION",
      MCIERR_FILE_NOT_FOUND           ,"MCIERR_FILE_NOT_FOUND",
      MCIERR_DEVICE_NOT_READY         ,"MCIERR_DEVICE_NOT_READY",
      MCIERR_INTERNAL                 ,"MCIERR_INTERNAL",
      MCIERR_DRIVER                   ,"MCIERR_DRIVER",
      MCIERR_CANNOT_USE_ALL           ,"MCIERR_CANNOT_USE_ALL",
      MCIERR_MULTIPLE                 ,"MCIERR_MULTIPLE",
      MCIERR_EXTENSION_NOT_FOUND      ,"MCIERR_EXTENSION_NOT_FOUND",
      MCIERR_OUTOFRANGE               ,"MCIERR_OUTOFRANGE",
      MCIERR_FLAGS_NOT_COMPATIBLE     ,"MCIERR_FLAGS_NOT_COMPATIBLE",
      MCIERR_FILE_NOT_SAVED           ,"MCIERR_FILE_NOT_SAVED",
      MCIERR_DEVICE_TYPE_REQUIRED     ,"MCIERR_DEVICE_TYPE_REQUIRED",
      MCIERR_DEVICE_LOCKED            ,"MCIERR_DEVICE_LOCKED",
      MCIERR_DUPLICATE_ALIAS          ,"MCIERR_DUPLICATE_ALIAS",
      MCIERR_BAD_CONSTANT             ,"MCIERR_BAD_CONSTANT",
      MCIERR_MUST_USE_SHAREABLE       ,"MCIERR_MUST_USE_SHAREABLE",
      MCIERR_MISSING_DEVICE_NAME      ,"MCIERR_MISSING_DEVICE_NAME",
      MCIERR_BAD_TIME_FORMAT          ,"MCIERR_BAD_TIME_FORMAT",
      MCIERR_NO_CLOSING_QUOTE         ,"MCIERR_NO_CLOSING_QUOTE",
      MCIERR_DUPLICATE_FLAGS          ,"MCIERR_DUPLICATE_FLAGS",
      MCIERR_INVALID_FILE             ,"MCIERR_INVALID_FILE",
      MCIERR_NULL_PARAMETER_BLOCK     ,"MCIERR_NULL_PARAMETER_BLOCK",
      MCIERR_UNNAMED_RESOURCE         ,"MCIERR_UNNAMED_RESOURCE",
      MCIERR_NEW_REQUIRES_ALIAS       ,"MCIERR_NEW_REQUIRES_ALIAS",
      MCIERR_NOTIFY_ON_AUTO_OPEN      ,"MCIERR_NOTIFY_ON_AUTO_OPEN",
      MCIERR_NO_ELEMENT_ALLOWED       ,"MCIERR_NO_ELEMENT_ALLOWED",
      MCIERR_NONAPPLICABLE_FUNCTION   ,"MCIERR_NONAPPLICABLE_FUNCTION",
      MCIERR_ILLEGAL_FOR_AUTO_OPEN    ,"MCIERR_ILLEGAL_FOR_AUTO_OPEN",
      MCIERR_FILENAME_REQUIRED        ,"MCIERR_FILENAME_REQUIRED",
      MCIERR_EXTRA_CHARACTERS         ,"MCIERR_EXTRA_CHARACTERS",
      MCIERR_DEVICE_NOT_INSTALLED     ,"MCIERR_DEVICE_NOT_INSTALLED",
      MCIERR_GET_CD                   ,"MCIERR_GET_CD",
      MCIERR_SET_CD                   ,"MCIERR_SET_CD",
      MCIERR_SET_DRIVE                ,"MCIERR_SET_DRIVE",
      MCIERR_DEVICE_LENGTH            ,"MCIERR_DEVICE_LENGTH",
      MCIERR_DEVICE_ORD_LENGTH        ,"MCIERR_DEVICE_ORD_LENGTH",
      MCIERR_NO_INTEGER               ,"MCIERR_NO_INTEGER",
      MCIERR_WAVE_OUTPUTSINUSE        ,"MCIERR_WAVE_OUTPUTSINUSE",
      MCIERR_WAVE_SETOUTPUTINUSE      ,"MCIERR_WAVE_SETOUTPUTINUSE",
      MCIERR_WAVE_INPUTSINUSE         ,"MCIERR_WAVE_INPUTSINUSE",
      MCIERR_WAVE_SETINPUTINUSE       ,"MCIERR_WAVE_SETINPUTINUSE",
      MCIERR_WAVE_OUTPUTUNSPECIFIED   ,"MCIERR_WAVE_OUTPUTUNSPECIFIED",
      MCIERR_WAVE_INPUTUNSPECIFIED    ,"MCIERR_WAVE_INPUTUNSPECIFIED",
      MCIERR_WAVE_OUTPUTSUNSUITABLE   ,"MCIERR_WAVE_OUTPUTSUNSUITABLE",
      MCIERR_WAVE_SETOUTPUTUNSUITABLE ,"MCIERR_WAVE_SETOUTPUTUNSUITABLE",
      MCIERR_WAVE_INPUTSUNSUITABLE    ,"MCIERR_WAVE_INPUTSUNSUITABLE",
      MCIERR_WAVE_SETINPUTUNSUITABLE  ,"MCIERR_WAVE_SETINPUTUNSUITABLE",
      MCIERR_SEQ_DIV_INCOMPATIBLE     ,"MCIERR_SEQ_DIV_INCOMPATIBLE",
      MCIERR_SEQ_PORT_INUSE           ,"MCIERR_SEQ_PORT_INUSE",
      MCIERR_SEQ_PORT_NONEXISTENT     ,"MCIERR_SEQ_PORT_NONEXISTENT",
      MCIERR_SEQ_PORT_MAPNODEVICE     ,"MCIERR_SEQ_PORT_MAPNODEVICE",
      MCIERR_SEQ_PORT_MISCERROR       ,"MCIERR_SEQ_PORT_MISCERROR",
      MCIERR_SEQ_TIMER                ,"MCIERR_SEQ_TIMER",
      MCIERR_SEQ_PORTUNSPECIFIED      ,"MCIERR_SEQ_PORTUNSPECIFIED",
      MCIERR_SEQ_NOMIDIPRESENT        ,"MCIERR_SEQ_NOMIDIPRESENT",
      MCIERR_NO_WINDOW                ,"MCIERR_NO_WINDOW",
      MCIERR_CREATEWINDOW             ,"MCIERR_CREATEWINDOW",
      MCIERR_FILE_READ                ,"MCIERR_FILE_READ",
      MCIERR_FILE_WRITE               ,"MCIERR_FILE_WRITE",
     #ifdef CHICAGO
      MCIERR_NO_IDENTITY              ,"MCIERR_NO_IDENTITY",

      MIXERR_INVALLINE            ,"Invalid Mixer Line",
      MIXERR_INVALCONTROL         ,"Invalid Mixer Control",
      MIXERR_INVALVALUE           ,"Invalid Mixer Value",
     #endif // CHICAGO
   #endif // DEBUG
      0xFFFFFFFE                  , "unknown error %d"
      };

    struct _mmdebug {
        int    Level;
        int    Mask;
        int    StopOnRip;
        DWORD  TakeFault;
        struct _mmerrors *paErrs;
        BOOL   Initialized;
        HANDLE hOut;
        } mmdebug = {0, 0xFF, 0, 0xFF, aMMErr};

    /*+ AuxFault
     *
     *-=================================================================*/

     UINT WINAPI AuxFault (
         DWORD dwFaultMask)
     {
         LPUINT pData = NULL;

         if (dwFaultMask & mmdebug.TakeFault)
            return *pData;
         return 0;
     }


    /*+ AuxOut - write a string to designated debug out
     *
     *-=================================================================*/

   void WINAPI AuxOut (
      LPTSTR psz)
      {
     #ifdef WIN32
      if (mmdebug.hOut)
         {
         UINT  cb = lstrlen(psz);
         DWORD dw;
         if (INVALID_HANDLE_VALUE != mmdebug.hOut)
            WriteFile (mmdebug.hOut, psz, cb, &dw, NULL);
         }
      else
     #endif
         {
        #ifdef DbgLog
         DbgOutString (psz); // from \quartz\sdk\classes\base\debug.cpp
        #else
         OutputDebugString (psz);
        #endif
         }
      }

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       int      cb;
       va_list  va;
       LPSTR    psz;

       // mask the iLevel passed with mmdebug.Mask. if this ends up
       // clearing the high bits then iLevel has a shot being smaller
       // than mmdebug.Level.  if not, then the second test will always
       // fail.  Thus mmdebug.Mask has bits set to DISABLE that category.
       // 
       // note that we always pass messages that have an iLevel < 0.
       // this level corresponds to Asserts & Rips so we always want to see them.
       //
       if (iLevel < 0 || mmdebug.Level >= (iLevel & mmdebug.Mask))
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          // if we begin with a drive letter, strip off all but filename
          //  
          if (psz[0] && psz[1] == ':')
             {
             UINT ii = 2;
             for (ii = 2; psz[ii] != 0; ++ii)
                 if (psz[ii] == '\\')
                    psz += ii+1, ii = 0;
             }

          // write to standard out if we have a handle. otherwise write to 
          // the debugger
          //
         #ifdef MODULE_DEBUG_PREFIX
          if (psz != szBuf)
             AuxOut (MODULE_DEBUG_PREFIX);
         #endif
          AuxOut (psz);
          }

       return cb;
       }

    /*+ AuxRip
     *
     *-=================================================================*/

    void FAR _cdecl AuxRip (
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       va_list  va;
       LPSTR    psz;
                
       va_start (va, lpFormat);
       wvsprintfA (szBuf, lpFormat, va);
       va_end (va);

       // eat leading ..\..\ which we get from __FILE__ since
       // george's wierd generic makefile stuff.
       //
       psz = szBuf;
       while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
          psz += 3;

       AuxOut ("RIP: ");
       AuxOut (psz);
       AuxOut ("\r\n");

       if (mmdebug.StopOnRip)
          {
         #if !defined _WIN32 || defined _X86_
          _asm {int 3};
         #else
          DebugBreak();
         #endif
          }
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = (LPBYTE)lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if ((mmdebug.Level < (iLevel & mmdebug.Mask)) || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          #ifdef MODULE_DEBUG_PREFIX
           AuxOut (MODULE_DEBUG_PREFIX);
          #endif

          AuxOut (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }
       
    /*+ AuxMMErrText
     *
     *-=================================================================*/
    
   LPCTSTR WINAPI AuxMMErrText (
      DWORD  mmr)
   {
      UINT uRemain = sizeof(aMMErr)/sizeof(aMMErr[0]);
      UINT uUpper  = uRemain-1;
      UINT uLower  = 0;
      static char szTemp[50];

      if (mmr <= aMMErr[uUpper].mmr)
      {
         // binary search for mmr match, if match
         // return string pointer
         //
         while (--uRemain)
         {
            UINT ii = (uLower + uUpper) >> 1;

            if (aMMErr[ii].mmr < mmr)
            {
               if (uLower == ii)
                  break;
               uLower = ii;
            }
            else if (aMMErr[ii].mmr > mmr)
            {
               if (uUpper == ii)
                  break;
               uUpper = ii;
            }
            else
            {
               return aMMErr[ii].psz;
               break;
            }
         }

         // we can only get to here if no match was found for
         // the error id.
         //
         if ( ! uRemain)
         {
            int ix;

            INLINE_BREAK;

            for (ix = 0; ix < sizeof(aMMErr)/sizeof(aMMErr[0])-1; ++ix)
            {
                assert (aMMErr[ix].mmr < aMMErr[ix+1].mmr);
            }
            wsprintf (szTemp, "error %d 0x%X", mmr, mmr);
            return szTemp;
         }
      }

      wsprintf (szTemp, aMMErr[uUpper].psz, mmr);
      return szTemp;
   }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel,
        int nMask)
        {
        int nOldLevel = mmdebug.Level;

        if (!mmdebug.Initialized)
           {
          #ifdef WIN32
           TCHAR szFile[MAX_PATH];
           mmdebug.TakeFault = GetProfileInt("Debug", "FaultMask", 1);

           GetProfileString("Debug", "MMDebugTo", "", szFile, sizeof(szFile));
#if 0
           if (!lstrcmpi(szFile, "Console"))
              {
              mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
              if (!mmdebug.hOut || mmdebug.hOut == INVALID_HANDLE_VALUE)
                 {
                 AllocConsole ();
                 mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
                 if (mmdebug.hOut == INVALID_HANDLE_VALUE)
                    mmdebug.hOut = NULL;
                 }
              SetConsoleTitle (MODULE_DEBUG_PREFIX " Debug Output");
              }
           else
#endif
           if (szFile[0] &&
                    lstrcmpi(szFile, "Debug") &&
                    lstrcmpi(szFile, "Debugger") &&
                    lstrcmpi(szFile, "Deb"))
              {
              mmdebug.hOut = CreateFile(szFile, GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL, OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
              if (INVALID_HANDLE_VALUE != mmdebug.hOut)
                 SetFilePointer (mmdebug.hOut, 0, NULL, FILE_END);
              }
          #endif
           mmdebug.Initialized = TRUE;
           }

        mmdebug.Level = (nLevel & 0xFF);
        mmdebug.Mask  = (nMask | 0xFF);
        return nOldLevel;
        }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG    

#ifdef __cplusplus
}
#endif // _cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\mixmulti.cpp ===
//      Mix.cpp
//      Copyright (c) Microsoft Corporation	1996, 1998
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

#ifndef XMIX


///////////////////////////////////////////////////////
// Modifications 
// member m_nChannels => parameter dwBufferCount
//
// Changed number of arguments into Filtered mixers
//
// Remove range checking after filter 

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

#define USE_MMX
#define USE_MMX_FILTERED

#ifdef i386 // {
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
#if 1 // {
	DWORD l_nChannels = dwBufferCount;
#if 1 // {
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 5;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 5;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00  \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx


	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1

//	pand		mm6, QWORD PTR ffffMask
	
//	packssdw	mm6, mm0				// 		Saturate to 16 bits, instead.
//	punpcklwd	mm6, mm0

//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp

//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx			// esi:eax
	adc		esi, edx

	pop		ecx
//	shrd	eax, esi, 30
		
//>>>>> MOD:PETCHEY 
//	shld	eax, esi, 2
//>>>>> should be 
	shld	esi, eax, 2
	mov		eax, esi

//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

#if 0
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;


        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
#endif
no_oflow:	;
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}
#else
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 


    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx], eax };

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 13
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 13
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }


$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 13;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}
#endif

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
	DWORD dMM4[2];					// Handle filter...
	DWORD dMM5[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi
}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer - 4
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1 // {
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1 // {
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif // }

#define DO_32BIT_MULTIPLY
#ifndef DO_32BIT_MULTIPLY
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.
#endif

//	pand		mm6, QWORD PTR ffffMask

#ifndef DO_32BIT_MULTIPLY
	movq		mm4, mm5
#endif
	mov	esi, DWORD PTR [ecx+4]

#ifndef DO_32BIT_MULTIPLY
	punpckldq	mm4, mm4
#endif

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM4, edi

	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM4+4, edi

	movq		mm4, QWORD PTR dMM4
#else
	pmaddwd		mm4, mm6
	psrad		mm4, 13
#endif

	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2


#ifndef DO_32BIT_MULTIPLY
	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
#endif
	mov	esi, DWORD PTR [ecx+8]

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM5, edi

	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM5+4, edi

	movq		mm5, QWORD PTR dMM5
#else
	pmaddwd		mm5, mm6
	psrad		mm5, 13
#endif
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // }{ There is noise here, probably due to the signed nature of the multiply.

	// NOTE the filter is NOT implemented here....

	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif // }

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches
	add	eax, esi		// lMInterp

#if 1 
//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
//	adc		esi, edx
	adc		edx, esi

	pop		ecx
//	shrd	eax, edx, 30
//	mov		esi,0x40000000
//	idiv	esi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx
#endif
	
//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

//>>>>>>>>>>>> removed dp
#if 0 
Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi
#endif

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 


    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms

NoMmxCleanupLabel:
#endif
}

	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
		dwI++;
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#else // }{     all assembly code
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;
	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI = 0;
    DWORD dwJ = 0;
    DWORD dwPosition = 0;
    long lA = 0;//, lB;
    long lM = 0;
    long lMInterp = 0;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#endif // }

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define MulDiv      MulDiv32
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\plclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	PLClock.h

  */

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);
private:
	REFERENCE_TIME		m_rfOffset;
};

class CSampleClock
{
public:
						CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock);
	LONGLONG			RefTimeToSample(REFERENCE_TIME rfTime);

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;		// Initial sample offset.
	DWORD				m_dwSampleRate;
};



#endif	// __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\simple.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <windowsx.h>
#include <stdio.h>
#include "misc.h"

#ifdef XBOX
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct  _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;
#endif // !_SECURITY_ATTRIBUTES_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\plclock.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	CPhaseLockClock

  */


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <windowsx.h>
#include <stdio.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "plclock.h"
#include "misc.h"
#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()

{
	m_rfOffset = 0;
}

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)

/*	When the clock starts, it needs to mark down the 
	difference between the time it is given and its concept of time. 
*/

{
	m_rfOffset = rfMasterTime - rfSlaveTime;
}	

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

/*	Convert the passed time to use the same base as the master clock.
*/

{
	rfSlaveTime += m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)

/*	SyncToTime provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/

{
	rfSlaveTime += m_rfOffset;
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
	m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
}

CSampleClock::CSampleClock()

{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)

{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefTimeToSample(REFERENCE_TIME rfTime)

{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	return rfTime + m_dwStart;
}


void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\private.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//
//
#ifndef _PRIVATE
#define _PRIVATE_

NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
);


#include <stdunk.h>

class CDmSynthStream;

class CMiniportDmSynth : public IMiniportSynthesizer, public CUnknown
{
friend class CDmSynthStream;

public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDmSynth);

    ~CMiniportDmSynth();

    // IMiniport
    //
    STDMETHOD(GetDescription)
    (   THIS_
        OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );

    STDMETHOD(DataRangeIntersection)
    (   THIS_
        IN      ULONG           PinId,
        IN      PKSDATARANGE    DataRange,
        IN      PKSDATARANGE    MatchingDataRange,
        IN      ULONG           OutputBufferLength,
        OUT     PVOID           ResultantFormat    OPTIONAL,
        OUT     PULONG          ResultantFormatLength
    );

    // IMiniportDmSynth
    //
    STDMETHOD(Init)
    (   THIS_
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTSYNTHESIZER Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );  
      
    STDMETHOD(NewStream)
    (   THIS_
        OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );

    STDMETHOD_(void, Service)
    (   void
    );

private:
    PPORTSYNTHESIZER        Port;
    CDmSynthStream *        Stream;    
};


class CDmSynthStream : public IMiniportSynthesizerStream, public CUnknown
{
public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmSynthStream);
    ~CDmSynthStream();
    NTSTATUS Init(CMiniportDmSynth *Miniport);

    // IMxfFilter
    //
    STDMETHOD(ConnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );
    
    STDMETHOD(DisconnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );

    STDMETHOD(PutMessage)
    (   THIS_
        IN  PDMUS_KERNEL_EVENT  Event
    ); 

    // IMiniportSynthStream
    //
    STDMETHOD(SetState)
    (   THIS_
        IN      KSSTATE     State
    );

    // Class
    //
    STDMETHOD(HandlePortParams)
    (   THIS_
        IN      PPCPROPERTY_REQUEST pRequest
    );

public:
    CSynth *                Synth;

private:
    CMiniportDmSynth *      Miniport;
    CSysLink *              Sink;
    SYNTH_PORTPARAMS        PortParams;
};

typedef CDmSynthStream *PDMSYNTHSTREAM;

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\sintab.h ===
static short sSin16[51] =
{
    0,
    3759,
    7460,
    11043,
    14452,
    17633,
    20536,
    23115,
    25329,
    27144,
    28531,
    29468,
    29940,
    29940,
    29468,
    28531,
    27144,
    25329,
    23115,
    20536,
    17633,
    14452,
    11043,
    7460,
    3759,
    0,
    -3759,
    -7460,
    -11043,
    -14452,
    -17633,
    -20536,
    -23115,
    -25329,
    -27144,
    -28531,
    -29468,
    -29940,
    -29940,
    -29468,
    -28531,
    -27144,
    -25329,
    -23115,
    -20536,
    -17633,
    -14452,
    -11043,
    -7460,
    -3760,
    0,
};
static unsigned char sSin8[51] =
{
    128,
    143,
    159,
    174,
    189,
    202,
    214,
    225,
    235,
    242,
    248,
    252,
    254,
    254,
    252,
    248,
    242,
    235,
    225,
    214,
    202,
    189,
    174,
    159,
    143,
    128,
    113,
    97,
    82,
    67,
    54,
    42,
    31,
    21,
    14,
    8,
    4,
    2,
    2,
    4,
    8,
    14,
    21,
    31,
    42,
    54,
    67,
    82,
    97,
    113,
    128,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\stdafx.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\sverb.h ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/****************************************************************************
Const defines :
*****************************************************************************/
#define FPU_DENORM_OFFS (float)1.0E-30

#define BASE_REV_DELAY  0x4000
#define BASE_DSPS_DELAY 0x800

#define DSPS_MASK   0x7ff
#define REV_MASK    0x3fff

/****************************************************************************
Coefs Struct :
*****************************************************************************/
typedef struct
{

	long mySize;
	long myVersion;
	float SampleRate;

	float directGain; 
	long  l_directGain; 
	float revGain; 
	long l_revGain; 

	long lDelay1;
	long lDelay2;
	long lDelay3;
	long lDelay4;

	long lDDly1; 
	long lDDly2; 

	float dDsps;
	long l_dDsps;

	float dDG1;
	long l_dDG1;

	float dDG2; 
	long l_dDG2; 

	float dFB11;
	long l_dFB11;
	float dFB12;
	long l_dFB12;
	float dFB21;
	long l_dFB21;
	float dFB22;
	long l_dFB22;
	float dFB31;
	long l_dFB31;
	float dFB32;
	long l_dFB32;
	float dFB41;
	long l_dFB41;
	float dFB42;
	long l_dFB42;

	float dDamp;
	long l_dDamp;


} sCoefsStruct;

/****************************************************************************
Initialization and control functions :
*****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_16 (float)((unsigned long)0x00008000)

void InitSVerbStates( long *pStates );
long DToF32( float dbl  );
void ConvertCoefsToFix( void *pC );
void InitSVerb( float SampleRate, void  *pCoefs);
void SetSVerb( float InGain, float dRevMix,  float dRevTime, 
			    float dHighFreqRTRatio, void  *pCoefs );



long GetCoefsSize(void);
long GetStatesSize(void);
long GetSVerbVersion(void);

float VerifySampleRate(void  *pCoefs);
long VerifyVersion(void  *pCoefs);
long VerifySize(void  *pCoefs);


#define CLIP_SHORT_TO_SHORT(x)\
			if (x>32767)\
				x = 32767;\
			else if (x<-32768)\
				x = -32768;

/****************************************************************************
//Process Functions :
*****************************************************************************/

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR );
__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR );

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\stdafx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\sources.inc ===
!IF 0

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

NOTE:	The file ddksources in this directory structure is used to build the
        DDK sythesizer sample.  If you make changes to this file, make sure
        to keep ddksources in sync as well.  See ddkreadme.txt for more info.

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmsynth$(LIBEXT)

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj
USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DREVERB_ENABLED -D_DMUSIC_USER_MODE_ -D_MT -DXBOX -DUNICODE

USE_LIBCMT=1

INCLUDES= $(INCLUDES); \
        ..\..\xprivate;   \
        ..\..\shared; \
        ..

SOURCES=\
clist.cpp           \
control.cpp         \
csynth.cpp          \
instr.cpp           \
voice.cpp           \
guids_dmsynth.cpp   \
wave.cpp            \
dls.cpp             \
dmrand.cpp


# XMIX is (DSound-based) hardware mixing for Xbox
!if !defined(SILVER) && !defined(NOXMIX)

C_DEFINES = $(C_DEFINES) -DXMIX

INCLUDES= $(INCLUDES); \
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\windows\directx\dsound\dsound;\
    $(BASEDIR)\private\windows\directx\dsound\common;\
    $(BASEDIR)\private\windows\directx\dsound\ac97;\
    $(BASEDIR)\private\windows\directx\dsound\tools\inc

SOURCES = $(SOURCES) \
dsoundsequencer.cpp
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\syslink.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// syslink.cpp
//
#include "common.h"
#include <mmsystem.h>


CSysLink::CSysLink()
{
    m_cRef = 1;
}

CSysLink::~CSysLink()
{
}

STDMETHODIMP CSysLink::QueryInterface(const IID &iid, void **ppv)
{
    if (IsEqualGUIDAligned(iid, IID_IUnknown))
    {
        *ppv = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(iid, IID_IDirectMusicSynthSink))
    {
        *ppv = PVOID(PDIRECTMUSICSYNTHSINK(this));
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

STDMETHODIMP_(ULONG) CSysLink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSysLink::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSysLink::Init(CSynth *pSynth) 
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetFormat(LPCWAVEFORMATEX pWaveFormat)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetMasterClock(IReferenceClock *pClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::GetLatencyClock(IReferenceClock **ppClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::Activate(HWND hWnd, BOOL fEnable)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)
{
    return S_OK;
}

STDMETHODIMP CSysLink::RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\ltcg\makefile.inc ===
# obj\$(TARGET_DIRECTORY)\xapi.def: xapi.src
#     $(TARGET_CPP) /EP $(CDEFINES) xapi.src > obj\$(TARGET_DIRECTORY)\xapi.def

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

# $(XDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib: $(SDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib
#     copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\synth.h ===
//      Synth.h
//      Copyright (c) 1996-1999 Microsoft Corporation
//

/*  For internal representation, volume is stored in Volume Cents, 
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/ 

#ifndef __SYNTH_H__
#define __SYNTH_H__

#pragma warning(disable:4296)

#include "clist.h"
#include "dmdls.h"
#include "dls2.h"
//#include "dsound.h"   
#include "dmusicc.h"
#include "dsoundsequencer.h"
#include "..\shared\dmstrm.h"
#include "..\shared\debug.h"
#include "..\shared\xsoundp.h"

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_CUTOFFFREQ   0x4A
#define CC_REVERB       0x5B
#define CC_CHORUS       0x5D
#define CC_MIXBINVOLUME 0x66
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE     0x7E
#define CC_POLYMODE     0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB     0x62
#define CC_NRPN_MSB     0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND   0x00
#define RPN_FINETUNE    0x01
#define RPN_COARSETUNE  0x02

/*  Sample format and Sample playback flags are organized
    together because together they determine which 
    mix loop to use.
*/

#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SFORMAT_ADPCM           4       // Four bit sample.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_INTERLEAVED       0x40    // Interleave Buffer 
#define SPLAY_FILTERED          0x80    // Non-trivial filter coeff's


/*  Output buffer format flags, defines whether the buffers being
    played are multi-buffer, interleave or just plain mono
*/
#define BUFFERFLAG_MONO         0x00000000
#define BUFFERFLAG_INTERLEAVED  0x00000001
#define BUFFERFLAG_MULTIBUFFER  0x00000002


typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG    STIME;  // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

typedef long    TCENT;
typedef short   SPERCENT;

#define COEFF_UNITY 0x40000000  // 1.0 multiplier as a 2.30 number
typedef unsigned long COEFF;    // 2.30 fixed point filter coefficient
typedef long COEFFDELTA;        // 2.30 fixed point filter coefficient delta value

#define FILTER_PARMS_DIM_Q  16      // the number of different resonances in the filter parameter table (rows)
#define FILTER_PARMS_DIM_FC 89      // the number of different cutoff frequencies in the filter parameter table (cols)
#define FILTER_FREQ_RANGE   10688   // the difference in pitch cents between the sample rate of the filter design and the 

#define MAX_VOLUME      0       // No attenuation and no amplification 
#define MIN_VOLUME     -9600    // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define MAX_DAUD_CHAN   8       // Maximum outputs for one voice. 

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}
#define CLAMP_VOLUME(a) {if (a < DSBVOLUME_MIN) a = DSBVOLUME_MIN; else if (a > DSBVOLUME_MAX) a = DSBVOLUME_MAX;}

class CControlLogic;

/*
>>>>>>>>> comment 
*/
#ifdef XBOX
class CBusIds
{
public:
    CBusIds() 
    {
        m_bControllers[0] = 0;
        m_dwMixBins = 0;
        m_pBuffer = NULL;
    }

    CBusIds(const CBusIds& other)
    {
        memcpy(m_bControllers,other.m_bControllers,8);
        m_dwMixBins = other.m_dwMixBins;
        m_pBuffer = other.m_pBuffer;
        if(m_pBuffer)
        {
            m_pBuffer->AddRef();
        }
    }

    ~CBusIds() 
    {
        if (m_pBuffer)
        {
            m_pBuffer->Release();
        }
    }

    CBusIds& operator=(const CBusIds& other)
    {
        if(this != &other)
        {
            memcpy(m_bControllers,other.m_bControllers,8);
            m_dwMixBins = other.m_dwMixBins;
            if(m_pBuffer)
            {
                m_pBuffer->Release();
            }
            m_pBuffer = other.m_pBuffer;
            if(m_pBuffer)
            {
                m_pBuffer->AddRef();
            }
        }
        return *this;
    }

    void AssignOutput(IDirectSoundBuffer *pBuffer,DWORD dwMixBins,BYTE *pbControllers)
    {

        if (dwMixBins) {
            m_dwMixBins = dwMixBins;
        }

        if (pbControllers)
        {
            memcpy(m_bControllers,pbControllers,8);
        }
        else m_bControllers[0] = 0;
        if (m_pBuffer)
        {
            m_pBuffer->Release();
        }

        m_pBuffer = pBuffer;

        if (m_pBuffer)
        {
            m_pBuffer->AddRef();
        }
    }

    bool HasBuffer() { return m_pBuffer != NULL; }

    IDirectSoundBuffer* GetBuffer() 
    {
        if(m_pBuffer)
        {
            m_pBuffer->AddRef();
        }
        return m_pBuffer;
    }

    DWORD                   m_dwMixBins;      // Which of the 32 mixbins this sends to.
    BYTE                    m_bControllers[8];// Which controllers for which mixbins on multi-mixbin buffer.

private:
    IDirectSoundBuffer *    m_pBuffer;      // Pointer to DSound buffer.
};
#else
class CBusIds
{
public:
    CBusIds();
    ~CBusIds();

    HRESULT     Initialize();
    HRESULT     AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount);

public:
    DWORD       m_dwBusCount;               // Number of Bus Id's
    DWORD       m_dwBusIds[MAX_DAUD_CHAN];  // Array of bus IDs 
};
#endif
/*  CSourceLFO is the file format definition of the LFO in an
    instrument. This is used to represent an LFO as part of
    a specific articulation set within an instrument that
    has been loaded from disk. Once the instrument is chosen
    to play a note, this is also copied into the CVoice
    object.
*/

class CSourceLFO
{
public:
                CSourceLFO();
    void        Init(DWORD dwMode);
    void        Verify();           // Verifies that the data is valid.
    VRELS       m_vrMWVolumeScale;  // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;   // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;    // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;     // Scaling of straight pitch signal from LFO.

    /* DirectX8 members */
    PRELS       m_prCPPitchScale;   // Scaling of pitch signal from channel pressure. 
    VRELS       m_vrCPVolumeScale;  // Scaling of volume signal from channel pressure.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff freq >>>>>> 
    PRELS       m_prMWCutoffScale;  // Scaling of Cutoff freq mod wheel
    PRELS       m_prCPCutoffScale;  // Scaling of Cutoff freq channel pressure
    DSLFODESC   m_Registers;
};

/*  CSourceEG is the file format definition of an Envelope
    generator in an instrument.
*/

class CSourceEG
{
public:
                CSourceEG();
    void        Init(DWORD dwEg);
    void        Verify();           // Verifies valid data.
//    STIME       m_stAttack;         // Attack rate.
//    STIME       m_stDecay;          // Decay rate.
//    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
//    SPERCENT    m_pcSustain;        // Sustain level.
//    short       m_sScale;           // Scaling of entire signal.

    /* DLS2 */
//    STIME       m_stDelay;          // Delay rate.
//    STIME       m_stHold;           // Hold rate.
    TRELS       m_trKeyHoldScale;   // Scaling of Hold by note value.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff feq >>>>>>

    DSENVELOPEDESC m_Registers;     // Envelope descriptor for hardware.
};

//>>>>>>>> comments 

class CSourceFilter
{
public:
                CSourceFilter();
    void        Init();
    void        Verify();

//    PRELS       m_prSampleRate;     // Sample rate in cents
    PRELS       m_prCutoff;         // Cutoff Frequency in absolute pitch
//    PRELS       m_prCutoffSRAdjust; // Cutoff Frequency adjusted to the sampel rate
    VRELS       m_vrQ;              // Resonance
//    DWORD       m_iQIndex;          // Q index          
    PRELS       m_prVelScale;       // Scale by key velocity
    PRELS       m_prKeyScale;       // Scaling by note value.
};

/*  CSourceArticulation is the file format definition of
    a complete articulation set: the LFO and two
    envelope generators.
    Since several regions within one Instrument can 
    share one articulation, a counter is used to keep
    track of the usage.
*/

class CSourceArticulation

{
public:
                CSourceArticulation();
    HRESULT     Load(CRiffParser *pParser);
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, 
                    void * pvOffsetTable[], DWORD dwIndex, 
                    BOOL fNewFormat);
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void        Init(BOOL fWave);
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    CSourceEG   m_PitchEG;          // Pitch envelope.
    CSourceEG   m_VolumeEG;         // Volume envelope.
    CSourceLFO  m_LFO;              // Low frequency oscillator.
//    DWORD       m_dwSampleRate;
    WORD        m_wUsageCount;      // Keeps track of how many times in use.
    short       m_sDefaultPan;      // default pan (for drums)

    /* DLS2 */
    CSourceLFO  m_LFO2;             // Vibrato
    CSourceFilter m_Filter;         // Low pass filter
};

/*  Since multiple regions may reference
    the same Wave, a reference count is maintained to
    keep track of how many regions are using the sample.
*/

class CWave : public CListItem
{
public:
                    CWave();
                    ~CWave();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    HRESULT         Load(CRiffParser *pParser);
    void            Verify();           // Verifies that the data is valid.
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
#ifdef DXAPI
//    void            PlayOn();           // Increment play count.
//    void            PlayOff();          // Decrement play count.
//    BOOL            IsPlaying();        // Is currently playing?
#endif
    CWave *         GetNext() {return(CWave *)CListItem::GetNext();};
    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleDataSize; // Size in bytes.
//    DWORD           m_dwSampleRate;
    HRESULT ( CALLBACK *m_lpFreeHandle)(HANDLE,HANDLE);
    XBOXADPCMWAVEFORMAT m_WaveFormat;   // Wave format from file.
    HANDLE          m_hUserData;        // Used to notify app when wave released.
    short *         m_pnWave;
    DWORD           m_dwID;             // ID for matching wave with regions.
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
    WORD            m_wPlayCount;       // Wave is currently being played.
//    BYTE            m_bSampleType;

    /* DirectX 8 members */
//    BYTE            m_bStream;          // This wave is used as a streaming buffer
//    BYTE            m_bActive;          // This buffer is currently be used to play out of
//    BYTE            m_bValid;           // Indicates data in the buffer is valid 
//    BYTE            m_bLastSampleInit;  // Indicates the the buffers last sample has been initialize
};


class CWavePool : public CList
{
public:
    CWave *         GetHead() {return (CWave *)CList::GetHead();};
    CWave *         GetItem(DWORD dwID) {return (CWave *)CList::GetItem((LONG)dwID);};
    CWave *         RemoveHead() {return (CWave *)CList::RemoveHead();};
    void            AddTail(CWave *pItem) {CList::AddTail(pItem);};
};

// Private interface for getting the length of a wave
interface IPrivateWave : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(REFERENCE_TIME *prtLength,
        DWORD *dwLoopStart, DWORD *dwLoopEnd) =0;
    virtual HRESULT STDMETHODCALLTYPE SetWaveParams(REFERENCE_TIME rtReadAhead,
        DWORD dwFlags) =0;
};

DEFINE_GUID(IID_IPrivateWave, 0xce6ae366, 0x9d61, 0x420a, 0xad, 0x53, 0xe5, 0xe5, 0xf6, 0xa8, 0x4a, 0xe4);
DEFINE_GUID(IID_CSourceWave,0xf94831cf, 0x6b90, 0x4138, 0xa9, 0xae, 0xb6, 0xb3, 0xa1, 0x63, 0xbb, 0x1);

// Flags for SetWaveBehavior()

#define DSOUND_WAVEF_ONESHOT        1           /* The wave will be played as a one shot */
#define DSOUND_WAVEF_PORT           2           /* The wave will be played via a DMusic port. */
#define DSOUND_WAVEF_SINK           4           /* The wave will be played via a streamed sink interface. */
#define DSOUND_WAVEF_CREATEMASK     0x00000001  /*  Currently only ONESHOT is define for CreateSource  */

// Source wave for Wave object loaded directly from a file (as opposed to member of DLS collection.)

class CSourceWave : CMemTrack,
    public IDirectSoundWave,    // Standard interface.
    public IPersistStream,      // For file io
    public IDirectMusicObject,  // For DirectMusic loader
    public IPrivateWave         // For GetLength
{
friend class CVoice;
friend class CControlLogic;
public:
    CSourceWave();
    ~CSourceWave();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundWave
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
    STDMETHODIMP GetStreamingParms(LPDWORD pdwFlags, LPREFERENCE_TIME prtReadahread);

    // IPersist functions (base class for IPersistStream)
    STDMETHODIMP GetClassID( CLSID* pClsId );

    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObject 
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPrivateWave
    STDMETHODIMP GetLength(REFERENCE_TIME *prtLength,
        DWORD *dwLoopStart, DWORD *dwLoopEnd);
    STDMETHODIMP SetWaveParams(REFERENCE_TIME rtReadAhead,
        DWORD dwFlags);
    

private:
    
    // Internal methods.
    HRESULT             Load(CRiffParser *pParser);
    HRESULT             Read(DWORD dwStartPosition, BYTE *pbData, DWORD dwLength); 

    BYTE                m_bActive;
    CRITICAL_SECTION    m_CriticalSection;      // Used to ensure thread safe
    REFERENCE_TIME      m_rtReadAheadTime;      // Readahead for streaming.
    DWORD               m_fdwFlags;             // Various flags, including whether this is a one-shot.
    long                m_cRef;                 // COM reference counter.
    IStream *           m_pStream;              // IStream pointer which is connected to IPersistStream
    XBOXADPCMWAVEFORMAT m_WaveFormat;           // File's format
    CSourceArticulation m_Articulation;         // For articulation embedded in wave file.
    short *             m_pnWave;               // Wave data.
    DWORD               m_dwSampleDataOffset;   // Start point for wave data in stream.
    DWORD               m_dwSampleDataSize;     // Raw size of wave data.
    DWORD               m_dwSampleCount;        // Total number of sample.
    DWORD               m_dwLoopStart; 
    DWORD               m_dwLoopEnd;
    DWORD               m_dwRepeatCount;
    CInfo               m_Info;
};


/*  The CSourceSample class describes one sample in an
    instrument. The sample is referenced by a CSourceRegion
    structure. 
*/
class Collection;

class CSourceSample
{
public:
                CSourceSample();
                ~CSourceSample();
    BOOL        CopyFromWave();
    void        Verify();           // Verifies that the data is valid.
    CWave *     m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleDataSize; // Size of sample date.
//    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    WORD        m_wID;              // Wave pool id.
//    BYTE        m_bSampleType;      // 16 or 8 or ADPCM.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
    DWORD       m_dwLoopType;       // WLOOP_TYPE_xxx
};

/*  The CSourceRegion class defines a region within an instrument.
    The sample is managed with a pointer instead of an embedded
    sample. This allows multiple regions to use the same
    sample.
    Each region also has an associated articulation. For drums, there
    is a one to one matching. For melodic instruments, all regions
    share the same articulation. So, to manage this, each region
    points to the articulation.
*/

class CSourceRegion : public CListItem
{
public:
                CSourceRegion();
                ~CSourceRegion();
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CSourceRegion *GetNext() {return(CSourceRegion *)CListItem::GetNext();};
    void        Verify();           // Verifies that the data is valid.
    HRESULT     Load(CRiffParser *pParser);
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, void * pvOffsetTable[], 
                    DWORD *pdwRegionIX, BOOL fNewFormat);
    CSourceSample m_Sample;       // Sample structure.
    CSourceArticulation * m_pArticulation; // Pointer to associated articulation.
    VRELS       m_vrAttenuation;    // Volume change to apply to sample.
    PRELS       m_prTuning;         // Pitch shift to apply to sample.
    BYTE        m_bAllowOverlap;    // Allow overlapping of note.
    BYTE        m_bKeyHigh;         // Upper note value for region.
    BYTE        m_bKeyLow;          // Lower note value.
    BYTE        m_bGroup;           // Logical group (for drums.)

    /* DLS2 */
    BYTE        m_bVelocityHigh;    // Upper velocity value for region.
    BYTE        m_bVelocityLow;     // Lower velocity value.
    SHORT       m_sWaveLinkOptions; // Wave link chunk option flags
    DWORD       m_dwChannel;        // Region channels, from WAVELINK chunk

    // Channel in m_dwChannel provides voice destination and overrides anything
    // from the articulation.
    //
    inline BOOL IsMultiChannel() const
    { return (BOOL)(m_sWaveLinkOptions & F_WAVELINK_MULTICHANNEL); }
};


class CSourceRegionList : public CList
{
public:
    CSourceRegion *GetHead() {return (CSourceRegion *)CList::GetHead();};
    CSourceRegion *RemoveHead() {return (CSourceRegion *)CList::RemoveHead();};
};


/*  The CInstrument class is really the file format definition
    of an instrument.
    The CInstrument can be either a Drum or a Melodic instrument.
    If a drum, it has up to 128 pairings of articulations and
    regions. If melodic, all regions share the same articulation.
    ScanForRegion is called by ControlLogic to get the region
    that corresponds to a note.
*/

class CInstManager;

class CInstrument :  public CListItem 
{
public:
                    CInstrument();
                    ~CInstrument();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void            Init();
    void            Verify();           // Verifies that the data is valid.
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwAccept);
    CInstrument *   GetNext() {return(CInstrument *)CListItem::GetNext();};
    CSourceRegion * ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion = NULL);
    CSourceRegionList m_RegionList;     // Linked list of regions.
    DWORD           m_dwProgram;        // Which program change it represents.
    HRESULT         LoadRegions(CRiffParser *pParser);
    HRESULT         Load(CRiffParser *pParser);
    CMemTrack       m_MemTrack;         // Only exists for debugging.
};

class CInstrumentList : public CList
{
public:
    CInstrument *    GetHead() {return (CInstrument *)CList::GetHead();};
    CInstrument *    RemoveHead() {return (CInstrument *)CList::RemoveHead();};
};

#define WAVE_HASH_SIZE          15      // Keep waves in a hash table of linked lists to speed access.
#define INSTRUMENT_HASH_SIZE    15      // Same with instruments.
#define WAVEART_HASH_SIZE       31

DEFINE_GUID(IID_CCollection,0xb28d5b61, 0xbd60, 0x4c62, 0xa9, 0xe1, 0x3b, 0xc2, 0x6, 0x50, 0x2b, 0xb5);

class CSynth;

class CCollection : public IDirectMusicCollection, public IPersistStream, public IDirectMusicObject, public AListItem
{
friend class CInstManager;
friend class CSynth;
public:
    
	// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
	STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistStream
	STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pIStream);
    STDMETHODIMP Save(IStream* pIStream, BOOL fClearDirty) ;
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) ;

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicCollection
	STDMETHODIMP GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument);
	STDMETHODIMP EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName);

	// Class
	CCollection();
    ~CCollection();

    CCollection *   GetNext() {return(CCollection *)AListItem::GetNext();};
private:
    HRESULT         Load(CRiffParser *pParser);
    void            AddInstrument(CInstrument *pInstrument);
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwKey);
    HRESULT         LoadWaves(CRiffParser *pParser);
    HRESULT         LoadInstruments(CRiffParser *pParser);
    void            ResolveConnections();
private:
    CMemTrack           m_MemTrack;
    CInfo               m_Info;
	long				m_cRef;
    long                m_dwConnectionCount;        // How many times this is connected to current synth.
    CSynth *            m_pSynth;                   // Parent synth (only one at a time.)
    CInstrumentList     m_InstrumentList[INSTRUMENT_HASH_SIZE];
    CWavePool           m_WavePool[WAVE_HASH_SIZE];
    CRITICAL_SECTION    m_CriticalSection;
};

class CCollectionList : public AList
{
public:
    CCollection *GetHead() {return (CCollection *)AList::GetHead();};
    void        AddHead(CCollection * pC) {AList::AddHead((AListItem *) pC);};
    CCollection *RemoveHead() {return (CCollection *)AList::RemoveHead();};
};


class CInstManager {
friend class CCollection;
friend class CSynth;
public:
                    CInstManager();
                    ~CInstManager();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CInstrument *   GetInstrument(DWORD dwPatch,DWORD dwKey,DWORD dwVelocity);
    void            Verify();           // Verifies that the data is valid.
    HRESULT         Download(LPHANDLE phDownload, 
                            void * pvData,
                            LPBOOL pbFree);
    HRESULT         Unload(HANDLE hDownload,
                            HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                            HANDLE hUserData);
    CWave *         GetWave(DWORD dwDLId);
private:
    HRESULT         DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat);
    HRESULT         DownloadWave(LPHANDLE phDownload,
                                DMUS_DOWNLOADINFO *pInfo, 
                                void *pvOffsetTable[], 
                                void *pvData);
    CCollectionList m_CollectionList;   // for regular playback.
    CInstrumentList m_InstrumentList;   // only for downloaded instruments for editing.
    CWavePool       m_WavePool[WAVE_HASH_SIZE]; // For editing
    CWavePool       m_FreeWavePool;     // Track waves still in use, but unloaded.
public:
    DWORD           m_dwSynthMemUse;        /* Memory used by synth wave data */ 

    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;
};



/*  The CVoiceLFO class is used to track the behavior
    of an LFO within a voice. The LFO is hard wired to 
    output both volume and pitch values, through separate
    calls to GetVolume and GetPitch.
    It also manages mixing Mod Wheel control of pitch and
    volume LFO output. It tracks the scaling of Mod Wheel
    for each of these in m_nMWVolumeScale and m_nMWPitchScale.
    It calls the Mod Wheel module to get the current values 
    if the respective scalings are greater than 0.
    All of the preset values for the LFO are carried in
    the m_CSource field, which is a replica of the file
    CSourceLFO structure. This is initialized with the
    StartVoice call.
*/

class CVoiceLFO 
{
public:
                CVoiceLFO();
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime);
    CSourceLFO  m_Source;           // All of the preset information.
    BOOL        m_bEnable;
};

/*  The CVoiceEG class is used to track the behavior of
    an Envelope Generator within a voice. There are two 
    EG's, one for pitch and one for volume. However, they
    behave identically.
    All of the preset values for the EG are carried in
    the m_Source field, which is a replica of the file
    CSourceEG structure. This is initialized with the
    StartVoice call.
*/

class CVoiceEG
{
public:
    static void Init();             // Set up linear attack table.
                CVoiceEG();
    STIME       StartVoice(CSourceEG *pSource, STIME stStartTime, 
                    WORD nKey, WORD nVelocity, STIME stMinAttack);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);
    CSourceEG   m_Source;           // Preset values for envelope, copied from file.
    STIME       m_stStartTime;      // Time note turned on
    STIME       m_stStopTime;       // Time note turned off
    static short m_snAttackTable[201];

    /* DirectX8 Memmebers */
    BOOL        m_bEnable;
};

class CVoiceFilter
{
public:
    void        StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity);
    void        GetCoeff(STIME stTime, PREL prFreqIn, COEFF &cfK, COEFF &cfB1, COEFF &cfB2);
    BOOL        IsFiltered();
    
public:
    CSourceFilter   m_Source;   
    CVoiceLFO       *m_pLFO;
    CVoiceEG        *m_pEG;

    PREL            m_prVelScale;
    PREL            m_prKeyScale;
    
    static COEFF    m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
};

#define MAXDB            0
#define MINDB           -100

class CDigitalAudio 
{
public:
    static void Init();                         // Set up lookup tables.
    static PFRACT PRELToPFRACT(PREL prPitch);   // Pitch cents to pitch.
    static VFRACT VRELToVFRACT(VREL vrVolume);  // dB to absolute.
    static PFRACT   m_spfCents[201];    // Pitch increment lookup.
    static PFRACT   m_spfSemiTones[97]; // Four octaves up and down.
    static VFRACT   m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1]; // dB conversion table.
};

VREL VelocityToVolume(WORD nVelocity);
VREL MIDIToPercent(WORD nMIDI);

class CPart;

class CVoice : public CListItem
{
public:
                    CVoice();
#ifdef XMIX
                    ~CVoice();
#endif
    CVoice *        GetNext() {return (CVoice *)CListItem::GetNext();};

    BOOL            StartVoice(CSynth *pControl,
                        CSourceRegion *pRegion, REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        WORD nKey,WORD nVelocity,
                        VREL vrVolume,      
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch);     

    BOOL            StartWave(CSynth *pSynth,
                        CSourceWave *pWave,
                        DWORD dwVoiceId,
                        REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        VREL vrVolume,      
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch,
                        DWORD dwVoiceStart,
                        DWORD dwLoopStart,
                        DWORD dwLoopEnd );

    BOOL            StartStreamedWave(CSynth *pSynth,
                        CSourceWave *pWave,
                        DWORD dwVoiceId,
                        REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        VREL vrVolume,     
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch,
                        DWORD dwVoiceStart,
                        DWORD dwLoopStart,
                        DWORD dwLoopEnd );
    static void     Init();             // Initialize LFO, Digital Audio.
    void            SendVolume(REFERENCE_TIME rtTime);
    void            SendPitch(REFERENCE_TIME rtTime);
    void            SendFilter(REFERENCE_TIME rtTime,BOOL fStart);
    void            SendLFOs(REFERENCE_TIME rtTime);
    void            StopVoice(REFERENCE_TIME rtTime);// Called on note off event.
    void            QuickStopVoice(REFERENCE_TIME rtTime);// Called to get quick release.
    void            ClearVoice();       // Release use of sample.
    void            DoWork(CSynth* pSynth);
    SAMPLE_POSITION GetCurrentPos();
    LPDIRECTSOUNDSEQUENCER GetSequencer();
    HRESULT         AllocateBuffer(XBOXADPCMWAVEFORMAT* pwfxFormat);
    LPDIRECTSOUNDSEQUENCERBUFFER m_pBuffer;
    XBOXADPCMWAVEFORMAT     m_WaveFormat; // Format of current buffer

#define VOICE_NUM_PACKETS 2 // Must match PACKETCOUNT in dmime\audiosink.h

    DWORD           m_dwPacketIndex[VOICE_NUM_PACKETS];
    WORD            m_wCurrentPacket;    // Index into m_dwStreamStatus
    WORD            m_wPacketsSubmitted; // count 0..VOICE_NUM_PACKETS
    DWORD           m_dwStreamPosition;
    DWORD           m_dwLoopStart;      // For streamed looping.
    DWORD           m_dwLoopEnd;  
    PVOID           m_pvBuffer[VOICE_NUM_PACKETS];
    DWORD           m_dwBufferSize;

    LPDIRECTSOUNDSEQUENCERSTREAM m_pStream;
    CSourceWave *   m_pWave;        // Pointer to source wave for streaming.
    CWave       *   m_pDLSWave;     // Pointer to DLS wave sample
    void            CreateStream();
    bool            StreamDoWork(REFERENCE_TIME now);
    HRESULT         WritePacket(REFERENCE_TIME rtTime,DWORD dwPacket);
    void            ProcessCompletedPackets(bool bCompleteUnsubmitted);

    void            StopStream(REFERENCE_TIME rt);

private:
//    CDigitalAudio m_DigitalAudio;  // The Digital Audio Engine structure.
    CSynth *    m_pSynth;           // To access sample rate, etc.
    long        m_lDefaultPan;      // Default pan
    PREL        m_prLastCutOff;     // Last cut off value.
    CSourceArticulation m_Articulation; // Copy of source articulation. We may munge some of it.     

public:
    DWORD       m_dwNoteID;         // Unique id to keep all voices that represent layers of one note connected.
    REFERENCE_TIME m_rtStartTime;   // Time the sound starts.
    REFERENCE_TIME m_rtStopTime;    // Time the sound stops.
    BOOL        m_fInUse;           // This is currently in use.
    BOOL        m_fNoteOn;          // Note is considered on.
    BOOL        m_fTag;             // Used to track note stealing.
    BOOL        m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD        m_nPart;            // Part that is playing this (channel).
    WORD        m_nKey;             // Note played.
    BOOL        m_fAllowOverlap;    // Allow overlapped note.
    DWORD       m_dwGroup;          // Group this voice is playing now
    DWORD       m_dwProgram;        // Bank and Patch choice.
    DWORD       m_dwPriority;       // Priority.
    CControlLogic * m_pControl;     // Which control group is playing voice.
    CPart *     m_pPart;            // And which corresponding part.
    DWORD       m_dwVoiceId;        // Used to identify a playing wave
    CSourceRegion *m_pRegion;       // Used to determine which region a voice is playing out of 
    CBusIds     m_BusIds;           // Bus Id's to play on this voice
    DWORD       m_dwLoopType;       // Loop type
    BOOL        m_fIgnorePan;       // If we're part of a multichannel wave/sample
    VREL        m_vrStartVolume;    // Initial volume, as computed by velocity, region, etc.
    PREL        m_prStartPitch;     // Initial pitch, as computed by region, sample rate, etc.
    PREL        m_prStartFilter;    // Initial filter.
    short       m_wFilterQ;         // Initial resonance.
    BOOL        m_fWave;
    BOOL        m_fStreamed;
    BOOL        m_fUseFilter;
    VREL        m_vrLastVolumes[8]; // Last volumes sent.
    PREL        m_prLastPitch;      // Last pitch sent.
    PREL        m_prLastFilter;     // Last filter sent.
};


class CVoiceList : public CList
{
public:
    CVoice *     GetHead() {return (CVoice *)CList::GetHead();};
    CVoice *     RemoveHead() {return (CVoice *)CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*  Finally, ControlLogic is the big Kahuna that manages 
    the whole system. It parses incoming MIDI events
    by channel and event type. And, it manages the mixing
    of voices into the buffer.

  MIDI Input:

    The most important events are the note on and
    off events. When a note on event comes in, 
    ControlLogic searches for an available voice.
    ControlLogic matches the channel and finds the
    instrument on that channel. It then call the instrument's
    ScanForRegion() command which finds the region 
    that matches the note. At this point, it can copy
    the region and associated articulation into the
    voice, using the StartVoice command.
    When it receives the sustain pedal command,
    it artificially sets all notes on the channel on
    until a sustain off arrives. To keep track of notes
    that have been shut off while the sustain was on
    it uses an array of 128 shorts, with each bit position 
    representing a channel. When the sustain releases,
    it scans through the array and creates a note off for
    each bit that was set.
    It also receives program change events to set the
    instrument choice for the channel. When such
    a command comes in, it consults the softsynth.ini file 
    and loads an instrument with the file name described
    in the ini file.
    Additional continuous controller events are managed
    by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
    modules.

  Mixing:

    Control Logic is also called to mix the instruments into
    a buffer at regular intervals. The buffer is provided by the
    calling sound driver (initially, AudioMan.) 
    Each voice is called to mix its sample into the buffer.
*/

typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MAX_NUM_VOICES          32  
#define NUM_EXTRA_VOICES        8   // Extra voices for when we overload.

class CPart
{
public:
                    CPart();
    void            Init(CControlLogic *pControl, CSynth *pSynth);
    void            RecordMIDI(REFERENCE_TIME rtTimeIn, BYTE bStatus, BYTE bData1, BYTE bData2);
    void            PlayNoteOff(REFERENCE_TIME rtTime,BYTE bNote);
    void            PlayNoteOn(REFERENCE_TIME rtTime,BYTE bNote, BYTE bVelocity);
    void            SendVolume(REFERENCE_TIME rtTime);
    void            SendPitch(REFERENCE_TIME rtTime);
    void            SendFilter(REFERENCE_TIME rtTime);
    void            SendLFOs(REFERENCE_TIME rtTime);
    void            SetSustain(REFERENCE_TIME rtTime,BOOL fSustain);
    void            GetVolume(VREL vrVoice,long lDefaultPan, VREL *pvrVolume,VREL *pvrLeft,VREL *pvrRight,VREL *pvrReverb,VREL *pvrChorus);
    void            GetVolume(VREL vrVoice, BYTE pbControllers[], VREL pvrVolume[]);
    void            GetPitch(PREL *prPitch);
    void            GetFilter(PREL *prFilter);
    void            GetModWheel(DWORD *pdwModWheel);
    void            GetPressure(DWORD *pdwPressure);
    void            AllNotesOff(REFERENCE_TIME rtTime);
    void            AllSoundsOff(REFERENCE_TIME rtTime);

    static VREL     m_svrPanToVREL[128];// Converts Pan to db.

    CControlLogic * m_pControl;
    CSynth *        m_pSynth;
    CBusIds         m_BusIds;           // Bus Id's for this channel 
    REFERENCE_TIME  m_rtLastTime;       // Time of the last event to come in. 
    BOOL            m_fSustain;         // Sustain on / off.
    BOOL            m_fMono;            // Mono mode?
    DWORD           m_dwProgram;        // Instrument choice.
    DWORD           m_dwPriority;       // Priorities for each channel.
    PREL            m_prFineTune;       // Fine tune for each channel.
    PREL            m_prScaleTune[12];  // Alternate scale for each channel.
    PREL            m_prCoarseTune;     // Coarse tune.
    short           m_nPitchBend;       // Pitch Bend.
    short           m_nCurrentRPN;      // RPN number.
    WORD            m_nData;            // Used to track RPN reading.
    BYTE            m_bModWheel;        // Mod Wheel.
    BYTE            m_bVolume;          // Volume.
    BYTE            m_bExpression;      // Expression.
    BYTE            m_bPan;             // Pan.
    BYTE            m_bReverbSend;      // Reverb send.
    BYTE            m_bChorusSend;      // Chorus send.
    BYTE            m_bFilter;          // Filter control.
    BYTE            m_bPressure;        // Channel Pressure.
    BYTE            m_bBankH;           // Bank selects for instrument.
    BYTE            m_bBankL;         
    BYTE            m_bPartToChannel;   // Channel to Part converter.
    BYTE            m_bDrums;           // Melodic or which drum?
    BYTE            m_bMixBinVolume[8]; // The 8 MixBin volume controllers.
};


class CControlLogic
{
    friend class CPart;
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    BOOL            RecordMIDI(REFERENCE_TIME rtTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, REFERENCE_TIME rtTime);
    CSynth *        m_pSynth;
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    /* DirectX8 methods */
    BOOL            RecordWaveEvent(REFERENCE_TIME rtTime, BYTE bChannel, VREL vrVolume, PREL prPitchIn, 
                        SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd,
                        IDirectSoundWave *pIWave, DWORD *pdwVoiceID);
    HRESULT         AssignChannelToOutput(DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers );
    
private:
    void            GMReset();
    CInstManager *  m_pInstruments;
    CPart           m_Part[16];         // One part for each MIDI channel. 
    BOOL            m_fEmpty;           // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;     // Final stage gain adjust
    BOOL            m_fXGActive;        // Is XG Active?
    BOOL            m_fGSActive;        // Is GS enabled?
    VREL            m_vrMasterVolume;   // Master Volume.

public:
    // This is static to protect the CMIDIRecorder free list, which is also static.
    // 
    static CRITICAL_SECTION s_CriticalSection; // Critical section to manage access.
    static DWORD            m_dwCSRefCount;    // Keep track of how many times it is requested.

    void InitCriticalSection();
    void KillCriticalSection();

};

#endif // __SYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\sverb.c ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/***********************************************************
General description :

The functions in this file provides for any apoplication to process audio data
with the SVerb algorithm.

In order to do so the application should :

1. Allocate two chunks of memory for 'Coefs' and 'States' with sizes as returned 
   by the functions 'GetCoefsSize' and 'GetStatesSize' accordingly.
   
2. Initialize these memory chunks using the functions : 'InitSVerb' and 'InitSVerbStates' 
   accordingly.

3. Change the settings of the SVerb sound using the function 'SetSVerb'.

4. Call one of the process functions according to the input/output data format:

   SVerbMonoToMonoShort 
   SVerbMonoToStereoShort
   SVerbStereoToStereoShort 
   SVerbMonoToMonoFloat
   SVerbMonoToStereoFloat
   SVerbStereoToStereoFloat

   The input/output are always the same data type (i.e. both input and output are short integer
   or both are 32bits floats).

   Stereo data format is always'interlaced' left,right samples.

   The 'coefs' and 'states' memory should be passed to the process functions.
   
5. Many coefs structures can be initialized each for different SVerb settings. Passing a different
   coefs structure will cause a real time change of sound quality.

   As long as sound continuity should be maintained the states structure should not be changes or
   re-initialized. Only when a completly new audio sequence is desired should the states be re-initialized.

6. Note that the coefs are valid per sampling rate.

7. Althaugh provisions for coefs compatibility for future versions are provided, it should be avoided to save coefs
   structures to files as-is and re-use them later. Rather the application should save the 'real-world'
   settings of the reverb - namely the parameters passed to 'SetSVerb'. These 'real-world' settings 
   will always be valid for future versions, as well as if other sampling rates are used. The coefs 
   structur(es) should be re-initialized in run time using the real-world settings and call to 
   'SetSverb'.


************************************************************/


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <String.h>
#include <math.h>
#include "SVerb.h"

#pragma optimize( "ty", on )

/****************************************************************************

Function Name	: GetCoefsSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold coefficients.

Description		:  

This function must be called before any calls to other functions that uses the coefs structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerb()'
and 'SetSVerb()'.

The caller should not be botherred by the internals of the coefs structure, rather only konw it's size 
and than allocate enough memory to hold it.

The structure allocated can be used in a very flexible way in order to allow for real-time, pre-computed
changes in Reverb Sound. 

*****************************************************************************/

long GetCoefsSize(void) 
{
	return sizeof(sCoefsStruct); 
};

/****************************************************************************

Function Name	: GetStatesSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold states.

Description		:  

This function must be called before any calls to other functions that uses the states structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerbStates()'.

The states allocated are valid in run-time only, and sould be re-initialized only when a complete
new input is to be processed by the SVerb. 

When changing the settings of revevreb in real time while audio is playing, the states should not 
be re-initialized, rather the same passed states must be passed to the process functions in order 
to maintain sound continuity.

*****************************************************************************/

long GetStatesSize(void) 
{
	return sizeof(long)*(BASE_REV_DELAY+2*BASE_DSPS_DELAY+2); 
};

/****************************************************************************

Function Name	: GetSVerbVersion

Input Arguments : None

Return Value    : Version of SVerb implementation - for future compatibility.

Description		:  

Since the caller do not know about the internals of the coefs structure, this function,
together with 'VerifyVersion' function provides a way to verify if a coefs structure
match the version of the reverb used.

This should be needed only if one is using a coefs structure that was saved to file, and 
being used later.

NOTE : In normal operation, this way of usage should be avoided... and only real-world reverb
settings should be saved to files, and re-initialize the coefs in run time.

*****************************************************************************/

long GetSVerbVersion(void) 
{
	return 0x1; 
};

/****************************************************************************

Function Name	: VerifySampleRate

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The sample rate for which this coefs are valid.

Description		:  

When an application uses different sampling rates, and re-uses same coefs structures, 
it should verify that the coefs match the audio sampling rate.

*****************************************************************************/

float VerifySampleRate(void *pC) {
	return ((sCoefsStruct *)pC)->SampleRate; 
};

/****************************************************************************

Function Name	: VerifyVersion

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The version of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's version.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifyVersion(void *pC) {
	return ((sCoefsStruct *)pC)->myVersion; 
};

/****************************************************************************

Function Name	: VerifySize

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The size of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's size.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifySize(void *pC) {
	return ((sCoefsStruct *)pC)->mySize; 
};


/****************************************************************************

Function Name	: InitSVerbStates

Input Arguments : 

 float *pStates	: The pointer to the states memory.

Return Value    : none.

Description		:  

After allocating memory for the states, according to thge size returned by 'GetStatesSize'
The application MUST initialize the states using this function. 
Note : in future versions this may be more complex than simply memset to 0...
*****************************************************************************/

void InitSVerbStates( long *pStates )
{
    memset( pStates, 0, GetStatesSize() ) ;
}

/****************************************************************************

Function Name	: DToF16

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

Converts a float number between -1.0 .. 1.0 to a 16bits integer 
fixed point representation.
This allows for fix point arithmetics, where two 16bits integers are multiplied to 
a 32bits integer, and we than take the upper 16 bits of the result.

*****************************************************************************/

long DToF16( float dbl  )
{
	dbl *= MAX_16;
	dbl = max(-MAX_16,min(MAX_16-(float)1.0,dbl+(float)0.5));
	return (long)(dbl);
}

/****************************************************************************

Function Name	: ConvertCoefsToFix

Input Arguments : 

 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  converts coefficients to longs, as fixed point numbers

*****************************************************************************/


void ConvertCoefsToFix( void *pC )
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

//		float directGain; 

	pCoefs->l_directGain =  DToF16(pCoefs->directGain);

//		float revGain; 
	pCoefs->l_revGain =  DToF16(pCoefs->revGain);
//		float dDsps;
	pCoefs->l_dDsps =  DToF16(pCoefs->dDsps);
//		float dDG1;
	pCoefs->l_dDG1 =  DToF16(pCoefs->dDG1);
//		float dDG2; 
	pCoefs->l_dDG2 =  DToF16(pCoefs->dDG2);
//	float dFB11;
	pCoefs->l_dFB11 =  DToF16(pCoefs->dFB11);
//		float dFB12;
	pCoefs->l_dFB12 =  DToF16(pCoefs->dFB12);
//		float dFB21;
	pCoefs->l_dFB21 =  DToF16(pCoefs->dFB21);
//		float dFB22;
	pCoefs->l_dFB22 =  DToF16(pCoefs->dFB22);
//		float dFB31;
	pCoefs->l_dFB31 =  DToF16(pCoefs->dFB31);
//		float dFB32;
	pCoefs->l_dFB32 =  DToF16(pCoefs->dFB32);
//		float dFB41;
	pCoefs->l_dFB41 =  DToF16(pCoefs->dFB41);
//		float dFB42;
	pCoefs->l_dFB42 =  DToF16(pCoefs->dFB42);
//		float dDamp;
	pCoefs->l_dDamp =  DToF16(pCoefs->dDamp);



}

/****************************************************************************

Function Name	: InitSVerb

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

After allocating memory for the coefs, according to thge size returned by 'GetCoefsSize'
The application MUST initialize the coefs using this function. 
The initialization takes the sampling rate as an argument, ans thus is valid per this
sampling rate only.

It is possible to find out what is the sampling rate a coefs structure is valid for by calling 
the function 'VerifySampleRate'.

This function initialises the SVerb to so reasonable default setting by calling 'SetSVerb' with
the following real-world settings :

InGain				= -3.0dB   (to avoid output overflows)
dRevMix				= -6.0dB   (a reasonable reverb mix)
dRevTime			= 1000.0ms (one second global reverb time)
dHighFreqRTRatio	= 0.001    (the ratio of the high frequencies to the global reverb time) 

*****************************************************************************/

void InitSVerb( float SampleRate, void *pC)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
 	//Magic numbers ...
    long lRefD;
	
	float dRatio =  (float)1.189207115003;
	
	float dD2MRatio = (float)0.2309333333;

	pCoefs->mySize = sizeof(sCoefsStruct);
	pCoefs->myVersion = 0x1;

	pCoefs->dDsps =  (float)0.6180339887499;

	pCoefs->SampleRate = SampleRate;

    lRefD = (long)( 0.5 + 0.045 * pCoefs->SampleRate ) ;

	pCoefs->lDelay1 = lRefD;
	pCoefs->lDelay3 = (long)(0.5 + dRatio * (float)pCoefs->lDelay1);
	pCoefs->lDelay2 = (long)(0.5 + dRatio * (float)pCoefs->lDelay3);
	pCoefs->lDelay4 = (long)(0.5 + dRatio * (float)pCoefs->lDelay2);
  
    pCoefs->lDDly1 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay1+pCoefs->lDelay2));
	pCoefs->lDDly2 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay3+pCoefs->lDelay4));

    pCoefs->lDelay1 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay2 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay3 -= pCoefs->lDDly2 ;    
    pCoefs->lDelay4 -= pCoefs->lDDly2 ;        

    pCoefs->lDelay1 <<= 2;    
    pCoefs->lDelay2 <<= 2;    
    pCoefs->lDelay3 <<= 2;    
    pCoefs->lDelay4 <<= 2;        

	pCoefs->lDDly1 <<= 1;
	pCoefs->lDDly2 <<= 1;

	SetSVerb( (float)0.0, (float)-10.0, (float)1000.0, (float)0.001, pC );

}

/****************************************************************************

Function Name	: SetSVerb

Input Arguments : 

InGain				: input gain in dB (to avoid output overflows)

dRevMix				: Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                      Negative values gives less wet signal.
					  The coeficients are calculated so that the overall output level stays 
					  (approximately) constant regardless of the ammount of reverb mix.
dRevTime			: The global reverb time (decay time) in milliseconds.

dHighFreqRTRatio	: The ratio of the high frequencies to the global reverb time. 
					  Unless very 'splashy-bright' reverbs are wanted, this should be set to 
					  a value < 1.0.
					  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
					  decay time for high frequencies will be 100ms.

void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

This function accepts the 'real world' settings or SVerb and computes the corresponding 
coefs structure.

The coefs pointer passed to it MUST have been initialized first by InitSVerb.

In normal uses one coefs structure is allocated, initialized, and than as the user changes 
SVerb settings this function should be called repeatedly with the same coefs pointer and the 
new 'real world' settings. 

And the coefs structure passed to the process function in the next buffer to process.

Also few coefs structures can be pre allocated, and initialized, and than different 'presets' 
can be pre-computed into each of them, and switched in real time. 

The coefs structures should not be saved to files by the application for future uses, rather 
the 'real world' settings them selvs. This way future compatibility is guaranteed.

*****************************************************************************/

void SetSVerb( float InGain, float dRevMix, 
			   float dRevTime, float dHighFreqRTRatio, void *pC )
{


	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

    float dD,dTmp,dInGain,dRevGain;

	float dHfR;
    float dAPS;

    if (dHighFreqRTRatio > (float) 0.999)
    {
        dHighFreqRTRatio = (float) 0.999;
    }
    if (dHighFreqRTRatio <= (float) 0.0)
    {
        dHighFreqRTRatio = (float) 0.001;
    }
    dHfR = ( (float)1.0/dHighFreqRTRatio - (float)1.0);

    if (dRevTime < (float) 0.001) 
    {
        dRevTime = (float) 0.001;
    }

    if (InGain > (float) 0.0)
    {
        InGain = (float) 0.0;
    }

    if (dRevMix > (float) 0.0)
    {
        dRevMix = (float) 0.0;
    }

    if (pCoefs->SampleRate < (float) 1.0) 
    {
        pCoefs->SampleRate = (float) 22050.0;
    }

    dAPS = (float)(-3000.0) / (pCoefs->SampleRate * dRevTime);


    pCoefs->dDamp = 0.0;

 	pCoefs->dDG1 = (float)pow((float)10.0,(float)(pCoefs->lDDly1>>1)*dAPS);
 	pCoefs->dDG2 = (float)pow((float)10.0,(float)(pCoefs->lDDly2>>1)*dAPS);

	//////////////////////////////

		pCoefs->dFB11 = (float)pow((float)10.0,(float)(pCoefs->lDelay1>>2)*dAPS);
        
		dD = pCoefs->dFB11 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay1>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB12 = pCoefs->dFB11 * dTmp;
		pCoefs->dFB11 *= ((float)1.0-dTmp);

	///////////////////////////////

		pCoefs->dFB21 = (float)pow((float)10.0,(float)(pCoefs->lDelay2>>2)*dAPS);
        
		dD = pCoefs->dFB21 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay2>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB22 = pCoefs->dFB21 * dTmp;
		pCoefs->dFB21 *= ((float)1.0-dTmp);

	////////////////////////////////

		pCoefs->dFB31 = (float)pow((float)10.0,(float)(pCoefs->lDelay3>>2)*dAPS);
        
		dD = pCoefs->dFB31 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
		    pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay3>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB32 = pCoefs->dFB31 * dTmp;
		pCoefs->dFB31 *= ((float)1.0-dTmp);


	//////////////////////////////

		pCoefs->dFB41 = (float)pow((float)10.0,(float)(pCoefs->lDelay4>>2)*dAPS);

        dD = pCoefs->dFB41 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay4>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB42 = pCoefs->dFB41 * dTmp;
		pCoefs->dFB41 *= ((float)1.0-dTmp);


    pCoefs->dDamp = (float)sqrt(pCoefs->dDamp);

 	dInGain = (float)pow((float)10.0, (float)0.05*InGain ) ;
	dRevMix = (float)pow((float)10.0,(float)0.1*dRevMix);

	dRevGain = (float)4.0 / pCoefs->dDamp * dInGain;

	//in the DSP we used -  	 
	

	pCoefs->directGain = dInGain * (float)sqrt((float)1.0-dRevMix);
	pCoefs->revGain = dRevGain * (float)sqrt(dRevMix);

	ConvertCoefsToFix( pC );

}

///////////////////////////////////////////////////////////////////////////////////////
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/* Process functions */
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/

/**********************************************************************************

Bellow are 6 different process functions.
The difference between the functions is only in the input/output data formats.

3 functions support short samples input/output.
3 other functions support float samples input/output.

Per each of the data types there are 3 functions :

  Mono-Mono
  Mono-Stereo
  Stereo-Stereo

The names of the functions are clear to which format they apply.

Stereo data is always interlaced left,right samples.

All process functions have basically the same format namely :

  SVerbXXXXXX(long NumInFrames, short *pInShort, short *pOutShort, 
			  void *pC, float *pStates)

Input arguments :

long NumInFrames	: Number of input frames
short *pInXXX		: Pointer to input buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.
short *pOutXXX		: Pointer to output buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.

void *pC			: The coefs structure allocated and initialized as explained above.
float *pStates		: The states structure allocated and initialized as explained above.

*******************************************************************************************/

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						  void *pC, long *pStates)
{

	sCoefsStruct *pCoefs =  ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (long)(*pInShort++)>>1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			Out1 += Out2;
			CLIP_SHORT_TO_SHORT(Out1)

			*pOutShort++ = (short)(Out1);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS
void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						    void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In1 += (In1>>1) - (In1>>2);
			In2 = In1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}
#endif

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						      void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In2 = (long)(*pInShort++);

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						  void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.5 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1+Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						    void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.7071 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						      void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (*pInFloat++) + FPU_DENORM_OFFS;
			In2 = (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR )
{
	float outL, outR;
	float *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = dDG1 * (*pDlyOut++) + *inR * dDsps;
	outR = dDG1 * (*pDlyOut) - *inL * dDsps ;

    // here we feed back the output.
	*pDly++ = *inL + dDsps * outR ;
	*pDly = *inR - dDsps * outL ;

	*inL = outL;
	*inR = outR;

}
#endif

__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR )
{
	long outL, outR;
	long *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = (dDG1 * (*pDlyOut++) + *inR * dDsps)>>15;

	outR = (dDG1 * (*pDlyOut) - *inL * dDsps)>>15;

    // here we feed back the output.
	*pDly++ = *inL + ((dDsps * outR)>>15) ;

	*pDly = *inR - ((dDsps * outL)>>15) ;

	*inL = outL;
	*inR = outR;

}
#pragma optimize( "ty", off )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\normal\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\syslink.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
// 
#ifndef _SYSLINK_
#define _SYSLINK_

#include <mmsystem.h>

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ HWND hWnd, 
                                           BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
};

typedef IDirectMusicSynthSink *PDIRECTMUSICSYNTHSINK;

class CSysLink : public IDirectMusicSynthSink
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG, AddRef)       (THIS);
    STDMETHOD_(ULONG, Release)      (THIS);

    // IDirectMusicSynthSink
    //
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth);
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat);
	STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock);
	STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock);
	STDMETHOD(Activate)             (THIS_ HWND hWnd, BOOL fEnable);
	STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, LONGLONG *pllSampleTime);

    // Class
    //
	CSysLink();
	~CSysLink();

private:
    LONG m_cRef;
};

#define STATIC_IID_IDirectMusicSynthSink \
    0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6
DEFINE_GUIDSTRUCT("aec17ce3-a514-11d1-afa6-00aa0024d8b6", IID_IDirectMusicSynthSink);
#define IID_IDirectMusicSynthSink DEFINE_GUIDNAMED(IID_IDirectMusicSynthSink)

#endif // _SYSLINK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\profile\makefile.inc ===
# obj\$(TARGET_DIRECTORY)\xapi.def: xapi.src
#     $(TARGET_CPP) /EP $(CDEFINES) xapi.src > obj\$(TARGET_DIRECTORY)\xapi.def

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

# $(XDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib: $(SDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib
#     copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\wave.cpp ===
//      Copyright (c) 1996-2001 Microsoft Corporation
//      dls.cpp
//

#include "simple.h"
#include <mmsystem.h>
#include <dmerror.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#include "..\shared\validate.h"
#include <dmusicf.h>
void MemDump(char * prompt);

#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>
//#include "debug.h"

#include "debug.h" 
#include "dmusicc.h" 
#include "dmusicip.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "synth.h"
#include <regstr.h>
#include <share.h>
//#include "waveutil.h"
#include "dmstrm.h"


STDAPI DirectSoundWaveCreate(REFIID iid, void ** ppDMC )
{
    CSourceWave *pWave = new CSourceWave;
    if (pWave)
    {
        return pWave->QueryInterface(iid,ppDMC);
    }
    return E_OUTOFMEMORY;
}

CSourceWave::CSourceWave() : CMemTrack(DMTRACK_WAVE)
{
    InitializeCriticalSection(&m_CriticalSection);

	m_fdwFlags		  = 0;
	m_pStream         = NULL;
    m_dwLoopStart     = 0;
    m_dwLoopEnd       = 0;
    m_dwRepeatCount   = 0;
	m_rtReadAheadTime = 100 * 10000;
    m_Articulation.Init(TRUE);
    m_dwSampleDataSize = 0;
    m_pnWave = NULL;

    m_cRef = 0;
}

CSourceWave::~CSourceWave()
{
	if (m_pStream) m_pStream->Release();
    delete [] m_pnWave;

    DeleteCriticalSection(&m_CriticalSection);
}

STDMETHODIMP CSourceWave::QueryInterface
(
    const IID &iid,
    void **ppv
)
{
	V_INAME(CSourceWave::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_CSourceWave)
    {
        *ppv = static_cast<CSourceWave*>(this);
    }
    else if (iid == IID_IPrivateWave)
    {
        *ppv = static_cast<IPrivateWave*>(this);
    }
    else if (iid == IID_IDirectSoundWave)
    {
        *ppv = static_cast<IDirectSoundWave*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CSourceWave::AddRef()
{
	V_INAME(CSourceWave::AddRef);

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSourceWave::Release()
{
	V_INAME(CSourceWave::Release);

    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSourceWave::GetFormat
(
    LPWAVEFORMATEX pwfx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten
)
{
    if (pwfx && (dwSizeAllocated >= sizeof(WAVEFORMATEX)))
    {
        *pwfx = m_WaveFormat.wfx;
        return S_OK;
    }
    return E_FAIL;
/*	V_INAME(CSourceWave::GetFormat);

    if (!pwfx && !pdwSizeWritten)
    {
        Trace(1, "ERROR: GetFormat (Wave): Must request either the format or the required size\n.");
        return E_INVALIDARG;
    }

    dwSizeAllocated = min(sizeof(XBOXADPCMWAVEFORMAT),dwSizeAllocated);

	V_BUFPTR_WRITE(pwfx, dwSizeAllocated); 
    pwfx->cbSize = 0;
    memcpy(pwfx, &m_WaveFormat, dwSizeAllocated);
    // Return the numbers of bytes actually writted
    if (pdwSizeWritten)
    {
        *pdwSizeWritten = dwSizeAllocated;
    }

    return S_OK;*/
}

STDMETHODIMP CSourceWave::CreateSource
(
    IDirectSoundSource  **ppSource,
    LPWAVEFORMATEX      pwfx,
    DWORD               fdwFlags
)
{
//	CWaveViewPort* 	pVP;
//	CREATEVIEWPORT	cvp;

	V_INAME(CSourceWave::CreateSource);
	V_PTRPTR_WRITE(ppSource);
//    V_PWFX_READ(pwfx);

    DWORD dwCreateFlags = 0;
    if (fdwFlags == DMUS_DOWNLOADINFO_ONESHOTWAVE)
    {
        dwCreateFlags |= DSOUND_WAVEF_ONESHOT;
    }
	if (dwCreateFlags & (~DSOUND_WAVEF_CREATEMASK))
	{
        Trace(1, "ERROR: CreateSource (Wave): Unknown flag.\n");
		return (E_INVALIDARG);
	}

//    TraceI(5, "CSourceWave::CreateSource [%d samples]\n", m_cSamples);
	return E_FAIL;
/*	pVP = new CWaveViewPort;
    if (!pVP)
    {
        return E_OUTOFMEMORY;
    }

	cvp.pStream 	= m_pStream;
	cvp.cSamples	= m_cSamples;
	cvp.cbStream	= m_cbStream;
	cvp.pwfxSource	= m_pwfx;
	cvp.pwfxTarget  = pwfx;
    cvp.fdwOptions  = dwCreateFlags;

	hr = pVP->Create(&cvp);

	if (SUCCEEDED(hr)) 
	{
		hr = pVP->QueryInterface(IID_IDirectSoundSource, (void **)ppSource);
	}
	else
	{
	    TraceI(5, "CSourceWave::CreateSource 00\n");
	}

	if (SUCCEEDED(hr))
	{
		// The QI gave us one ref too many
		pVP->Release();
	}
	else
	{
	    TraceI(5, "CSourceWave::CreateSource 01\n");
	}

    return hr;*/
}

STDMETHODIMP CSourceWave::GetStreamingParms
(
    LPDWORD              pdwFlags, 
    LPREFERENCE_TIME    prtReadAhead
)
{
    V_INAME(IDirectSoundWave::GetStreamingParms);
    V_PTR_WRITE(pdwFlags, DWORD);
    V_PTR_WRITE(prtReadAhead, REFERENCE_TIME);
    
    *pdwFlags = 0;

    if(!(m_fdwFlags & DSOUND_WAVEF_ONESHOT))
    {
        *pdwFlags = DMUS_WAVEF_STREAMING;
    }

    *pdwFlags |= m_fdwFlags & (DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);

    *prtReadAhead  = m_rtReadAheadTime;
    return S_OK;
}

STDMETHODIMP CSourceWave::GetClassID
(
    CLSID*  pClsId
)
{
	V_INAME(CSourceWave::GetClassID);
	V_PTR_WRITE(pClsId, CLSID); 

    *pClsId = CLSID_DirectSoundWave;
    return S_OK;
}

STDMETHODIMP CSourceWave::IsDirty()
{
	V_INAME(CSourceWave::IsDirty);

    return S_FALSE;
}

HRESULT CSourceWave::Read(DWORD dwStartPosition, BYTE *pbBuffer, DWORD dwLength)

{
    if ((dwLength + dwStartPosition) <= m_dwSampleDataSize)
    {
        LARGE_INTEGER li;
        li.QuadPart = m_dwSampleDataOffset + dwStartPosition;
        m_pStream->Seek(li, STREAM_SEEK_SET, NULL);
        return m_pStream->Read(pbBuffer,dwLength,NULL);
    }
    return E_FAIL;
}


HRESULT CSourceWave::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 

	BOOL fFormat = FALSE;
 	BOOL fHeader = FALSE;
    DWORD dwSamplesFromFact = 0;
    
    
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case DMUS_FOURCC_WAVEHEADER_CHUNK:
			{
                m_fdwFlags = 0;
				fHeader = TRUE;
				DMUS_IO_WAVE_HEADER iWaveHeader;
				memset(&iWaveHeader, 0, sizeof(iWaveHeader));
                hr = pParser->Read(&iWaveHeader, sizeof(iWaveHeader));
				if (iWaveHeader.dwFlags & DMUS_WAVEF_STREAMING)
				{
					m_rtReadAheadTime = iWaveHeader.rtReadAhead;
				}
				else
				{
					m_fdwFlags = DSOUND_WAVEF_ONESHOT;
					m_rtReadAheadTime = 0;
				}
                m_fdwFlags |= iWaveHeader.dwFlags & 
                    (DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);

                break;
			}
        case mmioFOURCC('f','m','t',' ') :
            hr = pParser->Read(&m_WaveFormat, sizeof(XBOXADPCMWAVEFORMAT));
            if ((m_WaveFormat.wfx.wFormatTag != WAVE_FORMAT_PCM)
                && (m_WaveFormat.wfx.wFormatTag != WAVE_FORMAT_XBOX_ADPCM)) 
            {
                return E_FAIL;
            } 
            // Clean up ADPCM waveformat if it's broken.
/*            if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
            {
                m_WaveFormat.wSamplesPerBlock = 64;
                m_WaveFormat.wfx.nBlockAlign = 36;
                m_WaveFormat.wfx.wBitsPerSample = 4;
                m_WaveFormat.wfx.cbSize = sizeof(m_WaveFormat) - sizeof(m_WaveFormat.wfx);
            }
            else
            {
                m_WaveFormat.wfx.cbSize = 0;
            }*/
		    fFormat = TRUE;
            break;
        case DMUS_FOURCC_GUID_CHUNK:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
                case DMUS_FOURCC_INFO_LIST:
                case DMUS_FOURCC_UNFO_LIST:
                    hr = m_Info.ReadChunk(pParser,ckNext.fccType);
                    break;
                case FOURCC_LART :
                case FOURCC_LAR2 :
                m_Articulation.Init(FALSE);
                m_Articulation.Load(pParser);
                break;
            }
            break;
        case mmioFOURCC('f','a','c','t'):
           hr = pParser->Read(&dwSamplesFromFact, sizeof(DWORD));
           break;
        case mmioFOURCC('s','m','p','l'):
            {
                typedef struct _rsmpl 
                {
                  DWORD dwManufacturer;
                  DWORD dwProduct;
                  DWORD dwSamplePeriod;
                  DWORD dwMIDIUnityNote;
                  DWORD dwMIDIPitchFraction;
                  DWORD dwSMPTEFormat;
                  DWORD dwSMPTEOffset;
                  DWORD cSampleLoops;
                  DWORD cbSamplerData;
                  // That ends the RSMPL structure, which is followed
                  // by the RLOOP structure:
                  DWORD dwIdentifier;
                  DWORD dwType;
                  DWORD dwStart;
                  DWORD dwEnd;
                  DWORD dwFraction;
                  DWORD dwPlayCount;
                } RSMPL_PLUS_RLOOP;
                RSMPL_PLUS_RLOOP rloop;
                rloop.dwEnd = rloop.dwStart = 0;
                rloop.cSampleLoops = 0;
                hr = pParser->Read(&rloop,sizeof(RSMPL_PLUS_RLOOP));
                if (rloop.cSampleLoops)
                {
                    m_dwLoopStart = rloop.dwStart;
                    m_dwLoopEnd = rloop.dwEnd + 1; // File format has endpoint inclusive.
                    if (rloop.dwPlayCount)
                    {
                        m_dwRepeatCount = rloop.dwPlayCount;
                    }
                    else
                    {
                        m_dwRepeatCount = -1; 
                    }
                }
            }
            break;

        case mmioFOURCC('d','a','t','a') :
            if (!fFormat) 
            {
                hr = E_FAIL; // If no wave format, this is a bad file. 
                break;
            }
            m_dwSampleDataSize = ckNext.cksize;
            // Load the data if this is non streaming. If there was no header chunk,
            // decide by looking at the length of the wave.
            if (!fHeader)
            {
                LONGLONG llTemp = 0;
                if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
                {
                    llTemp = (m_dwSampleDataSize * 64) / (36 * m_WaveFormat.wfx.nChannels);
                }
                else if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_PCM)
                {
                    llTemp = m_dwSampleDataSize * 8; // Total bits.
                    llTemp /= (m_WaveFormat.wfx.nChannels * m_WaveFormat.wfx.wBitsPerSample); // divided by bits per interleaved sample.
                }
                llTemp *= 1000;
                llTemp /= m_WaveFormat.wfx.nSamplesPerSec;
                if (llTemp > 5000)
                {
                    m_rtReadAheadTime = 100 * 10000;
                    m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
                }
                else
                {
                    m_rtReadAheadTime = 0;
                    m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
                }
            }
            if (m_fdwFlags & DSOUND_WAVEF_ONESHOT)
            {
                m_pnWave = (short *) new char[m_dwSampleDataSize];
                if (m_pnWave)
                {
                    hr = pParser->Read(m_pnWave, m_dwSampleDataSize);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // Store the start position if this is supposed to be streamed.
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream = pParser->GetStream();
                m_pStream->AddRef();
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
                m_dwSampleDataOffset = (DWORD) ul.QuadPart;
            }
            break;
        default:
            break;
        }
    }
    pParser->LeaveList();
    if (fFormat)
    {
        // Now, calculate out the number of samples, taking into consideration compression.
        LONGLONG llTemp;
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            llTemp = (m_dwSampleDataSize * 64) / (36 * m_WaveFormat.wfx.nChannels);
        }
        else if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_PCM)
        {
            llTemp = m_dwSampleDataSize * 8; // Total bits.
            llTemp /= (m_WaveFormat.wfx.nChannels * m_WaveFormat.wfx.wBitsPerSample); // divided by bits per interleaved sample.
        }
        else
        {
            Trace(0,"ERROR: Unknown wave format tag.");
            llTemp = 0;
            hr = E_FAIL;
        }
        m_dwSampleCount = (DWORD) llTemp;
    }
    else 
    {
        // No format or no data, return error (and wave will be deleted.)
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CSourceWave::Load( IStream* pIStream )
{
	V_INAME(IPersistStream::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == mmioFOURCC('W','A','V','E')))
    {
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing Wave\n");
        hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP CSourceWave::Save
(
    IStream*    pIStream,
    BOOL        fClearDirty
)
{
	V_INAME(CSourceWave::Save);

	return E_NOTIMPL; 
}

STDMETHODIMP CSourceWave::GetSizeMax
(
    ULARGE_INTEGER FAR* pcbSize
)
{
	V_INAME(CSourceWave::GetSizeMax);

	return E_NOTIMPL; 
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSourceWave::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CSourceWave::GetDescriptor);
	V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.GetDescriptor(pDesc,CLSID_DirectSoundWave);
}

STDMETHODIMP CSourceWave::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CSourceWave::SetDescriptor);
	V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CSourceWave::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CSourceWave::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.ParseDescriptor(pIStream,pDesc,mmioFOURCC('W','A','V','E'),CLSID_DirectSoundWave);
}

STDMETHODIMP CSourceWave::SetWaveParams(REFERENCE_TIME rtReadAhead,DWORD dwFlags)
{
	if (dwFlags & DMUS_WAVEF_STREAMING)
	{
		m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
		m_rtReadAheadTime = rtReadAhead;
	}
	else
	{
		m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
		m_rtReadAheadTime = 0;
	}

    m_fdwFlags &= ~(DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);
    m_fdwFlags |= dwFlags & (DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);

    return S_OK;
}

STDMETHODIMP CSourceWave::GetLength(REFERENCE_TIME *prtLength,
                               DWORD *dwLoopStart, DWORD *dwLoopEnd)
{
	HRESULT hr = S_OK;
    *dwLoopStart = m_dwLoopStart;
    *dwLoopEnd = m_dwLoopEnd;
	if (m_WaveFormat.wfx.nSamplesPerSec)
	{
        *prtLength = m_dwSampleCount;
        if (m_dwRepeatCount)
        {
            // If it repeats infinitely, just return the max.
            if (m_dwRepeatCount == -1)
            {
                // Make it play for 5 years, which is the life expectancy of the XBOX. 
                // That should be long enough, and it still
                // avoids overflowing which would happen if we set this to max.
                // Note that this is in mils, not reference time.
                *prtLength = 157680000000; // 1000 * 60 * 60 * 24 * 365 * 5
                return S_OK;
            }
            else
            {
                // Add all the repeats to the length.
                *prtLength += m_dwRepeatCount * (m_dwLoopEnd - m_dwLoopStart);
                // Subtract the section between the end of loop and the end.
                // We have to lose this because the synth loops infinitely, so we are really
                // sending back a length that will cause playback to stop after the
                // nth repeat, but there currently is no way to get it to follow into
                // the final section, so we lose that.
                // But, first test for a bad file.
                if (m_dwLoopEnd > m_dwSampleCount)
                {
                    Trace(1, "Warning: Wave has loop end %ld longer than wave length %ld\n",m_dwLoopEnd,m_dwSampleCount);
                    m_dwLoopEnd = m_dwSampleCount;
                }
                *prtLength -= (long) (m_dwSampleCount - m_dwLoopEnd);
            }
        }
        *prtLength *= 1000;
        *prtLength /= m_WaveFormat.wfx.nSamplesPerSec;
	}
	else
	{
        Trace(2, "WARNING: Couldn't get a length for a Wave.\n");
		hr = DMUS_E_BADWAVE;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\umsynth.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

#pragma warning(disable:4530)
// UMSynth.cpp : Implementation of CUserModeSynth

#ifdef XBOX
#include <xtl.h>
#include <xboxutil.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include <mmsystem.h>
#ifdef XBOX
#undef timeGetTime
#define timeGetTime GetTickCount
#endif // XBOX
#include <dsoundp.h>
#include <ks.h>

#include "debug.h"
#include "UMSynth.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "math.h"
#include "misc.h"
#include "dmksctrl.h"
#include "dsoundp.h"    // For IDirectSoundSource

#include <dmusprop.h>

#include "..\shared\validate.h"

/*DWORD GetTheCurrentTime()
{
	static BOOL s_fFirstTime = TRUE;
	static LARGE_INTEGER s_liPerfFrequency;
	static BOOL s_fUsePerfCounter = FALSE;
	if (s_fFirstTime)
	{
		s_fFirstTime = FALSE;
		s_fUsePerfCounter = QueryPerformanceFrequency(&s_liPerfFrequency);
		s_liPerfFrequency.QuadPart /= 1000;
	}
	if (s_fUsePerfCounter)
	{
		LARGE_INTEGER liPerfCounter;
		QueryPerformanceCounter(&liPerfCounter);
		liPerfCounter.QuadPart /= s_liPerfFrequency.QuadPart;
		return (DWORD) liPerfCounter.QuadPart;
	}
	else
	{
		return timeGetTime();
	}
}*/

/////////////////////////////////////////////////////////////////////////////
// CUserModeSynth

HRESULT CUserModeSynth::Init()

{
	return S_OK;
}

CUserModeSynth::CUserModeSynth()

{
    ::InitializeCriticalSection(&m_CriticalSection);
    m_MasterClock.m_pParent = this;
	m_cRef = 0;
    m_lVolume = 0;
    m_lBoost = 6 * 100;
    m_lGainAdjust = 6 * 100;            // Default 6 dB boost
	m_fActive = FALSE;
    m_pSynth = NULL;
}

CUserModeSynth::~CUserModeSynth()

{
//	Activate(FALSE);

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        delete m_pSynth;
    	m_pSynth = NULL;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    ::DeleteCriticalSection(&m_CriticalSection);
}


// CUserModeSynth::QueryInterface
//
STDMETHODIMP
CUserModeSynth::QueryInterface(const IID &iid,
                                   void **ppv)
{
    V_INAME(IDirectMusicSynth::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynthX) {
        *ppv = static_cast<IDirectMusicSynthX*>(this);
    }
	else if (iid == IID_IKsControl) 
    {
        *ppv = static_cast<IKsControl*>(this);
    }
/*	else if (iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
	}*/
    else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CUserModeSynth::AddRef
//
STDMETHODIMP_(ULONG)
CUserModeSynth::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CUserModeSynth::Release
//
STDMETHODIMP_(ULONG)
CUserModeSynth::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

/*STDMETHODIMP CUserModeSynth::SetSynthSink(
	IDirectMusicSynthSink *pSynthSink)	// <i IDirectMusicSynthSink> to connect to synth, or
										// NULL to disconnect.
{
	HRESULT hr = S_OK;
	V_INAME(IDirectMusicSynth::SetSynthSink);
	V_INTERFACE_OPT(pSynthSink);
	
    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>>. RELEASE THE DSINK IF PRESENT !!!!

	if (m_pSynthSink)
	{
		hr = m_pSynthSink->Init(NULL);
		m_pSynthSink->Release();
	}

	m_pSynthSink = pSynthSink;

//>>>>>>>>> the current state of the format of the the synth is
//>>>>>>>>> ambiguos if a sink has been previously applied.  
	m_dwBufferFlags &= ~BUFFERFLAG_MULTIBUFFER;	// .... just in case 

	if (m_pSynthSink)
	{
		m_pSynthSink->AddRef();
//		hr = m_pSynthSink->Init(static_cast<IDirectMusicSynthX*>(this));
	}
	::LeaveCriticalSection(&m_CriticalSection);
	
    return hr;
}*/

STDMETHODIMP CUserModeSynth::Open(	
	LPDMUS_PORTPARAMS pPortParams)		// <t DMUS_PORTPARAMS> structure for opening the port. If NULL, default settings are used.
{
	V_INAME(IDirectMusicSynth::Open);
    //if (pPortParams == NULL)
	//{
    //    Trace(1,"Error: Open called with NULL PortParams.\n");
	//	return E_FAIL;
	//}

    DWORD cbPortParams = 0;
    DWORD dwVer;
    
	if (pPortParams)
	{
        V_STRUCTPTR_READ_VER(pPortParams, dwVer);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 7);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 8);
        V_STRUCTPTR_READ_VER_END(DMUS_PORTPARAMS, pPortParams);

        switch (dwVer)
        {
            case 7:
                cbPortParams = sizeof(DMUS_PORTPARAMS7);
                break;

            case 8:
                cbPortParams = sizeof(DMUS_PORTPARAMS8);
                break;
        }
    }
        
    
	bool bPartialOpen = false;
	
	DMUS_PORTPARAMS myParams;
	myParams.dwSize = sizeof (myParams);
	myParams.dwVoices = 32;
	myParams.dwChannelGroups = 2;
	myParams.dwAudioChannels = 2;
	myParams.dwSampleRate = 22050;
	myParams.dwEffectFlags = DMUS_EFFECT_NONE;
    myParams.fShare = FALSE;
	myParams.dwValidParams = 
		DMUS_PORTPARAMS_VOICES | 
		DMUS_PORTPARAMS_CHANNELGROUPS |
		DMUS_PORTPARAMS_AUDIOCHANNELS |
		DMUS_PORTPARAMS_SAMPLERATE |
		DMUS_PORTPARAMS_EFFECTS |
		DMUS_PORTPARAMS_SHARE;
    
	if (pPortParams)
	{
	    if (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8))
        {
            myParams.dwValidParams |= DMUS_PORTPARAMS_FEATURES;
            myParams.dwFeatures = 0;
        }
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES)
		{
			if (pPortParams->dwVoices)
			{
				if (pPortParams->dwVoices <= MAX_VOICES)
				{
					myParams.dwVoices = pPortParams->dwVoices;
				}
				else
				{
					bPartialOpen = true;
					myParams.dwVoices = MAX_VOICES;
				}
			}
			else
			{
				bPartialOpen = true;
				myParams.dwVoices = 1; // MIN_VOICES
			}
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
		{
			if (pPortParams->dwChannelGroups)
            {
                if (pPortParams->dwChannelGroups <= MAX_CHANNEL_GROUPS)
			    {
				    myParams.dwChannelGroups = pPortParams->dwChannelGroups;
			    }
			    else
			    {
				    bPartialOpen = true;
				    myParams.dwChannelGroups = MAX_CHANNEL_GROUPS;
			    }
            }
			else
			{
				bPartialOpen = true;
				myParams.dwChannelGroups = 1; // MIN_CHANNEL_GROUPS
			}
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS)
		{
			if (pPortParams->dwAudioChannels)
            {
                if (pPortParams->dwAudioChannels <= 2)
			    {
				    myParams.dwAudioChannels = pPortParams->dwAudioChannels;
			    }
			    else
			    {
				    bPartialOpen = true;
				    myParams.dwAudioChannels = 2; // MAX_AUDIO_CHANNELS
			    }
            }
			else
			{
				bPartialOpen = true;
				myParams.dwAudioChannels = 1; // MIN_AUDIO_CHANNELS
			}
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
		{
            if (dwVer == 7)
            {
                // DX-7 compat: clamp sample rate to one of the
                // understood rates.
                //
    			if (pPortParams->dwSampleRate > 30000)
    			{
    				if(pPortParams->dwSampleRate != 44100)
    				{
    					bPartialOpen = true;
    				}
    				
    				myParams.dwSampleRate = 44100;
    			}
    			else if (pPortParams->dwSampleRate > 15000)
    			{
    				if(pPortParams->dwSampleRate != 22050)
    				{
    					bPartialOpen = true;
    				}

    				myParams.dwSampleRate = 22050;
    			}
    			else 
    			{
    				if(pPortParams->dwSampleRate != 11025)
    				{
    					bPartialOpen = true;
    				}

    				myParams.dwSampleRate = 11025;
    			}
            }
            else
            {
    			if (pPortParams->dwSampleRate > 96000)
    			{
    				bPartialOpen = true;
    				myParams.dwSampleRate = 96000;
    			}
    			else if (pPortParams->dwSampleRate < 11025)
    			{
    				bPartialOpen = true;
    				myParams.dwSampleRate = 11025;
    			}
                else myParams.dwSampleRate = pPortParams->dwSampleRate;
            }
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS)
		{
            if (pPortParams->dwEffectFlags & ~DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
                pPortParams->dwEffectFlags &= DMUS_EFFECT_REVERB;
            }

			myParams.dwEffectFlags = DMUS_EFFECT_NONE; 
			if (pPortParams->dwEffectFlags & DMUS_EFFECT_REVERB)
			{
				bPartialOpen = true;
			}
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
        {
            if (pPortParams->fShare)
            {
                bPartialOpen = true;
            }
        }

        if ((pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8)))
        {
            myParams.dwFeatures = pPortParams->dwFeatures;
        }
	}

	if (pPortParams)
	{
        DWORD dwSize = min(cbPortParams, myParams.dwSize);

        memcpy(pPortParams, &myParams, dwSize);
        pPortParams->dwSize = dwSize;
	}

//    m_dwSampleRate = 48000;
//    m_dwChannels = 2;
//	m_dwBufferFlags = (m_dwChannels==1)?BUFFERFLAG_MONO:BUFFERFLAG_INTERLEAVED;

	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_ALREADYOPEN;
	if (!m_pSynth)
	{
        try
        {
		    m_pSynth = new CSynth;
        }
        catch( ... )
        {
            m_pSynth = NULL;
        }

		if (!m_pSynth)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			// Note: hr is initalized to DMUS_E_ALREADYOPEN,
			// so we can't do the typical "if(SUCCEEDED(hr))" here.
			hr = m_pSynth->Initialize();

			if (SUCCEEDED(hr))
			{
				hr = m_pSynth->Open(myParams.dwChannelGroups,
					myParams.dwVoices);
			}
			if (SUCCEEDED(hr))
			{
                m_pSynth->SetGainAdjust(m_lGainAdjust);
                m_pSynth->SetMasterClock(&m_MasterClock);
//                m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);
			}
			else
			{
				delete m_pSynth;
				m_pSynth = NULL;
			}
		}
	}
	::LeaveCriticalSection(&m_CriticalSection);
	
	if(SUCCEEDED(hr))
	{
		if(bPartialOpen)
		{
			hr = S_FALSE;
		}
	}
	
	return hr;
}

STDMETHODIMP CUserModeSynth::SetNumChannelGroups(
	DWORD dwGroups)		// Number of ChannelGroups requested.

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	if (m_pSynth)
	{
		hr = m_pSynth->SetNumChannelGroups(dwGroups);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CUserModeSynth::SetMasterVolume(LONG lVolume)

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    m_lVolume =  lVolume;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }	
    ::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}


STDMETHODIMP CUserModeSynth::SendShortMsg(REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg)
{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	if (m_pSynth)
	{
		hr = m_pSynth->SendShortMsg(rt,dwGroup,dwMsg);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}



STDMETHODIMP CUserModeSynth::SendLongMsg(REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength)
{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	if (m_pSynth)
	{
		hr = m_pSynth->SendLongMsg(rt,dwGroup,pbMsg,dwLength);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}


STDMETHODIMP CUserModeSynth::Close()

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_ALREADYCLOSED;
	if (m_pSynth)
	{
		hr = m_pSynth->Close();
		delete m_pSynth;
		m_pSynth = NULL;
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}
/*STDMETHODIMP CUserModeSynth::Download(
	LPHANDLE phDownload,	// Pointer to download handle, to be created by <om IDirectMusicSynth::Download> and used later to unload the data.
	LPVOID pvData,			// Pointer to continuous memory segment with download data.
	LPBOOL pbFree)			// <p pbFree> indicates whether the synthesizer wishes to keep the memory in <p pvData> allocated.
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	V_INAME(IDirectMusicSynth::Download);
	V_PTR_WRITE(phDownload,HANDLE); 
	V_PTR_WRITE(pbFree,BOOL); 

	// pvData is validated inside synth while parsing.
	::EnterCriticalSection(&m_CriticalSection);
	if (m_pSynth)
	{
		hr = m_pSynth->Download(phDownload, pvData, pbFree);
	}
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

STDMETHODIMP CUserModeSynth::Unload(
	HANDLE hDownload,	// Handle to data, previously downloaded with a call to <om IDirectMusicSynth::Download>.
	HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), // If the original call to
						// <om IDirectMusicSynth::Download> returned FALSE in <p pbFree>,
						// the synthesizer hung onto the memory in the download chunk. If so,
						// the caller must be notified once the memory has been freed,
						// but that could occur later than <om IDirectMusicSynth::Download>
						// since a wave might be currently in use. <p lpFreeHandle> is a 
						// pointer to a callback
						// function which will be called when the memory is no longer in use.
	HANDLE hUserData)	// Pointer to user data, passed as a parameter to the 
						// <p lpFreeHandle> function, typically used so the callback routine can retrieve
						// its state.
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	::EnterCriticalSection(&m_CriticalSection);
	if (m_pSynth)
	{
		hr = m_pSynth->Unload(hDownload, lpFreeHandle, hUserData);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CUserModeSynth::PlayBuffer(
	REFERENCE_TIME rt,	// Start time of the buffer. This should be in 
						// REFERENCE_TIME units, relative to the master
						// clock, previously set with a call to <om IDirectMusicSynth::SetMasterClock>.
						// And, this should be after the time returned by the clock in 
						// <om IDirectMusicSynth::GetLatencyClock>.
	LPBYTE pbBuffer,	// Memory chunk with all the MIDI events, generated by <i IDirectMusicBuffer>.
	DWORD cbBuffer)		// Size of buffer.
{
	class MIDIEVENT : public DMUS_EVENTHEADER {
	public:
		 BYTE  abEvent[4];           
	};

	typedef class MIDIEVENT FAR  *LPMIDIEVENT;
	#define QWORD_ALIGN(x) (((x) + 7) & ~7)

	HRESULT hr;

    V_INAME(IDirectMusicSynth::PlayBuffer);
    V_BUFPTR_READ(pbBuffer,cbBuffer);

	::EnterCriticalSection(&m_CriticalSection);

    LPMIDIEVENT lpEventHdr;
    DWORD cbEvent;

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMUS_EVENTHEADER))
        {
            Trace(1,"Error: PlayBuffer called with error in buffer size.\n");
			::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        lpEventHdr = (LPMIDIEVENT)pbBuffer; 
        cbEvent = DMUS_EVENT_SIZE(lpEventHdr->cbEvent);
        if (cbEvent > cbBuffer)
        {
            Trace(1,"Error: PlayBuffer called with error in event size.\n");
			::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }
        
        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
		{
			hr = m_pSynth->PlayBuffer(rt + lpEventHdr->rtDelta, 
									  &lpEventHdr->abEvent[0],
									  lpEventHdr->cbEvent,
									  lpEventHdr->dwChannelGroup);
		}

        if (FAILED(hr))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}
*/


STDMETHODIMP CUserModeSynth::GetMasterClock(
	IReferenceClock **ppClock)	// Pointer to master <i IReferenceClock>, 
								// used by all devices in current instance of DirectMusic.

{
    return m_MasterClock.QueryInterface(IID_IReferenceClock,(void **) ppClock);
}

STDMETHODIMP CUserModeSynth::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->SetChannelPriority(dwChannelGroup,dwChannel,dwPriority);
    }
    Trace(1,"Error: Synth not initialized.\n");
    return E_FAIL;
}

STDMETHODIMP CUserModeSynth::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->GetChannelPriority(dwChannelGroup,dwChannel,pdwPriority);
    }
    Trace(1,"Error: Synth not initialized.\n");
    return E_FAIL;
}

static DWORD dwPropFalse = FALSE;
static DWORD dwPropTrue  = TRUE;
static DWORD dwSystemMemory = DMUS_PC_SYSTEMMEMORY;

GENERICPROPERTY CUserModeSynth::m_aProperty[] = 
{      
    { 
        &GUID_DMUS_PROP_GM_Hardware,		// Set
        0,                                  // Item
        KSPROPERTY_SUPPORT_GET,             // KS support flags
        GENPROP_F_STATIC,                   // GENPROP flags
        &dwPropFalse, sizeof(dwPropFalse),  // static data and size
        NULL                                // Handler
    },
    {   &GUID_DMUS_PROP_GS_Hardware,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse), 
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Hardware,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Capable,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_GS_Capable,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_INSTRUMENT2,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    { 
        &GUID_DMUS_PROP_DLS1,				
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    { 
        &GUID_DMUS_PROP_DLS2,				
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    { 
        &GUID_DMUS_PROP_SampleMemorySize,				
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwSystemMemory,  sizeof(dwSystemMemory),
        NULL
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetBoost
    },
};

const int CUserModeSynth::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

HRESULT CUserModeSynth::HandleSetBoost(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG)) 
    {
        return E_INVALIDARG;
    }

    m_lBoost =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

// 
// CDirectMusicEmulatePort::FindPropertyItem
//                         
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CUserModeSynth::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;



    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CUserModeSynth::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
            break;
            
        case KSPROPERTY_TYPE_SET:
            V_BUFPTR_READ(pvPropertyData, ulDataLength);
            break;
            
        case KSPROPERTY_TYPE_BASICSUPPORT:
            V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
            break;
    }

    
    V_PTR_WRITE(pulBytesReturned, ULONG);    

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        Trace(2,"Warning: KsProperty call requested unknown property.\n");
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                Trace(1,"Error: SynthSink does not support Get for the requested property.\n");
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            if (pvPropertyData != NULL)
            {
                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            }
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                Trace(1,"Error: SynthSink does not support Set for the requested property.\n");
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                Trace(1,"Error: Synth does not provide support for requested property type.\n");
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                Trace(1,"Error: Data size for property is too small.\n");
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(1, "Error: KSProperty Flags must contain one of: %s\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CUserModeSynth::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CUserModeSynth::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectMusicSynthX

STDMETHODIMP CUserModeSynth::PlayWave(REFERENCE_TIME rt, 
                                      DWORD dwChannelGroup, 
                                      DWORD dwChannel, 
                                      PREL prPitch, 
                                      VREL vrVolume, 
                                      SAMPLE_TIME stVoiceStart, 
                                      SAMPLE_TIME stLoopStart, 
                                      SAMPLE_TIME stLoopEnd,
                                      IDirectSoundWave *pIWave,
                                      DWORD *pdwVoiceID)
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->PlayWave(rt,dwChannelGroup, 
								 dwChannel,
								 vrVolume,
								 prPitch,
								 stVoiceStart,
								 stLoopStart,
								 stLoopEnd,
                                 pIWave,
                                 pdwVoiceID);
    }
    else
    {
        Trace(1,"Error: Failed wave playback, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::StopWave(REFERENCE_TIME rt, DWORD dwVoiceId )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->StopWave(rt, 
								 dwVoiceId); 
    }
    else
    {
        Trace(1,"Error: Failed stop of wave playback, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

/*STDMETHODIMP CUserModeSynth::GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] )
{
	V_INAME(IDirectMusicSynth::GetVoiceState);
	V_PTR_READ(dwVoice,sizeof(DWORD)*cbVoice);

	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {

        hr = m_pSynth->GetVoiceState(dwVoice, 
								     cbVoice, 
									 VoiceState);

    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

STDMETHODIMP CUserModeSynth::Refresh(DWORD dwDownloadID, DWORD dwFlags )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Refresh(dwDownloadID, 
							   dwFlags);
    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

#ifdef XBOX
STDMETHODIMP CUserModeSynth::IsReadyForData(DWORD dwDownloadId)
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->IsReadyForData(dwDownloadId);
    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}
#endif
*/

#ifndef XBOX
STDMETHODIMP CUserModeSynth::AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
	hr = m_pSynth->AssignChannelToBuses(dwChannelGroup, 
									     dwChannel, 
						                 pdwBuses, 
						                 cBuses);
	}
    else
    {
        Trace(1,"Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}                                           
#else
STDMETHODIMP CUserModeSynth::AssignChannelToOutput(DWORD dwChannelGroup, DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers  )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
	hr = m_pSynth->AssignChannelToOutput(dwChannelGroup, 
									     dwChannel, 
						                 pBuffer, 
						                 dwMixBins,
                                         pbControllers);
	}
    else
    {
        Trace(1,"Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

    return hr;
} 

#endif
/////////////////////////////////////////////////////////////////////
// Implementation of IDirectSoundSource

/*STDMETHODIMP CUserModeSynth::SetSink(IDirectSoundConnect* pSinkConnect)
{
    V_INAME(IDirectSoundSink::SetSink);
    V_INTERFACE_OPT(pSinkConnect);

	HRESULT hr = S_OK;

	LPVOID ptr = NULL;
    V_BUFPTR_WRITE_OPT(ptr, 0);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>> RELEASE THE DSLINK IF PRESENT !!!!

// FIXME: The calls into the SynthSink8 may require the DSound DLL Mutex.  If the Sink
// is making a a call to READ then we end up in a deadlock.  We need to be sure that the
// Synth isn't playing when we do this.

	if (m_pSynthSink8)
	{
	    // FIXME: whoever called us->SetSink() should previously have called
	    // pOldSink->RemoveSource(us) - it shouldn't be our responsibility to
	    // do this call (??):
		// m_pSynthSink8->RemoveSource(this);
		m_pSynthSink8->Release();
        m_pSynthSink8 = NULL;
	}

	if (pSinkConnect)
	{
        // Obtain the IDirectSoundSynthSink interface on the sink
        hr = pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink, (void**)&m_pSynthSink8);

        if (SUCCEEDED(hr))
        {
    		//
    		// Get the sink's format and validate it
    		//
    		WAVEFORMATEX wfx;
    		DWORD dwSize = sizeof wfx;
    		hr = m_pSynthSink8->GetFormat(&wfx, dwSize, NULL);
    		if (SUCCEEDED(hr) && wfx.wBitsPerSample != 16 )
    		{
                Trace(1,"Error; Synth can not write to any format other than 16 bit PCM.\n");
    			hr = DMUS_E_WAVEFORMATNOTSUPPORTED;
    		}

    		if (SUCCEEDED(hr))
    		{
    			// Flag the buffer format to be non-interleaved 
    			m_dwChannels = 1;	// This synth with a sink is concidered a mono source.
    			m_dwBufferFlags = BUFFERFLAG_MULTIBUFFER;	

    			if (m_pSynth)	
    			{
    				// reset sample rate if it has changed 
    				if (wfx.nSamplesPerSec != (WORD)m_dwSampleRate)
    				{
//    					m_pSynth->SetSampleRate(wfx.nSamplesPerSec);
    				}

    			}
    		}
    	}
    }

    ::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

STDMETHODIMP CUserModeSynth::Seek(ULONGLONG sp)
{

	m_ullPosition = sp/2;	//Convert from bytes to samples 

    return S_OK;
}

STDMETHODIMP CUserModeSynth::Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD dwBufferCount, PULONGLONG pullLength )
{
	V_INAME(IDirectMusicSynth::Read);
	V_PTR_READ(ppvBuffer,sizeof(LPVOID)*dwBufferCount);
	V_PTR_READ(pdwIDs,sizeof(LPDWORD)*dwBufferCount);
	for ( DWORD i = 0; i < dwBufferCount; i++ )
	{
		V_BUFPTR_WRITE(ppvBuffer[i],(DWORD)*pullLength);
		if ( ppvBuffer[i] == NULL )
		{
            Trace(1,"Error: Read called with NULL buffer.\n");
			return E_INVALIDARG;
		}
	}

	if ( *pullLength > 0x00000000FFFFFFFF )	// can't read more than a DWORD's worth of data
	{
        Trace(1,"Error: Read called with invalid buffer length.\n");
		return E_INVALIDARG;
	}

	if ( dwBufferCount == 0 )				// don't read no buffers
	{
        Trace(4,"Warning: Read called with 0 buffers.\n");
		return E_INVALIDARG;
	}
	if (!m_pSynthSink8)
	{
        Trace(1,"Error: Synth is not configured, can not play.\n");
		return DMUS_E_SYNTHNOTCONFIGURED;
	}
    if (!m_fActive)
    {
        Trace(3,"Warning: Synth is not active, can not play.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);

	if (m_pSynth)
	{
		// Mix
		DWORD dwLength = (DWORD)(*pullLength)/2;	// Convert from bytes to number of samples. Synth assumes 16 bit
		m_pSynth->Mix((short**)ppvBuffer, pdwIDs, pdwFuncIDs, plPitchBends, dwBufferCount, m_dwBufferFlags, dwLength, m_ullPosition);

		// Increment current sample position in the audio stream
		m_ullPosition += dwLength; //*pullLength;
	}

    ::LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}

STDMETHODIMP CUserModeSynth::GetSize(PULONGLONG pcb)
{
    return E_NOTIMPL;
}
*/

CClock::CClock()

{
    m_pParent = NULL;
    m_dwLastPosition = 0;
    m_llSampleTime = 0;
}


STDMETHODIMP CClock::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CClock::AddRef()
{
    return m_pParent->AddRef();
}

STDMETHODIMP_(ULONG) CClock::Release()
{
    return m_pParent->Release();
}

STDMETHODIMP CClock::AdviseTime(REFERENCE_TIME ,REFERENCE_TIME,HANDLE,DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::AdvisePeriodic(REFERENCE_TIME,REFERENCE_TIME,HANDLE,DWORD * )
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::Unadvise( DWORD )
{
    return E_NOTIMPL;
}

EXTERN_C DWORD WINAPI DirectSoundGetSampleTime(void);

STDMETHODIMP CClock::GetTime(LPREFERENCE_TIME pTime)
{
    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

	EnterCriticalSection( &m_pParent->m_CriticalSection );

    DWORD dwPosition = DirectSoundGetSampleTime();

    // Check to see if we looped around, which happens every 24 hours

    LONGLONG delta;
    if(dwPosition < m_dwLastPosition){
        // This is either a loop, or a dsound bug

        if(dwPosition < 100000 && m_dwLastPosition > (1 << 30) ){
            Trace(-1, "CClock::GetTime sample time wrapped (as it should every 24 hours. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = ((((LONGLONG) 1) << 32) + dwPosition) - m_dwLastPosition;
        }
        else {
            Trace(-1, "CClock::GetTime stream position decreased unexpectedly. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = 0; // Ignore.
            m_dwLastPosition = dwPosition; // Catch up. (Sometimes DSound resets the stream on us.)
        }
    }
    else {
        delta = dwPosition - m_dwLastPosition;
    }

    m_dwLastPosition = dwPosition;
    m_llSampleTime += delta;
    LONGLONG llTemp = m_llSampleTime * 10000;
	llTemp /= 48000;
	llTemp *= 1000;
    *pTime = llTemp;
	LeaveCriticalSection( &m_pParent->m_CriticalSection );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\voice.cpp ===
//      Voice.cpp
//      Copyright (c) 1996-1999 Microsoft Corporation
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#include <math.h>
#include "muldiv32.h"
#else
#include "debug.h"
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include <math.h>
#include <stdio.h>
#include "csynth.h"
#endif
#include "fparms.h" // Generated filter parameter arrays
#include "validate.h"
#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

#ifdef XBOX
#include "..\dmime\cmixbins.h"
#endif

#ifdef XMIX

static REFERENCE_TIME STimeToSeqTime(STIME stTime){
    // stTime is in sample time - 48000 units per second
    // REFERENCE_TIME is in NT system time = 10,000,000 per second
    REFERENCE_TIME result = stTime;
    result = result * 10000000 / 48000;
    return result;
}

#endif

PFRACT CDigitalAudio::m_spfCents[201];
PFRACT CDigitalAudio::m_spfSemiTones[97];
VFRACT CDigitalAudio::m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1];

void CDigitalAudio::Init()
{
    double flTemp;
    VREL    vrdB;

    for (vrdB = MINDB * 10;vrdB <= MAXDB * 10;vrdB++)
    {
        flTemp = vrdB;
        flTemp /= 100.0;
        flTemp = pow(10.0,flTemp);
        flTemp = pow(flTemp,0.5);   // square root.
        flTemp *= 4095.0; // 2^12th, but avoid overflow...
        m_svfDbToVolume[vrdB - (MINDB * 10)] = (long) flTemp;
    }

    PREL prRatio;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }
    
    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}

VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;

    if (vrVolume < MINDB * 10) 
        vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10) 
        vrVolume = MAXDB * 10;

    return (m_svfDbToVolume[vrVolume - MINDB * 10]);
}

PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}


CVoice::CVoice()
{
    m_pBuffer = NULL;
    m_pDLSWave = NULL;
    m_pWave = NULL;
    memset(&m_WaveFormat, 0, sizeof(m_WaveFormat));
    m_pStream = NULL;
    memset(m_dwPacketIndex,0,sizeof(m_dwPacketIndex));
    memset(m_pvBuffer,0,sizeof(m_pvBuffer));
    m_dwBufferSize = 0;
    m_wCurrentPacket = 0;
    m_wPacketsSubmitted = 0;
    m_pControl = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_rtStartTime = 0;
    m_rtStopTime = 0x7fffffffffffffff;
    m_fAllowOverlap = FALSE;
    m_pRegion = NULL;
    m_dwLoopType = 0;
}


CVoice::~CVoice()
{
    ClearVoice();
}

void CVoice::Init()
{
    static BOOL fBeenHereBefore = FALSE;
    if (fBeenHereBefore) return;
    fBeenHereBefore = TRUE;
    CDigitalAudio::Init();
}

LPDIRECTSOUNDSEQUENCER CVoice::GetSequencer()
{
    return m_pSynth->GetSequencer();
}

void CVoice::StopVoice(REFERENCE_TIME rtTime)
{
    if (m_fNoteOn)
    {
        m_dwGroup = 0;
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_rtStopTime = rtTime;
        if(m_pBuffer)
        {
            DWORD dwFlags = DSBSTOPEX_ENVELOPE;
            if (m_dwLoopType == WLOOP_TYPE_RELEASE)
            {
                dwFlags |= DSBSTOPEX_RELEASEWAVEFORM;
            }
            HRESULT hr = m_pBuffer->StopEx(rtTime,dwFlags);
            if(FAILED(hr) && rtTime)
            { 
                // If we ran out of memory, try to stop immediately to avoid a stuck-on note.
                m_pBuffer->StopEx(0,dwFlags);
            }
        }
        else 
        {
            StopStream(rtTime);
        }
    }
}

void CVoice::QuickStopVoice(REFERENCE_TIME rtTime)
{
    m_fSustainOn = FALSE;
    m_rtStopTime = rtTime;
    m_dwGroup = 0;
    if (m_pBuffer)
    {
        // Only kill the sound if it is on. We currently get a click if we try to call StopEx() a second time.
        if (m_fNoteOn) 
        {
            m_pBuffer->ClearAtOrAfter(rtTime);
            // Wave already has a release time of 1.
            if (!m_fWave) 
            {
                m_Articulation.m_VolumeEG.m_Registers.dwRelease = 1;
                m_pBuffer->SetEG(rtTime, &m_Articulation.m_VolumeEG.m_Registers);
            }
            if (FAILED(m_pBuffer->StopEx(rtTime,DSBSTOPEX_ENVELOPE)))
            {
                m_pBuffer->StopEx(0,DSBSTOPEX_ENVELOPE);
            }
        }
        else
        // If the sound is already in the release phase, hack to fade it out by hand.
        {
            if (!m_fTag)
            {
                m_pBuffer->ClearAtOrAfter(rtTime);
            }
            for (DWORD dwI = 0; dwI < 4; dwI++)
            {
                m_vrStartVolume -= 1200; // Drop the volume 12dB.
                SendVolume(rtTime);
                rtTime += 10000;    // Increment forward 1 ms. 
            }
        }
    }
    else
    {
        StopStream(rtTime);
    }
    m_fTag = TRUE;
    m_fNoteOn = FALSE;
}

void CVoice::StopStream(REFERENCE_TIME rtTime)
{
    ClearVoice();
//    if(m_pStream)
//    {
        // Unfortunately, we need to wait until after the Flush is processed so we can
        // release our buffer data. So we ignore the rtTime argument and stop immediately.

//        m_pStream->Clear();  // Remove any queued commands
//        m_pStream->Flush(0); // Stop audio, set status of pending packets to Flushed.
        DirectSoundDoWork(); // So the packet status gets updated.

//        ProcessCompletedPackets(TRUE); // Releases packets.

//        m_pStream->Release();

//        m_pStream = NULL;
//        m_fInUse = false;
//    }
}


HRESULT CVoice::AllocateBuffer(XBOXADPCMWAVEFORMAT* pwfxFormat)
{
    HRESULT hr = S_OK;

    if(m_pBuffer && !(pwfxFormat->wfx.cbSize == m_WaveFormat.wfx.cbSize
        && pwfxFormat->wfx.nAvgBytesPerSec == m_WaveFormat.wfx.nAvgBytesPerSec
        && pwfxFormat->wfx.nBlockAlign == m_WaveFormat.wfx.nBlockAlign
        && pwfxFormat->wfx.nChannels == m_WaveFormat.wfx.nChannels
        && pwfxFormat->wfx.nSamplesPerSec == m_WaveFormat.wfx.nSamplesPerSec
        && pwfxFormat->wfx.wBitsPerSample == m_WaveFormat.wfx.wBitsPerSample
        && pwfxFormat->wfx.wFormatTag == m_WaveFormat.wfx.wFormatTag))
    {
        hr = m_pBuffer->SetFormat(0, &pwfxFormat->wfx);

        if (SUCCEEDED(hr))
        {
            m_WaveFormat = *pwfxFormat;
        }
        else
        {
            DbgPrint("Failed to set buffer format!\n");

            m_pBuffer->Release();
            m_pBuffer = 0;
            memset(&m_WaveFormat, 0, sizeof(m_WaveFormat));
        }
    }
    if(!m_pBuffer)
    {
        m_WaveFormat = *pwfxFormat;
        DSBUFFERDESC dsbd;
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.lpwfxFormat = &m_WaveFormat.wfx;
        dsbd.dwFlags = DSBCAPS_CTRLFREQUENCY
            | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPOSITIONNOTIFY;
        hr = GetSequencer()->CreateBuffer(&dsbd, &m_pBuffer);
        if (FAILED(hr))
        {
            DbgPrint("Failed buffer creation!\n");
        }
    }
    return hr;
}

// Convert from frequency ratio to PREL.

__inline long RatioToPREL(float flRatio)
{
    const float             fl4096  = 1200.0f;
    long                    lPitch;

    __asm 
    {
        fld     fl4096
        fld     flRatio
        fyl2x
        fistp   lPitch
    }

    return lPitch;
}

void CVoice::SendPitch(REFERENCE_TIME rtTime)

{
    PREL prPitch;
    m_pPart->GetPitch(&prPitch);
    prPitch += m_prStartPitch;
    if (prPitch != m_prLastPitch)
    {
        m_prLastPitch = prPitch;
        // Convert from PREL format (1200 per octave) to NVidia (4096 per octave.)
        prPitch = (prPitch * 1024) + 512;
        prPitch /= 300;

        if(prPitch < DSBPITCH_MIN){
            Trace(3,"Clamping pitch to DSBPITCH_MIN\n");
            prPitch = DSBPITCH_MIN;
        }
        if(prPitch > DSBPITCH_MAX){
            Trace(3,"Clamping pitch to DSBPITCH_MAX\n");
            prPitch = DSBPITCH_MAX;
        }

        if (m_fStreamed)
        {
            if (m_pStream)
            {
                m_pStream->SetPitch(rtTime,prPitch);
            }
        }
        else
        {
            if (m_pBuffer)
            {
                m_pBuffer->SetPitch(rtTime,prPitch);
            }
        }
    }
}

void CVoice::SendLFOs(REFERENCE_TIME rtTime)

{
    long lPressure, lModWheel;
    m_pPart->GetPressure((DWORD *) &lPressure);
    m_pPart->GetModWheel((DWORD *) &lModWheel);

    // First, take the control pressure to pitch parameter and scale by control pressure.
    VREL vrTemp = (lPressure * m_Articulation.m_LFO.m_prCPPitchScale) / 127;
    // Then, add mod wheel to pitch parameter and scale it.
    vrTemp += (lModWheel * m_Articulation.m_LFO.m_prMWPitchScale) / 127;
    // Then, add to the default pitch control.
    vrTemp += m_Articulation.m_LFO.m_prPitchScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 614400;   // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO.m_Registers.lPitchModulation = vrTemp;

    // Now, do the same for LF02, which only does vibrato.
    vrTemp = (lPressure * m_Articulation.m_LFO2.m_prCPPitchScale) / 127;
    vrTemp += (lModWheel * m_Articulation.m_LFO2.m_prMWPitchScale) / 127;
    vrTemp += m_Articulation.m_LFO2.m_prPitchScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 614400;   // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO2.m_Registers.lPitchModulation = vrTemp;

    // Do the same for volume on first LFO. 
    vrTemp = (lPressure * m_Articulation.m_LFO.m_vrCPVolumeScale) / 127;
    vrTemp += (lModWheel * m_Articulation.m_LFO.m_vrMWVolumeScale) / 127;
    vrTemp += m_Articulation.m_LFO.m_vrVolumeScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 38400;    // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO.m_Registers.lAmplitudeModulation = vrTemp;

    // And, filter on the the first LFO.
    vrTemp = (lPressure * m_Articulation.m_LFO.m_prCPCutoffScale) / 127;
    vrTemp += (lModWheel * m_Articulation.m_LFO.m_prMWCutoffScale) / 127;
    vrTemp += m_Articulation.m_LFO.m_prCutoffScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 4915200;  // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO.m_Registers.lFilterCutOffRange = vrTemp;

    if (m_pBuffer)
    {
        m_pBuffer->SetLFO(rtTime, &m_Articulation.m_LFO.m_Registers);
        m_pBuffer->SetLFO(rtTime, &m_Articulation.m_LFO2.m_Registers);
    }
    else if (m_pStream)
    {
        m_pStream->SetLFO(rtTime, &m_Articulation.m_LFO.m_Registers);
        m_pStream->SetLFO(rtTime, &m_Articulation.m_LFO2.m_Registers);
    }
}

unsigned short g_nFilter[128] = {
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8020, 0x819d, 0x8303, 0x8455, 0x8595, 0x8756,
    0x886f, 0x89fe, 0x8af9, 0x8c5f, 0x8e1e, 0x8f57, 0x9081, 0x91f9,
    0x935a, 0x94a7, 0x95e2, 0x9756, 0x98b3, 0x99fe, 0x9b36, 0x9c99,
    0x9e1e, 0x9f57, 0xa0b2, 0xa1f9, 0xa35a, 0xa4a7, 0xa608, 0xa756,
    0xa8b3, 0xa9fe, 0xab55, 0xacb6, 0xae1d, 0xaf57, 0xb0b1, 0xb20f,
    0xb36f, 0xb4bb, 0xb61b, 0xb767, 0xb8c4, 0xba0d, 0xbb63, 0xbcc3,
    0xbe1d, 0xbf70, 0xc0bd, 0xc21a, 0xc36e, 0xc4c4, 0xc61a, 0xc76f,
    0xc8c2, 0xca13, 0xcb69, 0xccc1, 0xce1a, 0xcf6d, 0xd0c0, 0xd216,
    0xd36a, 0xd4bf, 0xd615, 0xd769, 0xd8bc, 0xda10, 0xdb65, 0xdcbc,
    0xde11, 0xdf62, 0xe0b6, 0xe208, 0xe35d, 0xe4b0, 0xe601, 0xe753,
    0xe8a6, 0xe9f7, 0xeb48, 0xec99, 0xede9, 0xef36, 0xf085, 0xf1d2,
    0xf31f, 0xf46a, 0xf5b4, 0xf6fc, 0xf842, 0xf988, 0xfacb, 0xfc0c,
    0xfd4b, 0xfe85, 0xffbe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
};

static unsigned short CalcCutOff(PREL prPitch)

{
    prPitch += 6400;
    if (prPitch < 0) prPitch = 0;
    if (prPitch > 12700) prPitch = 12700;
    long lIndex = prPitch / 100;
    long lTemp = g_nFilter[lIndex] + 
        ((prPitch % 100) * (g_nFilter[lIndex+1] - g_nFilter[lIndex])) / 100;
    return (short) lTemp;
}

unsigned short g_nResonance[23] = {
    0x8000, 0x7214, 0x65ac, 0x5a9d, 0x50c3, 0x47fa, 0x4026, 0x392c,
    0x32f5, 0x2d6a, 0x287a, 0x2413, 0x2026, 0x1ca7, 0x198a, 0x16c3,
    0x1449, 0x1214, 0x101d, 0xe5c, 0xccc, 0xb68, 0xa2a,
};


static unsigned short CalcResonance(DWORD dwQ)

{
    if (dwQ > 22) dwQ = 22;
    return g_nResonance[dwQ];
}

/* Code to generate the tables:

#include "stdafx.h"
#include "stdio.h"
#include "math.h"

long m_spfCents[201];
long m_spfSemiTones[97];

void Init()
{
    long prRatio;
    double flTemp;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }
    
    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}

long PRELToPFRACT(long prPitch)
{
    long pfPitch = 0;
    long prOctave;
    if (prPitch > 100)
    {
//        if (prPitch > 4800)
//        {
//            prPitch = 4800;
//        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
//        if (prPitch < -4800)
//        {
//            prPitch = -4800;
//        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}


unsigned long FreqToHardwareCoeff( float fFreq )
{
    float fNormCutoff = fFreq / 48000.0f;

    // Filter is ineffective out of these ranges, so why
    // bother even trying?
    if( fFreq < 30.0f )
        return 0x8000;
    if( fFreq > 8000.0f )
        return 0xffff;

    double fFC = float( 2.0f * sin( 3.1415926535897932384626433832795 * fNormCutoff ) );
    fFC = 4096.0f * log( fFC ) / log( 2.0f );
    long lOctaves = (long) fFC;

    return (unsigned long)lOctaves & 0xFFFF;
}

unsigned long dBToHardwareCoeff( long lResonance )
{
    float fResonance = (float)lResonance;

    if( fResonance > 22.5f )
        fResonance = 22.5f;

    double fQ = pow( 10.0, -0.05*fResonance);
    unsigned int dwQ = (unsigned int)(fQ*(1<<15));
    if( dwQ > 0xFFFF )
        dwQ = 0xFFFF;

    return (unsigned long)dwQ;
}

void GenerateQ()

{
    printf("short g_nResonance[23] = {\n    ");
    long dwIndent = 0;
    float flResonance;
    for (flResonance = 0; flResonance < 23; flResonance++)
    {
        if (dwIndent == 8)
        {
            printf("\n    ");
            dwIndent = 0;
        }
        dwIndent++;
        unsigned int pQ = dBToHardwareCoeff((long)flResonance);
        printf("0x%lx, ",(long)pQ);
    }
    printf("\n};\n");
}

void GenerateCutoff()

{
    Init();
    printf("short g_nFilter[128] = {\n    ");
    unsigned long dwIndent = 0;
    long prFilter;
    for (prFilter = (-64 * 100); prFilter < (64 * 100); prFilter += 100)
    {
        if (dwIndent == 8)
        {
            printf("\n    ");
            dwIndent = 0;
        }
        dwIndent++;
        // Now, we need to convert to a real frequency. The PREL values are relative
        // to A440, so get the sample rate by multiplying this relative pitch against 440Hz.
        unsigned long dwSampleRate = PRELToPFRACT(prFilter); 
        dwSampleRate = (440 * dwSampleRate) >> 12;
        unsigned int pF, pQ;
        pF = FreqToHardwareCoeff((float) dwSampleRate);
        char output[100];
        printf("0x%x, ",(long)pF);
    }
    printf("\n};\n");
}




int main(int argc, char* argv[])
{
	GenerateCutoff();
    GenerateQ();
	return 0;
}

*/

void CVoice::SendFilter(REFERENCE_TIME rtTime,BOOL fStart)

{
    DSFILTERDESC FilterDesc;
    // If this is a wave or DLS instrument that doesn't use filter, turn off filter if this
    // is the start.
    if (m_fUseFilter)
    {
        PREL prFilter;
        m_pPart->GetFilter(&prFilter);
        prFilter += m_prStartFilter;
        if (abs(prFilter - m_prLastFilter) >= 50)
        {
            DSFILTERDESC FilterDesc;
            FilterDesc.dwMode = DSFILTER_MODE_DLS2;
            FilterDesc.adwCoefficients[0] = CalcCutOff(prFilter-6900);
            FilterDesc.adwCoefficients[1] = CalcResonance(m_wFilterQ);
            FilterDesc.adwCoefficients[2] = 0;
            FilterDesc.adwCoefficients[3] = 0;
            FilterDesc.dwQCoefficient = 0;
            m_prLastFilter = prFilter;
            if (m_pBuffer)
            {
                m_pBuffer->SetFilter(rtTime,&FilterDesc);
            }
            else if (m_pStream)
            {
                m_pStream->SetFilter(rtTime,&FilterDesc);
            }
        }
        else
        {
            if (fStart)
            {
                m_prLastFilter = 0;
                FilterDesc.dwMode = DSFILTER_MODE_BYPASS;
                FilterDesc.adwCoefficients[0] = 0;
                FilterDesc.adwCoefficients[1] = 0;
                FilterDesc.adwCoefficients[2] = 0;
                FilterDesc.adwCoefficients[3] = 0;
                FilterDesc.dwQCoefficient = 0;
                if (m_pBuffer)
                {
                    m_pBuffer->SetFilter(rtTime,&FilterDesc);
                }
                else if (m_pStream)
                {
                    m_pStream->SetFilter(rtTime,&FilterDesc);
                }
            }
        }
/*      Testing parametric eq...
        // Now, we need to convert to a real frequency. The PREL values are relative
        // to A440, so get the samplerate by multiplying this relative pitch against 440Hz.
        static double fSampleRate = 100;
        fSampleRate *= 1.1;
        if (fSampleRate > 14000) fSampleRate = 50;
        FilterDesc.dwMode = DSFILTER_MODE_PARAMEQ;
        unsigned int pF, pQ;
        DlsToChamberlin(fSampleRate,10,&pF,&pQ);
        FilterDesc.adwCoefficients[0] = 1;
        FilterDesc.adwCoefficients[1] = 1;
        FilterDesc.adwCoefficients[2] = pF;
        FilterDesc.adwCoefficients[3] = pQ;
        FilterDesc.dwQCoefficient = 3;
        m_pBuffer->SetFilter(rtTime,&FilterDesc);*/

    }
}

void CVoice::SendVolume(REFERENCE_TIME rtTime)

{
    BOOL fBuffer = (m_pBuffer && !m_fStreamed);
    if (fBuffer || (m_fStreamed && m_pStream))
    {
        if (m_BusIds.HasBuffer())
        {
            // If we are sending to a buffer, then we just call SetVolume since there are no mixbins.
            VREL vrVolume;
            m_pPart->GetVolume(m_vrStartVolume,0,&vrVolume,NULL,NULL,NULL,NULL);
            CLAMP_VOLUME(vrVolume);
            if (abs(vrVolume - m_vrLastVolumes[0]) >= 10)
            {
                if (fBuffer)
                {
                    m_pBuffer->SetVolume(rtTime,vrVolume);
                }
                else 
                {
                    m_pStream->SetVolume(rtTime,vrVolume);
                }
                m_vrLastVolumes[0] = vrVolume;
            }
        }
        else if (m_BusIds.m_bControllers[0]) // Is this a multi-mixbin buffer?
        { 
            VREL vrVolumes[8];
            BOOL fChanged = false;
            m_pPart->GetVolume(m_vrStartVolume,m_BusIds.m_bControllers,vrVolumes);
            for (DWORD dwX = 0; m_BusIds.m_bControllers[dwX];dwX++)
            {
                CLAMP_VOLUME(vrVolumes[dwX]);
                if (abs(vrVolumes[dwX] - m_vrLastVolumes[dwX]) >= 10)
                {
                    m_vrLastVolumes[dwX] = vrVolumes[dwX];
                    fChanged = true;
                }
            }
            if (fChanged)
            {
                CMIXBINS MixBins;
                MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
                MixBins.PokeMixBinVolumesBasedOnMask(m_BusIds.m_dwMixBins, (long *)vrVolumes);
                if (fBuffer)
                {
                    m_pBuffer->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                else 
                {
                    m_pStream->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
            }
        } 
        else if ((m_BusIds.m_dwMixBins & ((1 << DSMIXBIN_FRONT_LEFT) | (1 << DSMIXBIN_FRONT_RIGHT))) == 
                ((1 << DSMIXBIN_FRONT_LEFT) | (1 << DSMIXBIN_FRONT_RIGHT)))
        {
            VREL vrVolumes[4];
            m_pPart->GetVolume(m_vrStartVolume,m_lDefaultPan,NULL,&vrVolumes[0],&vrVolumes[1],&vrVolumes[2],&vrVolumes[3]);
            CLAMP_VOLUME(vrVolumes[0]);
            CLAMP_VOLUME(vrVolumes[1]);
            CLAMP_VOLUME(vrVolumes[2]);
            CLAMP_VOLUME(vrVolumes[3]);
            if ((abs(vrVolumes[0] - m_vrLastVolumes[0]) >= 10) ||
                (abs(vrVolumes[1] - m_vrLastVolumes[1]) >= 10) ||
                (abs(vrVolumes[2] - m_vrLastVolumes[2]) >= 10) ||
                (abs(vrVolumes[3] - m_vrLastVolumes[3]) >= 10))
            {
                CMIXBINS MixBins;
                MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
                MixBins.PokeMixBinVolumesBasedOnMask(m_BusIds.m_dwMixBins, vrVolumes);                
                if (fBuffer)
                {
                    m_pBuffer->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                else 
                {
                    m_pStream->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                m_vrLastVolumes[0] = vrVolumes[0];
                m_vrLastVolumes[1] = vrVolumes[1];
                m_vrLastVolumes[2] = vrVolumes[2];
                m_vrLastVolumes[3] = vrVolumes[3];
            }
        }   
        // Then, the case of the one side of a stereo wave
        else 
        {
            VREL vrVolumes[3];
            m_pPart->GetVolume(m_vrStartVolume,m_lDefaultPan,&vrVolumes[0],NULL,NULL,&vrVolumes[1],&vrVolumes[2]);
            CLAMP_VOLUME(vrVolumes[0]);
            CLAMP_VOLUME(vrVolumes[1]);
            CLAMP_VOLUME(vrVolumes[2]);
            if ((abs(vrVolumes[0] - m_vrLastVolumes[0]) >= 10) ||
                (abs(vrVolumes[1] - m_vrLastVolumes[1]) >= 10) ||
                (abs(vrVolumes[2] - m_vrLastVolumes[2]) >= 10))
            {
                CMIXBINS MixBins;
                MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
                MixBins.PokeMixBinVolumesBasedOnMask(m_BusIds.m_dwMixBins, (long *)vrVolumes);
                if (fBuffer)
                {
                    m_pBuffer->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                else
                {
                    m_pStream->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                m_vrLastVolumes[0] = vrVolumes[0];
                m_vrLastVolumes[1] = vrVolumes[1];
                m_vrLastVolumes[2] = vrVolumes[2];
            }
        }      
    }
}

BOOL CVoice::StartVoice(CSynth *pSynth,
                        CSourceRegion *pRegion, REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        WORD nKey,WORD nVelocity,
                        VREL vrVolume,
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch)
{
    m_pSynth = pSynth;  
    m_fWave = FALSE;
    m_fStreamed = FALSE;
    m_BusIds = *pBusIds;
    
    memset(&m_vrLastVolumes[0],0,sizeof(VREL)*8);
    m_prLastPitch = m_prLastFilter = 0;
    if (pRegion->m_pArticulation == NULL)
    {
        return FALSE;
    }

    // If this is multichannel, that means this is a component of a larger wave. 
    // So, force it to play on the appropriate channel.
    if (!m_BusIds.HasBuffer() && pRegion->IsMultiChannel())
    {
        if (pRegion->m_dwChannel & WAVELINK_CHANNEL_RIGHT)
        {
            // Right side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_LEFT);
        }
        else
        {
            // Left side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_RIGHT);
        }
    }


    m_Articulation = *pRegion->m_pArticulation;
    m_dwLoopType = pRegion->m_Sample.m_dwLoopType;

    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    m_vrStartVolume = VelocityToVolume(nVelocity);

    m_vrStartVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = m_Articulation.m_sDefaultPan;
  
    // Now, scale the attack, hold, and decay times as appropriate by the velocity and midi note.
    m_Articulation.m_VolumeEG.m_Registers.dwAttack *= 
        CDigitalAudio::PRELToPFRACT(nVelocity * m_Articulation.m_VolumeEG.m_trVelAttackScale / 127);
    m_Articulation.m_VolumeEG.m_Registers.dwAttack /= 4096;
    FORCEBOUNDS(m_Articulation.m_VolumeEG.m_Registers.dwAttack,0,3750);

    m_Articulation.m_PitchEG.m_Registers.dwAttack *= 
        CDigitalAudio::PRELToPFRACT(nVelocity * m_Articulation.m_PitchEG.m_trVelAttackScale / 127);
    m_Articulation.m_PitchEG.m_Registers.dwAttack /= 4096;
    FORCEBOUNDS(m_Articulation.m_PitchEG.m_Registers.dwAttack,0,3750);

    m_Articulation.m_VolumeEG.m_Registers.dwHold  *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_VolumeEG.m_trKeyDecayScale / 127);
    m_Articulation.m_VolumeEG.m_Registers.dwHold  /= 4096;
    FORCEBOUNDS(m_Articulation.m_VolumeEG.m_Registers.dwHold,0,3750);

    m_Articulation.m_PitchEG.m_Registers.dwHold  *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_PitchEG.m_trKeyDecayScale / 127);
    m_Articulation.m_PitchEG.m_Registers.dwHold  /= 4096;
    FORCEBOUNDS(m_Articulation.m_PitchEG.m_Registers.dwHold,0,3750);

    m_Articulation.m_VolumeEG.m_Registers.dwDecay *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_VolumeEG.m_trKeyDecayScale / 127);
    m_Articulation.m_VolumeEG.m_Registers.dwDecay /= 4096;
    FORCEBOUNDS(m_Articulation.m_VolumeEG.m_Registers.dwDecay,0,3750);

    m_Articulation.m_PitchEG.m_Registers.dwDecay *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_PitchEG.m_trKeyDecayScale / 127);
    m_Articulation.m_PitchEG.m_Registers.dwDecay /= 4096;
    FORCEBOUNDS(m_Articulation.m_PitchEG.m_Registers.dwDecay,0,3750);

    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }

    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_fSustainOn = FALSE;
    m_rtStartTime = rtStartTime;
    m_rtStopTime = 0x7fffffffffffffff;
//    m_DigitalAudio.m_Source = pRegion->m_Sample;

    // save a reference to this wave so we can release our reference when the voice
    // stops playing
    pRegion->m_Sample.m_pWave->AddRef();

    //
    // if the dls wave we are about to associate with the voice
    // is different than the existing one, release our reference so we dont leak
    //

    if (m_pDLSWave && (pRegion->m_Sample.m_pWave != m_pDLSWave)) {
        m_pDLSWave->Release();
    }

    m_pDLSWave = pRegion->m_Sample.m_pWave;

//    m_pCurrentBuffer = 0;
//    m_DigitalAudio.m_pWaveArt = NULL;
    XBOXADPCMWAVEFORMAT *pWaveFormat = &pRegion->m_Sample.m_pWave->m_WaveFormat;

    if (SUCCEEDED(AllocateBuffer(pWaveFormat)))
    {
        DWORD dwSamplesPerBlock = 1;
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            dwSamplesPerBlock = 64;
        }
        // Now that we have a buffer, set the output.
        if (pBusIds->HasBuffer())
        {
            IDirectSoundBuffer* pBuffer = pBusIds->GetBuffer();
            m_pBuffer->SetOutputBuffer(0,pBuffer);
            pBuffer->Release();
        }
        else
        {
    //        Trace(-1,"%ld: Setting Mix Bins %lx on buffer %lx\n",(long) rtStartTime,pBusIds->m_dwMixBins,m_pBuffer);
            CMIXBINS MixBins;
            MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
            m_pBuffer->SetMixBins(0,MixBins.GetMixBins());
        }

        // Pitch to frequency

        prPitch += pRegion->m_prTuning;
        CSourceSample* pSample = &pRegion->m_Sample;
        long lKey = (long) nKey;
        prPitch += pSample->m_prFineTune;
        prPitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
        prPitch += RatioToPREL((float)pWaveFormat->wfx.nSamplesPerSec / (float) 48000);
        m_prStartPitch = prPitch;   // Store this as the base pitch.

        SendPitch(0);
        SendVolume(0);

        m_fUseFilter = (m_Articulation.m_Filter.m_prCutoff != 0x7FFF);
        m_prStartFilter = m_Articulation.m_Filter.m_prCutoff + 
            ((nVelocity * m_Articulation.m_Filter.m_prVelScale) / 127) + 
            ((nKey * m_Articulation.m_Filter.m_prKeyScale) / 127);
        m_wFilterQ = m_Articulation.m_Filter.m_vrQ / 10;
        SendFilter(0,TRUE);
        
        m_pBuffer->SetBufferData(0, pRegion->m_Sample.m_pWave->m_pnWave, pRegion->m_Sample.m_pWave->m_dwSampleDataSize);

        m_pBuffer->SetEG(0, &m_Articulation.m_VolumeEG.m_Registers);
        m_pBuffer->SetEG(0, &m_Articulation.m_PitchEG.m_Registers);

        SendLFOs(0);

        DWORD dwflag = 0;
        if(!pRegion->m_Sample.m_bOneShot)
        {
            // If there are loop points, convert to byte positions. 
            DWORD dwByteStart = (pRegion->m_Sample.m_dwLoopStart * pWaveFormat->wfx.nBlockAlign) / dwSamplesPerBlock;
            DWORD dwByteEnd = (pRegion->m_Sample.m_dwLoopEnd * pWaveFormat->wfx.nBlockAlign) / dwSamplesPerBlock;
            if(dwByteEnd > pRegion->m_Sample.m_pWave->m_dwSampleDataSize)
            {
                dwByteEnd = pRegion->m_Sample.m_pWave->m_dwSampleDataSize;
            }
            if (dwByteEnd > dwByteStart)
            {
                m_pBuffer->SetLoopRegion(0, dwByteStart, dwByteEnd - dwByteStart);
                dwflag = DSBPLAY_LOOPING;
            }
        }
    

        m_pBuffer->Play(rtStartTime, 0, 0, dwflag);
        return (TRUE);
    }
    return (FALSE);
}


BOOL CVoice::StartWave(CSynth *pSynth,
                       CSourceWave *pWave,
                       DWORD dwVoiceId,
                       REFERENCE_TIME rtStartTime,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       VREL vrMIDIVolume,
                       PREL prPitch,
                       PREL prMIDIPitch,
                       DWORD dwVoiceStart,
                       DWORD dwLoopStart,
                       DWORD dwLoopEnd
                       )
{
    m_pSynth = pSynth;
    m_fWave = TRUE;
    m_fStreamed = FALSE;
    m_BusIds = *pBusIds;
    memset(&m_vrLastVolumes[0],0,sizeof(VREL)*8);
    m_prLastPitch = m_prLastFilter = 0;
    m_Articulation = pWave->m_Articulation;

    // If this is multichannel, that means this is a component of a larger wave. 
    // So, force it to play on the appropriate channel.
/*    if (!m_BusIds.HasBuffer() && pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
    {
        if (pWaveArt->m_WaveArtDl.ulBus == 1)
        {
            // Right side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_LEFT);
        }
        else
        {
            // Left side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_RIGHT);
        }
    }*/

    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_rtStartTime = rtStartTime;
    m_rtStopTime = 0x7fffffffffffffff; 
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_fAllowOverlap = FALSE;    
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    pWave->m_bActive = TRUE;
    pWave->AddRef();
    m_pWave = pWave;

    if (SUCCEEDED(AllocateBuffer(&pWave->m_WaveFormat)))
    {

        // Now that we have a buffer, set the output.
        if (pBusIds->HasBuffer())
        {
            IDirectSoundBuffer* pBuffer = pBusIds->GetBuffer();
            m_pBuffer->SetOutputBuffer(0,pBuffer);
            pBuffer->Release();
        }
        else
        {
            CMIXBINS MixBins;
            MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
            m_pBuffer->SetMixBins(0,MixBins.GetMixBins());

        }

        prPitch += RatioToPREL((float)pWave->m_WaveFormat.wfx.nSamplesPerSec / (float) 48000);
        m_prStartPitch = prPitch;   // Store this as the base pitch.
        SendPitch(0);
        m_vrStartVolume = vrVolume;
        SendVolume(0);
        DWORD dwSampleLength = pWave->m_dwSampleCount;
        DWORD dwSamplesPerBlock = 1;
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            dwSamplesPerBlock = 64;
        }
        dwVoiceStart = (dwVoiceStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
        dwSampleLength = (dwSampleLength * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
        dwSampleLength -= dwVoiceStart;
        dwLoopEnd = (dwLoopEnd * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
        dwLoopStart = (dwLoopStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;

        m_pBuffer->SetBufferData(0, &pWave->m_pnWave[dwVoiceStart/2], dwSampleLength);

        m_fUseFilter = (m_Articulation.m_Filter.m_prCutoff != 0x7FFF);
        m_prStartFilter = m_Articulation.m_Filter.m_prCutoff;
        m_wFilterQ = m_Articulation.m_Filter.m_vrQ / 10;
        SendFilter(0,TRUE);
        
        m_pBuffer->SetEG(0, &m_Articulation.m_VolumeEG.m_Registers);
        m_pBuffer->SetEG(0, &m_Articulation.m_PitchEG.m_Registers);

        SendLFOs(0);

        DWORD dwflag = 0;
        if ((dwLoopEnd > dwVoiceStart) && (dwLoopStart >= dwVoiceStart))
        {
            dwLoopEnd -= dwVoiceStart;
            dwLoopStart -= dwVoiceStart;
            if(dwLoopEnd > dwSampleLength)
            {
                dwLoopEnd = dwSampleLength;
            }
            if (dwLoopEnd > dwLoopStart)
            {
                m_pBuffer->SetLoopRegion(rtStartTime, dwLoopStart, (dwLoopEnd - dwLoopStart));
                dwflag = DSBPLAY_LOOPING;
            }
        }
        m_pBuffer->Play(rtStartTime, 0, 0, dwflag);
        return (TRUE);
    }
    return (FALSE);
}

BOOL CVoice::StartStreamedWave(CSynth *pSynth,
                       CSourceWave *pWave,
                       DWORD dwVoiceId,
                       REFERENCE_TIME rtStartTime,
                       CBusIds * pBusIds,
                       VREL vrVolume, VREL vrMIDIVolume,
                       PREL prPitch, PREL prMIDIPitch,
                       DWORD dwVoiceStart,
                       DWORD dwLoopStart,
                       DWORD dwLoopEnd)
{
    m_pSynth = pSynth;
    m_fWave = TRUE;
    m_fStreamed = TRUE;
    m_BusIds = *pBusIds;
    memset(&m_vrLastVolumes[0],0,sizeof(VREL)*8);
    m_prLastPitch = m_prLastFilter = 0;
    m_Articulation = pWave->m_Articulation;

    // If this is multichannel, that means this is a component of a larger wave. 
    // So, force it to play on the appropriate channel.
/*    if (!m_BusIds.HasBuffer() && pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
    {
        if (pWaveArt->m_WaveArtDl.ulBus == 1)
        {
            // Right side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_LEFT);
        }
        else
        {
            // Left side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_RIGHT);
        }
    }*/


    // Initialize an envelope for wave playing 
    //

    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_rtStartTime = rtStartTime;
    m_rtStopTime = 0x7fffffffffffffff; 
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_fAllowOverlap = FALSE;    
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    if(m_pStream)
    {
        m_pStream->Release();
        m_pStream = 0;
    }
    
    DSSTREAMDESC dssd;

    ZeroMemory(&dssd, sizeof(dssd));
    
    dssd.dwFlags = DSSTREAMCAPS_CTRLFREQUENCY | DSSTREAMCAPS_CTRLVOLUME | DSSTREAMCAPS_ACCURATENOTIFY;
    dssd.dwMaxAttachedPackets = VOICE_NUM_PACKETS;
    dssd.lpwfxFormat = (LPWAVEFORMATEX) &pWave->m_WaveFormat;
    m_WaveFormat = pWave->m_WaveFormat;


    if (FAILED(GetSequencer()->CreateStream(&dssd, &m_pStream)))
    {
        return FALSE;
    }

    if (pBusIds->HasBuffer())
    {
        IDirectSoundBuffer* pBuffer = pBusIds->GetBuffer();
        m_pStream->SetOutputBuffer(0,pBuffer);
        pBuffer->Release();
    }
    else
    {
        CMIXBINS MixBins;
        MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
        m_pStream->SetMixBins(0,MixBins.GetMixBins());
    }

    prPitch += RatioToPREL((float)pWave->m_WaveFormat.wfx.nSamplesPerSec / (float) 48000);
    m_prStartPitch = prPitch;   // Store this as the base pitch.
    SendPitch(0);

    m_vrStartVolume = vrVolume;
    SendVolume(0);

    m_fUseFilter = (m_Articulation.m_Filter.m_prCutoff != 0x7FFF);
    m_prStartFilter = m_Articulation.m_Filter.m_prCutoff;
    m_wFilterQ = m_Articulation.m_Filter.m_vrQ / 10;
    SendFilter(0,TRUE);
    
    m_pStream->SetEG(0, &m_Articulation.m_VolumeEG.m_Registers);
    m_pStream->SetEG(0, &m_Articulation.m_PitchEG.m_Registers);

    SendLFOs(0);

    DWORD dwSamplesPerBlock = 1;
    if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
    {
        dwSamplesPerBlock = 64;
    }
    
    m_dwStreamPosition = (dwVoiceStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
    m_dwLoopEnd = (dwLoopEnd * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
    m_dwLoopStart = (dwLoopStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
    
    // Allocate the buffers.
    m_dwBufferSize = (DWORD)(pWave->m_rtReadAheadTime / 10000);
    if (m_dwBufferSize < 50) m_dwBufferSize = 50;
    m_dwBufferSize *= m_WaveFormat.wfx.nSamplesPerSec;
    m_dwBufferSize += 500;
    m_dwBufferSize /= 1000;
    if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
    {
        m_dwBufferSize += 32;
        m_dwBufferSize /= 64;
    }
    m_dwBufferSize *= m_WaveFormat.wfx.nBlockAlign;
    DWORD dwPacket = 0;
    for (; dwPacket < VOICE_NUM_PACKETS; dwPacket++)
    {
        if ((m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM) ||
            (m_WaveFormat.wfx.nChannels > 2))

        {        
            m_pvBuffer[dwPacket] = DirectMusicPhysicalAllocI(m_dwBufferSize);
        }
        else
        {
            m_pvBuffer[dwPacket] = new BYTE[m_dwBufferSize];
        }
        assert(m_pvBuffer[dwPacket]);
        if(!m_pvBuffer[dwPacket])
        {
            return false; // Out of physical memory. Eep!
        }
    }

    m_pWave = pWave;
    pWave->AddRef();
    m_wPacketsSubmitted = 0;
    m_wCurrentPacket = 0;
    memset(m_dwPacketIndex,0,sizeof(m_dwPacketIndex));

    for (; m_wCurrentPacket < VOICE_NUM_PACKETS; )
    {
        if (FAILED(WritePacket(rtStartTime,m_wCurrentPacket++)))
        {
            break;
        }
    }
    m_wCurrentPacket %= VOICE_NUM_PACKETS;
    return (TRUE);
}

HRESULT CVoice::WritePacket(REFERENCE_TIME rtTime,DWORD dwPacket)

{
    HRESULT hr = E_FAIL;
    if (m_dwStreamPosition < m_pWave->m_dwSampleDataSize)
    {
        DWORD dwPacketSize = m_dwBufferSize;
        if (m_dwLoopEnd && ((m_dwStreamPosition + dwPacketSize) > m_dwLoopEnd))
        {
            dwPacketSize = m_dwLoopEnd - m_dwStreamPosition;
            hr = m_pWave->Read(m_dwStreamPosition,(BYTE*) m_pvBuffer[dwPacket],dwPacketSize);
            m_dwStreamPosition = m_dwLoopStart;
        }
        else 
        {
            if ((m_dwStreamPosition + dwPacketSize) > m_pWave->m_dwSampleDataSize)
            {
                // If this is longer than the rest of the wave, read just what's needed.
                dwPacketSize = m_pWave->m_dwSampleDataSize - m_dwStreamPosition;
            }
            hr = m_pWave->Read(m_dwStreamPosition,(BYTE*) m_pvBuffer[dwPacket],dwPacketSize);
            m_dwStreamPosition += dwPacketSize;
        }

        if (SUCCEEDED(hr))
        {
            XMEDIAPACKET xmp;
            memset(&xmp,0,sizeof(xmp));
            xmp.pvBuffer = m_pvBuffer[dwPacket];
            xmp.dwMaxSize = dwPacketSize;      
            hr = m_pStream->Process(rtTime, &xmp, &m_dwPacketIndex[dwPacket]);
            m_wPacketsSubmitted++;
        }

    }

    return hr;
}

bool CVoice::StreamDoWork(REFERENCE_TIME rtNow)
{
    DWORD dwPacketStatus;
    if (rtNow > m_rtStartTime)
    {
        rtNow = 0;
    }
    else
    {
        rtNow = m_rtStartTime;
    }
    HRESULT hr = S_OK;
    for (;SUCCEEDED(hr);)
    {
        m_pStream->GetPacketStatus(m_dwPacketIndex[m_wCurrentPacket], &dwPacketStatus);
        if (dwPacketStatus == XMEDIAPACKET_STATUS_SUCCESS)
        {
            // Packet is no longer pending, so we can write to it again...
            hr = WritePacket(rtNow,m_wCurrentPacket++);
            m_wCurrentPacket %= VOICE_NUM_PACKETS;
        }
        else
        {
            break;
        }
    }
    return SUCCEEDED(hr);
}

/*SAMPLE_POSITION CVoice::GetCurrentPos()
{
    // TODO: Figure out why returning m_stStreamPosition sometimes causes the higher levels
    // to get ahead of us and try to refresh an active buffer.
    // (See Xbox bug 5956 DMusic: Streaming waves play back incorrectly; tons of debug spew.)

    // Trace(-1,"Reporting stream position %d\n", (DWORD) m_stStreamPosition);
    return m_dwStreamPosition;
}*/
    
void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    if(m_pBuffer)
    {
        m_pBuffer->Clear();
        m_pBuffer->SetBufferData(0,NULL,0);
        m_pBuffer->SetOutputBuffer(0,NULL);
        // Release the buffer so it will go back to the dsound pool.
        m_pBuffer->Release(); 
        m_pBuffer = NULL;
    }
    if(m_pStream)
    {
        m_pStream->Clear();
        m_pStream->Flush(0);
        // Release the stream so it will go back to the dsound pool. For some reason,
        // this was not enabled before. Need to make sure this is stable...
        m_pStream->Release();
        m_pStream = NULL;
    }
    if (m_pWave)
    {
        m_pWave->Release();
        m_pWave = NULL;
    }
    if (m_pDLSWave)
    {
        m_pDLSWave->Release();
        m_pDLSWave = NULL;
    }

    for(int i = 0; i < VOICE_NUM_PACKETS; i++)
    {
        if(m_pvBuffer[i])
        {
            if ((m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM) ||
                (m_WaveFormat.wfx.nChannels > 2))

            {
                DirectMusicPhysicalFreeI(m_pvBuffer[i]);
            }
            else
            {
                delete [] m_pvBuffer[i];
            }
            m_pvBuffer[i] = NULL;
        }
    }
}

void CVoice::DoWork(CSynth* pSynth)

{
    if (!m_fNoteOn) 
    {
        if(m_pBuffer)
        {
            DWORD dwStatus;
            m_pBuffer->GetStatus(&dwStatus);
            if( dwStatus == 0 ) // Sound stopped playing
            {
                ClearVoice();
            }
            else
            {
                // If this has been playing for 40 seconds after the stop time, it's somehow stuck on. Kill it.
                REFERENCE_TIME now;
                pSynth->m_MasterClock.GetTime(&now);
                if (now > (m_rtStopTime + (10000 * 40 * 1000)))
                {
                    ClearVoice();
                }
            }
        }
    }
    else
    {
        if (m_pStream && m_fInUse)
        {
            REFERENCE_TIME now;
            pSynth->m_MasterClock.GetTime(&now);
            m_fInUse = StreamDoWork(now); 
            if (!m_fInUse) 
            {
                ClearVoice();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmsynth\umsynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// UMSynth.h : Declaration of CUserModeSynth

#ifndef __UMSYNTH_H_
#define __UMSYNTH_H_

#include <ks.h>
#include <ksproxy.h>
#include <mmsystem.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "CSynth.h"
#include "synth.h"
#include "..\shared\xsoundp.h" // For IDirectSoundSource
#include "..\shared\dmusiccp.h" // For class ids.
class CUserModeSynth;

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
// {F5038F82-C052-11D2-872F-00600893B1BD}
DEFINE_GUID(CLSID_DDKSynth, 
0xf5038f82, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

typedef HRESULT (CUserModeSynth::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


#include <pshpack4.h>
struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};
#include <poppack.h>


class CClock : public IReferenceClock
{
friend class CUserModeSynth;
public:

    CClock();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
private:
    CUserModeSynth *	m_pParent;      // Pointer to parent structure.
    DWORD               m_dwLastPosition;
    LONGLONG            m_llSampleTime;
};


/////////////////////////////////////////////////////////////////////////////
// CDMSynth

class CUserModeSynth : public IDirectMusicSynthX, public IKsControl
{
friend class CClock;

public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynthX
public:
	virtual STDMETHODIMP Open(LPDMUS_PORTPARAMS pPortParams);
	virtual STDMETHODIMP Close(); 
	virtual STDMETHODIMP SetNumChannelGroups(DWORD dwGroups);
    virtual STDMETHODIMP SetMasterVolume(LONG lVolume);
    virtual STDMETHODIMP SendShortMsg(REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg);
    virtual STDMETHODIMP SendLongMsg(REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength);
//	virtual STDMETHODIMP Download(LPHANDLE phDownload, LPVOID pvData, LPBOOL pbFree);
//	virtual STDMETHODIMP Unload(HANDLE hDownload,
//								HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
//								HANDLE hUserData);

//	virtual STDMETHODIMP PlayBuffer(REFERENCE_TIME rt, LPBYTE pbBuffer, DWORD cbBuffer);
//	virtual STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
//	virtual STDMETHODIMP GetPortCaps(LPDMUS_PORTCAPS pCaps);
	virtual STDMETHODIMP GetMasterClock(IReferenceClock **ppClock);
//	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
//	virtual STDMETHODIMP Activate(BOOL fEnable);
//	virtual STDMETHODIMP SetSynthSink(IDirectMusicSynthSink *pSynthSink);
//	virtual STDMETHODIMP Render(short *pBuffer, DWORD dwLength, LONGLONG llPosition);
    virtual STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    virtual STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
//    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
//    virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

	virtual STDMETHODIMP PlayWave(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD dwChannel, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd, IDirectSoundWave *pIWave, DWORD *pdwVoiceID );
    virtual STDMETHODIMP StopWave(REFERENCE_TIME rt, DWORD dwVoiceId );
//    virtual STDMETHODIMP GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] );
//    virtual STDMETHODIMP Refresh(DWORD dwDownloadID, DWORD dwFlags );
    virtual STDMETHODIMP AssignChannelToOutput(DWORD dwChannelGroup, DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers );

// IDirectSoundSource
/*public:
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    virtual STDMETHODIMP SetSink(IDirectSoundConnect* pSinkConnect);
    virtual STDMETHODIMP Seek(ULONGLONG sp);
    virtual STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD cpvBuffer, PULONGLONG pcb);
	virtual STDMETHODIMP GetSize(PULONGLONG pcb);*/

// IDirectSoundSource : members 
private:
//	ULONGLONG m_ullPosition;

// IKsControl
public:
 	virtual STDMETHODIMP KsProperty(
		PKSPROPERTY pPropertyIn, 
		ULONG ulPropertyLength,
		LPVOID pvPropertyData, 
		ULONG ulDataLength,
		PULONG pulBytesReturned);

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
	CUserModeSynth();
	~CUserModeSynth();
	HRESULT		Init();

private:
    CClock      m_MasterClock;  // Master clock for timing, derived from DSound.
	long		m_cRef;
	CSynth *	m_pSynth;		// Just one synth engine.
	BOOL		m_fActive;		// Currently active.
    LONG        m_lVolume;      // in 1/100 dB
    LONG        m_lBoost;       // in 1/100 dB
    LONG        m_lGainAdjust;  // in 1/100 dB
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.

    HRESULT HandleSetVolume(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);

    HRESULT HandleSetBoost(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);
        
	HRESULT HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleEffects(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleGetSampleRate(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    //static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthFactory();

	// Destructor
	~CDirectMusicSynthFactory();

private:
	long m_cRef;
};



#endif //__UMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//

#ifdef XBOX
#include <xtl.h>
#endif // XBOX

#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\dll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// loader dll.cpp
//
// Dll entry points and CToolFactory, CContainerFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "BaseTool.h"
#include "Echo.h"
#include "Transpose.h"
#include "Duration.h"
#include "Quantize.h"
#include "TimeShift.h"
#include "Swing.h"
#include "Velocity.h"

#ifndef UNDER_CE
#include <regstr.h>
#endif

// Globals
//

// Version information for our class
//
TCHAR g_szEchoFriendlyName[]            = TEXT("Microsoft Echo Tool");
TCHAR g_szEchoShortName[]               = TEXT("Echo");
TCHAR g_szEchoDescription[]             = TEXT("Echoes notes");
TCHAR g_szEchoVerIndProgID[]            = TEXT("Microsoft.DirectMusicEchoTool");
TCHAR g_szEchoProgID[]                  = TEXT("Microsoft.DirectMusicEchoTool.1");

TCHAR g_szTransposeFriendlyName[]       = TEXT("Microsoft Transpose Tool");
TCHAR g_szTransposeShortName[]          = TEXT("Transpose");
TCHAR g_szTransposeDescription[]        = TEXT("Transposes notes");
TCHAR g_szTransposeVerIndProgID[]       = TEXT("Microsoft.DirectMusicTransposeTool");
TCHAR g_szTransposeProgID[]             = TEXT("Microsoft.DirectMusicTransposeTool.1");

TCHAR g_szDurationFriendlyName[]        = TEXT("Microsoft Duration Modifier Tool");
TCHAR g_szDurationShortName[]           = TEXT("Duration");
TCHAR g_szDurationDescription[]         = TEXT("Scales note durations");
TCHAR g_szDurationVerIndProgID[]        = TEXT("Microsoft.DirectMusicDurationTool");
TCHAR g_szDurationProgID[]              = TEXT("Microsoft.DirectMusicDurationTool.1");

TCHAR g_szQuantizeFriendlyName[]        = TEXT("Microsoft Quantize Tool");
TCHAR g_szQuantizeShortName[]           = TEXT("Quantize");
TCHAR g_szQuantizeDescription[]         = TEXT("Quantizes note starts and durations");
TCHAR g_szQuantizeVerIndProgID[]        = TEXT("Microsoft.DirectMusicQuantizeTool");
TCHAR g_szQuantizeProgID[]              = TEXT("Microsoft.DirectMusicQuantizeTool.1");

TCHAR g_szTimeShiftFriendlyName[]       = TEXT("Microsoft Time Shift Tool");
TCHAR g_szTimeShiftShortName[]          = TEXT("Time Shift");
TCHAR g_szTimeShiftDescription[]        = TEXT("Shifts and randomizes note starts");
TCHAR g_szTimeShiftVerIndProgID[]       = TEXT("Microsoft.DirectMusicTimeShiftTool");
TCHAR g_szTimeShiftProgID[]             = TEXT("Microsoft.DirectMusicTimeShiftTool.1");

TCHAR g_szSwingFriendlyName[]           = TEXT("Microsoft Swing Tool");
TCHAR g_szSwingShortName[]              = TEXT("Swing");
TCHAR g_szSwingDescription[]            = TEXT("Changes the timing to a adopt a triplet rhythm");
TCHAR g_szSwingVerIndProgID[]           = TEXT("Microsoft.DirectMusicSwingTool");
TCHAR g_szSwingProgID[]                 = TEXT("Microsoft.DirectMusicSwingTool.1");

TCHAR g_szVelocityFriendlyName[]        = TEXT("Microsoft Velocity Transform Tool");
TCHAR g_szVelocityShortName[]           = TEXT("Velocity Transform");
TCHAR g_szVelocityDescription[]         = TEXT("Modifies note velocities");
TCHAR g_szVelocityVerIndProgID[]        = TEXT("Microsoft.DirectMusicVelocityTool");
TCHAR g_szVelocityProgID[]              = TEXT("Microsoft.DirectMusicVelocityTool.1");

// Dll's hModule
//
HMODULE g_hModule = NULL; 

#ifndef UNDER_CE
// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;
#endif

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// CToolFactory::QueryInterface
//
HRESULT __stdcall
CToolFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CToolFactory::CToolFactory(DWORD dwToolType)

{
	m_cRef = 1;
    m_dwToolType = dwToolType;
	InterlockedIncrement(&g_cLock);
}

CToolFactory::~CToolFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CToolFactory::AddRef
//
ULONG __stdcall
CToolFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CToolFactory::Release
//
ULONG __stdcall
CToolFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CToolFactory::CreateInstance
//
//
HRESULT __stdcall
CToolFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CBaseTool *pTool;
    switch (m_dwToolType)
    {
    case TOOL_ECHO:
        pTool = new CEchoTool;
        break;
    case TOOL_TRANSPOSE:
        pTool = new CTransposeTool;
        break;
    case TOOL_SWING:
        pTool = new CSwingTool;
        break;
    case TOOL_DURATION:
        pTool = new CDurationTool;
        break;
    case TOOL_QUANTIZE:
        pTool = new CQuantizeTool;
        break;
    case TOOL_TIMESHIFT:
        pTool = new CTimeShiftTool;
        break;
    case TOOL_VELOCITY:
        pTool = new CVelocityTool;
        break;
    }

    if (pTool == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pTool->QueryInterface(iid, ppv);
    pTool->Release();
    
    return hr;
}

// CToolFactory::LockServer
//
HRESULT __stdcall
CToolFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_DirectMusicEchoTool)
    {
        dwTypeID = TOOL_ECHO;
    }
    else if(clsid == CLSID_DirectMusicTransposeTool) 
    {
        dwTypeID = TOOL_TRANSPOSE;
    }
    else if(clsid == CLSID_DirectMusicDurationTool) 
    {
        dwTypeID = TOOL_DURATION;
    }
    else if(clsid == CLSID_DirectMusicQuantizeTool) 
    {
        dwTypeID = TOOL_QUANTIZE;
    }
    else if(clsid == CLSID_DirectMusicTimeShiftTool) 
    {
        dwTypeID = TOOL_TIMESHIFT;
    }
    else if(clsid == CLSID_DirectMusicSwingTool) 
    {
        dwTypeID = TOOL_SWING;
    }
    else if(clsid == CLSID_DirectMusicVelocityTool) 
    {
        dwTypeID = TOOL_VELOCITY;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CToolFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}

const TCHAR cszToolRegRoot[] = TEXT(DMUS_REGSTR_PATH_TOOLS) TEXT("\\");
const TCHAR cszDescriptionKey[] = TEXT("Description");
const TCHAR cszNameKey[] = TEXT("Name");
const TCHAR cszShortNameKey[] = TEXT("ShortName");
const int CLSID_STRING_SIZE = 39;
HRESULT CLSIDToStr(const CLSID &clsid, TCHAR *szStr, int cbStr);

#ifndef XBOX

HRESULT RegisterTool(REFGUID guid,
                      const TCHAR szDescription[],
                      const TCHAR szShortName[],
                      const TCHAR szName[])
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszToolRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     szRegKey,
                     &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegSetValueEx(hk,
                  cszDescriptionKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szDescription,
                  lstrlen(szDescription) + 1))
    {
        hr = E_FAIL;
    }

    if (RegSetValueEx(hk,
                  cszNameKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szName,
                  lstrlen(szName) + 1))
    {
        hr = E_FAIL;
    }

    if (RegSetValueEx(hk,
                  cszShortNameKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szShortName,
                  lstrlen(szName) + 1))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);
    return hr;
}

HRESULT UnregisterTool(REFGUID guid)
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszToolRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_ALL_ACCESS | KEY_WRITE, &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegDeleteValue(hk,cszDescriptionKey))
    {
        hr = E_FAIL;
    }

    if (RegDeleteValue(hk,cszNameKey))
    {
        hr = E_FAIL;
    }

    if (RegDeleteValue(hk,cszShortNameKey))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);

    if (RegDeleteKey(HKEY_LOCAL_MACHINE,szRegKey))
    {
        hr = E_FAIL;
    }

    return hr;
}

#endif // ! XBOX

STDAPI DllUnregisterServer()
{
#ifndef XBOX
    UnregisterServer(CLSID_DirectMusicEchoTool,
                     g_szEchoFriendlyName,
                     g_szEchoVerIndProgID,
                     g_szEchoProgID);
    UnregisterTool(CLSID_DirectMusicEchoTool);
    UnregisterServer(CLSID_DirectMusicTransposeTool,
                     g_szTransposeFriendlyName,
                     g_szTransposeVerIndProgID,
                     g_szTransposeProgID);
    UnregisterTool(CLSID_DirectMusicTransposeTool);
    UnregisterServer(CLSID_DirectMusicDurationTool,
                     g_szDurationFriendlyName,
                     g_szDurationVerIndProgID,
                     g_szDurationProgID);
    UnregisterTool(CLSID_DirectMusicDurationTool);
    UnregisterServer(CLSID_DirectMusicQuantizeTool,
                     g_szQuantizeFriendlyName,
                     g_szQuantizeVerIndProgID,
                     g_szQuantizeProgID);
    UnregisterTool(CLSID_DirectMusicQuantizeTool);
    UnregisterServer(CLSID_DirectMusicSwingTool,
                     g_szSwingFriendlyName,
                     g_szSwingVerIndProgID,
                     g_szSwingProgID);
    UnregisterTool(CLSID_DirectMusicSwingTool);
    UnregisterServer(CLSID_DirectMusicTimeShiftTool,
                     g_szTimeShiftFriendlyName,
                     g_szTimeShiftVerIndProgID,
                     g_szTimeShiftProgID);
    UnregisterTool(CLSID_DirectMusicTimeShiftTool);
    UnregisterServer(CLSID_DirectMusicVelocityTool,
                     g_szVelocityFriendlyName,
                     g_szVelocityVerIndProgID,
                     g_szVelocityProgID);
    UnregisterTool(CLSID_DirectMusicVelocityTool);
#endif // ! XBOX
    return S_OK;
}

STDAPI DllRegisterServer()
{
#ifndef XBOX
    RegisterServer(g_hModule,
                   CLSID_DirectMusicEchoTool,
                   g_szEchoFriendlyName,
                   g_szEchoVerIndProgID,
                   g_szEchoProgID);
    RegisterTool(CLSID_DirectMusicEchoTool, g_szEchoDescription, g_szEchoShortName, g_szEchoFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicTransposeTool,
                   g_szTransposeFriendlyName,
                   g_szTransposeVerIndProgID,
                   g_szTransposeProgID);
    RegisterTool(CLSID_DirectMusicTransposeTool, g_szTransposeDescription, g_szTransposeShortName, g_szTransposeFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicDurationTool,
                   g_szDurationFriendlyName,
                   g_szDurationVerIndProgID,
                   g_szDurationProgID);
    RegisterTool(CLSID_DirectMusicDurationTool, g_szDurationDescription, g_szDurationShortName, g_szDurationFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicQuantizeTool,
                   g_szQuantizeFriendlyName,
                   g_szQuantizeVerIndProgID,
                   g_szQuantizeProgID);
    RegisterTool(CLSID_DirectMusicQuantizeTool, g_szQuantizeDescription, g_szQuantizeShortName, g_szQuantizeFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSwingTool,
                   g_szSwingFriendlyName,
                   g_szSwingVerIndProgID,
                   g_szSwingProgID);
    RegisterTool(CLSID_DirectMusicSwingTool, g_szSwingDescription, g_szSwingShortName, g_szSwingFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicTimeShiftTool,
                   g_szTimeShiftFriendlyName,
                   g_szTimeShiftVerIndProgID,
                   g_szTimeShiftProgID);
    RegisterTool(CLSID_DirectMusicTimeShiftTool, g_szTimeShiftDescription, g_szTimeShiftShortName, g_szTimeShiftFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicVelocityTool,
                   g_szVelocityFriendlyName,
                   g_szVelocityVerIndProgID,
                   g_szVelocityProgID);
    RegisterTool(CLSID_DirectMusicVelocityTool, g_szVelocityDescription, g_szVelocityShortName, g_szVelocityFriendlyName);

#endif // ! XBOX

    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            g_hModule = (HMODULE)hModule;
#ifndef UNDER_CE
            OSVERSIONINFO osvi;

            DisableThreadLibraryCalls(hModule);
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#endif
#ifdef DBG
			DebugInit();
#endif
		}
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\basetool.cpp ===
// BaseTool.cpp : Implementation of CBaseTool
//
// Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "basetool.h"

CBaseTool::CBaseTool()
{
    m_cRef = 1; // set to 1 so one call to Release() will free this
    InitializeCriticalSection(&m_CrSec);
}

CBaseTool::~CBaseTool()
{
    DeleteCriticalSection(&m_CrSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\basetool.h ===
#ifndef _BASE_TOOL_
#define _BASE_TOOL_

#include "dmusici.h"
#include "medparam.h"

extern long g_cComponent;

class CBaseTool : public IDirectMusicTool8
{
public:
	CBaseTool() 
    {
        m_cRef = 1; // set to 1 so one call to Release() will free this
        m_pParams = NULL;
        InitializeCriticalSection(&m_CrSec);
        InterlockedIncrement(&g_cComponent);
    }
    ~CBaseTool()
    {
        if (m_pParams)
        {
            m_pParams->Release();
        }
        DeleteCriticalSection(&m_CrSec);
       	InterlockedDecrement(&g_cComponent);
    }
    void CreateParams()
    {
           
    }
    void CloneParams()
    {
    }
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) PURE;
    STDMETHODIMP_(ULONG) AddRef() PURE;
    STDMETHODIMP_(ULONG) Release() PURE;

/*// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID) PURE;

// IPersistStream functions
    STDMETHODIMP IsDirty() PURE;
    STDMETHODIMP Load(IStream* pStream) PURE;
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) PURE;
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) PURE;*/

// IDirectMusicTool
	STDMETHODIMP Init(IDirectMusicGraph* pGraph) {return E_NOTIMPL;}
	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) {return E_NOTIMPL;}
	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) {return E_NOTIMPL;}
	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) {return E_NOTIMPL;}
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) PURE;
	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) {return E_NOTIMPL;}

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) PURE;

protected:
	long	m_cRef;			// reference counter
	CRITICAL_SECTION m_CrSec;	// to make SetEchoNum() and SetDelay() thread-safe
    IMediaParams * m_pParams;   // Helper object that manages IMediaParams.
};

class CToolFactory : public IClassFactory
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CToolFactory(DWORD dwToolType);

	// Destructor
	~CToolFactory(); 

private:
	long m_cRef;
    DWORD m_dwToolType;
};

// We use one class factory to create all tool classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define TOOL_ECHO       1
#define TOOL_TRANSPOSE  2
#define TOOL_SWING      3
#define TOOL_QUANTIZE   4
#define TOOL_VELOCITY   5
#define TOOL_DURATION   6
#define TOOL_TIMESHIFT  7

#endif // _BASE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\medparam_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Mar 24 17:07:36 2000
 */
/* Compiler settings for C:\dx8\dmusic\dmime\medparam.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMediaParamInfo = {0x6d6cbb60,0xa223,0x44aa,{0x84,0x2f,0xa2,0xf0,0x67,0x50,0xbe,0x6d}};


const IID IID_IMediaParams = {0x6d6cbb61,0xa223,0x44aa,{0x84,0x2f,0xa2,0xf0,0x67,0x50,0xbe,0x6e}};


const IID IID_IMediaParamsRecordNotify = {0xfea74878,0x4e39,0x4267,{0x8a,0x17,0x6a,0xaf,0x05,0x36,0xff,0x7c}};


const IID IID_IMediaParamsRecord = {0x21b64d1a,0x8e24,0x40f6,{0x87,0x97,0x44,0xcc,0x02,0x1b,0x2a,0x0a}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\guids.cpp ===
#include <objbase.h>
#include "initguid.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "basetool.h"
#include "tools.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\duration.cpp ===
// Duration.cpp : Implementation of CDurationTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#ifdef XBOX
#include <xtl.h>
#endif // XBOX

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "duration.h"
#include "toolhelp.h"


CDurationTool::CDurationTool()
{
    ParamInfo Params[DMUS_DURATION_PARAMCOUNT] = 
    {
        { DMUS_DURATION_SCALE, MPT_INT,MP_CAPS_ALL,0,8,1,
            L"Times",L"Scale",NULL},        // Scale - default to 1 (no change)
    };
    InitParams(DMUS_DURATION_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CDurationTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDurationTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CDurationTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicDurationTool)
	{
		*ppv = static_cast<IDirectMusicDurationTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CDurationTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicDurationTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CDurationTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CDurationTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_DURATION_CHUNK))
	{
        DMUS_IO_DURATION_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_DURATION_SCALE,(float) Header.flScale);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CDurationTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_DURATION_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_DURATION_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_DURATION_HEADER Header;
        GetParamFloat(DMUS_DURATION_SCALE,MAX_REF_TIME,&Header.flScale);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CDurationTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_DURATION_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CDurationTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_DurationPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CDurationTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only adjust the durations of notes. 
    if( pPMsg->dwType == DMUS_PMSGT_NOTE ) 
    {
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        float flScale;

        GetParamFloat(DMUS_DURATION_SCALE,rtTime,&flScale);
        if (flScale >= 0)
        {
            flScale *= pNote->mtDuration;
            pNote->mtDuration = (MUSIC_TIME) flScale;
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CDurationTool::Clone( IDirectMusicTool ** ppTool)

{
    CDurationTool *pNew = new CDurationTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CDurationTool::SetScale(float flScale) 
{
    return SetParam(DMUS_DURATION_SCALE,flScale);
}

STDMETHODIMP CDurationTool::GetScale(float * pflScale) 
{
    return GetParamFloat(DMUS_DURATION_SCALE,MAX_REF_TIME, pflScale);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\echo.h ===
#ifndef _ECHO_TOOL_
#define _ECHO_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CEchoTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicEchoTool

{
public:
	CEchoTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicEchoTool
	STDMETHODIMP SetRepeat(DWORD dwRepeat) ;
	STDMETHODIMP SetDecay(DWORD dwDecay) ;
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetDelay(DWORD dwDelay) ;
    STDMETHODIMP SetGroupOffset(DWORD dwChannelOffset) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetRepeat(DWORD * pdwRepeat) ;
	STDMETHODIMP GetDecay(DWORD * pdwDecay) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetDelay(DWORD * pdwDelay) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
    STDMETHODIMP GetGroupOffset(DWORD * pdwChannelOffset) ;
protected:	
};

#endif // _ECHO_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\dmobase.h ===
// dmobase.h - a collection of DMO base classes

// Current hierarchy:
//
//   IMediaObject
//   |
//   +-- C1in1outDMO - generic base class for DMOs with 1 in and 1 out
//   |   |
//   |   +-- FBRDMO - base class for fixed sample size, fixed bitrate DMOs
//   |   |   |
//   |   |   +-- CPCMDMO - base class for PCM audio DMOs
//   |   |
//   |   +-- C1for1 - base class for single sample per buffer 1-in/1-out DMOs
//   |
//   +-- CGenericDMO - resonably generic base class for multi-input/output DMOs
// 

#ifndef __DMOBASE_H_
#define __DMOBASE_H_

#include "dmo.h"
#include "assert.h"
#include "math.h"

//
// locking helper class
//
#ifdef DMO_NOATL
class CDMOAutoLock {
public:
   CDMOAutoLock(CRITICAL_SECTION* pcs)
      : m_pcs(pcs)
   {
      EnterCriticalSection(m_pcs);
   }
   ~CDMOAutoLock() {
      LeaveCriticalSection(m_pcs);
   }
private:
   CRITICAL_SECTION* m_pcs;
};
#else
class CDMOAutoLock {
public:
   CDMOAutoLock(CComAutoCriticalSection* pcs)
      : m_pcs(pcs)
   {
      m_pcs->Lock();
   }
   ~CDMOAutoLock() {
      m_pcs->Unlock();
   }
private:
   CComAutoCriticalSection* m_pcs;
};
#endif


//
// C1in1outDMO - generic base class for 1-input/1-output DMOs.
//
//
//
// C1in1outDMO implements all IMediaObject methods.  The derived class
// customizes the DMO's behavior by overriding some or all of the following
// virtual functions:
//
// Main Streaming:
//    AcceptInput          // accept one new input buffer
//    ProduceOutput        // fill up one output buffer with new data
//    AcceptingInput       // check if DMO is ready for new input
// Other streaming:
//    PrepareForStreaming  // hook called after both types have been set
//    Discontinuity        // notify DMO of a discontinuity
//    DoFlush              // discard all data and start anew
// Mediatype negotiation:
//    GetInputType         // input type enumerator
//    GetOutputType        // output type enumerator
//    CheckInputType       // verifies proposed input type is acceptable
//    CheckOutputType      // verifies proposed output type is acceptable
// Buffer size negotiation:
//    GetInputFlags        // input data flow flags
//    GetOutputFlags       // output fata flow flags
//    GetInputSizeInfo     // input buffer size requirements
//    GetOutputSizeInfo    // output buffer size requirements
//
// This base class assumes that the derived class will not override any
// IMediaObject methods directly - the derived class should override the
// methods listed above instead.
//
//
//
// The base class provides a default implementation for each of the
// overridables listed above.  However, to make a useful DMO the derived class
// probably needs to override at least the following two methods:
//
//    HRESULT AcceptingInput();
//    HRESULT AcceptInput(BYTE* pData,
//                        ULONG ulSize,
//                        DWORD dwFlags,
//                        REFERENCE_TIME rtTimestamp,
//                        REFERENCE_TIME rtTimelength,
//                        IMediaBuffer* pMediaBuffer);
//    HRESULT ProduceOutput(BYTE *pData,
//                        ULONG ulAvail,
//                        ULONG* pulUsed,
//                        DWORD* pdwStatus,
//                        REFERENCE_TIME *prtTimestamp,
//                        REFERENCE_TIME *prtTimelength);
//
// All good DMOs should also override these (the default implementation
// simply accepts any mediatype, which in general is not good DMO behavior):
//
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// DMOs that store data and/or state information may need to implement
//
//    HRESULT PrepareForStreaming();
//    HRESULT Discontinuity();
//    HRESULT Flush();
//
// Finally, DMOs that make any buffer size assumptions will need to override
// these:
//
//    HRESULT GetInputFlags(DWORD* pdwFlags);
//    HRESULT GetOutputFlags(DWORD* pdwFlags);
//    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
//    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment);
//
//
//
// The following functions are provided by this base class exclusively for use
// by the derived class.  The derived class should call these to find out the
// currently set mediatype(s) whenever it needs to make a decision that
// depends on the mediatype used.  Each of these returns NULL if the mediatype
// has not been set yet.
//
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

#define PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulStreamIndex >= 1) \
       return DMO_E_INVALIDSTREAMINDEX

class C1in1outDMO : public IMediaObject
{
public:
    C1in1outDMO() :
       m_bInputTypeSet(FALSE),
       m_bOutputTypeSet(FALSE),
       m_bIncomplete(FALSE)
    {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
    }
    ~C1in1outDMO() {
#ifdef DMO_NOATL
       DeleteCriticalSection(&m_cs);
#endif
    }

public:    
    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = 1;
        *pulNumberOfOutputStreams = 1;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       PROLOGUE;
       return GetInputFlags(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       PROLOGUE;
       return GetOutputFlags(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetInputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetOutputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       if (m_bInputTypeSet)
          return MoCopyMediaType(pmt, &m_InputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       if (m_bOutputTypeSet)
          return MoCopyMediaType(pmt, &m_OutputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       PROLOGUE;
       if (!m_bInputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetInputSizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       PROLOGUE;
       if (!m_bOutputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetOutputSizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       PROLOGUE;
       HRESULT hr = CheckInputType(pmt);
       if (FAILED(hr))
          return hr;

       if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
          return NOERROR;

       // Free any previous mediatype
       if (m_bInputTypeSet)
          MoFreeMediaType(&m_InputType);

       // actually set the type
       MoCopyMediaType(&m_InputType, pmt);
       m_bInputTypeSet = TRUE;

       if (m_bOutputTypeSet)
          PrepareForStreaming();
       return NOERROR;
    }
    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       PROLOGUE;
       HRESULT hr = CheckOutputType(pmt);
       if (FAILED(hr))
          return hr;

       if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
          return NOERROR;

       // Free any previous mediatype
       if (m_bOutputTypeSet)
          MoFreeMediaType(&m_OutputType);

       // actually set the type
       MoCopyMediaType(&m_OutputType, pmt);
       m_bOutputTypeSet = TRUE;

       if (m_bInputTypeSet)
          PrepareForStreaming();
       return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
       PROLOGUE;
       *pdwStatus = 0;
       if (AcceptingInput() == S_OK)
          *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
       return NOERROR;

    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
       PROLOGUE;
       return Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
       DoFlush();
       return NOERROR;
    }
    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}
    
    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       PROLOGUE;
       if (AcceptingInput() != S_OK)
          return DMO_E_NOTACCEPTING;
       if (!pBuffer)
          return E_POINTER;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pData;
       ULONG ulSize;
       HRESULT hr = pBuffer->GetBufferAndLength(&pData, &ulSize);
       if (FAILED(hr))
          return hr;
       if (pData == NULL)
          ulSize = 0;

       m_bIncomplete = TRUE; // new input means we may be able to produce output

       return AcceptInput(pData, ulSize, dwFlags, rtTimestamp, rtTimelength, pBuffer);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       HRESULT hr;
       CDMOAutoLock l(&m_cs);
       
       if (ulOutputBufferCount != 1)
          return E_INVALIDARG;

       pOutputBuffers[0].dwStatus = 0;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pOut;
       ULONG ulSize;
       ULONG ulAvail;

       if (pOutputBuffers[0].pBuffer) {
          hr = pOutputBuffers[0].pBuffer->GetBufferAndLength(&pOut, &ulSize);
          if (FAILED(hr)) return hr;
          hr = pOutputBuffers[0].pBuffer->GetMaxLength(&ulAvail);
          if (FAILED(hr)) return hr;
   
          if (ulSize) { // skip any already used portion of the buffer
             if (ulSize > ulAvail)
                return E_INVALIDARG;
             ulAvail -= ulSize;
             pOut += ulSize;
          }
       }
       else
          ulAvail = 0;

       if (ulAvail) { // have output buffer - call process
          ULONG ulProduced = 0;
          hr = ProduceOutput(pOut,
                             ulAvail,
                             &ulProduced,
                             &(pOutputBuffers[0].dwStatus),
                             &(pOutputBuffers[0].rtTimestamp),
                             &(pOutputBuffers[0].rtTimelength));
          if (FAILED(hr))
             return hr;

          HRESULT hrProcess = hr; // remember this in case it's S_FALSE

          // remember the DMO's incomplete status
          if (pOutputBuffers[0].dwStatus | DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
             m_bIncomplete = TRUE;
          else
             m_bIncomplete = FALSE;

          if (ulProduced > ulAvail)
             return E_FAIL;

          hr = pOutputBuffers[0].pBuffer->SetLength(ulSize + ulProduced);
          if (FAILED(hr))
             return hr;

          return hrProcess;
       }
       else { // no output buffer - assume they just want the incomplete flag
          if (m_bIncomplete)
             pOutputBuffers[0].dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
          return NOERROR;
       }
    }
    
protected:
    //
    // private methods for use by derived class
    //
    DMO_MEDIA_TYPE *InputType() {
       if (m_bInputTypeSet)
          return &m_InputType;
       else
          return NULL;
    }
    DMO_MEDIA_TYPE *OutputType() {
       if (m_bOutputTypeSet)
          return &m_OutputType;
       else
          return NULL;
    }

protected:    
    //
    // To be overriden by the derived class
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0; // default implementation assumes no lookahead
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0;
       return NOERROR;
    }
    
    virtual HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }
    virtual HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }

    virtual HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pcbMaxLookahead = 0; // default implementation assumes no lookahead
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }
    virtual HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }

    virtual HRESULT PrepareForStreaming() {
       return NOERROR;
    }
    virtual HRESULT AcceptingInput() {
       return S_FALSE;
    }
    virtual HRESULT Discontinuity() {
       return NOERROR;
    }
    virtual HRESULT DoFlush() {
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pMediaBuffer
    ) {
       m_bIncomplete = FALSE;
       return S_FALSE;
    }
    virtual HRESULT ProduceOutput(BYTE *pData,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       return S_FALSE;
    }

private:
    // mediatype stuff
    BOOL m_bInputTypeSet;
    BOOL m_bOutputTypeSet;
    DMO_MEDIA_TYPE m_InputType;
    DMO_MEDIA_TYPE m_OutputType;
    
    BOOL m_bIncomplete;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};



//
// C1for1DMO - base class for 1-input/1-output DMOs which
//  - work on whole samples at a time, one sample per buffer
//  - produce exactly one output sample for every input sample
//  - don't need to accumulate more than 1 input sample before producing
//  - don't produce any additional stuff at the end
//  - the output sample corresponds in time to the input sample
//
// The derived class must implement:
//    HRESULT Process(BYTE* pIn,
//                    ULONG ulBytesIn,
//                    BYTE* pOut,
//                    ULONG* pulProduced);
//    HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
//                           ULONG* pulMaxOutputSampleSize);
//
//
// The derived class should implement:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// The derived class may implement if it needs to:
//    HRESULT Init();
//
// The following methods are implemented by the base class.  The derived class
// should call these to find out if the input/output type has been set and if
// so what it was set to.
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

class C1for1DMO : public C1in1outDMO
{
public:
    C1for1DMO() :
       m_pBuffer(NULL)
    {
    }
    ~C1for1DMO() {
       if (m_pBuffer)
          m_pBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;
       
       *pulSize = m_ulMaxInputSize;
       *pcbMaxLookahead = 0;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;
       
       *pulSize = m_ulMaxOutputSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT PrepareForStreaming() {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       return Init();
    }
    HRESULT AcceptingInput() {
       return m_pBuffer ? S_FALSE : S_OK; // accept unless holding one already
    }
    HRESULT AcceptInput(BYTE* pData,
                        ULONG ulSize,
                        DWORD dwFlags,
                        REFERENCE_TIME rtTimestamp,
                        REFERENCE_TIME rtTimelength,
                        IMediaBuffer* pMediaBuffer
    ) {
       if (AcceptingInput() != S_OK)
          return E_FAIL;
       m_pData        = pData;
       m_ulSize       = ulSize;
       m_dwFlags      = dwFlags;
       m_rtTimestamp  = rtTimestamp;
       m_rtTimelength = rtTimelength;
       m_pBuffer      = pMediaBuffer;
       pMediaBuffer->AddRef();
       return NOERROR;
    }
    HRESULT DoFlush() {
       if (m_pBuffer) {
          m_pBuffer->Release();
          m_pBuffer = NULL;
       }
       return NOERROR;
    }
    HRESULT ProduceOutput(BYTE *pOut,
                          ULONG ulAvail,
                          ULONG* pulUsed,
                          DWORD* pdwStatus,
                          REFERENCE_TIME *prtTimestamp,
                          REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       *pdwStatus = 0;

       if (!m_pBuffer)
          return S_FALSE;
       if (ulAvail < m_ulMaxOutputSize)
          return E_INVALIDARG;

       HRESULT hr = Process(m_pData,
                            m_ulSize,
                            pOut,
                            pulUsed);
       
       m_pBuffer->Release();
       m_pBuffer = NULL;

       if (FAILED(hr))
          return hr;

       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       *prtTimestamp = m_rtTimestamp;
       *prtTimelength = m_rtTimelength;

       if (*pulUsed == 0)
          return S_FALSE;
       return hr;
    }
protected:
    //
    // To be implemented by derived class
    //
    virtual HRESULT Process(BYTE* pIn,
                            ULONG ulBytesIn,
                            BYTE* pOut,
                            ULONG* pulProduced) = 0;
    virtual HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
                                   ULONG* pulMaxOutputSampleSize) = 0;
    virtual HRESULT Init() {return NOERROR;}

private:
   IMediaBuffer* m_pBuffer;
   BYTE* m_pData;
   ULONG m_ulSize;
   DWORD m_dwFlags;
   REFERENCE_TIME m_rtTimestamp;
   REFERENCE_TIME m_rtTimelength;

   ULONG m_ulMaxOutputSize;
   ULONG m_ulMaxInputSize;
};


//
// CFBRDMO - DMO base class for 'fixed bitrate' DMOs.  More specifically,
// this base class assumes the following:
//  - 1 input, 1 output;
//  - both input and output consist of equally sized 'quanta';
//  - input/output quantum sizes can be determined from mediatypes;
//  - each output quantum can be generated independently (without looking at
//     previous output quanta);
//  - if multiple input quanta are needed to generate a particular output
//     quantum ('window overhead'), then the range of input required has an upper
//     bound derived from mediatypes on both sides (i.e., both 'lookahead'
//     and 'input memory' are bounded).
//
// The derived class must implement the following virtual functions:
//    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
//    HRESULT GetStreamingParams(
//       DWORD *pdwInputQuantumSize, // in bytes
//       DWORD *pdwOutputQuantumSize, // in bytes
//       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
//       DWORD *pdwLookBehind,
//       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
//       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
//    );
// The derived class should also implement the following:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
// The derived class may need to implement the followng:
//    HRESULT Init();
//    HRESULT Discontinuity();
//
// The derived class may use these entry points into the base class to get
// the currently set mediatypes:
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//
// The sum of *pdwMaxLookahead and *pdwLoookbehind is the 'window overhead' of
// the algorithm (the window overhead is 0 if the algorithm only needs the
// current input sample).
//
// Because the non-zero window overhead case is more complicated, it is handled by a
// separate set of functions in this base class.  The names of all non-zero
// window overhead functions have the 'NZWO' prefix.  The names of the
// zero window overhead functions begin with 'ZWO'.
//
// A data copy on the input side is necessary in the non-zero window overhead case.
//

class CFBRDMO : public C1in1outDMO
{
public:
    CFBRDMO() :
       m_bParametersSet(FALSE),
       m_pMediaBuffer(NULL),
       m_pAllocAddr(NULL),
       m_bStreaming(FALSE)
    {
    }
    ~CFBRDMO() {
       /*
       if (m_bStreaming)
          StopStreaming();
       */
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;
       if (m_pMediaBuffer)
          m_pMediaBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       //
       // For efficiency reasons we might like to be fed fairly large amounts
       // of data at a time, but technically all we need is one quantum.
       //
       *pulSize = m_ulInputQuantumSize;
       *pcbMaxLookahead = 0; // this base class does not rely on HOLDS_BUFFERS
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       *pulSize = m_ulOutputQuantumSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    
    virtual HRESULT Discontinuity() {
       m_bDiscontinuity = TRUE;
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pBuffer
    ) {
       // Every sample is a syncpoint for mediatypes
       // supported by objects of this class.
       assert(dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT);
       BOOL bTimestamp = (dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) ? TRUE : FALSE;

       if (m_ulWindowOverhead)
          return NZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
       else
          return ZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
    }
    virtual HRESULT ProduceOutput(BYTE *pOut,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       HRESULT hr;
       if (!m_bParametersSet)
          return DMO_E_TYPE_NOT_SET;
       
       // call Discontinuity() if this is the first ProcessOutput() call
       if (!m_bStreaming) {
          HRESULT hr = Discontinuity();
          if (FAILED(hr))
             return hr;
          m_bStreaming = TRUE;
       }

       *pdwStatus = 0;

       ULONG ulInputQuantaAvailable = InputQuantaAvailable();
       if (!ulInputQuantaAvailable)
          return S_FALSE; // did not produce anything

       ULONG ulOutputQuantaPossible = ulAvail / m_ulOutputQuantumSize;
       if (!ulOutputQuantaPossible)
          return E_INVALIDARG; // this would be rather lame

       ULONG ulQuantaToProcess = min(ulOutputQuantaPossible, ulInputQuantaAvailable);
       assert(ulQuantaToProcess > 0);

       BOOL bTimestamp;
       if (m_ulWindowOverhead)
          hr = NZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       else
          hr = ZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       if (FAILED(hr))
          return hr;

       *pulUsed = ulQuantaToProcess * m_ulOutputQuantumSize;

       *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (bTimestamp)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;

       // any data left ?
       if (InputQuantaAvailable()) // yes - set incomplete
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
       else if (m_bDiscontinuity) // no - process any discontinuity
          DoFlush();

       return NOERROR;
    }
    HRESULT DoFlush()
    {
       // reset flags
       m_bDiscontinuity = FALSE;
       m_bTimestamps = FALSE;

       if (m_ulWindowOverhead)
          NZWODiscardData();
       else
          ZWODiscardData();
          
       // notify the derived class
       Discontinuity();

       return NOERROR;
    }
    HRESULT AcceptingInput() {
       if (!m_bParametersSet) // uninitialized
          return FALSE;

       BOOL bResult;
       if (m_ulWindowOverhead)
          bResult = NZWOQueryAccept();
       else
          bResult = ZWOQueryAccept();

       return bResult ? S_OK : S_FALSE;
    }
    // End C1in1out overridables implementation
    
private:
    //
    // Common private code (window overhead or no window overhead)
    //
    // returns the number of input quanta available minus any window overhead
    ULONG InputQuantaAvailable() {
       if (m_ulWindowOverhead)
          return NZWOAvail();
       else
          return ZWOAvail();
    }

    // Private method to compute/allocate stuff once all types have been set.
    HRESULT PrepareForStreaming () {
       m_bParametersSet = FALSE;
       // Now that both types are set, query the derived class for params
       HRESULT hr;
       if (FAILED(hr = GetStreamingParams(&m_ulInputQuantumSize,
                               &m_ulOutputQuantumSize,
                               &m_ulLookahead,
                               &m_ulLookbehind,
                               &m_rtDurationNumerator,
                               &m_rtDenominator)))
          return hr;
       if (!m_rtDenominator) {
          assert(!"bad object - duration denominator should not be 0 !");
          return E_FAIL;
       }
       // Attempt to reduce the fraction.  Probably the most complicated number
       // we will ever see is 44100 = (3 * 7 * 2 * 5) ^ 2, so trying the first
       // few numbers should suffice in most cases.
       DWORD dwP[] = {2,3,5,7,11,13,17,19,23,29,31};
       for (DWORD c = 0; c < sizeof(dwP) / sizeof(DWORD); c++) {
          while ((m_rtDurationNumerator % dwP[c] == 0) &&
                 (m_rtDenominator % dwP[c] == 0)) {
             m_rtDurationNumerator /= dwP[c];
             m_rtDenominator /= dwP[c];
          }
       }

       // We cannot afford to have huge denominators, unfortunately, because
       // we store timestamp numerators using 64 bits, so a large denominator
       // could result in timestamp overflows.  So if the denominator is still
       // too large, reduce it anyway with loss of precision.
       ULONG ulMax = 0x10000; // largest acceptable denominator value
       if (m_rtDenominator >= ulMax) {
          double actual_ratio = (double)m_rtDurationNumerator * (double)m_rtDenominator;
          ULONG ulDenominator = 1;
          // Repeatedly increase the denominator until either the actual ratio
          // can be represented precisely using the denominator, or the
          // denominator gets too large.
          do {
             double fractional_part = actual_ratio * (double)ulDenominator 
                                    - floor(actual_ratio * (double)ulDenominator);
             if (fractional_part == 0)
                break;
             ULONG ulNewDenominator = (ULONG)floor(ulDenominator / fractional_part);
             if (ulNewDenominator >= ulMax)
                break;
             ulDenominator = ulNewDenominator;
          } while(1);
          m_rtDurationNumerator = (ULONG)floor(actual_ratio * ulDenominator);
          m_rtDenominator = ulDenominator;
       }

       m_ulWindowOverhead = m_ulLookahead + m_ulLookbehind;
       if (!m_ulWindowOverhead) // No window overhead - the simple case
          m_bParametersSet = TRUE;
       else // The complicated case with window overhead
          AllocateCircularBuffer();
       
       m_bTimestamps = FALSE;
       m_bDiscontinuity = FALSE;

       if (m_bStreaming) {
          //StopStreaming();
          m_bStreaming = FALSE;
       }
       Init();
       return m_bParametersSet ? NOERROR : E_FAIL;
    }
    // end common code

    //
    // zero window overhead case code
    //
    HRESULT ZWOProcessInput(IMediaBuffer* pBuffer,
                                     BYTE* pData,
                                     ULONG ulSize,
                                     BOOL bTimestamp,
                                     REFERENCE_TIME rtTimestamp) {
       assert(!m_pMediaBuffer);
       
       m_bTimestamp = bTimestamp;
       m_rtTimestamp = rtTimestamp;
       m_pData = pData;
       m_ulData = ulSize;
       m_ulUsed = 0;
       
       // make sure they gave us a meaningful amount of data
       if (m_ulData < m_ulInputQuantumSize)
          return S_FALSE;

       // save the buffer we were given
       m_pMediaBuffer = pBuffer;
       pBuffer->AddRef();
       return NOERROR;
    }
    HRESULT ZWOProcessOutput(BYTE* pOut,
                                      ULONG ulQuantaToProcess,
                                      BOOL* pbTimestamp,
                                      REFERENCE_TIME* prtTimestamp) {
       assert(m_ulUsed % m_ulInputQuantumSize == 0);
       HRESULT hr = FBRProcess(ulQuantaToProcess, m_pData + m_ulUsed, pOut);
       if (FAILED(hr)) return hr;
       ZWOConsume(ulQuantaToProcess);

       if (m_bTimestamp) { // there was a timestamp on this input buffer
          // m_rtTimestamp refers to the beginning of the input buffer.
          // Extrapolate to the beginning of the area we just processed.
          *prtTimestamp = m_rtTimestamp +
               (m_ulUsed % m_ulInputQuantumSize) * m_rtDurationNumerator /
                                                   m_rtDenominator;
          *pbTimestamp = TRUE;
       }
       else if (m_bTimestamps) { // there was a timestamp earlier
          // bugbug: should we extrapolate from a previous timestamp ?
          *pbTimestamp = FALSE;
       }
       else // no timestamps at all
          *pbTimestamp = FALSE;

       return NOERROR;
    }
    ULONG ZWOAvail() {
       if (m_pMediaBuffer) {
          assert(m_ulData - m_ulUsed > m_ulInputQuantumSize);
          return (m_ulData - m_ulUsed) / m_ulInputQuantumSize;
       }
       else
          return 0;
    }
    void ZWOConsume(ULONG ulN) { // the zero window overhead version
       assert(m_pMediaBuffer);
       m_ulUsed += ulN * m_ulInputQuantumSize;
       assert(m_ulData >= m_ulUsed);
       if (m_ulData - m_ulUsed < m_ulInputQuantumSize) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    BOOL ZWOQueryAccept() {
        // accept IFF not holding something already
       if (!m_pMediaBuffer)
          return TRUE;
       else
          return FALSE;
    }
    void ZWODiscardData() {
       if (m_pMediaBuffer) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    // End zero window overhead case code

    //
    // Non zero window overhead case code.
    //
    HRESULT NZWOProcessInput(IMediaBuffer* pBuffer,
                                  BYTE* pData,
                                  ULONG ulSize,
                                  BOOL bTimestamp,
                                  REFERENCE_TIME rtTimestamp) {
       if (bTimestamp) { // process the timestamp
          if (!m_bTimestamps) { // this is the first timestamp we've seen
             // Just getting started - initialize the timestamp to refer to
             // the first input quantum for which we will actually generate
             // output (the first m_ulLookbehind quanta are pure lookbehind and
             // generate no output).
             m_rtTimestampNumerator = rtTimestamp * m_rtDenominator
                                    + m_ulLookbehind * m_rtDurationNumerator;
   
          }
          else {
             // We are already streaming and just got a new timestamp.  Use it
             // to check if our stored timestamp has somehow drifted away from
             // where it should be and adjust if it is far enough off.
   
             ULONG ulInputQuantaAvailable = InputQuantaAvailable();
             if (ulInputQuantaAvailable) {
                // ulInputQuantaAvailable is how far back in time the next
                // quantum we would process is located relative the beginning
                // of the new buffer we just received.
   
                // Compute what the timestamp back there ought to be now.
                REFERENCE_TIME rtTimestampNumerator;
                rtTimestampNumerator = m_rtDenominator * rtTimestamp
                                     - ulInputQuantaAvailable * m_rtDurationNumerator;
   
                // Adjust the stored timestamp if it is off by more than half
                // the duration of a quantum.  Should also have a DbgLog here.
                if ((m_rtTimestampNumerator >= rtTimestampNumerator + m_rtDurationNumerator / 2) ||
                    (m_rtTimestampNumerator <= rtTimestampNumerator - m_rtDurationNumerator / 2)) {
                   m_rtTimestampNumerator = rtTimestampNumerator;
                }
             }
             else {
                // We must still be accumulating the initial window overhead.
                // Too early to need an adjustment, one would hope.
             }
          }
          m_bTimestamps = TRUE;
       }

       if (BufferUsed() + ulSize > m_ulBufferAllocated)
          return E_FAIL; // need a max input size to prevent this

       // append to our buffer
       AppendData(pData, ulSize);
       
       // are we ready to produce now ?
       if (NZWOAvail())
          return NOERROR;
       else
          return S_FALSE; // no output can be produced yet
    }
    HRESULT NZWOProcessOutput(BYTE* pOut,
                                   ULONG ulQuantaToProcess,
                                   BOOL* pbTimestamp,
                                   REFERENCE_TIME* prtTimestamp) {
       //
       // Handle any timestamps
       //
       if (m_bTimestamps) {
          // In window overhead mode the stored timestamp refers to the input
          // data immediately after lookbehind, which corresponds to the
          // begining of the output buffer by definition of FDRProcess.
          *prtTimestamp = m_rtTimestampNumerator / m_rtDenominator;
          *pbTimestamp = TRUE;
          
       }
       else
          *pbTimestamp = FALSE;

       //
       // Handle the data
       //
       HRESULT hr;
       ULONG ulInputNeeded = m_ulInputQuantumSize * (ulQuantaToProcess + m_ulWindowOverhead);
       assert(ulInputNeeded < BufferUsed());
       if (m_ulDataHead + ulInputNeeded <= m_ulBufferAllocated) {
          // No wraparound, everything is easy
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       }
       else { // The data we want to send wraps around the end
          // Q.: does it wrap around inside the window overhead area
          // or inside the main data area ?
          if (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize < m_ulBufferAllocated) {
             // The wraparound occurs inside the main data area.  Advance the
             // window overhead up to the wraparound point by processing some data.
             ULONG ulAdvance = m_ulBufferAllocated - (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize);
             assert(ulAdvance % m_ulInputQuantumSize == 0);
             ulAdvance /= m_ulInputQuantumSize; // convert to quanta
             assert(ulAdvance > 0);
             assert(ulAdvance < ulQuantaToProcess);
             hr = FBRProcess(ulAdvance,
                             m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                             pOut);
             if (FAILED(hr))
                return hr;
             NZWOConsume(ulAdvance);
             
             // Adjust stuff so that the code below can act
             // as if this extra process call never happened.
             pOut += m_ulOutputQuantumSize * ulAdvance;
             ulQuantaToProcess -= ulAdvance;
             assert(ulQuantaToProcess > 0);

             // Now the wraparound point should be exactly on the boundary
             // between window overhead and main data.
             assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize == m_ulBufferAllocated);
          } // wraparound in main data
          
          // When we get here, the wraparound point occurs somewhere inside
          // the window overhead area or right on the border between window overhead and
          // main data.
          assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize >= m_ulBufferAllocated);
          ULONG ulLookaheadToCopy = m_ulBufferAllocated - m_ulDataHead;
          
          // copy to the special area we reserved at the front
          memcpy(m_pCircularBuffer - ulLookaheadToCopy,
                 m_pCircularBuffer + m_ulDataHead,
                 ulLookaheadToCopy);
          
          // Now the block we are interested in is all in one piece
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer - ulLookaheadToCopy  + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       } // data handling - wraparound case
       return NOERROR;
    }
    void AllocateCircularBuffer() {
       // free any previously allocated input buffer
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;

       // bugbug: need a better way to decide this number
       m_ulBufferAllocated = max(m_ulInputQuantumSize * 16, 65536L);
       m_ulDataHead = m_ulDataTail = 0;

       // reserve room at the front for copying window overhead
       ULONG ulPrefix = m_ulWindowOverhead * m_ulInputQuantumSize;
       m_pAllocAddr = new BYTE[m_ulBufferAllocated + ulPrefix];
       if (!m_pAllocAddr)
          return;
       m_pCircularBuffer = m_pAllocAddr + ulPrefix;
       
       m_bParametersSet = TRUE;
    }
    BOOL NZWOQueryAccept() {
       // We are using a temp input buffer.  Is there room to append more ?
       // The answer really depends on how much data they will try to feed
       // us.  Without knowing the maximum input buffer size, we will accept
       // more if the input buffer is less than half full.
       if (2 * BufferUsed() < m_ulBufferAllocated)
          return TRUE;
       else
          return FALSE;
    }
    ULONG NZWOAvail() {
       ULONG ulInputQuantaAvailable = BufferUsed() / m_ulInputQuantumSize;
       if (ulInputQuantaAvailable > m_ulWindowOverhead)
          return ulInputQuantaAvailable - m_ulWindowOverhead;
       else
          return 0;
    }
    void NZWOConsume(ULONG ulN) { // the window overhead version
       assert(ulN * m_ulInputQuantumSize <= BufferUsed());
       m_ulDataHead += ulN * m_ulInputQuantumSize;
       if (m_ulDataHead > m_ulBufferAllocated) //wraparound
          m_ulDataHead -= m_ulBufferAllocated;
       
       // Advance the timestamp.
       // The same denominator is used for both timestamp and duration.
       m_rtTimestampNumerator += ulN * m_rtDurationNumerator;
    }
    ULONG BufferUsed() {
       if (m_ulDataTail >= m_ulDataHead)
          return m_ulDataTail - m_ulDataHead;
       else
          return m_ulBufferAllocated - (m_ulDataHead - m_ulDataTail);
    }
    void AppendData(BYTE *pData, ULONG ulSize) {
       if (m_ulDataTail + ulSize <= m_ulBufferAllocated) { // no wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, ulSize);
		  m_ulDataTail += ulSize;
       }
       else { // wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, m_ulBufferAllocated - m_ulDataTail);
          memcpy(m_pCircularBuffer, pData + m_ulBufferAllocated - m_ulDataTail, ulSize - (m_ulBufferAllocated - m_ulDataTail));
		  m_ulDataTail += ulSize;
		  m_ulDataTail -= m_ulBufferAllocated;
       }
    }
    void NZWODiscardData() {
       m_ulDataHead = m_ulDataTail = 0;
    }
    // End window overhead case code


protected:    
    //
    // To be implemebted by the derived class
    //
    virtual HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut) = 0;
    virtual HRESULT GetStreamingParams(
                       DWORD *pdwInputQuantumSize, // in bytes
                       DWORD *pdwOutputQuantumSize, // in bytes
                       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
                       DWORD *pdwLookbehind,
                       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
                       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
                    ) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }
    // Because AllocateStreamingResources() and FreeStreamingResources() are
    // optional, we have no place to call StopStreaming() from except the
    // destructor, and calling a virtual function from the destructor doesn't
    // work.  Without StopStreaming(), StartStreaming() is not much use either.
    // This sucks.  We need to change the IMediaObject spec and make those
    // calls mandatory.  Then we can implement StartStreaming/StopStraming.
    // virtual HRESULT StartStreaming() = 0;
    // virtual HRESULT StopStreaming() = 0;

private:

    BOOL m_bNewInput;

    // streaming parameters
    BOOL m_bParametersSet;
    ULONG m_ulInputQuantumSize;
    ULONG m_ulOutputQuantumSize;
    ULONG m_ulLookahead;
    ULONG m_ulLookbehind;
    ULONG m_ulWindowOverhead;
    REFERENCE_TIME m_rtDurationNumerator;
    REFERENCE_TIME m_rtDenominator;

    // streaming state
    BOOL m_bTimestamps; // we have seen at least one timestamp
    BOOL m_bDiscontinuity;
    BOOL m_bStreaming;
    
    // zero window overhead case input data
    IMediaBuffer *m_pMediaBuffer;
    BYTE *m_pData;
    ULONG m_ulData;
    ULONG m_ulUsed;
    BOOL m_bTimestamp; // timestamp on current buffer
    REFERENCE_TIME m_rtTimestamp;

    // window overhead case input data
    BYTE *m_pCircularBuffer;
    BYTE *m_pAllocAddr;
    ULONG m_ulBufferAllocated;
    ULONG m_ulDataHead;
    ULONG m_ulDataTail;
    REFERENCE_TIME m_rtTimestampNumerator; // uses the same denominator as duration

};


// CPCMDMO - base class for PCM audio transform filters.
// Helps non-converting PCM audio transforms with mediatype negotiation.
// Based on CFBRDMO - study that first.
//
// Derived class must implement:
//     FBRProcess()
// Deriver class may implement:
//   Discontinuity() // default implementaion does nothing
//   Init()          // default implementaion does nothing
//   GetPCMParams()    // default implementation proposes 44100/2/16
//   CheckPCMParams()  // default implementation accepts any 8/16 bit format
//   GetWindowParams()   // default implementation assumes no lookahead/lookbehind
//
// This class conveniently provides the following data members accessible
// by the derived class:
//   ULONG m_ulSamplingRate
//   ULONG m_cChannels
//   BOOL m_b8bit
//
#include <mmreg.h>
#include <uuids.h>

class CPCMDMO : public CFBRDMO
{
protected:
   //
   // implement pure virtual CFBRDMO methods
   //
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      return GetType(pmt, OutputType());
   }
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      return GetType(pmt, InputType());
   }
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, OutputType());
   }
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, InputType());
   }
   HRESULT Init() {
      return NOERROR;
   }
   HRESULT Discontinuity() {
      return NOERROR;
   }
   HRESULT GetStreamingParams(
              DWORD *pdwInputQuantumSize, // in bytes
              DWORD *pdwOutputQuantumSize, // in bytes
              DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
              DWORD *pdwMaxLookbehind,
              REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
              REFERENCE_TIME *prtDurationDenominator // optional, normally 1
           ) {
      // Sanity check: all of this should have been taken care of by base class
      DMO_MEDIA_TYPE* pmtIn =  InputType();
      DMO_MEDIA_TYPE* pmtOut = OutputType();
      if (!pmtIn || !pmtOut)
         return DMO_E_TYPE_NOT_SET;
      if (CheckType(pmtIn, NULL) || CheckType(pmtOut, pmtIn))
         return DMO_E_TYPE_NOT_ACCEPTED;
      
      WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmtIn->pbFormat;
      
      m_b8bit          = (pWave->wBitsPerSample == 8);
      m_cChannels      = pWave->nChannels;
      m_ulSamplingRate = pWave->nSamplesPerSec;
      
      *pdwInputQuantumSize    = pWave->nBlockAlign;
      *pdwOutputQuantumSize   = pWave->nBlockAlign;
      *prtQuantumDuration     = 10000000; // rt units per sec
      *prtDurationDenominator = pWave->nSamplesPerSec;
      
      GetWindowParams(pdwMaxLookahead, pdwMaxLookbehind);
      return NOERROR;
   }

protected:
   //
   // Methods to be overridden by derived class
   //
   // We use this to get lookahead/lookbehind from the derived class
   virtual void GetWindowParams(DWORD *pdwMaxLookahead,
                                DWORD *pdwMaxLookbehind) {
      *pdwMaxLookahead = 0;
      *pdwMaxLookbehind = 0;
   }
   // derived class can override these if it has specific requirements
   virtual void GetPCMParams(BOOL* pb8bit, DWORD* pcChannels, DWORD* pdwSamplesPerSec) {
      // These values are what the DMO will advertise in its media type.
      // Specifying them here does not mean that this is the only acceptable
      // combination - CheckPCMParams() is the ultimate authority on what we will
      // accept.
      *pb8bit = FALSE;
      *pcChannels = 2;
      *pdwSamplesPerSec = 44100;
   }
   virtual BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
      // Default implementation accepts anything.  Override if you have specific
      // requirements WRT sampling rate, number of channels, or bit depth.
      return TRUE;
   }
   
private:
   //
   // private helpers
   //
   HRESULT GetType(DMO_MEDIA_TYPE* pmt, const DMO_MEDIA_TYPE *pmtOther) {
      // If the other type is set, enumerate that.  Otherwise propose 44100/2/16.
      if (pmtOther) {
         MoCopyMediaType(pmt, pmtOther);
         return NOERROR;
      }
   
      HRESULT hr = MoInitMediaType(pmt, sizeof(WAVEFORMATEX));
      if (FAILED(hr))
         return hr;
   
      pmt->majortype  = MEDIATYPE_Audio;
      pmt->subtype    = MEDIASUBTYPE_PCM;
      pmt->formattype = FORMAT_WaveFormatEx;
   
      WAVEFORMATEX* pWave = (WAVEFORMATEX*) pmt->pbFormat;
      pWave->wFormatTag = WAVE_FORMAT_PCM;
   
      BOOL b8bit;
      DWORD cChannels;
      GetPCMParams(&b8bit, &cChannels, &(pWave->nSamplesPerSec));
      (pWave->nChannels) = (unsigned short)cChannels;
      pWave->wBitsPerSample = b8bit ? 8 : 16;
      pWave->nBlockAlign = pWave->nChannels * pWave->wBitsPerSample / 8;
      pWave->nAvgBytesPerSec = pWave->nSamplesPerSec * pWave->nBlockAlign;
      pWave->cbSize = 0;
   
      return NOERROR;
   }
   HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DMO_MEDIA_TYPE *pmtOther) {
      // verify that this is PCM with a WAVEFORMATEX format specifier
      if ((pmt->majortype  != MEDIATYPE_Audio) ||
          (pmt->subtype    != MEDIASUBTYPE_PCM) ||
          (pmt->formattype != FORMAT_WaveFormatEx) ||
          (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
          (pmt->pbFormat == NULL))
         return DMO_E_TYPE_NOT_ACCEPTED;
      
      // If other type set, accept only if identical to that.  Otherwise accept
      // any standard PCM audio.
      if (pmtOther) {
         if (memcmp(pmt->pbFormat, pmtOther->pbFormat, sizeof(WAVEFORMATEX)))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      else {
         WAVEFORMATEX* pWave = (WAVEFORMATEX*)pmt->pbFormat;
         if ((pWave->wFormatTag != WAVE_FORMAT_PCM) ||
             ((pWave->wBitsPerSample != 8) && (pWave->wBitsPerSample != 16)) ||
             (pWave->nBlockAlign != pWave->nChannels * pWave->wBitsPerSample / 8) ||
             (pWave->nAvgBytesPerSec != pWave->nSamplesPerSec * pWave->nBlockAlign) ||
             !CheckPCMParams((pWave->wBitsPerSample == 8), pWave->nChannels, pWave->nSamplesPerSec))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      return NOERROR;
   }

protected:
   // format info - the derived class may look at these (but no modify)
   ULONG m_ulSamplingRate;
   ULONG m_cChannels;
   BOOL m_b8bit;
};


//
// CGenericDMO - generic DMO base class.  This is currently the only base
// class for DMOs that have multiple inputs or multiple outputs.
//
// This base class tries to be reasonably generic.  The derived class reports
// how many streams it supports and describes each stream by calling
// CreateInputStreams() and CreateOutputStreams().  Each of these functions
// takes an array of STREAMDESCRIPTOR structures, each of which poits to an
// array of FORMATENTRY structures.
//
// This base class uses CInputStream and COutputStream classes (both derived
// from CStream) to keep track of input and output stream.  However, these
// objects are not visible to the derived class - the derived class only sees
// stream IDs.
//
// One limitation of the scheme use here is that the derived class cannot
// override the GetType/SetType methods individually for each stream.  It must
// either (a) live with a static, finite set of types communicated via the
// STREAMDESCRIPTOR structure, or (b) override all IMediaObject type methods
// and handle type negotiation for all streams itself.
//
// Processing occurs when the base class calles DoProcess (overridden by the
// derived class).  DoProcess receives an array of input buffer structs and
// an array of output buffer structs.  The base class takes care of talking
// to IMediaBuffers, so the derived class only sees actual data pointers.
//

// flags used to communicate with the derived class
enum _INPUT_STATUS_FLAGS {
   INPUT_STATUSF_RESIDUAL // cannot be further processed w/o additional input
};
                            
// These are used to pass buffers between this class and the derived class.
typedef struct _INPUTBUFFER {
   BYTE *pData;                 // [in] - if NULL, the rest are garbage
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [in] - DMO_INPUT_DATA_BUFFERF_XXX
   DWORD dwStatus;              // [out] - INPUT_STATUSF_XXX from above
   REFERENCE_TIME rtTimestamp;  // [in]
   REFERENCE_TIME rtTimelength; // [in]
} INPUTBUFFER, *PINPUTBUFFER;
typedef struct _OUTPUTBUFFER {
   BYTE *pData;                 // [in]
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [out] - DMO_OUTPUT_DATA_BUFFERF_XXX
   REFERENCE_TIME rtTimestamp;  // [out]
   REFERENCE_TIME rtTimelength; // [out]
} OUTPUTBUFFER, *POUTPUTBUFFER;

// Used by derived class to describe the format supported by each stream
typedef struct _FORMATENTRY
{
    const GUID *majortype;
    const GUID *subtype;
    const GUID *formattype;
    DWORD cbFormat;
    BYTE* pbFormat;
} FORMATENTRY;

// These are used by the derived class to described its streams
typedef struct _INPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
   BOOL         bHoldsBuffers;
   DWORD        dwMaxLookahead; // used if HOLDS_BUFFERS set
} INPUTSTREAMDESCRIPTOR;
typedef struct _OUTPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
} OUTPUTSTREAMDESCRIPTOR;

// Common input/output stream stuff
class CStream {
public:
    DMO_MEDIA_TYPE       m_MediaType;
    BOOL                m_bEOS;
    BOOL                m_bTypeSet;

    DWORD        m_cFormats;
    FORMATENTRY *m_pFormats;
    DWORD        m_dwMinBufferSize;

    //  Should really pass in a format type list
    CStream()
    {
        MoInitMediaType(&m_MediaType, 0);
        m_bTypeSet = FALSE;
        Flush();
    }
    ~CStream()
    {
        MoFreeMediaType(&m_MediaType);
    }
    HRESULT Flush() {
       m_bEOS = FALSE;
       return NOERROR;
    }
    HRESULT StreamInfo(unsigned long *pdwFlags)
    {
       if (pdwFlags == NULL) {
           return E_POINTER;
       }
       *pdwFlags = 0;
       return S_OK;
    }
    HRESULT GetType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt)
    {
        if (ulTypeIndex >= m_cFormats) {
            return E_INVALIDARG;
        }
        //  Just return our types
        MoInitMediaType(pmt, m_pFormats[ulTypeIndex].cbFormat);
        pmt->majortype  = *m_pFormats[ulTypeIndex].majortype;
        pmt->subtype    = *m_pFormats[ulTypeIndex].subtype;
        pmt->formattype = *m_pFormats[ulTypeIndex].formattype;
        memcpy(pmt->pbFormat, m_pFormats[ulTypeIndex].pbFormat, m_pFormats[ulTypeIndex].cbFormat);
        return S_OK;
    }
    HRESULT GetCurrentType(DMO_MEDIA_TYPE *pmt)
    {
        if (NULL == pmt) {
            return E_POINTER;
        }

        if (m_bTypeSet) {
           //  BUGBUG check success
           MoCopyMediaType(pmt, &(m_MediaType));
           return S_OK;
        }
        else
           return DMO_E_TYPE_NOT_SET;
    }
    HRESULT SetType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        //  Need to check this
        HRESULT hr = CheckType(pmt, 0);
        if (FAILED(hr)) {
            return hr;
        }
        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR; // check konly
        }
        //  BUGBUG - check success
        MoCopyMediaType(&m_MediaType, pmt);

        m_bTypeSet = TRUE;;
        return S_OK;
    }
    HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        if (pmt == NULL) {
            return E_POINTER;
        }
        //if (dwFlags & ~DMO_SET_TYPEF_NOT_PARTIAL)
        //    return E_INVALIDARG;

        //  Default - check GUIDs

        bool bMatched = false;
        for (DWORD i = 0; i < m_cFormats; i++) {
            const FORMATENTRY *pFormat = &(m_pFormats[i]);
            if (pmt->majortype  == *(pFormat->majortype) &&
                pmt->subtype    == *(pFormat->subtype) &&
                pmt->formattype == *(pFormat->formattype)) {
                bMatched = true;
                break;
            }
        }

        if (bMatched) {
            return S_OK;
        } else {
            return DMO_E_INVALIDTYPE;
        }
    }
    HRESULT SizeInfo(ULONG *plSize, ULONG *plAlignment)
    {
        if (plSize == NULL || plAlignment == NULL) {
            return E_POINTER;
        }

        *plAlignment = 1;
        *plSize      = m_dwMinBufferSize;
        return S_OK;
    }
};

// Input stream specific stuff
class CInputStream : public CStream {
public:
    BOOL         m_bHoldsBuffers;
    DWORD        m_dwMaxLookahead; // used if HOLDS_BUFFERS set

    // Current input sample
    IMediaBuffer *m_pMediaBuffer;
    DWORD m_dwFlags; // discontinuity, etc.
    REFERENCE_TIME m_rtTimestamp;
    REFERENCE_TIME m_rtTimelength;
    BYTE *m_pData;
    DWORD m_cbSize;
    DWORD m_cbUsed;

    // residual
    BYTE *m_pbResidual;
    DWORD m_cbResidual;
    DWORD m_cbResidualBuffer;

    // temporary buffer for handling the residual
    BYTE *m_pbTemp;

   HRESULT Flush() {
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      return CStream::Flush();
   }
   CInputStream() {
      m_pMediaBuffer = NULL;
      m_pbResidual = NULL;
      m_pbTemp = NULL;
   }
   ~CInputStream() {
      if (m_pMediaBuffer)
         m_pMediaBuffer->Release();
      if (m_pbResidual)
         delete[] m_pbResidual;
   }
   HRESULT StreamInfo(DWORD *pdwFlags) {
      HRESULT hr = CStream::StreamInfo(pdwFlags);
      if (FAILED(hr))
         return hr;
      if (m_bHoldsBuffers)
         *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
      return NOERROR;
   }
   HRESULT Init(INPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      m_bHoldsBuffers = pDescriptor->bHoldsBuffers;
      m_dwMaxLookahead = pDescriptor->dwMaxLookahead;
      
      // Just in case Init is called multiple times:
      // delete any preexisting stuff.
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      if (m_pbResidual) {
         delete[] m_pbResidual;
         m_pbResidual = NULL;
      }

      m_cbResidual = 0;
      m_cbResidualBuffer = m_dwMinBufferSize * 2; // enough ?
      m_pbResidual = new BYTE[m_cbResidualBuffer];

      return NOERROR;
   }
   HRESULT InputStatus(DWORD *pdwStatus) {
       // objects that hold buffers must implement InputStatus themselves
      assert(!m_bHoldsBuffers);
      *pdwStatus = 0;
      if (!m_pMediaBuffer)
         *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
      return NOERROR;
   }
   HRESULT Deliver(
      IMediaBuffer *pBuffer, // [in], must not be NULL
      DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
      REFERENCE_TIME rtTimestamp, // [in], valid if flag set
      REFERENCE_TIME rtTimelength // [in], valid if flag set
   ) {
      if (!pBuffer)
         return E_POINTER;
       // objects that hold buffers must implement Deliver themselves
      assert(!m_bHoldsBuffers);
      DWORD dwStatus = 0;
      InputStatus(&dwStatus);
      if (!(dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA))
         return DMO_E_NOTACCEPTING;
      assert(!m_pMediaBuffer); // can't hold multiple buffers

      //Deal with the IMediaBuffer
      HRESULT hr;
      hr = pBuffer->GetBufferAndLength(&m_pData, &m_cbSize);
      if (FAILED(hr))
         return hr;

      if (!m_cbSize) // empty buffer
         return S_FALSE; // no data

      pBuffer->AddRef();
      m_pMediaBuffer = pBuffer;
      m_dwFlags = dwFlags;
      m_rtTimestamp = rtTimestamp;
      m_rtTimelength = rtTimelength;
      m_cbUsed = 0;
      return NOERROR;
   }
   
   //
   // Fetch data from the currently held IMediaBuffer plus any residual
   //
   HRESULT PrepareInputBuffer(INPUTBUFFER *pBuffer)
   {
      // Q.: do we even have any data to give it ?
      if (m_pMediaBuffer) {
         // Is there a residual we need to feed first ?
         if (m_cbResidual) {
            // Yes, prepend the residual to the new input

            // If we have used some of the input buffer by now, we
            // should have also used up any residual with that.
            assert(m_cbUsed == 0);

            // compute how many bytes total we are going to send
            pBuffer->cbSize = m_cbResidual
                                      + m_cbSize;
            
            // Make sure we have at least dwMinBufferSize bytes of data.
            // We really should - the input buffer alone ought to be at
            // least that big.
            assert(pBuffer->cbSize >
                   m_dwMinBufferSize);

            // Is the residual buffer big enough to hold the residual plus
            // all of the new buffer ?
            if (pBuffer->cbSize <= m_cbResidualBuffer) {
               // Yes - wonderful, we can use the residual buffer
               memcpy(m_pbResidual + m_cbResidual,
                      m_pData,
                      m_cbSize);
               pBuffer->pData = m_pbResidual;
            }
            else {
               // No - allocate a sufficiently large temporary buffer.
               // This is supposed to be a rare case.
               m_pbTemp = new BYTE[pBuffer->cbSize];
               if (m_pbTemp == NULL)
                  return E_OUTOFMEMORY;
               // copy the residual
               memcpy(m_pbTemp,
                      m_pbResidual,
                      m_cbResidual);
               // append the new buffer
               memcpy(m_pbTemp + m_cbResidual,
                      m_pData,
                      m_cbSize);

               // set the buffer pointer to our temp buffer
               pBuffer->pData = m_pbTemp;
            }

            // BUGBUG - is this the correct way to handle timestamps &
            // discontinuities when handling a residual ?
            pBuffer->dwFlags = 0; 
         }
         else { // no residual
            pBuffer->pData = m_pData + m_cbUsed;
            pBuffer->cbSize = m_cbSize - m_cbUsed;
            pBuffer->dwFlags = m_dwFlags; 
            pBuffer->rtTimestamp = m_rtTimestamp;
            pBuffer->rtTimelength= m_rtTimelength;
         }
         pBuffer->cbUsed = 0; // derived class should set this
         pBuffer->dwStatus = 0; // derived class should set this
      }
      else {
         pBuffer->pData = NULL;
         pBuffer->cbSize = 0;
      }
      return NOERROR;
   }
   
   //
   // Save any residual and release the IMediaBuffer as appropriate.
   // Returns TRUE if there is enough data left to call ProcesInput again.
   //
   BOOL PostProcessInputBuffer(INPUTBUFFER *pBuffer)
   {
      BOOL bRet = FALSE;
      // did we even give this stream anything ?
      if (m_pMediaBuffer) {
         // Yes, but did it eat any of it ?
         if (pBuffer->cbUsed) {
            // Did we even get past the residual
            if (pBuffer->cbUsed > m_cbResidual) {
               // Yes - reflect this in the current buffer's cbUsed.
               m_cbUsed += (pBuffer->cbUsed - m_cbResidual);
               m_cbResidual = 0;
            }
            else { 
               // No - just subtract from the residual.
               // This is a rather silly case.
               m_cbResidual -= pBuffer->cbUsed;
               memmove(m_pbResidual,
                       m_pbResidual + pBuffer->cbUsed,
                       m_cbResidual);
            }
         }

         // Is there enough left to feed again the next time ?
         if ((m_cbSize - m_cbUsed <
              m_dwMinBufferSize) 
              || (pBuffer->dwStatus & INPUT_STATUSF_RESIDUAL)) {
            // No - copy the residual and release the buffer
            memcpy(m_pbResidual,
                   m_pData + m_cbUsed,
                   m_cbSize - m_cbUsed);
            m_cbResidual
              = pBuffer->cbSize - pBuffer->cbUsed;
            m_pMediaBuffer->Release();
            m_pMediaBuffer = NULL;
         }
         else { // Yes - need another Process call to eat remaining input
            bRet = TRUE;
         }

         // Free any temporary buffer we may have used - rare case
         if (m_pbTemp) {
            delete[] m_pbTemp;
            m_pbTemp = NULL;
         }
      }
      return bRet;
   }
   HRESULT Discontinuity() {
      // BUGBUG - implement
      // m_bDiscontinuity = TRUE;
      return NOERROR;
   }
   HRESULT SizeInfo(ULONG *pulSize,
                    ULONG *pulMaxLookahead,
                    ULONG *pulAlignment) {
      HRESULT hr = CStream::SizeInfo(pulSize, pulAlignment);
      if (FAILED(hr))
         return hr;

      if (m_bHoldsBuffers)
         *pulMaxLookahead = m_dwMaxLookahead;
      else
         *pulMaxLookahead = *pulSize;
      return NOERROR;
   }
};

// Output stream specific stuff
class COutputStream : public CStream {
public:
   BOOL m_bIncomplete;
   DWORD m_cbAlreadyUsed; // temp per-stream variable used during Process
   
   HRESULT Init(OUTPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      return NOERROR;
   }

   //
   // Initialize the OUTPUTBUFFER struct with info from the IMediaBuffer 
   //
   HRESULT PrepareOutputBuffer(OUTPUTBUFFER *pBuffer, IMediaBuffer *pMediaBuffer, BOOL bNewInput)
   {
      //
      // See if the caller supplied an output buffer
      //
      if (pMediaBuffer == NULL) {
         // This is allowed to be NULL only if (1) the object did not set
         // the INCOMPLETE flag for this stream during the last Process
         // call, and (2) no new input data has been supplied to the object
         // since the last Process call.  
         if (bNewInput)
            return E_POINTER;
         if (m_bIncomplete)
            return E_POINTER;

         // ok - initialize assuming no buffer
         pBuffer->cbSize = 0;
         pBuffer->pData = NULL;
      }
      else { // the IMediaBuffer is not NULL - deal with it
         HRESULT hr;
         hr = pMediaBuffer->GetMaxLength(&pBuffer->cbSize);
         if (FAILED(hr))
            return hr;

         hr = pMediaBuffer->GetBufferAndLength(
                 &(pBuffer->pData),
                 &(m_cbAlreadyUsed));
         if (FAILED(hr))
            return hr;

         // Check current size - should we even bother with this ?
         if (m_cbAlreadyUsed) {
            if (m_cbAlreadyUsed >= pBuffer->cbSize)
               return E_INVALIDARG; // buffer already full ?!?
            pBuffer->cbSize -= m_cbAlreadyUsed;
            pBuffer->pData += m_cbAlreadyUsed;
         }
      }
      
      // It is really the derived class's job to set these, but we
      // will be nice to it and initialize them anyway just in case.
      pBuffer->cbUsed = 0;
      pBuffer->dwFlags = 0;

      return NOERROR;
   }

   //
   // Copy the OUTPUTBUFFER back into the DMO_OUTPUT_DATA_BUFFER (yawn)
   //
   void PostProcessOutputBuffer(OUTPUTBUFFER *pBuffer, DMO_OUTPUT_DATA_BUFFER *pDMOBuffer, BOOL bForceIncomplete) {
      assert(pBuffer->cbUsed <= pBuffer->cbSize);
      if (pDMOBuffer->pBuffer)
         pDMOBuffer->pBuffer->SetLength(pBuffer->cbUsed + m_cbAlreadyUsed);
      pDMOBuffer->dwStatus = pBuffer->dwFlags;
      pDMOBuffer->rtTimestamp = pBuffer->rtTimestamp;
      pDMOBuffer->rtTimelength = pBuffer->rtTimelength;

      // Even if the derived class did not set INCOMPLETE, we may need to
      // set it anyway if some input buffer we are holding still has
      // enough data to call Process() again.
      if (bForceIncomplete)
         pDMOBuffer->dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

      // remember this output stream's INCOMPLETE state
      if (pDMOBuffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
         m_bIncomplete = TRUE;
      else
         m_bIncomplete = FALSE;
   }
};

// Code that goes at the beginning of every IMediaObject method
#define INPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulInputStreamIndex >= m_nInputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    CInputStream *pStream = &m_pInputStreams[ulInputStreamIndex]

#define OUTPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulOutputStreamIndex >= m_nOutputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    COutputStream *pStream = &m_pOutputStreams[ulOutputStreamIndex]


class CGenericDMO : public IMediaObject
{
public:
    CGenericDMO() {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
       m_nInputStreams = 0;
       m_nOutputStreams = 0;
    }
#ifdef DMO_NOATL
    ~CGenericDMO() {
       DeleteCriticalSection(&m_cs);
    }
#endif
    
public:
    //
    // Implement IMediaObject methods
    //
    STDMETHODIMP GetInputStreamInfo(ULONG ulInputStreamIndex, DWORD *pdwFlags)
    {
       INPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulOutputStreamIndex, DWORD *pdwFlags)
    {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulInputStreamIndex,
        DWORD *pdwStatus
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->InputStatus(pdwStatus);
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME *prtLatency) {
       // BUGBUG - I don't know what to do with this right now.
       // Punt to the derived class ?
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP ProcessInput(
        DWORD ulInputStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Deliver(pBuffer, dwFlags, rtTimestamp, rtTimelength);
    }
    STDMETHODIMP Discontinuity(ULONG ulInputStreamIndex) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
        
       //  Flush all the streams
       ULONG i;
       for (i = 0; i < m_nInputStreams; i++) {
          m_pInputStreams[i].Flush();
       }
       for (i = 0; i < m_nOutputStreams; i++) {
          m_pOutputStreams[i].Flush();
       }
       return S_OK;
    }

    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = m_nInputStreams;
        *pulNumberOfOutputStreams = m_nOutputStreams;
        return S_OK;
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       CDMOAutoLock l(&m_cs);
       if (ulOutputBufferCount != m_nOutputStreams)
          return E_INVALIDARG;

       HRESULT hr;
       DWORD c;
 
       // Prepare the input buffers
       for (c = 0; c < m_nInputStreams; c++) {
          // objects that hold buffers must implement Process themselves
          assert(!m_pInputStreams[c].m_bHoldsBuffers);
          hr = m_pInputStreams[c].PrepareInputBuffer(&m_pInputBuffers[c]);
          if (FAILED(hr))
             return hr;
       }
 
       //
       // Prepare the output buffers
       //
       for (c = 0; c < m_nOutputStreams; c++) {
          hr = m_pOutputStreams[c].PrepareOutputBuffer(&m_pOutputBuffers[c], pOutputBuffers[c].pBuffer, m_bNewInput);
          if (FAILED(hr))
             return hr;
       }

       hr = DoProcess(m_pInputBuffers,m_pOutputBuffers);
       if (FAILED(hr))
          return hr; // BUGBUG - don't just "return hr", do something !

       // post-process input buffers
       BOOL bSomeInputStillHasData = FALSE;
       for (c = 0; c < m_nInputStreams; c++) {
          if (m_pInputStreams[c].PostProcessInputBuffer(&m_pInputBuffers[c]))
             bSomeInputStillHasData = TRUE;
       }

       // post-process output buffers
       for (c = 0; c < m_nOutputStreams; c++) {
          m_pOutputStreams[c].PostProcessOutputBuffer(&m_pOutputBuffers[c],
                                                      &pOutputBuffers[c],
                                                      bSomeInputStillHasData);
       }

       m_bNewInput = FALSE;
       return NOERROR;
    }

protected:
    //
    // These are called by the derived class at initialization time
    //
    HRESULT CreateInputStreams(INPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pInputStreams = new CInputStream[cStreams];

       if (m_pInputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pInputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pInputStreams;
             return hr;
          }
       }

       m_pInputBuffers = new INPUTBUFFER[cStreams];
       if (!m_pInputBuffers) {
          delete[] m_pInputStreams;
          return E_OUTOFMEMORY;
       }

       m_nInputStreams = cStreams;
       return NOERROR;
    }
    HRESULT CreateOutputStreams(OUTPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pOutputStreams = new COutputStream[cStreams];

       if (m_pOutputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pOutputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pOutputStreams;
             return hr;
          }
       }
	   
       m_pOutputBuffers = new OUTPUTBUFFER[cStreams];
       if (!m_pOutputBuffers) {
          delete[] m_pOutputStreams;
          return E_OUTOFMEMORY;
       }

       m_nOutputStreams = cStreams;
       return NOERROR;
    }

    virtual HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER *) = 0;

private:

    ULONG           m_nInputStreams;
    CInputStream*   m_pInputStreams;
    ULONG           m_nOutputStreams;
    COutputStream*  m_pOutputStreams;

    INPUTBUFFER*    m_pInputBuffers;
    OUTPUTBUFFER*   m_pOutputBuffers;

    BOOL m_bNewInput;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};

#endif // __DMOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\duration.h ===
#ifndef _DURATION_TOOL_
#define _DURATION_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CDurationTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicDurationTool

{
public:
	CDurationTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicDurationTool
	STDMETHODIMP SetScale(float flScale) ;
	STDMETHODIMP GetScale(float * pflScale);
};

#endif // _DURATION_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard crap for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#ifndef XBOX
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif // ! XBOX
#endif // ! UNDER_CE
#endif // UNICODE

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
#ifndef XBOX
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

#endif // ! XBOX

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
#ifndef XBOX
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

#endif // ! XBOX

    return S_OK;
}

#ifndef XBOX

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}

#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\echo.cpp ===
// Echo.cpp : Implementation of CEchoTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#ifdef XBOX
#include <xtl.h>
#endif // XBOX

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "echo.h"
#include "toolhelp.h"


CEchoTool::CEchoTool()
{
    ParamInfo Params[DMUS_ECHO_PARAMCOUNT] = 
    {
        { DMUS_ECHO_REPEAT, MPT_INT,MP_CAPS_ALL,0,100,2,
            L"Repeats",L"Repeat",NULL },            // Repeat - twice by default
        { DMUS_ECHO_DECAY, MPT_INT,MP_CAPS_ALL,0,100,12,
            L"dB",L"Decay",NULL },           // Decay - 12 db by default
        { DMUS_ECHO_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MS,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Delay Units",L"Milliseconds,Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_ECHO_DELAY, MPT_INT,MP_CAPS_ALL,1,1000,1,
            L"",L"Delay",NULL},   // Delay - 1 grid note by default
        { DMUS_ECHO_GROUPOFFSET, MPT_INT,MP_CAPS_ALL,0,100,0,
            L"Channel Groups",L"Channel Offset", NULL },            // Group offset - none by default
        { DMUS_ECHO_TYPE, MPT_ENUM,MP_CAPS_ALL, DMUS_ECHOT_FALLING,DMUS_ECHOT_RISING_CLIP,DMUS_ECHOT_FALLING_CLIP,
            L"",L"Type",L"Falling,Falling & Truncated,Rising,Rising & Truncated"} // Type - falling by default
    };
    InitParams(DMUS_ECHO_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CEchoTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEchoTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CEchoTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicEchoTool)
	{
		*ppv = static_cast<IDirectMusicEchoTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CEchoTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicEchoTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CEchoTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CEchoTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_ECHO_CHUNK))
	{
        DMUS_IO_ECHO_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_ECHO_REPEAT,(float) Header.dwRepeat);
            SetParam(DMUS_ECHO_DECAY,(float) Header.dwDecay);
            SetParam(DMUS_ECHO_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_ECHO_DELAY,(float) Header.dwDelay);
            SetParam(DMUS_ECHO_GROUPOFFSET,(float) Header.dwGroupOffset);
            SetParam(DMUS_ECHO_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CEchoTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_ECHO_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_ECHO_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_ECHO_HEADER Header;
        GetParamInt(DMUS_ECHO_REPEAT,MAX_REF_TIME,(long *) &Header.dwRepeat);
        GetParamInt(DMUS_ECHO_DECAY,MAX_REF_TIME,(long *) &Header.dwDecay);
        GetParamInt(DMUS_ECHO_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_ECHO_DELAY,MAX_REF_TIME,(long *) &Header.dwDelay);
        GetParamInt(DMUS_ECHO_GROUPOFFSET,MAX_REF_TIME,(long *) &Header.dwGroupOffset);
        GetParamInt(DMUS_ECHO_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CEchoTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_ECHO_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CEchoTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_EchoPage;
	return NOERROR;
}


static long glResTypes[DMUS_TIME_UNIT_COUNT] = 
{ 1,    // DMUS_TIME_UNIT_MS
  1,    // DMUS_TIME_UNIT_MTIME 
  384,  // DMUS_TIME_UNIT_GRID
  768,  // DMUS_TIME_UNIT_BEAT
  3072, // DMUS_TIME_UNIT_BAR
  32,   // DMUS_TIME_UNIT_64T
  48,   // DMUS_TIME_UNIT_64
  64,   // DMUS_TIME_UNIT_32T  
  96,   // DMUS_TIME_UNIT_32 
  128,  // DMUS_TIME_UNIT_16T     
  192,  // DMUS_TIME_UNIT_16     
  256,  // DMUS_TIME_UNIT_8T    
  384,  // DMUS_TIME_UNIT_8         
  512,  // DMUS_TIME_UNIT_4T  
  768,  // DMUS_TIME_UNIT_4         
  1024, // DMUS_TIME_UNIT_2T   
  1536, // DMUS_TIME_UNIT_2   
  2048, // DMUS_TIME_UNIT_1T
  3072  // DMUS_TIME_UNIT_1
};

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CEchoTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    // We need to know if there's an offset, because that determines which kinds of messages we process.
    long lGroupOffset;
    GetParamInt(DMUS_ECHO_GROUPOFFSET,rtTime,&lGroupOffset);
    lGroupOffset *= 16; // Convert to pchannels.
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lRepeats, lDecay, lTimeUnit, lDelay, lType;
            
            GetParamInt(DMUS_ECHO_REPEAT,rtTime,&lRepeats);
            GetParamInt(DMUS_ECHO_DELAY,rtTime,&lDelay);
            GetParamInt(DMUS_ECHO_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_ECHO_DECAY,rtTime,&lDecay);
            GetParamInt(DMUS_ECHO_TYPE,rtTime,&lType);
            long lStartVolume;
            if (lTimeUnit > DMUS_TIME_UNIT_BAR)
            {
                lDelay *= glResTypes[lTimeUnit];
            }
            else if (lTimeUnit >= DMUS_TIME_UNIT_GRID)
            {
                DMUS_TIMESIGNATURE TimeSig;
                if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
                {
                    DWORD dwBeat = (4 * 768) / TimeSig.bBeat;
                    if (lTimeUnit == DMUS_TIME_UNIT_BEAT)
                    {
                        lDelay *= dwBeat;
                    }
                    else if (lTimeUnit == DMUS_TIME_UNIT_GRID)
                    {
                        lDelay *= (dwBeat / TimeSig.wGridsPerBeat);
                    }
                    else 
                    {
                        lDelay *= (dwBeat * TimeSig.bBeatsPerMeasure);
                    }
                }
            }
            lDecay *= 100;  // We'll do our math in 1/100ths of a dB.
            if (lType & DMUS_ECHOT_RISING)
            {
                lStartVolume = MidiToVolume(pNote->bVelocity) - (lRepeats * lDecay);
                lDecay = -lDecay;
            }
            else
            {
                lStartVolume = MidiToVolume(pNote->bVelocity);
            }
            long lCount;
            for (lCount = 0; lCount <= lRepeats; lCount++)
            {
                DMUS_NOTE_PMSG *pCopy = NULL;
                if (lCount > 0)
                {
                    pNote->dwSize = sizeof (DMUS_NOTE_PMSG);
                    pPerf8->ClonePMsg((DMUS_PMSG *) pNote,(DMUS_PMSG **)&pCopy);
                }
                else
                {
                    pCopy = pNote;
                }
                if (pCopy)
                {
                    pCopy->bVelocity = VolumeToMidi(lStartVolume - (lCount * lDecay));
                    pCopy->dwPChannel += (lCount * lGroupOffset);
                    if (lTimeUnit != DMUS_TIME_UNIT_MS)
                    {
                        pCopy->mtTime += (lCount * lDelay);
                        pCopy->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                    else
                    {
                        pCopy->rtTime += (lCount * lDelay * 10000); // Convert from ms to rt.
                        pCopy->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    }
                    if (lType & DMUS_ECHOT_FALLING_CLIP)
                    {
                        if (pCopy->mtDuration <= lDecay)
                        {
                            pCopy->mtDuration = lDecay - 1;
                        }
                    }
                    if (lCount) // Don't send the original note. We need it for clone and
                                // it will be requeued on DMUS_S_REQUEUE anyway.
                    {
                        if (SUCCEEDED(pCopy->pGraph->StampPMsg((DMUS_PMSG *)pCopy))) 
                        {
                            pPerf->SendPMsg((DMUS_PMSG *)pCopy);
                        }
                        else
                        {
                            pPerf->FreePMsg((DMUS_PMSG *)pCopy);
                        }
                    }
                }
            }
            pPerf8->Release();
        }
    }
    else if (lGroupOffset > 0)
    {
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            // If the echoes are being sent to other pchannels, duplicate all other events
            // so they go down those pchannels too.
            long lRepeats, lTimeUnit, lDelay;
            GetParamInt(DMUS_ECHO_REPEAT,rtTime,&lRepeats);
            GetParamInt(DMUS_ECHO_DELAY,rtTime,&lDelay);
            GetParamInt(DMUS_ECHO_TIMEUNIT,rtTime,&lTimeUnit);
            if (lTimeUnit > DMUS_TIME_UNIT_MS)
            {
                lDelay *= glResTypes[lTimeUnit];
            }
            long lCount;
            for (lCount = 0; lCount <= lRepeats; lCount++)
            {
                DMUS_PMSG *pCopy = NULL;
                if (lCount > 0)
                {
                    pPerf8->ClonePMsg(pPMsg,&pCopy);
                }
                else
                {
                    pCopy = pPMsg;
                }
                if (pCopy)
                {
                    pCopy->dwPChannel += (lCount * lGroupOffset);
                    if (lTimeUnit != DMUS_TIME_UNIT_MS)
                    {
                        pCopy->mtTime += (lCount * lDelay);
                        pCopy->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                    else
                    {
                        pCopy->rtTime += (lCount * lDelay * 10000); // Convert from ms to rt.
                        pCopy->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    }
                    if (lCount) // Don't send the original note. We need it for clone and
                                // it will be requeued on DMUS_S_REQUEUE anyway.
                    {
                        if (SUCCEEDED(pCopy->pGraph->StampPMsg((DMUS_PMSG *)pCopy))) 
                        {
                            pPerf->SendPMsg((DMUS_PMSG *)pCopy);
                        }
                        else
                        {
                            pPerf->FreePMsg((DMUS_PMSG *)pCopy);
                        }
                    }
                }
            }
            pPerf8->Release();
        }
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CEchoTool::Clone( IDirectMusicTool ** ppTool)

{
    CEchoTool *pNew = new CEchoTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CEchoTool::SetRepeat(DWORD dwRepeat) 
{
    return SetParam(DMUS_ECHO_REPEAT,(float) dwRepeat);
}

STDMETHODIMP CEchoTool::SetDecay(DWORD dwDecay) 
{
    return SetParam(DMUS_ECHO_DECAY,(float) dwDecay);
}

STDMETHODIMP CEchoTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_ECHO_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CEchoTool::SetDelay(DWORD dwDelay) 
{
    return SetParam(DMUS_ECHO_DELAY,(float) dwDelay);
}

STDMETHODIMP CEchoTool::SetGroupOffset(DWORD dwGroupOffset) 
{
    return SetParam(DMUS_ECHO_GROUPOFFSET,(float) dwGroupOffset);
}

STDMETHODIMP CEchoTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_ECHO_TYPE,(float) dwType);
}

STDMETHODIMP CEchoTool::GetRepeat(DWORD * pdwRepeat) 
{
    return GetParamInt(DMUS_ECHO_REPEAT,MAX_REF_TIME,(long *) pdwRepeat);
}

STDMETHODIMP CEchoTool::GetDecay(DWORD * pdwDecay) 
{
    return GetParamInt(DMUS_ECHO_DECAY,MAX_REF_TIME,(long *) pdwDecay);
}

STDMETHODIMP CEchoTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_ECHO_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CEchoTool::GetDelay(DWORD * pdwDelay) 
{
    return GetParamInt(DMUS_ECHO_DELAY,MAX_REF_TIME,(long *) pdwDelay);
}

STDMETHODIMP CEchoTool::GetGroupOffset(DWORD * pdwGroupOffset) 
{
    return GetParamInt(DMUS_ECHO_GROUPOFFSET,MAX_REF_TIME,(long *) pdwGroupOffset);
}

STDMETHODIMP CEchoTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_ECHO_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\param.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParams.
//

#include "dmerror.h"
#include "param.h"
#include "math.h"
#include "..\shared\validate.h"

CParamsManager::CParamsManager()
  
{
    m_fDirty = FALSE;
	m_fMusicTime = FALSE;
	m_cParams = 0;
	m_pCurveLists = NULL;
    m_pParamInfos = NULL;
	InitializeCriticalSection(&m_ParamsCriticalSection);
}

CParamsManager::~CParamsManager()
{
	delete[] m_pCurveLists;
	delete[] m_pParamInfos;
	DeleteCriticalSection(&m_ParamsCriticalSection);
}

HRESULT CParamsManager::InitParams(DWORD cParams,ParamInfo *pParamInfo)
{
	m_pCurveLists = new CCurveList[cParams];
	if (!m_pCurveLists)
		return E_OUTOFMEMORY;

	// save the parameter info
	m_pParamInfos = new ParamInfo[cParams];
	if (!m_pParamInfos)
		return E_OUTOFMEMORY;
    for (DWORD dwIndex = 0; dwIndex < cParams; dwIndex++)
    {
        if (pParamInfo[dwIndex].dwIndex < cParams)
        {
            memcpy(&m_pParamInfos[pParamInfo[dwIndex].dwIndex],&pParamInfo[dwIndex],sizeof(ParamInfo));
        }
    }
	m_cParams = cParams;

	return S_OK;
}

HRESULT CParamsManager::GetParamCount(DWORD *pdwParams)

{
    if (pdwParams == NULL)
        return E_POINTER;
    
    *pdwParams = m_cParams;
    return S_OK;
}

HRESULT CParamsManager::GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo)

{
    if (!pInfo)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        *pInfo = m_pParamInfos[dwParamIndex].MParamInfo;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetParamText(DWORD dwParamIndex,WCHAR **ppwchText)

{
    if (!ppwchText)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        // write string of format: "Label\0Unit\0Enums1\0Enum2\0...EnumN\0\0"
        ParamInfo &pinfo = m_pParamInfos[dwParamIndex];
        int iUnit = wcslen(pinfo.MParamInfo.szLabel) + 1; // begin writing unit text here
        int iEnums = iUnit + wcslen(pinfo.MParamInfo.szUnitText) + 1; // begin writing enum text here
        int iEnd = iEnums + wcslen(pinfo.pwchText) + 1; // write the final (second) null terminator here
        WCHAR *pwsz = static_cast<WCHAR *>(CoTaskMemAlloc((iEnd + 1) * sizeof(WCHAR)));
        if (!pwsz)
            return E_OUTOFMEMORY;

        // wcscpy will write into various points of the string, neatly terminating each with a null
        wcscpy(pwsz, pinfo.MParamInfo.szLabel);
        wcscpy(pwsz + iUnit, pinfo.MParamInfo.szUnitText);
        wcscpy(pwsz + iEnums, pinfo.pwchText);

        // The text field was defined with commas to separate the enum values.
        // Replace them with NULL characters now.
        for (WCHAR *pwch = pwsz + iEnums; *pwch; ++pwch)
        {
            if (*pwch == L',')
                *pwch = L'\0';
        }

        pwsz[iEnd] = L'\0';
        
        *ppwchText = pwsz;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetNumTimeFormats(DWORD *pdwNumTimeFormats)

{
    if (!pdwNumTimeFormats)
    {
        return E_POINTER;
    }
    *pdwNumTimeFormats = 2;
    return S_OK;
}

HRESULT CParamsManager::GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat)

{
    if (!pguidTimeFormat)
    {
        return E_POINTER;
    }
    if (dwFormatIndex == 0)
    {
        *pguidTimeFormat = GUID_TIME_REFERENCE;
    }
    else 
    {
        *pguidTimeFormat = GUID_TIME_MUSIC;
    }
    return S_OK;
}

HRESULT CParamsManager::GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData)

{
    return E_NOTIMPL;
}


HRESULT CParamsManager::CopyParamsFromSource( CParamsManager * pSource)

{
    HRESULT hr = S_OK;
    hr = InitParams(pSource->m_cParams,pSource->m_pParamInfos);
    if (SUCCEEDED(hr))
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
        {
            CCurveItem *pCurve = pSource->m_pCurveLists[dwIndex].GetHead();
            for (;pCurve;pCurve = pCurve->GetNext())
            {
	            CCurveItem *pNew = new CCurveItem;
                if (!pNew) 
                {
                    return E_OUTOFMEMORY;
                }
                pNew->m_Envelope = pCurve->m_Envelope;
                m_pCurveLists[dwIndex].AddTail(pNew);
            }
        }
    }
    return hr;
}


inline float ValRange(float valToClip, float valMin, float valMax)
{
	return valToClip < valMin
				? valMin
				: (valToClip > valMax ? valMax : valToClip);
}

HRESULT CParamsManager::GetParamFloat(DWORD dwParamIndex,REFERENCE_TIME rtTime,float *pval)
{
	HRESULT hr = S_OK;

	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// if no points, then neutral value
	CCurveItem *pCurve = pList->GetHead();
	if (!pCurve)
	{
		*pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
	}

	// Find the curve during or before the requested time
    // If the time is during a curve, we will use that.
    // If not, we need the end value of the previous curve.
    // Our list keeps these in backwards order, so we are scanning from the 
    // highest point in time backwards.

	for (;pCurve && pCurve->m_Envelope.rtStart > rtTime;pCurve = pCurve->GetNext());

    // If there is no pCurve, there was no curve prior to or during rtTime. Give up.
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
    }
    // Now, if pCurve ends before the requested time,
    // return the final value of pCurve, since that will hold until the start of the next curve.
    if (pCurve->m_Envelope.rtEnd < rtTime)
    {
		*pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
	}

    // If we get this far, the curve must bound rtTime.

	if (pCurve->m_Envelope.iCurve & MP_CURVE_JUMP)
	{
		*pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
	}


	REFERENCE_TIME rtTimeChange = pCurve->m_Envelope.rtEnd - pCurve->m_Envelope.rtStart;
	REFERENCE_TIME rtTimeIntermediate = rtTime - pCurve->m_Envelope.rtStart; 

	float fltScalingX = static_cast<float>(rtTimeIntermediate) / rtTimeChange; // horizontal distance along curve between 0 and 1
	float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
    switch (pCurve->m_Envelope.iCurve)
    {
    case MP_CURVE_SQUARE:
		fltScalingY = fltScalingX * fltScalingX;
        break;
    case MP_CURVE_INVSQUARE:
		fltScalingY = (float) sqrt(fltScalingX);
        break;
    case MP_CURVE_SINE:
        //  Maybe we should have a lookup table here?
        fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
        break;
    case MP_CURVE_LINEAR:
    default:
		fltScalingY = fltScalingX;
    }
    // Find out if we need to pull the start point from the previous curve,
    // the default neutral value, or the current curve.
    float fStartVal = pCurve->m_Envelope.valStart;
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_NEUTRALVAL)
    {
        fStartVal = pInfo->MParamInfo.mpdNeutralValue;
    }
    // Currentval, if it exists, will override neutralval.
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_CURRENTVAL)
    {
        // Take advantage of the fact that these are inserted in backwards order.
        // Scan for the previous curve that ends before this time.
        CCurveItem *pPrevious = pCurve->GetNext();
       	for (;pPrevious && pPrevious->m_Envelope.rtEnd > rtTime;pPrevious = pPrevious->GetNext());
        if (pPrevious)
        {
            fStartVal = pPrevious->m_Envelope.valEnd;
        }
    }
    
	// Apply that scaling to the range of the actual points
	*pval = (pCurve->m_Envelope.valEnd - pCurve->m_Envelope.valStart) * fltScalingY + pCurve->m_Envelope.valStart;
    LeaveCriticalSection(&m_ParamsCriticalSection);
	return hr;
}

HRESULT CParamsManager::GetParamInt(DWORD dwParamIndex,REFERENCE_TIME rt,long *pval)

{
    HRESULT hr = E_POINTER;
    if (pval)
    {
        float fVal;
        hr = GetParamFloat(dwParamIndex,rt,&fVal);
        if (SUCCEEDED(hr))
        {
            *pval = (long) (fVal + 1/2);    // Round.
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IMediaParams

HRESULT CParamsManager::GetParam(DWORD dwParamIndex,MP_DATA *pValue)
{
    V_INAME(CParams::GetParam);
    V_PTR_WRITE(pValue, MP_DATA);
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);

	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// if no points, then neutral value
	CCurveItem *pCurve = pList->GetHead();
	if (pCurve)
	{
		*pValue = pCurve->m_Envelope.valEnd;
	}
    else
    {
        *pValue = pInfo->MParamInfo.mpdNeutralValue;
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return S_OK;
}

HRESULT CParamsManager::SetParam(DWORD dwParamIndex,MP_DATA value)
{
	V_INAME(CParams::SetParam);
    
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// If we've already got a list, just force the most recent curve item to this value.
    // Otherwise, create a node and add it.
	CCurveItem *pCurve = pList->GetHead();
	if (!pCurve)
	{
        pCurve = new CCurveItem;
        if (pCurve)
        {
            pCurve->m_Envelope.rtStart =    0x8000000000000000; // Max negative.
            pCurve->m_Envelope.rtEnd =      0x7FFFFFFFFFFFFFFF; // Max positive.
            pCurve->m_Envelope.flags = 0;
            pList->AddHead(pCurve);
        }
		else 
        {
            LeaveCriticalSection(&m_ParamsCriticalSection);
            return E_OUTOFMEMORY;
        }
	}
    pCurve->m_Envelope.valStart = value;
    pCurve->m_Envelope.valEnd = value;
    pCurve->m_Envelope.iCurve = MP_CURVE_JUMP;
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::AddEnvelope(
		DWORD dwParamIndex,
		DWORD cPoints,
		MP_ENVELOPE_SEGMENT *ppEnvelope)
{
	V_INAME(CParams::AddEnvelope);
	V_PTR_READ(ppEnvelope, *ppEnvelope);

	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

	if (!m_pParamInfos)
		return DMUS_E_NOT_INIT;

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;

	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

    DWORD dwCount;
    for (dwCount = 0; dwCount < cPoints; dwCount++)
    {
        CCurveItem *pCurve = new CCurveItem;
        if (!pCurve) 
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        pCurve->m_Envelope = ppEnvelope[dwCount];
        pCurve->m_Envelope.valEnd = ValRange(pCurve->m_Envelope.valEnd, 
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pCurve->m_Envelope.valStart = ValRange(pCurve->m_Envelope.valStart, 
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pList->AddHead(pCurve);
    }

    LeaveCriticalSection(&m_ParamsCriticalSection);

	return hr;
}

HRESULT CParamsManager::FlushEnvelope(
		DWORD dwParamIndex,
		REFERENCE_TIME refTimeStart,
		REFERENCE_TIME refTimeEnd)
{
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

	if (!m_pParamInfos)
		return DMUS_E_NOT_INIT;

	if (refTimeStart >= refTimeEnd)
	    return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    CCurveList TempList;
    CCurveItem *pCurve;
    while (pCurve = pList->RemoveHead())
    {
        if ((pCurve->m_Envelope.rtStart >= refTimeStart) && 
            (pCurve->m_Envelope.rtEnd <= refTimeEnd))
        {
            delete pCurve;
        }
        else 
        {
            TempList.AddHead(pCurve);
        }
    }
    while (pCurve = TempList.RemoveHead())
    {
        pList->AddHead(pCurve);
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);

	return S_OK;
}

HRESULT CParamsManager::SetTimeFormat(
		GUID guidTimeFormat,
		MP_TIMEDATA mpTimeData)
{
    if (guidTimeFormat == GUID_TIME_REFERENCE)
    {
        m_fMusicTime = FALSE;
    }
    else if (guidTimeFormat == GUID_TIME_MUSIC)
    {
        m_fMusicTime = TRUE;
    }
    else
    {
        return E_INVALIDARG;
    }
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\param.h ===
#ifndef __TOOLPARAM_H__
#define __TOOLPARAM_H__



#include "medparam.h"
#include "alist.h"

typedef struct _ParamInfo
{
    DWORD dwIndex;                      // Which parameter.
    MP_PARAMINFO    MParamInfo;         // Standard MediaParams structure.
    WCHAR *         pwchText;           // Array of text names for enumerated types.
} ParamInfo;

class CCurveItem : public AListItem
{
public:
    CCurveItem* GetNext() { return (CCurveItem*)AListItem::GetNext();}
    MP_ENVELOPE_SEGMENT m_Envelope;     // Envelope segment.
};

class CCurveList : public AList
{
public:
//    void Clear();
    void AddHead(CCurveItem* pCurveItem) { AList::AddHead((AListItem*)pCurveItem);}
//    void Insert(CCurveItem* pCurveItem);
    CCurveItem* GetHead(){return (CCurveItem*)AList::GetHead();}
//    CCurveItem* GetItem(LONG lIndex){return (CCurveItem*)AList::GetItem(lIndex);}
    CCurveItem* RemoveHead(){ return (CCurveItem*)AList::RemoveHead();}
//    void Remove(CCurveItem* pCurveItem){AList::Remove((AListItem*)pCurveItem);}
//    void AddTail(CCurveItem* pCurveItem){AList::AddTail((AListItem*)pCurveItem);}
//    CCurveItem* GetTail(){ return (CCurveItem*)AList::GetTail();}
};

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF
#define MP_CAPS_ALL     MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE

class CParamsManager :	public IMediaParams, public IMediaParamInfo
{
public:
    CParamsManager();
    ~CParamsManager();

	// IUnknown
	STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *) PURE;
	STDMETHOD_(ULONG, AddRef)() PURE;
	STDMETHOD_(ULONG, Release)() PURE;

	// IMediaParams
	STDMETHODIMP GetParam(DWORD dwParamIndex, MP_DATA *pValue);
	STDMETHODIMP SetParam( DWORD dwParamIndex,MP_DATA value);
	STDMETHODIMP AddEnvelope(DWORD dwParamIndex,DWORD cPoints,MP_ENVELOPE_SEGMENT *ppEnvelope);
	STDMETHODIMP FlushEnvelope( DWORD dwParamIndex,REFERENCE_TIME refTimeStart,REFERENCE_TIME refTimeEnd);
	STDMETHODIMP SetTimeFormat( GUID guidTimeFormat,MP_TIMEDATA mpTimeData);

    // IMediaParamInfo
    STDMETHODIMP GetParamCount(DWORD *pdwParams);
    STDMETHODIMP GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo);
    STDMETHODIMP GetParamText(DWORD dwParamIndex,WCHAR **ppwchText);
    STDMETHODIMP GetNumTimeFormats(DWORD *pdwNumTimeFormats);
    STDMETHODIMP GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat);        
    STDMETHODIMP GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData);

protected:
    HRESULT InitParams( DWORD cParams, ParamInfo *pParamInfos);
	HRESULT GetParamFloat (DWORD dwParamIndex,REFERENCE_TIME rt,float *pval);
    HRESULT GetParamInt (DWORD dwParamIndex,REFERENCE_TIME rt,long *pval);
    HRESULT CopyParamsFromSource(CParamsManager * pSource);

	// data

	CRITICAL_SECTION m_ParamsCriticalSection;
    BOOL            m_fDirty;       // Has data changed since last file load or save?
	BOOL			m_fMusicTime;	// True if time format is music time, else false for clock time.
	DWORD           m_cParams;		// Nuimber of parameters.
	ParamInfo       *m_pParamInfos; // Array of ParamInfo structures, one for each parameter.
	CCurveList      *m_pCurveLists; // Array of Curve lists, one for each parameter.
};

#endif // __TOOLPARAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\quantize.cpp ===
// Quantize.cpp : Implementation of CQuantizeTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "quantize.h"
#include "toolhelp.h"

CQuantizeTool::CQuantizeTool()
{
    ParamInfo Params[DMUS_QUANTIZE_PARAMCOUNT] = 
    {
        { DMUS_QUANTIZE_STRENGTH, MPT_INT,MP_CAPS_ALL,0,110,80,
            L"Percent",L"Strength",NULL },            // Strength - 80% by default
        { DMUS_QUANTIZE_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MTIME,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Resolution Units",L"Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_QUANTIZE_RESOLUTION, MPT_INT,MP_CAPS_ALL,1,1000,1,
            L"",L"Resolution",NULL},   // Resolution - 1 grid note by default
        { DMUS_QUANTIZE_TYPE, MPT_ENUM,MP_CAPS_ALL, DMUS_QUANTIZET_START,DMUS_QUANTIZET_ALL,DMUS_QUANTIZET_START,
            L"",L"Type",L"Start Time,Duration,Start and Duration"} // Type - quantize start time by default
    };
    InitParams(DMUS_QUANTIZE_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CQuantizeTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CQuantizeTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CQuantizeTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicQuantizeTool)
	{
		*ppv = static_cast<IDirectMusicQuantizeTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CQuantizeTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicQuantizeTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CQuantizeTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CQuantizeTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_QUANTIZE_CHUNK))
	{
        DMUS_IO_QUANTIZE_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_QUANTIZE_STRENGTH,(float) Header.dwStrength);
            SetParam(DMUS_QUANTIZE_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_QUANTIZE_RESOLUTION,(float) Header.dwResolution);
            SetParam(DMUS_QUANTIZE_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CQuantizeTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_QUANTIZE_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_QUANTIZE_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_QUANTIZE_HEADER Header;
        GetParamInt(DMUS_QUANTIZE_STRENGTH,MAX_REF_TIME,(long *)&Header.dwStrength);
        GetParamInt(DMUS_QUANTIZE_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_QUANTIZE_RESOLUTION,MAX_REF_TIME,(long *) &Header.dwResolution);
        GetParamInt(DMUS_QUANTIZE_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CQuantizeTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_QUANTIZE_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CQuantizeTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_QuantizePage;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CQuantizeTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lStrength, lResolution, lTimeUnit, lType;
            
            GetParamInt(DMUS_QUANTIZE_STRENGTH,rtTime,&lStrength);
            GetParamInt(DMUS_QUANTIZE_RESOLUTION,rtTime,&lResolution);
            GetParamInt(DMUS_QUANTIZE_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_QUANTIZE_TYPE,rtTime,&lType);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime - pNote->nOffset,NULL,&TimeSig)))
            {
                lResolution *= CToolHelper::TimeUnitToTicks(lTimeUnit,&TimeSig);
                if (lResolution < 1) lResolution = 1;
                if ((lType == DMUS_QUANTIZET_START) || (lType == DMUS_QUANTIZET_ALL))
                {
                    MUSIC_TIME mtTime = -TimeSig.mtTime;
                    long lIntervals = (mtTime + (lResolution >> 1)) / lResolution;
                    long lOffset = mtTime - (lIntervals * lResolution);
                    lOffset *= lStrength;
                    lOffset /= 100;
                    pNote->mtTime -= lOffset;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                if ((lType == DMUS_QUANTIZET_LENGTH) || (lType == DMUS_QUANTIZET_ALL))
                {
                    long lIntervals = (pNote->mtDuration + (lResolution >> 1)) / lResolution;
                    if (lIntervals < 1) lIntervals = 1;
                    long lOffset = pNote->mtDuration - (lIntervals * lResolution);
                    lOffset *= lStrength;
                    lOffset /= 100;
                    pNote->mtDuration -= lOffset;
                }
                
            }
            pPerf8->Release();
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CQuantizeTool::Clone( IDirectMusicTool ** ppTool)

{
    CQuantizeTool *pNew = new CQuantizeTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CQuantizeTool::SetStrength(DWORD dwStrength) 
{
    return SetParam(DMUS_QUANTIZE_STRENGTH,(float) dwStrength);
}

STDMETHODIMP CQuantizeTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_QUANTIZE_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CQuantizeTool::SetResolution(DWORD dwResolution) 
{
    return SetParam(DMUS_QUANTIZE_RESOLUTION,(float) dwResolution);
}

STDMETHODIMP CQuantizeTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_QUANTIZE_TYPE,(float) dwType);
}

STDMETHODIMP CQuantizeTool::GetStrength(DWORD * pdwStrength) 
{
    return GetParamInt(DMUS_QUANTIZE_STRENGTH,MAX_REF_TIME,(long *) pdwStrength);
}

STDMETHODIMP CQuantizeTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_QUANTIZE_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CQuantizeTool::GetResolution(DWORD * pdwResolution) 
{
    return GetParamInt(DMUS_QUANTIZE_RESOLUTION,MAX_REF_TIME,(long *) pdwResolution);
}

STDMETHODIMP CQuantizeTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_QUANTIZE_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\swing.h ===
#ifndef _SWING_TOOL_
#define _SWING_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CSwingTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicSwingTool

{
public:
	CSwingTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicSwingTool
	STDMETHODIMP SetStrength(DWORD dwStrength) ;
	STDMETHODIMP GetStrength(DWORD * pdwStrength) ;
protected:	
};

#endif // _SWING_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc
!include $(DXROOT)\project.mk

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmtool

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF



TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmtool.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif


C_DEFINES= $(C_DEFINES) -D_WIN32


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\uuid.lib

INCLUDES=$(INCLUDES) \
    $(DXROOT)\dmusic\shared

SOURCES=\
    ..\alist.cpp                \
    ..\debug.cpp                \
    ..\dll.cpp                  \
    ..\duration.cpp             \
    ..\echo.cpp                 \
    ..\guids.cpp                \
    ..\oledll.cpp               \
    ..\param.cpp                \
	..\swing.cpp				\
    ..\toolhelp.cpp             \
    ..\transpose.cpp			\
	..\quantize.cpp				\
	..\timeshift.cpp			\
	..\velocity.cpp				\
	..\toolprop_i.c				\
    ..\medparam_i.c				\
	..\dmtool.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\timeshift.cpp ===
// TimeShift.cpp : Implementation of CTimeShiftTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "timeshift.h"
#include "toolhelp.h"


CTimeShiftTool::CTimeShiftTool()
{
    ParamInfo Params[DMUS_TIMESHIFT_PARAMCOUNT] = 
    {
        { DMUS_TIMESHIFT_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MTIME,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Resolution Units",L"Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_TIMESHIFT_RANGE, MPT_INT,MP_CAPS_ALL,0,200,0,
            L"Clicks",L"Shift",NULL},        // Time shift - default to 0 (no change)
        { DMUS_TIMESHIFT_OFFSET, MPT_INT,MP_CAPS_ALL,-200,200,0,
            L"Clicks",L"Random Range",NULL},        // Randmomize - default to 0 (no change)
    };
    InitParams(DMUS_TIMESHIFT_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CTimeShiftTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTimeShiftTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CTimeShiftTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicTimeShiftTool)
	{
		*ppv = static_cast<IDirectMusicTimeShiftTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CTimeShiftTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicTimeShiftTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CTimeShiftTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CTimeShiftTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_TIMESHIFT_CHUNK))
	{
        DMUS_IO_TIMESHIFT_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_TIMESHIFT_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_TIMESHIFT_RANGE,(float) Header.dwRange);
            SetParam(DMUS_TIMESHIFT_OFFSET,(float) Header.lOffset);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CTimeShiftTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_TIMESHIFT_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_TIMESHIFT_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_TIMESHIFT_HEADER Header;
        GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_TIMESHIFT_RANGE,MAX_REF_TIME,(long *)&Header.dwRange);
        GetParamInt(DMUS_TIMESHIFT_OFFSET,MAX_REF_TIME,&Header.lOffset);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTimeShiftTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_TIMESHIFT_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CTimeShiftTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_TimeShiftPage;

	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CTimeShiftTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only adjust the timing of notes. 
    if( pPMsg->dwType == DMUS_PMSGT_NOTE ) 
    {
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lOffset;
            DWORD dwRange;
            long lTimeUnit;
            GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_TIMESHIFT_RANGE,rtTime,(long *)&dwRange);
            GetParamInt(DMUS_TIMESHIFT_OFFSET,rtTime,&lOffset);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
            {
                long lResolution = CToolHelper::TimeUnitToTicks(lTimeUnit,&TimeSig);
                if (lResolution < 1) lResolution = 1;
                if (dwRange)
                {
                    dwRange *= lResolution;
                    pNote->mtTime += (dm_rand() % (dwRange << 1)) - dwRange;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                if (lOffset)
                {
                    lOffset *= lResolution;
                    pNote->mtTime += lOffset;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
            }
            pPerf8->Release();
        }   
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CTimeShiftTool::Clone( IDirectMusicTool ** ppTool)

{
    CTimeShiftTool *pNew = new CTimeShiftTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CTimeShiftTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_TIMESHIFT_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CTimeShiftTool::SetRange( DWORD dwRange) 
{
    return SetParam(DMUS_TIMESHIFT_RANGE,(float)dwRange);
}

STDMETHODIMP CTimeShiftTool::SetOffset( long lOffset)
{
    return SetParam(DMUS_TIMESHIFT_OFFSET,(float)lOffset);
}

STDMETHODIMP CTimeShiftTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CTimeShiftTool::GetRange(DWORD *pdwRange) 
{
    return GetParamInt(DMUS_TIMESHIFT_RANGE,MAX_REF_TIME, (long *) pdwRange);
}

STDMETHODIMP CTimeShiftTool::GetOffset(long *plOffset) 
{
    return GetParamInt(DMUS_TIMESHIFT_OFFSET,MAX_REF_TIME, plOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\timeshift.h ===
#ifndef _TIMESHIFT_TOOL_
#define _TIMESHIFT_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CTimeShiftTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicTimeShiftTool

{
public:
	CTimeShiftTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicTimeShiftTool
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetRange(DWORD dwRange) ;
	STDMETHODIMP SetOffset(long lOffset) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetRange(DWORD * pdwRange);
	STDMETHODIMP GetOffset(long * plOffset);
};

#endif // _TIMESHIFT_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\quantize.h ===
#ifndef _QUANTIZE_TOOL_
#define _QUANTIZE_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CQuantizeTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicQuantizeTool

{
public:
	CQuantizeTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicQuantizeTool
	STDMETHODIMP SetStrength(DWORD dwStrength) ;
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetResolution(DWORD dwResolution) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetStrength(DWORD * pdwStrength) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetResolution(DWORD * pdwResolution) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
protected:	
};

#endif // _QUANTIZE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\swing.cpp ===
// Swing.cpp : Implementation of CSwingTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "swing.h"
#include "toolhelp.h"

CSwingTool::CSwingTool()
{
    ParamInfo Params[DMUS_SWING_PARAMCOUNT] = 
    {
        { DMUS_SWING_STRENGTH, MPT_INT,MP_CAPS_ALL,0,100,100,
            L"Percent",L"Strength",NULL },            // Strength - 100% by default
    };
    InitParams(DMUS_SWING_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CSwingTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSwingTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSwingTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicSwingTool)
	{
		*ppv = static_cast<IDirectMusicSwingTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CSwingTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicSwingTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CSwingTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CSwingTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_SWING_CHUNK))
	{
        DMUS_IO_SWING_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_SWING_STRENGTH,(float) Header.dwStrength);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CSwingTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_SWING_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_SWING_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_SWING_HEADER Header;
        GetParamInt(DMUS_SWING_STRENGTH,MAX_REF_TIME,(long *)&Header.dwStrength);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CSwingTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_SWING_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CSwingTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_SwingPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CSwingTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lStrength;
            
            GetParamInt(DMUS_SWING_STRENGTH,rtTime,&lStrength);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
            {
                long lGrid = ((4 * 768) / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
                if ((TimeSig.wGridsPerBeat == 3) || (TimeSig.wGridsPerBeat == 6) || 
                    (TimeSig.wGridsPerBeat == 9) || (TimeSig.wGridsPerBeat == 12))
                {
                    // This is already in a triplet feel, so work in reverse.
                    // Adjust the timing, as set by the lStrength parameter.
                    // lStrength is a range from 0 for no swing to 100 for full swing.
                    // We are moving from grids 0,1,2,3,4,5... in triplet feel to grids 
                    // 0,1,2,4,5,6... in non-triplet feel.
                    // So, the notes need to be adjusted in time in either direction.
                    // When we change the time, we clear the DMUS_PMSGF_REFTIME flag, 
                    // telling the performance to recalculate the reference time stamp
                    // in the event when it is requeued.
                    static long lFromTriplet[12] = { 0,1,2,4,5,6,8,9,10,12,13,14 };
                    if (pNote->bGrid < 12)
                    {
                        // Calculate the position we are moving to.
                        long lTwoplet = ((lGrid * 3) / 4) * lFromTriplet[pNote->bGrid];
                        // Calculate the position we are moving from. 
                        lGrid *= pNote->bGrid;
                        // Calculate the new time. Note that we inverse strength since we are going from triplet.
                        pNote->mtTime += ((100 - lStrength) * (lTwoplet - lGrid)) / 100;
		                pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                }
                else if (TimeSig.wGridsPerBeat <= 16)
                {
                    // Adjust the timing, as set by the lStrength parameter.
                    // lStrength is a range from 0 for no swing to 100 for full swing.
                    // We are moving from grids 0,1,2,3 in straight ahead feel to grids 
                    // 0,1,2 in triplet feel.
                    // So, the notes need to be adjusted in time in either direction.
                    // When we change the time, we clear the DMUS_PMSGF_REFTIME flag, 
                    // telling the performance to recalculate the reference time stamp
                    // in the event when it is requeued.
                    static long lToTriplet[16] = { 0,1,2,2,3,4,5,5,6,7,8,8,9,10,11,11 };
                    if (pNote->bGrid < 16)
                    {
                        // Calculate the position we are moving to.
                        long lTriplet = ((lGrid * 4) / 3) * lToTriplet[pNote->bGrid];
                        // Calculate the position we are moving from. 
                        Trace(0,"%ld,%ld,%ld,%ld\t%ld,%ld,%ld\t",
                            (long)TimeSig.bBeatsPerMeasure,(long)TimeSig.bBeat,(long)TimeSig.wGridsPerBeat,
                            lGrid,(long)pNote->bBeat,(long)pNote->bGrid,(long)pNote->nOffset);
                        lGrid *= pNote->bGrid;
                        Trace(0,"%ld,%ld,%ld\n",lStrength,lTriplet,lGrid);
                        pNote->mtTime += (lStrength * (lTriplet - lGrid)) / 100;
		                pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                }
            }
            pPerf8->Release();
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CSwingTool::Clone( IDirectMusicTool ** ppTool)

{
    CSwingTool *pNew = new CSwingTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CSwingTool::SetStrength(DWORD dwStrength) 
{
    return SetParam(DMUS_SWING_STRENGTH,(float) dwStrength);
}

STDMETHODIMP CSwingTool::GetStrength(DWORD * pdwStrength) 
{
    return GetParamInt(DMUS_SWING_STRENGTH,MAX_REF_TIME,(long *) pdwStrength);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\toolhelp.cpp ===
// ToolHelp.cpp : Global functions.
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "toolhelp.h"

long CToolHelper::m_slMIDIToDB[128] = {       // Global array used to convert MIDI to dB. 
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};


long CToolHelper::m_slDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75, 
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42, 
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23, 
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13, 
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7, 
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0
};

long CToolHelper::m_slResTypes[DMUS_TIME_UNIT_COUNT] = 
{ 1,    // DMUS_TIME_UNIT_MS
  1,    // DMUS_TIME_UNIT_MTIME 
  384,  // DMUS_TIME_UNIT_GRID
  768,  // DMUS_TIME_UNIT_BEAT
  3072, // DMUS_TIME_UNIT_BAR
  32,   // DMUS_TIME_UNIT_64T
  48,   // DMUS_TIME_UNIT_64
  64,   // DMUS_TIME_UNIT_32T  
  96,   // DMUS_TIME_UNIT_32 
  128,  // DMUS_TIME_UNIT_16T     
  192,  // DMUS_TIME_UNIT_16     
  256,  // DMUS_TIME_UNIT_8T    
  384,  // DMUS_TIME_UNIT_8         
  512,  // DMUS_TIME_UNIT_4T  
  768,  // DMUS_TIME_UNIT_4         
  1024, // DMUS_TIME_UNIT_2T   
  1536, // DMUS_TIME_UNIT_2   
  2048, // DMUS_TIME_UNIT_1T
  3072  // DMUS_TIME_UNIT_1
};


BYTE CToolHelper::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_slDBToMIDI[lVolume];
    lResult += ((m_slDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

long CToolHelper::MidiToVolume(BYTE bMidi)

{
    if (bMidi > 127) bMidi = 127;
    return m_slMIDIToDB[bMidi];
}

long CToolHelper::TimeUnitToTicks(long lTimeUnit,DMUS_TIMESIGNATURE *pTimeSig) 
{ 
    long lTicks;
    if (lTimeUnit > DMUS_TIME_UNIT_BAR)
    {
        lTicks = m_slResTypes[lTimeUnit];
    }
    else if ((lTimeUnit >= DMUS_TIME_UNIT_GRID) && pTimeSig)
    {
        DWORD dwBeat = (4 * 768) / pTimeSig->bBeat;
        if (lTimeUnit == DMUS_TIME_UNIT_BEAT)
        {
            lTicks = dwBeat;
        }
        else if (lTimeUnit == DMUS_TIME_UNIT_GRID)
        {
            lTicks = (dwBeat / pTimeSig->wGridsPerBeat);
        }
        else 
        {
            lTicks = (dwBeat * pTimeSig->bBeatsPerMeasure);
        }
    }
    else lTicks = 0;
    return lTicks;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\toolhelp.h ===
#ifndef _TOOL_HELP_
#define _TOOL_HELP_

#include "dmusici.h"
#include "tools.h"

// Global class that provides various useful methods.

class CToolHelper 
{
public:
    BYTE VolumeToMidi(long lVolume);
    long MidiToVolume(BYTE bMidi);
    long TimeUnitToTicks(long lTimeUnit,DMUS_TIMESIGNATURE *pTimeSig);
private:
    static long m_slMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static long m_slDBToMIDI[97];    // For converting volume to MIDI.
    static long m_slResTypes[DMUS_TIME_UNIT_COUNT]; // Array for converting time units into ticks.
};

class CMusicVal
{
public:
    CMusicVal(WORD wMusicVal);
    WORD GetValue();
	void operator+=(CMusicVal Val);
    void operator+=(short nScale);  // Most common transposition would be by scale.
	void operator-=(CMusicVal Val);
	CMusicVal operator+(CMusicVal Val) const;
	CMusicVal operator-(CMusicVal Val) const;
private:
    void CleanUp();
    short       m_sOctave;
    short       m_sChord;
    short       m_sScale;
    short       m_sAccidental;
};

/*inline void CMusicVal::operator +

inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
_AFXWIN_INLINE void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
_AFXWIN_INLINE void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
_AFXWIN_INLINE CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
*/
inline CMusicVal::CMusicVal(WORD wMusicVal)

{
    m_sAccidental = wMusicVal & 0xF;
    if (wMusicVal & 0x8) // Negative?
    {
        m_sAccidental |= 0xFFF0;    // Yes, extend sign bit.
    }
    m_sScale = (wMusicVal & 0xF0) >> 4;
    m_sChord = (wMusicVal & 0xF00) >> 8;
    m_sOctave = wMusicVal >> 12;
    if (m_sOctave > 14) // We count the top two octaves as negative.
    {
        m_sOctave -= 16;
    }
}

inline WORD CMusicVal::GetValue()

{
    CleanUp();
    return (WORD) ((m_sOctave << 12) | (m_sChord << 8) | (m_sScale << 4) | (m_sAccidental & 0xF));
}

inline void CMusicVal::CleanUp()

{
    while (m_sAccidental < -8)
    {
        // This should never happen, but it does, do approximate math.
        m_sAccidental += 2;
        m_sScale -= 1;
    }
    while (m_sAccidental > 7)
    {
        // Likewise, this should not happen, so resulting math isn't perfect.
        m_sAccidental -= 2;
        m_sScale += 1;
    }
    while (m_sScale < 0)
    {
        m_sScale += 2;
        m_sChord -= 1;
    }
    while (m_sScale > 7)
    {
        m_sScale -= 2;
        m_sChord += 1;
    }
    while (m_sChord < 0)
    {
        m_sChord += 4;
        m_sOctave -= 1;
    }
    while (m_sChord > 4)
    {
        m_sChord -= 4;
        m_sOctave += 1;
    }
    while (m_sOctave < -2)
    {
        m_sOctave++;
    }
    while (m_sOctave >= 14)
    {
        m_sOctave--;
    }
}

inline void CMusicVal::operator+=(CMusicVal Val)

{ 
    m_sOctave += Val.m_sOctave;
    m_sChord += Val.m_sChord;
    m_sScale += Val.m_sScale;
    m_sAccidental  += Val.m_sAccidental;
}

inline void CMusicVal::operator+=(short nScale)

{ 
    m_sScale += nScale;
}


#endif // _TOOL_HELP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\tools.h ===
#ifndef _TOOLS_H_
#define _TOOLS_H_

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

/*  Time unit types. This is used by various tools to define the format for units of time. */

#define DMUS_TIME_UNIT_MS        0   /* Milliseconds. */
#define DMUS_TIME_UNIT_MTIME     1   /* Music Time. */
#define DMUS_TIME_UNIT_GRID      2   /* Grid size in current time signature. */
#define DMUS_TIME_UNIT_BEAT      3   /* Beat size in current time signature. */
#define DMUS_TIME_UNIT_BAR       4   /* Measure size in current time signature. */
#define DMUS_TIME_UNIT_64T       5   /* 64th note triplet. */
#define DMUS_TIME_UNIT_64        6   /* 64th note. */
#define DMUS_TIME_UNIT_32T       7   /* 32nd note triplet. */
#define DMUS_TIME_UNIT_32        8   /* 32nd note. */
#define DMUS_TIME_UNIT_16T       9   /* 16th note triplet. */
#define DMUS_TIME_UNIT_16        10  /* 16th note. */
#define DMUS_TIME_UNIT_8T        11  /* 8th note tripplet. */
#define DMUS_TIME_UNIT_8         12  /* 8th note. */
#define DMUS_TIME_UNIT_4T        13  /* Quarter note triplet. */
#define DMUS_TIME_UNIT_4         14  /* Quarter note. */
#define DMUS_TIME_UNIT_2T        15  /* Half note triplet. */
#define DMUS_TIME_UNIT_2         16  /* Half note. */
#define DMUS_TIME_UNIT_1T        17  /* Whole note triplet. */
#define DMUS_TIME_UNIT_1         18  /* Whole note. */

#define DMUS_TIME_UNIT_COUNT     19  /* Number of time unit types. */


interface IDirectMusicEchoTool;
#ifndef __cplusplus 
typedef interface IDirectMusicEchoTool IDirectMusicEchoTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicEchoTool
DECLARE_INTERFACE_(IDirectMusicEchoTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicEchoTool */
    STDMETHOD(SetRepeat)            (THIS_ DWORD dwRepeat) PURE;
    STDMETHOD(SetDecay)             (THIS_ DWORD dwDecay) PURE;
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetDelay)             (THIS_ DWORD dwDelay) PURE;
    STDMETHOD(SetGroupOffset)       (THIS_ DWORD dwGroupOffset) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetRepeat)            (THIS_ DWORD * pdwRepeat) PURE;
    STDMETHOD(GetDecay)             (THIS_ DWORD * pdwDecay) PURE;
    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetDelay)             (THIS_ DWORD * pdwDelay) PURE;
    STDMETHOD(GetGroupOffset)       (THIS_ DWORD * pdwGroupOffset) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_ECHO_REPEAT        0   /* How many times to repeat. */
#define DMUS_ECHO_DECAY         1   /* Decay, in decibels, between repeats. */
#define DMUS_ECHO_TIMEUNIT      2   /* Time unit used for converting the delay into music time. */
#define DMUS_ECHO_DELAY         3   /* Duration of time between echoes, in music time. */
#define DMUS_ECHO_GROUPOFFSET   4   /* Offset to add to PChannel in multiples of 16 for routing each echo to a separate output Pchannel. */
#define DMUS_ECHO_TYPE          5   /* Type of echo. (See DMUS_ECHOT_ values.) */

#define DMUS_ECHO_PARAMCOUNT    6   /* Number of parameters (above.) */

/*  Echo types. */

#define DMUS_ECHOT_FALLING      0   /* Regular echo, decreases in velocity with each one. */
#define DMUS_ECHOT_FALLING_CLIP 1   /* Regular echo, truncate notes lengths to just under decay time. */
#define DMUS_ECHOT_RISING       2   /* Echo starts quiet, increases to full velocity. */
#define DMUS_ECHOT_RISING_CLIP  3   /* Rising echo, truncate the lengths. */

#define FOURCC_ECHO_CHUNK        mmioFOURCC('e','c','h','o')

typedef struct _DMUS_IO_ECHO_HEADER
{
    DWORD   dwRepeat;       /* How many times to repeat. */
    DWORD   dwDecay;        /* Decay, in decibels, between repeats. */
    DWORD   dwTimeUnit;     /* Time format used for dwDelay. */
    DWORD   dwDelay;        /* Duration of time between echoes, in units defined by dwTimeUnit. */
    DWORD   dwGroupOffset;  /* Offset to add to PChannel for routing each echo. */
    DWORD   dwType;         /* Type of echo. (See DMUS_ECHOT_ values.) */
} DMUS_IO_ECHO_HEADER;

interface IDirectMusicTransposeTool;
#ifndef __cplusplus 
typedef interface IDirectMusicTransposeTool IDirectMusicTransposeTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicTransposeTool
DECLARE_INTERFACE_(IDirectMusicTransposeTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicTransposeTool */
    STDMETHOD(SetTranspose)         (THIS_ long lTranspose) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetTranspose)         (THIS_ long * plTranspose) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_TRANSPOSE_AMOUNT   0   /* How far up or down to transpose. */
#define DMUS_TRANSPOSE_TYPE     1   /* Transpose style (linear vs in scale.) */

#define DMUS_TRANSPOSE_PARAMCOUNT    2   /* Number of parameters (above.) */

/*  Transposition types. */

#define DMUS_TRANSPOSET_LINEAR  0   /* Transpose in linear increments. */
#define DMUS_TRANSPOSET_SCALE   1   /* Transpose in scale. */

#define FOURCC_TRANSPOSE_CHUNK        mmioFOURCC('t','r','a','n')

typedef struct _DMUS_IO_TRANSPOSE_HEADER
{
    long    lTranspose;     /* Transpose amount. */
    DWORD   dwType;         /* Type of echo. (See DMUS_ECHOT_ values.) */
} DMUS_IO_TRANSPOSE_HEADER;


interface IDirectMusicDurationTool;
#ifndef __cplusplus 
typedef interface IDirectMusicDurationTool IDirectMusicDurationTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDurationTool
DECLARE_INTERFACE_(IDirectMusicDurationTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDurationTool */
    STDMETHOD(SetScale)             (THIS_ float flScale) PURE;

    STDMETHOD(GetScale)             (THIS_ float * pflScale) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_DURATION_SCALE    0   /* Duration multiplier. */

#define DMUS_DURATION_PARAMCOUNT    1   /* Number of parameters (above.) */

#define FOURCC_DURATION_CHUNK        mmioFOURCC('d','u','r','a')

typedef struct _DMUS_IO_DURATION_HEADER
{
    float   flScale;                /* Duration multiplier. */
} DMUS_IO_DURATION_HEADER;


interface IDirectMusicQuantizeTool;
#ifndef __cplusplus 
typedef interface IDirectMusicQuantizeTool IDirectMusicQuantizeTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicQuantizeTool
DECLARE_INTERFACE_(IDirectMusicQuantizeTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicQuantizeTool */
    STDMETHOD(SetStrength)          (THIS_ DWORD dwStrength) PURE;
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetResolution)        (THIS_ DWORD dwResolution) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetStrength)          (THIS_ DWORD * pdwStrength) PURE;
    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetResolution)        (THIS_ DWORD * pdwResolution) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_QUANTIZE_STRENGTH    0   /* Strength of quantization (0 to 1.) */
#define DMUS_QUANTIZE_TIMEUNIT    1   /* Unit of time used to calculate resolution. */
#define DMUS_QUANTIZE_RESOLUTION  2   /* Quantization resolution in time format defined by dwTimeUnit. */
#define DMUS_QUANTIZE_TYPE        3   /* Flags for quantize start and/or duration. */

#define DMUS_QUANTIZE_PARAMCOUNT  4   /* Number of parameters (above.) */

/*  Quantize types. */

#define DMUS_QUANTIZET_START      0   /* Quantize just start time. */
#define DMUS_QUANTIZET_LENGTH     1   /* Quantize just duration. */
#define DMUS_QUANTIZET_ALL        2   /* Quantize start and duration. */

#define FOURCC_QUANTIZE_CHUNK        mmioFOURCC('q','u','n','t')

typedef struct _DMUS_IO_QUANTIZE_HEADER
{
    DWORD   dwStrength;               /* Quantize multiplier. */
    DWORD   dwTimeUnit;               /* Unit of time used to calculate resolution. */
    DWORD   dwResolution;             /* Quantization resolution in time format defined by dwTimeUnit. */
    DWORD   dwType;                   /* Flags for quantize start and/or duration. */
} DMUS_IO_QUANTIZE_HEADER;


interface IDirectMusicTimeShiftTool;
#ifndef __cplusplus 
typedef interface IDirectMusicTimeShiftTool IDirectMusicTimeShiftTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicTimeShiftTool
DECLARE_INTERFACE_(IDirectMusicTimeShiftTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicTimeShiftTool */
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetRange)             (THIS_ DWORD dwRange) PURE;
    STDMETHOD(SetOffset)            (THIS_ long lOffset) PURE;

    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetRange)             (THIS_ DWORD * pdwRange) PURE;
    STDMETHOD(GetOffset)            (THIS_ long * plOffset) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_TIMESHIFT_TIMEUNIT    0   /* Units for time offset and random range */
#define DMUS_TIMESHIFT_RANGE       1   /* Range for random time offset */
#define DMUS_TIMESHIFT_OFFSET      2   /* Straight offset to add to the note's time. */

#define DMUS_TIMESHIFT_PARAMCOUNT  3   /* Number of parameters (above.) */

#define FOURCC_TIMESHIFT_CHUNK        mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESHIFT_HEADER
{
    DWORD   dwTimeUnit;            /* Unit of time used to calculate resolution. */
    DWORD   dwRange;               /* Range for random time offset */
    long    lOffset;               /* Straight offset to add to the note's time. */
} DMUS_IO_TIMESHIFT_HEADER;


interface IDirectMusicSwingTool;
#ifndef __cplusplus 
typedef interface IDirectMusicSwingTool IDirectMusicSwingTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicSwingTool
DECLARE_INTERFACE_(IDirectMusicSwingTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSwingTool */
    STDMETHOD(SetStrength)          (THIS_ DWORD dwStrength) PURE;

    STDMETHOD(GetStrength)          (THIS_ DWORD * pdwStrength) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_SWING_STRENGTH    0   /* Strength of swing (0 to 100%) */

#define DMUS_SWING_PARAMCOUNT  1   /* Number of parameters (above.) */

#define FOURCC_SWING_CHUNK        mmioFOURCC('q','u','n','t')

typedef struct _DMUS_IO_SWING_HEADER
{
    DWORD   dwStrength;               /* Swing multiplier. */
} DMUS_IO_SWING_HEADER;

interface IDirectMusicVelocityTool;
#ifndef __cplusplus 
typedef interface IDirectMusicVelocityTool IIDirectMusicVelocityTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicVelocityTool
DECLARE_INTERFACE_(IDirectMusicVelocityTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicVelocityTool */
    STDMETHOD(SetStrength)          (THIS_ long lStrength) PURE;
    STDMETHOD(SetLowLimit)          (THIS_ long lVelocityOut) PURE;
    STDMETHOD(SetHighLimit)         (THIS_ long lVelocityOut) PURE;
    STDMETHOD(SetCurveStart)        (THIS_ long lVelocityIn) PURE;
    STDMETHOD(SetCurveEnd)          (THIS_ long lVelocityIn) PURE;

    STDMETHOD(GetStrength)          (THIS_ long * plStrength) PURE;
    STDMETHOD(GetLowLimit)          (THIS_ long * plVelocityOut) PURE;
    STDMETHOD(GetHighLimit)         (THIS_ long * plVelocityOut) PURE;
    STDMETHOD(GetCurveStart)        (THIS_ long * plVelocityIn) PURE;
    STDMETHOD(GetCurveEnd)          (THIS_ long * plVelocityIn) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_VELOCITY_STRENGTH    0   /* Strength of velocity modifier (0 to 100%) */
#define DMUS_VELOCITY_LOWLIMIT    1   /* Minimum value for output velocity */
#define DMUS_VELOCITY_HIGHLIMIT   2   /* Maximum value for output velocity */
#define DMUS_VELOCITY_CURVESTART  3   /* Velocity curve starts at low limit and this input velocity */
#define DMUS_VELOCITY_CURVEEND    4   /* Velocity curve ends at this input velocity and high limit */

#define DMUS_VELOCITY_PARAMCOUNT  5   /* Number of parameters (above.) */

#define FOURCC_VELOCITY_CHUNK        mmioFOURCC('v','e','l','o')

typedef struct _DMUS_IO_VELOCITY_HEADER
{
    long    lStrength;                /* Strength of transformation. */
    long    lLowLimit;                /* Minimum value for output velocity */
    long    lHighLimit;               /* Maximum value for output velocity */
    long    lCurveStart;              /* Velocity curve starts at low limit and this input velocity */
    long    lCurveEnd;                /* Velocity curve ends at this input velocity and high limit */
} DMUS_IO_VELOCITY_HEADER;


/* Class IDs for tools. */

DEFINE_GUID(CLSID_DirectMusicEchoTool, 0x64e49fa4, 0xbacf, 0x11d2, 0x87, 0x2c, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTransposeTool, 0xbb8d0702, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicSwingTool, 0xbb8d0703, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicQuantizeTool, 0xbb8d0704, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicVelocityTool, 0xbb8d0705, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicDurationTool, 0xbb8d0706, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicTimeShiftTool, 0xbb8d0707, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicMuteTool, 0xbb8d0708, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicChordSequenceTool, 0xbb8d0709, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);



/* Interface IDs for tools. */

DEFINE_GUID(IID_IDirectMusicEchoTool, 0x81f60d22, 0x9d10, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(IID_IDirectMusicTransposeTool,0x173803f4, 0x4fd5, 0x4ba1, 0x9e, 0x50, 0xdd, 0x5f, 0x56, 0x69, 0xd2, 0x25);
DEFINE_GUID(IID_IDirectMusicDurationTool,0xc6897cfb, 0x9a43, 0x420f, 0xb6, 0xdb, 0xdd, 0x32, 0xc1, 0x82, 0xe8, 0x33);
DEFINE_GUID(IID_IDirectMusicQuantizeTool,0x652e5667, 0x210d, 0x4d06, 0x83, 0x2a, 0xbc, 0x17, 0x92, 0x7e, 0x51, 0x42);
DEFINE_GUID(IID_IDirectMusicTimeShiftTool,0xc39abaf0, 0xc4f0, 0x4c6b, 0x83, 0x4a, 0xcf, 0x21, 0x7c, 0xbe, 0x95, 0x6d);
DEFINE_GUID(IID_IDirectMusicSwingTool,0xd876ffee, 0x3a6f, 0x43db, 0xa3, 0x5c, 0x68, 0x7b, 0x38, 0x6a, 0x71, 0x65);
DEFINE_GUID(IID_IDirectMusicVelocityTool,0xb15eb722, 0xfb50, 0x4e1f, 0xb2, 0x1, 0xa6, 0x99, 0xe0, 0x47, 0x79, 0x54);
DEFINE_GUID(IID_IDirectMusicMuteTool,0x20cc9511, 0x5802, 0x49a0, 0xba, 0x91, 0x8b, 0x29, 0xb0, 0xf7, 0x22, 0xab);
DEFINE_GUID(IID_IDirectMusicChordSequenceTool,0xc32c1b34, 0xe604, 0x48c1, 0xba, 0x8c, 0x7b, 0x50, 0x10, 0x17, 0xbd, 0x68);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif // _TOOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\toolprop_i.c ===
#include <toolprops_i.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\transpose.cpp ===
// Transpose.cpp : Implementation of CTransposeTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "transpose.h"
#include "toolhelp.h"

// We keep a default chord of C7 in the scale of C, in case there is no chord track
// at the time an in scale transposition is requested.

DMUS_CHORD_KEY CTransposeTool::m_gDefaultChord;

CTransposeTool::CTransposeTool()
{
    ParamInfo Params[DMUS_TRANSPOSE_PARAMCOUNT] = 
    {
        { DMUS_TRANSPOSE_AMOUNT, MPT_INT,MP_CAPS_ALL,-24,24,0,
            L"Intervals",L"Transpose",NULL},        // Tranpose - none by default
        { DMUS_TRANSPOSE_TYPE, MPT_ENUM,MP_CAPS_ALL,
            DMUS_TRANSPOSET_LINEAR,DMUS_TRANSPOSET_SCALE,DMUS_TRANSPOSET_SCALE,
            L"",L"Type",L"Linear,In Scale"} // Type - transpose in scale by default
    };
    InitParams(DMUS_TRANSPOSE_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
    wcscpy(m_gDefaultChord.wszName, L"M7");
    m_gDefaultChord.wMeasure = 0;
    m_gDefaultChord.bBeat = 0;
    m_gDefaultChord.bSubChordCount = 1;
    m_gDefaultChord.bKey = 12;
    m_gDefaultChord.dwScale = 0xab5ab5; // default scale is C Major
    m_gDefaultChord.bFlags = 0;
    for (int n = 0; n < DMUS_MAXSUBCHORD; n++)
    {
        m_gDefaultChord.SubChordList[n].dwChordPattern = 0x891; // default chord is major 7
        m_gDefaultChord.SubChordList[n].dwScalePattern = 0xab5ab5; // default scale is C Major
        m_gDefaultChord.SubChordList[n].dwInversionPoints = 0xffffff;
        m_gDefaultChord.SubChordList[n].dwLevels = 0xffffffff;
        m_gDefaultChord.SubChordList[n].bChordRoot = 12; // 2C
        m_gDefaultChord.SubChordList[n].bScaleRoot = 0;
    }
}

STDMETHODIMP_(ULONG) CTransposeTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTransposeTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CTransposeTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicTransposeTool)
	{
		*ppv = static_cast<IDirectMusicTransposeTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CTransposeTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicTransposeTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CTransposeTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CTransposeTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_TRANSPOSE_CHUNK))
	{
        DMUS_IO_TRANSPOSE_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_TRANSPOSE_AMOUNT,(float) Header.lTranspose);
            SetParam(DMUS_TRANSPOSE_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CTransposeTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_TRANSPOSE_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_TRANSPOSE_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_TRANSPOSE_HEADER Header;
        GetParamInt(DMUS_TRANSPOSE_AMOUNT,MAX_REF_TIME,(long *) &Header.lTranspose);
        GetParamInt(DMUS_TRANSPOSE_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTransposeTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_TRANSPOSE_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CTransposeTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_TransposePage;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CTransposeTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only transpose notes that are not on the drum pChannel.
    if( (pPMsg->dwType == DMUS_PMSGT_NOTE ) && ((pPMsg->dwPChannel & 0xF) != 0x9))
    {
        // We need to know the time format so we can call GetParamInt() to read control parameters.
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        long lTranspose, lType;
        long lNote = pNote->bMidiValue;
        
        GetParamInt(DMUS_TRANSPOSE_AMOUNT,rtTime,&lTranspose);
        GetParamInt(DMUS_TRANSPOSE_TYPE,rtTime,&lType);
        if (lType == DMUS_TRANSPOSET_LINEAR)
        {
            lNote += lTranspose;
            while (lNote < 0) lNote += 12;
            while (lNote > 127) lNote -= 12;
            pNote->bMidiValue = (BYTE) lNote;
        }
        else
        {
            IDirectMusicPerformance8 *pPerf8;
            if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **) &pPerf8)))
            {
                DMUS_CHORD_KEY Chord;
                DMUS_CHORD_KEY *pChord = &Chord;
                if (FAILED(pPerf8->GetParamEx(GUID_ChordParam,pNote->dwVirtualTrackID,
                                   pNote->dwGroupID,0,pNote->mtTime - pNote->nOffset, NULL, pChord)))
                {
                    // Couldn't find an active scale, use major scale instead.
                    pChord = &m_gDefaultChord;
                }
                WORD wVal;
                // First, use the current chord & scale to convert the note's midi value into scale position.
                if (SUCCEEDED(pPerf->MIDIToMusic(pNote->bMidiValue ,pChord,DMUS_PLAYMODE_PEDALPOINT,pNote->bSubChordLevel,&wVal)))
                {
                    // Scale position is octave position * 7 plus chord position * 2 plus the scale position.
                    long lScalePosition = (((wVal & 0xF000) >> 12) * 7) + (((wVal & 0xF00) >> 8) * 2) + ((wVal & 0xF0) >> 4);
                    // Now that we are looking at scale position, we can add the transposition.
                    lScalePosition += lTranspose;
                    // Make sure we don't wrap around.
                    while (lScalePosition < 0) lScalePosition += 7;
                    // A high MIDI value of 127 translates to scale position 74.
                    while (lScalePosition > 74) lScalePosition -= 7;
                    wVal &= 0x000F; // Keep only the accidental. 
                    // Now, insert the values back in. Start with chord.
                    wVal |= ((lScalePosition / 7) << 12);
                    // Then, scale position.
                    wVal |= ((lScalePosition % 7) << 4);
                    pPerf->MusicToMIDI(wVal,pChord,DMUS_PLAYMODE_PEDALPOINT,
                        pNote->bSubChordLevel,&pNote->bMidiValue);
                }
                pPerf8->Release();
            }
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CTransposeTool::Clone( IDirectMusicTool ** ppTool)

{
    CTransposeTool *pNew = new CTransposeTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CTransposeTool::SetTranspose(long lTranpose) 
{
    return SetParam(DMUS_TRANSPOSE_AMOUNT,(float) lTranpose);
}

STDMETHODIMP CTransposeTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_TRANSPOSE_TYPE,(float) dwType);
}

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF

STDMETHODIMP CTransposeTool::GetTranspose(long * plTranspose) 
{
    return GetParamInt(DMUS_TRANSPOSE_AMOUNT,MAX_REF_TIME, plTranspose);
}

STDMETHODIMP CTransposeTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_TRANSPOSE_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\transpose.h ===
#ifndef _TRANSPOSE_TOOL_
#define _TRANSPOSE_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CTransposeTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicTransposeTool

{
public:
	CTransposeTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    virtual STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);
    
// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicTransposeTool
	STDMETHODIMP SetTranspose(long lTranspose) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetTranspose(long * plTranspose) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
private:
    static DMUS_CHORD_KEY m_gDefaultChord;
};

#endif // _TRANSPOSE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\velocity.cpp ===
// Velocity.cpp : Implementation of CVelocityTool
//
// Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "velocity.h"
#include "toolhelp.h"

CVelocityTool::CVelocityTool()
{
    ParamInfo Params[DMUS_VELOCITY_PARAMCOUNT] = 
    {
        { DMUS_VELOCITY_STRENGTH, MPT_INT,MP_CAPS_ALL,0,100,100,
            L"Percent",L"Strength",NULL },            // Strength - 100% by default
        { DMUS_VELOCITY_LOWLIMIT, MPT_INT,MP_CAPS_ALL,1,127,1,
            L"Velocity",L"Lower Limit",NULL },        // Lower limit - 1 by default
        { DMUS_VELOCITY_HIGHLIMIT, MPT_INT,MP_CAPS_ALL,1,127,127,
            L"Velocity",L"Upper Limit",NULL },        // Upper limit - 127 by default
        { DMUS_VELOCITY_CURVESTART, MPT_INT,MP_CAPS_ALL,1,127,1,
            L"Velocity",L"Curve Start",NULL },        // Curve start - 1 by default
        { DMUS_VELOCITY_CURVEEND, MPT_INT,MP_CAPS_ALL,1,127,127,
            L"Velocity",L"Curve End",NULL },          // Curve End - 127 by default
    };
    InitParams(DMUS_VELOCITY_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CVelocityTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CVelocityTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CVelocityTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicVelocityTool)
	{
		*ppv = static_cast<IDirectMusicVelocityTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CVelocityTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicVelocityTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CVelocityTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CVelocityTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_VELOCITY_CHUNK))
	{
        DMUS_IO_VELOCITY_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_VELOCITY_STRENGTH,(float) Header.lStrength);
            SetParam(DMUS_VELOCITY_LOWLIMIT,(float) Header.lLowLimit);
            SetParam(DMUS_VELOCITY_HIGHLIMIT,(float) Header.lHighLimit);
            SetParam(DMUS_VELOCITY_CURVESTART,(float) Header.lCurveStart);
            SetParam(DMUS_VELOCITY_CURVEEND,(float) Header.lCurveEnd);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CVelocityTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_VELOCITY_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_VELOCITY_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_VELOCITY_HEADER Header;
        GetParamInt(DMUS_VELOCITY_STRENGTH,MAX_REF_TIME,&Header.lStrength);
        GetParamInt(DMUS_VELOCITY_LOWLIMIT,MAX_REF_TIME,&Header.lLowLimit);
        GetParamInt(DMUS_VELOCITY_HIGHLIMIT,MAX_REF_TIME,&Header.lHighLimit);
        GetParamInt(DMUS_VELOCITY_CURVESTART,MAX_REF_TIME,&Header.lCurveStart);
        GetParamInt(DMUS_VELOCITY_CURVEEND,MAX_REF_TIME,&Header.lCurveEnd);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CVelocityTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_VELOCITY_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CVelocityTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_VelocityPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CVelocityTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        long lStrength;
        long lLowLimit, lHighLimit, lCurveStart, lCurveEnd;
        GetParamInt(DMUS_VELOCITY_STRENGTH,rtTime,&lStrength);
        GetParamInt(DMUS_VELOCITY_LOWLIMIT,rtTime,&lLowLimit);
        GetParamInt(DMUS_VELOCITY_HIGHLIMIT,rtTime,&lHighLimit);
        GetParamInt(DMUS_VELOCITY_CURVESTART,rtTime,&lCurveStart);
        GetParamInt(DMUS_VELOCITY_CURVEEND,rtTime,&lCurveEnd);
        if (lCurveStart <= lCurveEnd)
        {
            long lNewVelocity;
            if (pNote->bVelocity <= lCurveStart)
            {
                lNewVelocity = lLowLimit;
            }
            else if (pNote->bVelocity >= lCurveEnd)
            {
                lNewVelocity = lHighLimit;
            }
            else
            {
                // For this case, compute the point on the line between (lCurveStart, lLowLimit) and (lCurveEnd, lHighLimit)
                lNewVelocity = lLowLimit + ((lHighLimit - lLowLimit) * (pNote->bVelocity - lCurveStart)) / (lCurveEnd - lCurveStart);
            }
            // Now, calculate the change we want to apply.
            lNewVelocity -= pNote->bVelocity;
            // Scale it to the amount we'll actually do.
            lNewVelocity = (lNewVelocity * lStrength) / 100;
            lNewVelocity += pNote->bVelocity;
            if (lNewVelocity < 1) lNewVelocity = 1;
            if (lNewVelocity > 127) lNewVelocity = 127;
            pNote->bVelocity = (BYTE) lNewVelocity;
        }

    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CVelocityTool::Clone( IDirectMusicTool ** ppTool)

{
    CVelocityTool *pNew = new CVelocityTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CVelocityTool::SetStrength(long lStrength) 
{
    return SetParam(DMUS_VELOCITY_STRENGTH,(float) lStrength);
}

STDMETHODIMP CVelocityTool::SetLowLimit(long lVelocityOut)
{
    return SetParam(DMUS_VELOCITY_LOWLIMIT,(float) lVelocityOut);
}

STDMETHODIMP CVelocityTool::SetHighLimit(long lVelocityOut)
{
    return SetParam(DMUS_VELOCITY_HIGHLIMIT,(float) lVelocityOut);
}

STDMETHODIMP CVelocityTool::SetCurveStart(long lVelocityIn)
{
    return SetParam(DMUS_VELOCITY_CURVESTART,(float) lVelocityIn);
}

STDMETHODIMP CVelocityTool::SetCurveEnd(long lVelocityIn)
{
    return SetParam(DMUS_VELOCITY_CURVEEND,(float) lVelocityIn);
}

STDMETHODIMP CVelocityTool::GetStrength(long * plStrength) 
{
    return GetParamInt(DMUS_VELOCITY_STRENGTH,MAX_REF_TIME,plStrength);
}

STDMETHODIMP CVelocityTool::GetLowLimit(long * plVelocityOut) 
{
    return GetParamInt(DMUS_VELOCITY_LOWLIMIT,MAX_REF_TIME,plVelocityOut);
}

STDMETHODIMP CVelocityTool::GetHighLimit(long * plVelocityOut) 
{
    return GetParamInt(DMUS_VELOCITY_HIGHLIMIT,MAX_REF_TIME,plVelocityOut);
}

STDMETHODIMP CVelocityTool::GetCurveStart(long * plVelocityIn) 
{
    return GetParamInt(DMUS_VELOCITY_CURVESTART,MAX_REF_TIME,plVelocityIn);
}

STDMETHODIMP CVelocityTool::GetCurveEnd(long * plVelocityIn) 
{
    return GetParamInt(DMUS_VELOCITY_CURVEEND,MAX_REF_TIME,plVelocityIn);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\velocity.h ===
#ifndef _VELOCITY_TOOL_
#define _VELOCITY_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "toolprops\toolprops.h"

class CVelocityTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicVelocityTool

{
public:
	CVelocityTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicVelocityTool
	STDMETHODIMP SetStrength(long lStrength) ;
    STDMETHODIMP SetLowLimit(long lVelocityOut) ;
    STDMETHODIMP SetHighLimit(long lVelocityOut) ;
    STDMETHODIMP SetCurveStart(long lVelocityIn) ;
    STDMETHODIMP SetCurveEnd(long lVelocityIn) ;

	STDMETHODIMP GetStrength(long * plStrength) ;
    STDMETHODIMP GetLowLimit(long * plVelocityOut) ;
    STDMETHODIMP GetHighLimit(long * plVelocityOut) ;
    STDMETHODIMP GetCurveStart(long * plVelocityIn) ;
    STDMETHODIMP GetCurveEnd(long * plVelocityIn) ;

protected:	
};

#endif // _VELOCITY_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\toolprops\toolprops_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 17 13:39:44 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtool\toolprops\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_TOOLPROPSLib = {0x2735B8F3,0xFF4A,0x4AF2,{0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32}};


const CLSID CLSID_EchoPage = {0x5337AF8F,0x3827,0x44DD,{0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F}};


const CLSID CLSID_TransposePage = {0x691BD8C2,0x2B07,0x4C92,{0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6}};


const CLSID CLSID_DurationPage = {0x79D9CAF8,0xDBDA,0x4560,{0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B}};


const CLSID CLSID_QuantizePage = {0x623286DC,0x67F8,0x4055,{0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmtool\toolprops\toolprops.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for toolprops.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __toolprops_h__
#define __toolprops_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __EchoPage_FWD_DEFINED__
#define __EchoPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class EchoPage EchoPage;
#else
typedef struct EchoPage EchoPage;
#endif /* __cplusplus */

#endif 	/* __EchoPage_FWD_DEFINED__ */


#ifndef __TransposePage_FWD_DEFINED__
#define __TransposePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransposePage TransposePage;
#else
typedef struct TransposePage TransposePage;
#endif /* __cplusplus */

#endif 	/* __TransposePage_FWD_DEFINED__ */


#ifndef __DurationPage_FWD_DEFINED__
#define __DurationPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DurationPage DurationPage;
#else
typedef struct DurationPage DurationPage;
#endif /* __cplusplus */

#endif 	/* __DurationPage_FWD_DEFINED__ */


#ifndef __QuantizePage_FWD_DEFINED__
#define __QuantizePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class QuantizePage QuantizePage;
#else
typedef struct QuantizePage QuantizePage;
#endif /* __cplusplus */

#endif 	/* __QuantizePage_FWD_DEFINED__ */


#ifndef __TimeShiftPage_FWD_DEFINED__
#define __TimeShiftPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeShiftPage TimeShiftPage;
#else
typedef struct TimeShiftPage TimeShiftPage;
#endif /* __cplusplus */

#endif 	/* __TimeShiftPage_FWD_DEFINED__ */


#ifndef __SwingPage_FWD_DEFINED__
#define __SwingPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class SwingPage SwingPage;
#else
typedef struct SwingPage SwingPage;
#endif /* __cplusplus */

#endif 	/* __SwingPage_FWD_DEFINED__ */


#ifndef __VelocityPage_FWD_DEFINED__
#define __VelocityPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class VelocityPage VelocityPage;
#else
typedef struct VelocityPage VelocityPage;
#endif /* __cplusplus */

#endif 	/* __VelocityPage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __TOOLPROPSLib_LIBRARY_DEFINED__
#define __TOOLPROPSLib_LIBRARY_DEFINED__

/* library TOOLPROPSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TOOLPROPSLib;

EXTERN_C const CLSID CLSID_EchoPage;

#ifdef __cplusplus

class DECLSPEC_UUID("5337AF8F-3827-44DD-9EE9-AB6E1AABB60F")
EchoPage;
#endif

EXTERN_C const CLSID CLSID_TransposePage;

#ifdef __cplusplus

class DECLSPEC_UUID("691BD8C2-2B07-4C92-A82E-92D858DE23D6")
TransposePage;
#endif

EXTERN_C const CLSID CLSID_DurationPage;

#ifdef __cplusplus

class DECLSPEC_UUID("79D9CAF8-DBDA-4560-A8B0-07E73A79FA6B")
DurationPage;
#endif

EXTERN_C const CLSID CLSID_QuantizePage;

#ifdef __cplusplus

class DECLSPEC_UUID("623286DC-67F8-4055-A9BE-F7A7176BD150")
QuantizePage;
#endif

EXTERN_C const CLSID CLSID_TimeShiftPage;

#ifdef __cplusplus

class DECLSPEC_UUID("7D3BDEE7-9557-4085-82EE-1B2F02CE4BA6")
TimeShiftPage;
#endif

EXTERN_C const CLSID CLSID_SwingPage;

#ifdef __cplusplus

class DECLSPEC_UUID("0B237E01-062A-4A40-8D43-4B5FCD49965A")
SwingPage;
#endif

EXTERN_C const CLSID CLSID_VelocityPage;

#ifdef __cplusplus

class DECLSPEC_UUID("30EC7213-64BE-4EF6-BB1B-463427EC864B")
VelocityPage;
#endif
#endif /* __TOOLPROPSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//
#ifdef XBOX
#include <xtl.h>
#include <xdbg.h>
#else  // XBOX
#include <windows.h>
#endif // XBOX
#include <stdio.h>
#include <stdarg.h>
#include <dmusicip.h>
#include "debug.h"

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
extern "C" void DMRegisterPMsgPerformanceCounters();
extern "C" void DMUnregisterPMsgPerformanceCounters();
extern "C" void DMRPC_DownloadBuffer();
extern "C" void DMURPC_DownloadBuffer();
#endif

// Heap objects
IDirectMusicHeap* gpDMHeap;
IDirectMusicHeap* gpDMPhysicalHeap;

// General Direct Music Initialization hook
// Required because we can't allocate any memory until after the heap is registered,
// but then there are various objects that depend upon static constructors being called.

extern LPDIRECTMUSICFACTORYFN gDirectMusicFactoryFn;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

HRESULT WrapPerformanceCountersAroundHeap(bool bPhysicalHeap, IDirectMusicHeap* pHeap, IDirectMusicHeap** ppWrappedHeap);

#endif


void InitializeDirectMusicDoWorkCriticalSection();
extern void CScriptTrackCallListInitialize(void);

void DirectMusicInitializedCheck(){
	ASSERTMSG("You must call either DirectMusicInitialize or DirectMusicInitializeEx before using DirectMusic.",
		gDirectMusicFactoryFn != NULL);
}

HRESULT WINAPI DirectMusicInitializeEx(IDirectMusicHeap* pNormalHeap, IDirectMusicHeap* pPhysicalHeap,
                                       LPDIRECTMUSICFACTORYFN pFactory){
    ASSERTMSG("Must not be NULL.",pNormalHeap);
    ASSERTMSG("Must not be NULL.",pPhysicalHeap);
    ASSERTMSG("Must not be NULL.",pFactory);

    ASSERTMSG("DirectMusicInitialize or DirectMusicInitializeEx has already been called.",
        gDirectMusicFactoryFn == NULL);

    HRESULT hr = S_OK;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    IDirectMusicHeap* pWrappedHeap;
    hr = WrapPerformanceCountersAroundHeap(false, pNormalHeap, &pWrappedHeap);
    if(SUCCEEDED(hr)){
        pNormalHeap = pWrappedHeap;
    }
    if(SUCCEEDED(hr)){
        hr = WrapPerformanceCountersAroundHeap(true, pPhysicalHeap, &pWrappedHeap);
    }
    if(SUCCEEDED(hr)){
        pPhysicalHeap = pWrappedHeap;
    }
#else
    pNormalHeap->AddRef();
    pPhysicalHeap->AddRef();
#endif

    if(SUCCEEDED(hr)){
        gpDMHeap = pNormalHeap;

        gpDMPhysicalHeap = pPhysicalHeap;

        gDirectMusicFactoryFn = pFactory;

        CScriptTrackCallListInitialize();
        InitializeDirectMusicDoWorkCriticalSection();
    }
    return hr;
}

HRESULT WINAPI DirectMusicInitialize(){
    HRESULT hr = S_OK;
    IDirectMusicHeap* pHeap = NULL;
    IDirectMusicHeap* pPhysicalHeap = NULL;
    if(SUCCEEDED(hr)){
        hr = DirectMusicCreateDefaultHeap(&pHeap);
    }
    if(SUCCEEDED(hr)){
        hr = DirectMusicCreateDefaultPhysicalHeap(&pPhysicalHeap);
    }
    if(SUCCEEDED(hr)){
        hr = DirectMusicInitializeEx(pHeap, pPhysicalHeap, &DirectMusicDefaultFactory);
    }
    if(pHeap){
        pHeap->Release();
    }
    if(pPhysicalHeap){
        pPhysicalHeap->Release();
    }
    return hr;
}

void* DirectMusicAllocI(size_t cb)
{
    if(!gpDMHeap) {
    	DirectMusicInitializedCheck();
    }
    void* pData = NULL;
    HRESULT hr = gpDMHeap->Allocate(cb, &pData);
    if(FAILED(hr) || pData == NULL){
        Trace(1,"DirectMusic normal heap failed to allocate a block of size %d bytes.\n", cb);
        return NULL;
    }
    ASSERTMSG("Allocated memory must be DWORD aligned.", (((int) pData) & 3) == 0);
    return pData;
}

void DirectMusicFreeI(void *pv)
{
    if(!gpDMHeap) {
    	DirectMusicInitializedCheck();
    }
    if(pv){
        gpDMHeap->Free(pv);
    }
}

void* DirectMusicPhysicalAllocI(size_t dwSize)
{
    if(!gpDMPhysicalHeap) {
    	DirectMusicInitializedCheck();
    }
    void* pData = NULL;
    HRESULT hr = gpDMPhysicalHeap->Allocate(dwSize, &pData);
    ASSERTMSG("Allocated memory must be DWORD aligned.", (((int) pData) & 3) == 0);
    if(FAILED(hr) || pData == NULL){
        Trace(1,"DirectMusic physical heap failed to allocate a block of size %d bytes.\n", dwSize);
        return NULL;
    }
    return pData;
}

void DirectMusicPhysicalFreeI(void *pv)
{
    if(!gpDMPhysicalHeap) {
        DirectMusicInitializedCheck();
    }
    if(pv){
        gpDMPhysicalHeap->Free(pv);
    }
}

// Standard heaps
// Note that we allocate these objects using LocalAlloc and free rather than the DMusic heap

#define LOCALALLOC_NEWDELETE \
    public: __inline void *__cdecl operator new(size_t cbBuffer) { return LocalAlloc(0,cbBuffer); } \
    public: __inline void *__cdecl operator new[](size_t cbBuffer) { return LocalAlloc(0,cbBuffer); } \
    public: __inline void __cdecl operator delete(void *pvBuffer) { if(pvBuffer) LocalFree(pvBuffer); } \
    public: __inline void __cdecl operator delete[](void *pvBuffer) { if(pvBuffer) LocalFree(pvBuffer); }


class DirectMusicDefaultHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicDefaultHeap(){
        m_cRef = 1;
    }

    HRESULT Initialize() {
        return S_OK;
    }

    ~DirectMusicDefaultHeap() {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        *ppData = HeapAlloc(GetProcessHeap(),0, dwSize); // LocalAlloc is threadsafe. Can't use malloc/free because it might not be threadsafe.
        if(!*ppData){
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }

    STDMETHOD(GetSize)(THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            DWORD dwSize = HeapSize(GetProcessHeap(), 0, pData);
            if(dwSize ==0xFFFFFFFF){
                hr = E_FAIL;
            }
            else {
                *pcbSize = dwSize;
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        HeapFree(GetProcessHeap(),0,pData); // LocalFree is threadsafe. Can't use malloc/free because it might not be threadsafe.
        return S_OK;
    }
};

class DirectMusicDefaultPhysicalHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicDefaultPhysicalHeap(){
        m_cRef = 1;
    }

    HRESULT Initialize() {
        return S_OK;
    }

    ~DirectMusicDefaultPhysicalHeap() {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        PVOID pData = XPhysicalAlloc(dwSize+4, MAXULONG_PTR, 0, PAGE_READWRITE);
        if(!pData){
            return E_OUTOFMEMORY;
        }
        ((DWORD*) pData)[0] = dwSize;
        *ppData = ((DWORD*) pData) + 1;
        return S_OK;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            *pcbSize = ((DWORD*) pData)[-1];
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        XPhysicalFree(((DWORD*) pData)-1);
        return S_OK;
    }
};

class DirectMusicFixedSizeHeap2 : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicFixedSizeHeap2(){
        m_cRef = 1;
        m_hHeap = GetProcessHeap();
        InitializeCriticalSection(&m_csPhysicalHeap);
    }

    HRESULT Initialize(DWORD dwNormalHeapSize) {
        m_dwLimit = dwNormalHeapSize;
        m_dwSize = 0;
        return S_OK;
    }

    ~DirectMusicFixedSizeHeap2() {
        // We don't delete m_hHeap, since it's the default process heap
        DeleteCriticalSection(&m_csPhysicalHeap);
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        HRESULT hr = S_OK;
        EnterCriticalSection(&m_csPhysicalHeap);
        if(m_dwSize + dwSize <= m_dwLimit){
            PVOID pData = HeapAlloc(m_hHeap, 0, dwSize);
            if(!pData){
			    hr = E_OUTOFMEMORY;
            }
            else {
                m_dwSize += dwSize;
                *ppData = pData;
            }
        }
        else {
            Trace(1,"Normal fixed size heap is out of memory. Limit = %d, current size = %d, request = %d.\n",
                m_dwLimit, m_dwSize, dwSize);
		    hr = E_OUTOFMEMORY;
        }
        LeaveCriticalSection(&m_csPhysicalHeap);
        return hr;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            DWORD dwSize = HeapSize(m_hHeap, 0, pData);
            if(dwSize ==0xFFFFFFFF){
                hr = E_FAIL;
            }
            else {
                *pcbSize = dwSize;
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        HRESULT hr = S_OK;
        if(pData){
            EnterCriticalSection(&m_csPhysicalHeap);
            DWORD dwSize = HeapSize(m_hHeap, 0, pData);
            if(m_dwSize >= dwSize){
                m_dwSize -= dwSize;
            }
            HeapFree(m_hHeap, 0, pData);
            LeaveCriticalSection(&m_csPhysicalHeap);
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }


private:
    CRITICAL_SECTION m_csPhysicalHeap;
    HANDLE m_hHeap; // An alias to GetProcessHeap();
    DWORD m_dwSize;
    DWORD m_dwLimit;

};

class DirectMusicFixedSizeHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE

    // Use standard HeapCreate / HeapAlloc heap for the normal heap.
    // 

    HANDLE m_hHeap; // Used for small blocks

    struct BlockHeader {
        DWORD dwSize;
    };

    // 1044480 is the threshold for using VirtualAlloc on the Xbox implementation of the Rtl Heap.
#define LARGEST_SMALL_HEAP_BLOCK_SIZE (1044480-sizeof(BlockHeader)) /* Blocks larger than this size are allocated using VirtualAlloc */

public:
    DirectMusicFixedSizeHeap(){
        m_cRef = 1;
        m_hHeap = 0;
    }

    HRESULT Initialize(DWORD dwNormalHeapSize) {
        if(dwNormalHeapSize){
            m_hHeap = HeapCreate(0, dwNormalHeapSize, dwNormalHeapSize);
            if(!m_hHeap){
                return E_OUTOFMEMORY;
            }
        }
        return S_OK;
    }

    ~DirectMusicFixedSizeHeap() {
        if(m_hHeap) {
            HeapDestroy(m_hHeap);
        }
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        HRESULT hr = S_OK;
        if(m_hHeap){
            DWORD dwSize2 = dwSize + sizeof(BlockHeader);
            PVOID pData = 0;
            if (dwSize <= LARGEST_SMALL_HEAP_BLOCK_SIZE){
                pData = HeapAlloc(m_hHeap, 0, dwSize2);
            }
            else {
                Trace(2,"DirectMusicFixedSizeHeap allocating large block (%d bytes) using VirtualAlloc\n", dwSize);
                pData = VirtualAlloc(NULL, dwSize2, MEM_COMMIT, PAGE_READWRITE);
            }
            if(!pData){
			    hr = E_OUTOFMEMORY;
            }
            else {
                BlockHeader* pHeader = (BlockHeader*) pData;
                pHeader->dwSize = dwSize;
                *ppData = pHeader + 1;
            }
        }
        else {
		    hr = E_OUTOFMEMORY;
        }
        return hr;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            BlockHeader* pHeader = ((BlockHeader*) pData) - 1;
            *pcbSize = pHeader->dwSize;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        HRESULT hr = S_OK;
        if(m_hHeap){
            if(pData){
                BlockHeader* pHeader = ((BlockHeader*) pData) - 1;
                if(pHeader->dwSize <= LARGEST_SMALL_HEAP_BLOCK_SIZE){ 
                    HeapFree(m_hHeap, 0, pHeader);
                }
                else {
                    VirtualFree(pHeader, 0, MEM_RELEASE);
                }
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }


private:

};

// VerifyHeap is slow, so we only do it on debug builds.

#ifdef DBG
    #define VERIFYHEAP// VerifyHeap();
#else
    #define VERIFYHEAP
#endif

class DirectMusicFixedSizePhysicalHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicFixedSizePhysicalHeap(){
        m_cRef = 1;
        m_pHead = 0;
        InitializeCriticalSection(&m_csPhysicalHeap);
    }

private:
    // Use a traditional first-fit heap for the physical memory heap

    struct BlockHead {
        BlockHead* pNext;
        unsigned int size;
        DWORD bUsed; // A DWORD to make the whole BlockHead struct DWORD aligned
    };

    CRITICAL_SECTION m_csPhysicalHeap;
    BlockHead* m_pHead;

public:

    HRESULT Initialize(DWORD dwPhysicalHeapSize) {

        if(dwPhysicalHeapSize < sizeof(BlockHead)){
            dwPhysicalHeapSize = 0;
        }
        else {
            m_pHead = (BlockHead*) XPhysicalAlloc(dwPhysicalHeapSize, MAXULONG_PTR, 0, PAGE_READWRITE);
            if(!m_pHead){
                return E_OUTOFMEMORY;
            }
            m_pHead->pNext = 0;
            m_pHead->size = dwPhysicalHeapSize-sizeof(BlockHead);
            m_pHead->bUsed = 0;
        }

        return S_OK;
    }

    ~DirectMusicFixedSizePhysicalHeap() {
        if(m_pHead){
            XPhysicalFree(m_pHead);
        }
        DeleteCriticalSection(&m_csPhysicalHeap);
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap methods */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        if(!m_pHead){
            return E_OUTOFMEMORY;
        }
		VERIFYHEAP
        PVOID pData = NULL;
        //Round up to the nearest DWORD.
        dwSize = (dwSize + 3) & ~3;

        EnterCriticalSection(&m_csPhysicalHeap);
        for(BlockHead* pB = m_pHead; pB; pB = pB->pNext){
            if((! pB->bUsed)){
                // Coalesce with next block, if possible
                while(pB->pNext && !pB->pNext->bUsed){
                    pB->size += pB->pNext->size + sizeof(BlockHead);
                    pB->pNext = pB->pNext->pNext;
                }
                // Is this block big enough to use?
                if(dwSize <= pB->size){
                    // Is it big enough to split?
                    if(dwSize + sizeof(BlockHead) < pB->size){
                        // split
                        BlockHead* pNew = (BlockHead*) (((char*) pB) + sizeof(BlockHead) + dwSize);
                        pNew->pNext = pB->pNext;
                        pNew->size = pB->size - (dwSize + sizeof(BlockHead));
                        pNew->bUsed = 0;
						pB->size = dwSize;
                        pB->pNext = pNew;
                    }
                    pB->bUsed = 'z';
                    pData = (void*) (((char*) pB) + sizeof(BlockHead));
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_csPhysicalHeap);
		VERIFYHEAP
        if(!pData){
            return E_OUTOFMEMORY;
        }
        *ppData = pData;
		VERIFYHEAP
        return S_OK;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
            *pcbSize = pB->size;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        if(!m_pHead){
            return E_FAIL;
        }
        if(pData){
			VERIFYHEAP
            EnterCriticalSection(&m_csPhysicalHeap);
            BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
            ASSERTMSG("Bad Block", pB->bUsed == 'z');
            pB->bUsed = 0;
            LeaveCriticalSection(&m_csPhysicalHeap);
			VERIFYHEAP
        }
        return S_OK;
    }

#ifdef VERIFYHEAP

	STDMETHOD(VerifyHeap)(){
		DWORD dwCount = 0;
		BlockHead *pB = NULL;
		char *pByte;

		EnterCriticalSection(&m_csPhysicalHeap);

		for(pB = m_pHead; pB; pB = pB->pNext){
			dwCount++;
			pByte = (char *)pB;
        
			//Verify that the first and last byte in this block are 'X'.
			if(pB->bUsed == 0){
				if((pByte + sizeof(BlockHead))[0] != 'X'){
					Trace(1,"Heap Corruption at beginning of block");
					assert(FALSE);
				}

				if((pByte + sizeof(BlockHead))[pB->size - 1] != 'X'){
					Trace(1,"Heap Corruption at end of block");
					assert(FALSE);
				}
			}

			//Verify that the sizes match.
			if (pB->pNext) {
				if((char *)pB->pNext - (char *)pB != pB->size + sizeof(BlockHead)){
					Trace(1,"Difference between pB (%08X) and pB->pNext (%08X) is %08X (%d), but the size of pB + sizeof(BlockHead) is %08X (%d)\n",
						 pB,
						 pB->pNext,
						 (char *)pB->pNext - (char *)pB,
						 (char *)pB->pNext - (char *)pB,
						 pB->size,
						 pB->size
						 );
					assert(FALSE);
				}
			}
		}

		LeaveCriticalSection(&m_csPhysicalHeap);
		return S_OK;
	}
#endif
};

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

class PerformanceCounterWrapper : public IDirectMusicHeap {
    LOCALALLOC_NEWDELETE
public:
    PerformanceCounterWrapper(){
        InitializeCriticalSection(&m_csHeap);
        m_cRef = 1;
        m_pHeap = 0;
        m_bPhysicalHeap = false;
    }

    ~PerformanceCounterWrapper(){
        if(m_pHeap){
            m_pHeap->Release();
        }
        DeleteCriticalSection(&m_csHeap);
    }

    HRESULT Initialize(bool bIsPhysicalHeap, IDirectMusicHeap* pHeap){
        m_bPhysicalHeap = bIsPhysicalHeap;
        m_pHeap = pHeap;
        m_pHeap->AddRef();
        m_dwHeapAllocation = 0;
        m_dwHeapAllocationPeak = 0;
        m_dwHeapAllocationBlocks = 0;
        m_dwHeapAllocationBlocksPeak = 0;
        m_dwHeapAllocationRate = 0;
        m_dwHeapAllocationBlocksRate = 0;
        return S_OK;
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        PVOID pData = Alloc(dwSize);
        if(!pData){
            return E_OUTOFMEMORY;
        }
        *ppData = pData;
        return S_OK;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        return Free2(pData);
    }

    void* Alloc(size_t cb){
        DWORD* pBlock = 0;
        HRESULT hr = m_pHeap->Allocate(cb, (PVOID*) & pBlock);
        if(FAILED(hr)){
            return NULL;
        }
        if(!pBlock){
            return NULL;
        }
        ASSERTMSG("Allocated memory must be DWORD aligned.", (((int) pBlock) & 3) == 0);
        EnterCriticalSection(&m_csHeap);
        m_dwHeapAllocation += cb;
        if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
            m_dwHeapAllocationPeak = m_dwHeapAllocation;
        }
        ++m_dwHeapAllocationBlocks;
        if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
            m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
        }
        m_dwHeapAllocationRate += cb;
        ++m_dwHeapAllocationBlocksRate;
        LeaveCriticalSection(&m_csHeap);

        return pBlock;
    }

    STDMETHOD(GetSize)(THIS_ PVOID pData, LPDWORD pcbSize){
        return m_pHeap->GetSize(pData, pcbSize);
    }

    HRESULT Free2(void *pv)
    {
        HRESULT hr = S_OK;
        if(pv){
            DWORD cb;
            hr = m_pHeap->GetSize(pv, &cb);
            if(SUCCEEDED(hr)){
                EnterCriticalSection(&m_csHeap);
                m_dwHeapAllocation -= cb;
                --m_dwHeapAllocationBlocks;
                LeaveCriticalSection(&m_csHeap);
                hr = m_pHeap->Free(pv);
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    void RegisterPerformanceCounters(){
        DMusicRegisterPerformanceCounter( Name("bytes"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocation );
        DMusicRegisterPerformanceCounter( Name("bytes peak"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationPeak );
        DMusicRegisterPerformanceCounter( Name("allocations"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationBlocks );
        DMusicRegisterPerformanceCounter( Name("allocations peak"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationBlocksPeak );
        DMusicRegisterPerformanceCounter( Name("allocation byte rate"),
                                      DMCOUNT_EVENT  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationRate );
        DMusicRegisterPerformanceCounter( Name("allocation rate"),
                                      DMCOUNT_EVENT  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationBlocksRate );

    }

    void UnregisterPerformanceCounters(){
        DMusicUnregisterPerformanceCounter(Name("bytes"));
        DMusicUnregisterPerformanceCounter(Name("bytes peak"));
        DMusicUnregisterPerformanceCounter(Name("allocations"));
        DMusicUnregisterPerformanceCounter(Name("allocations peak"));
        DMusicUnregisterPerformanceCounter(Name("allocation byte rate"));
        DMusicUnregisterPerformanceCounter(Name("allocation rate"));
    }

    char* Name(const char* sBase){
        _snprintf(m_sNameBuffer, sizeof(m_sNameBuffer), "DM heap %s %s", m_bPhysicalHeap ? "physical" : "normal" , sBase);
        return m_sNameBuffer;
    }

private:
    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    DWORD m_dwHeapAllocationRate;
    DWORD m_dwHeapAllocationBlocksRate;

    bool m_bPhysicalHeap;

    char m_sNameBuffer[100];

    IDirectMusicHeap* m_pHeap;
};

HRESULT WrapPerformanceCountersAroundHeap(bool bPhysicalHeap, IDirectMusicHeap* pInsideHeap, IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    PerformanceCounterWrapper* pHeap = new PerformanceCounterWrapper();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize(bPhysicalHeap, pInsideHeap);
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}


#endif // IMPLEMENT_PERFORMANCE_COUNTERS

void* WINAPI DirectMusicAlloc(size_t cb){
    return DirectMusicAllocI(cb);
}

void WINAPI DirectMusicFree(void *pv){
    DirectMusicFreeI(pv);
}

void* WINAPI DirectMusicPhysicalAlloc(size_t dwSize){
    return DirectMusicPhysicalAllocI(dwSize);
}

void WINAPI DirectMusicPhysicalFree(void* lpAddress){
    DirectMusicPhysicalFreeI(lpAddress);
}

HRESULT WINAPI DirectMusicCreateDefaultHeap(IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicDefaultHeap* pHeap = new DirectMusicDefaultHeap();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize();
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicCreateDefaultPhysicalHeap(IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicDefaultPhysicalHeap* pHeap = new DirectMusicDefaultPhysicalHeap();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize();
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicCreateFixedSizeHeap(DWORD dwHeapSize, IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicFixedSizeHeap2* pHeap = new DirectMusicFixedSizeHeap2();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize(dwHeapSize);
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicCreateFixedSizePhysicalHeap(DWORD dwHeapSize, IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicFixedSizePhysicalHeap* pHeap = new DirectMusicFixedSizePhysicalHeap();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize(dwHeapSize);
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicInitializeFixedSizeHeaps(DWORD dwNormalHeapSize, DWORD dwPhysicalHeapSize,
											  LPDIRECTMUSICFACTORYFN pFactory)
{
	IDirectMusicHeap* pPhysicalHeap = NULL;
	IDirectMusicHeap* pNormalHeap = NULL;
	HRESULT hr = S_OK;
	if(SUCCEEDED(hr)){
		hr = DirectMusicCreateFixedSizeHeap(dwNormalHeapSize, &pNormalHeap);
	}
	if(SUCCEEDED(hr)){
		hr = DirectMusicCreateFixedSizePhysicalHeap(dwPhysicalHeapSize, &pPhysicalHeap);
	}
	if(SUCCEEDED(hr)){
		hr = DirectMusicInitializeEx(pNormalHeap, pPhysicalHeap, pFactory);
	}
	if(pPhysicalHeap){
		pPhysicalHeap->Release();
	}
	if(pNormalHeap){
		pNormalHeap->Release();
	}
	return hr;
}

#ifdef DBG

#define MODULE "DMUSIC"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel = 1;

// The current RIP level.

static int giRIPLevel = 0;

// @globalv Do asserts break?
static BOOL gfAssertBreak = 1;

// @func Sets the debug level from WIN.INI
// 

#ifdef DXAPI
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);
    giRIPLevel = 0;
    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}
#endif // DXAPI

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugStringA(szDebugPrefix);
    }
    
    OutputDebugStringA(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
#ifndef DXAPI
	if ((iDebugLevel >= 0) && (iDebugLevel <= giRIPLevel)) 
	{
		DebugBreak();
	}
#endif
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(-1, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel)
{
    giDebugLevel = iDebugLevel;
    giRIPLevel = iRIPLevel;
}

CMemTrackList g_MemTrackList[DMTRACK_MAX];

CMemTrackList::CMemTrackList()
{
    InitializeCriticalSection(&m_CriticalSection);
}

CMemTrackList::~CMemTrackList()
{
    DeleteCriticalSection(&m_CriticalSection);
}

void CMemTrackList::AddHead(CMemTrack* pMemTrack) 
{ 
    EnterCriticalSection(&m_CriticalSection);
    AList::AddHead((AListItem*)pMemTrack);
    LeaveCriticalSection(&m_CriticalSection);
}

CMemTrack* CMemTrackList::GetHead()
{
    CMemTrack *pHead;
    EnterCriticalSection(&m_CriticalSection);
    pHead = (CMemTrack*)AList::GetHead();
    LeaveCriticalSection(&m_CriticalSection);
    return pHead;
}

CMemTrack* CMemTrackList::RemoveHead() 
{
    CMemTrack *pHead;
    EnterCriticalSection(&m_CriticalSection);
    pHead = (CMemTrack *) AList::RemoveHead();
    LeaveCriticalSection(&m_CriticalSection);
    return pHead;
}

void CMemTrackList::Remove(CMemTrack* pMemTrack)
{
    EnterCriticalSection(&m_CriticalSection);
    AList::Remove((AListItem*)pMemTrack);
    LeaveCriticalSection(&m_CriticalSection);
}

LONG CMemTrackList::GetCount()
{
    LONG lCount;
    EnterCriticalSection(&m_CriticalSection);
    lCount = AList::GetCount();
    LeaveCriticalSection(&m_CriticalSection);
    return lCount;
}

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
static LONG gDMusicClassInstanceCount[DMTRACK_MAX];
#endif

CMemTrack::CMemTrack(DWORD dwClass)
{
    m_dwClass = dwClass;
    if (dwClass < DMTRACK_MAX)
    {
        g_MemTrackList[dwClass].AddHead(this);
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        InterlockedIncrement(&gDMusicClassInstanceCount[m_dwClass]);
#endif

    }
}

CMemTrack::~CMemTrack()
{
    if (m_dwClass < DMTRACK_MAX)
    {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        InterlockedDecrement(&gDMusicClassInstanceCount[m_dwClass]);
#endif
        g_MemTrackList[m_dwClass].Remove(this);
    }
}


//Don't forget to update enumClass in DEBUG.H when you update this gpNames array!!!
static char *gpNames[DMTRACK_MAX] = {
    "File Stream",
    "Memory Stream",
    "Stream Stream",
    "Segment",
    "Segment State",
    "Loader",
    "Performance",
    "Wave Track",
    "Wave",
    "Wave ViewPort",
    "Wave Download",
    "Audio Path",
    "Audio Path Config",
    "Track",
    "Script",
    "Tool Graph",
    "Band",
    "Band Track",
    "DLS Collection",
    "DirectMusic Object",
    "Instrument",
    "Downloaded Instrument",
    "Composer",
    "ChordMap",
    "Template",
    "SignPost Track",
    "ChordMap Track",
    "Buffer",
    "Lyrics Track",
    "Marker Track",
    "Parameter Control Track",
    "Segment Trigger Track",
    "Sequence Track",
    "Song",
    "System Exclusive Track",
    "Tempo Track",
    "Time Signature Track",
    "Container",
};

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
static void RegisterDMusicObjectCounters(){
    for (DWORD dwI = 0; dwI < DMTRACK_MAX;dwI++)
    {
        char buf[200];
        _snprintf(buf,sizeof(buf),"DM allocated %ss", gpNames[dwI]);
        buf[sizeof(buf)-1] = 0;
        DMusicRegisterPerformanceCounter( buf,
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &gDMusicClassInstanceCount[dwI] );
    }
}

static void UnregisterDMusicObjectCounters(){
    for (DWORD dwI = 0; dwI < DMTRACK_MAX;dwI++)
    {
        char buf[200];
        _snprintf(buf,sizeof(buf),"DM allocated %ss", gpNames[dwI]);
        buf[sizeof(buf)-1] = 0;
        DMusicUnregisterPerformanceCounter( buf );
    }
}

#endif // IMPLEMENT_PERFORMANCE_COUNTERS

long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **ppName)

{
    if (dwMemType >= DMTRACK_MAX)
    {
        return -1;
    }
    if (ppName)
    {
        *ppName = gpNames[dwMemType];
    }
    return g_MemTrackList[dwMemType].GetCount();
}

void WINAPI DirectMusicDumpMemStats();

void WINAPI DirectMusicMemDump()
{
    DWORD dwI;
    DbgPrint("Objects Allocated:\n");
    for (dwI = 0; dwI < DMTRACK_MAX;dwI++)
    {
        if (g_MemTrackList[dwI].GetCount())
        {
            DbgPrint("%ld %s",g_MemTrackList[dwI].GetCount(),gpNames[dwI]);
            if (g_MemTrackList[dwI].GetCount() > 1)
            {
                DbgPrint("s\n");
            }
            else
            {
                DbgPrint("\n");
            }
        }
    }

    DirectMusicDumpMemStats();
}

#else
void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel)
{
}
void WINAPI DirectMusicMemDump() 
{
}
long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **pName) { return (long) 0; }

#endif

// Hooks to use an allocator from the application if there is one.
//

#include "..\shared\xalloc.h"

#ifdef DBG

// Define one of the following
// #define USE_SIZE_RECORDING_ALLOCATOR

// #define USE_LEAK_DETECTING_ALLOCATOR
// #define USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR

// #define USE_XHEAP_ALLOCATOR

#define USE_C_ALLOCATOR


#else // non-debug

// #define USE_XHEAP_ALLOCATOR

#define USE_C_ALLOCATOR

#endif

interface IDirectMusicAlloc 
{
	virtual LPVOID STDMETHODCALLTYPE Alloc(THIS_ DWORD cb) = 0;
    
	virtual VOID STDMETHODCALLTYPE Free(THIS_ LPVOID pvFree) = 0;
};

#ifdef USE_SIZE_RECORDING_ALLOCATOR

class CDirectMusicAllocatorI : public IDirectMusicAlloc
{
public:
    CDirectMusicAllocatorI();

    STDMETHODIMP_(LPVOID) Alloc(THIS_ DWORD cb);
    STDMETHODIMP_(VOID)   Free(THIS_ LPVOID pvFree);

    bool EverCalled() const;

private:
    bool                    m_fEverCalled;
};

static CDirectMusicAllocatorI g_DefaultAllocator;
static IDirectMusicAlloc *g_pAllocI = &g_DefaultAllocator;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicAllocatorI::CDirectMusicAllocatorI
//
//
CDirectMusicAllocatorI::CDirectMusicAllocatorI()    
    : m_fEverCalled(false)
{
}

static DWORD dwAllocated[1000];

void WINAPI DirectMusicDumpMemStats()

{
    DWORD dwIndex;
    for (dwIndex = 0; dwIndex < 1000; dwIndex++)
    {
        if (dwAllocated[dwIndex])
        {
            Trace(1,"%ld: %ld\n",dwIndex,dwAllocated[dwIndex]);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicAllocatorI::Alloc
// CDirectMusicAllocatorI::Free
//
// Default allocator just uses malloc and free
//
// Also track if we've ever been called so we can disallow the user setting
// the allocator if there's already memory allocated.
//

STDMETHODIMP_(LPVOID) CDirectMusicAllocatorI::Alloc(THIS_ DWORD cb)
{
    if (!m_fEverCalled)
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < 1000; dwIndex++)
        {
            dwAllocated[dwIndex] = 0;
        }
    }
    if (cb < 1000)
    {
        dwAllocated[cb]++;
    }
    m_fEverCalled = true;

    return malloc(cb);
}

STDMETHODIMP_(VOID) CDirectMusicAllocatorI::Free(THIS_ LPVOID pvAlloc)
{
    free(pvAlloc);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicAllocatorI::EverCalled
//
//
bool CDirectMusicAllocatorI::EverCalled() const
{
    return m_fEverCalled;
}

#endif // USE_SIZE_RECORDING_ALLOCATOR

#ifdef USE_LEAK_DETECTING_ALLOCATOR

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR
  #define COMPILING_ROCKALL_LIBRARY
  #include "..\xheap\xheap\blendedheap.hpp"
  #include "..\xheap\xheap\smallheap.hpp"
  #include "..\xheap\xheap\fastheap.hpp"
  #include "..\xheap\xheap\debugheap.hpp"
  #include "..\xheap\xheap\dynamicdebugheap.hpp"
  #include "..\xheap\xheap\pageheap.hpp"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate
//
// Simple memory allocation class that can do diffs between two states
//
class CAllocate : public IDirectMusicAlloc
{
public:
    struct SnapBlock
    {
        void               *m_pBlock;                       // -> block as seen by app
        size_t              m_cb;                           // bytes asked for by app
        DWORD               m_RA;                           // Address of allocator
        DWORD               m_nSeq;                         // Allocation sequence number
        bool                m_fDiff;                        // After diff, true if this block
                                                            // is not present in the other
                                                            //  snapshot
        bool                m_fUser;                        // Used in 3-generation diff
    };

    struct SnapHeader
    {
        int                 m_nBlocks;                      // Number of blocks in snapshot
        DWORD               m_cbTotal;                      // Total allocated bytes (app)
        SnapBlock           m_rgBlocks[1];                  // The blocks
    };

    // Constructor
    //
    CAllocate();
    ~CAllocate();

    // Allocator implementation
    //
    STDMETHODIMP_(LPVOID) Alloc(DWORD cb);
    STDMETHODIMP_(VOID) Free(void *pv);

    // Utility functions
    //
    SnapHeader *Snapshot();
    static void FreeSnapshot(SnapHeader *ph);
    static void Diff(SnapHeader *ph1, SnapHeader *ph2);

    enum BlockSortKey
    {
        bsk_ReturnAddress,
        bsk_BlockAddress,
        bsk_Size
    };

    static void SortSnapshot(SnapHeader *ph, BlockSortKey bsk);

    bool EverCalled() const { return m_fEverCalled; }

    DWORD GetTotalAllocationCount() const { return m_nSeq; }

private:
    struct Block
    {
        Block              *m_pNext;                        // Next block in the chain
        size_t              m_cb;                           // Bytes (not including this header)
        DWORD               m_RA;                           // Address of requestor
        DWORD               m_nSeq;                         // Unique sequence number to id blocks
                                                            // with same address
    };

    CRITICAL_SECTION        m_cs;                           // Protect allocation list
    Block                  *m_pBlocks;                      // The list itself
    int                     m_nBlocks;                      // Number of outstanding allocations
    DWORD                   m_nSeq;                         // Next unique sequence number

    DWORD                   m_nBytes;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    __int64                 m_llTotalBytes;                 // Total Bytes ever allocated
#endif

private:
    inline void EnterCS()       { EnterCriticalSection(&m_cs); }
    inline void LeaveCS()       { LeaveCriticalSection(&m_cs); }

    static int __cdecl SortRA(const void *p1, const void *p2);
    static int __cdecl SortBA(const void *p1, const void *p2);
    static int __cdecl SortSize(const void *p1, const void *p2);

    bool m_fEverCalled;

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR
    // DEBUG_HEAP m_heap;
    // FAST_HEAP m_heap;
    // BLENDED_HEAP m_heap;
    // SMALL_HEAP m_heap;
#endif

};

static CAllocate g_DefaultAllocator;
static IDirectMusicAlloc *g_pAllocI = &g_DefaultAllocator;

//////////////////////////////////////////////////////////////////////////////
//
// GrovelRA
//
// This function is tailored to the way the allocator call chain is set up.
// It also will not work in retail.
//
#ifdef DBG
static DWORD __declspec(naked) GrovelRA()
{
    _asm
    {
        mov     eax, [ebp]
        mov     eax, [eax]
        mov     eax, [eax + 4]
        ret
    }
}

DWORD CalculatePagesSpanned(CAllocate::SnapHeader* pNew)
{
    g_DefaultAllocator.SortSnapshot(pNew, CAllocate::bsk_BlockAddress);
    DWORD dwNumPages = 0;
    DWORD dwCurrentPage = 0; // Assumes that blocks are never allocated out of the zero page.
    for(int i = 0; i < pNew->m_nBlocks; i++){
        CAllocate::SnapBlock* pBlock = & pNew->m_rgBlocks[i];
        DWORD dwBaseAddress = (DWORD) pBlock->m_pBlock;
        DWORD dwStartPage = (dwBaseAddress >> 12);
        DWORD dwEndPage = ((dwBaseAddress + pBlock->m_cb - 1) >> 12);
        dwNumPages += dwEndPage-dwStartPage+1;
        if(dwCurrentPage == dwStartPage){
            dwNumPages--;
        }
        dwCurrentPage = dwEndPage;
    }
    return dwNumPages;
}

#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

static HRESULT
__stdcall DMPagesSpannedCallback
(
    PLARGE_INTEGER pliCounter,
    PLARGE_INTEGER pUnused
)
{
    CAllocate::SnapHeader* pNew = g_DefaultAllocator.Snapshot();
    DWORD dwPagesSpanned = CalculatePagesSpanned(pNew);
    g_DefaultAllocator.FreeSnapshot(pNew);

    pliCounter->HighPart = 0;
    pliCounter->LowPart = dwPagesSpanned;
    return XBDM_NOERR;
}

static HRESULT
__stdcall DMHeapDensityCallback
(
    PLARGE_INTEGER pliCounter,
    PLARGE_INTEGER pUnused
)
{
    CAllocate::SnapHeader* pNew = g_DefaultAllocator.Snapshot();
    DWORD dwBytesSpanned = CalculatePagesSpanned(pNew) << 12;
    DWORD dwBytesAllocated = pNew->m_cbTotal;
    g_DefaultAllocator.FreeSnapshot(pNew);

    DWORD dwDensity = dwBytesAllocated ? (dwBytesAllocated * 100 / dwBytesSpanned) : 0;

    pliCounter->HighPart = 0;
    pliCounter->LowPart = dwDensity;
    return XBDM_NOERR;
}

static HRESULT
__stdcall DMHeapDumpCallback
(
    PLARGE_INTEGER pliCounter,
    PLARGE_INTEGER pUnused
)
{
    
    static DWORD gCallCount;

    if(gCallCount++ % 10 == 0){
        DirectMusicDumpMemStats();
    }

    pliCounter->HighPart = 0;
    pliCounter->LowPart = gCallCount;
    return XBDM_NOERR;
}

#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

extern "C" void DMusicRegisterPerformanceCounters(){
    RegisterDMusicObjectCounters();
    DMRegisterPMsgPerformanceCounters();
    DMRPC_DownloadBuffer();
}

extern "C" void DMusicUnregisterPerformanceCounters(){
    UnregisterDMusicObjectCounters();
    DMUnregisterPMsgPerformanceCounters();
    DMURPC_DownloadBuffer();
}

#endif


//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::CAllocate
//
// 
CAllocate::CAllocate()
{
    InitializeCriticalSection(&m_cs);
    m_pBlocks = NULL;
    m_nBlocks = 0;
    m_nSeq = 0;
    m_fEverCalled = 0;
    m_nBytes = 0;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    m_llTotalBytes = 0;
    DMusicRegisterPerformanceCounter( "DM heap bytes",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_nBytes );
    DMusicRegisterPerformanceCounter( "DM heap allocations",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_nBlocks );
    DMusicRegisterPerformanceCounter( "DM heap allocation byte rate",
                                  DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                                  &m_llTotalBytes );
    DMusicRegisterPerformanceCounter( "DM heap allocation rate",
                                  DMCOUNT_EVENT  | DMCOUNT_ASYNC32,
                                  &m_nSeq );
    DMusicRegisterPerformanceCounter("DM heap pages spanned",
        DMCOUNT_VALUE | DMCOUNT_SYNC,
        &DMPagesSpannedCallback);
    DMusicRegisterPerformanceCounter("DM heap density (0..100)",
        DMCOUNT_VALUE | DMCOUNT_SYNC,
        &DMHeapDensityCallback);
#if 0 // Seems to be called always, not just when visible in the UI -- perhaps an xbperfmon bug?
    DMusicRegisterPerformanceCounter("DM heap dump (look at debug output)",
        DMCOUNT_VALUE | DMCOUNT_SYNC,
        &DMHeapDumpCallback);
#endif
#endif
}

CAllocate::~CAllocate(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounter("DM heap bytes");
    DMusicUnregisterPerformanceCounter("DM heap allocations");
    DMusicUnregisterPerformanceCounter("DM heap allocation byte rate");
    DMusicUnregisterPerformanceCounter("DM heap allocation rate");
    DMusicUnregisterPerformanceCounter("DM heap pages spanned");
    DMusicUnregisterPerformanceCounter("DM heap density (0..100)");
#if 0 // Seems to be called always, not just when visible in the UI -- perhaps an xbperfmon bug?
    DMusicUnregisterPerformanceCounter("DM heap dump (look at debug output)");
#endif
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Alloc
//
// Allocate method exposed to the app.
//
// cb [IN] - Requested block size
// 
// Returns a pointer to the block or NULL on out of memory.
// 
STDMETHODIMP_(LPVOID) CAllocate::Alloc(DWORD cb)
{
    m_fEverCalled = true;

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR

    Block *pb = (Block*)m_heap.New(sizeof(Block) + cb);

#else

    Block *pb = (Block*)malloc(sizeof(Block) + cb);

#endif

    if (pb == NULL)
        return NULL;
    
    pb->m_cb = cb;
    pb->m_nSeq = m_nSeq++;

#ifdef DBG
    pb->m_RA = GrovelRA();
#else
    pb->m_RA = 0;
#endif

    EnterCS();

        pb->m_pNext = m_pBlocks;
        m_pBlocks = pb;

        m_nBlocks++;

        m_nBytes += cb;

        m_llTotalBytes += cb;

    LeaveCS();

    return (LPVOID)(pb + 1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Free
//
// Free method exposed to the app.
//
// pv [IN] - The pointer to free; must have been allocated by this allocator
//           instance.
// 
STDMETHODIMP_(VOID) CAllocate::Free(void *pv)
{
    Block *pb = (Block*)pv;

    if (pb == NULL)
        return;

    pb--;

    EnterCS();

        Block *prev = NULL;
        Block *curr = m_pBlocks;

        while (curr && curr != pb)
        {
            prev = curr;
            curr = curr->m_pNext;
        }

        // If this fires then the block did not come from us.
        // 
        assert( curr );

        if (curr) 
        {
            if (prev)
            {
                prev->m_pNext = curr->m_pNext;
            }
            else
            {
                m_pBlocks = curr->m_pNext;
            }

            m_nBytes -= curr->m_cb;

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR

            m_heap.Delete(pb);

#else
            free(pb);
#endif

            m_nBlocks--;
        }

    LeaveCS();
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Snapshot
//
// Returns a pointer to a block of memory describing all the outstanding 
// allocations. This pointer must eventually be free'd with FreeSnapshot.
//
CAllocate::SnapHeader *CAllocate::Snapshot()
{
    EnterCS();

        int n = max(0, m_nBlocks - 1);

        SnapHeader *ph = (SnapHeader*)malloc(sizeof(SnapHeader) + n * sizeof(SnapBlock));
        if (ph)
        {
            ph->m_nBlocks = m_nBlocks;

            n = 0;

            DWORD cbTotal = 0;

            for (Block *pb = m_pBlocks; pb; pb = pb->m_pNext, n++)
            {
                ph->m_rgBlocks[n].m_cb = pb->m_cb;
                ph->m_rgBlocks[n].m_RA = pb->m_RA;
                ph->m_rgBlocks[n].m_nSeq = pb->m_nSeq;
                ph->m_rgBlocks[n].m_pBlock = (LPVOID)(pb + 1);

                cbTotal += pb->m_cb;
            }

            ph->m_cbTotal = cbTotal;

            assert( n == m_nBlocks );
        }

    LeaveCS();

    return ph;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::FreeSnapshot
//
// Free's a shapshot.
//
void CAllocate::FreeSnapshot(SnapHeader *psh)
{
    free(psh);
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Diff
//
// Generates the diff of two snapshots. Each entry in both snapshots will have
// the m_fDiff flag set to false if the block exists in both snapshots; else
// it will be set to true. 
//
// If ph1 was taken before ph2, then m_fDiff set on a ph1 entry means that 
// entry has since been free'd; while if the flag is set on a ph2 entry it
// means that the entry has since been allocated.
//
// This will resort both snapshots.
//
void CAllocate::Diff(SnapHeader *ph1, SnapHeader *ph2)
{
    int n1 = 0;
    int n2 = 0;

    SortSnapshot(ph1, bsk_BlockAddress);
    SortSnapshot(ph2, bsk_BlockAddress);

    while (n1 < ph1->m_nBlocks && n2 < ph2->m_nBlocks)
    {
        while (
            ph1->m_rgBlocks[n1].m_pBlock == ph2->m_rgBlocks[n2].m_pBlock &&
            n1 < ph1->m_nBlocks && n2 < ph2->m_nBlocks)
        {
            // This catches the case where the underlying allocator has
            // returned a previously used address.
            //
            bool fDiff = ph1->m_rgBlocks[n1].m_nSeq != ph2->m_rgBlocks[n2].m_nSeq;

            ph1->m_rgBlocks[n1++].m_fDiff = fDiff;
            ph2->m_rgBlocks[n2++].m_fDiff = fDiff;
        }

        while (
            ph1->m_rgBlocks[n1].m_pBlock < ph2->m_rgBlocks[n2].m_pBlock &&
            n1 < ph1->m_nBlocks)
        {
            ph1->m_rgBlocks[n1++].m_fDiff = true;
        }
        
        while (
            ph1->m_rgBlocks[n1].m_pBlock > ph2->m_rgBlocks[n2].m_pBlock &&
            n2 < ph2->m_nBlocks)
        {
            ph2->m_rgBlocks[n2++].m_fDiff = true;
        }
    }

    while (n1 < ph1->m_nBlocks)
    {
        ph1->m_rgBlocks[n1++].m_fDiff = true;
    }

    while (n2 < ph2->m_nBlocks)
    {
        ph2->m_rgBlocks[n2++].m_fDiff = true;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::SortSnapshot
//
// Sort the snapshot by the given key.
//
void CAllocate::SortSnapshot(SnapHeader *ph, BlockSortKey bsk)
{
    int (__cdecl *comp)(const void *, const void *) = NULL;

    switch (bsk)
    {
    case bsk_ReturnAddress:
        comp = SortRA;
        break;

    case bsk_BlockAddress:
        comp = SortBA;
        break;

    case bsk_Size:
        comp = SortSize;
        break;

    default:
        assert( false );
    }

    if (comp)
    {
        qsort(ph->m_rgBlocks, ph->m_nBlocks, sizeof(SnapBlock), comp);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::SortXxx
//
// Key compare functions for qsort
//
int __cdecl CAllocate::SortRA(const void *pv1, const void *pv2)
{
    const SnapBlock *pb1 = (const SnapBlock *)pv1;
    const SnapBlock *pb2 = (const SnapBlock *)pv2;

    if (pb1->m_RA < pb2->m_RA)
        return -1;
    else if (pb1->m_RA > pb2->m_RA)
        return 1;

    return 0;
}

int __cdecl CAllocate::SortBA(const void *pv1, const void *pv2)
{
    const SnapBlock *pb1 = (const SnapBlock *)pv1;
    const SnapBlock *pb2 = (const SnapBlock *)pv2;

    if (pb1->m_pBlock < pb2->m_pBlock)
        return -1;
    else if (pb1->m_pBlock > pb2->m_pBlock)
        return 1;

    return 0;
}

int __cdecl CAllocate::SortSize(const void *pv1, const void *pv2)
{
    const SnapBlock *pb1 = (const SnapBlock *)pv1;
    const SnapBlock *pb2 = (const SnapBlock *)pv2;

    if (pb1->m_cb < pb2->m_cb)
        return -1;
    else if (pb1->m_cb > pb2->m_cb)
        return 1;

    return 0;
}

static CAllocate::SnapHeader* pMiddle;
static CAllocate::SnapHeader* pNew;

static void PrintGarbage(const CAllocate::SnapBlock* pGarbageBlock, DWORD totalNum, DWORD totalMem){
    DbgPrint(" Allocator: 0x%08x instance( addr 0x%08x, seq %d) %5d blocks, %7d bytes average %7d bytes total\n",
        pGarbageBlock->m_RA, pGarbageBlock->m_pBlock, pGarbageBlock->m_nSeq, totalNum, totalNum ? totalMem / totalNum : totalMem, totalMem);
}

void WINAPI DirectMusicDumpMemStats()
{
    if(g_pAllocI != &g_DefaultAllocator){
        return; // Allocator has been replaced.
    }

    CAllocate::SnapHeader* pAncient;
    pAncient = pMiddle;
    pMiddle = pNew;
    pNew = g_DefaultAllocator.Snapshot();

    DbgPrint("Total allocated memory: %d bytes, %d active blocks, %d allocations\n",
        pNew->m_cbTotal, pNew->m_nBlocks, g_DefaultAllocator.GetTotalAllocationCount());

    // Calculate how many heap blocks are covered (for trying to minimize lacy heaps)
    {
        DWORD dwNumPages = CalculatePagesSpanned(pNew);
        DbgPrint("DMusic heap allocations span %d pages.\n", dwNumPages);
    }

    // Find 20 largest groups of objects..

    {
        DbgPrint("DMusic heap most frequent allocations:\n");
        g_DefaultAllocator.SortSnapshot(pNew, CAllocate::bsk_ReturnAddress);
        // How many different allocators?
        DWORD dwRA = 0;
        DWORD dwNumRA = 0;
        for(int i = 0; i < pNew->m_nBlocks; i++){
            if(pNew->m_rgBlocks[i].m_RA == dwRA){
            }
            else{
                dwNumRA++;
                dwRA = pNew->m_rgBlocks[i].m_RA;
            }   
        }
        DbgPrint("number of distinct allocators: %d\n", dwNumRA);
        struct RACount {
            DWORD m_dwRA;
            DWORD m_dwCount;
            static int __cdecl SortByCount(const void* pA, const void* pB){
                return ((RACount*) pA)->m_dwCount - ((RACount*) pB)->m_dwCount;
            }
        };
        RACount* pRACount = new RACount[dwNumRA];
        dwRA = 0;
        DWORD dwCurrentRA = 0;
        for(int i = 0; i < pNew->m_nBlocks; i++){
            if(pNew->m_rgBlocks[i].m_RA == dwRA){
                pRACount[dwCurrentRA].m_dwCount++;
            }
            else{
                if(dwRA != 0){
                    dwCurrentRA++;
                }
                dwRA = pNew->m_rgBlocks[i].m_RA; 
                pRACount[dwCurrentRA].m_dwRA = dwRA;
                pRACount[dwCurrentRA].m_dwCount = 1;
            }   
        }
        qsort(pRACount,dwNumRA,sizeof(RACount),RACount::SortByCount);

        for(DWORD i = 0; i < dwNumRA && i < 20; i++){
            RACount* pRAC = &pRACount[dwNumRA-(i+1)];
            DbgPrint("%2d: allocator: %8x instances: %4d\n",
                i, pRAC->m_dwRA, pRAC->m_dwCount);
        }
        delete [] pRACount;
    }

#ifdef TRACK_LONG_TERM_MEMORY_GROWTH

    if(!pAncient){
        DbgPrint("Not enough snapshots to generate long-term memory growth report yet.\n");
        return; // Not enough snapshots yet.
    }

    // Anything that's not in pAncient, but is in Middle and New, is new garbage

    g_DefaultAllocator.Diff(pAncient, pNew);
    for(int i = 0; i < pNew->m_nBlocks; i++){
        pNew->m_rgBlocks[i].m_fUser = pNew->m_rgBlocks[i].m_fDiff;
    }

    g_DefaultAllocator.Diff(pMiddle, pNew);

    // If m_fUser is true, that means block was not in old.
    // If m_fDiff is false, that means the block was in middle
    // Therefore it's probably new garbage

    // Sort by allocator

    g_DefaultAllocator.SortSnapshot(pNew, CAllocate::bsk_ReturnAddress);

    bool bPrintHeader = true;

    size_t totalMem = 0;
    size_t totalNum = 0;
    size_t totalAllocators = 0;

    CAllocate::SnapBlock* pGarbageBlock = 0;

    DbgPrint("Recently created long-term data, possibly garbage:\n");
    for(int i = 0; i < pNew->m_nBlocks; i++){
        CAllocate::SnapBlock* pBlock = & pNew->m_rgBlocks[i];
        if( pBlock->m_fUser && ! pBlock->m_fDiff) {
            if(bPrintHeader){
                bPrintHeader = false;
            }

            if(!pGarbageBlock || pGarbageBlock->m_RA != pBlock->m_RA){
                if(pGarbageBlock){
                    totalAllocators++;
                    PrintGarbage(pGarbageBlock, totalNum, totalMem);
                }
                pGarbageBlock = pBlock;
                totalNum = 0;
                totalMem = 0;
            }
            totalNum++;
            totalMem += pBlock->m_cb;
        }
    }
    if(pGarbageBlock){
        totalAllocators++;
        PrintGarbage(pGarbageBlock, totalNum, totalMem);
    }
    if(totalAllocators){
        DbgPrint(" end of report.\n");
    }
    else {
        DbgPrint(" no new blocks found.\n");
    }

#endif // TRACK_LONG_TERM_MEMORY_GROWTH

    if(pAncient){
        g_DefaultAllocator.FreeSnapshot(pAncient);
    }
}

#endif // USE_LEAK_DETECTING_ALLOCATOR

#ifdef USE_XHEAP_ALLOCATOR

#define COMPILING_ROCKALL_LIBRARY
#include "..\xheap\xheap\blendedheap.hpp"
#include "..\xheap\xheap\smallheap.hpp"
#include "..\xheap\xheap\fastheap.hpp"
#include "..\xheap\xheap\debugheap.hpp"
#include "..\xheap\xheap\dynamicdebugheap.hpp"
#include "..\xheap\xheap\pageheap.hpp"

static FAST_HEAP gDMusicHeap;


void WINAPI DirectMusicDumpMemStats()

{
    Trace(1,"DirectMusicDumpMemStats: Using xheap.\n");
}

////////////////////////////////////////////////////////////////////////////////
//
// Internal alloc/free routines to be called from operator new/delete
//
//
void* DirectMusicAllocI(size_t cb)
{
    return gDMusicHeap.New(cb);
}

void DirectMusicFreeI(void *pv)
{
    gDMusicHeap.Delete(pv);
}


#endif // USE_XHEAP_ALLOCATOR

#ifdef USE_C_ALLOCATOR

void WINAPI DirectMusicDumpMemStats()

{
    Trace(1,"DirectMusicDumpMemStats: Using C allocator.\n");
}

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
extern "C" void DMusicRegisterPerformanceCounters(){
    if(gpDMHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMHeap)->RegisterPerformanceCounters();
    }
    if(gpDMPhysicalHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMPhysicalHeap)->RegisterPerformanceCounters();
    }

#ifdef DBG
    RegisterDMusicObjectCounters();
#endif
    DMRegisterPMsgPerformanceCounters();
    DMRPC_DownloadBuffer();
}

extern "C" void DMusicUnregisterPerformanceCounters(){
    if(gpDMHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMHeap)->UnregisterPerformanceCounters();
    }
    if(gpDMPhysicalHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMPhysicalHeap)->UnregisterPerformanceCounters();
    }
#ifdef DBG
    UnregisterDMusicObjectCounters();
#endif
    DMUnregisterPMsgPerformanceCounters();
    DMURPC_DownloadBuffer();
}

#endif // IMPLEMENT_PERFORMANCE_COUNTERS

#endif // USE_C_ALLOCATOR

#if ! ( defined(USE_XHEAP_ALLOCATOR) || defined(USE_C_ALLOCATOR) )

////////////////////////////////////////////////////////////////////////////////
//
// DirectMusicSetAllocator 
//
// Allow the app to specify an interface to manage memory allocations.
//
// This function must be called once, and it must be called before 
//    InitAudioX. This prevents allocations being made via malloc
//    that will attempt to be free'd through the interface and vice
//    versa.
//
//
HRESULT WINAPI DirectMusicSetAllocator(IDirectMusicAlloc *pAlloc)
{
    if (g_pAllocI != &g_DefaultAllocator)
    {
        return DMUS_E_NOT_INIT;         // Someone has already set us
    }
    
    if (g_DefaultAllocator.EverCalled())
    {
        return DMUS_E_NOT_INIT;         // Too late, there's already memory allocated
    }

    if (!pAlloc)
    {
        return E_INVALIDARG;
    }
    
    g_pAllocI = pAlloc;

    return S_OK;
}



////////////////////////////////////////////////////////////////////////////////
//
// Internal alloc/free routines to be called from operator new/delete
//
//
void* DirectMusicAllocI(size_t cb)
{
    return g_pAllocI->Alloc(cb);
}

void DirectMusicFreeI(void *pv)
{
    g_pAllocI->Free(pv);
}


#endif // ! USE_XHEAP_ALLOCATOR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dlsstrm.h ===
//
// dlsstrm.h
//
// Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
    RIFFIO *    GetChunk() { return m_pChunk; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DLSSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dlsstrm.cpp ===
//
// dlsstrm.cpp
// 
// Copyright (c) 1995-1999 Microsoft Corporation. All rights reserved.
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(1,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(1,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(1," Type %s",szName);
                    }
#endif
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(1,"\n");
#endif
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(1,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#ifdef XBOX
#include <xtl.h>
#endif // XBOX

#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\des8.h ===
//------------------------------------------------------------------------------
//                                                                       
//   des8.h -- Design of DirectX 8 interfaces for DirectMusic 
//                                                                       
//   Copyright (c) 1998-1999 Microsoft Corporation
//                                                                       
//------------------------------------------------------------------------------
//
// Prototypes for new DirectX 8 interfaces for DirectMusic core
//
// This header discusses interfaces which manange wave playback between
// the wave object, the DirectMusic port, and a DirectMusic software synth.
// It does not address communication between the wave track and the wave 
// object or the software synth and DirectSound, or directly between the
// wave object and DirectSound.
//
// These interfaces are based on my understanding of our recent hallway
// discussions.
//
// Issues which need futher discussion are marked with XXX.
//
// 

//
// New schedule breakdown
//
// 1. Port (synth and WDM)
//    a. IDirectMusicPort::DownloadWave
//       Code is very similar for WDM or software synth
//       i.   Get needed information from WO and create IDirectSoundSource   0.5    
//       ii.  If oneshot, track and download header and wave data            3.5
//       iii. If streaming, download header                                  0.5
//
//    b. IDirectMusicPort::UnloadWave
//       i.   Arbitrate with device for 0 refcount of download               1.0
//
//    c. IDirectMusicPort::AllocVoice
//       i.   Allocate voice ID                                              0.5
//       ii.  If streaming, allocate preread samples and streaming buffers   2.5
//
//    d. Voice Service Thread
//       i.   Init and shutdown code at port create/destroy                  1.0
//       ii.  Call listed voices every ~100 ms                               0.5
//
//    e. CDirectMusicVoice::Service
//       i.   Communicate with device to determine each voice position       0.5
//       ii.  Calculate how much more wave data is needed                    1.0
//       iii. Fill wave data from IDirectSoundSource and send to device      1.0
//       iv.  Determine when playback is complete and stop voice             0.5
//
//    f. IDirectMusicVoice::Play
//       i.   Communicate request to device                                  0.3
//       ii.  Send down timestamped preread data                             0.3
//       iii. Insert into VST                                                0.3
//
//    g. IDirectMusicVoice::Stop
//       i.   Flag voice as stopped                                          0.5
//       ii.  Forward request to device                                      0.0
//
//    h. Setup and connection
//
//    i. Move sink code into DSound                                          3.0
//    
//      
                                                                           15.5
//
// Things to change
//
// * We will model the DownloadWave interface after the Download interface 
//   and will pass things down to the synth as such:
//
//   DLH + WAD -> Download header + Wave Articulation Data
//                                  (contains loop points and count, etc.)
//
//   DLH + DATA -> Download header + data
//   
// * For oneshot data we want to do download refcounting like we do for
//   regular DLS downloads. For streams we do not since the data that comes
//   down in each download is the next set of data for the device to play.
//
// Download waves first, then wave articulations
// Separate multichannel downloads
// Rotating buffers and refresh for streaming
//   

// New generic typedefs and #defines
//
typedef ULONGLONG SAMPLE_TIME;                  // Sample position w/in stream
typedef SAMPLESPOS *PSAMPLE_TIME;

#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   // Wave articulation data 
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   // One chunk of a streaming
                                                // wave 
                                                
// This is built by the wave object from the 'smpl' chunk embedded in the
// wave file if there is one, else it is just defaults.
//                    
typedef struct _DMUS_WAVEART
{
    DWORD               cbSize;                 // As usual
    WSMPL               WSMP;                   // Wave sample as per DLS1
    WLOOP               WLOOP[1];               // If cSampleCount > 1    
} DMUS_WAVEART; 


//------------------------------------------------------------------------------
//
// IDirectSoundSource
//
// An IDirectSound source is the interface to what we've been calling the
// viewport object.
//
// 
//
interface IDirectSoundSource
{  
    // Init
    //
    // Gives the interface of the connected sink
    STDMETHOD(Init)
    (THIS_
        IDirectSoundSink *pSink                 // Connected sink
    );
    
    // GetFormat
    //
    // Returns the format the source is returning the wave data in
    //
    STDMETHOD(GetFormat)
        (THIS_
         LPWAVEFORMATEX *pwfx,                  // Wave format to fill in
         LPDWORD pcbwfx                         // Size of wave format,
                                                // returns actual size
        ) PURE;
                                                      
    // Seek
    //
    // Seek to the given sample position in the stream. May be inexact
    // due to accuracy settings of wave object. To account for this
    //          
    STDMETHOD(Seek)
        (THIS_
         SAMPLEPOS sp                           // New sample position         
        ) PURE;

    // Read
    //
    // Read the given amount of sample data into the provided buffer starting
    // from the read cursor. The read cursor is set with seek and advanced
    // with each successive call to Read.
    //
    STDMETHOD(Read)
        (THIS_
         LPVOID *ppvBuffer,                     // Array of pvBuffer's
         DWORD cpvBuffer,                       // and how many are passed in
         PSAMPLEPOS pcb                         // In: number of samples to read
                                                // Out: number of samples read
        ) PURE;    
        
    // GetSize
    //
    // Returns the size of the entire wave, in bytes, in the requested format
    //
    STDMETHOD(GetSize)
        (THIS_
         PULONG *pcb                            // Out: Bytes in stream
        ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectSoundSink
//
// An IDirectSound sink is the interface which feeds itself from one 
// IDirectSoundSource. It is based on the IDirectMusicSynthSink interface
// 
//
interface IDirectSoundSink
{
    // Init
    //
    // Sets up the source to render from
    //
    STDMETHOD(Init)
    (THIS_
        IDirectSoundSource *pSource             // The source from which we read
    ) PURE;
    
    // SetMasterClock
    //
    // Sets the master clock (reference time) to use
    //
    STDMETHOD(SetMasterClock)
    (THIS_
        IReferenceClock *pClock                 // Master timebase
    ) PURE;
    
    // GetLatencyClock
    //
    // Returns the clock which reads latency time, relative to 
    // the master clock
    //
    STDMETHOD(GetLatencyClock)
    (THIS_
        IReferenceClock **ppClock               // Returns latency clock
    ) PURE;
    
    // Activate
    //
    // Starts or stops rendering
    //
    STDMETHOD(Activate)
    (THIS_
        BOOL fEnable                            // Get ready or stop
    ) PURE;
    
    // SampleToRefTime
    //
    // Converts a sample position in the stream to
    // master clock time
    //
    STDMETHOD(SampleToRefTime)
    (THIS_
        SAMPLE_TIME sp,                         // Sample time in
        REFERENCE_TIME *prt                     // Reference time out
    ) PURE;
    
    // RefToSampleTime
    //
    // Converts a reference time to the nearest
    // sample
    //
    STDMETHOD(RefToSampleTime)
    (THIS_
        REFERENCE_TIME rt,                      // Reference time in
        SAMPLE_TIME *psp                        // Sample time out
    ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectSoundWave
//
// Public interface for the wave object
//
#define DSWCS_F_DEINTERLEAVED 0x00000001        // Multi-channel data as
                                                // multiple buffers

interface IDirectSoundWave
{
    // GetWaveArticulation
    //
    // Returns wave articulation data, either based on a 'smpl' chunk 
    // from the wave file or a default.
    //
    STDMETHOD(GetWaveArticulation)
    (THIS_
        WAVEARTICULATION *pArticulation         // Articulation to fill in
    ) PURE;
    
    // CreateSource
    //
    // Creates a new IDirectSoundSource to read wave data from
    // this wave
    //
    STDMEHTOD(CreateSource)
    (THIS_
        IDirectSoundSource **ppSource           // Created viewport object
        LPWAVEFORMATEX pwfex,                   // Desired format
        DWORD dwFlags                           // DSWCS_xxx
    ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectMusicPort8
//
// 
//

#define DMDLW_STREAM                            0x00000001

interface IDirectMusicPort8 extends IDirectMusicPort
{ 
    // DownloadWave
    //
    // Creates a downloaded wave object representing the wave on this
    // port. 
    //
    STDMETHOD(DownloadWave)
        (THIS_
         IDirectSoundWave *pWave,               // Wave object
         ULONGLONG rtStart,                     // Start position (stream only)
         DWORD dwFlags,                         // DMDLW_xxx
         IDirectSoundDownloadedWave **ppWave    // Returned downloaded wave
        ) PURE;
        
    // UnloadWave
    //
    // Releases the downloaded wave object as soon as there are no voices
    // left referencing it.
    //
    STDMETHOD(UnloadWave)
        (THIS_ 
         IDirectSoundDownloadedWave *pWave      // Wave to unload
        ) PURE;

    // AllocVoice
    //
    // Allocate one playback instance of the downloaded wave on this
    // port.
    //
    STDMETHOD(AllocVoice)
        (THIS_
         IDirectSoundDownloadedWave *pWave,     // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         SAMPLE_TIME stReadAhead,               // How much to read ahead
         IDirectMusicVoice **ppVoice            // Returned voice
        ) PURE;        
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// DownloadWave (normal use)
//   
// 1. Application calls GetObject to load segment which contains a wave track.
//    This causes GetObject to be called on all related waves, creating wave
//    objects for all of them. 
//
// 2. Wave track calls SetParam on each wave object to set up author-time 
//    parameters on the wave. This includes:
//    - One-shot versus stream-ness
//    - Readahead amount
//
// 3. Application calls SetParam(GUID_Download,...) to force download. As well
//    as downloading DLS instruments (band track), the wave track calls 
//    DownloadWave for every wave to download. (Note: are we using the same GUID
//    for download? It doesn't appear that SetParam on a segment is broadcast
//    too all tracks, but rather is sent to the first track that understands
//    the GUID, or the nth if an index is given. This would mean that 
//    the application would have to call SetParam twice with the same GUID 
//    and a different track index if there are both band and wave tracks 
//    in the segment??
//
//    Returned is an IDirectMusicDownloadedWave(DirectSound?) to track the wave.
//
//    The following happen during the DownloadWave method call:
//
// 4. The port queries the wave object for the stream-ness and readahead
//    properties. 
//
// XXX We decided that these things were per wave object, right? 
//     (As opposed to the viewport). And the wave object already knows them or 
//     is the right object to provide reasonable defaults. 
//
// 5. The port requests a viewport from the wave object in its native format.
//
// 6. The port allocates buffer space. The buffer must be big enough to handle
//    the entire wave in the case of the one shot, or at least big enough to
//    handle the readahead samples in the streaming case. The streaming buffer
//    may be allocated larger, however, if it is going to be used for the
//    entire streaming session. Buffer choice here may be affected by the
//    underlying port. 
//
//    I assume we are going to parallel the DLS architecture as much as 
//    possible here and are going to be able to trigger a downloaded wave
//    more than once at the same time. In that case the buffer would have
//    to be stored in the _voice_, not the DownloadedWave (except perhaps
//    for the readahead which should always be kept around). Is this 
//    duplication of effort if we're going to be caching in the wave
//    object as well?
//
// 7. If the wave is a one-shot, then the port will request the entire data
//    for the wave from the viewport and downloads it to the device. At this
//    point the viewport is released since the entire data for the wave is in
//    the synth. If the wave is streaming, then nothing is done at the device
//    level.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// UnloadWave
//
// This tells the port that the application is done with the wave as soon as
// there are no more voice references to it. Internally it just calls 
// Release() on the downloaded wave object. The dlwave object can then no longer
// be used to create voices. However, the dlwave will only really be released
// once all voices that currently use it are released.
//
// This is identical to calling Release() on the dlwave object directly
// (why does it exist?)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// AllocVoice
//
// Allocate a voice object to play back the a wave on a channel group
//
// This call is simple. All it does it ask the synth for a voice ID (which
// is just a cookie that only has meaning to the synth) and creates the voice
// object.
//
// At this point the download is bound to the channel, since MIDI articulations
// sent to the voice before playback begins will need to know that.
//
// The voice object addref's the downloaded wave object.
//

//------------------------------------------------------------------------------
//
// IDirectMusicVoice 
//
// One playback instance of a downloaded wave on a port
//
// Note that since we're already bound to a channel after the voice is
// created, we don't need any methods on the voice object for MIDI
// articulation. That can just go through the normal synth mechanism.
//
interface IDirectMusicVoice
{
public:
    // Play
    //
    STDMETHOD(Play)
        (_THIS
         REFERENCE_TIME rtStart,                // Time to play
         REFERENCE_TIME rtStartInWave           // XXX Move this
                                                // Where in stream to start         
        ) PURE;
    
    // Should stop be scheduled or immediate?
    //    
    STDMETHOD(Stop)
        (_THIS                                  
          REFERENCE_TIME rtStop,                // When to stop
        ) PURE;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// QueryInterface(IID_IKsControl)
//
// All of the effects control should be in the DirectSound side now. 
// However, IKsControl can still be used as in 6.1 and 7 to determine
// synth caps.
// 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// Play
//
// XXX I am not sure this is the right place to deal with preread. However, 
//     we can't deal with it at DownloadWave(), because we don't know at that
//     point where to start (the app may play the stream from different
//     starting points on different voice). We *could* do it at voice allocation
//     time; that would just mean that the stream start position is fixed for
//     a particular voice no matter how many times the voice is triggered.
//     This is an issue because preread may take some time if decompression is
//     taking place and the seek request is far into the wave; it may cause
//     problems with low-latency Play commands.
//
//     Note that I am delegating the quality versus efficiency flag to private
//     communication between the wave object and the wave track or application.
//
// 1. Call Play() on the synth voice ID associated with this voice. If the 
//    associated wave is a one-shot, this is all that needs to be done.
//
// 2. For a stream, no preread data has been allocated yet. Tell the wave
//    object to seek to the given position and preread. Give the preread data
//    to the device via StreamVoiceData().
//
// 3. If the associated wave is a stream, insert this voice into the voice
//    service list. This will cause push-pull arbiration to be done on the
//    voice until it finishes or Stop() is called.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// Stop
//
// 1. Call Stop() on the synth voice.
//
// 2. If the voice is streaming and not done, pull it from the voice service
//    thread.
//

//------------------------------------------------------------------------------
//
// IDirectMusicSynth8
//
// New methods on the synthesizer interface for managing wave playback.
// A parallel to these methods will be needed on a hardware synth, probably
// implemented as a property set.
//
interface IDirectMusicSynth8 extends IDirectMusicSynth
{ 
public:
    STDMETHOD(DownloadWave)
        (THIS_
         LPHANDLE pHandle,                  // Returned handle representing DL
         LPVOID pvData,                     // Initial data
                                            // XXX >1 channel -> buffers?
         LPBOOL pbFree,                     // Is port allowed to free data?
         BOOL bStream                       // This is preroll data for a stream                                        
        ) PURE;
        
    STDMETHOD(UnloadWave)               
        (THIS_ 
         HANDLE phDownload,                 // Handle from DownloadWave
         HRESULT (CALLBACK *pfnFreeHandle)(HANDLE,HANDLE), 
                                            // Callback to call when done
                                            
         HANDLE hUserData                   // User data to pass back in 
                                            // callback
        ) PURE; 
        
    STDMETHOD(PlayVoice)
        (THIS_
         REFERENCE_TIME rt,                 // Time to start playback
         DWORD dwVoiceId,                   // Voice ID allocated by port
         DWORD dwChannelGroup,              // Channel group and
         DWORD dwChannel,                   // channel to start voice on
         DWORD dwDLId                       // Download ID of the wave to play
                                            // (This will be of the wave 
                                            // articulation)
        ) PURE;
        
    STDMETHOD(StopVoice)
        (THIS_
         DWORD dwVoice,                     // Voice to stop
         REFERENCE_TIME rt                  // When to stop
        ) PURE;
        
    struct VOICE_POSITION
    {
        ULONGLONG   ullSample;              // Sample w/in wave
        DWORD       dwSamplesPerSec;        // Playback rate at current pitch
    };
    
    STDMETHOD(GetVoicePosition)
        (THIS_
         HANDLE ahVoice[],                  // Array of handles to get position
         DWORD cbVoice,                     // Elements in ahVoice and avp
         VOICE_POSITION avp[]               // Returned voice position
        ) PURE;
        
    STDMETHOD(StreamVoiceData)
        (THIS_
         HANDLE hVoice,                     // Which voice this data is for
         LPVOID pvData,                     // New sample data
         DWORD cSamples                     // Number of samples in pvData
        ) PURE;        
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// DownloadWave
//
// This could be the same as Download except that we need to deal with
// the streaming case.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// UnloadWave
//
// Works just like Unload. In the streaming case, the callback will be
// called after _all_ data in the stream is free. Note that if UnloadWave
// is called while the wave is still playing, this could be quite some
// time.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// PlayVoice
//
// Schedule the voice to be played. The synth already has the data 
// for a oneshot wave, so starting playback is very fast. If the data is
// to be streamed it is the caller's responsibility (i.e. the port) to 
// keep the stream fed via StreamVoiceData()
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// StopVoice 
//
// Just what it says.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// GetVoicePosition
//
// This call retrieves the position of a set of voices. For each voice, the
// current sample position relative to the start of the stream and the 
// average number of samples per second at the current pitch is returned. This
// gives the caller all the information it needs to stay ahead of the 
// voice playback. This call is intended for use on streaming voices.
//
// Note that the playback position is an implication that all data up to the
// point of that sample is done with and the buffer space can be freed. This
// allows recycling of buffers in a streaming wave.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// StreamVoiceData
//
// This call queues more data for a streaming voice. 
//
// XXX This implies that there will be a discontinuity in the memory used
// by the synth mixer. How do we deal with that?
//
//

//------------------------------------------------------------------------------
//
// General questions and discussion
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// What can be underneath a DirectMusic port? 
//
// In 6.1 and 7 this was easy; either a SW synth on top of DSound 
// (synth port), or a kernel sw synth or hw synth (WDM port). (Not
// counting the dmusic16 code which will not be changing in 8).
//
// What are the scenarios we have now? Does it make sense (or is it even
// possible in light of backwards compat) to change what a port wraps?
// The two scenarios which match the existing ports are:
//
// Scenario: Software synthesizer on top of DirectSound as we have today.
// The hookup logic changes (we're talking n mono busses, etc.) but the 
// mechanics do not: the application can still just hand us a DirectSound
// object and we connect it to the bottom of the synthesizer. This still has
// to work with pre-8 applications making the same set of API calls they
// always did, but internally it can be totally different.
// XXX Did we ever expose the IDirectMusicSynthSink and methods for hooking
// it up? Can this change? (It has to...) I _think_ this was a DDK thing...
// The application can also create a DX8 DirectSound buffer with all the
// bells and whistles and have that work as well. We need some (DX8) specific
// mechanism for routing what goes out of the synth into the n mono inputs
// of the DirectSound buffer if it's more than just a legacy stereo buffer.
// 
//
// Scenario: We sit on top of a hardware or KM synth on top of *everything*
// else in kernel mode. We need private communication between DirectMusic,
// DirectSound, and SysAudio in order to hook this up, or we need to
// delegate the graph building tasks totally to DirectSound and have it
// deal exlusively with SysAudio connections. The latter is probably the
// way to go. In this case we fail if we cannot get a WDM driver under
// DirectSound to talk to, or if the DirectSound buffer is not totally in
// hardware. (This all argues for having DirectSound be able to instantiate
// the KM synth on top of the buffer rather than arbitrating with DirectMusic
// to do it). We need to define this interface ASAP.
// (Me, Dugan, Mohan, MikeM).
//
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmart.cpp ===
//
// dmart.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmart.h"
#include "dmcrchk.h"
#include "dls2.h"

#define FIVE_HERTZ  (-55791972)
#define MIN_TIME    (-783819269)    // Time cents for one ms.

// To support legacy articulation connection blocks
// Generic Destinations
#define CONN_DST_RESERVED          0x0002

// EG1 Destinations
#define CONN_DST_EG1_RESERVED      0x0208

// EG2 Destinations
#define CONN_DST_EG2_RESERVED      0x030c


CArticData::CArticData()

{
    m_ConnectionList.cbSize = sizeof(CONNECTIONLIST);
    m_ConnectionList.cConnections = 0;
    m_pConnections = NULL;
}

CArticData::~CArticData()

{
    if (m_pConnections) delete[] m_pConnections;
}

HRESULT CArticData::GenerateLevel1(DMUS_ARTICPARAMS *pParamStruct)

{
    if (pParamStruct)
    {
	    ZeroMemory(pParamStruct, sizeof(DMUS_ARTICPARAMS));
	    
        pParamStruct->LFO.pcFrequency = FIVE_HERTZ;
        pParamStruct->LFO.tcDelay = MIN_TIME;

	    pParamStruct->VolEG.tcAttack = MIN_TIME;
        pParamStruct->VolEG.tcDecay = MIN_TIME;
        pParamStruct->VolEG.ptSustain = 1000 << 16;
        pParamStruct->VolEG.tcRelease = MIN_TIME;
    
	    pParamStruct->PitchEG.tcAttack = MIN_TIME;
        pParamStruct->PitchEG.tcDecay = MIN_TIME;
        pParamStruct->PitchEG.ptSustain = 1000 << 16;
        pParamStruct->PitchEG.tcRelease = MIN_TIME;

        DWORD dwIndex;
        CONNECTION *pConnection;
		for (dwIndex = 0; dwIndex < m_ConnectionList.cConnections; dwIndex++)
		{
            pConnection = &m_pConnections[dwIndex];
			switch (pConnection->usSource)
			{
			case CONN_SRC_NONE :
				switch (pConnection->usDestination)
				{
				case CONN_DST_LFO_FREQUENCY :
					pParamStruct->LFO.pcFrequency =
						(PCENT) pConnection->lScale;
					break;
				case CONN_DST_LFO_STARTDELAY :
					pParamStruct->LFO.tcDelay =
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_ATTACKTIME :
					pParamStruct->VolEG.tcAttack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_DECAYTIME :
					pParamStruct->VolEG.tcDecay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_RESERVED :
					pParamStruct->VolEG.ptSustain = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_EG1_SUSTAINLEVEL :
					pParamStruct->VolEG.ptSustain = 
						(PERCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_RELEASETIME :
					pParamStruct->VolEG.tcRelease = 
						(TCENT) pConnection->lScale; 
					break;
				case CONN_DST_EG2_ATTACKTIME :
					pParamStruct->PitchEG.tcAttack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_DECAYTIME :
					pParamStruct->PitchEG.tcDecay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_RESERVED :
					pParamStruct->PitchEG.ptSustain = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_EG2_SUSTAINLEVEL :
					pParamStruct->PitchEG.ptSustain = 
						(PERCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_RELEASETIME :
					pParamStruct->PitchEG.tcRelease = 
						(TCENT) pConnection->lScale; 
					break;
				case CONN_DST_RESERVED :
					pParamStruct->Misc.ptDefaultPan = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_PAN :
					pParamStruct->Misc.ptDefaultPan = 
						(PERCENT) pConnection->lScale;
					break;
				}
				break;
			case CONN_SRC_LFO :
				switch (pConnection->usControl)
				{
				case CONN_SRC_NONE :
					switch (pConnection->usDestination)
					{
					case CONN_DST_ATTENUATION :
						pParamStruct->LFO.gcVolumeScale = 
							(GCENT) pConnection->lScale; 
						break;
					case CONN_DST_PITCH :
						pParamStruct->LFO.pcPitchScale = 
							(PCENT) pConnection->lScale; 
						break;
					}
					break;
				case CONN_SRC_CC1 :
					switch (pConnection->usDestination)
					{
					case CONN_DST_ATTENUATION :
						pParamStruct->LFO.gcMWToVolume = 
							(GCENT) pConnection->lScale; 
						break;
					case CONN_DST_PITCH :
						pParamStruct->LFO.pcMWToPitch = 
							(PCENT) pConnection->lScale; 
						break;
					}
					break;
				}
				break;
			case CONN_SRC_KEYONVELOCITY :
				switch (pConnection->usDestination)
				{
				case CONN_DST_EG1_ATTACKTIME :
					pParamStruct->VolEG.tcVel2Attack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_ATTACKTIME :
					pParamStruct->PitchEG.tcVel2Attack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_ATTENUATION :
					break;
				}
				break;
			case CONN_SRC_KEYNUMBER :
				switch (pConnection->usDestination)
				{
				case CONN_DST_EG1_DECAYTIME :
					pParamStruct->VolEG.tcKey2Decay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_DECAYTIME :
					pParamStruct->PitchEG.tcKey2Decay = 
						(TCENT) pConnection->lScale;
					break;
				}
				break;
			case CONN_SRC_EG2 :
				switch (pConnection->usDestination)
				{
				case CONN_DST_PITCH :
					pParamStruct->PitchEG.pcRange = 
						(PCENT) pConnection->lScale; 
					break;
				}
				break;
			}
		
		}
	}
    return S_OK;
}

DWORD CArticData::Size()

{
    if (m_pConnections)
    {
        return (m_ConnectionList.cConnections * sizeof CONNECTION) + sizeof CONNECTIONLIST;
    }
    return 0;
}

BOOL CArticData::Write(void * pv, DWORD* pdwCurrentOffset)

{
    if (m_pConnections)
    {
        CONNECTIONLIST *pList = (CONNECTIONLIST *) pv;
        CONNECTION *pConnection = (CONNECTION *) ((BYTE *)pv + sizeof(CONNECTIONLIST));
        *pList = m_ConnectionList;
        memcpy(pConnection,m_pConnections,m_ConnectionList.cConnections * sizeof CONNECTION);
        *pdwCurrentOffset += Size();
    }
    return TRUE;
}

HRESULT CArticData::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

    CONNECTION *pOldConnections = m_pConnections;
    DWORD dwOldCount = m_ConnectionList.cConnections;

	hr = pParser->Read(&m_ConnectionList, sizeof(m_ConnectionList));
	if(SUCCEEDED(hr))
	{	
        DWORD dwSize = m_ConnectionList.cConnections * sizeof(CONNECTION);
        if (dwSize > (pParser->GetChunk()->cksize - sizeof(CONNECTIONLIST)))
        {
            return E_FAIL;  // corrupt file.
        }
        m_pConnections = new CONNECTION[m_ConnectionList.cConnections + dwOldCount];
        if (m_pConnections)
        {
		    hr = pParser->Read(m_pConnections,dwSize);
            if (SUCCEEDED(hr))
            {
                if (pOldConnections && dwOldCount)
                {
                    memcpy(&m_pConnections[m_ConnectionList.cConnections],
                        pOldConnections,dwOldCount * sizeof(CONNECTION));
                    m_ConnectionList.cConnections += dwOldCount;
                }
            }
            else
            {
                delete[] m_pConnections;
                m_pConnections = pOldConnections;
                m_ConnectionList.cConnections = dwOldCount;

            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
            
	return hr;
}



//////////////////////////////////////////////////////////////////////
// Class CArticulation

//////////////////////////////////////////////////////////////////////
// CArticulation::CArticulation

CArticulation::CArticulation() 

{
#ifdef DXAPI
    m_dwCountExtChk = 0; 
    m_fNewFormat = FALSE;
#endif
    m_fDLS1 = TRUE;
    m_fCSInitialized = FALSE;
//    InitializeCriticalSection(&m_DMArtCriticalSection);
    m_fCSInitialized = TRUE;
}

CArticulation::~CArticulation()

{
    if (m_fCSInitialized)
    {
    	Cleanup();
//    	DeleteCriticalSection(&m_DMArtCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Load

HRESULT CArticulation::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

	RIFFIO ck;

//	EnterCriticalSection(&m_DMArtCriticalSection);

    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
		switch(ck.ckid)
		{
#ifdef DXAPI
        case FOURCC_CDL :
            hr = m_Condition.Load(pParser);
            break;
#endif
        case FOURCC_ART2 :
        case FOURCC_ART1 : 
            hr = m_ArticData.Load(pParser);
            break;
		default:
			// If we get here we have an unknown chunk
#ifdef DXAPI
            CExtensionChunk* pExtensionChunk = new CExtensionChunk;
			if(pExtensionChunk)
			{
				hr = pExtensionChunk->Load(pParser);

				if(SUCCEEDED(hr))
				{
					m_ExtensionChunkList.AddHead(pExtensionChunk);
					m_dwCountExtChk++;
				}
				else
				{
					delete pExtensionChunk;
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			} 
#endif
			break;
		}
	}
    pParser->LeaveList();
	
	if(FAILED(hr))
	{
		Cleanup();
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);
    
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Cleanup

void CArticulation::Cleanup()
{
#ifdef DXAPI
	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		m_dwCountExtChk--;
		delete pExtChk;
	}
	assert(m_dwCountExtChk == 0);
#endif
}

#ifdef DXAPI
DWORD CArticulation::Count()
{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_Condition.m_fOkayToDownload)
    {
        DWORD dwCount = m_dwCountExtChk + 1;
        if (m_Condition.m_fOkayToDownload && m_ArticData.Size()) dwCount++;
        return dwCount;
    }
    return 0;
}
#else
DWORD CArticulation::Count()
{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_ArticData.Size()) return 2;
    return 1;
}
#endif
#ifdef DXAPI
void CArticulation::SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2)

{
    m_fNewFormat = fNewFormat;
    if (fSupportsDLS2)
    {
        m_Condition.Evaluate(pPort);
    }
    else
    {
        m_Condition.m_fOkayToDownload = m_fDLS1;
    }
}

BOOL CArticulation::CheckForConditionals()

{
    return  m_Condition.HasChunk();
}
#endif
//////////////////////////////////////////////////////////////////////
// CArticulation::Size
#ifdef DXAPI
DWORD CArticulation::Size()
{
	DWORD dwSize = 0;
	DWORD dwCountExtChk = 0;
    if (!m_Condition.m_fOkayToDownload)
    {
        return 0;
    }

    if (m_fNewFormat)
    {
	    dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
    }
    else
    {
        dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
    }
	
    if (m_Condition.m_fOkayToDownload && m_ArticData.Size())
    {
        if (m_fNewFormat)
        {
            dwSize += CHUNK_ALIGN(m_ArticData.Size());
        }
        else
        {
		    dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	    }
    }
	// Calculate the space need for Articulation's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwSize += pExtChk->Size();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk != dwCountExtChk)
	{
		assert(false);
		dwSize = 0;
	}

	return dwSize;
}

#else

DWORD CArticulation::Size()
{
	DWORD dwSize = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	
    if (m_ArticData.Size())
    {
        dwSize += CHUNK_ALIGN(m_ArticData.Size());
    }

	return dwSize;
}
#endif
//////////////////////////////////////////////////////////////////////
// CArticulation::Write
#ifdef DXAPI
HRESULT CArticulation::Write(void* pv, 
							 DWORD* pdwCurOffset, 
							 DWORD* pDMWOffsetTable,
							 DWORD* pdwCurIndex,
                             DWORD dwNextArtIndex)
{
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMWOffsetTable);
	assert(pdwCurIndex);
	
    HRESULT hr = S_OK;
	
    if (!m_Condition.m_fOkayToDownload)
    {
        return hr;        // This actually should never happen.
    }   

//	EnterCriticalSection(&m_DMArtCriticalSection);

    DWORD dwRelativeCurOffset = 0;

    ULONG *pulFirstExtCkIdx = NULL;
        
    if (m_fNewFormat)
    {     
    	DMUS_ARTICULATION2* pArt = (DMUS_ARTICULATION2 *)pv;
        dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
        pArt->ulNextArtIdx = dwNextArtIndex;
        if (m_ArticData.Size())
        {
            pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArtIdx = (*pdwCurIndex)++;
            DWORD dwOffsetStart = *pdwCurOffset; 
            m_ArticData.Write((BYTE *)pv + dwRelativeCurOffset,pdwCurOffset);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);	
        }
        else
	    {
		    pArt->ulArtIdx = 0;
	    }
        pulFirstExtCkIdx = &pArt->ulFirstExtCkIdx;
    }
    else
    {
        DMUS_ARTICULATION* pArt = (DMUS_ARTICULATION *)pv;
	    dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
	        (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));

	    if(m_ArticData.Size())
	    {
		    pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArt1Idx = (*pdwCurIndex)++;

            m_ArticData.GenerateLevel1((DMUS_ARTICPARAMS*)
                ((BYTE *)pv + dwRelativeCurOffset));
		    dwRelativeCurOffset += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
		    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	    }
	    else
	    {
		    pArt->ulArt1Idx = 0;
	    }
        pulFirstExtCkIdx = &pArt->ulFirstExtCkIdx;
    }
	// Write extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	if(pExtChk)
	{
		DWORD dwCountExtChk = m_dwCountExtChk;
        DWORD dwIndexNextExtChk;
        *pulFirstExtCkIdx = dwIndexNextExtChk = *pdwCurIndex;
		for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
		{
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk++;    // Add one, since the extension chunks are all in a row.
			}

			pDMWOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset;            
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);		
			dwCountExtChk--;
		}
	}
	else
	{
		// If no extension chunks set to zero
		*pulFirstExtCkIdx = 0;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	return hr;
}
#else
HRESULT CArticulation::Write(void* pv, 
							 DWORD* pdwCurOffset, 
							 DWORD* pDMWOffsetTable,
							 DWORD* pdwCurIndex,
                             DWORD dwNextArtIndex)
{
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMWOffsetTable);
	assert(pdwCurIndex);
	
    DWORD dwRelativeCurOffset = 0;

    {
        DMUS_ARTICULATION2* pArt = (DMUS_ARTICULATION2 *)pv;
        dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
        pArt->ulNextArtIdx = dwNextArtIndex;
        if (m_ArticData.Size())
        {
            pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArtIdx = (*pdwCurIndex)++;
            DWORD dwOffsetStart = *pdwCurOffset; 
            m_ArticData.Write((BYTE *)pv + dwRelativeCurOffset,pdwCurOffset);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);	
        }
        else
	    {
		    pArt->ulArtIdx = 0;
	    }
    }

	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmart.h ===
//
// dmart.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMART_H
#define DMART_H

#include "dmextchk.h"

class CRiffParser;

class CArticData 
{
public:
	CArticData();
	~CArticData();
    HRESULT         Load(CRiffParser *pParser);
    HRESULT         GenerateLevel1(DMUS_ARTICPARAMS *pParamStuct);
inline DWORD        Size();
    BOOL            Write(void *pv,DWORD* pdwCurrentOffset);
private:
    CONNECTIONLIST  m_ConnectionList;
    CONNECTION *    m_pConnections;
};


class CArticulation : public AListItem
{
public:
	CArticulation();
	~CArticulation();
	CArticulation* GetNext(){return(CArticulation*)AListItem::GetNext();}

	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, 
				  DWORD* pdwCurrentOffset, 
				  DWORD* pDMWOffsetTable,
				  DWORD* pdwCurIndex,
                  DWORD dwNextArtIndex);
#ifdef DXAPI
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2);
    BOOL CheckForConditionals();

#endif
	DWORD Size();
	DWORD Count();

private:
	void Cleanup();

//	CRITICAL_SECTION	m_DMArtCriticalSection;
    BOOL                m_fCSInitialized;
    CArticData          m_ArticData;            // Articulation chunk from file.
#ifdef DXAPI
    CExtensionChunkList	m_ExtensionChunkList;   // Unknown additional data chunks.
	DWORD				m_dwCountExtChk;        // Number of extension chunks.
    CConditionChunk     m_Condition;            // Optional conditional chunk;
    BOOL                m_fNewFormat;           // True if the synth handles the INSTRUMENT2 format.
#endif
public:
    BOOL                m_fDLS1;                // True if DLS1 chunk.
};

class CArticulationList : public AList
{
public:
	CArticulationList(){}
	~CArticulationList()
	{
		while(!IsEmpty())
		{
			CArticulation* pArticulation = RemoveHead();
			delete pArticulation;
		}
	}

    CArticulation* GetHead(){return (CArticulation *)AList::GetHead();}
	CArticulation* GetItem(LONG lIndex){return (CArticulation*)AList::GetItem(lIndex);}
    CArticulation* RemoveHead(){return(CArticulation *)AList::RemoveHead();}
	void Remove(CArticulation* pArticulation){AList::Remove((AListItem *)pArticulation);}
	void AddTail(CArticulation* pArticulation){AList::AddTail((AListItem *)pArticulation);}
};

#endif // #ifndef DMART_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmbuffer.cpp ===
// dmbuffer.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Implementation of IDirectMusicBuffer
//
// @doc EXTERNAL
//
//
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX

#include "debug.h"

#include "dmusicp.h"
#include "validate.h"

const GUID guidZero = {0};

static BYTE bMessageLength[128] = 
{
    // Channel
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Note off 0x80-0x8f
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Note on 0x90-0x9f
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Key pressure 0xa0-0xaf
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Control Change 0xb0-0xbf
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     // Patch change 0xc0-0xcf
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     // Channel pressure 0xd0-0xdf
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Pitch bend 0xe0-0xef

    // SysEx
    0,                                                  // 0xf0 SOX invalid in this context

    // System common
    2,                                                  // 0xf1 MTC quarter frame
    3,                                                  // 0xf2 SPP
    2,                                                  // 0xf3 Song select
    0,                                                  // 0xf4 Undefined
    0,                                                  // 0xf5 Undefined
    1,                                                  // 0xf6 Tune request
    0,                                                  // 0xf7 EOX invalid in this context

    // System realtime
    1,                                                  // 0xf8 Timing clock
    0,                                                  // 0xf9 Undefined
    1,                                                  // 0xfa Start
    1,                                                  // 0xfb Continue
    1,                                                  // 0xfc Start
    0,                                                  // 0xfd Undefined
    1,                                                  // 0xfe Active Sense
    1,                                                  // 0xff System Reset
};

//
// Constructor. Takes number of bytes
//
CDirectMusicBuffer::CDirectMusicBuffer(
                                       DMUS_BUFFERDESC &dmbd)
   : m_BufferDesc(dmbd)
{
    m_cRef = 1;
    m_pbContents = NULL;
}

// Destructor
// Clean up after ourselves
//
CDirectMusicBuffer::~CDirectMusicBuffer()
{
    if (m_pbContents) {
        delete[] m_pbContents;
    }
}

// Init
//
// Allocates the buffer; gives us a chance to return out of memory
//
HRESULT
CDirectMusicBuffer::Init()
{
    m_maxContents = DWORD_ROUNDUP(m_BufferDesc.cbBuffer);

    m_pbContents = new BYTE[m_maxContents];
    if (NULL == m_pbContents) {
        return E_OUTOFMEMORY;
    }

    m_cbContents = 0;
    m_idxRead = 0;
    m_totalTime = 0;

    if (m_BufferDesc.guidBufferFormat == KSDATAFORMAT_TYPE_MUSIC ||
        m_BufferDesc.guidBufferFormat == guidZero)
    {
        m_BufferDesc.guidBufferFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    }
    
    return S_OK;
}

// @method HRESULT | IDirectMusicBuffer | GetRawBufferPtr | Returns a pointer to the buffer's contents.
//
// @comm
//
// Returns a pointer to the underlying buffer data structure.
// This method returns a pointer to the raw data of the buffer. The format of this data is implementation
// dependent. The lifetime of this data is the same as the lifetime of the buffer object; therefore, the
// returned pointer should not be held past the next call to the <m Release> method.
//
// @rdesc
//
// @flag S_OK | On success
// @flag E_POINTER | If the given <p ppData> pointer is invalid
//
STDMETHODIMP
CDirectMusicBuffer::GetRawBufferPtr(
    LPBYTE *ppData)         // @parm Receives a pointer to the buffer's data.
{
    V_INAME(IDirectMusicBuffer::GetRawBufferPointer);
    V_PTRPTR_WRITE(ppData);
    
    *ppData = m_pbContents;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetStartTime | Gets the start time of the data in the buffer.
//
// @comm
// Gets the start time of the data in the buffer.  The start time is relative to DirectMusic's master clock.
//
// @rdesc
//
// @flag S_OK | On success
// @flag DMUS_E_BUFFER_EMPTY | If there is no data in the buffer
// @flag E_POINTER | If the passed <p prt> pointer is invalid
// 
STDMETHODIMP
CDirectMusicBuffer::GetStartTime(
    LPREFERENCE_TIME prt)       // @parm Receives the start time.
{
    V_INAME(IDirectMusicBuffer::GetStartTime);
    V_PTR_WRITE(prt, REFERENCE_TIME);
    
    if (m_cbContents)
    {
        *prt = m_rtBase;
        return S_OK;
    }

    return DMUS_E_BUFFER_EMPTY;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetUsedBytes | Returns the amount of music data currently in the buffer.
//
// @comm
// Gets the number of bytes of data in the buffer.
//
// @rdesc
//
// @flag S_OK | On success
// @flag E_POINTER | If the given <p pcb> pointer is invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetUsedBytes(
    LPDWORD pcb)                // @parm Receives the number of used bytes.
{
    V_INAME(IDirectMusicBuffer::GetUsedBytes);
    V_PTR_WRITE(pcb, DWORD);
    
    *pcb = m_cbContents;
    
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetMaxBytes | Returns the maximum number of bytes the buffer can hold.
//
// @comm
// Retrieves the maximum number of bytes that can be stored in the buffer.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pcb> pointer was invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetMaxBytes(
    LPDWORD pcb)                // @parm Receives the maximum number of bytes the buffer can hold.
{
    V_INAME(IDirectMusicBuffer::GetMaxBytes);
    V_PTR_WRITE(pcb, DWORD);
    
    *pcb = m_maxContents;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetBufferFormat | Returns the GUID representing the buffer format.
//
// @comm
// Retrieves the GUID representing the format of the buffer. If the format was not specified, then KSDATAFORMAT_SUBTYPE_MIDI
// will be returned.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pGuidFormat> pointer was invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetBufferFormat(
    LPGUID pGuidFormat)                // @parm Receives the GUID format of the buffer
{
    V_INAME(IDirectMusicBuffer::GetBufferFormat);
    V_PTR_WRITE(pGuidFormat, GUID);

    *pGuidFormat = m_BufferDesc.guidBufferFormat;
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | SetStartTime | Sets the start time of the buffer.
//
// @comm
// Sets the start time of the data in the buffer.  Times in DirectMusic
// are relative to master clock which can be retrieved and set with the
// <i IDirectMusic> interface. For more information about the master clock,
// see the description of <om IDirectMusic::SetMasterClock>.
//
// @rdesc
//
// @flag S_OK | On success
//
STDMETHODIMP
CDirectMusicBuffer::SetStartTime(
    REFERENCE_TIME rt)          // @parm The new start time for the buffer.
{
    m_rtBase = rt;
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | SetUsedBytes | Sets the number of bytes of data in the buffer.
//
// @comm
// This method allows an application to repack a buffer manually. Generally this should only be done
// if the data format in the buffer is different from the default format provided by DirectMusic. (i.e.
// in a format other than KSDATAFORMAT_SUBTYPE_MIDI).
//
// @rdesc
//
// @flag S_OK | On success
// @flag DMUS_E_BUFFER_FULL | If the specified number of bytes exceeds the maximum buffer size as returned by <m GetMaxBytes>.
//
STDMETHODIMP
CDirectMusicBuffer::SetUsedBytes(
    DWORD cb)                   // @parm The number of valid data bytes in the buffer
{
    if (cb > m_maxContents)
    {
        return DMUS_E_BUFFER_FULL;
    }
    
    m_cbContents = cb;
    
    return S_OK;
}

// CDirectMusicBuffer::QueryInterface
//
STDMETHODIMP
CDirectMusicBuffer::QueryInterface(const IID &iid,
                                   void **ppv)
{
    V_INAME(IDirectMusicBuffer::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicBuffer) {
        *ppv = static_cast<IDirectMusicBuffer*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CDirectMusicBuffer::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicBuffer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicBuffer::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicBuffer::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | Flush | Empties the buffer.
//
// @comm
// Discards all data in the buffer.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicBuffer::Flush()
{
    m_cbContents = 0;
    m_totalTime = 0;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | TotalTime | Returns the total time spanned by the data in the buffer.
//
// @comm
// As with all times in DirectMusic, the time is specified in 100 ns units.
// 
// @rdesc Returns one of the following
//
// @flag S_OK | On success.
// @flag E_POINTER | If the <p prtTime> pointer is invalid.
//
STDMETHODIMP
CDirectMusicBuffer::TotalTime(
                              LPREFERENCE_TIME prtTime)      // @parm Received the total time spanned by the buffer
{
    V_INAME(IDirectMusicBuffer::TotalTile);
    V_PTR_WRITE(prtTime, REFERENCE_TIME);
    
    *prtTime = m_totalTime;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | PackStructured | Inserts a MIDI channel message event at the end of the buffer.
//
// @comm
// There must be at least 24 bytes free in the buffer to insert a channel message.
//
// Although buffers may overlap in time, events within a buffer may not. All events in a buffer must
// be packed in order of ascending time.
//
// @rdesc
//
// @flag S_OK | On success.
// @flag E_OUTOFMEMORY | If there is no room in the buffer for the event.
//
STDMETHODIMP
CDirectMusicBuffer::PackStructured(
                                   REFERENCE_TIME rt,   // @parm The absolute time of the event
                                   DWORD dwChannelGroup,// @parm The channel group of the event on the outgoing port
                                   DWORD dwMsg)         // @parm The channel message to pack 
{
    BYTE b0 = (BYTE)(dwMsg & 0x000000FF);
    BYTE bLength = (b0 & 0x80) ? bMessageLength[b0 & 0x7f] : 0;
    if (bLength == 0)
    {
        return DMUS_E_INVALID_EVENT;
    }

    DMUS_EVENTHEADER *pHeader = AllocEventHeader(rt, 
                                                 bLength, 
                                                 dwChannelGroup, 
                                                 DMUS_EVENT_STRUCTURED);
    if (pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory((LPBYTE)(pHeader + 1), &dwMsg, bLength);

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | PackUnstructured | Inserts a MIDI channel message event at the end of the buffer.
//
// @comm
// There must be at least 16 bytes plus the quadword-aligned size of the message
// free in the buffer to insert a channel message.
//
// Although buffers may overlap in time, events within a buffer may not. All events in a buffer must
// be packed in order of ascending time.
// 
// @rdesc
//  
// @flag S_OK | On success.
// @flag E_OUTOFMEMORY | If there is no room in the buffer for the event.
// @flag E_POINTER | If the <p lpb> pointer is invalid.
//
//
STDMETHODIMP
CDirectMusicBuffer::PackUnstructured(
                              REFERENCE_TIME rt,    // @parm The absolute time of the event
                              DWORD dwChannelGroup, // @parm The channel group of the event on the outgoing port
                              DWORD cb,             // @parm The size in bytes of the event
                              LPBYTE lpb)           // @parm The next event must be played contigously
{
    V_INAME(IDirectMusicBuffer::PackSysEx);
    V_BUFPTR_READ(lpb, cb);

    DMUS_EVENTHEADER *pHeader = AllocEventHeader(rt, 
                                                 cb, 
                                                 dwChannelGroup,
                                                 0);
    if (pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory((LPBYTE)(pHeader + 1), lpb, cb);
    
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | ResetReadPtr | Causes the next to GetNextEvent to return the first event in the buffer.
//
// @comm
// Moves the read pointer to the start of the data in the buffer.
//
// @rdesc
//
// @flag S_OK | On success
//
STDMETHODIMP
CDirectMusicBuffer::ResetReadPtr()
{
    m_idxRead = 0;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetNextEvent | Returns the next event in the buffer and advances the read pointer.
//
// @comm
// Any of the passed pointers may be NULL if the pointed-to item is not needed.
//
// The pointer returned in <p ppData> is only valid for the lifetime of the buffer object. It should only
// be held until the next call of the object's Release method.
//
// @rdesc
//
// @flag S_OK | On success
// @flag S_FALSE | If there are no more events in the buffer
// @flag E_POINTER | If any of the pointers is invalid
//
STDMETHODIMP
CDirectMusicBuffer::GetNextEvent(
                                 LPREFERENCE_TIME prt,      // @parm Receives the time of the event
                                 LPDWORD pdwChannelGroup,   // @parm Receives the channel group of the event
                                 LPDWORD pdwLength,         // @parm Receives the length in bytes of the event
                                 LPBYTE *ppData)            // @parm Receives a pointer to the event data
{
    V_INAME(IDirectMusicBuffer::GetNextEvent);
    V_PTR_WRITE_OPT(prt, REFERENCE_TIME);
    V_PTR_WRITE_OPT(pdwChannelGroup, DWORD);
    V_PTR_WRITE_OPT(pdwLength, DWORD);
    V_PTRPTR_WRITE_OPT(ppData);
            
    if (m_idxRead >= m_cbContents) {
        return S_FALSE;
    }

    LPDMUS_EVENTHEADER pHeader = (LPDMUS_EVENTHEADER)(m_pbContents + m_idxRead);
    m_idxRead += DMUS_EVENT_SIZE(pHeader->cbEvent);

    if (pdwLength) {
        *pdwLength = pHeader->cbEvent;
    }

    if (pdwChannelGroup) {
        *pdwChannelGroup = pHeader->dwChannelGroup;
    }

    if (prt) {
        *prt = m_rtBase + pHeader->rtDelta;
    }

    if (ppData) {
        *ppData = (LPBYTE)(pHeader + 1);
    }

    return S_OK;
}



DMUS_EVENTHEADER *
CDirectMusicBuffer::AllocEventHeader(
    REFERENCE_TIME rt,
    DWORD cbEvent,
    DWORD dwChannelGroup,
    DWORD dwFlags)
{
    DMUS_EVENTHEADER *pHeader;
    LPBYTE pbWalk = m_pbContents;
    DWORD  cbWalk = m_cbContents;

    // Add in header size and round up
    //
    DWORD cbNewEvent = DMUS_EVENT_SIZE(cbEvent);

    if (m_maxContents - m_cbContents < cbNewEvent)
    {
        return NULL;
    }

    if (m_cbContents == 0)
    {
        // Empty buffer
        //
        m_rtBase = rt;
        m_cbContents = cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)m_pbContents;
    }
    else if (rt >= m_rtBase + m_totalTime)
    {
        // At end of buffer
        //
        if (rt - m_rtBase > m_totalTime)
            m_totalTime = rt - m_rtBase;
        
        pHeader = (DMUS_EVENTHEADER*)(m_pbContents + m_cbContents);
        m_cbContents += cbNewEvent;
    }
    else if (rt < m_rtBase)
    {
        // New first event and have to adjust all the offsets.
        //
        REFERENCE_TIME rtDelta = m_rtBase - rt;

        while (cbWalk)
        {
            assert(cbWalk >= sizeof(DMUS_EVENTHEADER));

            DMUS_EVENTHEADER *pHeader = (DMUS_EVENTHEADER*)pbWalk;
            DWORD cbEvent = DMUS_EVENT_SIZE(pHeader->cbEvent);
            assert(cbWalk >= cbEvent);

            pHeader->rtDelta += rtDelta;
            m_totalTime = pHeader->rtDelta;

            cbWalk -= cbEvent;
            pbWalk += cbEvent;
        }        

        m_rtBase = rt;
        MoveMemory(m_pbContents + cbNewEvent, m_pbContents, m_cbContents);

        m_cbContents += cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)m_pbContents;
    }
    else
    {
        
        // Out of order event. Search until we find where it goes
        //
        for (;;)
        {
            assert(cbWalk >= sizeof(DMUS_EVENTHEADER));
            
            DMUS_EVENTHEADER *pHeader = (DMUS_EVENTHEADER*)pbWalk;
            DWORD cbEvent = DMUS_EVENT_SIZE(pHeader->cbEvent);
            assert(cbWalk >= cbEvent);

            if (m_rtBase + pHeader->rtDelta > rt)
            {
                break;
            }

            cbWalk -= cbEvent;
            pbWalk += cbEvent;
        }        

        // pbWalk points to first byte to go *after* the new event, which will be the new
        // event's location. cbWalk is the number of bytes left in the buffer
        //
        MoveMemory(pbWalk + cbNewEvent, pbWalk, cbWalk);
        
        m_cbContents += cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)pbWalk;
    }

    pHeader->cbEvent            = cbEvent;
    pHeader->dwChannelGroup     = dwChannelGroup;
    pHeader->rtDelta            = rt - m_rtBase;
    pHeader->dwFlags            = dwFlags;

    return pHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmcollec.cpp ===
//
// dmcollec.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//
// @doc EXTERNAL
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include "debug.h"
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "dmusicp.h"
#include "debug.h"
#include "dlsstrm.h"
#include "dmcrchk.h"
#include "dminsobj.h"
#include "dmcollec.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CCollection

//////////////////////////////////////////////////////////////////////
// CCollection::CCollection

CCollection::CCollection() : m_MemTrack(DMTRACK_COLLECTION)
{
    m_pStream = NULL;
    m_dwSizeRiffChunk = 0;
    m_dwFirstInsId = 0;
    m_dwNumPatchTableEntries = 0;
    m_pPatchTable = NULL;
    m_dwFirstWaveId = 0;
    m_dwWaveTableBaseAddress = 0;
    m_pWaveOffsetTable = NULL;
    m_dwWaveOffsetTableSize = 0;
#ifdef DXAPI
	ZeroMemory(&m_vVersion, sizeof(m_vVersion));
    m_pCopyright = NULL;
    m_wszName[0] = 0;
#endif
    m_guidObject = GUID_NULL;
    m_bLoaded = false;
    m_cRef = 1;
    m_fCSInitialized = FALSE;
	InterlockedIncrement(&g_cComponent);
    InitializeCriticalSection(&m_CDMCollCriticalSection);
    m_fCSInitialized = TRUE;
}
	
//////////////////////////////////////////////////////////////////////
// CCollection::~CCollection()

CCollection::~CCollection()
{
    if (m_fCSInitialized)
    {
    	Cleanup();

        EnterCriticalSection(&m_CDMCollCriticalSection);

        if ((!m_InstList.IsEmpty()))
        {
#ifdef DBG
            assert(FALSE); // should never happen (as long as instruments keep a refcnt on us)
#endif // DBG
            while (!m_InstList.IsEmpty())
            {
                m_InstList.RemoveHead();
            }
        }

        LeaveCriticalSection(&m_CDMCollCriticalSection);

        DeleteCriticalSection(&m_CDMCollCriticalSection);
    }

  	InterlockedDecrement(&g_cComponent);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CCollection::QueryInterface

STDMETHODIMP CCollection::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicCollection::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicCollection)
	{
		*ppv = static_cast<IDirectMusicCollection*>(this);
	} 
	else if(iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if(iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::AddRef

STDMETHODIMP_(ULONG) CCollection::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CCollection::Release

STDMETHODIMP_(ULONG) CCollection::Release()
{
    if(!InterlockedDecrement(&m_cRef))
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CCollection::Load

STDMETHODIMP CCollection::Load(IStream* pStream)
{
	// Argument validation
	V_INAME(CCollection::Load);
	V_PTR_READ(pStream, IStream);

	// If we have a previous DLS stream return with an error
	if(m_pStream)
	{
		return DMUS_E_ALREADY_LOADED;
	}
    pStream->AddRef();
    m_pStream = pStream;
	HRESULT hr = S_OK;
	RIFFIO ckMain;
    CRiffParser Parser(pStream);
    // Get the current position in the stream and save for validation.
    Parser.EnterList(&ckMain);  
    Parser.MarkPosition();
    // This should be the start of the data chunk, so add the size of the RIFF header.
    m_dwStartRiffChunk = (DWORD) ckMain.liPosition.QuadPart + 8;
    if (Parser.NextChunk(&hr))
    {
		// Now that we've read the header, store the size of the data to follow (which
        // should be the entire DLS collection if in fact this is FOURCC_DLS).
        // This will be used for validation later.
		m_dwSizeRiffChunk = ckMain.cksize;
        if (ckMain.fccType == FOURCC_DLS)
        {
			// We have a DLS Collection we now want to parse it
			hr = Parse(&Parser);
		}
		else
		{
			hr = DMUS_E_NOTADLSCOL;
		}
	}

	m_bLoaded = true;

	if(FAILED(hr))
	{
		// If not a DLS Collection or some other error release allocated resources
		Cleanup();
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

//////////////////////////////////////////////////////////////////////
// CCollection::GetDescriptor

STDMETHODIMP CCollection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CCollection::GetDescriptor);
    // Deal with the fact that we wrote really stupid invalidation tests for DX7, and then
    // crafted the code to pass (that's right... Wobert!)
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
	    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }
#ifdef DXAPI
	if(m_vVersion.dwVersionMS || m_vVersion.dwVersionLS)
	{
		pDesc->dwValidData |= DMUS_OBJ_VERSION;
		pDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
		pDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
	}

	if(m_pCopyright != NULL && 
	   m_pCopyright->m_byFlags & DMC_FOUNDINAM)
	{
		pDesc->dwValidData |= DMUS_OBJ_NAME;
		wcscpy(pDesc->wszName, m_pCopyright->m_pwzName);
	}
#endif
	if(m_guidObject != GUID_NULL)
	{
		pDesc->dwValidData |= DMUS_OBJ_OBJECT;
		pDesc->guidObject = m_guidObject;
	}
#ifdef DXAPI
    if (m_wszName[0])
    {
        wcscpy(pDesc->wszName, m_wszName);
        pDesc->dwValidData |= DMUS_OBJ_NAME;
    }
#endif
	pDesc->guidClass = CLSID_DirectMusicCollection;
	pDesc->dwValidData |= DMUS_OBJ_CLASS;

	if(m_bLoaded)
	{
		pDesc->dwValidData |= DMUS_OBJ_LOADED;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::SetDescriptor

STDMETHODIMP CCollection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	V_INAME(CCollection::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);
	if (pDesc->dwSize)
    {
	    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }
    
	DWORD dwTemp = pDesc->dwValidData;

	if(pDesc->dwValidData == 0)
	{
		return S_OK;
	}

	if(pDesc->dwValidData & DMUS_OBJ_OBJECT)
	{
		m_guidObject = pDesc->guidObject;
	}

	if(pDesc->dwValidData & DMUS_OBJ_CLASS)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_CLASS;
	}
#ifdef DXAPI
	if(pDesc->dwValidData & DMUS_OBJ_NAME)
	{
        wcscpy(m_wszName, pDesc->wszName);
	}
#endif
	if(pDesc->dwValidData & DMUS_OBJ_CATEGORY)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_CATEGORY;
	}

	if(pDesc->dwValidData & DMUS_OBJ_FILENAME)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_FILENAME;
	}

	if(pDesc->dwValidData & DMUS_OBJ_FULLPATH)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_FULLPATH;
	}

	if(pDesc->dwValidData & DMUS_OBJ_URL)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_URL;
	}

	if(pDesc->dwValidData & DMUS_OBJ_VERSION)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_VERSION;
	}
	
	if(pDesc->dwValidData & DMUS_OBJ_DATE)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_DATE;
	}

	if(pDesc->dwValidData & DMUS_OBJ_LOADED)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_LOADED;
	}
	
	return dwTemp == pDesc->dwValidData ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// CCollection::ParseDescriptor

STDMETHODIMP CCollection::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
	// Argument validation
	V_INAME(CCollection::ParseDescriptor);
	V_PTR_READ(pStream, IStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    // This is a stupid hack to make up for regression issues... Sigh...
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    CRiffParser Parser(pStream);
    RIFFIO ckMain;
	RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == FOURCC_DLS))
    {
        dwValidData = DMUS_OBJ_CLASS;
		pDesc->guidClass = CLSID_DirectMusicCollection;
        Parser.EnterList(&ckNext);
	    while(Parser.NextChunk(&hr))
	    {
		    switch(ckNext.ckid)
		    {
            case FOURCC_DLID:
				hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
				dwValidData |= DMUS_OBJ_OBJECT;
				break;
            case FOURCC_VERS:
				hr = Parser.Read( &pDesc->vVersion, sizeof(DLSVERSION) );
				dwValidData |= DMUS_OBJ_VERSION;
				break;
			case FOURCC_LIST:
				if (ckNext.fccType == mmioFOURCC('I','N','F','O'))
                {
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
					{
						if (ckUNFO.ckid == mmioFOURCC('I','N','A','M'))
						{
			                char szName[DMUS_MAX_NAME];
			                hr = Parser.Read(szName, DMUS_MAX_NAME);
				            MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, DMUS_MAX_NAME);
				            dwValidData |= DMUS_OBJ_NAME;
						}
					}
                    Parser.LeaveList();          
				}
				break;
		    }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_NOTADLSCOL;
    }
	if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
	return hr;
}

STDMETHODIMP CCollection::GetInstrument(
	DWORD dwPatch,							// @parm Instrument patch number, including bank select and drum flag.
	IDirectMusicInstrument** ppInstrument)	// @parm Return value in pointer to <i IDirectMusicInstrument> interface.
{
	// Argument validation
	V_INAME(CCollection::GetInstrument);
	V_PTRPTR_WRITE(ppInstrument);

	// We use 0x7F to strip out the Drum Kit flag
	BYTE bMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
	BYTE bLSB = (BYTE) (dwPatch >> 8);
	BYTE bInstrument = (BYTE) dwPatch & 0x7F;

    EnterCriticalSection(&m_CDMCollCriticalSection);

	HRESULT hr = E_FAIL;

	CInstrument* pDMInstrument = NULL;
    
    hr = FindInstrument(dwPatch, &pDMInstrument);
    
    if (!pDMInstrument && SUCCEEDED(hr))
    {
        try
        {
            pDMInstrument = new CInstrument();
        }
        catch( ... )
        {
            pDMInstrument = NULL;
        }

	    if (pDMInstrument)
	    {
		    hr = pDMInstrument->Init(dwPatch, this);

		    if (SUCCEEDED(hr))
		    {
			    hr = AddInstrument(pDMInstrument);
		    }
	    }
	    else
	    {
		    hr = E_OUTOFMEMORY;
	    }
    }
	
    if (FAILED(hr))
    {
        if (pDMInstrument)
        {
            pDMInstrument->Release();
        }
    }
    else
    {
        *ppInstrument = pDMInstrument;
    }

    LeaveCriticalSection(&m_CDMCollCriticalSection);

	return hr;
}

STDMETHODIMP CCollection::EnumInstrument(
	DWORD dwIndex,		// @parm Index into collection's list of instruments.
	DWORD* pdwPatch,	// @parm Pointer to DWORD variable to store patch number in.
	LPWSTR pwszName,		// @parm Address of the WCHAR buffer to receive the instrument name.
						// NULL, if no name desired.
	DWORD dwNameLen)	// @parm Length of the instrument name buffer in WCHARs.
{
	// Argument validation
	V_INAME(IDirectMusicCollection::EnumInstrument);	
	V_PTR_WRITE(pdwPatch, DWORD);

	if(pwszName && (dwNameLen > 0))
	{
		V_BUFPTR_WRITE(pwszName, (sizeof(WCHAR) * dwNameLen));
	}

	if(dwIndex >= m_dwNumPatchTableEntries)
	{
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	*pdwPatch = m_pPatchTable[dwIndex].ulPatch;

	if(pwszName && dwNameLen != 0)
	{
		wcscpy(pwszName, L"");

		LARGE_INTEGER li;
		li.QuadPart = m_pPatchTable[dwIndex].ulOffset;
		assert(m_pStream);
		// Seek to beginning of the instrument list chunk in DLS file
		hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);
		RIFFIO ckMain;
        CRiffParser Parser(m_pStream);
        Parser.EnterList(&ckMain);
        if (Parser.NextChunk(&hr))
        {
			if ((ckMain.ckid == FOURCC_LIST) && (ckMain.fccType == FOURCC_INS))
            {
                RIFFIO ckInfo;
                Parser.EnterList(&ckInfo);
                while (Parser.NextChunk(&hr))
                {
                    if ((ckInfo.ckid == FOURCC_LIST) && (ckInfo.fccType == mmioFOURCC('I','N','F','O')))
                    {
                        RIFFIO ckName;
                        Parser.EnterList(&ckName);
                        while (Parser.NextChunk(&hr))
                        {
                            if (ckName.ckid == mmioFOURCC('I','N','A','M'))
                            {
			                    char szName[DMUS_MAX_NAME];
			                    hr = Parser.Read(szName, min(dwNameLen,DMUS_MAX_NAME));
				                MultiByteToWideChar(CP_ACP, 0, szName, -1, pwszName, dwNameLen);
                                break;
                            }
                        }
                        Parser.LeaveList();
                        break;
                    }
				}
                Parser.LeaveList();
			}
            else
            {
                hr = E_FAIL;
            }
		}
	}
	
	return hr;
}
 
//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CCollection::Cleanup

void CCollection::Cleanup()
{
	if(m_pStream)
	{
		m_pStream->Release();
		m_pStream = NULL;
	}

	if(m_pPatchTable)
	{
		delete [] m_pPatchTable;
		m_pPatchTable = NULL;
		m_dwNumPatchTableEntries = 0;
	}
	
	delete[] m_pWaveOffsetTable;
	m_pWaveOffsetTable = NULL;
#ifdef DXAPI
	delete m_pCopyright;
	m_pCopyright = NULL;
#endif
	m_bLoaded = false;
}

//////////////////////////////////////////////////////////////////////
// CCollection::Parse

HRESULT CCollection::Parse(CRiffParser *pParser)
{	
	RIFFIO ckNext;
    HRESULT hr = S_OK;
    BOOL fJustDidInfo = false; // Hack to work around bad file, which caused a regression.
                               // Here for DX7 compatibility.
    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
        fJustDidInfo = false;
        switch(ckNext.ckid)
		{
#ifdef DXAPI
        case FOURCC_VERS:
			hr = pParser->Read(&m_vVersion, sizeof(DLSVERSION));
			break;
#endif
		case FOURCC_DLID:
            hr = pParser->Read(&m_guidObject, sizeof(GUID));
            break;
		case FOURCC_COLH:
			DLSHEADER dlsHeader;
			hr = pParser->Read(&dlsHeader, sizeof(DLSHEADER));
			if(SUCCEEDED(hr))
			{
				m_dwNumPatchTableEntries = dlsHeader.cInstruments;
				m_pPatchTable = new DMUS_PATCHENTRY[m_dwNumPatchTableEntries];
				if(m_pPatchTable == NULL)
				{
					hr = E_OUTOFMEMORY;
				}
			}
			break;
		case FOURCC_PTBL:
			hr = BuildWaveOffsetTable(pParser);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
#ifdef DXAPI
				case mmioFOURCC('I','N','F','O'):
                    fJustDidInfo = true;
					m_pCopyright = new CCopyright(true);
					if(m_pCopyright)
					{
						hr = m_pCopyright->Load(pParser);
						if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0 &&
						   (m_pCopyright->m_byFlags & DMC_FOUNDINAM) == 0)
						{
							delete m_pCopyright;
							m_pCopyright = NULL;
							break;
						}
                        if (m_pCopyright->m_byFlags & DMC_FOUNDINAM)
                        {
                            if (m_pCopyright->m_pwzName)
                            {
                                wcsncpy(m_wszName, m_pCopyright->m_pwzName, DMUS_MAX_NAME);
                            }
                        }
					}
					else
					{
						hr =  E_OUTOFMEMORY;
					}
					break;
#endif
				case FOURCC_WVPL:
				{			
                    pParser->MarkPosition();
					// We need to store the start of the wave table. This should point to the first
                    // Wave in the file. So, we take our current position.
					m_dwWaveTableBaseAddress = (DWORD) ckNext.liPosition.QuadPart; //DM_WAVELISTCHK_OFFSET_FROM_WAVE_TBL_BASE;
					hr = ValidateOffset(m_dwWaveTableBaseAddress);
					break;
				}
				case FOURCC_LINS :
					hr = BuildInstrumentOffsetTable(pParser);
					break;
			}
			break;
		}
	}
    if (FAILED(hr) && fJustDidInfo)
    {
        hr = S_OK;
    }
    pParser->LeaveList();

	// If we return an error Parse() is expecting the caller to call Cleanup
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::BuildInstrumentOffsetTable

HRESULT CCollection::BuildInstrumentOffsetTable(CRiffParser *pParser)
{
	CDirectMusicPort::GetDLIdP(&m_dwFirstInsId, m_dwNumPatchTableEntries);
	DWORD dwCurId = m_dwFirstInsId;
	DWORD dwIndex = 0;	
	RIFFIO ckNext;  
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		if ((ckNext.ckid == FOURCC_LIST) && (ckNext.fccType == FOURCC_INS))
        {
			RIFFIO ck;
            pParser->MarkPosition();
	        DWORD dwSavedPos = (DWORD) ckNext.liPosition.QuadPart - 12; 
            pParser->EnterList(&ck);
            while (pParser->NextChunk(&hr))
            {
				if (ck.ckid == FOURCC_INSH)
                {
					DWORD dwPatch;
					INSTHEADER instHeader;
					hr = pParser->Read(&instHeader, sizeof(INSTHEADER));
					if(SUCCEEDED(hr))
					{
						dwPatch = instHeader.Locale.ulInstrument;
						dwPatch |= (instHeader.Locale.ulBank) << 8;
						dwPatch |= (instHeader.Locale.ulBank & 0x80000000);
                        if (dwIndex < m_dwNumPatchTableEntries)
                        {
							m_pPatchTable[dwIndex].ulId = dwCurId++;
							m_pPatchTable[dwIndex].ulOffset = dwSavedPos;
							m_pPatchTable[dwIndex++].ulPatch = dwPatch;
                        }
                        else hr = E_FAIL;
					}
                }
            }
            pParser->LeaveList();
		}
	}
    pParser->LeaveList();

	if(SUCCEEDED(hr) && dwIndex != m_dwNumPatchTableEntries)
	{
		hr = E_FAIL;
	}

	// If we return an error BuildInstrumentOffsetTable() is expecting the caller to call Cleanup
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::BuildWaveOffsetTable

HRESULT CCollection::BuildWaveOffsetTable(CRiffParser *pParser)
{
	POOLCUE* pTablePoolCue = NULL;
	POOLTABLE pt;
	HRESULT hr = pParser->Read(&pt, sizeof(POOLTABLE));

	if(SUCCEEDED(hr))
	{
		pTablePoolCue = new POOLCUE[pt.cCues];
		
		if(pTablePoolCue == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
  			hr = pParser->Read(pTablePoolCue, pt.cCues * sizeof(POOLCUE));
			if(SUCCEEDED(hr))
			{
				CDirectMusicPort::GetDLIdP(&m_dwFirstWaveId, pt.cCues);
				m_pWaveOffsetTable = new DMUS_WAVEOFFSET[pt.cCues];
                m_dwWaveOffsetTableSize = pt.cCues;
				if(m_pWaveOffsetTable)
				{
					for(DWORD i = 0; i < pt.cCues; i++)
					{
						m_pWaveOffsetTable[i].dwId = m_dwFirstWaveId + i;
						m_pWaveOffsetTable[i].dwOffset = pTablePoolCue[i].ulOffset;
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
	}
	
    if (pTablePoolCue)
    {
	    delete [] pTablePoolCue;
    }
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::ExtractInstrument

HRESULT CCollection::ExtractInstrument(DWORD& dwPatch, CInstrObj** pInstrObj)
{
	// Argument validation - Debug
	assert(pInstrObj);

    // Bug 42673: If we create a collection and never call load on it m_pStream can be NULL
    // assert(m_pStream);
    if(m_pStream == NULL)
    {
        Trace(1, "ERROR: CCollection::ExtractInstrument failed. Collection is not loaded (stream is NULL)\n");
        return DMUS_E_NOT_LOADED;
    }

	HRESULT hr = E_FAIL;

	bool bFound = false;

	*pInstrObj = NULL;		

	for(DWORD dwIndex = 0; dwIndex < m_dwNumPatchTableEntries; dwIndex++)
	{
		if(dwPatch == m_pPatchTable[dwIndex].ulPatch)
		{
			bFound = true;
			hr = S_OK;
			break;
		}
	}
	
	if(bFound)
	{
        CInstrObj *pInstrument;
        try
        {
		    pInstrument = new CInstrObj;
        }
        catch( ... )
        {
            pInstrument = NULL;
        }
		if(pInstrument)
		{
			LARGE_INTEGER li;
			li.QuadPart = m_pPatchTable[dwIndex].ulOffset;
			// Seek to beginning of the instrument list chunk in DLS file
			hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);
            CRiffParser Parser(m_pStream);
            RIFFIO ckNext;
            Parser.EnterList(&ckNext);
	        if (Parser.NextChunk(&hr))
	        {
		        if ((ckNext.ckid == FOURCC_LIST) && (ckNext.fccType == FOURCC_INS))
                {
				    hr = pInstrument->Load(m_pPatchTable[dwIndex].ulId, &Parser, this);
				    if(SUCCEEDED(hr))
				    {
					    hr = pInstrument->FixupWaveRefs();
				    }
                }
			}
			if(FAILED(hr))
			{
				delete pInstrument;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		} 
        if (SUCCEEDED(hr))
        {
            *pInstrObj = pInstrument;
        }
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////
// CCollection::ExtractWave

HRESULT CCollection::ExtractWave(DWORD dwId, CWaveObj** ppWaveObj)
{
	// Assumption validation - Debug
	assert(ppWaveObj);

#ifdef DBG
	if(dwId >= CDirectMusicPortDownload::sNextDLId)
	{
		assert(FALSE);
	}
#endif

	assert(m_pStream);

	DWORD dwOffset	= m_dwWaveTableBaseAddress
					  + m_pWaveOffsetTable[dwId - m_dwFirstWaveId].dwOffset; 
//					  - DM_WAVELISTCHK_OFFSET_FROM_WAVE_FORMTYPE;
	
	
	HRESULT hr = ValidateOffset(dwOffset);

	if(FAILED(hr))
	{
		return hr;
	}

	LARGE_INTEGER li;
	li.QuadPart = dwOffset;
	// Seek to beginning of the wave list chunk in DLS file
	hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);

	if(SUCCEEDED(hr))
	{
        try
        {
		    *ppWaveObj = new CWaveObj;
        }
        catch( ... )
        {
            *ppWaveObj = NULL;
        }

		if(*ppWaveObj)
		{
            CRiffParser Parser(m_pStream);
            RIFFIO ckNext;
            Parser.EnterList(&ckNext);
	        if (Parser.NextChunk(&hr))
	        {
                if ((ckNext.ckid == FOURCC_LIST) && ((ckNext.fccType == FOURCC_wave) || (ckNext.fccType == mmioFOURCC('W', 'A', 'V', 'E'))))
                {
			        hr = (*ppWaveObj)->Load(dwId, &Parser, this);
                }
            }
			if(FAILED(hr))
			{
				delete *ppWaveObj;
				*ppWaveObj = NULL;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::FindInstrument

STDMETHODIMP
CCollection::FindInstrument(DWORD dwPatch,CInstrument** ppDMInst)
{
    assert(ppDMInst);

    HRESULT hr = S_FALSE;

    for (CInstrument* pDMInst = m_InstList.GetHead();
        pDMInst; pDMInst = pDMInst->GetNext())
    {
        if (pDMInst->m_dwOriginalPatch == dwPatch)
        {
            *ppDMInst = pDMInst;
            (*ppDMInst)->AddRef();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::AddInstrument

STDMETHODIMP
CCollection::AddInstrument(CInstrument* pDMInst)
{
    assert(pDMInst);

    m_InstList.AddTail(pDMInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::RemoveInstrument

STDMETHODIMP
CCollection::RemoveInstrument(CInstrument* pDMInst)
{
    assert(pDMInst);

    EnterCriticalSection(&m_CDMCollCriticalSection);
    m_InstList.Remove(pDMInst);
    LeaveCriticalSection(&m_CDMCollCriticalSection);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmcount.h ===
//
// dmcount.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//

#ifndef DMCOUNT_H
#define DMCOUNT_H

class CWaveID : public AListItem
{
friend class CInstrObj;
friend class CWaveObj;

public:
	CWaveID(DWORD dwId) {m_dwId = dwId;} 
	~CWaveID() {}

	CWaveID* GetNext(){return(CWaveID*)AListItem::GetNext();}

private:
	DWORD	m_dwId;
};

class CWaveIDList : public AList
{
public:
	CWaveIDList(){}
	~CWaveIDList() 
	{
		while(!IsEmpty())
		{
			CWaveID* pWaveID = RemoveHead();
			delete pWaveID;
		}
	}

    CWaveID* GetHead(){return(CWaveID *)AList::GetHead();}
	CWaveID* GetItem(LONG lIndex){return(CWaveID*)AList::GetItem(lIndex);}
    CWaveID* RemoveHead(){return(CWaveID *)AList::RemoveHead();}
	void Remove(CWaveID* pWaveID){AList::Remove((AListItem *)pWaveID);}
	void AddTail(CWaveID* pWaveID){AList::AddTail((AListItem *)pWaveID);}
};

#endif // #ifndef DMCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmclock.cpp ===
//
// DMClock.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Code for dealing with master clocks
//
// 
//
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX

#include "debug.h"
#include <tchar.h>
#include <mmsystem.h>

#include "dmusicp.h"
#include "debug.h"
#include "validate.h"

const TCHAR cszClockMemory[] = TEXT("DirectMusicMasterClock");
const TCHAR cszClockMutex[]  = TEXT("DirectMusicMasterClockMutex");

#ifdef XBOX
CLOCKSHARE g_csMemory;
#endif // XBOX

// CMasterClock::CMasterClock
//
// All real initialization is done in Init
//
CMasterClock::CMasterClock()
{
    m_cRef = 0;
    m_cRefPrivate = 0;

    m_pMasterClock = NULL;
    m_hClockMemory = NULL;
    m_pClockMemory = NULL;
    m_hClockMutex  = NULL;
    m_pExtMasterClock = NULL;
    m_llExtOffset = 0;
    m_pSinkSync = NULL;
}

// CMasterClock::~CMasterClock
//
CMasterClock::~CMasterClock()
{
    Close();
}

// CMasterClock::Init
//
// Create Windows objects for shared memory and synchronization
// Create the list of clocks 
//
HRESULT CMasterClock::Init()
{
#ifdef XBOX

    BOOL fFirst = TRUE;
    
    m_pClockMemory = &g_csMemory;

#else  // XBOX

    // Create a file mapping object for the shared master clock settings
    //
    m_hClockMemory = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(CLOCKSHARE),
                                       cszClockMemory);
    if (m_hClockMemory == NULL)
    {
        TraceI(0, "CreateFileMapping failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    // Was this the call that created the shared memory?
    //
    BOOL fFirst = (GetLastError() != ERROR_ALREADY_EXISTS);

    m_pClockMemory = (CLOCKSHARE*)MapViewOfFile(m_hClockMemory,
                                                FILE_MAP_WRITE,
                                                0, 0,                // Start mapping at the beginning
                                                0);                  // Map entire file
    if (m_pClockMemory == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    m_hClockMutex = CreateMutex(NULL,             // Default security descriptor
                                fFirst,           // Own mutex if we are first instance
                                cszClockMutex);
    if (m_hClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }
#endif // XBOX

#ifdef XBOX

    // If we weren't the first to call CreateMutex(), then fFirst should be FALSE
    //
    fFirst = (ERROR_ALREADY_EXISTS != GetLastError());
    
#endif // XBOX

    if (fFirst)
    {
        // We are the first instance and we own the mutex to modify the shared memory.
        //
        m_pClockMemory->guidClock = GUID_SysClock;
        m_pClockMemory->dwFlags = 0;
#ifndef XBOX
        ReleaseMutex(m_hClockMutex);
#endif
    }    

    // Initialize list of possible clocks
    //
    UpdateClockList();

    return S_OK;
}

// CMasterClock::Close
//
// Release all resources.
//  Release master clock
//  Release list of enum'ed clocks
//  Release Windows objects for shared memory and synchronization
//
void CMasterClock::Close()
{
    CNode<CLOCKENTRY *> *pClockNode;
    CNode<CLOCKENTRY *> *pClockNext;

    // Clock wrapped by CMasterClock
    //
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pExtMasterClock)
    {
        m_pExtMasterClock->Release();
        m_pExtMasterClock = NULL;
    }

    if (m_pSinkSync)
    {
        m_pSinkSync->Release();
        m_pSinkSync = NULL;
    }

    // List of enum'ed clocks
    //
    for (pClockNode = m_lstClocks.GetListHead(); pClockNode; pClockNode = pClockNext)
    {
        pClockNext = pClockNode->pNext;

        delete pClockNode->data;
        m_lstClocks.RemoveNodeFromList(pClockNode);
    }

    // Everything else
    //
    if (m_hClockMutex)
    {
        CloseHandle(m_hClockMutex);
    }

#ifndef XBOX
    if (m_pClockMemory)
    {
        UnmapViewOfFile(m_pClockMemory);
    }

    if (m_hClockMemory)
    {
        CloseHandle(m_hClockMemory);
    }
#endif // ! XBOX
}

// CMasterClock::UpdateClockList()
//
// Make sure the list of available clocks is up to date
//
HRESULT CMasterClock::UpdateClockList()
{
    HRESULT hr;

    CNode<CLOCKENTRY *> *pNode;
    CNode<CLOCKENTRY *> *pNext;

    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pNode->data->fIsValid = FALSE;
    }

    // Add the system clock. This clock must *always* be there
    //
#if defined(USE_WDM_DRIVERS) 
    hr = AddPcClocks(this);
#else
    hr = S_FALSE;
#endif

    if (FAILED(hr) || hr == S_FALSE)
    {         
        AddSysClocks(this);
    }

    AddDsClocks(this);

    // Remove nodes which are no longer valid
    //
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNext)
    {
        pNext = pNode->pNext;

        if (!pNode->data->fIsValid)
        {
            delete pNode->data;
            m_lstClocks.RemoveNodeFromList(pNode);
        }
    }

    return m_lstClocks.GetNodeCount() ? S_OK : S_FALSE;
}

// CMasterClock::AddClock
//
// Add the given clock to the list if it isn't there already
//
HRESULT CMasterClock::AddClock(
    PCLOCKENTRY pClock)
{
    CNode<CLOCKENTRY *> *pNode;
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pClock->cc.guidClock == pNode->data->cc.guidClock)
        {
            pNode->data->fIsValid = TRUE;
            return S_OK;
        }
    }

    // No existing entry - need to create a new one
    //
    PCLOCKENTRY pNewClock = new CLOCKENTRY;
    if (NULL == pNewClock)
    {
        return E_OUTOFMEMORY;
    }

	CopyMemory(pNewClock, pClock, sizeof(CLOCKENTRY));
    pNewClock->fIsValid = TRUE;

    if (NULL == m_lstClocks.AddNodeToList(pNewClock))
    {
        delete pNewClock;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

// CMasterClock::GetMasterClockInterface
//
// Retrieve the wrapped master clock. This should be the *only* way 
// DirectMusic gets the master clock. It is responsible for creating
// the clock and updating the shared memory if the clock does not
// exist yet.
//
HRESULT CMasterClock::GetMasterClockInterface(IReferenceClock **ppClock)
{
#ifndef XBOX
    WaitForSingleObject(m_hClockMutex, INFINITE);
#endif

    if (m_pMasterClock == NULL)
    {
        // We don't have a wrapped clock yet
        //
        HRESULT hr = CreateMasterClock();
        if (FAILED(hr))
        {
#ifndef XBOX
            ReleaseMutex(m_hClockMutex);
#endif
            return hr;
        }

        // Now we do. This means it can no longer be changed.
        //
        m_pClockMemory->dwFlags |= CLOCKSHARE_F_LOCKED;
    }

    // We have the clock. We return an interface to *this* object, which is also
    // a clock and wraps the real one. This allows us to track releases.
    //
    *ppClock = (IReferenceClock*)this;    
    AddRef();
#ifndef XBOX
    ReleaseMutex(m_hClockMutex);
#endif

    return S_OK;
}

// CMasterClock::CreateMasterClock
//
// Actually create the clock object.
//
// This method is private to CMasterClock and assumes the mutex is taken so it can
// access the shared memory.
//
HRESULT CMasterClock::CreateMasterClock()
{
    HRESULT hr;
    CNode<CLOCKENTRY *> *pNode;
    CLOCKENTRY *pClock;

    // Assume clock will not be found
    //
    hr = E_INVALIDARG;

    pClock = NULL;
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (m_pClockMemory->guidClock == pNode->data->cc.guidClock)
        {
            pClock = pNode->data;
            break;
        }
    }

    if (pClock)
    {
        hr = pClock->pfnGetInstance(&m_pMasterClock, this);
    }

    if (SUCCEEDED(hr))
    {
        if (FAILED(m_pMasterClock->QueryInterface(IID_IDirectSoundSinkSync, (void**)&m_pSinkSync)))
        {
            // This is OK, not all clocks support this
            //
            m_pSinkSync = NULL;
        }
    }
    
    return hr;    
}

// CMasterClock::SyncToExternalClock
//
// Sync to an application-given master clock
//
void CMasterClock::SyncToExternalClock()
{
    HRESULT hr;

    assert(m_pExtMasterClock);
    assert(m_pMasterClock);

    REFERENCE_TIME rtSystem;
    hr = m_pMasterClock->GetTime(&rtSystem);

    REFERENCE_TIME rtExternal;
    if (SUCCEEDED(hr))
    {
        hr = m_pExtMasterClock->GetTime(&rtExternal);
    }

    if (SUCCEEDED(hr))
    {
        LONGLONG drift = (rtSystem + m_llExtOffset) - rtExternal;
        m_llExtOffset -= drift / 100;
    }
}

// CMasterClock::EnumMasterClock
//
// Traverse the list looking for the given node
//
HRESULT CMasterClock::EnumMasterClock(
    DWORD           dwIndex,             
    LPDMUS_CLOCKINFO lpClockInfo,
    DWORD           dwVer)        
{
	CNode<CLOCKENTRY *> *pNode;
	DWORD   dwSize; //Used to preserve the dwSize parameter

	pNode = m_lstClocks.GetListHead();
	if (dwIndex == 0 || pNode == NULL)
	{
		UpdateClockList();
	}
    
    pNode = m_lstClocks.GetListHead();
    if (NULL == pNode)
    {
        return E_NOINTERFACE;
    }

	while (dwIndex-- && pNode)
	{
		pNode = pNode->pNext;
	}

	if (pNode == NULL)
	{
		return S_FALSE;
	}

    // Let's capture the dwSize parameter and preserve it past the memcopy.
    // if we don't do this then the dwSize probably becomes the size of the
    // largest strucure
    dwSize = lpClockInfo->dwSize;

    switch (dwVer)
    {
        case 7:
        default:
            memcpy(lpClockInfo, &pNode->data->cc, sizeof(DMUS_CLOCKINFO7));
            break;

        case 8:
            memcpy(lpClockInfo, &pNode->data->cc, sizeof(DMUS_CLOCKINFO8));
    }

    // Now restore the dwSize member
    lpClockInfo->dwSize = dwSize;

	return S_OK;
}


// CMasterClock::GetMasterClock
//
// Return the guid and/or interface to the master clock.
// The master clock may be created as a side effect of this call if one does not
// exist already.
//
HRESULT CMasterClock::GetMasterClock(
    LPGUID pguidClock,              
    IReferenceClock **ppClock)      
{
    HRESULT hr = S_OK;
#ifndef XBOX
    WaitForSingleObject(m_hClockMutex, INFINITE);
#endif
    if (pguidClock)
    {
        *pguidClock = m_pClockMemory->guidClock;
    }

    if (ppClock)
    {
        hr = GetMasterClockInterface(ppClock);
    }
#ifndef XBOX
    ReleaseMutex(m_hClockMutex);
#endif
    return hr;
}

// CMasterClock::SetMasterClock
//
// If the master clock can be updated (i.e. there are no open instances of it),
// then change the shared memory which indicates the GUID.
//
HRESULT CMasterClock::SetMasterClock(REFGUID rguidClock)
{
    HRESULT hr;
    CNode<CLOCKENTRY *> *pNode;
    CLOCKENTRY *pClock;
#ifndef XBOX
    WaitForSingleObject(m_hClockMutex, INFINITE);
#endif
    

    if (m_pClockMemory->dwFlags & CLOCKSHARE_F_LOCKED) 
    {
        hr = DMUS_E_PORTS_OPEN;
    }
    else
    {
        // Assume clock will not be found
        //
        hr = E_INVALIDARG;

        pClock = NULL;
        for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
        {
            if (rguidClock == pNode->data->cc.guidClock)
            {
                pClock = pNode->data;
                break;
            }
        }

        if (pClock)
        {
            // It exists! Save the GUID for later
            //
            m_pClockMemory->guidClock = rguidClock;
            hr = S_OK;
        }
    }
#ifndef XBOX
    ReleaseMutex(m_hClockMutex);
#endif
    return hr;
}

// CMasterClock::SetMasterClock
//
// This version takes an IReferenceClock and uses it to override the clock
// for this process.
//
// This clock is allowed to be jittery. What will actually happen is that the
// system master clock will be locked to this clock so that the master clock
// will be fine grained.
//
HRESULT CMasterClock::SetMasterClock(IReferenceClock *pClock)
{
    HRESULT hr = S_OK;
#ifndef XBOX
    WaitForSingleObject(m_hClockMutex, INFINITE);
#endif
    // We must have the default system clock first so we can sync it
    //
    if (pClock && m_pMasterClock == NULL)
    {
        // We don't have a wrapped clock yet
        //
        hr = CreateMasterClock();
        
        if (SUCCEEDED(hr))
        {
            // Now we do. This means it can no longer be changed.
            //
            m_pClockMemory->dwFlags |= CLOCKSHARE_F_LOCKED;
        }
    }

    // Now set up sync to this master clock
    //
    if (SUCCEEDED(hr))
    {        
        if (pClock)
        {
            REFERENCE_TIME rtSystem;
            REFERENCE_TIME rtExternal;

            hr = m_pMasterClock->GetTime(&rtSystem);
            
            if (SUCCEEDED(hr))
            {
                hr = pClock->GetTime(&rtExternal);
            }

            if (SUCCEEDED(hr))
            {
                m_llExtOffset = rtExternal - rtSystem;
            }
        }
    }    

    // If everything went well, switch over to the new clock
    //
    if (SUCCEEDED(hr))
    {
        if (m_pExtMasterClock)
        {
            m_pExtMasterClock->Release();
            m_pExtMasterClock = NULL;
        }

        m_pExtMasterClock = pClock;

        if (m_pExtMasterClock)
        {
            m_pExtMasterClock->AddRef();
        }
    }
#ifndef XBOX
    ReleaseMutex(m_hClockMutex);
#endif
    return S_OK;
}

// CMasterClock::AddRefPrivate
//
// Release a private reference to the master clock held by DirectMusic
//
LONG CMasterClock::AddRefPrivate()
{
    InterlockedIncrement(&m_cRefPrivate);
    return m_cRefPrivate;
}

// CMasterClock::ReleasePrivate
//
// Release a private reference to the master clock held by DirectMusic
//
LONG CMasterClock::ReleasePrivate()
{
    long cRefPrivate = InterlockedDecrement(&m_cRefPrivate);

    if (cRefPrivate == 0 && m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return cRefPrivate;
}

// CMasterClock::CreateDefaultMasterClock
//
// Creates a private instance of the hardware clock we're using. This is always 
// the first entry in the clock list
//
HRESULT CMasterClock::CreateDefaultMasterClock(IReferenceClock **ppClock)
{
    HRESULT hr = S_OK;
    CLOCKENTRY *pClock;
#ifndef XBOX
    WaitForSingleObject(m_hClockMutex, INFINITE);
#endif
    if (m_lstClocks.GetListHead() == NULL)
    {
        UpdateClockList();
    }

    if (m_lstClocks.GetListHead() == NULL)
    {
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        pClock = m_lstClocks.GetListHead()->data;
        hr = pClock->pfnGetInstance(ppClock, this);
    }    
#ifndef XBOX    
    ReleaseMutex(m_hClockMutex);
#endif
    return hr;
}

STDMETHODIMP CMasterClock::SetClockOffset(LONGLONG llOffset)
{
    if (m_pSinkSync)
    {
        return m_pSinkSync->SetClockOffset(llOffset);
    }
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock interface
//
//

// CMasterClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CMasterClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);
    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IDirectSoundSinkSync)
    {
        // Only support this if the wrapped clock supports it
        //
        if (m_pSinkSync)
        {
            *ppv = static_cast<IDirectSoundSinkSync*>(this);
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        // Some master clocks expose private interfaces. Wrap them.
        //
        // Note that these interfaces acrue to the reference count of the wrapped
        // clock, not CMasterClock
        //
        if (m_pMasterClock)
        {
            return m_pMasterClock->QueryInterface(iid, ppv);
        }

        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CMasterClock::AddRef
// 
STDMETHODIMP_(ULONG) CMasterClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CMasterClock::Release
//
// Since we are tracking a reference count for our wrapped clock, this
// gets a little strange. We have to release that object and change the
// shared memory on the last release, but we don't release ourselves (the
// wrapper object stays around for the life of this instance of DirectMusic).
//
STDMETHODIMP_(ULONG) CMasterClock::Release()
{
#ifndef XBOX
    WaitForSingleObject(m_hClockMutex, INFINITE);
#endif
    m_cRef--;
    if (m_cRef == 0) 
    {
        // Last release! Get rid of the clock and mark the shared memory
        // as unlocked.
        //
        m_pMasterClock->Release();
        m_pMasterClock = NULL;

        m_pClockMemory->dwFlags &= ~CLOCKSHARE_F_LOCKED;
    }
#ifndef XBOX
    ReleaseMutex(m_hClockMutex);
#endif
    if (m_cRefPrivate == 0 && m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CMasterClock::GetTime
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::GetTime(REFERENCE_TIME *pTime)
{
    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    HRESULT hr = E_NOINTERFACE;
        
    if (m_pMasterClock) 
    {
        REFERENCE_TIME rt;

        HRESULT hr = m_pMasterClock->GetTime(&rt);

        if (SUCCEEDED(hr) && m_pExtMasterClock)
        {
            SyncToExternalClock();

            rt += m_llExtOffset;
        }

        *pTime = rt;

        return hr;
    }

    return hr;
}

// CMasterClock::AdviseTime
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::AdviseTime(REFERENCE_TIME baseTime,  
			    REFERENCE_TIME streamTime,
			    HANDLE hEvent,            
			    DWORD * pdwAdviseCookie)
{
    V_INAME(IReferenceClock::AdviseTime);
    V_PTR_WRITE(pdwAdviseCookie, DWORD);
    
    if (m_pMasterClock)
    {
        return m_pMasterClock->AdviseTime(baseTime, streamTime, hEvent, pdwAdviseCookie);
    }
    
    return E_NOINTERFACE;    
}                

// CMasterClock::AdvisePeriodic
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::AdvisePeriodic(REFERENCE_TIME startTime,
				REFERENCE_TIME periodTime,
				HANDLE hSemaphore,   
				DWORD * pdwAdviseCookie)
{
    V_INAME(IReferenceClock::AdvisePeriodic);
    V_PTR_WRITE(pdwAdviseCookie, DWORD);
    
    if (m_pMasterClock)
    {
        return m_pMasterClock->AdvisePeriodic(startTime, periodTime, hSemaphore, pdwAdviseCookie);
    }
    
    return E_NOINTERFACE;    
}

// CMasterClock::AdvisePeriodic
//
// This is possibly called directly by an app
//
STDMETHODIMP CMasterClock::Unadvise(DWORD dwAdviseCookie)
{
    if (m_pMasterClock)
    {
        return m_pMasterClock->Unadvise(dwAdviseCookie);
    }
    
    return E_NOINTERFACE;    
}

// CMasterClock::GetParam
//
// Called by a client to request internal information from the clock
// implementation
//
STDMETHODIMP CMasterClock::GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize)
{
    if (m_pMasterClock == NULL) 
    {
        // Master clock must exist first
        //
        return E_NOINTERFACE;
    }

    IMasterClockPrivate *pPrivate;

    HRESULT hr = m_pMasterClock->QueryInterface(IID_IMasterClockPrivate, (void**)&pPrivate);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pPrivate->GetParam(rguidType, pBuffer, cbSize);

    pPrivate->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmcollec.h ===
//
// dmcollec.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMCOLLEC_H
#define DMCOLLEC_H

#include "dmusicip.h"
#include "dminstru.h"

class CCopyright;
class CRiffParser;

typedef struct _DMUS_WAVEOFFSET
{
	DWORD	dwId;
	DWORD	dwOffset;
} DMUS_WAVEOFFSET;

typedef struct _DMUS_PATCHENTRY
{
	ULONG	ulId;
	ULONG	ulPatch;
	ULONG	ulOffset;
} DMUS_PATCHENTRY;

class CCollection : public IDirectMusicCollection, public IPersistStream, public IDirectMusicObject
{
friend class CInstrObj;
friend class CWaveObj;
friend class CInstrument;

public:
	enum {DM_OFFSET_RIFFCHUNK_DATA = 8, 
		  DM_WAVELISTCHK_OFFSET_FROM_WAVE_TBL_BASE = 12, 
		  DM_WAVELISTCHK_OFFSET_FROM_WAVE_FORMTYPE = 8};
    
	// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
	STDMETHODIMP GetClassID(CLSID* pClassID) {return E_NOTIMPL;}

    // IPersistStream
	STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pIStream);
    STDMETHODIMP Save(IStream* pIStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicCollection
	STDMETHODIMP GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument);
	STDMETHODIMP EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName);

	// Class
	CCollection();
    ~CCollection();

private:
	void Cleanup();
	HRESULT Parse(CRiffParser *pParser);
	HRESULT BuildInstrumentOffsetTable(CRiffParser *pParser);
	HRESULT BuildWaveOffsetTable(CRiffParser *pParser);

	HRESULT ExtractInstrument(DWORD& dwPatch, CInstrObj** pInstrObj);
	HRESULT ExtractWave(DWORD dwId, CWaveObj** ppWaveObj);
	
	HRESULT ValidateOffset(DWORD dwOffset)
	{
		if(dwOffset < m_dwStartRiffChunk  || 
		   dwOffset > (m_dwStartRiffChunk + m_dwSizeRiffChunk - 1))
		{
			assert(FALSE); // We want to make it known if we get here
			return DMUS_E_INVALIDOFFSET;
		}
	
		return S_OK;            
	}

    STDMETHODIMP FindInstrument(DWORD dwPatch, CInstrument** ppDMDLInst);
    STDMETHODIMP AddInstrument(CInstrument* pDMDLInst);
    STDMETHODIMP RemoveInstrument(CInstrument* pDMDLInst);

private:
    CMemTrack                       m_MemTrack;
    IStream *                       m_pStream;              // Stream used for reading the collection and pulling waves out for downloading.    
    DWORD                           m_dwSizeRiffChunk;			// Size of DLS chunk, for validation.
    DWORD                           m_dwStartRiffChunk;         // Start of DLS chunk in file (could be embedded in larger file.)
    DWORD							m_dwFirstInsId;
	ULONG							m_dwNumPatchTableEntries;
	DMUS_PATCHENTRY*				m_pPatchTable;
	DWORD							m_dwFirstWaveId;				
	DWORD                           m_dwWaveTableBaseAddress;		// Used to hold the start of waves within DLS file
	DMUS_WAVEOFFSET*				m_pWaveOffsetTable;	
    DWORD                           m_dwWaveOffsetTableSize;    // Used to verify that references are within range (check for bad wave links in file.)
#ifdef DXAPI
    CCopyright*						m_pCopyright;
    WCHAR			                m_wszName[DMUS_MAX_NAME]; // Name of DLS collection.
	DLSVERSION						m_vVersion;
#endif
	GUID							m_guidObject;
	bool							m_bLoaded;
	long							m_cRef;
    CInstrumentList                 m_InstList;
    CRITICAL_SECTION                m_CDMCollCriticalSection;
    BOOL                            m_fCSInitialized;
};

#endif // #ifndef DMCOLLEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmcrchk.h ===
//
// dmcrchk.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.


#ifndef DMCRCHK_H
#define DMCRCHK_H

#define	DMC_FOUNDICOP (1 << 0)
#define	DMC_FOUNDINAM (1 << 1)
#define	DMC_LOADNAME  (1 << 2)

#include "dmusicip.h"

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

class CRiffParser;

class CCopyright
{
friend class CCollection;
friend class CInstrObj;
friend class CWaveObj;

public:
	CCopyright(bool bLoadName = false) : 
	m_byFlags(0),
	m_pwzName(NULL),
	m_pDMCopyright(NULL), 
	m_dwExtraChunkData(0){if(bLoadName){m_byFlags |= DMC_LOADNAME;};}

	~CCopyright(){Cleanup();}

	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* dwOffset);

	DWORD Size() {return CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT) + m_dwExtraChunkData);}
	DWORD Count()
	{
		// Return the number of Offset Table entries needed during a call to Write
		return 1;
	}

private:
	void Cleanup()
	{
		delete [] (BYTE *)m_pDMCopyright;
		delete [] m_pwzName;
	}

private:
	BYTE			m_byFlags;
	WCHAR*			m_pwzName;
	DMUS_COPYRIGHT*	m_pDMCopyright;
	DWORD			m_dwExtraChunkData;
};


#endif // #ifndef DMCRCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmdlinst.cpp ===
//
// dmdlinst.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//

#include "debug.h"
#include "dmusicc.h"
#include "dmdlinst.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CDownloadedInstrument

CDownloadedInstrument::~CDownloadedInstrument() 
{
    // If pDMDLInst->m_ppDownloadedBuffers == NULL we have been unloaded
    if(m_pPort && m_ppDownloadedBuffers != NULL)
    {
        Trace(2, "WARNING: DirectMusicDownloadedInstrument final release before unloaded!\n");
        m_cRef++; // This is ugly but it prevents a circular reference see Unload's implementation
        
        if (m_cDLRef >= 1)
        {
            // we need to remove ourselves from the port collection, or else we leave the port in an invalid state
            m_cDLRef = 1;

            if (FAILED(m_pPort->UnloadInstrument(this)))
            {
                TraceI(0, "~CDownloadedInstrument- UnloadInstrument failed\n");
            }
        }
    }

    if (m_ppDownloadedBuffers) delete [] m_ppDownloadedBuffers;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::QueryInterface

STDMETHODIMP CDownloadedInstrument::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownloadedInstrument::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicDownloadedInstrument)
    {
        *ppv = static_cast<IDirectMusicDownloadedInstrument*>(this);
    } 
    else if(iid == IID_IDirectMusicDownloadedInstrumentPrivate) 
    {
        *ppv = static_cast<IDirectMusicDownloadedInstrumentPrivate*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::AddRef

STDMETHODIMP_(ULONG) CDownloadedInstrument::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::Release

STDMETHODIMP_(ULONG) CDownloadedInstrument::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmcrchk.cpp ===
//
// dmcrck.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmcrchk.h"

//////////////////////////////////////////////////////////////////////
// Class CCopyright

//////////////////////////////////////////////////////////////////////
// CCopyright::Load

HRESULT CCopyright::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;
    RIFFIO ckNext;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case mmioFOURCC('I','C','O','P'):
			m_byFlags |= DMC_FOUNDICOP;
			// We want to make sure we only allocate extra bytes if the chunk size is 
			// greater then the DMUS_MIN_DATA_SIZE
			if(pParser->GetChunk()->cksize < DMUS_MIN_DATA_SIZE)
			{
				m_dwExtraChunkData = 0;
			}
			else
			{
				m_dwExtraChunkData = pParser->GetChunk()->cksize - DMUS_MIN_DATA_SIZE;
			}
			
			m_pDMCopyright  = (DMUS_COPYRIGHT*) 
				new BYTE[CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT) + m_dwExtraChunkData)];

			if(m_pDMCopyright)
			{
				hr = pParser->Read(m_pDMCopyright->byCopyright, pParser->GetChunk()->cksize);
				m_pDMCopyright->cbSize = pParser->GetChunk()->cksize;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			break;
		case mmioFOURCC('I','N','A','M'):
		    if(m_byFlags & DMC_LOADNAME)
		    {
			    m_pwzName = new WCHAR[DMUS_MAX_NAME];
			    if(m_pwzName)
			    {
				    char szName[DMUS_MAX_NAME];
				    hr = pParser->Read(szName,sizeof(szName));
				    if(SUCCEEDED(hr))
				    {
					    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_pwzName, DMUS_MAX_NAME);
				    }
			    }
			    else
			    {
				    hr = E_OUTOFMEMORY;
			    }
		    }
            m_byFlags |= DMC_FOUNDINAM;
		    break;
	    }
    }
    pParser->LeaveList();
	if(FAILED(hr))
	{
		Cleanup();
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCopyright::Write

HRESULT CCopyright::Write(void* pv, DWORD* dwCurOffset)
{
	// Argument validation
	assert(pv);
	assert(dwCurOffset);

	HRESULT hr = S_OK;

	CopyMemory(pv, (void *)m_pDMCopyright, Size());
	*dwCurOffset += Size();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmdlinst.h ===
//
// dmdlinst.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL

#ifndef DMDLINST_H
#define DMDLINST_H

#include "alist.h"

// IDirectMusicDownloadedInstrumentPrivate
//

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrumentPrivate 
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrumentPrivate, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicDownloadedInstrumentPrivate
    // No methods at this time
};

DEFINE_GUID(IID_IDirectMusicDownloadedInstrumentPrivate, 0x94feda0, 0xa3bb, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/*
@interface IDirectMusicDownloadedInstrument | 
<i IDirectMusicDownloadedInstrument> is used to keep 
track of a downloaded instrument. It should be
used exactly twice:

First, when an instrument is downloaded via a call to 
<om IDirectMusicPort::DownloadInstrument>, 
<i IDirectMusicDownloadedInstrument> is returned apon
successful download. 

Second, when unloading the instrument via a call to
<om IDirectMusicPort::UnloadInstrument>.

Once the instrument has been unloaded, 
<i IDirectMusicDownloadedInstrument> becomes invalid.

@base public | IUnknown

@xref <i IDirectMusicCollection>, <i IDirectMusicPort>,
<i IDirectMusicInstrument>, 
<om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPort::UnloadInstrument>

@ex Download the instrument, then unload it (fat lot of
good that will do us, but, hey, this is only a demo). 
Notice that
<p pDLInstrument> is never AddRef'd or Release'd. These are
automatically managed by the calls to Download and Unload. | 

    HRESULT myFickleDownload(   
        IDirectMusicInstrument* pInstrument,
        IDirectMusicPort *pPort,
        DWORD dwPatch)

    {
        HRESULT hr;
        IDirectMusicDownloadedInstrument * pDLInstrument;
        hr = pPort->DownloadInstrument(pInstrument, &pDLInstrument, NULL, 0);
        if (SUCCEEDED(hr))
        {
            pPort->UnloadInstrument(pDLInstrument);
        }
        return hr;
    }
*/


class CDownloadedInstrument : public IDirectMusicDownloadedInstrument,
    public IDirectMusicDownloadedInstrumentPrivate, public AListItem
{
friend class CDirectMusicPortDownload;

public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicDownloadedInstrument
    //
    // No methods at this time

private:
    friend class CDirectMusicPortDownload;

    CDownloadedInstrument() : m_MemTrack(DMTRACK_DLINSTRUMENT)
    {
        m_ppDownloadedBuffers = NULL;
        m_pPort = NULL;
        m_dwDLTotal = 0;
        m_dwDLSoFar = 0;
        m_cRef = 1;
        m_cDLRef = 0;
    }
    ~CDownloadedInstrument();

    CDownloadedInstrument* GetNext() {return (CDownloadedInstrument*)AListItem::GetNext();}

private:
    IDirectMusicDownload**   m_ppDownloadedBuffers;  // Array of downloaded buffers, starting with the instrument, 
                                                // and then one for each wave.
    IDirectMusicPort*        m_pPort;           // Port that this 
    DWORD                    m_dwDLTotal;       // Number of objects in the array pointed to by m_pDLList.
    DWORD                    m_dwDLSoFar;       // How many have been downloaded so far.
    long                     m_cRef;
    long                     m_cDLRef;
    CMemTrack                m_MemTrack;        // For debugging leaks.
};

class CDLInstrumentList : public AList
{
private:
    friend class CDirectMusicPortDownload;

    CDLInstrumentList(){}
    ~CDLInstrumentList() 
    {
        while (!IsEmpty())
        {
            CDownloadedInstrument* pDMDLInst = RemoveHead();
            if (pDMDLInst)
            {
                pDMDLInst->Release();
            }
        }
    }

    CDownloadedInstrument* GetHead(){return (CDownloadedInstrument*)AList::GetHead();}
    CDownloadedInstrument* GetItem(LONG lIndex){return (CDownloadedInstrument*)AList::GetItem(lIndex);}
    CDownloadedInstrument* RemoveHead(){return (CDownloadedInstrument*)AList::RemoveHead();}
    void Remove(CDownloadedInstrument* pDMDLInst){AList::Remove((AListItem*)pDMDLInst);}
    void AddTail(CDownloadedInstrument* pDMDLInst){AList::AddTail((AListItem*)pDMDLInst);}
};

#endif // #ifndef DMDLINST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmdload.cpp ===
//
// dmdload.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL 
//

#include "debug.h"
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "dmusicp.h"
#include "dmdload.h"
#include "validate.h"

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

#include <critsec.h>

static CRITICAL_SECTION gDownloadDataCounterCrSec;
static DWORD g_dwDownloadedData;

extern "C" void DMRPC_DownloadBuffer(){
    INITIALIZE_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
    DMusicRegisterPerformanceCounter( "DM downloaded instrument data (bytes)",
                          DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                          &g_dwDownloadedData );
}

extern "C" void DMURPC_DownloadBuffer(){
    DMusicUnregisterPerformanceCounter( "DM downloaded instrument data (bytes)");
}


#endif

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::CDownloadBuffer

CDownloadBuffer::CDownloadBuffer() : 
m_DLHandle(NULL),
m_dwDLId(0xFFFFFFFF),
m_pvBuffer(NULL),
m_dwSize(0),
m_lDownloadCount(0),
m_cRef(1)
{
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::~CDownloadBuffer

CDownloadBuffer::~CDownloadBuffer()
{
	// If assert fires we have not unloaded from a port; this is a problem
	// It should never happen since the download code will have a reference
	assert(m_lDownloadCount == 0);

	delete [] m_pvBuffer;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    if(m_dwSize){
        ENTER_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
        g_dwDownloadedData -= m_dwHeaderSize + m_dwSize;
        LEAVE_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
    }
#endif
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::QueryInterface

STDMETHODIMP CDownloadBuffer::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicDownload)
	{
        *ppv = static_cast<IDirectMusicDownload*>(this);
    } 
	else if(iid == IID_IDirectMusicDownloadPrivate)
	{
		*ppv = static_cast<IDirectMusicDownloadPrivate*>(this);
	}
	else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::AddRef

STDMETHODIMP_(ULONG) CDownloadBuffer::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::Release

STDMETHODIMP_(ULONG) CDownloadBuffer::Release()
{
    if(!InterlockedDecrement(&m_cRef))
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicDownload

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

/*

@method HRESULT | IDirectMusicDownload | GetBuffer | 
Returns a pointer to a buffer which contains
the data buffer managed by the <i IDirectMusicDownload>
inteface. Authoring tools 
that create instruments and download them
directly to the synthesizer use this method to access the
memory and write the instrument definition into it.  

@rdesc Returned codes include:

@flag S_OK | Success.
@flag DMUS_E_BUFFERNOTAVAILABLE | Buffer is not available, probably
because data has already been downloaded to DLS device. 
@flag E_POINTER | Invalid pointer.

@xref <i IDirectMusicDownload>, <i IDirectMusicPortDownload>, 
<om IDirectMusicPortDownload::GetBuffer>

*/

STDMETHODIMP CDownloadBuffer::GetBuffer(
    void** ppvBuffer,   // @parm Pointer to store address of data buffer in.
    DWORD* pdwSize)     // @parm Size of the returned buffer, in bytes.
{
	// Argument validation
	V_INAME(IDirectMusicDownload::GetBuffer);
	V_PTRPTR_WRITE(ppvBuffer);
	V_PTR_WRITE(pdwSize, DWORD);

	if(IsDownloaded() == S_OK)
	{
		return DMUS_E_BUFFERNOTAVAILABLE;
	}

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	*pdwSize = m_dwSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::SetBuffer

HRESULT CDownloadBuffer::SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize)
{
	// Assumption validation - Debug
	// We should never have a non-NULL pvBuffer and a size of zero
#ifdef DBG
	if(pvBuffer && dwSize == 0)
	{
		assert(false);
	}
#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    ENTER_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
    if(m_dwSize){
        g_dwDownloadedData -= (m_dwHeaderSize + m_dwSize);
    }
    g_dwDownloadedData += dwHeaderSize + dwSize;
    LEAVE_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
#endif

	m_pvBuffer = pvBuffer;
    m_dwHeaderSize = dwHeaderSize;
	m_dwSize = dwSize;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

HRESULT CDownloadBuffer::GetBuffer(void** ppvBuffer)
{
	// Argument validation - Debug
	assert(ppvBuffer);

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetHeader

HRESULT CDownloadBuffer::GetHeader(void** ppvHeader, DWORD *pdwHeaderSize)
{
	// Argument validation - Debug
	assert(ppvHeader);
    assert(pdwHeaderSize);

	*ppvHeader = m_pvBuffer;
    *pdwHeaderSize = m_dwHeaderSize;
    
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmdsclk.cpp ===
//
// DMDSClk.CPP
//
// Copyright (c) 1997-2000 Microsoft Corporation
//
// DirectSound buffer tweaked master clock
//
// 
//
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "debug.h"
#include "validate.h"
#include "resource.h"

class CDsClock : public IReferenceClock, public IDirectSoundSinkSync
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // IDirectSoundSinkSync
    //
    STDMETHODIMP SetClockOffset(LONGLONG llClockOffset);

    // Class
    //
    CDsClock();
    ~CDsClock();
    HRESULT Init(CMasterClock *pMasterClock);

private:
    long m_cRef;
    IReferenceClock         *m_pHardwareClock;
    LONGLONG                m_llOffset;
};



static HRESULT CreateDsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);

// AddDsClocks
//
//
HRESULT AddDsClocks(CMasterClock *pMasterClock)
{
    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce.cc);
    ce.cc.guidClock = GUID_DsClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = 0;
    ce.pfnGetInstance = CreateDsClock;

#ifdef XBOX
    wcscpy(ce.cc.wszDescription,L"DirectSound Clock");
#else
    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_DSOUNDCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }
#endif // ! XBOX

    return pMasterClock->AddClock(&ce);
}

static HRESULT CreateDsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    HRESULT hr;

    TraceI(3, "Creating Ds clock\n");
                          
    CDsClock *pClock = new CDsClock();

    hr = pClock->Init(pMasterClock);
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

CDsClock::CDsClock() :
    m_cRef(1),
    m_pHardwareClock(NULL),
    m_llOffset(0)
{
}

CDsClock::~CDsClock()
{
    RELEASE(m_pHardwareClock);
}

// CDsClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CDsClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IDirectSoundSinkSync)
    {
        *ppv = static_cast<IDirectSoundSinkSync*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CDsClock::AddRef
// 
STDMETHODIMP_(ULONG) CDsClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CDsClock::Release
//
STDMETHODIMP_(ULONG) CDsClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDsClock::Init
//
HRESULT CDsClock::Init(CMasterClock *pMasterClock)
{
    // Get the 'real' clock
    //
    return pMasterClock->CreateDefaultMasterClock(&m_pHardwareClock);
}

// CDsClock::SetClockOffset
//
STDMETHODIMP
CDsClock::SetClockOffset(LONGLONG llOffset)
{
    m_llOffset += llOffset;

    return S_OK;
}

STDMETHODIMP 
CDsClock::GetTime(REFERENCE_TIME *pTime)
{
    HRESULT hr;

    assert(m_pHardwareClock);

    hr = m_pHardwareClock->GetTime(pTime);

    if (SUCCEEDED(hr))
    {
        *pTime += m_llOffset;
    }

    return hr;
}

STDMETHODIMP 
CDsClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CDsClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CDsClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmextchk.cpp ===
//
// dmextchk.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
//
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmextchk.h"
#include "dls2.h"
#include "dmportdl.h"

//////////////////////////////////////////////////////////////////////
// Class CExtensionChunk

//////////////////////////////////////////////////////////////////////
// CExtensionChunk::Load

HRESULT CExtensionChunk::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

	DWORD cbRead = 0;
    RIFFIO *pChunk = pParser->GetChunk();

	if(pChunk->cksize < DMUS_MIN_DATA_SIZE)
	{
		m_dwExtraChunkData = 0;
	}
	else
	{
		m_dwExtraChunkData = pChunk->cksize - DMUS_MIN_DATA_SIZE;
	}

	m_pExtensionChunk  = (DMUS_EXTENSIONCHUNK*) 
		new BYTE[CHUNK_ALIGN(sizeof(DMUS_EXTENSIONCHUNK) + m_dwExtraChunkData)];

	if(m_pExtensionChunk)
	{
		m_pExtensionChunk->cbSize = pChunk->cksize;
		m_pExtensionChunk->ulNextExtCkIdx = 0; // We will set this member to its final value later
		m_pExtensionChunk->ExtCkID = pChunk->ckid;

		hr = pParser->Read(m_pExtensionChunk->byExtCk, pChunk->cksize);
	}
	else
	{
		hr = E_OUTOFMEMORY;	
	}

	if(FAILED(hr))
	{
		Cleanup();
	}
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CExtensionChunk::Write

HRESULT CExtensionChunk::Write(void* pv, DWORD* pdwCurOffset, DWORD dwIndexNextExtChk)
{
	// Argument validation - Debug
	assert(pv);
	assert(pdwCurOffset);

	HRESULT hr = S_OK;

	CopyMemory(pv, (void *)m_pExtensionChunk, Size());
	*pdwCurOffset += Size();
	((DMUS_EXTENSIONCHUNK*)pv)->ulNextExtCkIdx = dwIndexNextExtChk;

	return hr;
}

BOOL CStack::Push(long lData)

{
    if (m_dwIndex >= STACK_DEPTH) return FALSE;
    m_lStack[m_dwIndex++] = lData;
    return TRUE;
}

long CStack::Pop()

{
    if (m_dwIndex > 0)
    {
        return m_lStack[--m_dwIndex];
    }
    return 0;
}

BOOL CConditionChunk::Evaluate(CDirectMusicPortDownload *pPort)

{
    long lLength = m_dwLength;
    if ( lLength )
    {
        CStack  Stack;
        BOOL fResult = FALSE;
        BYTE *pData = m_bExpression;
        while (lLength > 0)
        {
            USHORT usToken;
            long lTemp;
            long lOpA, lOpB;
            GUID dlsid;
            memcpy(&usToken,pData,sizeof(USHORT));
            pData += sizeof(USHORT);
            lLength -= sizeof(USHORT);
            if ((usToken > 0) && (usToken < DLS_CDL_NOT))
            {
                lOpA = Stack.Pop();
                lOpB = Stack.Pop();
                switch (usToken)
                {
                case DLS_CDL_AND :
                    lTemp = lOpA & lOpB;
                    break;
                case DLS_CDL_OR :
                    lTemp = lOpA | lOpB;
                    break;
                case DLS_CDL_XOR :
                    lTemp = lOpA ^ lOpB;
                    break;
                case DLS_CDL_ADD :
                    lTemp = lOpA + lOpB;
                    break;
                case DLS_CDL_SUBTRACT :
                    lTemp = lOpA - lOpB;
                    break;
                case DLS_CDL_MULTIPLY :
                    lTemp = lOpA * lOpB;
                    break;
                case DLS_CDL_DIVIDE :
                    if (lOpB) lTemp = lOpA / lOpB;
                    else lTemp = 0;
                    break;
                case DLS_CDL_LOGICAL_AND :
                    lTemp = lOpA && lOpB;
                    break;
                case DLS_CDL_LOGICAL_OR :
                    lTemp = lOpA || lOpB;
                    break;
                case DLS_CDL_LT :
                    lTemp = lOpA < lOpB;
                    break;
                case DLS_CDL_LE :
                    lTemp = lOpA <= lOpB;
                    break;
                case DLS_CDL_GT :
                    lTemp = lOpA > lOpB;
                    break;
                case DLS_CDL_GE :
                    lTemp = lOpA >= lOpB;
                    break;
                case DLS_CDL_EQ :
                    lTemp = lOpA == lOpB;
                    break;
                }
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_NOT)
            {
                Stack.Push(!Stack.Pop());
            }
            else if (usToken == DLS_CDL_CONST)
            {
                memcpy(&lTemp,pData,sizeof(long));
                pData += sizeof(long);
                lLength -= sizeof(long);
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_QUERY)
            {
                memcpy(&dlsid,pData,sizeof(DLSID));
                pData += sizeof(DLSID);
                lLength -= sizeof(DLSID);
                pPort->QueryDLSFeature(dlsid,&lTemp);
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_QUERYSUPPORTED)
            {
                memcpy(&dlsid,pData,sizeof(DLSID));
                pData += sizeof(DLSID);
                lLength -= sizeof(DLSID);
                Stack.Push(SUCCEEDED(pPort->QueryDLSFeature(dlsid,&lTemp)));
            }
        }
        return (m_fOkayToDownload = (BOOL) Stack.Pop());
    }
    return (m_fOkayToDownload = TRUE);
}

HRESULT CConditionChunk::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

    if (m_bExpression)
    {
        delete m_bExpression;
        m_bExpression = NULL;
        m_dwLength = 0;
    }
    RIFFIO *pChunk = pParser->GetChunk();
    m_bExpression = new BYTE[pChunk->cksize];
    if (m_bExpression)
    {
        m_dwLength = pChunk->cksize;
		pParser->Read(m_bExpression, pChunk->cksize);
	}
	else
	{
		hr = E_OUTOFMEMORY;	
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmextchk.h ===
//
// dmextchk.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#ifndef DMEXTCHK_H
#define DMEXTCHK_H

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

class CRiffParser;
class CExtensionChunk : public AListItem
{
public:
	CExtensionChunk() : m_pExtensionChunk(NULL), m_dwExtraChunkData(0){}
	~CExtensionChunk() {Cleanup();}

	CExtensionChunk* GetNext(){return(CExtensionChunk*)AListItem::GetNext();}
	
	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* pdwOffset, DWORD dwIdxNextExtChk);
	
	DWORD Size(){return CHUNK_ALIGN(sizeof(DMUS_EXTENSIONCHUNK) + m_dwExtraChunkData);}
	DWORD Count()
	{
		// Return the number of Offset Table entries needed during a call to Write
		return 1;
	}

private:
	void Cleanup()
	{	
		delete [] (BYTE *)m_pExtensionChunk;
	} 

private:
	DMUS_EXTENSIONCHUNK* m_pExtensionChunk;
	DWORD m_dwExtraChunkData;
};

class CDirectMusicPortDownload;

class CExtensionChunkList : public AList
{
friend class CCollection;
friend class CInstrObj;
friend class CWaveObj;
friend class CRegion;
friend class CArticulation;

private:
	CExtensionChunkList(){}
	~CExtensionChunkList()
	{
		while(!IsEmpty())
		{
			CExtensionChunk* pExtensionChunk = RemoveHead();
			delete pExtensionChunk;
		}
	}

    CExtensionChunk* GetHead(){return (CExtensionChunk *)AList::GetHead();}
	CExtensionChunk* GetItem(LONG lIndex){return (CExtensionChunk*)AList::GetItem(lIndex);}
    CExtensionChunk* RemoveHead(){return(CExtensionChunk *)AList::RemoveHead();}
	void Remove(CExtensionChunk* pExtensionChunk){AList::Remove((AListItem *)pExtensionChunk);}
	void AddTail(CExtensionChunk* pExtensionChunk){AList::AddTail((AListItem *)pExtensionChunk);}
};


#define STACK_DEPTH 20

class CStack {
public:
    CStack() { m_dwIndex = 0; }
    BOOL        Push(long lData);
    long        Pop();
private:
    DWORD       m_dwIndex;
    long        m_lStack[STACK_DEPTH];
};

class CConditionChunk {
public:
                CConditionChunk()
                {
                    m_bExpression = NULL;
                    m_dwLength = 0;
                    m_fOkayToDownload = TRUE;
                }
                ~CConditionChunk()
                {
                    if (m_bExpression) delete m_bExpression;
                }
    BOOL        Evaluate(CDirectMusicPortDownload *pPort);
    HRESULT     Load(CRiffParser *pParser);
    BOOL        HasChunk() 
                {
                    return m_dwLength;
                }
    BOOL        m_fOkayToDownload; // Result of evaluation.
private:
    BYTE *      m_bExpression;  // Expression in binary form, copied from file.
    DWORD       m_dwLength;     // Length of binary expression chunk.
};


#endif // #ifndef DMEXTCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmeport.h ===
//
// dmeport.h
//
// Emulation for MME drivers on NT
//
// Copyright (c) 1997-2000 Microsoft Corporation
// 
#ifndef _DMEPORT_
#define _DMEPORT_

#include "..\shared\dmusiccp.h"

#define SYSEX_SIZE            4096
#define SYSEX_BUFFERS         8

typedef HRESULT (*PORTENUMCB)(
    LPVOID pInstance,          // @parm Callback instance data
    DMUS_PORTCAPS &dmpc,                              
    PORTTYPE pt,                              
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The node ID of the device's synth node (unused for legacy)
    HKEY hkPortsRoot);         // @parm Where port information is stored in the registry


extern HRESULT EnumLegacyDevices(CDirectMusic *pDM, PORTENUMCB pCB);
extern HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    DMUS_PORTPARAMS8 *pPortParams,
    IDirectMusicPort8 **pPort);
    
extern HRESULT MMRESULTToHRESULT(
    MMRESULT mmr);

struct QUEUED_SYSEX_EVENT : public QUEUED_EVENT
{
    BYTE            m_abRest[sizeof(MIDIHDR) + SYSEX_SIZE - sizeof(DWORD)];
};

#define EVENT_F_MIDIHDR 0x00000001  // This event starts with a MIDIHDR
    

#include "tpool.h"

#define THREAD_KILL_TIMEOUT         5000
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#define MIDI_CHANNELS               16

// 10 ms in 100ns units
//
#define FIXED_LEGACY_LATENCY_OFFSET (10L * 10L * 1000L)

struct DMQUEUEDEVENT
{
    DMQUEUEDEVENT           *m_pNext;
    DMEVENT                 m_event;
    LPBYTE                  m_pbEvent;
};

class CEmulateLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CEmulateLatencyClock(IReferenceClock *pMasterClock);
    ~CEmulateLatencyClock();

    void Close();

private:
    long m_cRef;
    IReferenceClock *m_pMasterClock;
};

// Struct for holding a property item supported by the synth
//

class CDirectMusicEmulatePort;

typedef HRESULT (CDirectMusicEmulatePort::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};


class CDirectMusicEmulatePort : 
    public IDirectMusicPort8, 
    public IDirectMusicThru,
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument*,
                                            IDirectMusicDownloadedInstrument**,
                                            DMUS_NOTERANGE*,
                                            DWORD);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument*);
    
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwNumChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwNumChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
        
    // IDirectMusicThru
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);
    
    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave    
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        

    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();

    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoicePosition(
        DWORD dwVoice[], 
        DWORD cbVoice,
        SAMPLE_POSITION dwVoicePos[]);
         
    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);
         
    // Class
    //
    CDirectMusicEmulatePort(PORTENTRY *pPE, CDirectMusic *pDM);
    virtual ~CDirectMusicEmulatePort();
    virtual HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    virtual HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer) PURE;

    
   

private:
    long                    m_cRef;
    IDirectMusicPortNotify  *m_pNotify;
    DMUS_PORTCAPS           m_dmpc;
    long                    m_lActivated;    

    CEmulateLatencyClock    *m_pLatencyClock;
    
protected:    
    CDirectMusic            *m_pDM;
    UINT                    m_id;
    IReferenceClock         *m_pMasterClock;

private:
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    
private:
    HRESULT InitializeClock();
    
protected:
    virtual HRESULT ActivateLegacyDevice(BOOL fActivate) PURE;
};

class CDirectMusicEmulateInPort : public CDirectMusicEmulatePort
{
    friend static VOID CALLBACK midiInProc(
        HMIDIIN             hMidiIn, 
        UINT                wMsg, 
        DWORD_PTR           dwInstance, 
        DWORD_PTR           dwParam1, 
        DWORD_PTR           dwParam2);

public:
    // Class
    //
    CDirectMusicEmulateInPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulateInPort();

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    DWORD InputWorker();
    STDMETHODIMP Close();
    HRESULT ActivateLegacyDevice(BOOL fActivate);
    
    // IDirectMusicPort
    //    
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);

    // IDirectMusicThru
    //
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);

private:
    HANDLE                  m_hAppEvent;

    EVENT_POOL              m_FreeEvents;        
    EVENT_QUEUE             m_ReadEvents;

    IDirectMusicBuffer      *m_pThruBuffer;
    LPDMUS_THRU_CHANNEL     m_pThruMap;

    
    CRITICAL_SECTION        m_csEventQueues;
    BOOL                    m_fCSInitialized;

    HMIDIIN                 m_hmi;
    REFERENCE_TIME          m_rtStart;

    BOOL                    m_fFlushing;
    LONG                    m_lPendingSysExBuffers;
    QUEUED_SYSEX_EVENT      m_SysExBuffers[SYSEX_BUFFERS];

private:
    HRESULT PostSysExBuffers();
    HRESULT FlushSysExBuffers();
    void Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    BOOL RecordShortEvent(DWORD_PTR dwMessage,  REFERENCE_TIME rtTime);
    BOOL RecordSysEx(DWORD_PTR dwMessage,  REFERENCE_TIME rtTime);
    void QueueEvent(QUEUED_EVENT *pEvent);
    void ThruEvent(DMEVENT *pEvent);
};

class CDirectMusicEmulateOutPort : public CDirectMusicEmulatePort
{
    friend static VOID CALLBACK midiOutProc(
        HMIDIOUT            hMidiOut, 
        UINT                wMsg, 
        DWORD_PTR           dwInstance, 
        DWORD_PTR           dwParam1, 
        DWORD_PTR           dwParam2);

    friend static VOID CALLBACK timerProc(
        UINT                    uTimerID, 
        UINT                    uMsg, 
        DWORD_PTR               dwUser, 
        DWORD_PTR               dw1, 
        DWORD_PTR               dw2);

public:
    CDirectMusicEmulateOutPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulateOutPort();

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    STDMETHODIMP Close();
    HRESULT ActivateLegacyDevice(BOOL fActivate);
    

private:
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    void Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    void Timer();
    void SetNextTimer();
    
private:
    HMIDIOUT                m_hmo;
    CRITICAL_SECTION        m_csPlayQueue;
    DMQUEUEDEVENT          *m_pPlayQueue;
    CPool<DMQUEUEDEVENT>    m_poolEvents;
    LONG                    m_lTimerId;
    BOOL                    m_fClosing;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmdll.cpp ===
//
// dmdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Dll entry points as well IDirectMusicFactory & 
// IDirectMusicCollectionFactory implementations
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "debug.h"
#include "debug.h"

#include "oledll.h"

#include "dmusicp.h"
#include "dmcollec.h"
#include "dminstru.h"
#include "dswave.h"
#include "dmvoice.h"
#include "verinfo.h"
#include "..\shared\xcreate.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Version information for our class
//
#ifndef XBOX

TCHAR g_szFriendlyName[]    = TEXT("DirectMusic");
TCHAR g_szVerIndProgID[]    = TEXT("Microsoft.DirectMusic");
TCHAR g_szProgID[]          = TEXT("Microsoft.DirectMusic.1");

TCHAR g_szCollFriendlyName[]    = TEXT("DirectMusicCollection");
TCHAR g_szCollVerIndProgID[]    = TEXT("Microsoft.DirectMusicCollection");
TCHAR g_szCollProgID[]          = TEXT("Microsoft.DirectMusicCollection.1");

#endif // ! XBOX

// Thunk helper dll
const char g_szDM32[]      = "DMusic32.dll";
const char g_szKsUser[]    = "KsUser.dll";

#ifndef XBOX

// Dll's hModule
//
HMODULE g_hModule = NULL;
HMODULE g_hModuleDM32 = NULL;
HMODULE g_hModuleKsUser = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

#else // XBOX

extern long g_cLock;
long g_cComponent = 0;

#endif // !XBOX

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::QueryInterface

HRESULT __stdcall
CDirectMusicFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::AddRef

ULONG __stdcall
CDirectMusicFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::Release

ULONG __stdcall
CDirectMusicFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::CreateInstance

HRESULT __stdcall
CDirectMusicFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

//
// Removed since we depend on dsound timebomb
//
#if 0
	#pragma message( "Remove time bomb for final!" )
    SYSTEMTIME  st;

    GetSystemTime( &st );

   if ((st.wYear > DX_EXPIRE_YEAR) || 
      ((st.wYear == DX_EXPIRE_YEAR) && (st.wMonth > DX_EXPIRE_MONTH)) ||
      ((st.wYear == DX_EXPIRE_YEAR) && (st.wMonth == DX_EXPIRE_MONTH) && (st.wDay > DX_EXPIRE_DAY)))
   {
        if (0 == MessageBox(NULL, DX_EXPIRE_TEXT,
                            "Microsoft DirectMusic", MB_OK))
        {
            Trace(-1, DX_EXPIRE_TEXT "\n");
            *ppv = NULL;
        }

        return E_FAIL;
    }
#endif

    CDirectMusic *pDM = new CDirectMusic;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDM->Init();
    if (!SUCCEEDED(hr)) {
        delete pDM;
        return hr;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::LockServer

HRESULT __stdcall
CDirectMusicFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicCreate

STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC )
{
    CDirectMusicFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMC);
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::QueryInterface

STDMETHODIMP CDirectMusicCollectionFactory::QueryInterface(const IID &iid,
														   void **ppv)
{
    V_INAME(IDirectMusicCollectionFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IClassFactory) 
	{
        *ppv = static_cast<IClassFactory*>(this);
    } 
	else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::AddRef

STDMETHODIMP_(ULONG) CDirectMusicCollectionFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::Release

STDMETHODIMP_(ULONG) CDirectMusicCollectionFactory::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::CreateInstance

STDMETHODIMP CDirectMusicCollectionFactory::CreateInstance(IUnknown* pUnknownOuter,
														   const IID& iid,
														   void** ppv)
{
    // Argument validation - Debug
    assert(pUnknownOuter == NULL);

	if(pUnknownOuter) 
    {
         return CLASS_E_NOAGGREGATION;
    }

    CCollection *pDMC;
    try
    {
        pDMC = new CCollection;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if(pDMC == NULL) 
	{
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pDMC->QueryInterface(iid, ppv);
    
    pDMC->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::LockServer

STDMETHODIMP CDirectMusicCollectionFactory::LockServer(BOOL bLock)
{
    if(bLock) 
	{
        InterlockedIncrement(&g_cLock);
    } 
	else 
	{
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// DirectMusicCollectionCreate

STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC )
{
    CDirectMusicCollectionFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMC);
}


//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

#ifndef XBOX

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

#endif

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

#ifndef XBOX

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusic)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicCollection) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicCollectionFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

#endif

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer
#ifndef XBOX

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusic,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);

    UnregisterServer(CLSID_DirectMusicCollection,
                     g_szCollFriendlyName,
                     g_szCollVerIndProgID,
                     g_szCollProgID);

    return S_OK;
}
#endif // ! XBOX

//////////////////////////////////////////////////////////////////////
// DllRegisterServer
#ifndef XBOX

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusic,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicCollection,
				   g_szCollFriendlyName,
				   g_szCollVerIndProgID,
				   g_szCollProgID);

	return S_OK;
}

#endif // ! XBOX

#ifndef XBOX

//////////////////////////////////////////////////////////////////////
// LoadDmusic32 - Load if not already loaded
BOOL LoadDmusic32()
{
    if (g_hModuleDM32)
    {
        return TRUE;
    }

    g_hModuleDM32 = (HMODULE)LoadLibrary(g_szDM32);
    if (NULL == g_hModuleDM32)
    {
        Trace(-1, "Could not LoadLibrary Dmusic32.dll. WinMM devices will not be enumerated.\n");
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// LoadKsUser - Load if not already loaded
BOOL LoadKsUser()
{
    if (g_hModuleKsUser)
    {
        return TRUE;
    }

    g_hModuleKsUser = (HMODULE)LoadLibrary(g_szKsUser);
    if (NULL == g_hModuleKsUser)
    {
        Trace(-1, "Could not LoadLibrary KSUser.dll. WDM devices will not be enumerated.\n");
        return FALSE;
    }

    return TRUE;
}

#endif // ! XBOX

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifndef XBOX

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    static int nReferenceCount = 0;
    static BOOL fCSInitialized = FALSE;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

                osvi.dwOSVersionInfoSize = sizeof(osvi);
                GetVersionEx(&osvi);
                if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                {
                    TraceI(0, "Running on Win9x\n");
                    g_fFlags |= DMI_F_WIN9X;
                }

                try 
                {
				    InitializeCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
                    InitializeCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
                    InitializeCriticalSection(&CDirectMusicVoice::m_csVST);
                }
                catch( ... )
                {
                    return FALSE;
                }
                fCSInitialized = TRUE;
            }

            break;


        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                if (fCSInitialized)
                {
				    DeleteCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
                    DeleteCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
                    DeleteCriticalSection(&CDirectMusicVoice::m_csVST);
                    fCSInitialized = FALSE;
                }

                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}

#else

// We're a library, so we initialize ourselves using the C++ language feature that
// initializes statically allocated classes.

class DMusicInit {
public:
	DMusicInit(){
		InitializeCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
		InitializeCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
		InitializeCriticalSection(&CDirectMusicVoice::m_csVST);
	}
};

DMusicInit gDMusicInit;

#endif // !XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmdload.h ===
//
// dmdload.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
// @doc EXTERNAL
//

#include "..\shared\validate.h"

#ifndef DMDLOAD_H
#define DMDLOAD_H

/*
@interface IDirectMusicDownload | 
The <i IDirectMusicDownload> interface represents
a contiguous memory chunk, used for downloading to a
DLS synth port. 

The <i IDirectMusicDownload> interface and its contained
memory chunk are always created with a call to
<om IDirectMusicPortDownload::AllocateBuffer>.
The memory can then be accessed via the one method
that <i IDirectMusicDownload> provides: 
<om IDirectMusicDownload::GetBuffer>.

@base public | IUnknown

@meth HRESULT | GetBuffer | Returns the memory segment and its size.

@xref <i IDirectMusic>, <i IDirectMusicPortDownload>,
<om IDirectMusicPortDownload::AllocateBuffer>

*/

// IDirectMusicDownloadPrivate
//
#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadPrivate 
DECLARE_INTERFACE_(IDirectMusicDownloadPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectMusicDownloadPrivate
    STDMETHOD(SetBuffer)			(THIS_ void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize) PURE;
	STDMETHOD(GetBuffer)			(THIS_ void** ppvBuffer) PURE;
    STDMETHOD(GetHeader)            (THIS_ void** ppvHeader, DWORD* dwHeaderSize) PURE;
};

DEFINE_GUID(IID_IDirectMusicDownloadPrivate, 0x19e55e60, 0xa146, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

class CDownloadBuffer : public IDirectMusicDownload, public IDirectMusicDownloadPrivate, public AListItem
{
friend class CDirectMusicPort;
friend class CDirectMusicSynthPort;
friend class CDirectMusicPortDownload;
friend class CDLBufferList;
friend HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData);
friend void writewave(IDirectMusicDownload* pDMDownload);
friend void writeinstrument(IDirectMusicDownload* pDMDownload);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicDownload
    STDMETHODIMP GetBuffer(void** ppvBuffer, DWORD* pdwSize);

	// IDirectMusicDownloadPrivate
    STDMETHODIMP SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize);
	STDMETHODIMP GetBuffer(void** ppvBuffer);
    STDMETHODIMP GetHeader(void** ppvHeader, DWORD *pdwHeaderSize);

private:	
    // Class
    CDownloadBuffer();
    ~CDownloadBuffer();

	CDownloadBuffer* GetNext(){return(CDownloadBuffer*)AListItem::GetNext();}

	long IncDownloadCount()
	{
		// Should never be less than zero
		assert(m_lDownloadCount >= 0);
		
		InterlockedIncrement(&m_lDownloadCount);
		
		return(m_lDownloadCount);
	}
	
	long DecDownloadCount()
	{
		InterlockedDecrement(&m_lDownloadCount);
		
		// Should never be less than zero		
		assert(m_lDownloadCount >= 0);
		
		return(m_lDownloadCount);
	}
	
	HRESULT IsDownloaded()
	{
		// Should never be less than zero
		assert(m_lDownloadCount >= 0);
		
		return(m_DLHandle ? S_OK : S_FALSE);
	}

private:
	HANDLE					m_DLHandle;
	DWORD					m_dwDLId;
	void*					m_pvBuffer;
    DWORD                   m_dwHeaderSize;
	DWORD					m_dwSize;
	long					m_lDownloadCount;
	long					m_cRef;
};

class CDLBufferList : public AList
{
friend class CDirectMusicPortDownload;
friend class CDownloadedInstrument;
friend class CDirectMusicSynthPort;
friend class CDirectMusicPort;

private:
	CDLBufferList(){}
	~CDLBufferList()
	{
		while(!IsEmpty())
		{
			CDownloadBuffer* pDownload = RemoveHead();
			delete pDownload;
		}
	}

    CDownloadBuffer* GetHead(){return (CDownloadBuffer *)AList::GetHead();}
	CDownloadBuffer* GetItem(LONG lIndex){return (CDownloadBuffer*)AList::GetItem(lIndex);}
    CDownloadBuffer* RemoveHead(){return(CDownloadBuffer *)AList::RemoveHead();}
	void Remove(CDownloadBuffer* pDownload){AList::Remove((AListItem *)pDownload);}
	void AddTail(CDownloadBuffer* pDownload){AList::AddTail((AListItem *)pDownload);}
};

#endif // #ifndef DMDLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dminsobj.h ===
//
// dminsobj.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//

#ifndef DMINSOBJ_H
#define DMINSOBJ_H

#include "dmregion.h"
#include "dmextchk.h"
#include "dmcount.h"

class CCopyright;
class CArticulation;
class CRiffParser;

class CInstrObj : public AListItem      
{       
friend class CCollection;
friend class CInstrument;
friend class CDirectMusicPortDownload;

private:
	CInstrObj();
	~CInstrObj();

	CInstrObj* GetNext(){return (CInstrObj*)AListItem::GetNext();}
	HRESULT Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent);
	HRESULT Size(DWORD* pdwSize);
	HRESULT Write(void* pvoid);
#ifdef DXAPI
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2);
    void CheckForConditionals();
#endif
	void Cleanup();
	HRESULT BuildRegionList(CRiffParser *pParser);
	HRESULT ExtractRegion(CRiffParser *pParser, BOOL fDLS1);
	HRESULT BuildWaveIDList();
	HRESULT	GetWaveCount(DWORD* pdwCount);
	HRESULT GetWaveIDs(DWORD* pdwWaveIds);
	HRESULT FixupWaveRefs();

private:
//	CRITICAL_SECTION		m_DMInsCriticalSection;
    BOOL                    m_fCSInitialized;
	DWORD                   m_dwPatch;
	CRegionList				m_RegionList;
//	DWORD					m_dwCountRegion;
	CArticulationList		m_ArticulationList;
#ifdef DXAPI
	CCopyright*				m_pCopyright;
	CExtensionChunkList		m_ExtensionChunkList;
	DWORD					m_dwCountExtChk;
#endif
    DWORD					m_dwId;
	
	// Weak reference since we live in a CInstrument which has 
	// a reference to the collection
	CCollection*	        m_pParent;										

	CWaveIDList				m_WaveIDList;   // List of WaveIDs, one for each wave that this instrument references.
	DWORD                   m_dwNumOffsetTableEntries;
	DWORD					m_dwSize;       // Size required to download instrument to current port.
#ifdef DXAPI
    CDirectMusicPortDownload * m_pPort;     // Used to track which port condition chunks, etc, are valid for.
    BOOL                    m_fNewFormat;   // Indicates the current port handles INSTRUMENT2 chunks. 
    BOOL                    m_fHasConditionals; // Indicates the instrument has conditional chunks.
#endif
#ifdef DBG
	bool					m_bLoaded;
#endif
};      

#endif // #ifndef DMINSOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dminsobj.cpp ===
//
// dminsobj.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "dmart.h"
#include "debug.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmcrchk.h"
#include "dmportdl.h"
#include "dminsobj.h"
#include "dls2.h"


//////////////////////////////////////////////////////////////////////
// Class CInstrObj

//////////////////////////////////////////////////////////////////////
// CInstrObj::CInstrObj

CInstrObj::CInstrObj() 


{
    m_fCSInitialized = FALSE;
//    InitializeCriticalSection(&m_DMInsCriticalSection);
    m_fCSInitialized = TRUE;

    m_dwPatch = 0;
#ifdef DXAPI
    m_fHasConditionals = TRUE;  // Set to true just in case.
    m_pCopyright = NULL;
    m_dwCountExtChk = 0;
    m_pPort = NULL;
#endif
    m_dwId = 0;
    m_pParent = NULL;
    m_dwNumOffsetTableEntries = 0;
    m_dwSize = 0;
#ifdef DBG
    m_bLoaded = false;
#endif
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::~CInstrObj

CInstrObj::~CInstrObj()
{
    if (m_fCSInitialized)
    {
    	Cleanup();
//    	DeleteCriticalSection(&m_DMInsCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Load

HRESULT CInstrObj::Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent)
{
	if(dwId >= CDirectMusicPortDownload::sNextDLId)
	{
		assert(FALSE); // We want to make it known if we get here
		return DMUS_E_INVALID_DOWNLOADID;
	}

	HRESULT hr = S_OK;

	// Argument validation - Debug
	assert(pParent);

	RIFFIO ckNext;
//	EnterCriticalSection(&m_DMInsCriticalSection);
    pParser->EnterList(&ckNext);
	m_dwId = dwId;
	m_pParent = pParent; // We reference no need to Addref
    BOOL fDLS1;
    while (pParser->NextChunk(&hr))
	{
        fDLS1 = FALSE;
		switch(ckNext.ckid)
		{
			case FOURCC_DLID:
				break;

			case FOURCC_INSH :
			{	
				INSTHEADER instHeader;
				hr = pParser->Read(&instHeader,sizeof(INSTHEADER));
				m_dwPatch = instHeader.Locale.ulInstrument;
				m_dwPatch |= (instHeader.Locale.ulBank) << 8;
				m_dwPatch |= (instHeader.Locale.ulBank & 0x80000000);
				break;
			}
			case FOURCC_LIST :
				switch (ckNext.fccType)
				{
					case FOURCC_LRGN :
						hr = BuildRegionList(pParser);
						break;
#ifdef DXAPI                
					case mmioFOURCC('I','N','F','O') :
						m_pCopyright = new CCopyright   ;
						if(m_pCopyright)
						{
							hr = m_pCopyright->Load(pParser);
							if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0)
							{
								delete m_pCopyright;
								m_pCopyright = NULL;
							}
						}
						else
						{
							hr =  E_OUTOFMEMORY;
						}
						break;
#endif
					case FOURCC_LART :
                        fDLS1 = TRUE;
                    case FOURCC_LAR2 :
                        CArticulation *pArticulation;
                                               
                        try
                        {
                            pArticulation = new CArticulation;
                        }
                        catch( ... )
                        {
                            pArticulation = NULL;
                        }

						if(pArticulation)
						{
                            pArticulation->m_fDLS1 = fDLS1;
							hr = pArticulation->Load(pParser);
                            m_ArticulationList.AddHead(pArticulation); 
                            // Note: If the load failed, this will get deleted in the destructor of the instrument.
						}
						else
						{
							hr =  E_OUTOFMEMORY;
						}
						
						break;

					default:
#ifdef DXAPI
						// If we get here we have an unknown chunk
						CExtensionChunk* pExtensionChunk = new CExtensionChunk;
						if(pExtensionChunk)
						{
							hr = pExtensionChunk->Load(pParser);
                            m_ExtensionChunkList.AddHead(pExtensionChunk);
							m_dwCountExtChk++;
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
#endif
						break;
				}
				break;

			default:
				// If we get here we have an unknown chunk
#ifdef DXAPI
                CExtensionChunk* pExtensionChunk = new CExtensionChunk;
				if(pExtensionChunk)
				{
					hr = pExtensionChunk->Load(pParser);
					m_ExtensionChunkList.AddHead(pExtensionChunk);
					m_dwCountExtChk++;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
#endif
				break;
		}
		
	}
    pParser->LeaveList();
	
	if(FAILED(hr))
	{
		Cleanup();
	}

#ifdef DBG
	if(SUCCEEDED(hr))
	{
		m_bLoaded = true;
	}
#endif
#ifdef DXAPI	
    CheckForConditionals();
#endif
//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Cleanup

void CInstrObj::Cleanup()
{
//	EnterCriticalSection(&m_DMInsCriticalSection);

	while(!m_RegionList.IsEmpty())
	{
		CRegion* pRegion = m_RegionList.RemoveHead();
		delete pRegion;
	}

    while(!m_ArticulationList.IsEmpty())
	{
		CArticulation* pArticulation = m_ArticulationList.RemoveHead();
		delete pArticulation;
	}
	
#ifdef DXAPI
	delete m_pCopyright;
	m_pCopyright = NULL;
	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		m_dwCountExtChk--;
		delete pExtChk;
	}

	// If asserts fire we did not cleanup all of our regions and extension chunks
	assert(!m_dwCountExtChk);
#endif
	// Weak reference since we live in a CInstrument which has 
	// a strong reference to the collection
	m_pParent = NULL;
	
	while(!m_WaveIDList.IsEmpty())
	{
		CWaveID* pWaveID = m_WaveIDList.RemoveHead();
		delete pWaveID;
	}

#ifdef DBG
	m_bLoaded = false;
#endif

//	LeaveCriticalSection(&m_DMInsCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::BuildRegionList

HRESULT CInstrObj::BuildRegionList(CRiffParser *pParser)
{
	HRESULT	hr = S_OK;
	
	RIFFIO ckNext;    
    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
    {
		if (ckNext.ckid == FOURCC_LIST)
        {
            if (ckNext.fccType == FOURCC_RGN)
            {
				hr = ExtractRegion(pParser, TRUE);
            }
            else if (ckNext.fccType == FOURCC_RGN2)
            {
                hr = ExtractRegion(pParser, FALSE);
			}
		}
	}
    pParser->LeaveList();

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::ExtractRegion

HRESULT CInstrObj::ExtractRegion(CRiffParser *pParser, BOOL fDLS1)
{
	HRESULT hr = S_OK;
	
//	EnterCriticalSection(&m_DMInsCriticalSection);

	CRegion* pRegion;
	
	try
	{
	    pRegion = new CRegion;
    }
    catch( ... )
    {
        pRegion = NULL;
    }

	if(pRegion)
	{
        pRegion->m_fDLS1 = fDLS1;
		hr = pRegion->Load(pParser);

		if(SUCCEEDED(hr))
		{
			m_RegionList.AddHead(pRegion);				
		}
		else
		{
			delete pRegion;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	} 

//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::BuildWaveIDList

HRESULT CInstrObj::BuildWaveIDList()
{
	// Assumption validation - Debug
#ifdef DBG
	assert(m_bLoaded);
#endif

	HRESULT hr = S_OK;
    CWaveIDList TempList;
    CWaveID* pWaveID;

//	EnterCriticalSection(&m_DMInsCriticalSection);

	CRegion* pRegion = m_RegionList.GetHead();
	for(; pRegion && SUCCEEDED(hr); pRegion = pRegion->GetNext())
	{
		bool bFound = false;
		DWORD dwId = pRegion->GetWaveId();
		pWaveID = TempList.GetHead();
		for(; pWaveID && !bFound; pWaveID = pWaveID->GetNext())
		{
			if(dwId == pWaveID->m_dwId)
			{
				bFound = true;
			}
		}

		if(!bFound)
		{
			pWaveID = new CWaveID(dwId);
			if(pWaveID)
			{
				TempList.AddHead(pWaveID);
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

	if(FAILED(hr))
	{
		while(!m_WaveIDList.IsEmpty())
		{
			CWaveID* pWaveID = TempList.RemoveHead();
			delete pWaveID;
		}
	}

    // Reverse list so it is in same order as region list.
    
    while (pWaveID = TempList.RemoveHead())
    {
        m_WaveIDList.AddHead(pWaveID);
    }

//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::GetWaveCount

HRESULT CInstrObj::GetWaveCount(DWORD* pdwCount)
{
	// Assumption validation - Debug
#ifdef DBG
	assert(m_bLoaded);
#endif	
	assert(pdwCount);

	HRESULT hr = S_OK;

//	EnterCriticalSection(&m_DMInsCriticalSection);
	
	if(m_WaveIDList.IsEmpty())
	{
		hr = BuildWaveIDList();
	}
	
	*pdwCount = m_WaveIDList.GetCount();

//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::GetWaveIDs

HRESULT CInstrObj::GetWaveIDs(DWORD* pdwWaveIds)
{
	// Assumption validation - Debug
	assert(pdwWaveIds);

#ifdef DBG
	assert(m_bLoaded);
#endif

//	EnterCriticalSection(&m_DMInsCriticalSection);

	HRESULT hr = S_OK;

	if(m_WaveIDList.IsEmpty())
	{
		hr = BuildWaveIDList();
	}
	
	if(FAILED(hr))
	{
//		LeaveCriticalSection(&m_DMInsCriticalSection);
		return hr;
	}

	CWaveID* pWaveID = m_WaveIDList.GetHead();
	for(int i = 0; pWaveID; pWaveID = pWaveID->GetNext(), i++)
	{
		pdwWaveIds[i] = pWaveID->m_dwId;
	}

//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return hr;
}
#ifdef DXAPI
void CInstrObj::SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2)

{
    if (m_pPort != pPort) // Make sure we have our settings for the current port.
    {
        m_dwSize = 0;     // Force the size to be recomputed (since conditional chunks can cause a change in size.)
        m_pPort = pPort;
        BOOL fSupportsDLS2 = FALSE;
        pPort->QueryDLSFeature(GUID_DMUS_PROP_INSTRUMENT2,(long *) &m_fNewFormat);
        if (m_fNewFormat)
        {
            pPort->QueryDLSFeature(GUID_DMUS_PROP_DLS2,(long *) &fSupportsDLS2);
            fSupportsDLS2 = fSupportsDLS2 && fAllowDLS2;
        }
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        for (;pArticulation;pArticulation = pArticulation->GetNext())
        {
            pArticulation->SetPort(pPort,m_fNewFormat,fSupportsDLS2);
		}
		CRegion* pRegion = m_RegionList.GetHead();
		for(; pRegion; pRegion = pRegion->GetNext())
		{
			pRegion->SetPort(pPort,m_fNewFormat,fSupportsDLS2);
        }
    }
}

void CInstrObj::CheckForConditionals()

{
    m_fHasConditionals = FALSE;
	CArticulation *pArticulation = m_ArticulationList.GetHead();
    for (;pArticulation;pArticulation = pArticulation->GetNext())
    {
        m_fHasConditionals = m_fHasConditionals || pArticulation->CheckForConditionals();
	}
	CRegion* pRegion = m_RegionList.GetHead();
	for(; pRegion; pRegion = pRegion->GetNext())
	{
		m_fHasConditionals = m_fHasConditionals || pRegion->CheckForConditionals();
	}
}
#endif

//////////////////////////////////////////////////////////////////////
// CInstrObj::Size
#ifdef DXAPI
HRESULT CInstrObj::Size(DWORD* pdwSize)
{
	// Assumption validation - Debug
	assert(pdwSize);
#ifdef DBG
	assert(m_bLoaded);
#endif

	// If we have already calculated the size we do not need to do it again
	if(m_dwSize)
	{
		*pdwSize = m_dwSize;
		return S_OK;
	}
	
	HRESULT hr = S_OK;
	
	m_dwSize = 0;
	m_dwNumOffsetTableEntries = 0;

	DWORD dwCountExtChk = 0;

	// Calculate the space needed for DMUS_DOWNLOADINFO 
	m_dwSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	// Calculate the space needed for DMUS_INSTRUMENT
	m_dwSize += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
	m_dwNumOffsetTableEntries++;

	// Calculate the space needed for Instrument's extension chunks
    CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		m_dwSize += pExtChk->Size();
		m_dwNumOffsetTableEntries += pExtChk->Count();
		dwCountExtChk++;
	}
	
	// We want to validate the number of extension chunks
	if(m_dwCountExtChk == dwCountExtChk)
	{
		// Calculate the space needed for Instrument's copyright
		if(m_pCopyright)
		{
			m_dwSize += m_pCopyright->Size();
			m_dwNumOffsetTableEntries += m_pCopyright->Count();
		}
		// If instrument does not have one use collection's
		else if(m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
		{
			m_dwSize += m_pParent->m_pCopyright->Size();
			m_dwNumOffsetTableEntries += m_pParent->m_pCopyright->Count();
		}
		// Calculate the space needed for Instrument's Articulation
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
			    m_dwSize += pArticulation->Size();
			    m_dwNumOffsetTableEntries += pArticulation->Count();
                if (m_fNewFormat)
                {
                    pArticulation = pArticulation->GetNext();
                }
                else break;
            }
		}

		// Calculate the space needed for Instrument's regions 
		CRegion* pRegion = m_RegionList.GetHead();
		for(; pRegion; pRegion = pRegion->GetNext())
		{
			m_dwSize += pRegion->Size();
			m_dwNumOffsetTableEntries += pRegion->Count();
		}

		// Calculate the space needed for offset table
		m_dwSize += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(ULONG));
	}
    else
	{
		hr = E_FAIL;
	}
	// If everything went well, we have the size
	if(SUCCEEDED(hr))
	{
		*pdwSize = m_dwSize;
	}
	else
	{
		m_dwSize = 0;
	}

	return hr;
}

#else
HRESULT CInstrObj::Size(DWORD* pdwSize)
{
	// Assumption validation - Debug
	assert(pdwSize);
#ifdef DBG
	assert(m_bLoaded);
#endif

	// If we have already calculated the size we do not need to do it again
	if(m_dwSize)
	{
		*pdwSize = m_dwSize;
		return S_OK;
	}
	
	HRESULT hr = S_OK;
	
	m_dwSize = 0;
	m_dwNumOffsetTableEntries = 0;

	// Calculate the space needed for DMUS_DOWNLOADINFO 
	m_dwSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	// Calculate the space needed for DMUS_INSTRUMENT
	m_dwSize += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
	m_dwNumOffsetTableEntries++;

	// Calculate the space needed for Instrument's extension chunks
	{
		// Calculate the space needed for Instrument's Articulation
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
			    m_dwSize += pArticulation->Size();
			    m_dwNumOffsetTableEntries += pArticulation->Count();
                pArticulation = pArticulation->GetNext();
            }
		}

		// Calculate the space needed for Instrument's regions 
		CRegion* pRegion = m_RegionList.GetHead();
		for(; pRegion; pRegion = pRegion->GetNext())
		{
			m_dwSize += pRegion->Size();
			m_dwNumOffsetTableEntries += pRegion->Count();
		}

		// Calculate the space needed for offset table
		m_dwSize += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(ULONG));
	}
	// If everything went well, we have the size
	if(SUCCEEDED(hr))
	{
		*pdwSize = m_dwSize;
	}
	else
	{
		m_dwSize = 0;
	}

	return hr;
}
#endif
//////////////////////////////////////////////////////////////////////
// CInstrObj::Write
#ifdef DXAPI
HRESULT CInstrObj::Write(void* pvoid)
{
	// Assumption validation - Debug
	assert(pvoid);
#ifdef DBG
	assert(m_bLoaded);
#endif

	DWORD dwSize = 0;
	Size(&dwSize);
	
	HRESULT hr = S_OK;

//	EnterCriticalSection(&m_DMInsCriticalSection);

	DWORD dwCurIndex = 0;	// Used to determine what index to store offset in Offset Table
	DWORD dwCurOffset = 0;	// Offset relative to beginning of passed in memory

	// Write DMUS_DOWNLOADINFO	
	DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
    if (m_fNewFormat)
    {
	    pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT2;
    }
    else
    {
        pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT;
    }
	pDLInfo->dwDLId = m_dwId;
	pDLInfo->dwNumOffsetTableEntries = m_dwNumOffsetTableEntries;
	pDLInfo->cbSize = dwSize;

	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);

	// Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(DWORD));
	
	// First entry in ulOffsetTable is the address of the first object.
	pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
	dwCurIndex++;


	// Write Instrument MIDI address
	DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT*)(((BYTE *)pvoid) + dwCurOffset);

	pDMInstrument->ulPatch = m_dwPatch;
	pDMInstrument->ulFlags = 0;
	
	// Set if a GM instrument
	if(m_pParent->m_guidObject == GUID_DefaultGMCollection)
	{
		pDMInstrument->ulFlags |= DMUS_INSTRUMENT_GM_INSTRUMENT;
	}
	
	// Increment pass the DMUS_INSTRUMENT structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
	
	// Write regions
    pDMInstrument->ulFirstRegionIdx = 0;
	CRegion* pRegion = m_RegionList.GetHead();
    while (pRegion && (pRegion->Count() == 0))
    {
        pRegion = pRegion->GetNext();
    }
    while (pRegion)
	{
        DWORD dwNextRegionIndex = 0;
        CRegion *pNextRegion = pRegion->GetNext();
        // Make sure the next chunk can also be downloaded.
        while (pNextRegion && (pNextRegion->Count() == 0))
        {
            pNextRegion = pNextRegion->GetNext();
        }
        if (pNextRegion)
        {
            dwNextRegionIndex = dwCurIndex + pRegion->Count();
        }
        if (pDMInstrument->ulFirstRegionIdx == 0)
        {
            pDMInstrument->ulFirstRegionIdx = dwCurIndex;
        }

		pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
		hr = pRegion->Write(((BYTE *)pvoid + dwCurOffset), 
							&dwCurOffset,
							pDMOffsetTable->ulOffsetTable,
							&dwCurIndex,
							dwNextRegionIndex);
        if (FAILED(hr)) break;
        pRegion = pNextRegion;
	}

	if(SUCCEEDED(hr))
	{
        // Write extension chunks
		CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
		if(pExtChk)
		{
			DWORD dwCountExtChk = m_dwCountExtChk;
			DWORD dwIndexNextExtChk;
			pDMInstrument->ulFirstExtCkIdx = dwIndexNextExtChk = dwCurIndex;

			for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
			{
				if(dwCountExtChk == 1)
				{
					dwIndexNextExtChk = 0;
				}
				else
				{
					dwIndexNextExtChk = dwCurIndex + 1;
				}
				
				pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
				hr = pExtChk->Write(((BYTE *)pvoid + dwCurOffset), 
									&dwCurOffset,
									dwIndexNextExtChk);
				
				dwCountExtChk--;
			}
		}
		else
		{
			// If no extension chunks set to zero
			pDMInstrument->ulFirstExtCkIdx = 0;
		}
	}
	if(SUCCEEDED(hr))
	{
		// Write copyright information
		if(m_pCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMInstrument->ulCopyrightIdx = dwCurIndex;
			hr = m_pCopyright->Write(((BYTE *)pvoid + dwCurOffset),
									 &dwCurOffset);
			dwCurIndex++;
		}
		// If instrument does not have one use collection's
		else if(m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMInstrument->ulCopyrightIdx = dwCurIndex;
			hr = (m_pParent->m_pCopyright)->Write(((BYTE *)pvoid + dwCurOffset), 
												  &dwCurOffset);
			dwCurIndex++;
		}
		else
		{
			pDMInstrument->ulCopyrightIdx = 0;
		}
	}

	if(SUCCEEDED(hr))
	{
        pDMInstrument->ulGlobalArtIdx = 0;
		// Write global articulation if we have one
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        // Scan past articulation chunks that will not be downloaded.
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
		{
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            if (m_fNewFormat)
            {
                pNextArt = pArticulation->GetNext();
                // Make sure the next chunk can also be downloaded.
                while (pNextArt && (pNextArt->Count() == 0))
                {
                    pNextArt = pNextArt->GetNext();
                }
                if (pNextArt)
                {
                    dwNextArtIndex = dwCurIndex + pArticulation->Count();
                }
            }
            if (pDMInstrument->ulGlobalArtIdx == 0)
            {
                pDMInstrument->ulGlobalArtIdx = dwCurIndex;
            }
			pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
			hr = pArticulation->Write(((BYTE *)pvoid + dwCurOffset),
										&dwCurOffset,
										pDMOffsetTable->ulOffsetTable,
										&dwCurIndex,
                                        dwNextArtIndex);
            pArticulation = pNextArt;
            if (FAILED(hr)) break;
		}

	}

	if(FAILED(hr))
	{
		// If we fail we want to cleanup the contents of passed in buffer
		ZeroMemory(pvoid, dwSize);
	}

//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return hr;
}
#else
HRESULT CInstrObj::Write(void* pvoid)
{
	// Assumption validation - Debug
	assert(pvoid);
#ifdef DBG
	assert(m_bLoaded);
#endif

	DWORD dwSize = 0;
	Size(&dwSize);
	
	HRESULT hr = S_OK;

	DWORD dwCurIndex = 0;	// Used to determine what index to store offset in Offset Table
	DWORD dwCurOffset = 0;	// Offset relative to beginning of passed in memory

	// Write DMUS_DOWNLOADINFO	
	DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
    pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT2;
	pDLInfo->dwDLId = m_dwId;
	pDLInfo->dwNumOffsetTableEntries = m_dwNumOffsetTableEntries;
	pDLInfo->cbSize = dwSize;

	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);

	// Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(DWORD));
	
	// First entry in ulOffsetTable is the address of the first object.
	pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
	dwCurIndex++;


	// Write Instrument MIDI address
	DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT*)(((BYTE *)pvoid) + dwCurOffset);

	pDMInstrument->ulPatch = m_dwPatch;
	pDMInstrument->ulFlags = 0;
	
	// Set if a GM instrument
	if(m_pParent->m_guidObject == GUID_DefaultGMCollection)
	{
		pDMInstrument->ulFlags |= DMUS_INSTRUMENT_GM_INSTRUMENT;
	}
	
	// Increment pass the DMUS_INSTRUMENT structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
	
	// Write regions
    pDMInstrument->ulFirstRegionIdx = 0;
	CRegion* pRegion = m_RegionList.GetHead();
    while (pRegion && (pRegion->Count() == 0))
    {
        pRegion = pRegion->GetNext();
    }
    while (pRegion)
	{
        DWORD dwNextRegionIndex = 0;
        CRegion *pNextRegion = pRegion->GetNext();
        // Make sure the next chunk can also be downloaded.
        while (pNextRegion && (pNextRegion->Count() == 0))
        {
            pNextRegion = pNextRegion->GetNext();
        }
        if (pNextRegion)
        {
            dwNextRegionIndex = dwCurIndex + pRegion->Count();
        }
        if (pDMInstrument->ulFirstRegionIdx == 0)
        {
            pDMInstrument->ulFirstRegionIdx = dwCurIndex;
        }

		pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
		hr = pRegion->Write(((BYTE *)pvoid + dwCurOffset), 
							&dwCurOffset,
							pDMOffsetTable->ulOffsetTable,
							&dwCurIndex,
							dwNextRegionIndex);
        if (FAILED(hr)) break;
        pRegion = pNextRegion;
	}

	if(SUCCEEDED(hr))
	{
        pDMInstrument->ulGlobalArtIdx = 0;
		// Write global articulation if we have one
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        // Scan past articulation chunks that will not be downloaded.
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
		{
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            pNextArt = pArticulation->GetNext();
            // Make sure the next chunk can also be downloaded.
            while (pNextArt && (pNextArt->Count() == 0))
            {
                pNextArt = pNextArt->GetNext();
            }
            if (pNextArt)
            {
                dwNextArtIndex = dwCurIndex + pArticulation->Count();
            }
            if (pDMInstrument->ulGlobalArtIdx == 0)
            {
                pDMInstrument->ulGlobalArtIdx = dwCurIndex;
            }
			pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
			hr = pArticulation->Write(((BYTE *)pvoid + dwCurOffset),
										&dwCurOffset,
										pDMOffsetTable->ulOffsetTable,
										&dwCurIndex,
                                        dwNextArtIndex);
            pArticulation = pNextArt;
            if (FAILED(hr)) break;
		}

	}

	return hr;
}
#endif

//////////////////////////////////////////////////////////////////////
// CInstrObj::FixupWaveRefs

HRESULT CInstrObj::FixupWaveRefs()
{

//	EnterCriticalSection(&m_DMInsCriticalSection);
	
	CRegion* pRegion = m_RegionList.GetHead();
	
	for(; pRegion; pRegion = pRegion->GetNext())
	{
        if (pRegion->m_WaveLink.ulTableIndex < m_pParent->m_dwWaveOffsetTableSize)
        {
		    pRegion->m_WaveLink.ulTableIndex = m_pParent->m_pWaveOffsetTable[pRegion->m_WaveLink.ulTableIndex].dwId;
        }
        else
        {
            Trace(1,"Error: Bad DLS file has out of range wavelink.\n");
            return DMUS_E_BADWAVELINK;
        }
    }

//	LeaveCriticalSection(&m_DMInsCriticalSection);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmksclk.cpp ===
//
// DMKSClk.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrapper for using a KS clock as the DirectMusic master clock
//
// 
//
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include <winerror.h>
#include "dmusicp.h"
#include "debug.h"
#include "resource.h"

// Since we only allocate one of these clocks in the entire system,
// this stuff is global.
//

// We have to be able to get the process id of someone with a handle to
// the clock. Since the original creator might go away before other users,
// we store the process id of everyone who uses the clock. This implies
// a max limit on concurrent processes using it.
//
#define MAX_CLOCK_SHARERS   64              // Max processes who can access clock   
                                            // at once.
typedef struct KSCLOCKSHARE
{
    LONG                cRef;               // Count of processes using handle

    struct 
    {
        HANDLE          hKsClock;           // This user's handle and
        DWORD           dwProcessId;        // process id
    } aUsers[MAX_CLOCK_SHARERS];

} *PKSCLOCKSHARE;

class CKsClock : public IReferenceClock, public IMasterClockPrivate
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // IMasterClockPrivate
    STDMETHODIMP GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize);

    // Class
    //
    CKsClock();
    ~CKsClock();
    HRESULT Init();

private:
    long m_cRef;

    HRESULT CreateKsClockShared();
    void    DeleteKsClockShared();
    HRESULT CreateKsClockHandle();
    HRESULT DuplicateKsClockHandle();

private:
    static const char m_cszKsClockMemory[];       // Name of shared memory object
    static const char m_cszKsClockMutex[];        // Name of mutex protecting shared memory

    static LONG m_lSharedMemoryInitialized;       // Has this process initialized shared memory?
    static HANDLE m_hFileMapping;                 // File mapping handle for shared memory
    static PKSCLOCKSHARE m_pShared;               // Pointer to shared memory
    static HANDLE m_hKsClockMutex;                // Mutex for shared memory access
    static HANDLE m_hClock;                       // Clock handle in this process
};

static HRESULT CreateKsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);

const char       CKsClock::m_cszKsClockMemory[] = "DirectMusicKsClock";
const char       CKsClock::m_cszKsClockMutex[]  = "DirectMusicKsClockMutex";

LONG             CKsClock::m_lSharedMemoryInitialized = 0;
HANDLE           CKsClock::m_hFileMapping = NULL;         
PKSCLOCKSHARE    CKsClock::m_pShared = NULL;        
HANDLE           CKsClock::m_hKsClockMutex = NULL;
HANDLE           CKsClock::m_hClock;                

#ifdef DEAD_CODE

// AddKsClocks
//
// Add Ks clock to the list of clocks.
//
HRESULT AddKsClocks(CMasterClock *pMasterClock)
{
    HANDLE hClock;

    // Make sure we can create a default Ks clock
    //
    if (!OpenDefaultDevice(KSCATEGORY_CLOCK, &hClock))
    {
        TraceI(0, "Could not create Ks clock\n");
        return S_FALSE;
    }

    CloseHandle(hClock);

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce);
    ce.cc.guidClock = GUID_SysClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreateKsClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}
#endif

// CreateKsClock
//
// Return an IReferenceClock based on the one Ks clock in the system
//
static HRESULT CreateKsClock(IReferenceClock **ppClock)
{
    HRESULT hr;

    TraceI(0, "Creating KS clock\n");

    CKsClock *pClock = new CKsClock();

    hr = pClock->Init();
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

// CKsClock::CKsClock()
//
// 
CKsClock::CKsClock() : 
    m_cRef(1)
{
}

// CKsClock::~CKsClock()
//
// 
CKsClock::~CKsClock()
{
    if (InterlockedDecrement(&m_lSharedMemoryInitialized) == 0)
    {
        DeleteKsClockShared();        
    }
}

// CKsClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CKsClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IMasterClockPrivate)
    {
        *ppv = static_cast<IMasterClockPrivate*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CKsClock::AddRef
// 
STDMETHODIMP_(ULONG) CKsClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CKsClock::Release
//
STDMETHODIMP_(ULONG) CKsClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CKsClock::Init
//
HRESULT CKsClock::Init()
{
    HRESULT hr;

    if (InterlockedIncrement(&m_lSharedMemoryInitialized) == 1)
    {
        hr = CreateKsClockShared();
        if (FAILED(hr))
        {
            return hr;
        }    
    }

    return S_OK;
}

// CKsClock::CreateKsClockShared
//
// Initialize the shared memory object in this process.
// Make sure a handle to the Ks clock exists in this process.
//
HRESULT CKsClock::CreateKsClockShared()
{
    HRESULT hr;
    DWORD dwErr;

    // Create and take the mutex up front. This is neccesary to guarantee that if 
    // we are the first process in the system to create this object, then we do 
    // initialization before anyone else can access the shared memory object.
    //
    m_hKsClockMutex = CreateMutex(NULL,             // Default security descriptor
                                  FALSE,            // Own mutex if we are first instance
                                  m_cszKsClockMutex);
    if (m_hKsClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    WaitForSingleObject(m_hKsClockMutex, INFINITE);

    // Create the file mapping and view of the shared memory, noticing if we are the first 
    // object to create it.
    //
    m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(KSCLOCKSHARE),
                                       m_cszKsClockMemory);
    dwErr = GetLastError();
    if (m_hFileMapping == NULL)
    {
        ReleaseMutex(m_hKsClockMutex);
        
        return HRESULT_FROM_WIN32(dwErr);
    }    

    BOOL fFirst = (dwErr != ERROR_ALREADY_EXISTS);

    m_pShared = (PKSCLOCKSHARE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_WRITE,
                                             0, 0,                // Start mapping at the beginning
                                             0);                  // Map entire file
    if (m_pShared == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());

        ReleaseMutex(m_hKsClockMutex);
        return E_OUTOFMEMORY;
    }

    // Initialize the refernce count if we are the first process, and increment
    // it in any case. (Note we're still in the mutex, so we don't need 
    // InterlockedIncrement.
    //
    if (fFirst)
    {
        m_pShared->cRef = 0;
        ZeroMemory(m_pShared->aUsers, sizeof(m_pShared->aUsers));
    }
    ++m_pShared->cRef;

    // If the clock handle doesn't exist yet, create it; else duplicate it. 
    //
    if (m_pShared->cRef == 1)
    {
        hr = CreateKsClockHandle();
    }
    else
    {
        hr = DuplicateKsClockHandle();
    }

    // Release the mutex and return success or failure.
    //
    ReleaseMutex(m_hKsClockMutex);

    return hr;
}

// CKsClock::DeleteKsClockShared
//
// The last instance of CKsClock in this process is being deleted. 
//
void CKsClock::DeleteKsClockShared()
{
    // If the mutex was never created, then none of the other objects could have
    // been created.
    //
    if (m_hKsClockMutex)
    {
        WaitForSingleObject(m_hKsClockMutex, INFINITE);

        if (m_pShared)
        {
            for (int i = 0; i < MAX_CLOCK_SHARERS; i++)
            {
                if (m_pShared->aUsers[i].dwProcessId == GetCurrentProcessId())
                {
                    m_pShared->aUsers[i].dwProcessId = 0;
                    m_pShared->aUsers[i].hKsClock = NULL;

                    break;
                }
            }
        }

        if (m_hClock)
        {
            CloseHandle(m_hClock);
            m_hClock = NULL;
        }        

        if (m_pShared)
        {
            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }

        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
                
        ReleaseMutex(m_hKsClockMutex);
        CloseHandle(m_hKsClockMutex);                            
    }
}

// CKsClock::CreateKsClockHandle
//
// Create the first and only Ks clock handle in the system
//
HRESULT CKsClock::CreateKsClockHandle()
{
    // Attempt to open the clock
    //
    if (!OpenDefaultDevice(KSCATEGORY_CLOCK, &m_hClock))
    {
        m_hClock = NULL;

        TraceI(0, "Could not create Ks clock\n");
        return E_FAIL;
    }

    KSPROPERTY      ksp;
    KSSTATE			state;

    ksp.Set    = KSPROPSETID_Clock;
    ksp.Id     = KSPROPERTY_CLOCK_STATE;
    ksp.Flags  = KSPROPERTY_TYPE_SET;

	state      = KSSTATE_RUN;

    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(state), 
                  &state,
                  NULL))
    {
        CloseHandle(m_hClock);
        m_hClock = NULL;
        TraceI(0, "Could not set clock into run state\n");
        return E_FAIL;
    }

    // Successful clock open. Since we're creating, we know we're the first
    // instance of the clock and therefore the users array is empty.
    //
    m_pShared->aUsers[0].hKsClock = m_hClock;
    m_pShared->aUsers[0].dwProcessId = GetCurrentProcessId();    

    return S_OK;
}

// CKsClock::DuplicateKsClockHandle
//
// There is already a Ks clock in the system. Duplicate the handle in this process
// context.
//
HRESULT CKsClock::DuplicateKsClockHandle()
{
    // Find another user of the clock; also, find a slot in the users array for
    // this process
    //
    int iEmptySlot = -1;
    int iOtherProcess = -1;
    HANDLE hClock = NULL;

    for (int i = 0; 
         (i < MAX_CLOCK_SHARERS) && (iEmptySlot == -1 || !hClock); 
         i++)
    {
        if (m_pShared->aUsers[i].dwProcessId == 0 && iEmptySlot == -1)
        {
            iEmptySlot = i;
            continue;
        }

        if (hClock)
        {
            continue;
        }            

        HANDLE hOtherProcess = OpenProcess(PROCESS_DUP_HANDLE, 
                                           FALSE,
                                           m_pShared->aUsers[i].dwProcessId);
        if (hOtherProcess == NULL)
        {
            TraceI(0, "OpenProcess: %d\n", GetLastError());
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hKsClock = NULL;
            continue;
        }

        BOOL fSuccess = DuplicateHandle(hOtherProcess,
                                        m_pShared->aUsers[i].hKsClock,
                                        GetCurrentProcess(),
                                        &hClock,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FALSE,
                                        0);
        if (!fSuccess)
        {
            TraceI(0, "DuplicateHandle: %d\n", GetLastError());
        }

        CloseHandle(hOtherProcess);

        if (!fSuccess)
        {
            // Other process exists, but could not duplicate handle
            //
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hKsClock = NULL;

            hClock = NULL;
        }
    }

    assert(iEmptySlot != -1);
    assert(hClock);

    m_hClock = hClock;

    m_pShared->aUsers[iEmptySlot].dwProcessId = GetCurrentProcessId();
    m_pShared->aUsers[iEmptySlot].hKsClock = hClock;

    return S_OK;
}

STDMETHODIMP 
CKsClock::GetTime(REFERENCE_TIME *pTime)
{
    KSPROPERTY ksp;

    ksp.Set   = KSPROPSETID_Clock;
    ksp.Id    = KSPROPERTY_CLOCK_TIME;
    ksp.Flags = KSPROPERTY_TYPE_GET;

    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(*pTime),
                  pTime,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

STDMETHODIMP 
CKsClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CKsClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CKsClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}

//
// CKsClock::GetParam (IMasterClockPrivate)
//
// This method is used internally by the port to get the user mode handle of the Ks clock
// we're using. The handle is then downloaded to kernel mode where it is referenced as a
// file object and used by the filters as the timebase as well.
//
STDMETHODIMP 
CKsClock::GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize)
{
    if (rguidType == GUID_KsClockHandle)
    {
        if (cbSize != sizeof(HANDLE))
        {
            return E_INVALIDARG;
        }

        *(LPHANDLE)pBuffer = m_hClock;
        return S_OK;
    }

    return DMUS_E_TYPE_UNSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmportdl.cpp ===
//
// dmportdl.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#include "debug.h"
#include "dmusicp.h"
#include "dminstru.h"
#include "dminsobj.h"
#include "dmdlinst.h"
#include "dmportdl.h"
#include "dswave.h"
#include "validate.h"
#include "dmvoice.h"
#include <limits.h>

DWORD CDirectMusicPortDownload::sNextDLId = 0;
CRITICAL_SECTION CDirectMusicPortDownload::sDMDLCriticalSection;

 
#ifdef DMUS_GEN_INS_DATA
void writewave(IDirectMusicDownload* pDMDownload, DWORD dwId);
void writeinstrument(IDirectMusicDownload* pDMDownload, DWORD dwId);
#endif

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::CDirectMusicPortDownload

CDirectMusicPortDownload::CDirectMusicPortDownload() :
m_cRef(1),
m_fNewFormat(NEWFORMAT_NOT_RETRIEVED),
m_dwAppend(APPEND_NOT_RETRIEVED)
{
    m_fDMDLCSinitialized = m_fCDMDLCSinitialized = FALSE;

    InitializeCriticalSection(&m_DMDLCriticalSection);
    m_fDMDLCSinitialized = TRUE;

    InitializeCriticalSection(&m_CDMDLCriticalSection);
    m_fCDMDLCSinitialized = TRUE;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::~CDirectMusicPortDownload

CDirectMusicPortDownload::~CDirectMusicPortDownload()
{
    DWORD dwIndex;
#ifdef DBG
    BOOL fAssert = TRUE;
#endif
    if (m_fDMDLCSinitialized && m_fCDMDLCSinitialized)
    {    
#ifdef DBG
        EnterCriticalSection(&m_CDMDLCriticalSection);
        if (!m_DLInstrumentList.IsEmpty())
        {
            Trace(0, "ERROR: IDirectMusicDownloadedInstrument objects not unloaded before port final release!\n");
            fAssert = FALSE;
        }
        LeaveCriticalSection(&m_CDMDLCriticalSection);

        EnterCriticalSection(&m_DMDLCriticalSection);

        for (dwIndex = 0; dwIndex < DLB_HASH_SIZE; dwIndex++)
        {
            if (!m_DLBufferList[dwIndex].IsEmpty())
            {
                if (fAssert)
                {
                    assert(FALSE);
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_DMDLCriticalSection);
    #endif // DBG

        // remove any bad list items before they are illegally destroyed in list dtor
        EnterCriticalSection(&m_CDMDLCriticalSection);
        if (!m_DLInstrumentList.IsEmpty())
        {
            m_DLInstrumentList.RemoveAll();
        }
        LeaveCriticalSection(&m_CDMDLCriticalSection);

        EnterCriticalSection(&m_DMDLCriticalSection);
        for (dwIndex = 0; dwIndex < DLB_HASH_SIZE; dwIndex++)
        {
            if (!m_DLBufferList[dwIndex].IsEmpty())
            {
                m_DLBufferList[dwIndex].RemoveAll();
            }
        }
        LeaveCriticalSection(&m_DMDLCriticalSection);
    }

    if (m_fDMDLCSinitialized)
    {
        DeleteCriticalSection(&m_DMDLCriticalSection);
    }

    if (m_fCDMDLCSinitialized)
    {
        DeleteCriticalSection(&m_CDMDLCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::QueryInterface

STDMETHODIMP CDirectMusicPortDownload::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicPortDownload) 
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AddRef

STDMETHODIMP_(ULONG) CDirectMusicPortDownload::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Release

STDMETHODIMP_(ULONG) CDirectMusicPortDownload::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicPortDownload

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AllocateBuffer

STDMETHODIMP 
CDirectMusicPortDownload::AllocateBuffer(
    DWORD dwSize,
    IDirectMusicDownload** ppIDMDownload) 
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::AllocateBuffer);
    V_PTRPTR_WRITE(ppIDMDownload);

    if(dwSize > ULONG_MAX)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    CDownloadBuffer* pdmdl = NULL;
    BYTE* pbuf = new BYTE[dwSize + sizeof(KSNODEPROPERTY)];

    if(pbuf)
    {
        pdmdl = new CDownloadBuffer;
        if(pdmdl)
        {
            hr = pdmdl->SetBuffer(pbuf, sizeof(KSNODEPROPERTY), dwSize);
            if(SUCCEEDED(hr))
            {
                *ppIDMDownload = (IDirectMusicDownload*)pdmdl;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr))
    {
        if (pdmdl) delete pdmdl;
        if (pbuf) delete [] pbuf;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetBuffer

STDMETHODIMP 
CDirectMusicPortDownload::GetBuffer(
    DWORD dwDLId,
    IDirectMusicDownload** ppIDMDownload)
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::GetBuffer);
    V_PTRPTR_WRITE(ppIDMDownload);

    if(dwDLId >= CDirectMusicPortDownload::sNextDLId)
    {
        return DMUS_E_INVALID_DOWNLOADID;
    }

    return GetBufferInternal(dwDLId,ppIDMDownload);
}

STDMETHODIMP 
CDirectMusicPortDownload::GetBufferInternal(
    DWORD dwDLId,IDirectMusicDownload** ppIDMDownload)
{
    EnterCriticalSection(&m_DMDLCriticalSection);

    bool bFound = false;    
    
    // Check the download list
    CDownloadBuffer* pDownload = m_DLBufferList[dwDLId % DLB_HASH_SIZE].GetHead();

    for( ; pDownload; pDownload = pDownload->GetNext())
    {
        if(dwDLId == pDownload->m_dwDLId)
        {
            *ppIDMDownload = pDownload;
            (*ppIDMDownload)->AddRef();
            bFound = true;
            break;
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return bFound ? S_OK : DMUS_E_NOT_DOWNLOADED_TO_PORT;   
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Download

STDMETHODIMP CDirectMusicPortDownload::Download(IDirectMusicDownload* pIDMDownload)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Unload

STDMETHODIMP CDirectMusicPortDownload::Unload(IDirectMusicDownload* pIDMDownload)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetAppend

STDMETHODIMP CDirectMusicPortDownload::GetAppend(DWORD* pdwAppend)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetDLId

STDMETHODIMP CDirectMusicPortDownload::GetDLId(
    DWORD* pdwStartDLId,
    DWORD dwCount)
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::GetDLId);
    V_PTR_WRITE(pdwStartDLId, DWORD);

    if(dwCount > ULONG_MAX || (sNextDLId + dwCount) > ULONG_MAX)
    {
        return E_INVALIDARG;
    }

    GetDLIdP(pdwStartDLId, dwCount);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetDLIdP

void CDirectMusicPortDownload::GetDLIdP(DWORD* pdwStartDLId, DWORD dwCount)
{
    assert(pdwStartDLId);

    EnterCriticalSection(&sDMDLCriticalSection);
    
    *pdwStartDLId = sNextDLId;
    
    sNextDLId += dwCount;
    
    LeaveCriticalSection(&sDMDLCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// Internal

void CDirectMusicPortDownload::ClearDLSFeatures()

{
    m_DLSFeatureList.Clear();
}

STDMETHODIMP
CDirectMusicPortDownload::QueryDLSFeature(REFGUID rguidID, long *plResult)

{
    *plResult = 0;      // Set to 0, which is the default for when the GUID is not supported.
    CDLSFeature *pFeature = m_DLSFeatureList.GetHead();
    for (;pFeature;pFeature = pFeature->GetNext())
    {
        if (rguidID == pFeature->m_guidID)
        {
            *plResult = pFeature->m_lResult;
            return pFeature->m_hr;
        }
    }
    IKsControl *pControl;
    HRESULT hr = QueryInterface(IID_IKsControl, (void**)&pControl);
    if (SUCCEEDED(hr))
    {
        KSPROPERTY ksp;
        ULONG cb;

        ZeroMemory(&ksp, sizeof(ksp));
        ksp.Set   = rguidID;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                             sizeof(ksp),
                             (LPVOID)plResult,
                             sizeof(*plResult),
                             &cb);
        pControl->Release();
        pFeature = new CDLSFeature;
        if (pFeature)
        {
            pFeature->m_hr = hr;
            pFeature->m_guidID = rguidID;
            pFeature->m_lResult = *plResult;
            m_DLSFeatureList.AddHead(pFeature);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::DownloadP

STDMETHODIMP
CDirectMusicPortDownload::DownloadP(IDirectMusicInstrument* pInstrument,
                                    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
                                    DMUS_NOTERANGE* pNoteRanges,
                                    DWORD dwNumNoteRanges,
                                    BOOL fVersion2)
{
#ifdef DBG
    // Argument validation
    // We only want to do this in a DEBUG build since whoever calls us needs to do 
    // the RELEASE build validation
    V_INAME(IDirectMusicPortDownload::DownloadP);
    V_PTR_READ(pInstrument, IDirectMusicInstrument); 
    V_PTRPTR_WRITE(ppDownloadedInstrument);
    V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));
#endif

    // If you can QI pInstrument for private interface IDirectMusicInstrumentPrivate 
    // pInstrument is of type CInstrument.
    IDirectMusicInstrumentPrivate* pDMIP = NULL;
    HRESULT hr = pInstrument->QueryInterface(IID_IDirectMusicInstrumentPrivate, (void **)&pDMIP);

    if (FAILED(hr))
    {
        return hr;
    }

    pDMIP->Release();

    EnterCriticalSection(&m_CDMDLCriticalSection);

    hr = GetCachedAppend(&m_dwAppend);
    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CDMDLCriticalSection);
        return hr;
    }

    if (m_fNewFormat == NEWFORMAT_NOT_RETRIEVED)
    {
        QueryDLSFeature(GUID_DMUS_PROP_INSTRUMENT2,(long *) &m_fNewFormat);
    }

    CInstrument *pCInstrument = (CInstrument *)pInstrument;

    // Get number of waves in an instrument
    DWORD dwCount;
    hr = pCInstrument->GetWaveCount(&dwCount);

    // Get Download ID's for each wave in instrument
    DWORD* pdwWaveIds = NULL;   
    if (SUCCEEDED(hr))
    {
        pdwWaveIds = new DWORD[dwCount];
        if (pdwWaveIds)
        {
            hr = pCInstrument->GetWaveDLIDs(pdwWaveIds);
        }
        else
        {
            hr = E_OUTOFMEMORY;             
        }
    }

    // Get DownloadedInstrument object
    CDownloadedInstrument* pDMDLInst = NULL;
    IDirectMusicPort* pIDMPort = NULL;
    DWORD dwDLId = pCInstrument->GetInstrumentDLID();
    BOOL fInstrumentNeedsDownload = FALSE;
    if (SUCCEEDED(hr))
    {
        hr = QueryInterface(IID_IDirectMusicPort, (void **)&pIDMPort);
        
        if (SUCCEEDED(hr))
        {
            hr = FindDownloadedInstrument(dwDLId, &pDMDLInst);

            if (!pDMDLInst && SUCCEEDED(hr))
            {
                fInstrumentNeedsDownload = TRUE;
                pDMDLInst = new CDownloadedInstrument;

                if (pDMDLInst)
                {       
                    // Allocate an IDirectMusicDownload pointer for each wave and one for the instrument
                    pDMDLInst->m_ppDownloadedBuffers = new IDirectMusicDownload*[dwCount + 1];
                    if (pDMDLInst->m_ppDownloadedBuffers)
                    {
                        pDMDLInst->m_dwDLTotal = dwCount + 1;
                        memset(pDMDLInst->m_ppDownloadedBuffers, 0, pDMDLInst->m_dwDLTotal * sizeof(IDirectMusicDownload*));
                        pDMDLInst->m_pPort = pIDMPort;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        pDMDLInst->Release(); 
                        pDMDLInst = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // don't let DMDLInst hold a refcnt on the port so we can final-release the port if the app
            //  misses a DMDLInst release
            pIDMPort->Release(); pIDMPort = NULL;
        }
    }
    
    DWORD dwSize;
    
    // Download the data for each wave if necessary
    if (SUCCEEDED(hr))
    {
#ifdef DXAPI
        // First, make sure all conditional chunks are evaluated properly for this port.
        pCInstrument->SetPort(this, fVersion2);
#endif
        // All waves are already down?
        if (pDMDLInst->m_dwDLSoFar < dwCount) 
        {
            // Find out which waves need to be downloaded. 
            DWORD* pdwWaveRefs = NULL;  

            pdwWaveRefs = new DWORD[dwCount];
            if (pdwWaveRefs)
            {
                DWORD dwWaveIndex;
                hr = GetWaveRefs(&pDMDLInst->m_ppDownloadedBuffers[1], 
                    pdwWaveRefs, pdwWaveIds, dwCount, 
                    pCInstrument, pNoteRanges, dwNumNoteRanges);
                for(dwWaveIndex = 0; dwWaveIndex < dwCount && SUCCEEDED(hr); dwWaveIndex++)
                {
                    if (!pdwWaveRefs[dwWaveIndex] || pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1])
                    {
                        continue;
                    }
            
                    // Determine if we need to download the wave
                    IDirectMusicDownload* pDMDownload = NULL;

                    hr = GetBufferInternal(pdwWaveIds[dwWaveIndex], &pDMDownload);

                    // If NULL not downloaded so we need to download
                    if (pDMDownload == NULL && hr == DMUS_E_NOT_DOWNLOADED_TO_PORT)
                    {
				        DWORD dwSampleSize;	// Bit size of wave data.
                        hr = pCInstrument->GetWaveSize(pdwWaveIds[dwWaveIndex], &dwSize, &dwSampleSize);
                        if (SUCCEEDED(hr))
                        {
                            dwSize += (m_dwAppend * (dwSampleSize / 8));

                            hr = AllocateBuffer(dwSize, &pDMDownload);
                            if (SUCCEEDED(hr))
                            {
                                hr = pCInstrument->GetWave(pdwWaveIds[dwWaveIndex], pDMDownload);
#ifdef DMUS_GEN_INS_DATA
                                if (SUCCEEDED(hr))
                                {
                                    writewave(pDMDownload, pdwWaveIds[dwWaveIndex]);
                                }
#endif
                            }

                            if (SUCCEEDED(hr))
                            {
                                hr = Download(pDMDownload);
                            }

                            if (SUCCEEDED(hr))
                            {
                                pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = pDMDownload;
                                pDMDLInst->m_dwDLSoFar++;  
                                fInstrumentNeedsDownload = TRUE;
                            }

                            if (FAILED(hr) && pDMDownload != NULL)
                            {
                                pDMDownload->Release();
                                pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = NULL;
                            }
                        }
                    }
                    else if (SUCCEEDED(hr))
                    {
                        if (pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] == NULL)
                        {
                            ((CDownloadBuffer*)pDMDownload)->IncDownloadCount();
                            pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = pDMDownload;
                            pDMDLInst->m_dwDLSoFar++;
                        }
                        else
                        {
                            pDMDownload->Release(); // for being found
                            pDMDownload = NULL;
                        }
                    }
                }
                delete [] pdwWaveRefs;
            }
            else
            {
                hr = E_OUTOFMEMORY;             
            }
        }
    }

    // Download instrument data
    if (SUCCEEDED(hr))
    {
        // Determine if we need to downloaded the instrument
        if (fInstrumentNeedsDownload)
        {
            // First, get the old download, if it exists (this should be the case
            // when an instrument needs to be updated because more waves were downloaded.)
            IDirectMusicDownload* pDMOldDownload = NULL;
            GetBufferInternal(dwDLId, &pDMOldDownload);

            hr = pCInstrument->GetInstrumentSize(&dwSize);
        
            IDirectMusicDownload* pDMNewDownload = NULL;
        
            if (SUCCEEDED(hr))
            {
                hr = AllocateBuffer(dwSize, &pDMNewDownload);
                if (SUCCEEDED(hr))
                {
                    hr = pCInstrument->GetInstrument(pDMNewDownload);
#ifdef DMUS_GEN_INS_DATA                        
                    if (SUCCEEDED(hr))
                    {
                        writeinstrument(pDMNewDownload, dwDLId);
                    }
#endif
                }
            
                if (SUCCEEDED(hr))
                {
                    hr = Download(pDMNewDownload);
                }
            
                if (SUCCEEDED(hr))
                {
                    pDMDLInst->m_ppDownloadedBuffers[0] = pDMNewDownload;
                }

                if (FAILED(hr) && pDMNewDownload != NULL)
                {
                    pDMNewDownload->Release();
                    pDMDLInst->m_ppDownloadedBuffers[0] = NULL;
                }
            }
        
            if (pDMOldDownload)
            {
                Unload(pDMOldDownload);
                pDMOldDownload->Release(); // for being found
                pDMOldDownload->Release(); // to destroy
                pDMOldDownload = NULL;
            }
        }
    }

    delete [] pdwWaveIds;

    if (FAILED(hr))
    {
        if (pDMDLInst)
        {
            if (!pDMDLInst->m_cDLRef)
            {
                CDownloadBuffer* pDMDL = NULL;

                for(DWORD i = 0; i < pDMDLInst->m_dwDLTotal; i++)
                {   
                    pDMDL = (CDownloadBuffer*)(pDMDLInst->m_ppDownloadedBuffers[i]);
        
                    if(pDMDL)
                    {
                        Unload((IDirectMusicDownload*)pDMDL);
                        pDMDL->Release();
                    }
                }   

                delete [] (pDMDLInst->m_ppDownloadedBuffers);
                pDMDLInst->m_ppDownloadedBuffers = NULL;
            }

            pDMDLInst->Release();
        }
    }
    else
    {
        if (!pDMDLInst->m_cDLRef)
        {
            hr = AddDownloadedInstrument(pDMDLInst);
        }

        pDMDLInst->m_cDLRef++;
        *ppDownloadedInstrument = pDMDLInst;
    }

    LeaveCriticalSection(&m_CDMDLCriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::UnloadP

STDMETHODIMP
CDirectMusicPortDownload::UnloadP(IDirectMusicDownloadedInstrument* pDownloadedInstrument)
{
#ifdef DBG
    // Argument validation
    // We only want to do this in a DEBUG build since whoever calls us needs to do 
    // the RELEASE build validation
    V_INAME(IDirectMusicPortDownload::UnloadP);
    V_PTR_READ(pDownloadedInstrument, IDirectMusicDownloadedInstrument); 
#endif

    // If you can QI pDownloadedInstrument for private interface IDirectMusicDownloadedInstrumentPrivate 
    // pDownloadedInstrument is of type CDownloadedInstrument.
    IDirectMusicDownloadedInstrumentPrivate* pDMDIP = NULL;
    HRESULT hr = pDownloadedInstrument->QueryInterface(IID_IDirectMusicDownloadedInstrumentPrivate, (void **)&pDMDIP);

    if(FAILED(hr))
    {
        return hr;
    }

    pDMDIP->Release();

    CDownloadedInstrument* pDMDLInst = (CDownloadedInstrument *)pDownloadedInstrument;

    IDirectMusicPort* pIDMP = NULL;
        
    QueryInterface(IID_IDirectMusicPort, (void **)&pIDMP);
    
    // Make sure we are downloaded to this port and that we have not been previously unloaded
    // If pDMDLInst->m_ppDownloadedBuffers == NULL we may have been downloadeded to this port but are no longer
    if(pDMDLInst->m_pPort != pIDMP || pDMDLInst->m_ppDownloadedBuffers == NULL)
    {
        pIDMP->Release();
        return DMUS_E_NOT_DOWNLOADED_TO_PORT;
    }
    
    pIDMP->Release();

    EnterCriticalSection(&m_CDMDLCriticalSection);

    if (pDMDLInst->m_cDLRef && --pDMDLInst->m_cDLRef == 0)
    {
        CDownloadBuffer* pDMDL = NULL;

        for(DWORD i = 0; i < pDMDLInst->m_dwDLTotal; i++)
        {   
            pDMDL = (CDownloadBuffer*)(pDMDLInst->m_ppDownloadedBuffers[i]);
        
            if(pDMDL)
            {
                Unload((IDirectMusicDownload*)pDMDL);
                pDMDL->Release();
            }
        }   

        delete [] (pDMDLInst->m_ppDownloadedBuffers);
        pDMDLInst->m_ppDownloadedBuffers = NULL;
        RemoveDownloadedInstrument(pDMDLInst);
    }
    else
    {
        hr = S_FALSE;
    }

    LeaveCriticalSection(&m_CDMDLCriticalSection);

    return hr;
}



//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetWaveRefs

STDMETHODIMP
CDirectMusicPortDownload::GetWaveRefs(IDirectMusicDownload* ppDownloadedBuffers[],
                                      DWORD* pdwWaveRefs,
                                      DWORD* pdwWaveIds,
                                      DWORD dwNumWaves,
                                      CInstrument* pCInstrument,
                                      DMUS_NOTERANGE* pNoteRanges,
                                      DWORD dwNumNoteRanges)
{
    assert(pdwWaveRefs);
    assert(ppDownloadedBuffers);
    assert(pCInstrument);
    assert(dwNumNoteRanges ? (pNoteRanges != NULL) : TRUE);

    memset(pdwWaveRefs, 0, dwNumWaves * sizeof(DWORD));

    // Get number of waves in an instrument
    DWORD dwCount;
    if (FAILED(pCInstrument->GetWaveCount(&dwCount)))
    {
        return E_UNEXPECTED;
    }

    if (dwCount != dwNumWaves)
    {
        return E_INVALIDARG;
    }

    CInstrObj *pInstObj = pCInstrument->m_pInstrObj;
    
    if (pInstObj)
    {
#ifdef DXAPI
        if (pInstObj->m_fHasConditionals || dwNumNoteRanges)
#else
        if (dwNumNoteRanges)
#endif
        {
            CRegion *pRegion = pInstObj->m_RegionList.GetHead();
            DWORD dwWaveIdx;
            for (dwWaveIdx = 0; dwWaveIdx < dwNumWaves; dwWaveIdx++)
            {
                // Check if the wave is already downloaded.
                if (!ppDownloadedBuffers[dwWaveIdx])
                {
                    // We always scan forward through the regions, since they are in the same order as the array.
                    for (;pRegion;pRegion = pRegion->GetNext())
                    {
                        // Does this region point to the next wave? If not, it must be a duplicate.
                        if (pRegion->m_WaveLink.ulTableIndex == pdwWaveIds[dwWaveIdx])
                        {
                            // Conditional chunk allow download?
#ifdef DXAPI
                            if (pRegion->m_Condition.m_fOkayToDownload)
#endif
                            {
                                // Verify against note ranges.
                                if (dwNumNoteRanges)
                                {
                                    DWORD dwLowNote = DWORD(pRegion->m_RgnHeader.RangeKey.usLow);
                                    DWORD dwHighNote = DWORD(pRegion->m_RgnHeader.RangeKey.usHigh);

                                    for (DWORD dwNRIdx = 0; dwNRIdx < dwNumNoteRanges; dwNRIdx++)
                                    {
                                        if (dwHighNote < pNoteRanges[dwNRIdx].dwLowNote ||
                                            dwLowNote > pNoteRanges[dwNRIdx].dwHighNote)
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            pdwWaveRefs[dwWaveIdx]++;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    pdwWaveRefs[dwWaveIdx]++;
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwNumWaves; dwIndex++)
            {
                if (!ppDownloadedBuffers[dwIndex])
                {
                    pdwWaveRefs[dwIndex]++;
                }
            }
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::FindDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::FindDownloadedInstrument(DWORD dwId,
                                                   CDownloadedInstrument** ppDMDLInst)
{
    assert(ppDMDLInst);

    HRESULT hr = S_FALSE;

    for (CDownloadedInstrument* pDMDLInst = m_DLInstrumentList.GetHead();
        pDMDLInst; pDMDLInst = pDMDLInst->GetNext())
    {
        IDirectMusicDownload* pDMDownload = pDMDLInst->m_ppDownloadedBuffers[0];
        
        if (pDMDownload && ((CDownloadBuffer*)pDMDownload)->m_dwDLId == dwId)
        {
            *ppDMDLInst = pDMDLInst;
            (*ppDMDLInst)->AddRef();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AddDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::AddDownloadedInstrument(CDownloadedInstrument* pDMDLInst)
{
    assert(pDMDLInst);

    m_DLInstrumentList.AddTail(pDMDLInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::RemoveDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::RemoveDownloadedInstrument(CDownloadedInstrument* pDMDLInst)
{
    assert(pDMDLInst);

    m_DLInstrumentList.Remove(pDMDLInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::FreeBuffer

STDMETHODIMP
CDirectMusicPortDownload::FreeBuffer(IDirectMusicDownload* pIDMDownload)                                       
{
    // Argument validation
    assert(pIDMDownload);

    void* pvBuffer = NULL; 

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();
        
        HRESULT hr = ((CDownloadBuffer*)pIDMDownload)->IsDownloaded();
        
        if(hr != S_FALSE)
        {
            return DMUS_E_BUFFERNOTAVAILABLE;
        }

        DWORD dwSize;
        hr = ((CDownloadBuffer*)pIDMDownload)->GetHeader(&pvBuffer, &dwSize);

    }

    if(SUCCEEDED(hr))
    {
        hr = ((CDownloadBuffer*)pIDMDownload)->SetBuffer(NULL, 0, 0);
        delete [] pvBuffer;
    }

    return hr;
}

#ifdef DMUS_GEN_INS_DATA
void writewave(IDirectMusicDownload* pDMDownload, DWORD dwId)
{
    DWORD dwSize = 0;
    void* pvBuffer = NULL;
    HRESULT hr = pDMDownload->GetBufferInternal(&pvBuffer, &dwSize);

    HANDLE hfw = NULL;
    if(SUCCEEDED(hr))
    {
        char filename[1024];
        wsprintf(filename, "%s%d%s", "d:\\InstrumentData\\wavedata", dwId, ".dat");
        hfw = CreateFile(filename,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    }

    if(pvBuffer && hfw != INVALID_HANDLE_VALUE)
    {

        DWORD w;
        BOOL b = WriteFile(hfw, 
                           ((BYTE *)pvBuffer),
                           dwSize,
                           &w,
                           NULL);
    }

    CloseHandle(hfw);
}

void writeinstrument(IDirectMusicDownload* pDMDownload, DWORD dwId)
{
    DWORD dwSize = 0;
    void* pvBuffer = NULL;
    HANDLE hfi = NULL;
    HRESULT hr = pDMDownload->GetBufferinternal(&pvBuffer, &dwSize);
    
    if(SUCCEEDED(hr))
    {
        char filename[1024];
        wsprintf(filename, "%s%d%s", "d:\\InstrumentData\\instrumentdata", dwId, ".dat");
        hfi = CreateFile(filename,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    }

    if(pvBuffer && hfi != INVALID_HANDLE_VALUE)
    {

        DWORD w;
        BOOL b = WriteFile(hfi, 
                           ((BYTE *)pvBuffer),
                           dwSize,
                           &w,
                           NULL);
    }
    
    CloseHandle(hfi);
}
#endif // #ifdef DMUS_GEN_INS_DATA

//#############################################################################
//
// Wave object support after this
//
//
//#############################################################################

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::DownloadWaveP
//
// This function supports the DownloadWave method on IDirectMusicPort.
// It is not related directly to DLS functionality, but rather to
// downloading oneshot and streaming waves from an IDirectSoundWave.
//
// rtStart is not the starting time on the master clock, but rather
// the offset within the stream (if this is a stream).
//

STDMETHODIMP 
CDirectMusicPortDownload::DownloadWaveP(IDirectSoundWave *pIDSWave,               
                                        IDirectSoundDownloadedWaveP **ppWave,
                                        REFERENCE_TIME rtStartHint)
{
    HRESULT                     hr = S_OK;
    CDirectSoundWave            *pDSWave = NULL;
    BOOL                        fIsStreaming = FALSE;
    BOOL                        fUseNoPreRoll = FALSE;
    REFERENCE_TIME              rtReadAhead = 0;
    DWORD                       dwFlags = 0;

    hr = pIDSWave->GetStreamingParms(&dwFlags, &rtReadAhead);
    fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
    fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;

    EnterCriticalSection(&m_CDMDLCriticalSection);
    
    // See if there is already a CDirectSoundWave object
    // wrapping this interface
    //
    if (SUCCEEDED(hr))
    {
        TraceI(2, "DownloadWaveP: Got interface %p\n", pIDSWave);
        
        // We want to download streaming waves everytime
        if(fIsStreaming == FALSE)
        {
            pDSWave = CDirectSoundWave::GetMatchingDSWave(pIDSWave);
        }
    
        if (pDSWave == NULL) 
        {
            TraceI(2, "Hmmmm. nope, haven't seen that before.\n");
            // This object has not been seen before. Wrap it.
            //
            pDSWave = new CDirectSoundWave(
                pIDSWave, 
                fIsStreaming ? true : false,
                rtReadAhead,
                fUseNoPreRoll ? true : false,
                rtStartHint);
            hr = HRFromP(pDSWave);

            if (SUCCEEDED(hr))
            {
                hr = pDSWave->Init(this);
                if (FAILED(hr))
                {
                    delete pDSWave;
                    pDSWave = NULL;
                }
            }
        }
        else 
        {
            TraceI(2, "Found download %p\n", pDSWave);
        }
    }

    // Download wave data if needed. This will do nothing on streaming waves.
    //
    if (SUCCEEDED(hr))
    {
        hr = pDSWave->Download();
    }

    if (SUCCEEDED(hr))
    {
        assert(pDSWave);
        hr = pDSWave->QueryInterface(IID_IDirectSoundDownloadedWaveP, (void**)ppWave);
    }

    if (FAILED(hr) && pDSWave)
    {
        // Something failed, unload anything we downloaded.
        //
        pDSWave->Unload();
    }

    RELEASE(pDSWave);

    LeaveCriticalSection(&m_CDMDLCriticalSection);

    return hr;
}    

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::UnloadWaveP
//
STDMETHODIMP
CDirectMusicPortDownload::UnloadWaveP(IDirectSoundDownloadedWaveP *pWave)
{
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    // XXX Stop playing voices?
    //
    HRESULT hr = pDSWave->Unload();
	if (SUCCEEDED(hr))
	{
		hr = pDSWave->Release();
	}
    
    return hr;    
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AllocVoice
//
// Voice management is neccessarily very tied to download management,
// so it makes sense for the download manager to dole out voices.
// 
// Methods on IDirectMusicPortPrivate are used to contain the port-
// specific code to do things like play.
//
STDMETHODIMP
CDirectMusicPortDownload::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,          // Wave to play on this voice
    DWORD dwChannel,                            // Channel and channel group
    DWORD dwChannelGroup,                       //  this voice will play on
    REFERENCE_TIME rtStart,                     // Where to start (stream only)
    SAMPLE_TIME stLoopStart,                    // Loop start and end
    SAMPLE_TIME stLoopEnd,                      //  (one shot only)
    IDirectMusicVoiceP **ppVoice                 // Returned voice
)
{
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    HRESULT hr;
    CDirectMusicVoice *pVoice;

    IDirectMusicPort *pPort;
    hr = QueryInterface(IID_IDirectMusicPort, (void**)&pPort);

    if (SUCCEEDED(hr))
    {
        pVoice = new CDirectMusicVoice(
            this, 
            pWave,
            dwChannel,
            dwChannelGroup,
            rtStart, 
            pDSWave->GetReadAhead(),
            stLoopStart,
            stLoopEnd);

        hr = HRFromP(pVoice);

        pPort->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pVoice->Init();
    }

    if (SUCCEEDED(hr))
    {
        *ppVoice = static_cast<IDirectMusicVoiceP*>(pVoice);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetCachedAppend
//
STDMETHODIMP
CDirectMusicPortDownload::GetCachedAppend(DWORD *pdw)
{
    HRESULT                 hr = S_OK;

    if (m_dwAppend == APPEND_NOT_RETRIEVED)
    {
        hr = GetAppend(&m_dwAppend);
    }

    *pdw = m_dwAppend;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmport.cpp ===
//
// dmport.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: CDirectMusicPort : Implements the WDM version of IDirectMusicPort.
//
// @doc EXTERNAL
//
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#ifdef XBOX
#include <xtl.h>
#include <xboxutil.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dminstru.h"
#include "dmdlinst.h"
#include "validate.h"

#pragma warning(disable:4200)

static const GUID guidZero;

#ifdef DBG
extern void _TraceIGuid(int iLevel, GUID *pGUID);
#define TraceIGuid _TraceIGuid
#else
#define TraceIGuid(x,y)
#endif

#define POSTED_STREAM_READ_IRPS     (60)
#define BYTES_PER_READ_IRP          (QWORD_ALIGN(2 * QWORD_ALIGN(sizeof(DMEVENT) + sizeof(DWORD)) - 1))

typedef struct
{
    KSSTREAM_HEADER     kssh;
    OVERLAPPED          overlapped;
    char                buffer[BYTES_PER_READ_IRP];    
} READ_IRP;

#ifndef XBOX

// @globalv:(INTERNAL) Registry location of WDM driver port definitions
//
// @comm This might need to change
//
const char cszWDMPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\WDMPort";

//#endif // ! XBOX

HRESULT EnumerateSADDevice(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    LPSTR               pInstIdPrefDev,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               *plEnumeratedPorts);

HRESULT EnumerateSADDevicePin(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               idxPin,
    BOOL                fOnPrefDev,
    LPWSTR              wszDescription,
    LPSTR               psrtInstanceId,
    ULONG               *plEnumeratedPorts,
    LPWSTR              szDIName);

static DWORD WINAPI FreeWDMHandle(LPVOID lpThreadParameter);
static DWORD WINAPI CaptureThread(LPVOID lpThreadParameter);

//////////////////////////////////////////////////////////////////////
// EnumerateWDMDevices
//
HRESULT EnumerateWDMDevices(CDirectMusic *pDirectMusic)
{
//#ifdef XBOX
    return S_FALSE;
//#else  // XBOX
    HANDLE          hSysAudio;
	HKEY            hkPortsRoot;
    ULONG           cTotalDevices;
    ULONG           idxDevice;
    LPSTR           pInstIdPrefDev = NULL; 
    ULONG           lEnumeratedPorts;

    // Determine the instance ID of the preferred wave audio device
    //  pInstIDPrefDev will allocate a string buffer
    if (!InstanceIdOfPreferredAudioDevice(&pInstIdPrefDev))
    {
        TraceI(0, "Could not determine a preferred wave audio device\n");
     
        if (pInstIdPrefDev!= NULL) delete[] pInstIdPrefDev;
        pInstIdPrefDev = NULL;
        
    }
    else
    {
        TraceI(1, "Preferred device [%s]\n", pInstIdPrefDev);
    }

	// Open or create the reg key to store WDM driver linkages
    //
	if (RegCreateKey(HKEY_LOCAL_MACHINE,
					 cszWDMPortsRoot,
					 &hkPortsRoot))
	{
		hkPortsRoot = NULL;
	}

    // Description of standard streaming interface driver must support to be 
    // enumerated
    //

    // If we can't open SysAudio, we can't enum any WDM devices
    //
    if (!OpenDefaultDevice(KSCATEGORY_SYSAUDIO, &hSysAudio))
    {
        return S_FALSE;
    }
   
    // Figure out how many devices there are and walk the list of them.
    //
    if (!GetSysAudioDeviceCount(hSysAudio, &cTotalDevices))
    {
        return S_FALSE;
    }

    // Enumerate and get info on each SAD device
    //

    lEnumeratedPorts = 0;
    for (idxDevice = 0; idxDevice < cTotalDevices; ++idxDevice)
    {
        EnumerateSADDevice(pDirectMusic, 
                           hkPortsRoot, 
                           pInstIdPrefDev, 
                           hSysAudio, 
                           idxDevice,
                           &lEnumeratedPorts);
    }

    TraceI(1, "EnumerateWDMDevices: Added %lu ports\n", lEnumeratedPorts);

	if (hkPortsRoot)
	{
		RegCloseKey(hkPortsRoot);
	}
				
    CloseHandle(hSysAudio);

    //Deallocate pInstIdPrefDev
    if (pInstIdPrefDev != NULL) delete[] pInstIdPrefDev;

    return lEnumeratedPorts ? S_OK : S_FALSE;
//#endif // XBOX
}

//#ifndef XBOX

HRESULT EnumerateSADDevice(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    LPSTR               pInstIdPrefDev,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               *plEnumeratedPorts)
{
    LPSTR               pstrInstanceId = NULL;

    ULONG               cPins;
    ULONG               idxPin;
    WCHAR               wszDIName[256];
    CHAR                szDIName[256];
    WCHAR               wszDescription[DMUS_MAX_DESCRIPTION];
    BOOL                fOnPrefDev;

    // Set SysAudio to talk to us about this device number
    //
    if (!SetSysAudioDevice(hSysAudio, idxDevice))
    {
        TraceI(0, "EnumerateSADDevice: Failed to set device to %d\n", idxDevice);
        return S_FALSE;
    }

    if (!GetDeviceFriendlyName(hSysAudio, idxDevice, wszDescription, sizeof(wszDescription)))
    {
        TraceI(0, "AddWDMDevices: Failed to get friendly name!\n");
        return S_FALSE;
    }

    char sz[256];
    wcstombs(sz, wszDescription, sizeof(sz));
    TraceI(1, "Looking at [%s]\n", sz);

    fOnPrefDev = FALSE;
    if (!GetDeviceInterfaceName(hSysAudio, idxDevice, wszDIName, sizeof(wszDIName)))
    {
        TraceI(0, "No interface name for device.\n");
        return S_FALSE;
    }

    wcstombs(szDIName, wszDIName, sizeof(szDIName));
    if (!DINameToInstanceId(szDIName, &pstrInstanceId))
    {
        TraceI(0, "Could not determine instance ID\n");
        return S_FALSE;
    }
    TraceI(1, "DIName [%s]\nInstId [%s]\n",
        szDIName,
        pstrInstanceId);

    if (pInstIdPrefDev)
    {
        if (!_stricmp(pstrInstanceId, pInstIdPrefDev))
        {
            TraceI(1, "This filter is on the preferred audio device\n");
            fOnPrefDev = TRUE;
        }
    }

    HRESULT hr = S_FALSE;
    // Get the number of pin types on this device
    //
    if (GetNumPinTypes(hSysAudio, &cPins))
    {
        for (idxPin = 0; idxPin < cPins; idxPin++)
        {
            hr = EnumerateSADDevicePin(pDirectMusic,
                                       hkPortsRoot,
                                       hSysAudio,
                                       idxDevice,
                                       idxPin,
                                       fOnPrefDev,
                                       wszDescription,
                                       pstrInstanceId,
                                       plEnumeratedPorts,
                                       wszDIName);
        }
    }
    else
    {
        TraceI(0, "AddWDMDevices: Failed to get number of pin types for device %d\n", idxDevice);
    }

    delete[] pstrInstanceId;

    return hr;
}

//#endif // ! XBOX

HRESULT EnumerateSADDevicePin(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               idxPin,
    BOOL                fOnPrefDev,
    LPWSTR              wszDescription,
    LPSTR               pstrInstanceId,
    ULONG               *plEnumeratedPorts,
    LPWSTR              wszDIName)
{
    ULONG               idxNode;
    KSPIN_DATAFLOW      dataflow;
    SYNTHCAPS           caps;
	DMUS_PORTCAPS       dmpc;

    // First make sure this pin speaks standard KS streaming. If not, we can't use it.
    //
    if (!PinSupportsInterface(hSysAudio, idxPin, KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_STREAMING))
    {
        TraceI(1, "EnumerateSADDevicePin: Pin %d does not support standard streaming\n", idxPin);
        return S_FALSE;
    }    

    // Supports standard streaming, now make sure it supports synth format.
    //
    if (!PinSupportsDataRange(hSysAudio, idxPin, KSDATAFORMAT_TYPE_MUSIC, KSDATAFORMAT_SUBTYPE_DIRECTMUSIC))
    {
        TraceI(1, "EnumerateSADDevicePin: Pin %d does not support DirectMusic data range\n", idxPin);
        return S_FALSE;
    }

    // Get the data flow direction
    //
    if (!PinGetDataFlow(hSysAudio, idxPin, &dataflow))
    {
        TraceI(0, "EnumerateSADDevicePin: PinGetDataFlow failed!\n");
        return S_FALSE;
    }

    // Find the synth caps node
    //
    idxNode = FindGuidNode(hSysAudio, idxPin, KSNODETYPE_DMSYNTH_CAPS);
    if (idxNode == -1) 
    {            
        if ((idxNode = FindGuidNode(hSysAudio, idxPin, KSCATEGORY_SYNTHESIZER)) == -1)
        {
            TraceI(1, "EnumerateSADDevicePin: Pin %d has no reachable synthcaps or synth node.\n", idxPin);
            return S_FALSE;
        }
    }

    // Get the caps
    //
    ZeroMemory(&caps, sizeof(caps));
    if (!GetFilterCaps(hSysAudio, idxNode, &caps))
    {
        TraceI(0, "EnumerateSADDevicePin: Pin %d with synth node failed caps!\n", idxPin);
        return S_FALSE;
    }

    TraceI(2, "Pin %d works for %s\n", 
             idxPin, 
             (dataflow == KSPIN_DATAFLOW_OUT) ? "capture" : "render");

    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);

    dmpc.dwClass                = dataflow == KSPIN_DATAFLOW_OUT ? DMUS_PC_INPUTCLASS : DMUS_PC_OUTPUTCLASS;
    dmpc.dwType                 = DMUS_PORT_KERNEL_MODE;

    wcscpy(dmpc.wszDescription, wszDescription);

    dmpc.guidPort               = caps.Guid;
	dmpc.dwFlags                = caps.Flags; 
    dmpc.dwMemorySize           = caps.MemorySize;
    dmpc.dwMaxChannelGroups     = caps.MaxChannelGroups;
    dmpc.dwMaxVoices            = caps.MaxVoices;
    dmpc.dwMaxAudioChannels     = caps.MaxAudioChannels;
    dmpc.dwEffectFlags          = caps.EffectFlags;


    PORTENTRY *pPort = NULL;

    // We may have to fixup the guids for non-software
    // synths
    if (!(caps.Flags & SYNTH_PC_SOFTWARESYNTH))
    {

        
        pPort = pDirectMusic->GetPortByGUID(dmpc.guidPort);

        while(pPort != NULL)
        {
            //The port is in the list

            //Is this port the same as another one?
            if (wcscmp(wszDIName,pPort->wszDIName)==0 && idxPin == pPort->idxPin)
            {
                // The GUID and DeviceID and the PIN# Match
                // This is great, lets get outta the loop
                pPort = NULL;
            }
            else
            {
                //The GUID is in use by another device
                //We need to increment the guid and try again
                dmpc.guidPort.Data1++;

                //Get the new port.
                pPort = pDirectMusic->GetPortByGUID(dmpc.guidPort);
            }
            
        }
            
    }

	pDirectMusic->AddDevice(dmpc,
			      ptWDMDevice,
			      idxDevice,
			      idxPin,
                  idxNode,
                  (caps.Flags & SYNTH_PC_SOFTWARESYNTH) ? FALSE : fOnPrefDev,
			      hkPortsRoot,
			      wszDIName,
			      pstrInstanceId);
    ++*plEnumeratedPorts;
    return S_OK;
}

#endif // !XBOX

//////////////////////////////////////////////////////////////////////
// CreateCDirectMusicPort
//
HRESULT
CreateCDirectMusicPort(
                       PORTENTRY *pPE, 
                       CDirectMusic *pDM, 
                       LPDMUS_PORTPARAMS pPortParams,
                       IDirectMusicPort **ppPort)
{
    HRESULT hr = S_OK;
    CDirectMusicPort *pPort = NULL;
    
    try
    {
        pPort = new CDirectMusicPort(pPE, pDM);
    } catch(...)
    {
    }

    if (pPort == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = pPort->Init(pPortParams);
    }

    if (SUCCEEDED(hr))
    {
        *ppPort = static_cast<IDirectMusicPort*>(pPort);
    }
    else
    {
        delete pPort;            
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::CDirectMusicPort

CDirectMusicPort::CDirectMusicPort(PORTENTRY *pPE,
                                   CDirectMusic *pDM) : 
m_cRef(1), 
m_pDM(pDM),
m_hUnloadThread(NULL),
m_phUnloadEventList(NULL),
m_hCaptureWake(NULL),
m_phNewUnloadEventList(NULL),
m_hCopiedEventList(NULL),
m_dwNumEvents(0),
m_dwNumEventsAllocated(256),
m_fHasActivated(FALSE),
m_lActivated(0),
m_pMasterClock(NULL),
m_fShutdownThread(FALSE),
m_pThruMap(NULL),
m_pThruBuffer(NULL),
m_dwChannelGroups(0),
m_fDirectSoundSet(FALSE),
m_pDirectSound(NULL),
m_hCaptureThread(NULL),
m_fSyncToMaster(TRUE),
m_lTimeOffset(0),
m_pPCClock(NULL)
{
    InterlockedIncrement(&g_cComponent);

    m_fPortCSInitialized = FALSE;
    m_fQueueCSInitialized = FALSE;

	InitializeCriticalSection(&m_DMPortCriticalSection);
    m_fPortCSInitialized = TRUE;

    InitializeCriticalSection(&m_csEventQueues);
    m_fQueueCSInitialized = TRUE;
    
    InitializeCriticalSection(&m_OverlappedCriticalSection);

    OverlappedStructs *pOverlappedStructs = new OverlappedStructs;
    if( pOverlappedStructs )
    {
        if( NULL != m_lstOverlappedStructs.AddNodeToList( pOverlappedStructs ) )
        {
            ZeroMemory( pOverlappedStructs->aOverlappedIO, sizeof( OVERLAPPED ) * OVERLAPPED_ARRAY_SIZE );
            ZeroMemory( pOverlappedStructs->afOverlappedInUse, sizeof( BOOL ) * OVERLAPPED_ARRAY_SIZE );
            ZeroMemory( pOverlappedStructs->apOverlappedBuffer, sizeof( BYTE * ) * OVERLAPPED_ARRAY_SIZE );
        }
        else
        {
            delete pOverlappedStructs;

            // Don't need to fail - we'll just try to create a new one when PlayBuffer() is called
        }
    }

    m_hPin = INVALID_HANDLE_VALUE;
    m_hSysAudio = INVALID_HANDLE_VALUE;

    m_fIsOutput = (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS) ? TRUE : FALSE;

    // XXX Can these change? Think about FrankYe's PnP stuff
    //

    dmpc = pPE->pc;
    m_pNotify = NULL;
    m_pClock = NULL;

    m_guidPort = pPE->pc.guidPort;
    m_fAudioDest = pPE->fAudioDest;

    m_fCanDownload = (pPE->pc.dwFlags & DMUS_PC_DLS) || 
                     (pPE->pc.dwFlags & DMUS_PC_DLS2);

    if (!m_fAudioDest)
    {
        m_idxDev = pPE->idxDevice;
        m_idxPin = pPE->idxPin;
        m_idxSynthNode = pPE->idxNode;
    }
    else
    {
        PORTDEST *pChosenDest = NULL;

        CNode<PORTDEST*> *pNode;
        
        for (pNode = pPE->lstDestinations.GetListHead(); pNode; pNode=pNode->pNext)
        {
            // Choose either first or default
            //
            if (pChosenDest == NULL || pNode->data->fOnPrefDev)
            {
                pChosenDest = pNode->data;
            }
        }
        
        //So what happens if fOnPrefDev never returns true?
        assert(pChosenDest);
        
        m_idxDev = pChosenDest->idxDevice;
        m_idxPin = pChosenDest->idxPin;
        m_idxSynthNode = pChosenDest->idxNode;
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::~CDirectMusicPort

CDirectMusicPort::~CDirectMusicPort()
{
    if (m_fPortCSInitialized && m_fQueueCSInitialized)
    {
        Close();

#ifdef DBG
    	EnterCriticalSection(&m_DMPortCriticalSection);

    	// This list should be empty when we get here
    	CDownloadBuffer* pDownload = m_UnloadedList.GetHead();
    	if(pDownload)
    	{
    		assert(false);
    	}
    	
    	LeaveCriticalSection(&m_DMPortCriticalSection);
#endif
    }

	if (m_fPortCSInitialized)  DeleteCriticalSection(&m_DMPortCriticalSection);
    if (m_fQueueCSInitialized) DeleteCriticalSection(&m_csEventQueues);

    DeleteCriticalSection(&m_OverlappedCriticalSection);

    // Cleanup the array of overlapped structures
    CNode<OverlappedStructs *> *pOverlappedNode, *pOverlappedNext;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNext)
    {
        pOverlappedNext = pOverlappedNode->pNext;

        delete pOverlappedNode->data;
        m_lstOverlappedStructs.RemoveNodeFromList(pOverlappedNode);
    }

    InterlockedDecrement(&g_cComponent);
}

struct KS_PORTPARAMS
{
    KSNODEPROPERTY      ksnp;
    SYNTH_PORTPARAMS    spp;    
};

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Init
//
HRESULT
CDirectMusicPort::Init(LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT hr = E_FAIL;
    BOOL fValidParamChanged = FALSE;

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    if (m_pThruMap == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hr = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to create thruing buffer\n");
        return hr;
    }

    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Get a handle to SysAudio
    //
    if (!OpenDefaultDevice(KSCATEGORY_SYSAUDIO, &m_hSysAudio))
    {
        TraceI(0, "CDirectMusicPort::Init failed to open SysAudio\n");
        return E_FAIL;
    }

    if (!SetSysAudioDevice(m_hSysAudio, m_idxDev))
    {
        TraceI(0, "Failed to set device on SysAudio\n");
        goto Cleanup;
    }

    if (!CreateVirtualSource(m_hSysAudio, &m_ulVirtualSourceIndex)) 
    {   
        TraceI(0, "Failed to create virtual source\n");
        goto Cleanup;
    }

    hr = CreatePin(m_hSysAudio, m_idxPin, &m_hPin);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to create pin: %x\n", hr);
        goto Cleanup;
    }

    if (!AttachVirtualSource(m_hPin, m_ulVirtualSourceIndex))
    {
        TraceI(0, "Failed to attach virtual source\n");
        goto Cleanup;
    }

    // Set port params
    //
    if (pPortParams)
    {
        KS_PORTPARAMS kspp;

        ZeroMemory(&kspp, sizeof(kspp));
        kspp.ksnp.Property.Set    = KSPROPSETID_Synth;
        kspp.ksnp.Property.Id     = KSPROPERTY_SYNTH_PORTPARAMETERS;
        kspp.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
        kspp.ksnp.NodeId          = m_idxSynthNode;
        kspp.ksnp.Reserved        = 0;
        kspp.spp.ValidParams      = pPortParams->dwValidParams;
        kspp.spp.Voices           = pPortParams->dwVoices;
        kspp.spp.ChannelGroups    = pPortParams->dwChannelGroups;
        kspp.spp.AudioChannels    = pPortParams->dwAudioChannels;
        kspp.spp.SampleRate       = pPortParams->dwSampleRate;
        kspp.spp.EffectsFlags     = pPortParams->dwEffectFlags;
        kspp.spp.Share            = pPortParams->fShare;

        assert
        (
            DMUS_PORTPARAMS_VOICES == SYNTH_PORTPARAMS_VOICES &&
            DMUS_PORTPARAMS_CHANNELGROUPS == SYNTH_PORTPARAMS_CHANNELGROUPS &&
            DMUS_PORTPARAMS_AUDIOCHANNELS == SYNTH_PORTPARAMS_AUDIOCHANNELS &&
            DMUS_PORTPARAMS_SAMPLERATE == SYNTH_PORTPARAMS_SAMPLERATE &&
            DMUS_PORTPARAMS_EFFECTS == SYNTH_PORTPARAMS_EFFECTS &&
            DMUS_PORTPARAMS_SHARE == SYNTH_PORTPARAMS_SHARE
        );

        SYNTH_PORTPARAMS spp;
        if (!Property(m_hPin,
                      sizeof(kspp),
                      (PKSIDENTIFIER)&kspp,
                      sizeof(spp),
                      &spp,
                      NULL))
        {
            hr = WIN32ERRORtoHRESULT(GetLastError());
            goto Cleanup;
        }

        if ((pPortParams->dwValidParams != spp.ValidParams) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES) && 
             (pPortParams->dwVoices != spp.Voices)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS) && 
             (pPortParams->dwChannelGroups != spp.ChannelGroups)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS) && 
             (pPortParams->dwAudioChannels != spp.AudioChannels)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE) && 
             (pPortParams->dwSampleRate != spp.SampleRate)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS) && 
             (pPortParams->dwEffectFlags != spp.EffectsFlags)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE) && 
             (pPortParams->fShare != (BOOL) spp.Share)))
        {
            fValidParamChanged = TRUE;

            pPortParams->dwValidParams  = spp.ValidParams;
            pPortParams->dwVoices       = spp.Voices;
            pPortParams->dwChannelGroups= spp.ChannelGroups;
            pPortParams->dwAudioChannels= spp.AudioChannels;
            pPortParams->dwSampleRate   = spp.SampleRate;
            pPortParams->dwEffectFlags  = spp.EffectsFlags;
            pPortParams->fShare         = (BOOL) spp.Share;
        }
            
        TraceI(0, "dmport: create: fValidParamChanged %d\n", 
            (int)fValidParamChanged);

        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else if (FAILED(GetNumChannelGroups(&m_dwChannelGroups)))
        {
            m_dwChannelGroups = 1;
        }

        if (m_fIsOutput)
        {
            InitChannelPriorities(1, m_dwChannelGroups);
        }
    }           

    // create latency clock
    //
    m_pClock = new CPortLatencyClock(m_hPin, m_idxSynthNode, this);
    if (!m_pClock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get our notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_pNotify->Release();

    if (m_fIsOutput)
    {
        // Render only
        //
        // set volume boost default (zero)
        //
        KSNODEPROPERTY ksnp;
        LONG lVolume;

        ksnp.Property.Set   = KSPROPSETID_Synth;
        ksnp.Property.Id    = KSPROPERTY_SYNTH_VOLUMEBOOST;
        ksnp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
        ksnp.NodeId         = m_idxSynthNode;
        ksnp.Reserved       = 0;

        lVolume = 0;

        if (!Property(m_hPin,
                      sizeof(ksnp),
                      (PKSIDENTIFIER)&ksnp,
                      sizeof(lVolume),
                      &lVolume,
                      NULL))
        {
            if (!(dmpc.dwFlags & DMUS_PC_EXTERNAL))
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
                TraceI(0, "Could not set default volume boost %08X\n", hr);
                goto Cleanup;
            }
        }          

        // Initialize download. This creates all the events needed for asynchronously
        // dealing with unload.
        //
        hr = InitializeDownloadObjects();
    }
    else
    {
        // Capture only
        //
        // Set up the thread to post multiple IRP's to the pin and queue the data
        // when it gets to user mode.
        //
        hr = InitializeCapture();
    }

    if (FAILED(hr)) 
    {
        goto Cleanup;
    }

    hr = m_pDM->GetMasterClock(NULL, &m_pMasterClock);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to get master clock\n");
        goto Cleanup;
    }    

#if 0
    // We need to get the handle from the master clock and pass it down to the
    // pin so the timebase will be the same.
    //
    IMasterClockPrivate *pPrivate;

    hr = m_pMasterClock->QueryInterface(IID_IMasterClockPrivate, (void**)&pPrivate);
    if (FAILED(hr)) 
    {
        TraceI(0, "Master clock is not a Ks clock -- cannot instantiate WDM port!\n");
        goto Cleanup;
    }

    HANDLE hClock;
    hr = pPrivate->GetParam(GUID_KsClockHandle, &hClock, sizeof(hClock));
    pPrivate->Release();

    if (FAILED(hr))
    {
        TraceI(0, "Could not get handle of Ks clock\n");
        goto Cleanup;
    }
#endif  // WIN95

    PinSetState(KSSTATE_STOP);

#if 0

    KSPROPERTY ksp;
    
    ksp.Set =   KSPROPSETID_Stream;
    ksp.Id =    KSPROPERTY_STREAM_MASTERCLOCK;    
    ksp.Flags = KSPROPERTY_TYPE_SET;

    if (!Property(m_hPin,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(HANDLE),
                  &hClock,
                  NULL))
    {
        hr = WIN32ERRORtoHRESULT(GetLastError());
        TraceI(0, "Could not set the master clock handle on the kernel pin %08X\n", hr);
        goto Cleanup;
    }           
#endif
 
    PinSetState(KSSTATE_PAUSE);

	TraceI(2, "CDirectMusicPort::Init() Pin %p\n", m_hPin);

#ifdef DXAPI
    // If we have WDM ports, then the default master clock will be the
    // portcls clock.
    //
    hr = m_pDM->GetMasterClockWrapperI()->CreateDefaultMasterClock(&m_pPCClock);
#else
    hr = m_pDM->GetMasterClock(NULL,&m_pPCClock);
#endif
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hr = m_pMasterClock->GetTime(&rtMasterClock);
    if (SUCCEEDED(hr))
    {
        hr = m_pPCClock->GetTime(&rtSlaveClock);
    }

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;
                

    if (fValidParamChanged)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
            
Cleanup:
    if (FAILED(hr))
    {
        Close();
    }
    
    return hr;        
}

//////////////////////////////////////////////////////////////////////
//
// InitializeDownloadObjects
//
// Create the events to handle asynchronous download notification and 
// start the download thread.
//
HRESULT 
CDirectMusicPort::InitializeDownloadObjects()
{
	m_phUnloadEventList = new HANDLE[m_dwNumEventsAllocated];
	if (m_phUnloadEventList == NULL)
	{
        TraceI(0, "Failed to alloc memory for unload event list\n");
		return E_OUTOFMEMORY;
	}
	
	// Used to Kill the unload thread
	m_phUnloadEventList[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
	if(m_phUnloadEventList[0] == NULL)
	{
        TraceI(0, "Failed to create kill event\n");
		return E_FAIL;
	}
	m_dwNumEvents++;

	// Used to Wake unload thread
	m_phUnloadEventList[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
	if(m_phUnloadEventList[1] == NULL)
	{
        TraceI(0, "Failed to create wake event\n");
		return E_FAIL;
	}
	m_dwNumEvents++;

    // Used for asynchronously sending down events

    m_phUnloadEventList[2] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[2] == NULL)
    {
        TraceI(0, "Failed to create overlapped struct event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;

    // Now, use the same event for all the OVERLAPPED structures
    EnterCriticalSection( &m_OverlappedCriticalSection );
    CNode<OverlappedStructs *> *pOverlappedNode;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
    {
        OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
        if( pOverlappedStructs )
        {
            for( int iEvent = 0; iEvent < OVERLAPPED_ARRAY_SIZE; iEvent++ )
            {
                pOverlappedStructs->aOverlappedIO[iEvent].hEvent = m_phUnloadEventList[2];
            }
        }
    }
    LeaveCriticalSection( &m_OverlappedCriticalSection );

	m_hCopiedEventList = CreateEvent(NULL, TRUE, FALSE, NULL);
	if(m_hCopiedEventList == NULL)
	{
        TraceI(0, "Failed to create copy event\n");
		return E_FAIL;
	}
	
	DWORD dwThreadId;

	m_hUnloadThread = CreateThread(NULL, 0, ::FreeWDMHandle, this, 0, &dwThreadId);
	if(m_hUnloadThread == NULL)
	{
		TraceI(0, "Failed to create unload thread\n");
		return E_FAIL;
	} 

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
// InitializeCapture
//
HRESULT
CDirectMusicPort::InitializeCapture()
{
    DWORD dwError;
    DWORD dwThreadId;

    m_hCaptureWake = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hCaptureWake == NULL) 
    {
        dwError = GetLastError();
        TraceI(0, "Failed to create capture thread wakeup event %d\n", dwError);
        return WIN32ERRORtoHRESULT(dwError);
    }

    m_hCaptureThread = CreateThread(NULL, 0, ::CaptureThread, this, 0, &dwThreadId);
    if (m_hCaptureThread == NULL)
    {
        dwError = GetLastError();
        TraceI(0, "Failed to create capture thread %d\n", dwError);
        return WIN32ERRORtoHRESULT(dwError);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::QueryInterface

STDMETHODIMP
CDirectMusicPort::QueryInterface(const IID &iid,
                                 void **ppv)
{
    V_INAME(IDirectMusicPort::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortDownload)
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::AddRef

STDMETHODIMP_(ULONG)
CDirectMusicPort::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Release

STDMETHODIMP_(ULONG)
CDirectMusicPort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {

        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }
        
        delete this;
        return 0;
    }

    return m_cRef;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | Compact | Compacts downloaded DLS data to create a large chunk of contiguous sample memory.
//
// @comm
// The IDirectMusicPort::Compact method is used to instruct the hardware
// or driver to compact DLS/wavetable memory, thus making the largest
// possible contiguous chunk of memory available for new instruments to
// be downloaded.  This method is only valid for an output port that
// supports wavetable synthesis.  This call is passed directly to the
// driver, which handles compacting of the memory whether it is on the
// card or in host memory.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicPort::Compact()
{
    KSNODEPROPERTY      ksnp;

    // Compact takes no parameters
    //
    ksnp.Property.Set     = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_DLS_COMPACT;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  0,
                  NULL,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetCaps | Gets the capabilities of the port.
//
// @comm
// The IDirectMusicPort::GetCaps method retrieves the port's capabilities.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pPortCaps> pointer is invalid.
// @flag E_INVALIDARG | If the <p PortCaps> struct pointed to is not the correct size.
//
STDMETHODIMP
CDirectMusicPort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)          // @parm Pointer to the <t DMUS_PORTCAPS> structure to receive the capabilities of the port.
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | DeviceIoControl | Performs a DeviceIoControl on the underlying
// file handle implementing the port.
//
// @comm
// This method wraps a call to the system DeviceIoControl API on the file handle implementing 
// the port. This method is only supported on ports implemented by a WDM filter graph. In the
// case of a WDM filter graph, the file handle used will be the topmost pin in the graph.
//
// DirectMusic reserves the right to refuse to perform defined KS operations on a pin which 
// might collide with operations it is performing on the filter graph. User defined operations,
// however, will never be blocked.
//
// For more information on the semantics of the DeviceIoControl call, see the Win32 API documentation.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If any of the passed pointers were invalid.
// @flag E_NOTIMPL | If the port is not a WDM port.
// @flag E_INVALIDARG | If the specified IO control code is not allowed (such as IOCTL_KS_PROPERTY). 
//
// Other return codes as defined by the system DeviceIoControl API call or the underlying driver responding
// to the call.
//
STDMETHODIMP 
CDirectMusicPort::DeviceIoControl(
    DWORD dwIoControlCode,              // @parm Control code of operation to perform
    LPVOID lpInBuffer,                  // @parm Pointer to buffer to supply input data
    DWORD nInBufferSize,                // @parm Size of input buffer
    LPVOID lpOutBuffer,                 // @parm Pointer to buffer to receive output buffer
    DWORD nOutBufferSize,               // @parm Size of output buffer
    LPDWORD lpBytesReturned,            // @parm Pointer to variable to receive output byte count
    LPOVERLAPPED lpOverlapped)          // @parm Pointer to overlapped structure for asynrchronous operation
{
    V_INAME(IDirectMusicPort::DeviceIoControl);
    V_BUFPTR_READ_OPT(lpInBuffer, nInBufferSize);
    V_BUFPTR_WRITE_OPT(lpOutBuffer, nOutBufferSize);
    V_PTR_WRITE(lpBytesReturned, DWORD);
    V_PTR_WRITE(lpOverlapped, OVERLAPPED);

    BOOL fResult;

    if (dwIoControlCode == IOCTL_KS_PROPERTY) 
    {
        TraceI(0, "DeviceIoControl: Use IKsControl to set or get property items.");
        return E_INVALIDARG;
    }

    fResult = ::DeviceIoControl(m_hPin,
                                dwIoControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                lpOutBuffer,
                                nOutBufferSize,
                                lpBytesReturned,
                                lpOverlapped);

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | SetNumChannelGroups | Sets the number of channel groups requested for this port.
//
// @comm
// The IDirectMusicPort::SetNumChannelGroups method changes the number
// of channel groups that the application needs on the port.  If the
// number of requested channel groups could not be allocated,
// E_INVALIDARG is returned.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_INVALIDARG | If the requested number of channel groups could not be allocated
//
STDMETHODIMP
CDirectMusicPort::SetNumChannelGroups(
    DWORD dwChannelGroups)      // @parm The number of channel groups on this port that the application wants to allocate.  
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(DWORD),
                  &dwChannelGroups,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    DWORD dwActualChannelGroups = 0;
    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(ksnp),
                   (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   &dwActualChannelGroups,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           

    if( dwActualChannelGroups != dwChannelGroups )
    {
        return E_INVALIDARG;
    }

    if (m_fIsOutput && (dwChannelGroups > m_dwChannelGroups))
    {
        InitChannelPriorities(m_dwChannelGroups + 1, dwChannelGroups);
    }
    
    m_dwChannelGroups = dwChannelGroups;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetNumChannelGroups | Gets the number of channel groups used  for this port.
//
// @comm
// The IDirectMusicPort::GetNumChannelGroups method get the number
// of channel groups that the application is using on the port.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the passed pointer is invalid
//
STDMETHODIMP
CDirectMusicPort::GetNumChannelGroups(
    LPDWORD pdwChannelGroups)      // @parm Contains the number of channel groups currently in use by this port on return
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(ksnp),
                   (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   pdwChannelGroups,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | PlayBuffer | Queues a DirectMusicBuffer object for playback.
//
// @comm
// The IDirectMusicPort::PlayBuffer method is used to queue a
// buffer for playback by the port.  The buffer is only in use by the
// system for the duration of this method and is free to be reused after
// this method returns.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pIBuffer> pointer is invalid.
// @flag E_NOTIMPL | If the port is not an output port.
//
STDMETHODIMP
CDirectMusicPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)               // @parm A pointer to an <i IDirectMusicBuffer> interface representing the
                                                // object which should be added to the port's playback queue.
{
    DWORD cbData;
    LPBYTE pbData;
    REFERENCE_TIME rtStart;
    HRESULT hr;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    if (!m_lActivated)
    {
        return DMUS_E_SYNTHINACTIVE;
    }

    hr = pIBuffer->GetUsedBytes(&cbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetRawBufferPtr(&pbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetStartTime(&rtStart);
    if (FAILED(hr))
    {
        return hr;
    }

    SyncClocks();
    MasterToSlave(&rtStart);

    KSSTREAM_HEADER kssh;
    ULONG cbRet;

    kssh.Size               = sizeof(KSSTREAM_HEADER);
    kssh.TypeSpecificFlags  = 0;

    kssh.PresentationTime.Time        = rtStart;
    kssh.PresentationTime.Numerator   = 1;
    kssh.PresentationTime.Denominator = 1;

    kssh.Duration     = 0;
    kssh.FrameExtent  = cbData;
    kssh.DataUsed     = cbData;
    // Assigned to a temporary buffer later on
    //kssh.Data         = pbData;
    kssh.Data         = 0;
    kssh.OptionsFlags = 0;

    // Try and find an available OVERLAPPED structure
    int iOverlapped;
    OverlappedStructs *pOverlappedStructsToUse = NULL;
    EnterCriticalSection( &m_OverlappedCriticalSection );

    // Iterate through the list of overlapped structure arrays
    CNode<OverlappedStructs *> *pOverlappedNode;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode && !pOverlappedStructsToUse; pOverlappedNode = pOverlappedNode->pNext)
    {
        // get a pointer to each array
        OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
        if( pOverlappedStructs )
        {
            // Iterate through the array
            for( iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
            {
                if( !pOverlappedStructs->afOverlappedInUse[iOverlapped] )
                {
                    // Found a free one - exit the loop
                    pOverlappedStructsToUse = pOverlappedStructs;
                    break;
                }
            }
        }
    }

    // Didn't find a free one
    if( !pOverlappedStructsToUse )
    {
        TraceI(0, "PlayBuffer: Failed to find a free OVERLAPPED structure - trying to free one\n");

        // Iterate through the list of overlapped structure arrays
        for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode && !pOverlappedStructsToUse; pOverlappedNode = pOverlappedNode->pNext)
        {
            // get a pointer to each array
            OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
            if( pOverlappedStructs )
            {
                // Iterate through the array
                for( iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                {
                    if( HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                    {
                        // Found a completed one - exit the loop and re-use it
                        pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                        delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                        pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;
                        pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;

                        pOverlappedStructsToUse = pOverlappedStructs;
                        break;
                    }
                }
            }
        }

        // Still didn't find a free one
        if( !pOverlappedStructsToUse )
        {
            TraceI(0, "PlayBuffer: All OVERLAPPED structures in use - creating new ones\n");

            // Create a new structure with another 200 OVERLAPPED structures
            OverlappedStructs *pOverlappedStructs = new OverlappedStructs;
            if( pOverlappedStructs )
            {
                // If we could allocate the memory, add it to the list
                if( NULL != m_lstOverlappedStructs.AddNodeToList( pOverlappedStructs ) )
                {
                    // Initialize the array of structures
                    ZeroMemory( pOverlappedStructs->aOverlappedIO, sizeof( OVERLAPPED ) * OVERLAPPED_ARRAY_SIZE );
                    ZeroMemory( pOverlappedStructs->afOverlappedInUse, sizeof( BOOL ) * OVERLAPPED_ARRAY_SIZE );
                    ZeroMemory( pOverlappedStructs->apOverlappedBuffer, sizeof( BYTE * ) * OVERLAPPED_ARRAY_SIZE );
                    for( int iEvent = 0; iEvent < OVERLAPPED_ARRAY_SIZE; iEvent++ )
                    {
                        pOverlappedStructs->aOverlappedIO[iEvent].hEvent = m_phUnloadEventList[2];
                    }

                    // Now, flag to use the first item in the new structure
                    pOverlappedStructsToUse = pOverlappedStructs;
                    iOverlapped = 0;
                }
                else
                {
                    // Out of memory - fail
                    delete pOverlappedStructs;
                    LeaveCriticalSection( &m_OverlappedCriticalSection );
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                // Out of memory - fail
                LeaveCriticalSection( &m_OverlappedCriticalSection );
                return E_OUTOFMEMORY;
            }
        }
    }

    // Try and allocate a buffer to store the memory in while the driver is using it
    pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] = new BYTE[cbData];
    if( NULL == pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] )
    {
        // Out of memory - fail
        LeaveCriticalSection( &m_OverlappedCriticalSection );
        return E_OUTOFMEMORY;
    }
    CopyMemory(pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped], pbData, cbData);

    // Set the KS Stream to use the just-allocated buffer
    kssh.Data         = pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped];

    // Mark the OVERLAPPED structure as in use
    pOverlappedStructsToUse->afOverlappedInUse[iOverlapped] = TRUE;

    BOOL fResult;
    fResult = ::DeviceIoControl(m_hPin, 
                                IOCTL_KS_WRITE_STREAM, 
                                &kssh, 
                                sizeof(KSSTREAM_HEADER), 
                                &kssh, 
                                sizeof(KSSTREAM_HEADER), 
                                &cbRet, 
                                &(pOverlappedStructsToUse->aOverlappedIO[iOverlapped]));

    // If we failed
    if( !fResult )
    {
        // Get the error code
        DWORD dwErrorCode = GetLastError();

        // If we're just pending
        if( ERROR_IO_PENDING == dwErrorCode )
        {
            // That's expected - return S_OK
            hr = S_OK;
        }
        else
        {
            // Other error - convert to a HRESULT
            hr = WIN32ERRORtoHRESULT( dwErrorCode );

            // Mark the OVERLAPPED structure as free
            pOverlappedStructsToUse->afOverlappedInUse[iOverlapped] = FALSE;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].Internal = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].InternalHigh = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].Offset = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].OffsetHigh = 0;

            // Free the memory we allocated
            delete pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped];
            pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] = NULL;
        }
    }
    else
    {
        // We succeeded - return S_OK
        hr = S_OK;
    }

    LeaveCriticalSection( &m_OverlappedCriticalSection );

    return hr;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | SetReadNotificationHandle | Sets an event to pulse when music data has been captured.
//
// @comm
// The IDirectMusicPort::SetReadNotificationHandle method sets the event
// notification status. This method specifies an event that is to be set
// when MIDI messages are available to be read with the
// <om IDirectMusicPort::Read> method. The event will be pulsed whenever new
// data is available.  To turn off event notification, call
// SetEventNotification with a NULL value for the hEvent parameter.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// 
STDMETHODIMP
CDirectMusicPort::SetReadNotificationHandle(
    HANDLE hEvent)              // @parm  An event handle returned from the Window's CreateEvent call.  It identifies the
                                // event that is to be notified when data is available to be read.
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    m_hAppEvent = hEvent;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | Read | Reads captured music data into a DirectMusicBuffer.
//
// @comm
//
// The IDirectMusicPort::Read method fills the buffer object with
// incoming MIDI data.  Read should be called with new buffer objects
// until no more data is available to be read.  When there is no more
// data to read, the method returns S_FALSE.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pIBuffer> pointer is invalid.
// @flag E_NOTIMPL | If the port is not an input port.


STDMETHODIMP
CDirectMusicPort::Read(
    IDirectMusicBuffer *pIBuffer)                          // @parm A buffer that will be filled with incoming MIDI data
{
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }


    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }
    
    LPBYTE pbBuffer;
    HRESULT hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    TraceI(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart= 0;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        TraceI(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {               
        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;

        DWORD cbQueuedEvent = DMUS_EVENT_SIZE(pQueuedEvent->e.cbEvent);
        TraceI(2, "Read: cbEvent %u  cbQueuedEvent %u\n", 
            pQueuedEvent->e.cbEvent,
            cbQueuedEvent);

        if (cbQueuedEvent > cbBuffer)
        {
            TraceI(2, "Read: No more room for events in buffer.\n");
            break;
        }

        TraceI(2, "Read: Got an event!\n");

        pQueuedEvent->e.rtDelta -= rtStart;

        CopyMemory(pbData, 
                   &pQueuedEvent->e,
                   sizeof(DMEVENT) - sizeof(DWORD) + pQueuedEvent->e.cbEvent);

        pbData += cbQueuedEvent;
        cbBuffer -= cbQueuedEvent;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.cbEvent <= sizeof(DWORD))
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
        else
        {
            // This event was allocated via new char[]
            //
            char *pOriginalMemory = (char*)pQueuedEvent;
            delete[] pOriginalMemory;
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    TraceI(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes((DWORD)(pbData - pbBuffer));

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}
/*
@struct DMUS_NOTERANGE | Contains a range of notes. An array of 
<t DMUS_NOTERANGE> structures is used as an optional parameter
by <om IDirectMusicPort::DownloadInstrument> to 
determine which regions within the DLS instrument to download. 

@field DWORD | dwSize | Contains the total size in bytes of the structure
@field DWORD | dwLowNote | Sets the low note for the range within the 
<i IDirectMusicInstrument> to download.
@field DWORD | dwHighNote | Sets the high note for the range within the 
<i IDirectMusicInstrument> to download.

@xref <om IDirectMusicPort::DownloadInstrument>, 
<om IDirectMusicPerformance::DownloadInstrument>
*/

/*
@method:(EXTERNAL) HRESULT | IDirectMusicPort | DownloadInstrument | 
Downloads an <i IDirectMusicInstrument> to the port.

<om IDirectMusicPort::DownloadInstrument> pulls the 
instrument data from <p pInstrument> 
and sends it to the synthesizer. 

The instrument is parsed and converted into a series of 
instrument articulation and wave memory chunks. In addition, if
the waves are compressed, the download operation decompresses the
waves and write the uncompressed data into the memory chunks.

The optional <p pNoteRanges> parameter allows the caller to 
economize on allocated memory. When specificed, only the wave and
articulation data for the required ranges of notes are downloaded.

The address of an <i IDirectMusicDownloadedInstrument> interface pointer,
which is later used to unload the instrument, is returned.

@rdesc Returns one of the following:
@flag S_OK | The operation completed successfully.
@flag E_POINTER | If any of the pointers is invalid
@flag E_NOTIMPL | If the port does not support DLS.

@xref <i IDirectMusic>, 
<i IDirectMusicPort>,
<om IDirectMusicSynth::Download>,
<om IDirectMusicBand::Download>,
<om IDirectMusicPerformance::DownloadInstrument>
*/
STDMETHODIMP
CDirectMusicPort::DownloadInstrument(
    IDirectMusicInstrument* pInstrument,                        // @parm Contains a pointer to an <i IDirectMusicInstrument> object
                                                                // from which <om IDirectMusicPort::Download> extracts the necessary
                                                                // instrument data to be downloaded.
                           
    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,   // @parm Address of the <i IDirectMusicDownloadedInstrument> interface pointer.
                                                                // This interface pointer is later used to unload the instrument with a call
                                                                // to <om IDirectMusicPort::Unload>.
                           
    DMUS_NOTERANGE* pNoteRanges,                                // @parm An optional pointer to an array of <t DMUS_NOTERANGE>
                                                                // structures. Each <t DMUS_NOTERANGE> structure in the array specifies a
                                                                // contiguous range of MIDI notes to which the instrument must
                                                                // respond. An instrument region will be downloaded only if at least one
                                                                // note in that region is specified in the <t DMUS_NOTERANGE> structures.  If
                                                                // none of the notes contained within a specific instrument region is
                                                                // included in any of the <t DMUS_NOTERANGE> structures, then that region and
                                                                // its associated wave data will not be downloaded. This allows for the
                                                                // more efficient usage of the device's resources as well as improved
                                                                // efficiency of downloads.
																// However, if the entire instrument is desired (and that is usually the
																// case,) <p pNoteRanges> can be set
																// to NULL.
   
    DWORD dwNumNoteRanges)                                      // @parm The number of <t DMUS_NOTERANGE> structures in the array pointed to by
                                                                // <p pNoteRanges>. If this value is set to 0, <p pNoteRanges> is
                                                                // ignored and all regions and wave data for the instrument are downloaded.
{
    V_INAME(IDirectMusicPort::DownloadInstrument);
    V_INTERFACE(pInstrument);
	V_PTRPTR_WRITE(ppDownloadedInstrument);
	V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fCanDownload)
    {
        return E_NOTIMPL;
    }

	return CDirectMusicPortDownload::DownloadP(pInstrument,
											   ppDownloadedInstrument,
											   pNoteRanges,
											   dwNumNoteRanges,
                                               TRUE);
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicPort | UnloadInstrument | 
Unloads an instrument
previously downloaded with <om IDirectMusicPort::Download>. Once an
instrument has been unloaded it is no longer available to process
MIDI messages.

@rdesc Returns one of the following
@flag S_OK | The operation completed successfully.
@flag E_POINTER | If the <p pDownloadedInstrument> pointer is invalid.
@flag E_NOTIMPL | If the port does not support DLS.

@xref <i IDirectMusic>, 
<i IDirectMusicPort>,
<om IDirectMusicSynth::Unload>,
<om IDirectMusicBand::Unload>,
<om IDirectMusicPerformance::UnloadInstrument>
*/

STDMETHODIMP
CDirectMusicPort::UnloadInstrument(
	IDirectMusicDownloadedInstrument* pDownloadedInstrument)	// @parm Pointer to an <i IDirectMusicDownloadedInstrument> interface.
                                                                // This interface pointer was obtained by a call to 
																// <om IDirectMusicPort::DownloadInstrument>.
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fCanDownload)
    {
        return E_NOTIMPL;
    }

	return CDirectMusicPortDownload::UnloadP(pDownloadedInstrument);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Download

typedef struct 
{
    KSNODEPROPERTY  ksnp;
    SYNTH_BUFFER    dlsBuffer;
} KSPROPERTY_DOWNLOAD;

STDMETHODIMP 
CDirectMusicPort::Download(IDirectMusicDownload* pIDMDownload)
{
    V_INAME(IDirectMusicPort::Download);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);

	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();		

		hr = ((CDownloadBuffer *)pIDMDownload)->IsDownloaded();
		if(hr != S_FALSE)
		{
			LeaveCriticalSection(&m_DMDLCriticalSection);
			return DMUS_E_ALREADY_DOWNLOADED;
		}

		void* pvBuffer = NULL;
        DWORD dwSize;
		hr = ((CDownloadBuffer *)pIDMDownload)->GetBuffer(&pvBuffer, &dwSize);

		if(pvBuffer == NULL)
		{
			hr = DMUS_E_BUFFERNOTSET;
		}

		if(SUCCEEDED(hr))
		{
			KSPROPERTY_DOWNLOAD kspDownload;
			SYNTHDOWNLOAD sd;
            ULONG ulBytesReturned;

            ZeroMemory(&kspDownload, sizeof(kspDownload));
			kspDownload.ksnp.Property.Set    = KSPROPSETID_Synth_Dls;
			kspDownload.ksnp.Property.Id     = KSPROPERTY_SYNTH_DLS_DOWNLOAD;
			kspDownload.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
			kspDownload.ksnp.NodeId          = m_idxSynthNode;
		    kspDownload.ksnp.Reserved        = 0;

            kspDownload.dlsBuffer.BufferSize    = dwSize;
            kspDownload.dlsBuffer.BufferAddress = pvBuffer;

			if (!Property(m_hPin,
						  sizeof(kspDownload),
						  (PKSIDENTIFIER)&kspDownload,
						  sizeof(sd),
						  &sd,
						  &ulBytesReturned))
			{
				hr = WIN32ERRORtoHRESULT(GetLastError());
			}           
            else if (ulBytesReturned < sizeof(sd))
            {
                hr = DMUS_E_DRIVER_FAILED;
            }
			else
			{
				hr = S_OK;
			}

			if(SUCCEEDED(hr))
			{
                ((CDownloadBuffer *)pIDMDownload)->m_DLHandle = sd.DownloadHandle;

				// AddRef() before we add it to the list.
				pIDMDownload->AddRef();
                DWORD dwID = ((DMUS_DOWNLOADINFO*)pvBuffer)->dwDLId;
				((CDownloadBuffer *)pIDMDownload)->m_dwDLId = dwID;
				m_DLBufferList[dwID % DLB_HASH_SIZE].AddHead((CDownloadBuffer*)pIDMDownload);

				((CDownloadBuffer*)pIDMDownload)->IncDownloadCount();

				if(sd.Free)
				{
					pvBuffer = NULL;
                    DWORD dw;
					((CDownloadBuffer *)pIDMDownload)->GetHeader(&pvBuffer, &dw);
					((CDownloadBuffer *)pIDMDownload)->SetBuffer(NULL, 0, 0);
					delete [] pvBuffer;
				}
				else
				{
					// If we do not free buffer we need to AddRef()
					// We do not want buffer to go away until the IDirectMusicPort is 
					// finished with it.
					pIDMDownload->AddRef();
				}
			}
			else if(FAILED(hr))
			{
				((CDownloadBuffer *)pIDMDownload)->m_DLHandle = NULL;
			}
		}
	}
	
	LeaveCriticalSection(&m_DMDLCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Unload

STDMETHODIMP 
CDirectMusicPort::Unload(IDirectMusicDownload* pIDMDownload)
{
    V_INAME(IDirectMusicPort::Unload);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);

	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();

        if (((CDownloadBuffer *)pIDMDownload)->IsDownloaded() == S_OK)
        {
		    if(((CDownloadBuffer *)pIDMDownload)->DecDownloadCount() == 0)
		    {
			    m_DLBufferList[((CDownloadBuffer *)pIDMDownload)->m_dwDLId % DLB_HASH_SIZE].Remove((CDownloadBuffer *)pIDMDownload);

#if 0
			    if(m_dwNumEvents < m_dwNumEventsAllocated)
			    {
				    m_phUnloadEventList[m_dwNumEvents] = CreateEvent(NULL, TRUE, FALSE, NULL);
				    m_dwNumEvents++;
			    }
			    else
			    {
				    // Allocate more handles
			    }
#endif
			    
			    KSNODEPROPERTY ksnp;

			    ksnp.Property.Set = KSPROPSETID_Synth_Dls;
			    ksnp.Property.Id = KSPROPERTY_SYNTH_DLS_UNLOAD;
			    ksnp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
			    ksnp.NodeId = m_idxSynthNode;
		        ksnp.Reserved = 0;
			    
			    HANDLE hDLHandle = ((CDownloadBuffer *)pIDMDownload)->m_DLHandle;

#if 0
			    if (!PropertyAsync(m_hPin,
							       sizeof(ksnp),
						           (PKSIDENTIFIER)&ksnp,
						           sizeof(HANDLE),
							       &hDLHandle,
							       NULL,
                                   &(((CDownloadBuffer *)pIDMDownload)->m_DLHandle))) // XXX DLHandle is not currently event handle!!!
			    {
				    hr = WIN32ERRORtoHRESULT(GetLastError());
			    }           
			    else
			    {
				    void* pBuffer = NULL;
				    ((CDownloadBuffer*)pIDMDownload)->GetBuffer(&pBuffer);

				    if(pBuffer == NULL && WaitForSingleObject((((CDownloadBuffer *)pIDMDownload)->m_DLHandle), 0) == WAIT_OBJECT_0)
				    {
					    pIDMDownload->Release();
				    }
				    else
				    {
					    m_UnloadedList.AddTail((CDownloadBuffer*)pIDMDownload);
				    }
				    
				    hr = S_OK;
			    }
#else
                if (!Property(m_hPin,
                              sizeof(ksnp),
                              (PKSIDENTIFIER)&ksnp,
                              sizeof(HANDLE),
                              &hDLHandle,
                              NULL))
                {
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }           
                else
                {
                    pIDMDownload->Release();
                    hr = S_OK;
                }
#endif
            }
		}
        else
        {
            TraceI(0, "CDirectMusicPort::Unload- not downloaded\n");
        }
	}

	LeaveCriticalSection(&m_DMDLCriticalSection);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetAppend

STDMETHODIMP 
CDirectMusicPort::GetAppend(DWORD* pdwAppend)
{
	V_INAME(IDirectMusicPort::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    if(!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY ksnp;

    ksnp.Property.Set = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id = KSPROPERTY_SYNTH_DLS_APPEND;
    ksnp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId = m_idxSynthNode;
    ksnp.Reserved = 0;

    ULONG ulBytesReturned;
    if((!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   pdwAppend,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetLatencyClock | Gets an <i IReferenceClock> which returns the port's latency clock.
//
// @comm
// The IDirectMusicPort::GetLatencyClock is used to get an
// IReferenceClock interface pointer to the port's latency clock.  The
// latency clock specifies the nearest time in the future at which an
// event can be played on time.  The latency clock is based on the
// DirectMusic master clock, which is set with
// <om IDirectMusic::SetMasterClock>.  
//
// In accordance with COM rules, GetLatencyClock performs an AddRef on the
// returned interface. Therefore the application must call Release on the returned
// interface at some point.
//
// @rdesc
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p ppClock> pointer is invalid
//
STDMETHODIMP
CDirectMusicPort::GetLatencyClock(
    IReferenceClock **ppClock)              // @parm Address of the latency clock's <i IReferenceClock> interface pointer.
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pClock->AddRef();
    *ppClock = m_pClock;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetRunningStats | Gets detailed statistics about the performance of a software synthesizer.
//
// @comm
//
// The IDirectMusicPort::GetRunningStats method fills in a
// <t DMUS_SYNTHSTATS> structure with the current information about the state
// of the port's synthesizer.  See the <t DMUS_SYNTHSTATS> structure for
// details on the type of data that is reported with regards to the
// synthesizer's current status.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pStats> pointer was invalid.
// @flag E_INVALIDARG | The given <p pStats> struct was not the correct size.
// @flag E_NOTIMPL | If the port is not a software synthesizer.
//
STDMETHODIMP
CDirectMusicPort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)                                // @parm Pointer to the <t DMUS_SYNTHSTATS> structure to receive
                                                            // running statistics of the synthesizer.
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);
    
    if(!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY ksnp;

    ksnp.Property.Set = KSPROPSETID_Synth;
    ksnp.Property.Id = KSPROPERTY_SYNTH_RUNNINGSTATS;
    ksnp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId = m_idxSynthNode;
    ksnp.Reserved = 0;

    ULONG ulBytesReturned;

    SYNTH_STATS stats;

    if((!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(stats),
                  &stats,
                  &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(stats)))
    {
        TraceI(1, "GetRunningStats: GetLastError() %d\n", GetLastError());
        return E_NOTIMPL;
    }           

    pStats->dwValidStats    = stats.ValidStats;
    pStats->dwVoices        = stats.Voices;
    pStats->dwTotalCPU      = stats.TotalCPU;
    pStats->dwCPUPerVoice   = stats.CPUPerVoice;
    pStats->dwLostNotes     = stats.LostNotes;
    pStats->dwFreeMemory    = stats.FreeMemory;
    pStats->lPeakVolume     = stats.PeakVolume;
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Activate

STDMETHODIMP
CDirectMusicPort::Activate(
    BOOL fActivate)
{
	V_INAME(IDirectMusicPort::Activate);


    if (fActivate)
    {
        if (m_fAudioDest && !m_fDirectSoundSet)
        {
            BOOL fGotDSound = FALSE;

            // Note: If any of this fails, will fall back to preferred 
            // device set up at port create.
            //
            LPDIRECTSOUND pDSound;
            if (FAILED(m_pDM->GetDirectSoundI(&pDSound))) 
            {
                TraceI(0, "Failed to get DSound from DirectMusic object!\n");
            } 
            else
            {
#ifndef XBOX
                if (SUCCEEDED(SetDirectSoundI(pDSound, NULL, FALSE)))
                {
                    fGotDSound = TRUE;
                }
                else
                {
                    TraceI(0, "Failed to set DSound on port!\n");
                }
#endif
                m_pDM->ReleaseDirectSoundI();
            }
        }

        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }

	
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    BOOL fResult = PinSetState(fActivate ? KSSTATE_RUN : KSSTATE_ACQUIRE);

    if (fResult && fActivate)
    {
        m_fHasActivated = TRUE;
    }

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::SetChannelPriority

typedef struct 
{
    KSNODEPROPERTY              ksnp;
    SYNTHVOICEPRIORITY_INSTANCE vpi;
} KSPROPERTY_VOICEPRIORITY;

STDMETHODIMP 
CDirectMusicPort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    KSPROPERTY_VOICEPRIORITY kvp;
    
    ZeroMemory(&kvp, sizeof(kvp));
    kvp.ksnp.Property.Set    = KSPROPSETID_Synth;
    kvp.ksnp.Property.Id     = KSPROPERTY_SYNTH_VOICEPRIORITY;
    kvp.ksnp.Property.Flags  = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    kvp.ksnp.NodeId          = m_idxSynthNode;
    kvp.ksnp.Reserved        = 0;

    kvp.vpi.ChannelGroup = dwChannelGroup;
    kvp.vpi.Channel      = dwChannel;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(kvp),
                   (PKSIDENTIFIER)&kvp,
                   sizeof(DWORD),
                   &dwPriority,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           

    return S_OK;    
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetChannelPriority

STDMETHODIMP 
CDirectMusicPort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    V_INAME(IDirectMusicPort::GetChannelPriority);
    V_PTR_WRITE(pdwPriority, DWORD);

    KSPROPERTY_VOICEPRIORITY kvp;
    
    ZeroMemory(&kvp, sizeof(kvp));
    kvp.ksnp.Property.Set    = KSPROPSETID_Synth;
    kvp.ksnp.Property.Id     = KSPROPERTY_SYNTH_VOICEPRIORITY;
    kvp.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    kvp.ksnp.NodeId          = m_idxSynthNode;
    kvp.ksnp.Reserved        = 0;

    kvp.vpi.ChannelGroup = dwChannelGroup;
    kvp.vpi.Channel      = dwChannel;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(kvp),
                   (PKSIDENTIFIER)&kvp,
                   sizeof(DWORD),
                   pdwPriority,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           

    return S_OK;    
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::SetDirectSound

STDMETHODIMP
CDirectMusicPort::SetDirectSound(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
#ifndef XBOX
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (m_fHasActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer && !pDirectSound)
    {
        return E_INVALIDARG;
    }

    return SetDirectSoundI(pDirectSound, pDirectSoundBuffer, TRUE);
#else
    return S_OK;
#endif
}

#ifndef XBOX
HRESULT
CDirectMusicPort::SetDirectSoundI(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer,
    BOOL fSetByUser)
{
    LPSTR pstrInterface = NULL;
    HRESULT hr = DirectSoundDevice(pDirectSound, &pstrInterface);
    if (FAILED(hr)) 
    {
        return hr;
    }

    PORTENTRY *pPort = m_pDM->GetPortByGUID(m_guidPort);

    LPSTR pstrInstanceId = NULL;

    if ((pPort == NULL) ||
        (!(pPort->fAudioDest)) ||
        (!DINameToInstanceId(pstrInterface, &pstrInstanceId)))
    {
        delete[] pstrInterface;
        return DMUS_E_DRIVER_FAILED;
    }

    // We don't need this anymore
    delete[] pstrInterface;

    CNode<PORTDEST *> *pNode;
    PORTDEST *pDest;

    for (pNode = pPort->lstDestinations.GetListHead(); 
         pNode; 
         pNode = pNode->pNext)
    {
        pDest = pNode->data;

        if (!_stricmp(pDest->pstrInstanceId, pstrInstanceId))
        {
            m_idxDev = pDest->idxDevice;
            m_idxPin = pDest->idxPin;
            m_idxSynthNode = pDest->idxNode;

            delete[] pstrInstanceId;

            if (!m_fDirectSoundSet && fSetByUser)
            {
                m_fDirectSoundSet = TRUE;
            }

            return pDirectSoundBuffer ? DMUS_S_NOBUFFERCONTROL  : S_OK;
        }
    }

    delete[] pstrInstanceId;
    return DMUS_E_DRIVER_FAILED;    
}
#endif

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetFormat

STDMETHODIMP
CDirectMusicPort::GetFormat(
    LPWAVEFORMATEX pwfex,
    LPDWORD pdwwfex,
    LPDWORD pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

	BOOL fSizeQuery = (pwfex == NULL);

	// kernel mode drivers don't use the buffer size parameter
	//

	if (pcbBuffer != NULL)
	{
	    *pcbBuffer = 0;
	}

    KSNODEPROPERTY      ksnp;
	
    ksnp.Property.Set     = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_DLS_WAVEFORMAT;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

	// If we're doing a size query, use a WAVEFORMATEX on the stack
	//
	if (fSizeQuery)
	{
		WAVEFORMATEX wfex;

		DWORD cb = sizeof(WAVEFORMATEX);
		if (!Property(m_hPin,
					  sizeof(ksnp),
					  (PKSIDENTIFIER)&ksnp,
					  cb,
					  &wfex,
					  &cb))
		{
			DWORD dwError = GetLastError();
			
			if (dwError != ERROR_INSUFFICIENT_BUFFER)
			{
				return WIN32ERRORtoHRESULT(dwError);
			}
		}

        // ERROR_INSUFFICIENT_BUFFER or success (the format fit in our wfex). 
        // We should have back the amount of space the driver needed for 
        // the format.
        //
		*pdwwfex = cb;
		return S_OK;
	}

	assert(pwfex);

	// Not a size query, just fill the user's wfex buffer
	//
    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
				  *pdwwfex,
                  pwfex,
                  pdwwfex))
	{
		return WIN32ERRORtoHRESULT(GetLastError());
	}

    return S_OK;
}

// CDirectMusicPort::DownloadWave
//
STDMETHODIMP 
CDirectMusicPort::DownloadWave(
    IDirectSoundWave *pWave,               
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

// CDirectMusicPort::UnloadWave
//
STDMETHODIMP 
CDirectMusicPort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

            
// CDirectMusicPort::AllocVoice
//
STDMETHODIMP 
CDirectMusicPort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,         
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}        

// CDirectMusicPort::SetSink
//
STDMETHODIMP 
CDirectMusicPort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_INTERFACE(pSinkConnect);

    return E_NOTIMPL;
}

// CDirectMusicPort::GetSink
//
STDMETHODIMP 
CDirectMusicPort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_PTRPTR_WRITE(ppSinkConnect);

    return E_NOTIMPL;
}
#ifndef XBOX
// CDirectMusicPort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicPort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}    
#else
STDMETHODIMP 
CDirectMusicPort::AssignChannelToOutput(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
        IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
        DWORD dwMixBins,
        BYTE *pbControllers)
{
    return E_NOTIMPL;
}    

#endif
// CDirectMusicPort::ThruChannel
//
STDMETHODIMP 
CDirectMusicPort::ThruChannel(
    DWORD dwSourceChannelGroup, 
    DWORD dwSourceChannel, 
    DWORD dwDestinationChannelGroup,
    DWORD dwDestinationChannel,
    LPDIRECTMUSICPORT pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }    

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    // XXX Fix this!
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        TraceI(0, "ThruChannel: dwSourceChannelGroup %d is invalid\n", dwSourceChannelGroup);
        return E_INVALIDARG;
    }
    
    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpcDest;
        dmpc.dwSize = sizeof(dmpcDest);
        HRESULT hr = pDestinationPort->GetCaps(&dmpcDest);
        if (FAILED(hr))
        {
            TraceI(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpcDest.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups) 
        {
            TraceI(0, "ThruChannel: dwDestinationChannelGroup %d is invalid -or- \n", dwDestinationChannelGroup);
            TraceI(0, "ThruChannel: dwDestinationChannel %d is invalid\n", dwDestinationChannel);
            TraceI(0, "ThruChannel: Destination has %d channel groups\n", dmpcDest.dwMaxChannelGroups);

            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;
        m_pThruMap[dwSourceChannel].fThruInWin16 = FALSE;

        TraceI(2, "ThruChannel: From (%u,%u) -> (%u,%u,%p)\n",
            dwSourceChannelGroup,
            dwSourceChannel,
            dwDestinationChannelGroup,
            dwDestinationChannel,
            pDestinationPort);

        pDestinationPort->AddRef();
    } 
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Close

STDMETHODIMP
CDirectMusicPort::Close()
{
    if (m_hPin != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPin);
        m_hPin = INVALID_HANDLE_VALUE;
    }

    if (m_hSysAudio != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hSysAudio);
        m_hSysAudio = INVALID_HANDLE_VALUE;
    }

    if (m_hCaptureThread != NULL)
    {
        m_fShutdownThread = TRUE;
        SetEvent(m_hCaptureWake);
        if (WaitForSingleObject(m_hCaptureThread, 5000) == WAIT_TIMEOUT)
        {
            TraceI(0, "Capture thread refused to die.\n");
        }

        CloseHandle(m_hCaptureThread);
        m_hCaptureThread = NULL;
    }

	if (m_hCopiedEventList != NULL)
	{
        CloseHandle(m_hCopiedEventList);
        m_hCopiedEventList = NULL;
	}

	if (m_phUnloadEventList)
    {
        BOOL bStatus = SetEvent(m_phUnloadEventList[0]);

#ifdef DBG	
	    if(!bStatus)
	    {
		    TraceI(0, "Failed to SetEvent used to notify unload thread to terminate\n");
	    }
#endif
        
        if (m_hUnloadThread)
        {
            WaitForSingleObject(m_hUnloadThread, INFINITE);
        }

        // Clean up the OVERLAPPED array

        // Continue waiting until all overlapped IO has completed
        BOOL fContinue = TRUE;
        while( fContinue )
        {
            // First clear the event and fContinue flag
            ResetEvent( m_phUnloadEventList[2] );
            fContinue = FALSE;

            // Check if any IO has not yet completed
            EnterCriticalSection( &m_OverlappedCriticalSection );

            // Iterate through the list of overlapped structure arrays
            CNode<OverlappedStructs *> *pOverlappedNode;
            for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
            {
                // get a pointer to each array
                OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
                if( pOverlappedStructs )
                {
                    // Iterate through the array
                    for( int iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                    {
                        // Only look at the structures that are in use
                        if( pOverlappedStructs->afOverlappedInUse[iOverlapped] )
                        {
                            if( HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                            {
                                // Found a completed one - clean it up
                                pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                                delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                                pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;

                                // Flag the structure as available
                                pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;
                            }
                            else
                            {
                                // Still waiting for the IO to complete
                                fContinue = TRUE;
                            }
                        }
                    }
                }
            }

            LeaveCriticalSection( &m_OverlappedCriticalSection );

            // If continuing, wait until the event is signaled
            if( fContinue )
            {
                if (WaitForSingleObject(m_phUnloadEventList[2], 1000) == WAIT_TIMEOUT) 
                {
                    TraceI(0, "Close: overlapped IO is taking very long to complete.\n");
                }
            }
        }

	    // Cleanup all allocated events
	    for(DWORD dwCount = 0; dwCount < m_dwNumEvents; dwCount++)
	    {
		    if(m_phUnloadEventList[dwCount])
		    {
			    CloseHandle(m_phUnloadEventList[dwCount]);
			    m_phUnloadEventList[dwCount] = NULL;
		    }
	    }
    
	    delete [] m_phUnloadEventList;
        m_phUnloadEventList = NULL;
    }

    if (m_hUnloadThread)
    {
        CloseHandle(m_hUnloadThread);
        m_hUnloadThread = NULL;
    }

    if (m_phNewUnloadEventList)
    {
        delete [] m_phNewUnloadEventList;
        m_phNewUnloadEventList = NULL;
    }

	if (m_pClock)
    {
        m_pClock->Release();
        m_pClock = NULL;
    }

    if (m_pPCClock)
    {
        m_pPCClock->Release();
        m_pPCClock = NULL;
    }

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pThruMap)
    {
        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    m_pDM = NULL;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::StartVoice
//
STDMETHODIMP CDirectMusicPort::StartVoice(          
     DWORD dwVoiceId,
     DWORD dwChannel,
     DWORD dwChannelGroup,
     REFERENCE_TIME rtStart,
     DWORD dwDLId,
     LONG prPitch,
     LONG vrVolume,
     SAMPLE_TIME stVoiceStart,
     SAMPLE_TIME stLoopStart,
     SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::StopVoice
//
STDMETHODIMP CDirectMusicPort::StopVoice(          
     DWORD dwVoiceId,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetVoiceState
//
STDMETHODIMP CDirectMusicPort::GetVoiceState(
    DWORD dwVoice[], 
    DWORD cbVoice,
    DMUS_VOICE_STATE dwVoiceState[]) 
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSynthPort::Refresh
//
STDMETHODIMP CDirectMusicPort::Refresh(
    DWORD dwDownloadId,
    DWORD dwFlags)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSynthPort::IsReadyForData
//
STDMETHODIMP CDirectMusicPort::IsReadyForData(
    DWORD dwDownloadId)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

/*
@method:(EXTERNAL) HRESULT | IKsControl | KsProperty | Get or set the value of a property.

This method forwards a property request to the port. A property request consists of a property set
and id to set or get, and associated data. In some cases instance data is required to specify which
instance of a property should should be accessed.

The operation performed and property to be accessed are specicified by a <c KSPROPERTY> structure. This 
structure contains Set and Id members which specify the property item to access. The Flags field may contain
exactly one of the following flags to specify the operation:

@flag KSPROPERTY_TYPE_GET | To retrieve the given property item's value
@flag KSPROPERTY_TYPE_SET | To store the given property item's valud
@flag KSPROPERTY_TYPE_BASICSUPPORT | To determine the type of support available for the property set

For KSPROPERTY_TYPE_BASICSUPPORT, the data returned in <p *pvPropertyData> will be a DWORD containing these same
flags indicating which operations are possible.

@ex The following code uses KsProperty to determine if the port supports General MIDI in hardware:

    BOOL IsGMSupported(IDirectMusicPort *pPort)
    {
        HRESULT     hr;
        IKsControl  *pControl;
        KSPROPERTY  ksp;
        DWORD       dwIsSupported;
        ULONG       cb;
        BOOL        fIsSupported;

        hr = pPort->QueryInterface(IID_IKsControl, (void**)&pControl);
        if (FAILED(hr))
        {
            // Port does not support properties, assume no GM support
            //
            return FALSE;
        }

        // Ask about GM
        //
        ksp.Set   = GUID_DMUS_PROP_GM_Hardware;
        ksp.Id    = 0;                            // Per dmusicc.h, item 0 is support, which returns a DWORD boolean
        ksp.Flags = KSPROPERTY_TYPE_GET;          // Retrieve the value

        hr = pControl->KsProperty(&ksp,
                                  sizeof(ksp),    // If there was instance data, it would immediately follow ksp and
                                                  // the length would reflect this.
                                  &dwIsSupported,
                                  sizeof(dwIsSupported),
                                  &cb);

        fIsSupported = FALSE;
        if (SUCCEEDED(hr) || cb >= sizeof(dwIsSupported)
        {
            // Set is supported
            //
            fIsSupported = (BOOL)(dwIsSupported ? TRUE : FALSE);
        }
        
         pControl->Release();

        return fIsSupported;
    }

@rdesc

@flag S_OK | The operation completed successfully.
@flag E_POINTER | If any pointer parameter invalid
@flag DMUS_E_UNKNOWN_PROPERTY  | If the specified property set or item is unsupported by this port.


*/
STDMETHODIMP 
CDirectMusicPort::KsProperty(
        IN PKSPROPERTY  pProperty,              // @parm The property item and operation to perform. If this property contains
                                                // instance data, then that data should reside in memory immediately
                                                // following the KSPROPERTY structure. 
        IN ULONG        ulPropertyLength,       // @parm The length of the memory pointed to by <p pProperty>, including any
                                                // instance data.
        IN OUT LPVOID   pvPropertyData,         // @parm For a set operation, a memory buffer containing data representing
                                                // the new value of the property. For a get operation, a memory buffer big
                                                // enough to hold the value of the property. For a basic support query,
                                                // a pointer to a buffer at least the size of a DWORD.
        IN ULONG        ulDataLength,           // @parm The length of the buffer pointed to by <p pvPropertyData>.
        OUT PULONG      pulBytesReturned)       // @parm On a get or basic support call, the number of bytes returned in
                                                // <p pvPropertyData> by the port. 
{
    LONG lVolume;

    V_INAME(DirectMusicPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (ulPropertyLength < sizeof(KSPROPERTY))
    {
        return E_INVALIDARG;
    }

    //Check that the buffer isn't NULL
	//
    if (pvPropertyData == NULL)
    {
    	return E_POINTER;
    }

    // Don't let callers touch property sets we use
    //
    if (pProperty->Set == KSPROPSETID_Synth) 
    {
        if (pProperty->Id != KSPROPERTY_SYNTH_VOLUME)
        {
            return DMUS_E_UNKNOWN_PROPERTY;
        }
        else if (ulDataLength != sizeof(LONG))
        {
            return E_INVALIDARG;
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_SET)
        {
            lVolume = *(LONG*)pvPropertyData;

            // Clamp to -200..+20 db
            //
            if (lVolume < -20000) 
            {
                lVolume = -20000;
                pvPropertyData = &lVolume;
            }
            else if (lVolume > 2000)
            {
                lVolume = 2000;
                pvPropertyData = &lVolume;
            }
        }
    }
    else if (pProperty->Set == KSPROPSETID_Synth_Dls)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_PROPERTY,
                        pProperty,
                        ulPropertyLength,
                        pvPropertyData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // try topology node
        PKSNODEPROPERTY pksnp = (PKSNODEPROPERTY)new BYTE[sizeof(KSNODEPROPERTY) - sizeof(KSPROPERTY) + ulPropertyLength];
        if (pksnp == NULL)
        {
            return E_OUTOFMEMORY;
        }    
        memcpy(&pksnp->Property, pProperty, sizeof(KSPROPERTY));
        pksnp->Property.Flags |= KSPROPERTY_TYPE_TOPOLOGY;
        pksnp->NodeId   = m_idxSynthNode;
        pksnp->Reserved = 0;

        fResult = SyncIoctl(m_hPin,
                            IOCTL_KS_PROPERTY,
                            pksnp,
                            sizeof(KSNODEPROPERTY) - sizeof(KSPROPERTY) + ulPropertyLength,
                            pvPropertyData,
                            ulDataLength,
                            pulBytesReturned);

        delete [] pksnp;
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(1, "DeviceIoControl: %08X\n", GetLastError());

        TraceI(1, "KS Item: ");
        TraceIGuid(1, &pProperty->Set);
        TraceI(1, "\t#%d\n", pProperty->Id);
        TraceI(1, "\tFlags: %08X\n", pProperty->Flags);
    }
#endif // DBG

    if (!fResult)
    {
        DWORD dwError = GetLastError();
        
        if (dwError)
        {
            return WIN32ERRORtoHRESULT(dwError);
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    
    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IKsControl | KsEvent | Enable or disable firing of the given event.

@comm

Currently DirectMusic does not contain support for events.

*/
STDMETHODIMP 
CDirectMusicPort::KsEvent(
        IN PKSEVENT     pEvent,
        IN ULONG        ulEventLength,
        IN OUT LPVOID   pvEventData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_ENABLE_EVENT,  // XXX Fix this!!!
                        pEvent,
                        ulEventLength,
                        pvEventData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // NYI: try topology node
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());
    }
#endif // DBG

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}


/*
@method:(EXTERNAL) HRESULT | IKsControl | Method | Calls the specified Ks method.

@comm

Currently DirectMusic does not contain support for methods.

*/
STDMETHODIMP 
CDirectMusicPort::KsMethod(
        IN PKSMETHOD    pMethod,
        IN ULONG        ulMethodLength,
        IN OUT LPVOID   pvMethodData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicPort::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulMethodLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_METHOD,
                        pMethod,
                        ulMethodLength,
                        pvMethodData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // NYI: try topology node
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());
    }
#endif // DBG

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}
//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::PinSetState

BOOL CDirectMusicPort::PinSetState(KSSTATE DeviceState)
{
    KSPROPERTY      ksp;

    ksp.Set    = KSPROPSETID_Connection;
    ksp.Id     = KSPROPERTY_CONNECTION_STATE;
    ksp.Flags  = KSPROPERTY_TYPE_SET;

    return Property(m_hPin,
                    sizeof(KSPROPERTY),
                    &ksp,
                    sizeof(DeviceState),
                    &DeviceState,
                    NULL);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::FreeWDMHandle

void CDirectMusicPort::FreeWDMHandle()
{
	while(1)
	{
        // If the unload list has been cleaned up on us, exit the 
        // thread. This can happen under really heavy load (like
        // stress) when downloads are being unloaded right at
        // port release time
        //
        DWORD dwIndex;
        try
        {
            // Fix 43266: Make sure both of these are non-zero before calling
            // WaitForMultipleObjects
            if( NULL != m_phUnloadEventList
            &&  0 != m_dwNumEvents )
            {
                dwIndex = WaitForMultipleObjects(m_dwNumEvents, 
                                                 m_phUnloadEventList,
                                                 FALSE,
                                                 INFINITE);
            }
            else
            {
                return;
            }
        }
        catch (...) 
        {
            return;
        }
		
		if(dwIndex == 0 || dwIndex == WAIT_FAILED)
		{
			// If first event is signaled or error it is time to die.
			return;
		}
		else if(dwIndex == 1)
		{
			// If second event is signaled we need to changes the objects
			// we are waiting on.
			continue;
			
		}
        else if(dwIndex == 2 )
        {
            // If third event is signaled, we need to check which
            // OVERLAPPED structures are in use

            // But, first clear the event
            ResetEvent( m_phUnloadEventList[2] );

            EnterCriticalSection( &m_OverlappedCriticalSection );

            // Iterate through the list of overlapped structure arrays
            CNode<OverlappedStructs *> *pOverlappedNode;
            for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
            {
                // get a pointer to each array
                OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
                if( pOverlappedStructs )
                {
                    // Iterate through the array
                    for( int iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                    {
                        if( pOverlappedStructs->afOverlappedInUse[iOverlapped]
                        &&  HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                        {
                            // Found a completed one - clean it up
                            pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                            delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                            pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;

                            // Flag the structure as available
                            pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;
                        }
                    }
                }
            }

            LeaveCriticalSection( &m_OverlappedCriticalSection );
        }
		else if(dwIndex == 3)
		{
			// If fourth event is signaled we need to change our event list
			if(m_phNewUnloadEventList)
			{
				CopyMemory(m_phNewUnloadEventList, m_phUnloadEventList, (sizeof(HANDLE) * m_dwNumEvents));
				delete [] m_phUnloadEventList;
				m_phUnloadEventList = m_phNewUnloadEventList;
				m_phNewUnloadEventList = NULL;
				PulseEvent(m_hCopiedEventList);
			}
			else
			{
				// We should never get here
				assert(false);
				PulseEvent(m_hCopiedEventList);
			}
		}
		else
		{
			assert(dwIndex > 3);
			for(DWORD i = 0; i < m_dwNumEvents; i++)
			{
				DWORD dwState = WaitForSingleObject(m_phUnloadEventList[i], 0);
				if(dwState == WAIT_OBJECT_0)
				{
					CDownloadBuffer* pDownload = m_UnloadedList.GetHead();
					for( ; pDownload; pDownload = pDownload->GetNext())
					{
						if(m_phUnloadEventList[i] == (((CDownloadBuffer *)pDownload)->m_DLHandle))
						{
							void* pvBuffer = NULL;
                            DWORD dw;
							HRESULT hr = ((CDownloadBuffer *)pDownload)->GetHeader(&pvBuffer, &dw);
	
							if(SUCCEEDED(hr))
							{
								hr = ((CDownloadBuffer *)pDownload)->SetBuffer(NULL, 0, 0);
								if(SUCCEEDED(hr))
								{
									delete [] pvBuffer;
									pDownload->Release();
								}
							}
							break;
						}
					}
				}
#ifdef DBG
				else if(dwState == WAIT_FAILED)
				{
					assert(false);
					return;
				}
				else if(dwState == WAIT_ABANDONED)
				{
					// We should never get here
					assert(false);
				}
#endif
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////
// FreeWDMHandle

static DWORD WINAPI FreeWDMHandle(LPVOID lpThreadParameter)
{
    ((CDirectMusicPort *)lpThreadParameter)->FreeWDMHandle();

    return 0;
}

//////////////////////////////////////////////////////////////////////
//
// CaptureThread
//
void CDirectMusicPort::CaptureThread()
{
    READ_IRP    irp[POSTED_STREAM_READ_IRPS];
    READ_IRP    *pirp;

    assert(POSTED_STREAM_READ_IRPS + 1 < MAXIMUM_WAIT_OBJECTS);
    HANDLE      aWaitHandles[POSTED_STREAM_READ_IRPS + 1];
    HANDLE      *pWaitHandles;

    ULONG       cbRet;

    // Create events. If this fails, don't go any farther
    //
    ZeroMemory(irp, sizeof(irp));

    pWaitHandles = aWaitHandles;
    pirp = &irp[0];

    for (pirp = &irp[0], pWaitHandles = &aWaitHandles[0]; 
         pirp < &irp[POSTED_STREAM_READ_IRPS]; 
         pirp++, pWaitHandles++)
    {
        *pWaitHandles = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (*pWaitHandles == NULL)
        {
            TraceI(0, "Failed to CreateEvent in CaptureThread\n");
    
            int idx = (int) (pWaitHandles - aWaitHandles);

            pWaitHandles = aWaitHandles;
            while (idx--)
            {
                CloseHandle(*pWaitHandles++);
                return;
            }
        }

        pirp->overlapped.hEvent = *pWaitHandles;
    }

    // Initialize IRP's
    //
    for (pirp = &irp[0]; pirp < &irp[POSTED_STREAM_READ_IRPS]; pirp++)
    {
        pirp->kssh.Size               = sizeof(KSSTREAM_HEADER);

        pirp->kssh.PresentationTime.Numerator   = 1;
        pirp->kssh.PresentationTime.Denominator = 1;

        pirp->kssh.FrameExtent  = BYTES_PER_READ_IRP;
        pirp->kssh.Data         = &pirp->buffer[0];

        TraceI(2, "About to DeviceIoControl\n");
        if (!::DeviceIoControl(m_hPin,
                               IOCTL_KS_READ_STREAM,
                               NULL, 0,
                               &pirp->kssh, sizeof(pirp->kssh),
                               &cbRet,
                               &pirp->overlapped))
        {
#ifdef DBG
            DWORD dwError = GetLastError();
            if (dwError != ERROR_IO_PENDING)
            {
                TraceI(0, "CaptureThread: Warning: AsyncIoctl failed %d\n", dwError);
            }
#endif
        }
    }                   

    // Last event is the thread wakeup event
    //
    aWaitHandles[POSTED_STREAM_READ_IRPS] = m_hCaptureWake;

    // Process events and shove them into the read queue
    //
    for(;;)
    {
        WaitForMultipleObjects(POSTED_STREAM_READ_IRPS + 1,
                               &aWaitHandles[0],
                               FALSE,               // Wake on any, not all
                               INFINITE);
        
        // First see if the thread is dying. If so, get out of here.
        //
        if (m_fShutdownThread)
        {
            for (pWaitHandles = &aWaitHandles[0]; 
                 pWaitHandles < &aWaitHandles[POSTED_STREAM_READ_IRPS]; 
                 pWaitHandles++)
            {
                CloseHandle(*pWaitHandles);
            }
            
            return;
        }            

        // Still alive. Process any queued data.
        //
        for (pirp = &irp[0]; pirp < &irp[POSTED_STREAM_READ_IRPS]; pirp++)
        {
            if (WaitForSingleObject(pirp->overlapped.hEvent, 0) != WAIT_OBJECT_0)
            {
                continue;
            }                        

            assert(pirp->kssh.PresentationTime.Numerator == pirp->kssh.PresentationTime.Denominator);
            if (pirp->kssh.DataUsed)
            {
                InputWorkerDataReady(pirp->kssh.PresentationTime.Time, 
                                     (LPBYTE)pirp->kssh.Data, 
                                     pirp->kssh.DataUsed);
                if (m_hAppEvent)
                {
                    try 
                    {
                        SetEvent(m_hAppEvent);
                    } 
                    catch (...) 
                    {
                        Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
                    }    
                }
            }

            ResetEvent(pirp->overlapped.hEvent);
            pirp->kssh.DataUsed = 0;
            pirp->kssh.OptionsFlags = 0;

            if (!::DeviceIoControl(m_hPin,
                                   IOCTL_KS_READ_STREAM,
                                   NULL, 0,
                                   &pirp->kssh, sizeof(pirp->kssh),
                                   &cbRet,
                                   &pirp->overlapped))
            {
                if (GetLastError() != ERROR_IO_PENDING) 
                {
                    TraceI(0, "CaptureThread: Warning: AsyncIoctl repost failed %d\n", GetLastError());
                }
            }
        }            
    }
}

// CDirectMusicPort::InputWorkerDataReady()
//
// The input worker thread has been notified that there is data available. 
// Read any pending events from the 16-bit DLL, perform needed thruing, and
// save the data in a queue so we can repackage it on the read request
// from the client.
//
void CDirectMusicPort::InputWorkerDataReady(REFERENCE_TIME rtStart, LPBYTE pbData, ULONG cbData)
{
    DMEVENT *pEvent;
    DWORD cbRounded;

    TraceI(2, "Enter InputWorkerDataReady()\n");

    SyncClocks();
    SlaveToMaster(&rtStart);

    for(;;)
    {
        if (cbData == 0)
        {
            return;
        }

        // Copy temporary buffer as events into queue
        //
        while (cbData)
        {
            pEvent = (DMEVENT*)pbData;
            cbRounded = DMUS_EVENT_SIZE(pEvent->cbEvent);

            TraceI(2, "cbData %u  cbRounded %u\n", cbData, cbRounded);

            if (cbRounded > cbData)
            {
                TraceI(0, "InputWorkerDataReady: Event ran off end of buffer\n");
                break;
            }

            cbData -= cbRounded;
            pbData += cbRounded;

            EnterCriticalSection(&m_csEventQueues);

            QUEUED_EVENT *pQueuedEvent;
            int cbEvent;

            
            if (pEvent->cbEvent <= sizeof(DWORD))
            {
                // Channel message or other really small event, take from
                // free pool.
                //
                pQueuedEvent = m_FreeEvents.Alloc();
                cbEvent = sizeof(DMEVENT);

                TraceI(4, "Queue [%02X %02X %02X %02X]\n",
                    pEvent->abEvent[0],
                    pEvent->abEvent[1],
                    pEvent->abEvent[2],
                    pEvent->abEvent[3]);
            }
            else
            {
                // SysEx or other long event, just allocate it
                //
                cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);
                pQueuedEvent = (QUEUED_EVENT*)new char[QUEUED_EVENT_SIZE(pEvent->cbEvent)];
            }

            if (pQueuedEvent)
            {

                CopyMemory(&pQueuedEvent->e, pEvent, cbEvent);

                // rtDelta is the absolute time of the event while it's in our queue
                //
                pQueuedEvent->e.rtDelta += rtStart;
                ThruEvent(&pQueuedEvent->e);

        
                if (m_ReadEvents.pFront)
                {
                    m_ReadEvents.pRear->pNext = pQueuedEvent;
                }
                else
                {
                    m_ReadEvents.pFront = pQueuedEvent;   
                }

                m_ReadEvents.pRear = pQueuedEvent;
                pQueuedEvent->pNext = NULL;
            }
            else
            {
                TraceI(1, "InputWorker: Failed to allocate event; dropping\n");
            }        
            LeaveCriticalSection(&m_csEventQueues);
        }
    }    
    TraceI(2, "Leave InputWorkerDataReady()\n");
}

void CDirectMusicPort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify 
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        TraceI(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        TraceI(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        TraceI(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }
    
    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        TraceI(0, "Thru: buffer setup failed\n");
    }

    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->rtDelta = 5 * 10000;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}


//////////////////////////////////////////////////////////////////////
//
// CaptureThread
//
static DWORD WINAPI CaptureThread(LPVOID lpThreadParameter)
{
    ((CDirectMusicPort *)lpThreadParameter)->CaptureThread();

    return 0;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::InitChannelPriorities

static DWORD adwChannelPriorities[16] =
{
    DAUD_CHAN1_DEF_VOICE_PRIORITY,
    DAUD_CHAN2_DEF_VOICE_PRIORITY,
    DAUD_CHAN3_DEF_VOICE_PRIORITY,
    DAUD_CHAN4_DEF_VOICE_PRIORITY,
    DAUD_CHAN5_DEF_VOICE_PRIORITY,
    DAUD_CHAN6_DEF_VOICE_PRIORITY,
    DAUD_CHAN7_DEF_VOICE_PRIORITY,
    DAUD_CHAN8_DEF_VOICE_PRIORITY,
    DAUD_CHAN9_DEF_VOICE_PRIORITY,
    DAUD_CHAN10_DEF_VOICE_PRIORITY,
    DAUD_CHAN11_DEF_VOICE_PRIORITY,
    DAUD_CHAN12_DEF_VOICE_PRIORITY,
    DAUD_CHAN13_DEF_VOICE_PRIORITY,
    DAUD_CHAN14_DEF_VOICE_PRIORITY,
    DAUD_CHAN15_DEF_VOICE_PRIORITY,
    DAUD_CHAN16_DEF_VOICE_PRIORITY
};

void CDirectMusicPort::InitChannelPriorities(
    UINT uLowCG,
    UINT uHighCG)
{
    while (uLowCG <= uHighCG)
    {
        for (UINT uChannel = 0; uChannel < 16; uChannel++)
        {
            SetChannelPriority(uLowCG, uChannel, adwChannelPriorities[uChannel]);
        }

        uLowCG++;
    }
}

HRESULT WIN32ERRORtoHRESULT(DWORD dwError)
{
    HRESULT                 hr;
    
    switch(dwError)
    {
        case ERROR_SUCCESS:
            hr = S_OK;
            break;

        case ERROR_INVALID_FUNCTION:
        case ERROR_BAD_COMMAND:
        case ERROR_INVALID_DATA:
        case ERROR_INVALID_PARAMETER:
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_NOACCESS:
        case ERROR_INVALID_FLAGS:
            hr = E_INVALIDARG;
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
        case ERROR_NO_SYSTEM_RESOURCES:
        case ERROR_NONPAGED_SYSTEM_RESOURCES:
        case ERROR_PAGED_SYSTEM_RESOURCES:
            hr = E_OUTOFMEMORY;
            break;

        case ERROR_NOT_SUPPORTED:
        case ERROR_CALL_NOT_IMPLEMENTED:
        case ERROR_PROC_NOT_FOUND:
        case ERROR_NOT_FOUND:
            hr = E_NOTIMPL;
            break;

        default:
            hr = E_FAIL;
            break;
    }

    return hr;
}


void CDirectMusicPort::MasterToSlave(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt -= m_lTimeOffset;
    }
}

void CDirectMusicPort::SlaveToMaster(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt += m_lTimeOffset;
    }
}

void CDirectMusicPort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (SUCCEEDED(hr))
        {
            hr = m_pPCClock->GetTime(&rtSlaveClock);
        }
    
        if (SUCCEEDED(hr))
        {
            drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

            // Work-around 46782 for DX8 release:
            // If drift is greater than 10ms, jump to the new offset value instead
            // of drifting there slowly.
            if( drift > 10000 * 10
            ||  drift < 10000 * -10 )
            {
                m_lTimeOffset -= drift;
            }
            else
            {
                m_lTimeOffset -= drift / 100;
            }
        }
    }
}

// CPortLatencyClock
//
CPortLatencyClock::CPortLatencyClock(
    HANDLE hPin,
    ULONG ulNodeId,
    CDirectMusicPort *pPort) : m_cRef(1), m_hPin(hPin), m_ulNodeId(ulNodeId), m_pPort(pPort)
{
}

// CPortLatencyClock::~CPortLatencyClock
//
CPortLatencyClock::~CPortLatencyClock()
{
}

// CPortLatencyClock::QueryInterface
//
STDMETHODIMP
CPortLatencyClock::QueryInterface(const IID &iid,
                                  void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else if (iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CPortLatencyClock::AddRef
//
STDMETHODIMP_(ULONG)
CPortLatencyClock::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

// CPortLatencyClock::Release
//
STDMETHODIMP_(ULONG)
CPortLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CPortLatencyClock::GetTime
//
STDMETHODIMP 
CPortLatencyClock::GetTime(
    REFERENCE_TIME *pTime)
{
    V_INAME(IDirectMusicPort:IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    assert(sizeof(REFERENCE_TIME) == sizeof(ULONGLONG));

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_LATENCYCLOCK;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_ulNodeId;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(REFERENCE_TIME),
                  pTime,
                  &ulBytesReturned))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           

    if (ulBytesReturned < sizeof(REFERENCE_TIME))
    {
        return DMUS_E_DRIVER_FAILED;
    }

	if( m_pPort )
	{
		m_pPort->SlaveToMaster( pTime );
	}

    return S_OK;
}

// CPortLatencyClock::AdviseTime
//
STDMETHODIMP 
CPortLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}       

// CPortLatencyClock::AdvisePeriodic
//
STDMETHODIMP 
CPortLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

// CPortLatencyClock::Unadvise
//
STDMETHODIMP 
CPortLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmpcclk.cpp ===
//
// DMPcClk.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrapper for using clock from portclass as the DirectMusic master clock
// (Win9x only)
// 
//
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX
#include <objbase.h>
#include <winerror.h>
#ifndef XBOX
#include <setupapi.h>
#endif // ! XBOX
#include "dmusicp.h"
#ifndef XBOX
#include "suwrap.h"
#endif // ! XBOX
#include "debug.h"
#include "resource.h"

// Since we only allocate one of these clocks in the entire system,
// this stuff is global.
//

// We have to be able to get the process id of someone with a handle to
// the clock. Since the original creator might go away before other users,
// we store the process id of everyone who uses the clock. This implies
// a max limit on concurrent processes using it.
//
#define MAX_CLOCK_SHARERS   64              // Max processes who can access clock   
                                            // at once.
typedef struct PCCLOCKSHARE
{
    LONG                cRef;               // Count of processes using handle

    struct 
    {
        HANDLE          hPcClock;           // This user's handle and
        DWORD           dwProcessId;        // process id
    } aUsers[MAX_CLOCK_SHARERS];

} *PPCCLOCKSHARE;

#ifdef XBOX
PCCLOCKSHARE g_pccs;

#define GetCurrentProcessId() ((DWORD) -1)
#endif // XBOX

class CPcClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CPcClock();
    ~CPcClock();
    HRESULT Init();

private:
    long m_cRef;

    HRESULT CreatePcClockShared();
    void    DeletePcClockShared();
    HRESULT CreatePcClockHandle();
    HRESULT DuplicatePcClockHandle();

private:
    static const char m_cszPcClockMemory[];       // Name of shared memory object
    static const TCHAR m_cszPcClockMutex[];        // Name of mutex protecting shared memory

    static LONG m_lSharedMemoryInitialized;       // Has this process initialized shared memory?
    static HANDLE m_hFileMapping;                 // File mapping handle for shared memory
    static PPCCLOCKSHARE m_pShared;               // Pointer to shared memory
    static HANDLE m_hPcClockMutex;                // Mutex for shared memory access
    static HANDLE m_hClock;                       // Clock handle in this process
};

HRESULT CreatePcClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);
static BOOL LookForPortClock(PHANDLE phClock);

const char       CPcClock::m_cszPcClockMemory[] = "DirectMusiCPcClock";
const TCHAR      CPcClock::m_cszPcClockMutex[]  = TEXT("DirectMusiCPcClockMutex");

LONG             CPcClock::m_lSharedMemoryInitialized = 0;
HANDLE           CPcClock::m_hFileMapping = NULL;         
PPCCLOCKSHARE    CPcClock::m_pShared = NULL;        
HANDLE           CPcClock::m_hPcClockMutex = NULL;
HANDLE           CPcClock::m_hClock;                


// AddPcClocPc
//
// Add Pc clock to the list of clocPc.
//
HRESULT AddPcClocks(CMasterClock *pMasterClock)
{
    HANDLE hClock;

    // Make sure we can create a default Pc clock
    //
    DWORD ms = timeGetTime();
    if (!LookForPortClock(&hClock))
    {
        TraceI(1, "Could not create Pc clock\n");
        return S_FALSE;
    }
    TraceI(3, "LookForPortClock took %d\n", timeGetTime() - ms);

    CloseHandle(hClock);

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce.cc);
    ce.cc.guidClock = GUID_SysClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreatePcClock;

#ifndef XBOX
    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
#endif // ! XBOX
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}

// CreatePcClock
//
// Return an IReferenceClock based on the one Pc clock in the system
//
HRESULT CreatePcClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    HRESULT hr;

    TraceI(3, "Creating Pc clock\n");

    CPcClock *pClock = new CPcClock();

    hr = pClock->Init();
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

// CPcClock::CPcClock()
//
// 
CPcClock::CPcClock() : 
    m_cRef(1)
{
}

// CPcClock::~CPcClock()
//
// 
CPcClock::~CPcClock()
{
    if (InterlockedDecrement(&m_lSharedMemoryInitialized) == 0)
    {
        DeletePcClockShared();        
    }
}

// CPcClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CPcClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CPcClock::AddRef
// 
STDMETHODIMP_(ULONG) CPcClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CPcClock::Release
//
STDMETHODIMP_(ULONG) CPcClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CPcClock::Init
//
HRESULT CPcClock::Init()
{
    HRESULT hr;

    if (InterlockedIncrement(&m_lSharedMemoryInitialized) == 1)
    {
        hr = CreatePcClockShared();
        if (FAILED(hr))
        {
            return hr;
        }    
    }

    return S_OK;
}

// CPcClock::CreatePcClocPchared
//
// Initialize the shared memory object in this process.
// Make sure a handle to the Pc clock exists in this process.
//
HRESULT CPcClock::CreatePcClockShared()
{
    HRESULT hr;
    DWORD dwErr;

    // Create and take the mutex up front. This is neccesary to guarantee that if 
    // we are the first process in the system to create this object, then we do 
    // initialization before anyone else can access the shared memory object.
    //
    m_hPcClockMutex = CreateMutex(NULL,             // Default security descriptor
                                  FALSE,            // Own mutex if we are first instance
                                  m_cszPcClockMutex);
    if (m_hPcClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    WaitForSingleObject(m_hPcClockMutex, INFINITE);

#ifndef XBOX
    // Create the file mapping and view of the shared memory, noticing if we are the first 
    // object to create it.
    //
    m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(PCCLOCKSHARE),
                                       m_cszPcClockMemory);
    dwErr = GetLastError();
    if (m_hFileMapping == NULL)
    {
        ReleaseMutex(m_hPcClockMutex);
        
        return HRESULT_FROM_WIN32(dwErr);
    }    

    BOOL fFirst = (dwErr != ERROR_ALREADY_EXISTS);

    m_pShared = (PPCCLOCKSHARE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_WRITE,
                                             0, 0,                // Start mapping at the beginning
                                             0);                  // Map entire file
    if (m_pShared == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());

        ReleaseMutex(m_hPcClockMutex);
        return E_OUTOFMEMORY;
    }

    // Initialize the refernce count if we are the first process, and increment
    // it in any case. (Note we're still in the mutex, so we don't need 
    // InterlockedIncrement.
    //
    if (fFirst)
#else  // ! XBOX
    m_pShared = &g_pccs;
    
    if (ERROR_ALREADY_EXISTS != GetLastError())
#endif // ! XBOX
    {
        m_pShared->cRef = 0;
        ZeroMemory(m_pShared->aUsers, sizeof(m_pShared->aUsers));
    }
    ++m_pShared->cRef;

    // If the clock handle doesn't exist yet, create it; else duplicate it. 
    //
    if (m_pShared->cRef == 1)
    {
        hr = CreatePcClockHandle();
    }
    else
    {
        hr = DuplicatePcClockHandle();
    }

    // Release the mutex and return success or failure.
    //
    ReleaseMutex(m_hPcClockMutex);

    return hr;
}

// CPcClock::DeletePcClocPchared
//
// The last instance of CPcClock in this process is being deleted. 
//
void CPcClock::DeletePcClockShared()
{
    // If the mutex was never created, then none of the other objects could have
    // been created.
    //
    if (m_hPcClockMutex)
    {
        WaitForSingleObject(m_hPcClockMutex, INFINITE);

        if (m_pShared)
        {
            for (int i = 0; i < MAX_CLOCK_SHARERS; i++)
            {
                if (m_pShared->aUsers[i].dwProcessId == GetCurrentProcessId())
                {
                    m_pShared->aUsers[i].dwProcessId = 0;
                    m_pShared->aUsers[i].hPcClock = NULL;

                    break;
                }
            }
        }

        if (m_hClock)
        {
            CloseHandle(m_hClock);
            m_hClock = NULL;
        }        

#ifndef XBOX
        if (m_pShared)
        {
            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }

        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
#endif // ! XBOX

        ReleaseMutex(m_hPcClockMutex);
        CloseHandle(m_hPcClockMutex);                            
    }
}

// CPcClock::CreatePcClockHandle
//
// Create the first and only Pc clock handle in the system
//
HRESULT CPcClock::CreatePcClockHandle()
{
    // Attempt to open the clock
    //
    if (!LookForPortClock(&m_hClock))
    {
        TraceI(0, "Could not create Pc clock\n");
        return S_FALSE;
    }

    // Successful clock open. Since we're creating, we know we're the first
    // instance of the clock and therefore the users array is empty.
    //
    m_pShared->aUsers[0].hPcClock = m_hClock;
    m_pShared->aUsers[0].dwProcessId = GetCurrentProcessId();    

    return S_OK;
}

// CPcClock::DuplicatePcClockHandle
//
// There is already a Pc clock in the system. Duplicate the handle in this process
// context.
//
HRESULT CPcClock::DuplicatePcClockHandle()
{
    // Find another user of the clock; also, find a slot in the users array for
    // this process
    //
    int iEmptySlot = -1;
    int iOtherProcess = -1;
    HANDLE hClock = NULL;

    for (int i = 0; 
         (i < MAX_CLOCK_SHARERS) && (iEmptySlot == -1 || !hClock); 
         i++)
    {
        if (m_pShared->aUsers[i].dwProcessId == 0 && iEmptySlot == -1)
        {
            iEmptySlot = i;
            continue;
        }

        if (hClock)
        {
            continue;
        }            

#ifdef XBOX
        HANDLE hOtherProcess = GetCurrentProcess();
#else  // XBOX
        HANDLE hOtherProcess = OpenProcess(PROCESS_DUP_HANDLE, 
                                           FALSE,
                                           m_pShared->aUsers[i].dwProcessId);
        if (hOtherProcess == NULL)
        {
            TraceI(0, "OpenProcess: %d\n", GetLastError());
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hPcClock = NULL;
            continue;
        }
#endif // ! XBOX

        BOOL fSuccess = DuplicateHandle(hOtherProcess,
                                        m_pShared->aUsers[i].hPcClock,
                                        GetCurrentProcess(),
                                        &hClock,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FALSE,
                                        0);
        if (!fSuccess)
        {
            TraceI(0, "DuplicateHandle: %d\n", GetLastError());
        }

#ifndef XBOX
        CloseHandle(hOtherProcess);
#endif // ! XBOX

        if (!fSuccess)
        {
            // Other process exists, but could not duplicate handle
            //
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hPcClock = NULL;

            hClock = NULL;
        }
    }

    assert(iEmptySlot != -1);
    assert(hClock);

    m_hClock = hClock;

    m_pShared->aUsers[iEmptySlot].dwProcessId = GetCurrentProcessId();
    m_pShared->aUsers[iEmptySlot].hPcClock = hClock;

    return S_OK;
}

STDMETHODIMP 
CPcClock::GetTime(REFERENCE_TIME *pTime)
{
    KSPROPERTY ksp;

    ZeroMemory(&ksp, sizeof(ksp));
    ksp.Set   = KSPROPSETID_SynthClock;
    ksp.Id    = KSPROPERTY_SYNTH_MASTERCLOCK;
    ksp.Flags = KSPROPERTY_TYPE_GET;


    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(*pTime),
                  pTime,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

STDMETHODIMP 
CPcClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CPcClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CPcClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}


static BOOL    
LookForPortClock(PHANDLE phClock)
{
/*#ifdef XBOX
    *phClock = NULL;
    return FALSE;
#else // XBOX*/
    SetupAPI suwrap;
    HANDLE hFilter = INVALID_HANDLE_VALUE;

    if (!suwrap.IsValid()) 
    {
        return FALSE;
    }

    *phClock = (HANDLE)NULL;

	GUID *pClassGuid = const_cast<GUID*>(&KSCATEGORY_AUDIO);
	HDEVINFO hDevInfo = suwrap.SetupDiGetClassDevs(pClassGuid,
											NULL,
											NULL,
											DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
	{
		TraceI(0, "Could not open SetupDiGetClassDevs\n");
        return FALSE;
	}

	SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	DevInterfaceData.cbSize = sizeof(DevInterfaceData);

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];
	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

    int iDevice = 0;

	while (suwrap.SetupDiEnumDeviceInterfaces(hDevInfo, NULL, pClassGuid, iDevice++, &DevInterfaceData))
    {
		if (suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo, 
		                                    &DevInterfaceData, 
		                                    pDevInterfaceDetails,
 										    sizeof(rgbStorage), 
 										    NULL, 
 										    NULL))
        {
            // Have to convert this since there's no CreateFileW on Win9x.
            //
            hFilter = CreateFile(pDevInterfaceDetails->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                        NULL);
            if (hFilter == NULL || hFilter == INVALID_HANDLE_VALUE)
            {
                continue;
            }

            KSPROPERTY ksp;

            ZeroMemory(&ksp, sizeof(ksp));
            ksp.Set   = KSPROPSETID_SynthClock;
            ksp.Id    = KSPROPERTY_SYNTH_MASTERCLOCK;
            ksp.Flags = KSPROPERTY_TYPE_GET;

            REFERENCE_TIME rt;

            if (!Property(
                hFilter,
                sizeof(ksp),
                (PKSIDENTIFIER)&ksp,
                sizeof(rt),
                &rt,
                NULL))
            {
                CloseHandle(hFilter);
                hFilter = INVALID_HANDLE_VALUE;
                continue;
            }
            
            break;
        }
    }

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    if (hFilter != INVALID_HANDLE_VALUE)
    {
        *phClock = hFilter;
        return TRUE;
    }

    return FALSE;
//#endif // XBOX
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dminstru.cpp ===
//
// dminstru.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//

#include "debug.h"
#include "dmusicp.h"
#include "dmusicc.h"

#include "alist.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmportdl.h"
#include "dminstru.h"
#include "dminsobj.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CInstrument

//////////////////////////////////////////////////////////////////////
// CInstrument::CInstrument

CInstrument::CInstrument() :
m_dwOriginalPatch(0),
m_dwPatch(0),
m_pParentCollection(NULL),
m_pInstrObj(NULL),
m_bInited(false),
m_dwId(-1),
m_cRef(1),
m_MemTrack(DMTRACK_INSTRUMENT)
{
	InitializeCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::~CInstrument

CInstrument::~CInstrument()
{
	Cleanup();
	DeleteCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CInstrument::QueryInterface

STDMETHODIMP CInstrument::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicInstrument::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicInstrument) 
	{
        *ppv = static_cast<IDirectMusicInstrument*>(this);
    } 
    else if(iid == IID_IDirectMusicInstrumentPrivate) 
	{
        *ppv = static_cast<IDirectMusicInstrumentPrivate*>(this);
    } 
	else 
	{
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::AddRef

STDMETHODIMP_(ULONG) CInstrument::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::Release

STDMETHODIMP_(ULONG) CInstrument::Release()
{
	if(!InterlockedDecrement(&m_cRef)) 
	{
	    if(m_pParentCollection)
	    {
		    m_pParentCollection->RemoveInstrument(this);
	    }

		if(!m_cRef) // remotely possible that collection bumped before we were removed
        {
            delete this;
            return 0;
        }
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicInstrument

//////////////////////////////////////////////////////////////////////
// CInstrument::GetPatch

/*

@method:(EXTERNAL) HRESULT | IDirectMusicInstrument | GetPatch | 
Gets the MIDI patch number from the instrument. The MIDI 
patch number is an address composed of the MSB and LSB
bank selects, and program change number. An optional flag
bit indicates that the instrument is a drum, rather than
melodic, instrument.

@comm The patch number returned in <p dwPatch> describes the
full patch address, including the MIDI parameters for MSB and LSB
bank select. MSB is shifted left 16 bits and LSB is shifted
8 bits. Program change is stored in the bottom 8 bits.

In addition, the high bit (0x80000000)
must be set if the instrument is
specifically a drum kit, intended to be played on MIDI 
channel 10. 
Note that this a special tag for DLS Level 1, 
since DLS Level 1 always plays drums on MIDI channel 10.
However, future versions of DLS will probably do away with 
the differentiation of drums verses melodic isntruments. 
All channels will support drums and the format differences
between drums and melodic instruments will go away.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | Invalid pointer in <p pdwPatch>.


@xref <i IDirectMusicCollection>, 
<i IDirectMusicInstrument>,
<om IDirectMusicInstrument::SetPatch>,
<om IDirectMusicCollection::GetInstrument>
*/

STDMETHODIMP CInstrument::GetPatch(
	DWORD* pdwPatch)	// @parm Returned patch number.
{
	if(!m_bInited)
	{
		return DMUS_E_NOT_INIT;
	}

	// Argument validation
	V_INAME(IDirectMusicInstrument::GetPatch);
	V_PTR_WRITE(pdwPatch, DWORD);

	*pdwPatch = m_dwPatch;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::SetPatch
/*
@method:(EXTERNAL) HRESULT | IDirectMusicInstrument | SetPatch | 
Sets the MIDI patch number for the instrument. Although
each instrument in a DLS collection has a predefined
patch number, the patch number
can be reassigned once the instrument
has been pulled from the <i IDirectMusicCollection>
via a call to <om IDirectMusicCollection::GetInstrument>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag DMUS_E_INVALIDPATCH | Invalid MIDI address in <p dwPatch>.

@xref <i IDirectMusicCollection>, 
<i IDirectMusicInstrument>,
<om IDirectMusicInstrument::GetPatch>,
<om IDirectMusicCollection::GetInstrument>

@ex The following example gets an instrument from a collection,
remaps its
MSB bank select to a different bank, then downloads the
instrument. |

	HRESULT myRemappedDownload(
		IDirectMusicCollection *pCollection,
		IDirectMusicPort *pPort,
		IDirectMusicDownloadedInstrument **ppDLInstrument,
		BYTE bMSB,       // Requested MIDI MSB for patch bank select.
		DWORD dwPatch)   // Requested patch. 

	{
		HRESULT hr;
		IDirectMusicInstrument* pInstrument;
		hr = pCollection->GetInstrument(dwPatch, &pInstrument);
		if (SUCCEEDED(hr))
		{
			dwPatch &= 0xFF00FFFF;  // Clear MSB.
			dwPatch |= bMSB << 16;  // Stick in new MSB value.
			pInstrument->SetPatch(dwPatch);
			hr = pPort->DownloadInstrument(pInstrument, ppDLInstrument, NULL, 0);
			pInstrument->Release();
		}
		return hr;
	}
*/

STDMETHODIMP CInstrument::SetPatch(
	DWORD dwPatch)	// @parm New patch number to assign to instrument.
{
	// Argument validation - Runtime
	if(!m_bInited)
	{
		return DMUS_E_NOT_INIT;
	}

	// We use 0x7F to strip out the Drum Kit flag
	BYTE bMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
	BYTE bLSB = (BYTE) (dwPatch >> 8);
	BYTE bInstrument = (BYTE) dwPatch;

	if(bMSB < 0 || bMSB > 127 ||
	   bLSB < 0 || bLSB > 127 ||
	   bInstrument < 0 || bInstrument > 127)
	{
		return DMUS_E_INVALIDPATCH;
	} 

	m_dwPatch = dwPatch;
	CDirectMusicPort::GetDLIdP(&m_dwId, 1);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CInstrument::Cleanup

void CInstrument::Cleanup()
{
	EnterCriticalSection(&m_DMICriticalSection);

	while(!m_WaveObjList.IsEmpty())
	{
		CWaveObj* pWaveObj = m_WaveObjList.RemoveHead();
		if(pWaveObj)
		{
			delete pWaveObj;
		}
	}

	if(m_pInstrObj)
	{
		delete m_pInstrObj;
	}

	if(m_pParentCollection)
	{
        m_pParentCollection->Release();
		m_pParentCollection = NULL;
	}

	m_bInited = false;

	LeaveCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::Init

HRESULT CInstrument::Init(DWORD dwPatch, 
									 CCollection* pParentCollection)
{
	// Argument validation - Debug
	assert(pParentCollection);

	m_dwOriginalPatch = m_dwPatch = dwPatch;
	m_pParentCollection = pParentCollection;
	m_pParentCollection->AddRef();

	HRESULT hr = pParentCollection->ExtractInstrument(dwPatch, &m_pInstrObj);

	if(FAILED(hr) || hr == S_FALSE)
	{
		Cleanup();
		return DMUS_E_INVALIDPATCH;
	}

	m_bInited = true;

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveCount

HRESULT CInstrument::GetWaveCount(DWORD* pdwCount)
{
	// Assumption validation - Debug
	assert(m_pInstrObj);
	assert(pdwCount);

	return(m_pInstrObj->GetWaveCount(pdwCount));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveIDs

HRESULT CInstrument::GetWaveDLIDs(DWORD* pdwIds)
{
	assert(m_pInstrObj);
	assert(pdwIds);

	return(m_pInstrObj->GetWaveIDs(pdwIds));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveSize

HRESULT CInstrument::GetWaveSize(DWORD dwId, DWORD* pdwSize, DWORD* pdwSampleSize)
{
	assert(pdwSize);

	if(dwId >= CDirectMusicPortDownload::sNextDLId)
	{
		assert(FALSE); // We want to make it known if we get here
		return DMUS_E_INVALID_DOWNLOADID;
	}

	EnterCriticalSection(&m_DMICriticalSection);

	HRESULT hr = E_FAIL;
	bool bFound = false;

	CWaveObj* pWaveObj = m_WaveObjList.GetHead();

	for(; pWaveObj; pWaveObj = pWaveObj->GetNext())
	{
		if(dwId == pWaveObj->m_dwId)
		{
			bFound = true;
			hr = S_OK;
			break;
		}
	}

	if(!bFound)
	{
		hr = m_pParentCollection->ExtractWave(dwId, &pWaveObj);
		if(SUCCEEDED(hr))
		{
			m_WaveObjList.AddHead(pWaveObj);
		}
	}
	
	if(SUCCEEDED(hr))
	{
		hr = pWaveObj->Size(pdwSize,pdwSampleSize);
	}

	LeaveCriticalSection(&m_DMICriticalSection);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWave

HRESULT CInstrument::GetWave(DWORD dwWId, IDirectMusicDownload* pIDMDownload)
{
	assert(pIDMDownload);

	if(dwWId >= CDirectMusicPortDownload::sNextDLId)
	{
		assert(FALSE); // We want to make it known if we get here
		return DMUS_E_INVALID_DOWNLOADID;
	}

	EnterCriticalSection(&m_DMICriticalSection);

	HRESULT hr = E_FAIL;
	bool bFound = false;
	
	CWaveObj* pWaveObj = m_WaveObjList.GetHead();

	for(; pWaveObj; pWaveObj = pWaveObj->GetNext())
	{
		if(dwWId == pWaveObj->m_dwId)
		{
			bFound = true;
			hr = S_OK;
			break;
		}
	}

	if(!bFound)
	{
		hr = m_pParentCollection->ExtractWave(dwWId, &pWaveObj);
		if(SUCCEEDED(hr))
		{
			m_WaveObjList.AddHead(pWaveObj);
		}
	}
	
	void* pvoid = NULL;
	DWORD dwBufSize = 0;
	DWORD dwWaveSize = 0;
	DWORD dwSampleSize = 0;

	if(SUCCEEDED(hr))
	{
		hr = pIDMDownload->GetBuffer(&pvoid, &dwBufSize);
		
		if(SUCCEEDED(hr))
		{
			hr = pWaveObj->Size(&dwWaveSize,&dwSampleSize);

			if(FAILED(hr) || dwWaveSize > dwBufSize)
			{
				hr =  DMUS_E_INSUFFICIENTBUFFER;
			}
			else
			{
				hr = pWaveObj->Write((BYTE *)pvoid);
			}
		}
	}

	LeaveCriticalSection(&m_DMICriticalSection);

	return hr;
}

#ifdef DXAPI
void CInstrument::SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2)

{
	assert(m_pInstrObj);
	m_pInstrObj->SetPort(pPort,fAllowDLS2);
}
#endif

//////////////////////////////////////////////////////////////////////
// CInstrument::GetInstrumentSize
 
HRESULT CInstrument::GetInstrumentSize(DWORD* pdwSize)
{
	assert(m_pInstrObj);
	assert(pdwSize);

	return(m_pInstrObj->Size(pdwSize));	
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetInstrument

HRESULT CInstrument::GetInstrument(IDirectMusicDownload* pIDMDownload)
{
	assert(m_pInstrObj);	
	assert(pIDMDownload);

	void* pvoid = NULL;
	DWORD dwBufSize = 0;
	DWORD dwInstSize = 0;

	HRESULT hr = pIDMDownload->GetBuffer(&pvoid, &dwBufSize);
	
	if(SUCCEEDED(hr))
	{
		hr = m_pInstrObj->Size(&dwInstSize);

		if(FAILED(hr) || dwInstSize > dwBufSize)
		{
			hr = DMUS_E_INSUFFICIENTBUFFER;
		}
		else
		{
			hr = m_pInstrObj->Write((BYTE *)pvoid);

			// We need to adjust dwDLId if the m_dwPatch was changed with a call to SetPatch
			// as well as adjust the ulPatch to reflect the patch set with SetPatch
			if(SUCCEEDED(hr))
			{
	            DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)
                    (((BYTE *)pvoid) + (DWORD) CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)));
				DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT *) 
                    (((BYTE *)pvoid) + pDMOffsetTable->ulOffsetTable[0]);
				
				if(m_dwPatch != pDMInstrument->ulPatch)
				{
					assert(m_dwId != -1);
					((DMUS_DOWNLOADINFO*)pvoid)->dwDLId = m_dwId;
					pDMInstrument->ulPatch = m_dwPatch;
				}
			}
		}
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dminstru.h ===
//
// dminstru.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//
// @doc EXTERNAL
//

#ifndef DMINSTRU_H
#define DMINSTRU_H

class CCollection;
class CInstrObj;

#include "alist.h"
#include "dmwavobj.h"
#include "dminsobj.h"

// IDirectMusicInstrumentPrivate
//

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrumentPrivate 
DECLARE_INTERFACE_(IDirectMusicInstrumentPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectMusicInstrumentPrivate
	// No methods at this time
};

DEFINE_GUID(IID_IDirectMusicInstrumentPrivate, 0xbcb20080, 0xa40c, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/*
@interface IDirectMusicInstrument | 
<i IDirectMusicInstrument> manages downloading
an individual instrument from a DLS collection 
(<i IDirectMusicCollection>.)

@comm 
The only way to create an <i IDirectMusicInstrument> for
downloading is to first open an <i IDirectMusicCollection>,
then call <om IDirectMusicCollection::GetInstrument>
to get the requested instrument.

To download an instrument, pass it to <om IDirectMusicPort::Download>,
which, if successful, returns a pointer to an
<i IDirectMusicDownloadedInstrument> interface. 
The <i IDirectMusicDownloadedInstrument> interface is
used only to unload the instrument.

@base public | IUnknown

@meth HRESULT | GetPatch | Returns the patch number of the instrument.
@meth HRESULT | SetPatch | Assign a new patch number to the instrument.

@xref <i IDirectMusicCollection>, <i IDirectMusicPort>,
<i IDirectMusicDownloadedInstrument>, 
<om IDirectMusicCollection::GetInstrument>,
<om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPerformance::DownloadInstrument>

@ex Access an instrument from a collection and download it. In addition,
set a range of notes within the instrument to download. This is not
required, but it can improve efficiency because only the waves needed
to render the specified range are downloaded to the synth. | 

	HRESULT myDownload(
		IDirectMusicCollection *pCollection,		// DLS collection.
		IDirectMusicPort *pPort,					// Port to download to.
		IDirectMusicDownloadedInstrument **ppDLInstrument, // Returned.
		DWORD dwPatch,								// Requested instrument.				
		DWORD dwLowNote,							// Low note of range.
		DWORD dwHighNote)							// High note of range.

	{
		HRESULT hr;
		IDirectMusicInstrument* pInstrument;
		hr = pCollection->GetInstrument(dwPatch, &pInstrument);
		if (SUCCEEDED(hr))
		{
			DMUS_NOTERANGE NoteRange[1]; // Optional note range.
			NoteRange[0].dwLowNote = dwLowNote;
			NoteRange[0].dwHighNote = dwHighNote;
			hr = pPort->DownloadInstrument(pInstrument, ppDLInstrument, NoteRange, 1);
			pInstrument->Release();
		}
		return hr;
	}
*/


class CInstrument : public IDirectMusicInstrument, public IDirectMusicInstrumentPrivate, public AListItem
{
friend class CCollection;
friend class CDirectMusicPortDownload;

public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicInstrument
	STDMETHODIMP GetPatch(DWORD* pdwPatch);
	STDMETHODIMP SetPatch(DWORD dwPatch);

private:
    // Class
    //
    CInstrument();
    ~CInstrument();

    CInstrument* GetNext() {return (CInstrument*)AListItem::GetNext();}

	HRESULT Init(DWORD dwPatch, 
				 CCollection* pParentCollection);

	HRESULT GetWaveCount(DWORD* pdwCount);
	HRESULT GetWaveDLIDs(DWORD* pdwIds);
	HRESULT GetWaveSize(DWORD dwId, DWORD* pdwSize, DWORD * pdwSampleSize);
	HRESULT GetWave(DWORD dwDLId, IDirectMusicDownload* pIDMDownload);
#ifdef DXAPI
    void SetPort(CDirectMusicPortDownload *pPort, BOOL fAllowDLS2);
#endif
	HRESULT GetInstrumentSize(DWORD* pdwSize);
	HRESULT GetInstrument(IDirectMusicDownload* pIDMDownload);
	
	DWORD GetInstrumentDLID()
	{
		if(m_dwId != 0xFFFFFFFF)
		{
			return m_dwId;
		}
		else
		{
			return m_pInstrObj->m_dwId;		
		}
	}
	
	void Cleanup();


private:
	CRITICAL_SECTION				m_DMICriticalSection;
    CMemTrack                       m_MemTrack;
	DWORD                           m_dwOriginalPatch;
    DWORD                           m_dwPatch;
	CCollection*			        m_pParentCollection;
	CInstrObj*						m_pInstrObj;
	CWaveObjList					m_WaveObjList;
	bool							m_bInited;
	DWORD							m_dwId;
	long							m_cRef;
};

class CInstrumentList : public AList
{
friend class CCollection;

private:
    CInstrumentList(){}
    ~CInstrumentList() 
    {
        while (!IsEmpty())
        {
            CInstrument* pInstrument = RemoveHead();
            if (pInstrument)
            {
                pInstrument->Release();
            }
        }
    }

    CInstrument* GetHead(){return (CInstrument*)AList::GetHead();}
    CInstrument* GetItem(LONG lIndex){return (CInstrument*)AList::GetItem(lIndex);}
    CInstrument* RemoveHead(){return (CInstrument*)AList::RemoveHead();}
    void Remove(CInstrument* pInstrument){AList::Remove((AListItem*)pInstrument);}
    void AddTail(CInstrument* pInstrument){AList::AddTail((AListItem*)pInstrument);}
};

#endif // #ifndef DMINSTRU_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmportdl.h ===
//
// dmportdl.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//

#ifndef DMPORTDL_H
#define DMPORTDL_H 

#include "dmusicc.h"
#include "dmdlinst.h"
#include "dmdload.h"
////#include "dmdlwave.h"
#include "..\shared\dmusiccp.h"

class CDLSFeature : public AListItem
{
public:
	CDLSFeature*    GetNext(){return(CDLSFeature*)AListItem::GetNext();}
    GUID    m_guidID;       // GUID for query.
    long    m_lResult;      // Data returned by query.
    HRESULT m_hr;           // Indicates whether the synth supported the Query.
};

class CDLSFeatureList : public AList
{
public:
    ~CDLSFeatureList() { Clear(); }
    void Clear()
	{
		while(!IsEmpty())
		{
			CDLSFeature* pFeature = RemoveHead();
			delete pFeature;
		}
	}
    CDLSFeature* GetHead(){return (CDLSFeature *)AList::GetHead();}
    CDLSFeature* RemoveHead(){return(CDLSFeature *)AList::RemoveHead();}
	void Remove(CDLSFeature* pFeature){AList::Remove((AListItem *)pFeature);}
};

#define DLB_HASH_SIZE   31  // Hash table for download buffer lists.

class CDirectSoundWave;

class CDirectMusicPortDownload : public IDirectMusicPortDownload
{
friend class CCollection;
friend class CInstrument;
friend class CInstrObj;
friend class CConditionChunk;
friend class CDirectMusicDownloadedWave;
friend class CDirectMusicVoice;
friend class CDirectSoundWaveDownload;

public:
    CDirectMusicPortDownload();
    virtual ~CDirectMusicPortDownload();

    STDMETHODIMP GetDLId(DWORD* pdwStartDLId, DWORD dwCount);
    
    STDMETHOD(Refresh)(
        THIS_
        DWORD dwDLId,
        DWORD dwFlags) PURE;

#ifdef XBOX
    STDMETHOD(IsReadyForData)(
        THIS_
        DWORD dwDLId) PURE;
#endif

    static void GetDLIdP(DWORD* pdwStartDLId, DWORD dwCount);
        
protected:
    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPortDownload
    STDMETHODIMP GetBuffer(DWORD dwId, IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP AllocateBuffer(DWORD dwSize, IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP FreeBuffer(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP GetAppend(DWORD* pdwAppend);

    
    // Class
    STDMETHODIMP DownloadP(IDirectMusicInstrument* pInstrument,
                           IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
                           DMUS_NOTERANGE* NoteRanges,
                           DWORD dwNumNoteRanges,
                           BOOL fVersion2);
    STDMETHODIMP UnloadP(IDirectMusicDownloadedInstrument* pDownloadedInstrument);
    
    STDMETHODIMP DownloadWaveP(IDirectSoundWave *pWave,               
                               IDirectSoundDownloadedWaveP **ppWave,
                               REFERENCE_TIME rtStartHint);
                               
    STDMETHODIMP UnloadWaveP(IDirectSoundDownloadedWaveP *pWave);                               

    STDMETHODIMP AllocVoice(
        IDirectSoundDownloadedWaveP *pWave,          // Wave to play on this voice
        DWORD dwChannel,                            // Channel and channel group
        DWORD dwChannelGroup,                       //  this voice will play on
        REFERENCE_TIME rtStart,
        SAMPLE_TIME stLoopStart,
        SAMPLE_TIME stLoopEnd,                                                        
        IDirectMusicVoiceP **ppVoice);               // Returned voice
        
    STDMETHODIMP GetCachedAppend(                                            
        DWORD *pdw);                                // DWORD to receive append        
        
        
private:  
    STDMETHODIMP GetBufferInternal(DWORD dwDLId,IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP QueryDLSFeature(REFGUID rguidID, long * plResult);
    void ClearDLSFeatures();
    STDMETHODIMP GetWaveRefs(IDirectMusicDownload* ppDownloadedBuffers[],
                             DWORD* pdwWaveRefs,
                             DWORD* pdwWaveIds,
                             DWORD dwNumWaves,
                             CInstrument* pCInstrument,
                             DMUS_NOTERANGE* NoteRanges,
                             DWORD dwNumNoteRanges);
    STDMETHODIMP FindDownloadedInstrument(DWORD dwId, CDownloadedInstrument** ppDMDLInst);
    STDMETHODIMP AddDownloadedInstrument(CDownloadedInstrument* pDMDLInst);
    STDMETHODIMP RemoveDownloadedInstrument(CDownloadedInstrument* pDMDLInst);
    
    STDMETHODIMP FindDownloadedWaveObject(IDirectSoundWave *pWave,
                                          CDirectMusicDownloadedWave **ppDLWave);
                                          
    STDMETHODIMP AddDownloadedWaveObject(CDirectMusicDownloadedWave *pDLWave);                                          

    STDMETHODIMP RemoveDownloadedWaveObject(CDirectMusicDownloadedWave *pDLWave);
    
    STDMETHODIMP AllocWaveArticulation(IDirectSoundWave *pWave, IDirectMusicDownload **ppDownload);
    
public:
    static CRITICAL_SECTION sDMDLCriticalSection;
    static DWORD sNextDLId;

protected:
    CDLSFeatureList             m_DLSFeatureList;       // Cached list of DLS queries, built and then freed during each download.
    CDLInstrumentList			m_DLInstrumentList;     // Linked list of downloaded instruments,
                                                        // each represented by an IDirectMusicDownloadedInstrument
                                                        // interface. 
    CDLBufferList	            m_DLBufferList[DLB_HASH_SIZE];         // Linked list of downloaded buffers, each
                                                        // represented by an IDirectMusicDownload interface.
    CRITICAL_SECTION			m_DMDLCriticalSection;  // For the interface
    BOOL                        m_fDMDLCSinitialized;    
    DWORD						m_dwAppend;             // Append in samples, as required by synth.
    DWORD                       m_fNewFormat;           // Set if the synth handles DMUS_INSTRUMENT2 chunks.
    long						m_cRef;
    
    // Additions to track downloaded wave objects
    //
//    CDMDLWaveList               m_DLWaveList;           // Holds all wave obj interfaces downloaded to this port

private:    
    CRITICAL_SECTION m_CDMDLCriticalSection; // for the class
    BOOL             m_fCDMDLCSinitialized;};

#define APPEND_NOT_RETRIEVED	0xFFFFFFFF
#define NEWFORMAT_NOT_RETRIEVED 0xFFFFFFFF

#endif // #ifndef DMPORTDL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmregion.cpp ===
//
// dmregion.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>
#include "dmusicp.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmart.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmregion.h"
#include "dls2.h"

//////////////////////////////////////////////////////////////////////
// Class CRegion

//////////////////////////////////////////////////////////////////////
// CRegion::CRegion

CRegion::CRegion()
{
#ifdef DXAPI
    m_dwCountExtChk = 0;
    m_fNewFormat = FALSE;
#endif
    m_fDLS1 = TRUE;
//    m_fCSInitialized = FALSE;
//	InitializeCriticalSection(&m_DMRegionCriticalSection);
//    m_fCSInitialized = TRUE;
	
	ZeroMemory(&m_RgnHeader, sizeof(m_RgnHeader));
	ZeroMemory(&m_WaveLink, sizeof(m_WaveLink));
	ZeroMemory(&m_WSMP, sizeof(m_WSMP));
	ZeroMemory(&m_WLOOP, sizeof(m_WLOOP));
}

//////////////////////////////////////////////////////////////////////
// CRegion::~CRegion

CRegion::~CRegion() 
{
    if (m_fCSInitialized)
    {
    	Cleanup();
//	    DeleteCriticalSection(&m_DMRegionCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CRegion::Load

HRESULT CRegion::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

	RIFFIO ckNext;
    BOOL fDLS1;

//	EnterCriticalSection(&m_DMRegionCriticalSection);
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        fDLS1 = FALSE;
		switch(ckNext.ckid)
		{
#ifdef DXAPI
        case FOURCC_CDL :
            hr = m_Condition.Load(pParser);
            break;
#endif
		case FOURCC_RGNH :
			hr = pParser->Read(&m_RgnHeader,sizeof(RGNHEADER));
			break;
		case FOURCC_WSMP :
			hr = pParser->Read(&m_WSMP, sizeof(WSMPL));
			if(m_WSMP.cSampleLoops)
			{
				hr = pParser->Read(m_WLOOP, sizeof(WLOOP));
			}
			break;
		case FOURCC_WLNK :
			hr = pParser->Read(&m_WaveLink,sizeof(WAVELINK));
			break;
		case FOURCC_LIST :
			switch (ckNext.fccType)
			{
            case FOURCC_LART :
                fDLS1 = TRUE;
            case FOURCC_LAR2 :
                CArticulation *pArticulation;
                                       
                try
                {
                    pArticulation = new CArticulation;
                }
                catch( ... )
                {
                    pArticulation = NULL;
                }

				if(pArticulation)
				{
                    pArticulation->m_fDLS1 = fDLS1;
					hr = pArticulation->Load(pParser);
                    m_ArticulationList.AddHead(pArticulation); 
				}
				else
				{
					hr =  E_OUTOFMEMORY;
				}
				
				break;

    		default:
				// If we get here we have an unknown chunk
#ifdef DXAPI
				CExtensionChunk* pExtensionChunk = new CExtensionChunk;
				if(pExtensionChunk)
				{
					hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);								
					m_dwCountExtChk++;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
#endif
                break;
			}
			break;

		default:
			// If we get here we have an unknown chunk
#ifdef DXAPI
			CExtensionChunk* pExtensionChunk = new CExtensionChunk;
			if(pExtensionChunk)
			{
				hr = pExtensionChunk->Load(pParser);
                m_ExtensionChunkList.AddHead(pExtensionChunk);								
				m_dwCountExtChk++;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
#endif
			break;
		}
	}
    pParser->LeaveList();
	if(FAILED(hr))
	{
		Cleanup();
	}
//	LeaveCriticalSection(&m_DMRegionCriticalSection);

	return hr; 
}	

//////////////////////////////////////////////////////////////////////
// CRegion::Cleanup

void CRegion::Cleanup()
{
//	EnterCriticalSection(&m_DMRegionCriticalSection);
	
    while(!m_ArticulationList.IsEmpty())
	{
		CArticulation* pArticulation = m_ArticulationList.RemoveHead();
		delete pArticulation;
	}
#ifdef DXAPI
	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		delete pExtChk;
	}
#endif	
//	LeaveCriticalSection(&m_DMRegionCriticalSection);
}

#ifdef DXAPI
DWORD CRegion::Count()

{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_Condition.m_fOkayToDownload)
    {
        DWORD dwCount = m_dwCountExtChk + 1;
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
                dwCount += pArticulation->Count();
                if (m_fNewFormat)
                {
                    pArticulation = pArticulation->GetNext();
                }
                else
                {
                    break;
                }
            }
        }
        return dwCount;
    }
    return 0;
}
#else
DWORD CRegion::Count()

{
	// Return the number of Offset Table entries needed during a call to Write
    DWORD dwCount = 1;
    CArticulation *pArticulation = m_ArticulationList.GetHead();
    while (pArticulation)
    {
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        if (pArticulation)
        {
            dwCount += pArticulation->Count();
            pArticulation = pArticulation->GetNext();
        }
    }
    return dwCount;
}
#endif
#ifdef DXAPI
void CRegion::SetPort(CDirectMusicPortDownload *pPort, BOOL fNewFormat, BOOL fSupportsDLS2)

{
    m_fNewFormat = fNewFormat;
    if (fSupportsDLS2)
    {
        m_Condition.Evaluate(pPort);
    }
    else
    {
        m_Condition.m_fOkayToDownload = m_fDLS1;
    }
    if (m_Condition.m_fOkayToDownload)
    {
 	    CArticulation *pArticulation = m_ArticulationList.GetHead();
        for (;pArticulation;pArticulation = pArticulation->GetNext())
        {
            pArticulation->SetPort(pPort,fNewFormat,fSupportsDLS2);
	    }
    }
}

BOOL CRegion::CheckForConditionals()

{
    BOOL fHasConditionals = FALSE;
 	CArticulation *pArticulation = m_ArticulationList.GetHead();
    for (;pArticulation;pArticulation = pArticulation->GetNext())
    {
        fHasConditionals = fHasConditionals || pArticulation->CheckForConditionals();
	}
    return fHasConditionals || !m_fDLS1 || m_Condition.HasChunk();
}
#endif
//////////////////////////////////////////////////////////////////////
// CRegion::Size
#ifdef DXAPI
DWORD CRegion::Size()
{
	DWORD dwSize = 0;
	DWORD dwCountExtChk = 0;

    if (!m_Condition.m_fOkayToDownload)
    {
        return 0;
    }

	dwSize += CHUNK_ALIGN(sizeof(DMUS_REGION));

	// Calculate the space need for Region's articulation
	CArticulation *pArticulation = m_ArticulationList.GetHead();
    while (pArticulation)
    {
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        if (pArticulation)
        {
		    dwSize += pArticulation->Size();
            if (m_fNewFormat)
            {
                pArticulation = pArticulation->GetNext();
            }
            else
            {
                break;
            }
        }
	}
	// Calculate the space need for Region's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwSize += pExtChk->Size();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk != dwCountExtChk)
	{
		assert(false);
		dwSize = 0;
	}
	
	return dwSize;
}
#else

DWORD CRegion::Size()
{
	DWORD dwSize = CHUNK_ALIGN(sizeof(DMUS_REGION));

	// Calculate the space need for Region's articulation
	CArticulation *pArticulation = m_ArticulationList.GetHead();
    while (pArticulation)
    {
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        if (pArticulation)
        {
		    dwSize += pArticulation->Size();
            pArticulation = pArticulation->GetNext();
        }
	}
	
	return dwSize;
}
#endif
//////////////////////////////////////////////////////////////////////
// CRegion::Write
#ifdef DXAPI
HRESULT CRegion::Write(void* pv, 
					   DWORD* pdwCurOffset, 
					   DWORD* pDMIOffsetTable, 
					   DWORD* pdwCurIndex, 
					   DWORD dwIndexNextRegion)
{
	HRESULT hr = S_OK;

	// Argument validation - Debug
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMIOffsetTable);
	assert(pdwCurIndex);

    if (!m_Condition.m_fOkayToDownload)
    {
        return S_OK;
    }

//    EnterCriticalSection(&m_DMRegionCriticalSection);

	CopyMemory(pv, (void *)&m_RgnHeader, sizeof(RGNHEADER));
	
	((DMUS_REGION*)pv)->WaveLink = m_WaveLink;
	((DMUS_REGION*)pv)->WSMP = m_WSMP;
	((DMUS_REGION*)pv)->WLOOP[0] = m_WLOOP[0];
	((DMUS_REGION*)pv)->ulNextRegionIdx = dwIndexNextRegion;

	*pdwCurOffset += CHUNK_ALIGN(sizeof(DMUS_REGION));
	DWORD dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_REGION));
	
	// Write extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	if(pExtChk)
	{
		DWORD dwCountExtChk = m_dwCountExtChk;
		DWORD dwIndexNextExtChk;
		((DMUS_REGION*)pv)->ulFirstExtCkIdx = dwIndexNextExtChk = *pdwCurIndex;
		
		for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
		{
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = dwIndexNextExtChk + 1;
			}
			
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
			dwCountExtChk--;
		}
	}
	else
	{
		// If no extension chunks set to zero
		((DMUS_REGION*)pv)->ulFirstExtCkIdx = 0;
	}
	if(SUCCEEDED(hr))
	{
        ((DMUS_REGION*)pv)->ulRegionArtIdx = 0;
		// Write region articulation if we have one
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
		{
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            if (m_fNewFormat)
            {
                pNextArt = pArticulation->GetNext();
                while (pNextArt && (pNextArt->Count() == 0))
                {
                    pNextArt = pNextArt->GetNext();
                }
                if (pNextArt)
                {
                    dwNextArtIndex = *pdwCurIndex + pArticulation->Count();
                }
            }
            if (((DMUS_REGION*)pv)->ulRegionArtIdx == 0)
            {
                ((DMUS_REGION*)pv)->ulRegionArtIdx = *pdwCurIndex;
            }
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
            hr = pArticulation->Write(((BYTE *)pv + dwRelativeCurOffset),
										pdwCurOffset,
										pDMIOffsetTable,
										pdwCurIndex,
                                        dwNextArtIndex);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
            pArticulation = pNextArt;
		}
	}

//	LeaveCriticalSection(&m_DMRegionCriticalSection);

	return hr;
}
#else

HRESULT CRegion::Write(void* pv, 
					   DWORD* pdwCurOffset, 
					   DWORD* pDMIOffsetTable, 
					   DWORD* pdwCurIndex, 
					   DWORD dwIndexNextRegion)
{
	HRESULT hr = S_OK;

	// Argument validation - Debug
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMIOffsetTable);
	assert(pdwCurIndex);

	CopyMemory(pv, (void *)&m_RgnHeader, sizeof(RGNHEADER));
	
	((DMUS_REGION*)pv)->WaveLink = m_WaveLink;
	((DMUS_REGION*)pv)->WSMP = m_WSMP;
	((DMUS_REGION*)pv)->WLOOP[0] = m_WLOOP[0];
	((DMUS_REGION*)pv)->ulNextRegionIdx = dwIndexNextRegion;

	*pdwCurOffset += CHUNK_ALIGN(sizeof(DMUS_REGION));
	DWORD dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_REGION));
	
	{
        ((DMUS_REGION*)pv)->ulRegionArtIdx = 0;
		// Write region articulation if we have one
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
		{
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            pNextArt = pArticulation->GetNext();
            while (pNextArt && (pNextArt->Count() == 0))
            {
                pNextArt = pNextArt->GetNext();
            }
            if (pNextArt)
            {
                dwNextArtIndex = *pdwCurIndex + pArticulation->Count();
            }
            if (((DMUS_REGION*)pv)->ulRegionArtIdx == 0)
            {
                ((DMUS_REGION*)pv)->ulRegionArtIdx = *pdwCurIndex;
            }
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
            hr = pArticulation->Write(((BYTE *)pv + dwRelativeCurOffset),
										pdwCurOffset,
										pDMIOffsetTable,
										pdwCurIndex,
                                        dwNextArtIndex);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
            pArticulation = pNextArt;
		}
	}

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmsport7.h ===
//
// dmsport7.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort7 implementation; code specific to DX-7 style ports
// 
#ifndef _DMSPORT7_H_
#define _DMSPORT7_H_

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7
//
class CDirectMusicSynthPort7 : public CDirectMusicSynthPort
{
public:
    CDirectMusicSynthPort7(
        PORTENTRY           *pe,
        CDirectMusic        *pDM,
        IDirectMusicSynth   *pSynth);

    ~CDirectMusicSynthPort7();

    HRESULT Initialize(
        DMUS_PORTPARAMS *pPortParams);   

    // Overridden public methods
    //
    STDMETHODIMP Close();

    STDMETHODIMP Activate(
        BOOL fActivate);

    STDMETHODIMP KsProperty(
        IN PKSPROPERTY  pProperty,
        IN ULONG        ulPropertyLength,
        IN OUT LPVOID   pvPropertyData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned);

    STDMETHODIMP GetFormat(
        LPWAVEFORMATEX  pwfex,
        LPDWORD         pdwwfex,
        LPDWORD         pcbBuffer);

    STDMETHODIMP SetDirectSound(
        LPDIRECTSOUND       pDirectSound,
        LPDIRECTSOUNDBUFFER pDirectSoundBuffer);

private:
    void CacheSinkUsesDSound();

private:
    IDirectMusicSynth       *m_pSynth;              // 6.1/7.0 Synth 
    IDirectMusicSynthSink   *m_pSink;               //  and sink 
    bool                    m_fSinkUsesDSound;      // Does sink use dsound?
    bool                    m_fUsingDirectMusicDSound;
                                                    // Using default dsound
    LPDIRECTSOUND           m_pDirectSound;         // Directsound object and
    LPDIRECTSOUNDBUFFER     m_pDirectSoundBuffer;   //  buffer
    LPWAVEFORMATEX          m_pwfex;                // Cached wave format
    long                    m_lActivated;           // Is port active?
    bool                    m_fHasActivated;        // Has it ever activated?
};

#endif // _DMSPORT7_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmregion.h ===
//
// dmregion.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#ifndef DMREGION_H
#define DMREGION_H

#include "dmextchk.h"
#include "dmart.h"

class CRiffParser;

class CRegion : public AListItem
{
friend CInstrObj;

public:
	CRegion(); 
	~CRegion();

	CRegion* GetNext(){return(CRegion*)AListItem::GetNext();}
	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* pdwCurOffset, DWORD* pDMIOffsetTable, 
        DWORD* pdwCurIndex, DWORD dwIndexNextRegion);
#ifdef DXAPI
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2);
    BOOL CheckForConditionals();
#endif
	DWORD Size();
	DWORD Count();

	DWORD GetWaveId() {return(m_WaveLink.ulTableIndex);};
private:
	void Cleanup();

private:
//    CRITICAL_SECTION	m_DMRegionCriticalSection;
    BOOL                m_fCSInitialized;
public:
	RGNHEADER			m_RgnHeader;
	WAVELINK			m_WaveLink;
	WSMPL				m_WSMP;
	WLOOP				m_WLOOP[1];
private:
	CArticulationList	m_ArticulationList;
#ifdef DXAPI
    CConditionChunk     m_Condition;            // Optional conditional chunk;
	CExtensionChunkList m_ExtensionChunkList;
	DWORD				m_dwCountExtChk;
    BOOL                m_fNewFormat;           // Port can handle new format.
#endif
    BOOL                m_fDLS1;                // This is a DLS1 region.
};

class CRegionList : public AList
{
friend class CInstrObj;
friend class CCDirectMusicPortDownload;

public:
	CRegionList(){}
	~CRegionList() 
	{
		while(!IsEmpty())
		{
			CRegion* pRegion = RemoveHead();
			delete pRegion;
		}
	}

    CRegion* GetHead(){return(CRegion *)AList::GetHead();}
	CRegion* GetItem(LONG lIndex){return(CRegion*)AList::GetItem(lIndex);}
    CRegion* RemoveHead(){return(CRegion *)AList::RemoveHead();}
	void Remove(CRegion* pRegion){AList::Remove((AListItem *)pRegion);}
	void AddTail(CRegion* pRegion){AList::AddTail((AListItem *)pRegion);}
};

#endif // #ifndef DMREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmsport.cpp ===
//
// dmsport.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort implementation; code common to DX7 and DX8 style ports.
// 
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"

#include "dmsport7.h"
#include "dmsport8.h"

const GUID guidZero = {0};

HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData);

////////////////////////////////////////////////////////////////////////////////
//
// CreateCDirectMusicSynthPort
//
// Determine which type of port (DX7 or DX8) is being created and which
// types the requested synth supports. Create the highest level of 
// port possible.
//
HRESULT 
CreateCDirectMusicSynthPort(
    PORTENTRY               *pe, 
    CDirectMusic            *pDM, 
    UINT                    uVersion,
    DMUS_PORTPARAMS         *pPortParams,
    IDirectMusicPort        **ppPort)
{
    HRESULT hr = S_OK;

    // Determine what type of connection we can get. We can only
    // do DX-8 if we've been asked for it and the synth supports
    // it.
    //
    IDirectMusicSynth *pSynth = NULL;
    IDirectMusicSynth8 *pSynth8 = NULL;

    bool fAudioPath = false;

    if (uVersion >= 8 && (pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES))
    {
        fAudioPath = (pPortParams->dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH) ? true : false;
    }

    if (!fAudioPath)
    {
        // Specifically requested old style interface.
        //
        uVersion = 7;
    }

    if (uVersion >= 8) 
    {
        // Asked for DX-8 interfaces.
        //
		hr = DirectMusicCreateInstance(
            pe->pc.guidPort,
            NULL,
            IID_IDirectMusicSynth8,
            (void**)&pSynth8);

        // If creation failed for some legitimate reason, return.
        // If E_NOINTERFACE then we can try to fall back on DX-7.
        //
        if (FAILED(hr) && hr != E_NOINTERFACE)
        {
            return hr;
        }
    }

    if (uVersion < 8 || hr == E_NOINTERFACE)
    {
        // Asked for DX-7 interfaces or we couldn't get DX-8 interfaces.
        //
        hr = DirectMusicCreateInstance(
            pe->pc.guidPort,
            NULL,
            IID_IDirectMusicSynth,
            (void**)&pSynth);
        // If synth doesn't support that, we have nothing to fall back
        // onto.
        //
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    // Create and initialize the correct type of port.
    //        
    if (pSynth)
    {
        assert(!pSynth8);
#ifndef XBOX    
        CDirectMusicSynthPort7 *pPort7 = new CDirectMusicSynthPort7(pe, pDM, pSynth);

        if (pPort7 == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPort7->Initialize(pPortParams);
        }

        if (SUCCEEDED(hr))
        {
            *ppPort = static_cast<IDirectMusicPort*>(pPort7);
            (*ppPort)->AddRef();
        }

        RELEASE(pPort7);
        RELEASE(pSynth);

        if (SUCCEEDED(hr) && fAudioPath)
        {
            // They asked for an audio path but ended up without it
            //
            pPortParams->dwFeatures &= ~DMUS_PORT_FEATURE_AUDIOPATH;
            hr = S_FALSE;
        }
#endif
    }
    else if (pSynth8)
    {
        assert(!pSynth);

        CDirectMusicSynthPort8 *pPort8 = new CDirectMusicSynthPort8(pe, pDM, pSynth8);

        if (pPort8 == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPort8->Initialize(pPortParams);
        }

        if (SUCCEEDED(hr))
        {
            pPort8->QueryInterface(IID_IDirectMusicPort,(void **) ppPort);
        }

        RELEASE(pPort8);
        RELEASE(pSynth8);
    }
    else
    {
        assert(false);
    }

    return hr;
}   

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::CDirectMusicSynthPort
//
CDirectMusicSynthPort::CDirectMusicSynthPort(
    PORTENTRY           *pPE,
    CDirectMusic        *pDM,
    IDirectMusicSynth   *pSynth)
{
    m_cRef                  = 1;
    
    m_pDM                   = pDM;
    m_pSynth                = pSynth;
    m_dmpc                  = pPE->pc;

    m_pNotify               = NULL;
    m_pSynthPropSet         = NULL;
    m_pSinkPropSet          = NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::~CDirectMusicSynthPort
//
CDirectMusicSynthPort::~CDirectMusicSynthPort()
{
    Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::QueryInterface
//
STDMETHODIMP
CDirectMusicSynthPort::QueryInterface(const IID &iid,
                                        void **ppv)
{
    V_INAME(IDirectMusicPort::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortDownload)
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);		
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicSynthPort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicSynthPort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Initialize
//
// Initialization common to all versions
//
HRESULT
CDirectMusicSynthPort::Initialize(
    DMUS_PORTPARAMS *pPortParams)
{
    HRESULT hr;

    // Get our notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (SUCCEEDED(hr))
    {
        // HACK HACK: Don't hold a refcount against DirectMusic
        //
        m_pNotify->Release();
    }
    else
    {
        TraceI(1, "Failed to get IDirectMusicPortNotify\n");
    }

    // Save off property set handler
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->QueryInterface(
            IID_IKsControl, 
            (void**)&m_pSynthPropSet);
        if (FAILED(hr)) 
        {
            TraceI(1, "NOTE: Synth has no property set\n");
              
            // This is a warning, not an error
            //
            hr = S_OK;
        }
    }

    // Cache number of channel groups
    //
    if (SUCCEEDED(hr))
    {
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else
        {
            m_dwChannelGroups = 1;
        }

        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES)
        {
            m_dwFeatures = pPortParams->dwFeatures;
        }
        else
        {
            m_dwFeatures = 0;
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Close
//
STDMETHODIMP CDirectMusicSynthPort::Close()
{
    if (m_pNotify)
    {   
        m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        m_pNotify = NULL;
    }

    RELEASE(m_pSynthPropSet);
    RELEASE(m_pSinkPropSet);

    m_pDM = NULL;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::InitChannelPriorities 
//
//
static DWORD adwChannelPriorities[16] =
{
    DAUD_CHAN1_DEF_VOICE_PRIORITY,
    DAUD_CHAN2_DEF_VOICE_PRIORITY,
    DAUD_CHAN3_DEF_VOICE_PRIORITY,
    DAUD_CHAN4_DEF_VOICE_PRIORITY,
    DAUD_CHAN5_DEF_VOICE_PRIORITY,
    DAUD_CHAN6_DEF_VOICE_PRIORITY,
    DAUD_CHAN7_DEF_VOICE_PRIORITY,
    DAUD_CHAN8_DEF_VOICE_PRIORITY,
    DAUD_CHAN9_DEF_VOICE_PRIORITY,
    DAUD_CHAN10_DEF_VOICE_PRIORITY,
    DAUD_CHAN11_DEF_VOICE_PRIORITY,
    DAUD_CHAN12_DEF_VOICE_PRIORITY,
    DAUD_CHAN13_DEF_VOICE_PRIORITY,
    DAUD_CHAN14_DEF_VOICE_PRIORITY,
    DAUD_CHAN15_DEF_VOICE_PRIORITY,
    DAUD_CHAN16_DEF_VOICE_PRIORITY
};

void CDirectMusicSynthPort::InitChannelPriorities(
    UINT uLowCG,
    UINT uHighCG)
{
    while (uLowCG <= uHighCG)
    {
        for (UINT uChannel = 0; uChannel < 16; uChannel++)
        {
            m_pSynth->SetChannelPriority(uLowCG, uChannel, adwChannelPriorities[uChannel]);        
        }

        uLowCG++;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetSinkKsControl 
//
//
void CDirectMusicSynthPort::SetSinkKsControl(
    IKsControl *pSinkKsControl)
{
    RELEASE(m_pSinkPropSet);

    m_pSinkPropSet = pSinkKsControl;
    if (m_pSinkPropSet) 
    {
        m_pSinkPropSet->AddRef();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::InitializeVolumeBoost
//
//
void CDirectMusicSynthPort::InitializeVolumeBoost()
{
    HRESULT hr;

    if (m_pSynthPropSet)
    {
    	// set volume boost
        //
    	KSPROPERTY ksp;
    	ULONG cb;
        ULONG lVolume = 0;          // zero boost by default

    	ZeroMemory(&ksp, sizeof(ksp));
    	ksp.Set   = KSPROPSETID_Synth;
    	ksp.Id    = KSPROPERTY_SYNTH_VOLUMEBOOST;
    	ksp.Flags = KSPROPERTY_TYPE_SET;

    	hr = m_pSynthPropSet->KsProperty(&ksp,
    		     				        sizeof(ksp),
    			     			        (LPVOID)&lVolume,
    				     		        sizeof(lVolume),
    					     	        &cb);
        if (FAILED(hr))
        {
            TraceI(2, "NOTE: Set volume boost failed %08X\n", hr);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Compact
//
STDMETHODIMP CDirectMusicSynthPort::Compact()
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetCaps
//
STDMETHODIMP CDirectMusicSynthPort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &m_dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DeviceIoControl
//
STDMETHODIMP CDirectMusicSynthPort::DeviceIoControl(
    DWORD           dwIoControlCode, 
    LPVOID          lpInBuffer, 
    DWORD           nInBufferSize, 
    LPVOID          lpOutBuffer, 
    DWORD           nOutBufferSize, 
    LPDWORD         lpBytesReturned, 
    LPOVERLAPPED    lpOverlapped)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetNumChannelGroups
//
STDMETHODIMP CDirectMusicSynthPort::SetNumChannelGroups(
    DWORD dwChannelGroups)      
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = m_pSynth->SetNumChannelGroups(dwChannelGroups);

    if (FAILED(hr))
    {
        return hr;
    }

    if (dwChannelGroups > m_dwChannelGroups)
    {
        InitChannelPriorities(m_dwChannelGroups + 1, dwChannelGroups);
    }
    
    m_dwChannelGroups = dwChannelGroups;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetNumChannelGroups
//
STDMETHODIMP CDirectMusicSynthPort::GetNumChannelGroups(
    LPDWORD pdwChannelGroups)      
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = m_dwChannelGroups;
    
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::PlayBuffer
//
STDMETHODIMP CDirectMusicSynthPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    REFERENCE_TIME rt;
    DWORD cb;
    LPBYTE lpb;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    hr = pIBuffer->GetStartTime(&rt);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetUsedBytes(&cb);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetRawBufferPtr(&lpb);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }
    
    return m_pSynth->PlayBuffer(rt, lpb, cb);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetEventNotification
//
STDMETHODIMP CDirectMusicSynthPort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Read
//
STDMETHODIMP CDirectMusicSynthPort::Read(
	IDirectMusicBuffer *pIBuffer)                          
{
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);
    
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DownloadInstrument
//
STDMETHODIMP CDirectMusicSynthPort::DownloadInstrument(
    IDirectMusicInstrument* pInstrument,
    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
    DMUS_NOTERANGE* pNoteRanges,
    DWORD dwNumNoteRanges)
{
    V_INAME(IDirectMusicPort::DownloadInstrument);
    V_INTERFACE(pInstrument);
	V_PTRPTR_WRITE(ppDownloadedInstrument);
	V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	return CDirectMusicPortDownload::DownloadP(pInstrument,
											   ppDownloadedInstrument,
											   pNoteRanges,
											   dwNumNoteRanges,
                                               TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::UnloadInstrument
//
STDMETHODIMP CDirectMusicSynthPort::UnloadInstrument(
    IDirectMusicDownloadedInstrument* pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	return CDirectMusicPortDownload::UnloadP(pDownloadedInstrument);
}

//////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Download
//
STDMETHODIMP CDirectMusicSynthPort::Download(
	IDirectMusicDownload* pIDMDownload)	
{
    V_INAME(IDirectMusicPort::Download);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);

	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();		

		hr = ((CDownloadBuffer *)pIDMDownload)->IsDownloaded();
		if(hr != S_FALSE)
		{
			LeaveCriticalSection(&m_DMDLCriticalSection);
			return DMUS_E_ALREADY_DOWNLOADED;
		}

		void* pvBuffer = NULL;

		hr = ((CDownloadBuffer *)pIDMDownload)->GetBuffer(&pvBuffer);

		if(pvBuffer == NULL)
		{
			hr = DMUS_E_BUFFERNOTSET;
		}

        if (SUCCEEDED(hr) && !(m_dwFeatures & DMUS_PORT_FEATURE_STREAMING))
        {
            DMUS_DOWNLOADINFO *pdl = (DMUS_DOWNLOADINFO*)pvBuffer;

            if (pdl->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE)
            {
                // That feature is disabled, pretend we don't understand
                //
                hr = DMUS_E_UNKNOWNDOWNLOAD;
            }
        }

		BOOL bFree = false;
		if(SUCCEEDED(hr))
		{
			hr = m_pSynth->Download(&(((CDownloadBuffer *)pIDMDownload)->m_DLHandle),
									pvBuffer, 
									&bFree);

			if(SUCCEEDED(hr))
			{
				// AddRef() before we add it to the list.
				pIDMDownload->AddRef();
                DWORD dwID = ((DMUS_DOWNLOADINFO*)pvBuffer)->dwDLId;
				((CDownloadBuffer *)pIDMDownload)->m_dwDLId = dwID;
				m_DLBufferList[dwID % DLB_HASH_SIZE].AddHead((CDownloadBuffer*)pIDMDownload);
				((CDownloadBuffer*)pIDMDownload)->IncDownloadCount();

				if(bFree)
				{
					pvBuffer = NULL;
                    DWORD dw;
					((CDownloadBuffer *)pIDMDownload)->GetHeader(&pvBuffer, &dw);
					((CDownloadBuffer *)pIDMDownload)->SetBuffer(NULL, 0, 0);
					delete [] pvBuffer;
				}
				else
				{
					// If we do not free buffer we need to AddRef()
					// We do not want buffer to go away until the IDirectMusicPort is 
					// finished with it.
					pIDMDownload->AddRef();
				}
			}
			else if(FAILED(hr))
			{
				((CDownloadBuffer *)pIDMDownload)->m_DLHandle = NULL;
			}
		}
	}
	
	LeaveCriticalSection(&m_DMDLCriticalSection);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Unload
//
STDMETHODIMP CDirectMusicSynthPort::Unload(
	IDirectMusicDownload* pIDMDownload)	
{
    V_INAME(IDirectMusicPort::Unload);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);


	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();

        if (((CDownloadBuffer *)pIDMDownload)->IsDownloaded() == S_OK)
        {
		    if(((CDownloadBuffer *)pIDMDownload)->DecDownloadCount() == 0)
		    {
			    m_DLBufferList[((CDownloadBuffer *)pIDMDownload)->m_dwDLId % DLB_HASH_SIZE].Remove(
                    (CDownloadBuffer *)pIDMDownload);
			    pIDMDownload->Release();
			    hr = m_pSynth->Unload(((CDownloadBuffer *)pIDMDownload)->m_DLHandle, FreeHandle, (HANDLE)pIDMDownload);
		    }
        }
        else
        {
            TraceI(0, "CDirectMusicSynthPort::Unload- not downloaded\n");
        }
	}

	LeaveCriticalSection(&m_DMDLCriticalSection);
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetAppend
//
STDMETHODIMP CDirectMusicSynthPort::GetAppend(
    DWORD* pdwAppend)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    V_INAME(IDirectMusicPort::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    return m_pSynth->GetAppend(pdwAppend);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetLatencyClock
//
STDMETHODIMP CDirectMusicSynthPort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetLatencyClock(ppClock);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetRunningStats
//
STDMETHODIMP CDirectMusicSynthPort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetRunningStats(pStats);
}

#if 0
// XXX Different

#endif

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::SetChannelPriority
//
STDMETHODIMP CDirectMusicSynthPort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->SetChannelPriority(dwChannelGroup, dwChannel, dwPriority);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::GetChannelPriority
//
STDMETHODIMP CDirectMusicSynthPort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    V_INAME(IDirectMusicPort::GetChannelPriority);
    V_PTR_WRITE(pdwPriority, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::SetDirectSound
//
// XXX What does this mean in terms of DX8?
// XXX This can probably become pure virtual
//
STDMETHODIMP
CDirectMusicSynthPort::SetDirectSound(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetFormat
//
// XXX What does pcbBuffer mean in terms of DX8?
// XXX This can probably become pure virtual
//
STDMETHODIMP CDirectMusicSynthPort::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DownloadWave
//
STDMETHODIMP CDirectMusicSynthPort::DownloadWave(
    IDirectSoundWave *pWave,          
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::UnloadWave
//
STDMETHODIMP CDirectMusicSynthPort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AllocVoice
//
STDMETHODIMP 
CDirectMusicSynthPort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,         
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicSynthPort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    V_INAME(IDirectMusicPort::AssignChannelToBuses);
    V_BUFPTR_WRITE(pdwBuses, sizeof(DWORD) * cBusCount);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::StartVoice
//
STDMETHODIMP CDirectMusicSynthPort::StartVoice(          
    DWORD dwVoiceId,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    DWORD dwDLId,
    LONG prPitch,
    LONG vrVolume,
    SAMPLE_TIME stVoiceStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::StopVoice
//
STDMETHODIMP CDirectMusicSynthPort::StopVoice(          
    DWORD dwVoiceId,
    REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetVoiceState
//
STDMETHODIMP CDirectMusicSynthPort::GetVoiceState(
    DWORD dwVoice[], 
    DWORD cbVoice,
    DMUS_VOICE_STATE VoiceState[]) 
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Refresh
//
STDMETHODIMP CDirectMusicSynthPort::Refresh(
    DWORD dwDownloadId,
    DWORD dwFlags)
{
    return E_NOTIMPL;
}

#ifdef XBOX
STDMETHODIMP CDirectMusicSynthPort::IsReadyForData(
    DWORD dwDownloadId)
{
    return E_NOTIMPL;
}
#endif


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetSink
//
STDMETHODIMP CDirectMusicSynthPort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetSink
//
STDMETHODIMP CDirectMusicSynthPort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsProperty
//
STDMETHODIMP CDirectMusicSynthPort::KsProperty(
        IN PKSPROPERTY  pProperty,
        IN ULONG        ulPropertyLength,
        IN OUT LPVOID   pvPropertyData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    LONG lVolume;

    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);

    // pvPropertyData is not optional on a SET operation
    //
    if (pProperty->Flags & KSPROPERTY_TYPE_SET)
    {
        V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
    } 
    else 
    {
        V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    }
    
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;

    // Don't let callers touch property sets we use
    //
    if (pProperty->Set == KSPROPSETID_Synth) 
    {
        if (pProperty->Id != KSPROPERTY_SYNTH_VOLUME)
        {
            return DMUS_E_UNKNOWN_PROPERTY;
        }
        else if (ulDataLength != sizeof(LONG))
        {
            return E_INVALIDARG;
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_SET)
        {
            lVolume = *(LONG*)pvPropertyData;

            // Clamp to -200..+20 db
            //
            if (lVolume < -20000) 
            {
                lVolume = -20000;
                pvPropertyData = &lVolume;
            }
            else if (lVolume > 2000)
            {
                lVolume = 2000;
                pvPropertyData = &lVolume;
            }
        }
    }
    else if (pProperty->Set == KSPROPSETID_Synth_Dls)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }


    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsProperty(pProperty, 
                                         ulPropertyLength,
                                         pvPropertyData,
                                         ulDataLength,
                                         pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsProperty(pProperty, 
                                        ulPropertyLength,
                                        pvPropertyData,
                                        ulDataLength,
                                        pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsMethod
//
STDMETHODIMP CDirectMusicSynthPort::KsMethod(
        IN PKSMETHOD    pMethod,
        IN ULONG        ulMethodLength,
        IN OUT LPVOID   pvMethodData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // If they don't support it, then it's unknown
    //
    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;
    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsMethod(pMethod, 
                                       ulMethodLength,
                                       pvMethodData,
                                       ulDataLength,
                                       pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsMethod(pMethod, 
                                      ulMethodLength,
                                      pvMethodData,
                                      ulDataLength,
                                      pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsEvent
//
STDMETHODIMP CDirectMusicSynthPort::KsEvent(
        IN PKSEVENT     pEvent,
        IN ULONG        ulEventLength,
        IN OUT LPVOID   pvEventData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;

    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsEvent(pEvent, 
                                      ulEventLength,
                                      pvEventData,
                                      ulDataLength,
                                      pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsEvent(pEvent, 
                                     ulEventLength,
                                     pvEventData,
                                     ulDataLength,
                                     pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// FreeHandle - Callback function used by Synth
//
HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData)
{
    DWORD dw;
	void* pvBuffer = NULL;
	HRESULT hr = ((CDownloadBuffer *)hUserData)->GetHeader(&pvBuffer, &dw);
	
	if(SUCCEEDED(hr))
	{
		hr = ((CDownloadBuffer *)hUserData)->SetBuffer(NULL, 0, 0);
		delete [] pvBuffer;
	}

	((CDownloadBuffer *)hUserData)->Release();

	return hr;
}

#if 0
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetCachedFormat
//
HRESULT CDirectMusicSynthPort::GetCachedFormat(LPWAVEFORMATEX *ppwfex)
{
    HRESULT hr;

    if (m_pwfex == NULL) 
    {
        DWORD cbWaveFormat;

        hr = m_pSynth->GetFormat(NULL, &cbWaveFormat);
        if (FAILED(hr))
        {
            TraceI(0, "DownloadWave: Synth failed GetFormat size query %08X\n", hr);
            return hr;
        }

        m_pwfex = (LPWAVEFORMATEX)(new BYTE[cbWaveFormat]);
        if (m_pwfex == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = m_pSynth->GetFormat(m_pwfex, &cbWaveFormat);
        if (FAILED(hr)) 
        {
            delete[] m_pwfex;
            m_pwfex =  NULL;

            TraceI(0, "DownloadWave: Synth failed GetFormat %08X\n", hr);
            return hr;
        }
    }

    *ppwfex = m_pwfex;

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmsport7.cpp ===
//
// dmsport7.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort7 implementation; code specific to DX-7 style ports
// 
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"
#include "dmsport7.h"
#include "..\shared\dmusiccp.h" // For class ids.
#include "..\shared\xcreate.h"

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CDirectMusicSynthPort7
//
//
CDirectMusicSynthPort7::CDirectMusicSynthPort7(
    PORTENTRY           *pe,
    CDirectMusic        *pDM,
    IDirectMusicSynth   *pSynth) :

        CDirectMusicSynthPort(pe, pDM, pSynth)
{
    m_pSynth = pSynth;
    m_pSynth->AddRef();

    m_pSink                     = NULL;
    m_fSinkUsesDSound           = false;
    m_fUsingDirectMusicDSound   = false;    
    m_pDirectSound              = NULL;
    m_pDirectSoundBuffer        = NULL;
    m_pwfex                     = NULL;
    m_lActivated                = 0;
    m_fHasActivated             = false;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CDirectMusicSynthPort7
//
//
CDirectMusicSynthPort7::~CDirectMusicSynthPort7()
{
    Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Initialize
//
//
HRESULT CDirectMusicSynthPort7::Initialize(
    DMUS_PORTPARAMS *pPortParams)
{
    HRESULT             hrOpen;

    HRESULT             hr = CDirectMusicSynthPort::Initialize(pPortParams);
	IReferenceClock*    pClock = NULL;

    // Create the sink
    //
    if (SUCCEEDED(hr))
    {
        hr = DirectMusicCreateInstance(CLSID_DirectMusicSynthSink,
                              NULL,IID_IDirectMusicSynthSink,(LPVOID*)&m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "DirectMusicCreateInstance sink %08X\n", hr);
        }
    }

    // Give the sink's IKsControl to the base class. This needs to be
    // done here since the sink is a different type between 7 and 8.
    //
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;

        HRESULT hrTemp = m_pSink->QueryInterface(
            IID_IKsControl, 
            (void**)&pKsControl);
        if (FAILED(hrTemp))
        {
            TraceI(2, "NOTE: Sink has no property set interface.\n");
        }

        SetSinkKsControl(pKsControl);
        RELEASE(pKsControl);
    }

    // Get the master clock and give it to the synth and sink
    //
    if (SUCCEEDED(hr))
    {	
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to GetMasterClock %08X\n", hr);
        }
    }

    if (SUCCEEDED(hr)) 
    {
        hr = m_pSynth->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetMasterClock on synth %08X\n", hr);
        }
    }        

    if (SUCCEEDED(hr)) 
    {
        hr = m_pSink->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetMasterClock on sink %08X\n", hr);
        }
    }        

    // Connect sink to synth
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->SetSynthSink(m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetSink on synth %08X\n", hr);
        }
    }

    // Open the synth. We have to be careful to save the return code because
    // if S_FALSE is returned here it must be returned to the caller.
    //
    if (SUCCEEDED(hr))
    {
    	hrOpen = m_pSynth->Open(pPortParams);
        if (FAILED(hrOpen))
        {
            hr = hrOpen;
            TraceI(1, "Failed to open synth %08lX\n", hr);
        }
    }

    // Initialize channel priorities and volume boost
    //
    if (SUCCEEDED(hr))
    {
        InitChannelPriorities(1, m_dwChannelGroups);
        InitializeVolumeBoost();
    }

    CacheSinkUsesDSound();

    RELEASE(pClock);

    return SUCCEEDED(hr) ? hrOpen : hr;
}       

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Close
//
STDMETHODIMP CDirectMusicSynthPort7::Close()
{
    if (m_pSynth)
    {
        m_pSynth->Activate(FALSE);
        m_pSynth->Close();

        RELEASE(m_pSynth);
    }

    RELEASE(m_pSink);
    RELEASE(m_pDirectSoundBuffer);
    RELEASE(m_pDirectSound);

    delete[] m_pwfex;
    m_pwfex = NULL;

    CDirectMusicSynthPort::Close();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Activate
//
STDMETHODIMP CDirectMusicSynthPort7::Activate(
    BOOL fActivate)
{
    HRESULT hr;

	V_INAME(IDirectMusicPort::Activate);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }
	
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (m_fSinkUsesDSound)
        {
            if (m_pDirectSound == NULL)
            {
                m_fUsingDirectMusicDSound = true;

                hr = m_pDM->GetDirectSoundI(&m_pDirectSound);
                if (FAILED(hr))
                {
                    m_pDirectSound = NULL;
                    m_fUsingDirectMusicDSound = false;
                    m_lActivated = 0;
                    return hr;
                }
            }

            hr = m_pSink->SetDirectSound(m_pDirectSound, m_pDirectSoundBuffer);
            if (FAILED(hr))
            {
                if (m_fUsingDirectMusicDSound)
                {
                    m_pDM->ReleaseDirectSoundI();
                    m_pDirectSound = NULL;
                }
                m_fUsingDirectMusicDSound = false;
                m_lActivated = 0;
                return hr;
            }
        }
    }

    hr = m_pSynth->Activate(fActivate);
    if (FAILED(hr))
    {
        // Flip back activate state -- operation failed
        //
        m_lActivated = fActivate ? 0 : 1;

        return hr;
    }

    // XXX Reset activation flags???
    //
    if (fActivate)
    {
        m_fHasActivated = true;
    }
    else
    {
        if (m_fSinkUsesDSound)
        {
            m_pSink->SetDirectSound(NULL, NULL);        
            if (m_fUsingDirectMusicDSound)
            {
                m_pDM->ReleaseDirectSoundI();
                m_pDirectSound = NULL;
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::KsProperty
//
STDMETHODIMP CDirectMusicSynthPort7::KsProperty(
    IN PKSPROPERTY  pProperty,
    IN ULONG        ulPropertyLength,
    IN OUT LPVOID   pvPropertyData,
    IN ULONG        ulDataLength,
    OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (pProperty->Set == GUID_DMUS_PROP_SetSynthSink &&
        pProperty->Id == 0)
    {
        if (pProperty->Flags & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if (ulDataLength < sizeof(ULONG))
            {
                return E_INVALIDARG;
            }
            else
            {
                *PULONG(pvPropertyData) = KSPROPERTY_TYPE_BASICSUPPORT |
                                          KSPROPERTY_TYPE_SET;
                *pulBytesReturned = sizeof(ULONG);
                return S_OK;
            }
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_GET)
        {
            return DMUS_E_GET_UNSUPPORTED;
        }

        // Trying to set a sink. Take care of it in the port
        //
        if (m_fHasActivated)
        {
            return DMUS_E_ALREADY_ACTIVATED;
        }

        if (ulDataLength != sizeof(LPUNKNOWN))
        {
            return E_INVALIDARG;
        }
            
        LPUNKNOWN pUnknown = *(LPUNKNOWN*)pvPropertyData;
        V_INTERFACE(pUnknown);

        IDirectMusicSynthSink *pSink;

        HRESULT hr;        
        hr = pUnknown->QueryInterface(IID_IDirectMusicSynthSink, (void**)&pSink);
        if (FAILED(hr))
        {
            return hr;
        }

        m_pSink->Release();
        m_pSink = pSink;
        m_pSink->AddRef();

        // Give synth sink master clock
        //
        IReferenceClock* pClock;
        
        hr = m_pDM->GetMasterClock(NULL, &pClock);

        if (FAILED(hr))
        {
            TraceI(1, "Failed to create master clock\n");
            return hr;
        }
        
        hr = m_pSink->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to set master clock on sink\n");
            return hr;
        }
        else
        {
            TraceI(1, "(KsProperty) Sink succeeded set master clock\n");
        }

        pClock->Release();

        hr = m_pSynth->SetSynthSink(m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to set sink on synth\n");
            return hr;
        }

        // Recache the sink property set interface
        //
        IKsControl *pKsControl = NULL;
        hr = m_pSink->QueryInterface(IID_IKsControl, (void**)&pKsControl);
        if (FAILED(hr))
        {
            TraceI(0, "Warning: Sink does not support IKsControl\n");
            pKsControl = NULL;
        }

        SetSinkKsControl(pKsControl);

        CacheSinkUsesDSound();

        return S_OK;
    }

    // All other properties run through the default handlers
    //
    return CDirectMusicSynthPort::KsProperty(
        pProperty,
        ulPropertyLength,
        pvPropertyData,
        ulDataLength,
        pulBytesReturned);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::GetFormat
//
STDMETHODIMP CDirectMusicSynthPort7::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    HRESULT hr = m_pSynth->GetFormat(pwfex, pdwwfex);
    if (FAILED(hr))
    {
        return hr;
    }

    //only get the buffer size if pcbBuffer is valid
    if (pcbBuffer != NULL)
    {
        hr = m_pSink->GetDesiredBufferSize(pcbBuffer);
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort7::SetDirectSound
//
STDMETHODIMP CDirectMusicSynthPort7::SetDirectSound(
    LPDIRECTSOUND       pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_lActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer && !pDirectSound)
    {
        return E_INVALIDARG;
    }

    if (m_pDirectSound)
    {
        if (m_fUsingDirectMusicDSound)
        {
            ((CDirectMusic*)m_pDM)->ReleaseDirectSoundI();
            m_pDirectSound = NULL;
        }
        else
        {
            m_pDirectSound->Release();
        }
    }

    if (m_pDirectSoundBuffer)
    {
        m_pDirectSoundBuffer->Release();
    }

    m_pDirectSound = pDirectSound;
    m_pDirectSoundBuffer = pDirectSoundBuffer;

    if (m_pDirectSound)
    {
        m_pDirectSound->AddRef();
    }

    if (m_pDirectSoundBuffer)
    {
        m_pDirectSoundBuffer->AddRef();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CacheSinkUsesDSound
//
void CDirectMusicSynthPort7::CacheSinkUsesDSound()
{
    m_fSinkUsesDSound = false;

    if (m_pSinkPropSet) 
    {
        HRESULT hr;
        KSPROPERTY ksp;
        ULONG ulUsesDSound;
        ULONG cb;

    	ZeroMemory(&ksp, sizeof(ksp));
    	ksp.Set   = GUID_DMUS_PROP_SinkUsesDSound;
    	ksp.Id    = 0;
    	ksp.Flags = KSPROPERTY_TYPE_GET;

        hr = m_pSinkPropSet->KsProperty(&ksp,
    				       	            sizeof(ksp),
    						            (LPVOID)&ulUsesDSound,
    						            sizeof(ulUsesDSound),
    						            &cb);
        if (SUCCEEDED(hr) && ulUsesDSound)
        {
            TraceI(2, "This synth sink uses DirectSound\n");
            m_fSinkUsesDSound = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmsysclk.cpp ===
//
// dmsysclk.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//
//
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX
#include <objbase.h>
#include "dmusicp.h"
#include "debug.h"
#include "resource.h"

// RDTSC: Pentium instruction to read the cycle clock (increments once per clock cycle)
//
#define RDTSC _asm _emit 0x0f _asm _emit 0x31 

#define MS_CALIBRATE    (100)           // How long to calibate the Pentium clock against timeGetTime?
#define REFTIME_PER_MS  (10 * 1000)     // 10 100-ns units per millisecond

// Registry constant to dispable Pentium clock
//
static const char cszUsePentiumClock[] = "UsePentiumClock";

// Only determine which clock to use once
//
typedef enum
{
    SYSCLOCK_UNKNOWN,
    SYSCLOCK_WINMM,
    SYSCLOCK_PENTIMER
} SYSCLOCK_T;

static SYSCLOCK_T gSysClock = SYSCLOCK_UNKNOWN;
static DWORD gdwCycPer100ns;

static HRESULT CreateSysClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);
static void ProbeClock();

#ifndef XBOX
// Class implmentations, private to dmsysclk.cpp
//
class CReferenceClockWinmm : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    CReferenceClockWinmm();

private:
    long m_cRef;
};
#endif // !XBOX
#ifdef _X86_
class CReferenceClockPentium : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    CReferenceClockPentium(DWORD dwDivisor);

private:
    long m_cRef;
    DWORD m_dwDivisor;
    REFERENCE_TIME m_rtBaseTime;  // Keep track of the start time so we can start at that and never roll over.
};
#endif

// AddSysClocks
//
// Add system clock to the list of clocks.
//
HRESULT AddSysClocks(CMasterClock *pMasterClock)
{
    if (gSysClock == SYSCLOCK_UNKNOWN)
    {
        ProbeClock();
    }

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce);
    ce.cc.guidClock = GUID_SysClock;
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreateSysClock;

#ifdef XBOX
    wcscpy(ce.cc.wszDescription,L"System Clock");
#else
    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }
#endif //  XBOX

    return pMasterClock->AddClock(&ce);
}


// CreateSysClock
//
// Determine clock parameters if need be and create the appropriate type
// of system clock for this system.
//
HRESULT CreateSysClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    HRESULT hr;

    switch (gSysClock)
    {
#ifndef XBOX
        case SYSCLOCK_WINMM:
        {
            TraceI(2, "Creating SysClock [WinMM]\n");
            CReferenceClockWinmm *pWinmmClock = new CReferenceClockWinmm;

            if (!pWinmmClock)
            {
                return E_OUTOFMEMORY;
            }

            hr = pWinmmClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
            pWinmmClock->Release();
            break;
        }
#endif // !XBOX       
#ifdef _X86_
        case SYSCLOCK_PENTIMER:
        {
            TraceI(2, "Creating SysClock [PentTimer]\n");
            CReferenceClockPentium *pPentiumClock = new CReferenceClockPentium(gdwCycPer100ns);

            if (!pPentiumClock)
            {
                return E_OUTOFMEMORY;
            }

            hr = pPentiumClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
            pPentiumClock->Release();
            break;
        };
#endif

        case SYSCLOCK_UNKNOWN:
            TraceI(2, "CreateSysClock: Attempt to create w/o AddClock first??\n");
            return E_FAIL;
            break; 

        default:
            TraceI(0, "CreateSysClock: Unknown system clock type %d\n", (int)gSysClock);
            hr = E_FAIL;
            break;
    }

    return hr;
}

// ProbeClock
//
// Determine what type of clock to use. If we're on a Pentium (better be, it's required)
// then use the Pentium clock. This requires calibration.
//
// Otherwise fall back on timeGetTime. 
//
// Non-Intel compiles just default to setting the timeGetTime clock.
//
static void ProbeClock()
{
    int bIsPentium;


#ifdef XBOX
    // Don't bother checking for pentium on xbox
    //
    bIsPentium = 1;
#else  // XBOX
    // This code determines if we're running on a Pentium or better.
    //
    bIsPentium = 0;

#ifdef _X86_
    // First make sure this feature isn't disabled in the registry
    //

    HKEY hk;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue;
    BOOL fUsePentium;

    // Default to use Pentium clock if not specified
    //
    fUsePentium = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_DMUS_DEFAULTS,
                   &hk) == ERROR_SUCCESS)
    {
        cbValue = sizeof(dwValue);
        if (RegQueryValueEx(hk,
                            cszUsePentiumClock,
                            NULL,               // Reserved
                            &dwType,
                            (LPBYTE)&dwValue,
                            &cbValue) == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            cbValue == sizeof(DWORD))
        {
            fUsePentium = dwValue ? TRUE : FALSE;
        }

        RegCloseKey(hk);
    }

    // Only test for Pentium if allowed by the registry.
    //
    if (fUsePentium)
    {
        _asm 
        {
            pushfd                      // Store original EFLAGS on stack
            pop     eax                 // Get original EFLAGS in EAX
            mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
            xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
            push    eax                 // Save new EFLAGS value on stack
            popfd                       // Replace current EFLAGS value
            pushfd                      // Store new EFLAGS on stack
            pop     eax                 // Get new EFLAGS in EAX
            xor     eax, ecx            // Can we toggle ID bit?
            jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
            inc     dword ptr [bIsPentium]
Done:
        }
    }

#endif

#endif // ! XBOX

    TraceI(2, "ProbeClock: bIsPentium %d\n", bIsPentium);

    if (!bIsPentium)
    {
        TraceI(2, "Using timeGetTime() as the system clock\n");
        gSysClock = SYSCLOCK_WINMM;
        return;        
    }

#ifdef _X86_
    TraceI(2, "Using the Pentium chip clock as the system clock\n");
    gSysClock = SYSCLOCK_PENTIMER;

#ifdef XBOX
    gdwCycPer100ns = 733;
#else
    // If we have a Pentium, then we need to calibrate
    //
    _int64 cycStart;
    _int64 cycEnd;
    DWORD  msStart;
    DWORD  msEnd;

    // On NT, need this to make timeGetTime read with a reasonable accuracy
    //
    timeBeginPeriod(1);

    // Start as close to the start of a millisecond boundary as
    // possible.
    //
    msStart = timeGetTime() + 1;
    while (timeGetTime() < msStart)
        ;

    // Read the Pentium clock at that time
    //
    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycStart], eax
        mov     dword ptr [cycStart+4], edx
    }

    // Wait for the number of milliseconds until end of calibration
    // Again, we're trying to get the time right when the timer switches
    // to msEnd.
    //
    msEnd = msStart + MS_CALIBRATE;
    
    while (timeGetTime() < msEnd)
        ;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycEnd], eax
        mov     dword ptr [cycEnd+4], edx
    }

    // Done with the time critical part
    //
    timeEndPeriod(1);

    // We now know how many clock cycles per MS_CALIBRATE milliseconds. Use that
    // to figure out how many clock cycles per 100ns for IReferenceClock.
    //
    _int64 cycDelta = cycEnd - cycStart;
    
    gdwCycPer100ns = (DWORD)(cycDelta / (REFTIME_PER_MS * MS_CALIBRATE));
    TraceI(2, "ClockProbe: Processor clocked at %u Mhz\n", ((cycDelta / MS_CALIBRATE) + 500) / 1000);
#endif // !XBOX
#endif // _X86_
}

#ifndef XBOX
//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock wrapper for timeGetTime()
//
CReferenceClockWinmm::CReferenceClockWinmm() : m_cRef(1)
{
}

STDMETHODIMP
CReferenceClockWinmm::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CReferenceClockWinmm::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CReferenceClockWinmm::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CReferenceClockWinmm::GetTime(
    REFERENCE_TIME *pTime)
{
    *pTime = ((ULONGLONG)timeGetTime()) * (10L * 1000L);
    return S_OK;
}

STDMETHODIMP
CReferenceClockWinmm::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockWinmm::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockWinmm::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
#endif // !XBOX
#ifdef _X86_
//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock wrapper for Pentium clock
//
CReferenceClockPentium::CReferenceClockPentium(DWORD dwDivisor) : m_cRef(1)
{
    m_dwDivisor = dwDivisor;
    m_rtBaseTime = 0;
}

STDMETHODIMP
CReferenceClockPentium::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CReferenceClockPentium::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CReferenceClockPentium::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}
STDMETHODIMP
CReferenceClockPentium::GetTime(
    REFERENCE_TIME *pTime)
{
    _int64 cycNow;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycNow], eax
        mov     dword ptr [cycNow+4], edx
    }

#ifdef XBOX
    cycNow *= 10;          // Gives greater clock granularity.
    cycNow /= 733; // m_dwDivisor;
#else
    cycNow /= m_dwDivisor;
#endif
    if (m_rtBaseTime == 0) // If we haven't started, initialize the base time.
    {
        m_rtBaseTime = cycNow;
    }
    cycNow -= m_rtBaseTime;
    *pTime = cycNow;
    return S_OK;
}

STDMETHODIMP
CReferenceClockPentium::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockPentium::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockPentium::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmsport8.h ===
//
// dmsport8.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort8 implementation; code specific to DX-8 style ports
// 

#ifndef _DMSPORT8_H_
#define _DMSPORT8_H_

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8
//
class CDirectMusicSynthPort8 : public CDirectMusicSynthPort
{
public:
    CDirectMusicSynthPort8(
        PORTENTRY           *pe,
        CDirectMusic        *pDM,
        IDirectMusicSynth8  *pSynth);

    ~CDirectMusicSynthPort8();

    HRESULT Initialize(
        DMUS_PORTPARAMS *pPortParams);   

    // Overridden public methods
    //
    STDMETHODIMP Close();

    STDMETHODIMP Activate(
        BOOL fActivate);
        
    STDMETHODIMP SetDirectSound(
        LPDIRECTSOUND       pDirectSound,
        LPDIRECTSOUNDBUFFER pDirectSoundBuffer);

    STDMETHODIMP DownloadWave(
        IDirectSoundWave *pWave,               
        IDirectSoundDownloadedWaveP **ppWave,
        REFERENCE_TIME rtStartHint);

    STDMETHODIMP UnloadWave(
        IDirectSoundDownloadedWaveP *pDownloadedWave);

    STDMETHODIMP AllocVoice(
        IDirectSoundDownloadedWaveP  *pWave,     
        DWORD                       dwChannel,                       
        DWORD                       dwChannelGroup,                  
        REFERENCE_TIME              rtStart,                     
        SAMPLE_TIME                 stLoopStart,
        SAMPLE_TIME                 stLoopEnd,
        IDirectMusicVoiceP           **ppVoice);

#ifndef XBOX
    STDMETHODIMP AssignChannelToBuses(
        DWORD       dwChannelGroup,
        DWORD       dwChannel,
        LPDWORD     pdwBuses,
        DWORD       cBusCount);

#else
	STDMETHODIMP AssignChannelToOutput(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
        IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
        DWORD dwMixBins,                        // Or, mixbins, if assigned to them.
        BYTE *pbControllers);

#endif

    STDMETHODIMP StartVoice(          
        DWORD               dwVoiceId,
        DWORD               dwChannel,
        DWORD               dwChannelGroup,
        REFERENCE_TIME      rtStart,
        DWORD               dwDLId,
        LONG                prPitch,
        LONG                vrVolume,
        SAMPLE_TIME         stStartVoice,
        SAMPLE_TIME         stLoopStart,
        SAMPLE_TIME         stLoopEnd);

    STDMETHODIMP StopVoice(          
        DWORD               dwVoiceId,
        REFERENCE_TIME      rtStop);

    STDMETHODIMP GetVoiceState(
        DWORD               dwVoice[], 
        DWORD               cbVoice,
        DMUS_VOICE_STATE    VoiceState[]);

    STDMETHODIMP Refresh(
        DWORD   dwDownloadId,
        DWORD   dwFlags);
#ifdef XBOX
    STDMETHODIMP IsReadyForData(
        DWORD dwDownloadID);
#endif

    STDMETHODIMP SetSink(
        LPDIRECTSOUNDCONNECT pSinkConnect);
        
    STDMETHODIMP GetSink(
        LPDIRECTSOUNDCONNECT* ppSinkConnect);

    STDMETHODIMP GetFormat(
        LPWAVEFORMATEX  pwfex,
        LPDWORD         pdwwfex,
        LPDWORD         pcbBuffer);
	
private:
    IDirectMusicSynth8     *m_pSynth;               // 8.0 Synth 
    bool                    m_fUsingDirectMusicDSound;
                                                    // Using default dsound
    LPDIRECTSOUND8          m_pDirectSound;         // Directsound object
    LPDIRECTSOUNDCONNECT    m_pSinkConnect;         // DirectSound sink
    LPDIRECTSOUNDBUFFER     m_pdsb[4];              // Sink buffers
    LPDIRECTSOUNDSOURCE     m_pSource;              // Synth's source
    
    static WAVEFORMATEX     s_wfexDefault;          // Default format
    
    bool                    m_fVSTStarted;          // Has voice service thread
                                                    //  been started?
    DWORD                   m_dwChannelGroups;      // How many channel groups
    
    LONG                    m_lActivated;           // Is port active?
    bool                    m_fHasActivated;        // Has ever activated?
    DWORD                   m_dwSampleRate;         // Sample rate for synth
    
private:
    HRESULT AllocDefaultSink();
    HRESULT CreateAndConnectDefaultSink();
};



#endif // _DMSPORT8_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmsport8.cpp ===
//
// dmsport8.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort8 implementation; code specific to DX-8 style ports
// 
#ifndef XBOX
#include <objbase.h>
#else
#define DSBCAPS_GLOBALFOCUS 0
#endif // !XBOX
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"
#include "dmsport8.h"
#include "dsoundp.h"    // For IDirectSoundConnect

static const DWORD g_dwDefaultSampleRate = 22050;

WAVEFORMATEX CDirectMusicSynthPort8::s_wfexDefault = 
{
    WAVE_FORMAT_PCM,            // wFormatTag
    1,                          // nChannels
    g_dwDefaultSampleRate,      // nSamplesPerSec
    g_dwDefaultSampleRate * 2,  // nAvgBytesPerSec
    2,                          // nBlockAlign
    8 * 2,                      // wBitsPerSample
    0                           // cbSize
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CDirectMusicSynthPort8
//
//
CDirectMusicSynthPort8::CDirectMusicSynthPort8(
    PORTENTRY           *pe,
    CDirectMusic        *pDM,
    IDirectMusicSynth8  *pSynth) :

        CDirectMusicSynthPort(pe, pDM, static_cast<IDirectMusicSynth*>(pSynth))
{
    m_pSynth = pSynth;
    m_pSynth->AddRef();

    m_fUsingDirectMusicDSound   = false;
    m_pDirectSound              = NULL;
    m_pSinkConnect              = NULL;
    m_fVSTStarted               = false;
    m_pSource                   = NULL;
    m_lActivated                = 0;
    m_fHasActivated             = false;
    m_dwSampleRate              = g_dwDefaultSampleRate;

    memset(m_pdsb, 0, sizeof(m_pdsb));

}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CDirectMusicSynthPort8
//
//
CDirectMusicSynthPort8::~CDirectMusicSynthPort8()
{
    Close();
}
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Initialize
//
//
HRESULT CDirectMusicSynthPort8::Initialize(
    DMUS_PORTPARAMS     *pPortParams)
{
    HRESULT hr      = CDirectMusicSynthPort::Initialize(pPortParams);
    HRESULT hrOpen  = S_OK;

    if (m_pSynth == NULL) 
    {
        // XXX error code
        //
        return E_FAIL;
    }

    // We need DirectSound before connection now
    //
    LPDIRECTSOUND pDirectSound;

    hr = ((CDirectMusic*)m_pDM)->GetDirectSoundI(&pDirectSound);

#ifndef XBOX
    // Make sure we have DirectSound 8.
    //
    if (SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound8, (void**)&m_pDirectSound);
        RELEASE(pDirectSound);
    }

#else // XBOX

	m_pDirectSound = pDirectSound;
	hr = S_OK;

#endif // XBOX

    if (SUCCEEDED(hr))
    {
        // Override default sample rate
        //
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
        {
            m_dwSampleRate = pPortParams->dwSampleRate;
        }
    }

    // Create and hand out the master clock
    //
	IReferenceClock* pClock = NULL;

    if (SUCCEEDED(hr))
    {
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->SetMasterClock(pClock);
        RELEASE(pClock);
    }

    // Start the voice service thread
    //
    if (SUCCEEDED(hr))
    {
        hr = CDirectMusicVoice::StartVoiceServiceThread((IDirectMusicPort*)this);
    }

    if (SUCCEEDED(hr))
    {
        m_fVSTStarted = true;
    }

    // Open the synth. We have to be careful to save the return code because
    // if S_FALSE is returned here it must be returned to the caller.
    //
    if (SUCCEEDED(hr))
    {
    	hrOpen = m_pSynth->Open(pPortParams);
        if (FAILED(hrOpen))
        {
            hr = hrOpen;
            TraceI(1, "Failed to open synth %08lX\n", hr);
        }
    }

    // Set up channel priorities and volume boost
    // 
    if (SUCCEEDED(hr))
    {    
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else
        {
            m_dwChannelGroups = 1;
        }

        InitChannelPriorities(1, m_dwChannelGroups);
        InitializeVolumeBoost();
    }

    // Save source so we can connect to it later
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->QueryInterface(IID_IDirectSoundSource, (void**)&m_pSource);
    }

    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Close
//
STDMETHODIMP CDirectMusicSynthPort8::Close()
{
    // Stop voice service thread
    //
    if (m_fVSTStarted)
    {
        CDirectMusicVoice::StopVoiceServiceThread((IDirectMusicPort*)this);
        m_fVSTStarted = FALSE;
    }
    
    // Turn off and close
    //
    if (m_pSynth) 
    {
        m_pSynth->Activate(false);
        m_pSynth->Close();
        RELEASE(m_pSynth);
    }

    // Force synth and sink to disassociate
    //
    if (m_pSinkConnect)
    {
        m_pSinkConnect->RemoveSource(m_pSource);
    }

    if (m_pSource) 
    {
        m_pSource->SetSink(NULL);            
    }

    // Release everything
    //
    RELEASE(m_pdsb[0]);
    RELEASE(m_pdsb[1]);
    RELEASE(m_pdsb[2]);
    RELEASE(m_pdsb[3]);

    RELEASE(m_pSinkConnect);
    RELEASE(m_pSource);
    RELEASE(m_pDirectSound);

    return CDirectMusicSynthPort::Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Activate
//
// XXX Write me
//
STDMETHODIMP CDirectMusicSynthPort8::Activate(
    BOOL fActivate)
{
    HRESULT hr = S_OK;

	V_INAME(IDirectMusicPort::Activate);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }
	
    if (fActivate && !m_pSinkConnect)
    {
        hr = CreateAndConnectDefaultSink();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->Activate(fActivate);
    }

    if (SUCCEEDED(hr))
    {
        m_fHasActivated = true;
    }
    else
    {
        // Flip back activate state -- operation failed
        //
        m_lActivated = fActivate ? 0 : 1;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::SetDirectSound
//
STDMETHODIMP CDirectMusicSynthPort8::SetDirectSound(
    LPDIRECTSOUND       pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE(pDirectSound);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_lActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    IDirectSound8 *pDirectSound8;

    // Make sure we have an IDirectSound8, and as a side effect AddRef
    //
#ifndef XBOX
    hr = pDirectSound->QueryInterface(IID_IDirectSound8, (void**)&pDirectSound8);
    if (SUCCEEDED(hr))
#else // XBOX
	pDirectSound8 = pDirectSound;
	pDirectSound->AddRef();
	hr = S_OK;
#endif // XBOX
    
    {
        RELEASE(m_pDirectSound);
        m_pDirectSound = pDirectSound8;
    }
        
    return hr;        
}
       
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::DownloadWave
//
STDMETHODIMP CDirectMusicSynthPort8::DownloadWave(
    IDirectSoundWave            *pWave,               
    IDirectSoundDownloadedWaveP  **ppWave,
    REFERENCE_TIME              rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    TraceI(1, "DownloadWave %08X\n", pWave);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
	return CDirectMusicPortDownload::DownloadWaveP(pWave,
                                                   ppWave,
                                                   rtStartHint);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::UnloadWave
//
STDMETHODIMP CDirectMusicSynthPort8::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return CDirectMusicPortDownload::UnloadWaveP(pDownloadedWave);
}

            
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AllocVoice
//
STDMETHODIMP CDirectMusicSynthPort8::AllocVoice(
    IDirectSoundDownloadedWaveP  *pWave,     
    DWORD                       dwChannel,                       
    DWORD                       dwChannelGroup,                  
    REFERENCE_TIME              rtStart,                     
    SAMPLE_TIME                 stLoopStart,
    SAMPLE_TIME                 stLoopEnd,         
    IDirectMusicVoiceP           **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return CDirectMusicPortDownload::AllocVoice(
        pWave,
        dwChannel,
        dwChannelGroup,
        rtStart,
        stLoopStart,
        stLoopEnd,
        ppVoice);
}        
#ifndef XBOX
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AssignChannelToBuses
//
STDMETHODIMP CDirectMusicSynthPort8::AssignChannelToBuses(
    DWORD       dwChannelGroup,
    DWORD       dwChannel,
    LPDWORD     pdwBuses,
    DWORD       cBusCount)
{
    V_INAME(IDirectMusicPort::AssignChannelToBuses);
    V_BUFPTR_WRITE(pdwBuses, sizeof(DWORD) * cBusCount);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->AssignChannelToBuses(
        dwChannelGroup,
        dwChannel,
        pdwBuses,
        cBusCount);
}        

#else

STDMETHODIMP CDirectMusicSynthPort8::AssignChannelToOutput(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
        IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
        DWORD dwMixBins,
        BYTE *pbControllers)            
{
    V_INAME(IDirectMusicPort::AssignChannelToOutput);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->AssignChannelToOutput(
        dwChannelGroup,
        dwChannel,
        pBuffer,
        dwMixBins,
        pbControllers);
}        


#endif
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::StartVoice
//
STDMETHODIMP CDirectMusicSynthPort8::StartVoice(          
    DWORD               dwVoiceId,
    DWORD               dwChannel,
    DWORD               dwChannelGroup,
    REFERENCE_TIME      rtStart,
    DWORD               dwDLId,
    LONG                prPitch,
    LONG                vrVolume,
    SAMPLE_TIME         stVoiceStart, 
    SAMPLE_TIME         stLoopStart,
    SAMPLE_TIME         stLoopEnd)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // XXX make cg/c order consistent
    // XXX make API names consistent
    //
    return m_pSynth->PlayVoice(rtStart,
                               dwVoiceId,
                               dwChannelGroup,
                               dwChannel,
                               dwDLId,
                               prPitch, 
                               vrVolume,
                               stVoiceStart,
                               stLoopStart,
                               stLoopEnd);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::StopVoice
//
STDMETHODIMP CDirectMusicSynthPort8::StopVoice(          
    DWORD               dwVoiceId,
    REFERENCE_TIME      rtStop)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->StopVoice(rtStop,
                               dwVoiceId);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetVoiceState
//
STDMETHODIMP CDirectMusicSynthPort8::GetVoiceState(
    DWORD               dwVoice[], 
    DWORD               cbVoice,
    DMUS_VOICE_STATE    VoiceState[])
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetVoiceState(dwVoice, cbVoice, VoiceState);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Refresh
//
STDMETHODIMP CDirectMusicSynthPort8::Refresh(
    DWORD   dwDownloadId,
    DWORD   dwFlags)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->Refresh(dwDownloadId, dwFlags);
}

#ifdef XBOX

STDMETHODIMP CDirectMusicSynthPort8::IsReadyForData(
    DWORD   dwDownloadId)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->IsReadyForData(dwDownloadId);
}

#endif

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::SetSink
//
STDMETHODIMP CDirectMusicSynthPort8::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_INTERFACE(pSinkConnect);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fHasActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    // Do this in the order which permits the easiest backing out.
    HRESULT hr = pSinkConnect->AddSource(m_pSource);

    if (SUCCEEDED(hr))
    {
        hr = m_pSource->SetSink(pSinkConnect);
        if (FAILED(hr))
        {
            pSinkConnect->RemoveSource(m_pSource);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (m_pSinkConnect)
        {
            m_pSinkConnect->RemoveSource(m_pSource);

            // This does nothing if the sink is already not ours.

            RELEASE(m_pdsb[0]);
            RELEASE(m_pdsb[1]);
            RELEASE(m_pdsb[2]);
            RELEASE(m_pdsb[3]);
        
            RELEASE(m_pSinkConnect);
        }

        pSinkConnect->AddRef();
        m_pSinkConnect = pSinkConnect;
    }


    // We've got the connection to the sink, let's set KSControl on the Sink
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;
        hr = m_pSinkConnect->QueryInterface(IID_IKsControl, (void**)&pKsControl);
        if (FAILED(hr))
        {
            TraceI(0, "Warning: Sink does not support IKsControl\n");
            pKsControl = NULL;
        }

        SetSinkKsControl(pKsControl);

        //The SetSinkKsControl does an AddRef() so we can release!
        RELEASE(pKsControl);
    }

    
    return hr;    
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetSink
//
STDMETHODIMP CDirectMusicSynthPort8::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    V_INAME(IDirectMusicPort::GetSink);
    V_PTRPTR_WRITE(ppSinkConnect);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *ppSinkConnect = m_pSinkConnect;
    m_pSinkConnect->AddRef();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetFormat
//
STDMETHODIMP CDirectMusicSynthPort8::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    HRESULT hr = m_pSynth->GetFormat(pwfex, pdwwfex);
    if (FAILED(hr))
    {
        return hr;
    }

    //>>>>>>>>>>>> NEED A MEMTHOD IN SYNTH 
    if ((pcbBuffer != NULL) && (pwfex != NULL))
    {
        *pcbBuffer = 2/*DSBUFFER_LENGTH_SEC*/ * pwfex->nAvgBytesPerSec;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CreateAndConnectDefaultSink
//
// INTERNAL
//
//
HRESULT CDirectMusicSynthPort8::CreateAndConnectDefaultSink()
{
    HRESULT             hr;

    hr = AllocDefaultSink();

    // Give the sink's IKsControl to the base class. This needs to be
    // done here since the sink is a different type between 7 and 8.
    //
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;

        HRESULT hrTemp = m_pSinkConnect->QueryInterface(
            IID_IKsControl, 
            (void**)&pKsControl);
        if (FAILED(hrTemp))
        {
            TraceI(2, "NOTE: Sink has no property set interface.\n");
        }

        SetSinkKsControl(pKsControl);
        RELEASE(pKsControl);
    }

    // Connect the two together
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSource->SetSink(m_pSinkConnect);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSinkConnect->AddSource(m_pSource);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AllocDefaultSink
//
// INTERNAL
//
// Try to allocate a default sink and buses, releasing any current sink.
//
// Caller guarantees the port has never been activated. 
//
HRESULT CDirectMusicSynthPort8::AllocDefaultSink()
{
#ifdef XBOX
    return E_FAIL;
#else
	IReferenceClock     *pClock = NULL;
    IDirectSoundConnect *pSinkConnect = NULL;
    IDirectSoundBuffer  *pdsb[4];
	WAVEFORMATEX        wfex;

    assert(!m_fHasActivated);

    memset(pdsb, 0, sizeof(pdsb));

    // Create a sink
    //

	// initialize with default
	wfex = s_wfexDefault; 

	//XXX 
	//>>>> NOTE:PETCHEY
	// We should also able to create a mono sink 
	// pPortParams->dwAudioChannels
    wfex.nSamplesPerSec  = m_dwSampleRate;
    wfex.nAvgBytesPerSec = wfex.nSamplesPerSec * wfex.nChannels * (wfex.wBitsPerSample/8);              // 

    IDirectSoundPrivate* pDSPrivate;
    HRESULT hr = m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);

    if (SUCCEEDED(hr))
    {
        hr = pDSPrivate->AllocSink(&wfex, &pSinkConnect);
        pDSPrivate->Release();
    }


	HRESULT hr = E_FAIL; // TODO: Fix this.


    // Standard bus connections
    //  
    DSBUFFERDESC dsbd;
	DWORD dwbus;

    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

		dwbus = DSBUSID_LEFT;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[0]);
    }

    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

		dwbus = DSBUSID_RIGHT;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[1]);
    }
    
    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

      //XXX Set up effect

		dwbus = DSBUSID_REVERB_SEND;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[2]);
    }
    
    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;
      //XXX Set up effect

		dwbus = DSBUSID_CHORUS_SEND;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[3]);
    }

    // Master clock
    //
    if (SUCCEEDED(hr))
    {
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
    }

    if (SUCCEEDED(hr))
    {
        hr = pSinkConnect->SetMasterClock(pClock);
        RELEASE(pClock);
    }

    // If we got this far then we are going to replace any existing sink
    // with the new one
    //
    if (SUCCEEDED(hr))
    {
		if (m_pSinkConnect && m_pSource)
		{
	        m_pSinkConnect->RemoveSource(m_pSource);
		}
        
        RELEASE(m_pdsb[0]);
        RELEASE(m_pdsb[1]);
        RELEASE(m_pdsb[2]);
        RELEASE(m_pdsb[3]);
    
        RELEASE(m_pSinkConnect);

        assert(sizeof(m_pdsb) == sizeof(pdsb));
        memcpy(m_pdsb, pdsb, sizeof(m_pdsb));

        m_pSinkConnect = pSinkConnect;
    }

    if (FAILED(hr))
    {
        RELEASE(pdsb[0]);
        RELEASE(pdsb[1]);
        RELEASE(pdsb[2]);
        RELEASE(pdsb[3]);
    
        RELEASE(pSinkConnect);
    }

    return hr;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmusicp.h ===
//
// DMusicP.H
//
// Private include for Dmusic.DLL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//

#ifndef _DMUSICP_
#define _DMUSICP_

#include "tlist.h"
#include "alist.h"
#include "debug.h"
#include <devioctl.h>

#include "mmsystem.h"
#include "dsoundp.h"         // DSound must be before KS*.h

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "dmksctrl.h"

#include "dmusicc.h"
#include "dmusicip.h"
#include "dmusics.h"
#include "..\shared\dmusiccp.h"
#include "..\shared\dowork.h"

#include "dmdload.h"
#include "dmportdl.h"

#include <stddef.h>
#include "dmusprop.h"
#include "tpool.h"

#define RELEASE(x) { if (x) (x)->Release(); (x) = NULL; }

#define HRFromP(x) ((x) ? S_OK : E_OUTOFMEMORY)

extern char g_szFriendlyName[];             // Module friendly name
extern char g_szVerIndProgID[];             // and program ID w/ version
extern char g_szProgID[];                   // Just program ID
extern HMODULE g_hModule;                   // DLL module handle (dmusic.dll)
extern HMODULE g_hModuleDM32;               // dmusic32.dll module handle if loaded
extern HMODULE g_hModuleKsUser;             // ksuser.dll module handle if loaded
extern long g_cComponent;                   // Component count for server locking
extern long g_cLock;                        // Lock count for server locking
extern DWORD g_fFlags;                      // DMI_F_XXX flags

#define DMI_F_WIN9X     0x00000001          // Running on Win9x

#define DWORD_ROUNDUP(x) (((x) + 3) & ~3)
#define QWORD_ROUNDUP(x) (((x) + 7) & ~7)

// Array elements in X
//
#define ELES(x)          (sizeof(x) / sizeof((x)[0]))

#define SafeAToW(w,a) \
                      { mbstowcs(w, a, ELES(w) - 1); (w)[ ELES(w) - 1] = L'\0'; }

#define SafeWToA(a,w) \
                      { wcstombs(a, w, ELES(a) - 1); (a)[ ELES(a) - 1] = '\0'; }

// Driver message for NT. Determines the number of ports on a driver
//
#ifndef DRV_QUERYDRVENTRY
#define DRV_QUERYDRVENTRY (0x0801)
#endif

// For selector tiling, the tile info is 16 bits of sel[0] and 16 bits of count
#define TILE_SEL0(x)  (((DWORD)((x) & 0xffff0000)) >> 16)
#define TILE_P1616(x) ((DWORD)((x) & 0xffff0000))
#define TILE_COUNT(x) ((x) & 0x0000ffff)

// Where are things in our registry?
#define REGSTR_PATH_DIRECTMUSIC  	"Software\\Microsoft\\DirectMusic"
#define REGSTR_PATH_DMUS_DEFAULTS	REGSTR_PATH_DIRECTMUSIC "\\Defaults"


// @struct PORTENTRY | Entry in the linked list of ports
typedef enum
{
    ptWDMDevice,
    ptLegacyDevice,
    ptSoftwareSynth
} PORTTYPE;

typedef struct tagPORTDEST
{
    ULONG   idxDevice;
    ULONG   idxPin;
    ULONG   idxNode;
    LPSTR   pstrInstanceId;
    BOOL    fOnPrefDev;
} PORTDEST;

typedef struct tagPORTENTRY PORTENTRY;
struct tagPORTENTRY
{
    PORTTYPE type;       // @field What type of port is this?
    

    BOOL fIsValid;       // @field TRUE if this entry is still an active driver after
                         // rebuilding the port list.
    
    ULONG idxDevice;     // @field If the port is a legacy driver, contains the device ID.
    ULONG idxPin;        
    ULONG idxNode;
    
    BOOL fPrefDev;       // @field TRUE if this is a preferred device
    
                         // Filter and pin to open through SysAudio
    int nSysAudioDevInstance;
    int nFilterPin;

    DMUS_PORTCAPS pc;    // @field Contains the port capabilities which will be returned to the application
                         // upon enumeration of the device.
                         
    BOOL fAudioDest;     // @field True if this port can be connected to multiple audio
                         // destinations (WDM transform filter; i.e. kernel SW synth)

    CList<PORTDEST *> lstDestinations;

    WCHAR wszDIName[256]; //@field contains the DeviceName for WDM devices
};

class CMasterClock;
typedef struct tagCLOCKENTRY CLOCKENTRY;
typedef struct tagCLOCKENTRY *PCLOCKENTRY;

struct tagCLOCKENTRY
{
    BOOL fIsValid;
    DMUS_CLOCKINFO cc;
    HRESULT (*pfnGetInstance)(IReferenceClock **ppClock, CMasterClock *pMasterClock);
};

// This structure is held in shared memory. All instances of DirectMusic use it to ensure that
// the same master clock is in place.
//
#define CLOCKSHARE_F_LOCKED         0x00000001      // If clock is locked; i.e. cannot change

typedef struct tagCLOCKSHARE CLOCKSHARE;
struct tagCLOCKSHARE
{
    GUID        guidClock;          // Current master clock
    DWORD       dwFlags;            // CLOCKSHARE_F_xxx
};

// Private interface to get parameters associated with specific master clocks
//
#undef  INTERFACE
#define INTERFACE  IMasterClockPrivate
DECLARE_INTERFACE_(IMasterClockPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectMusicKsClockPrivate
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, LPVOID pBuffer, DWORD cbSize) PURE;
};

// This class wraps the master clock and handles all the problems associated with only
// one instance per system.
//
class CMasterClock : public IReferenceClock, public IDirectSoundSinkSync, IMasterClockPrivate
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
	        			    REFERENCE_TIME streamTime,
			        	    HANDLE hEvent,            
				            DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					            REFERENCE_TIME periodTime,
					            HANDLE hSemaphore,   
					            DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);
    STDMETHODIMP GetParam(REFGUID rguidType, 
                          LPVOID pBuffer, 
                          DWORD cbSize);
                          
    // IDirectSoundSyncSink
    //
    STDMETHODIMP SetClockOffset(LONGLONG llOffset);                         
    
    
    // Used by DirectMusic for communication with the
    // implementation
    //
    CMasterClock();
    ~CMasterClock();
    HRESULT Init();
    HRESULT GetMasterClockInterface(IReferenceClock **ppClock);
    
    HRESULT EnumMasterClock(DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo, DWORD dwVer);
    HRESULT GetMasterClock(LPGUID pguidClock, IReferenceClock **ppClock);
    HRESULT SetMasterClock(REFGUID rguidClock);
    HRESULT SetMasterClock(IReferenceClock *pClock);
   
    LONG AddRefPrivate();
    LONG ReleasePrivate();
    
    HRESULT AddClock(PCLOCKENTRY pClock);
    
    // For clocks (Dsound clock) which need a clean clock to sync on
    //
    HRESULT CreateDefaultMasterClock(IReferenceClock **ppReferenceClock);


private:
    void Close();
    HRESULT UpdateClockList();
    void SyncToExternalClock();
    HRESULT CreateMasterClock();
    

private:
    LONG m_cRef;            // Ref count of wrapped clock
    LONG m_cRefPrivate;     // Ref count of CMasterClock object
    
    CList<CLOCKENTRY *>   m_lstClocks;
        
    GUID                  m_guidMasterClock;
    IReferenceClock      *m_pMasterClock;
    IDirectSoundSinkSync *m_pSinkSync;
    HANDLE                m_hClockMemory;
    HANDLE                m_hClockMutex;
    CLOCKSHARE           *m_pClockMemory;
    
    IReferenceClock      *m_pExtMasterClock;
    LONGLONG              m_llExtOffset;
};


// Helper functions for clocks
//
HRESULT AddSysClocks(CMasterClock *);
HRESULT AddDsClocks(CMasterClock *);
HRESULT AddPcClocks(CMasterClock *);
#ifdef DEAD_CODE
HRESULT AddKsClocks(CMasterClock *);
#endif

//HRESULT CreateSysClock(IReferenceClock **ppClock);

// IDirectMusicPortNotify
//
// A port uses this (private) interface from IDirectMusic to notify IDirectMusic when it goes away.
// 
#undef  INTERFACE
#define INTERFACE  IDirectMusicPortNotify
DECLARE_INTERFACE_(IDirectMusicPortNotify, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicPortNotify
    STDMETHOD(NotifyFinalRelease)   (THIS_ IDirectMusicPort *pPort) PURE;
};

#define MIDI_CHANNELS               16

// DMEVENT as buffered by IDirectMusicBuffer
//
#include <pshpack4.h>
struct DMEVENT : public DMUS_EVENTHEADER
{
    BYTE        abEvent[sizeof(DWORD)];
};
#include <poppack.h>

// Encapsulated for queueing
//
struct QUEUED_EVENT
{
    QUEUED_EVENT    *pNext;
    DMEVENT         e;
};

#define QUEUED_EVENT_SIZE(cbEvent)  (DMUS_EVENT_SIZE(cbEvent) + sizeof(QUEUED_EVENT) - sizeof(DMEVENT))

// Free pool of 4-byte events
//
typedef CPool<QUEUED_EVENT> EVENT_POOL;

class EVENT_QUEUE
{
public:
    EVENT_QUEUE() { pFront = pRear = NULL; }
    
    QUEUED_EVENT    *pFront;
    QUEUED_EVENT    *pRear;
};

// How long to wait for the capture thread to die
//
#define THREAD_KILL_TIMEOUT         5000

// How big is the capture thread's work buffer?
//
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

typedef struct _DMUS_THRU_CHANNEL *LPDMUS_THRU_CHANNEL;
typedef struct _DMUS_THRU_CHANNEL
{
    DWORD               dwDestinationChannel;
    DWORD               dwDestinationChannelGroup;
    IDirectMusicPort    *pDestinationPort;
    BOOL                fThruInWin16;
} DMUS_THRU_CHANNEL;



// IDirectMusicPortPrivate
//
// A port implements this interface to expose methods to DirectMusic which are not exposed to the
// outside world
//
#undef  INTERFACE
#define INTERFACE  IDirectMusicPortPrivate
DECLARE_INTERFACE_(IDirectMusicPortPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicPortPrivate
    STDMETHOD(Close)                (THIS_) PURE;
    
    // Voice management
    //
    STDMETHOD(StartVoice)          
        (THIS_
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG veVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd
        ) PURE;

    STDMETHOD(StopVoice)          
        (THIS_
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop
        ) PURE;
        
    STDMETHOD(GetVoiceState)     
        (THIS_ DWORD dwVoice[], 
         DWORD cbVoice,
         DMUS_VOICE_STATE dwVoiceState[] 
        ) PURE;
        
    STDMETHOD(Refresh)
        (THIS_ DWORD dwDownloadID,
         DWORD dwFlags
        ) PURE;
#ifdef XBOX
    STDMETHOD(IsReadyForData)
        (THIS_ DWORD dwDownloadID
        ) PURE;
#endif
};

// @class Implementation of IDirectMusic
//
class CDirectMusic : public IDirectMusic8, public IDirectMusicPortNotify {
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusic
    //
    STDMETHODIMP EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);
    STDMETHODIMP CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc, LPDIRECTMUSICBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
    STDMETHODIMP CreatePort(REFGUID ruidPort, LPDMUS_PORTPARAMS pPortParams, LPDIRECTMUSICPORT *ppPort, LPUNKNOWN pUnkOuter);
    STDMETHODIMP EnumMasterClock(DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo);
    // NOTE: This is a GUID* rather than REFGUID so they can pass NULL if they don't care
    //
    STDMETHODIMP GetMasterClock(GUID *guidClock, IReferenceClock **ppReferenceClock);
    STDMETHODIMP SetMasterClock(REFGUID guidClock);
    STDMETHODIMP Activate(BOOL fEnable);
	STDMETHODIMP GetDefaultPort(GUID *guidPort);
	STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, HWND hwnd);
    STDMETHODIMP SetExternalMasterClock(IReferenceClock *pClock);
    

    // IDirectMusicPortNotify
    //
    STDMETHODIMP NotifyFinalRelease(IDirectMusicPort *pPort);
    

    // Class
    //
    CDirectMusic();
    ~CDirectMusic();
    HRESULT Init();
    HRESULT UpdatePortList();
    HRESULT AddWDMDevices();
    HRESULT AddLegacyDevices();
    HRESULT AddSoftwareSynths();
    HRESULT AddDevice(DMUS_PORTCAPS &dmpc, 
                      PORTTYPE pt, 
                      int idxDev, 
                      int idxPin, 
                      int idxNode, 
                      BOOL fIsPreferred, 
                      HKEY hkPortsRoot, 
                      LPWSTR wszDIName, 
                      LPSTR pstrInstanceId);
    HRESULT InitClockList();
    HRESULT UpdateClockList();
    HRESULT AddClock(DMUS_CLOCKINFO &dmcc);
	void GetDefaultPortI(GUID *pguidPort);

    HRESULT GetDirectSoundI(LPDIRECTSOUND *ppDirectSound);
    void ReleaseDirectSoundI();
    PORTENTRY *GetPortByGUID(GUID guid);

#ifdef DXAPI    
    inline CMasterClock *GetMasterClockWrapperI()
    { return m_pMasterClock; }
#endif
    
private:
    long m_cRef;                                // Reference count
    CMemTrack m_MemTrack;                       // Only for debugging memory leaks
    
    CList<PORTENTRY *> m_lstDevices;            // Enumerated ports
    CList<IDirectMusicPort *> m_lstOpenPorts;   // Open ports

#ifdef DXAPI
    CMasterClock *m_pMasterClock;               // Current master clock
#else
    IReferenceClock *m_pMasterClock;
#endif
    long m_fDirectSound;                        // Has SetDirectSound been called?  
    BOOL m_fCreatedDirectSound;                 // True if DirectMusic was the one that created DirectSound  
    long m_cRefDirectSound;                     // Internal refs against DirectSound
    LPDIRECTSOUND m_pDirectSound;               // The DirectSound object, either from app or created
    HWND m_hWnd;                                // hWnd for DirectSound focus management    
    BOOL m_fDefaultToKernelSwSynth;             // (Reg) Default to kernel synth
    BOOL m_fDisableHWAcceleration;              // (Reg) Don't use any kernel devices
    BOOL m_nVersion;                            // DX Version QI'd for

    static LONG m_lInstanceCount;               // How many are there?
};

// WDM port
//
extern HRESULT
CreateCDirectMusicPort(
                       PORTENTRY *pPE, 
                       CDirectMusic *pDM, 
                       LPDMUS_PORTPARAMS pPortParams,
                       IDirectMusicPort **ppPort);

#define OVERLAPPED_ARRAY_SIZE 200

struct OverlappedStructs
{
    OVERLAPPED  aOverlappedIO[OVERLAPPED_ARRAY_SIZE];// Array of overlapped structures
    BOOL        afOverlappedInUse[OVERLAPPED_ARRAY_SIZE];// Array of flags set when correspondin overlapped structure is in use
    BYTE       *apOverlappedBuffer[OVERLAPPED_ARRAY_SIZE];// Array of buffers that store the events we sent down
};

class CPortLatencyClock;
class CDirectMusicPort : 
    public CDirectMusicPortDownload, 
    public IDirectMusicThru,
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicPortPrivate, 
    public IKsControl
{
friend DWORD WINAPI FreeWDMHandle(LPVOID);
friend DWORD WINAPI CaptureThread(LPVOID);

friend class CPortLatencyClock;
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInstrument,
	    							IDirectMusicDownloadedInstrument** pDownloadedInstrument,
									DMUS_NOTERANGE* NoteRanges,
									DWORD dwNumNoteRanges);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument* pDownloadedInstrument);

    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
    
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, DWORD dwSourceChannel, DWORD dwDestinationChannelGroup, DWORD dwDestinationChannel, LPDIRECTMUSICPORT pDestinationPort);

    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         OUT IDirectMusicVoiceP **ppVoice            
        );        
#ifndef XBOX
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        

#else
	STDMETHODIMP AssignChannelToOutput(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
        IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
        DWORD dwMixBins,                        // Or, mixbins, if assigned to them.
        BYTE *pbControllers);

#endif

    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    // IKsControl
    //
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // Override two methods from CDirectMusicPortDownload
	virtual STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();
    
    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE dwVoicePos[]);
         
    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);

#ifdef XBOX
    STDMETHODIMP IsReadyForData(
        DWORD dwDownloadID);
#endif

    // Class
    //
    CDirectMusicPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicPort();
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

private:
    // General port stuff
    //
    long                    m_cRef;                 // Reference count
	CDirectMusic            *m_pDM;                 // Owning DirectMusic object
    BOOL                    m_fIsOutput;            // Capture or render port
    IDirectMusicPortNotify  *m_pNotify;             // Notification interface on destruction
    DMUS_PORTCAPS           dmpc;                   // Caps as given to EnumPort
    BOOL                    m_fHasActivated;        // Has this port ever been activated?
    LONG                    m_lActivated;           // Activation count
    LPDIRECTSOUND           m_pDirectSound;         // DirectSound object for destination
    DWORD                   m_dwChannelGroups;      // Channel groups allocated
    GUID                    m_guidPort;             // GUID associated with port
    BOOL                    m_fAudioDest;           // There was a destination found 
    BOOL                    m_fDirectSoundSet;      // DirectSound object was set by app
    BOOL                    m_fCanDownload;         // This port supports downloads
    
    // WDM stuff
    //
    DWORD                   m_idxDev;               // SysAudio: Device number
    DWORD                   m_idxPin;               // SysAudio: Pin number
    DWORD                   m_idxSynthNode;         // SysAudio: Node number of synth node
    HANDLE                  m_hSysAudio;            // Handle to sysaudio instance
    HANDLE                  m_hPin;                 // Handle to pin
    ULONG                   m_ulVirtualSourceIndex; // Virtual source index for volume
    CList<OverlappedStructs *> m_lstOverlappedStructs;// List of arrays of overlapped structures and flags
    CRITICAL_SECTION        m_OverlappedCriticalSection;// Overlapped structure access critical section
    
    // Clock stuff
    //
    IReferenceClock         *m_pMasterClock;        // Master clock wrapped by this port
    CPortLatencyClock       *m_pClock;              // Implementation of latency clock
    
    // DLS download tracking stuff
    //
	HANDLE                  m_hUnloadThread;        // Thread for unloading async downloads
	HANDLE                  *m_phUnloadEventList;   // Event array of async downloads
	HANDLE                  *m_phNewUnloadEventList;// ??? Wobert - investigate 
	HANDLE                  m_hCopiedEventList;     // ???
	DWORD                   m_dwNumEvents;          // ???
	DWORD                   m_dwNumEventsAllocated; // ???
	CDLBufferList           m_UnloadedList;         // ???
    
	CRITICAL_SECTION        m_DMPortCriticalSection;// Port critical section
    BOOL                    m_fPortCSInitialized;   // Critical section initialized properly
    
    // Capture stuff
    //
    HANDLE                  m_hCaptureWake;         // Wake capture thread up to die
    HANDLE                  m_hCaptureThread;       // Capture thread handle
    BOOL                    m_fShutdownThread;      // Flag capture thread to die
    EVENT_POOL              m_FreeEvents;           // Free 4-byte events for capture thread
    EVENT_QUEUE             m_ReadEvents;           // Events captured, waiting to be read
    CRITICAL_SECTION        m_csEventQueues;        // CS protects event queues
    BOOL                    m_fQueueCSInitialized;  // CS properly initialized
    HANDLE                  m_hAppEvent;            // Application event to kick on new capture data
    
    // Thruing stuff
    //
    IDirectMusicBuffer      *m_pThruBuffer;         // Temp buffer to use for thruing 
    LPDMUS_THRU_CHANNEL     m_pThruMap;             // Thruing channel/mute map
    
    // Clock sync stuff
    //
    bool                    m_fSyncToMaster;        // Need to sync to master clock
    LONGLONG                m_lTimeOffset;          // Time difference
    IReferenceClock        *m_pPCClock;             // PortCls clock
    
private:
    BOOL PinSetState(KSSTATE DeviceState);
    HRESULT InitializeDownloadObjects();
    HRESULT InitializeCapture();
	void FreeWDMHandle();
    void CaptureThread();
    void InputWorkerDataReady(REFERENCE_TIME rtStart, LPBYTE pbData, ULONG cbData);
    void ThruEvent(DMEVENT *pEvent);
    void InitChannelPriorities(UINT uLoCG, UINT uHighCG);
    HRESULT SetDirectSoundI(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer,
        BOOL fSetByUser);
    void MasterToSlave(REFERENCE_TIME *);
    void SlaveToMaster(REFERENCE_TIME *);
    void SyncClocks();
};

class CPortLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    virtual STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    virtual STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    virtual STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    virtual STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CPortLatencyClock(HANDLE hPin, ULONG ulNodeId, CDirectMusicPort *port);
    ~CPortLatencyClock();

private:
    long m_cRef;                   
    HANDLE m_hPin;                  
    ULONG m_ulNodeId;
    CDirectMusicPort *m_pPort;
};

// Synth port
//
extern HRESULT 
CreateCDirectMusicSynthPort(
    PORTENTRY               *pe, 
    CDirectMusic            *pDM, 
    UINT                    uVersion,
    DMUS_PORTPARAMS         *pPortParams,
    IDirectMusicPort        **ppPort);
class CDirectMusicSynthPort : 
    public CDirectMusicPortDownload, 
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);

	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInstrument,
							 			    IDirectMusicDownloadedInstrument** pDownloadedInstrument,
											DMUS_NOTERANGE* NoteRanges,
											DWORD dwNumNoteRanges);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument* pDownloadedInstrument);

    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate) PURE;
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);

    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,     
         DWORD dwChannel,                       
         DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         IDirectMusicVoiceP **ppVoice            
        );        

    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        
        
    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    virtual STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();

    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart, 
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE dwVoiceState[]);

    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);

#ifdef XBOX
    STDMETHODIMP IsReadyForData(
        DWORD dwDownloadID);
#endif

    // Class
    //
    static HRESULT CreateSynthPort(
        PORTENTRY               *pe, 
        CDirectMusic            *pDM, 
        UINT                    uVersion,
        DMUS_PORTPARAMS         *pPortParams,
        CDirectMusicSynthPort   **ppPort);
    
    CDirectMusicSynthPort(
        PORTENTRY               *pPE, 
        CDirectMusic            *pDM,
        IDirectMusicSynth       *pSynth);
        
    virtual ~CDirectMusicSynthPort();
    
protected:    
    HRESULT Initialize(LPDMUS_PORTPARAMS pPortParams);
    void InitChannelPriorities(UINT uLoCG, UINT uHighCG);
    void InitializeVolumeBoost();
    void SetSinkKsControl(IKsControl *pSinkKsControl);
    
protected:
    long                        m_cRef;             // COM reference count
    CDirectMusic                *m_pDM;             // Owning DirectMusic object
    IDirectMusicPortNotify      *m_pNotify;         // Notification interface
    IKsControl                  *m_pSynthPropSet;   // Synth property set
    IKsControl                  *m_pSinkPropSet;    //  and sink property set
    IDirectMusicSynth           *m_pSynth;          // Base level synth iface
    DWORD                       m_dwChannelGroups;  // Cached #channel groups
    DMUS_PORTCAPS               m_dmpc;
    DWORD                       m_dwFeatures;       // Features from portparams
};


// IDirectMusicBuffer implementation.
//
// Common to emulation/WDM.
//
class CDirectMusicBuffer : public IDirectMusicBuffer
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicBuffer
    //
    virtual STDMETHODIMP Flush();
    virtual STDMETHODIMP TotalTime(LPREFERENCE_TIME pdwTime);
    virtual STDMETHODIMP PackStructured(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD dwMsg);
    virtual STDMETHODIMP PackUnstructured(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD cb, LPBYTE lpb);
    virtual STDMETHODIMP ResetReadPtr();
    virtual STDMETHODIMP GetNextEvent(LPREFERENCE_TIME, LPDWORD, LPDWORD, LPBYTE *);
    
    virtual STDMETHODIMP GetRawBufferPtr(LPBYTE *);
    virtual STDMETHODIMP GetStartTime(LPREFERENCE_TIME);
    virtual STDMETHODIMP GetUsedBytes(LPDWORD);
    virtual STDMETHODIMP GetMaxBytes(LPDWORD);
    virtual STDMETHODIMP GetBufferFormat(LPGUID pGuidFormat);

    virtual STDMETHODIMP SetStartTime(REFERENCE_TIME);
    virtual STDMETHODIMP SetUsedBytes(DWORD);
    
    
    // Class
    //
    CDirectMusicBuffer(DMUS_BUFFERDESC &dmbd);
    ~CDirectMusicBuffer();
    HRESULT Init();
    DMUS_EVENTHEADER *AllocEventHeader(REFERENCE_TIME rt, DWORD cbEvent, DWORD dwChannelGroup, DWORD dwFlags);

private:
    long m_cRef;
    REFERENCE_TIME m_rtBase;
    REFERENCE_TIME m_totalTime;
    LPBYTE m_pbContents;
    DWORD m_maxContents;
    DWORD m_cbContents;
    DWORD m_idxRead;
    DMUS_BUFFERDESC m_BufferDesc;

    DWORD m_nEvents;
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicFactory() : m_cRef(1) {}

    // Destructor
    // ~CMathFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicCollectionFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
	CDirectMusicCollectionFactory() : m_cRef(0) {AddRef();}

	// Destructor
	 ~CDirectMusicCollectionFactory() {} 

private:
	long m_cRef;
};


#ifdef USE_WDM_DRIVERS
// Enumeration of WDM devices
//
HRESULT EnumerateWDMDevices(CDirectMusic *pDirectMusic);
#endif


// Helper functions for dealing with SysAudio
//
BOOL OpenDefaultDevice(REFGUID rguidCategory, HANDLE *pHandle);
BOOL GetSysAudioProperty(HANDLE hFileObject, ULONG PropertyId, ULONG DeviceIndex, ULONG cbProperty, PVOID pProperty);
BOOL SetSysAudioProperty(HANDLE hFileObject, ULONG PropertyId, ULONG cbProperty, PVOID pProperty);
BOOL GetPinProperty(HANDLE pFileObject, ULONG PropertyId, ULONG PinId, ULONG cbProperty, PVOID pProperty);
BOOL SetPinProperty(HANDLE pFileObject, ULONG PropertyId, ULONG PinId, ULONG cbProperty, PVOID pProperty);
BOOL GetPinPropertyEx(HANDLE hFileObject, ULONG PropertyId, ULONG PinId, PVOID *ppProperty);
BOOL IsEqualInterface(const KSPIN_INTERFACE *pInterface1, const KSPIN_INTERFACE *pInterface2);
HRESULT CreatePin(HANDLE handleFilter, ULONG ulPinId, HANDLE *pHandle);
BOOL GetSizedProperty(HANDLE handle, ULONG ulPropSize, PKSPROPERTY pKsProperty, PVOID* ppvBuffer, PULONG pulBytesReturned);
BOOL Property(HANDLE handle, ULONG ulPropSize, PKSPROPERTY pKsProperty, ULONG ulBufferSize, PVOID pvBuffer, PULONG pulBytesReturned);
BOOL SyncIoctl(HANDLE handle, ULONG ulIoctl, PVOID pvInBuffer, ULONG ulInSize, PVOID   pvOutBuffer, ULONG ulOutSize, PULONG pulBytesReturned);

BOOL GetSysAudioDeviceCount(HANDLE hSysAudio, PULONG pulDeviceCount);
BOOL SetSysAudioDevice(HANDLE hSysAudio, ULONG idxDevice);
BOOL CreateVirtualSource(HANDLE hSysAudio, PULONG pulSourceIndex);
BOOL AttachVirtualSource(HANDLE hPin, ULONG ulSourceIndex);
int  FindGuidNode(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguid);
BOOL GetFilterCaps(HANDLE hSysAudio, ULONG idxNode, PSYNTHCAPS pcaps);
BOOL GetNumPinTypes(HANDLE hSysAudio, PULONG pulPinTypes);
BOOL PinSupportsInterface(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguidInterface, ULONG ulId);
BOOL PinSupportsDataRange(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguidFormat, REFGUID rguidSubformat);
BOOL PinGetDataFlow(HANDLE hSysAudio, ULONG ulPinId, PKSPIN_DATAFLOW pkspdf);
BOOL GetDeviceFriendlyName(HANDLE hSysAudio, ULONG ulDeviceIndex, PWCHAR pwch, ULONG cbwch);
BOOL GetDeviceInterfaceName(HANDLE hSysAudio, ULONG ulDeviceIndex, PWCHAR pwch, ULONG cbwch);
BOOL DINameToInstanceId(char *pstrDIName, char **ppInstanceId);
BOOL InstanceIdOfPreferredAudioDevice(char **ppInstanceId);

// Helper functions for dealing with DirectSound
//
HRESULT DirectSoundDevice(LPDIRECTSOUND pDirectSound, LPSTR *pstrInterface);

HRESULT WIN32ERRORtoHRESULT(DWORD dwError);

// Helper functions from DMDLL.CPP
//
BOOL LoadDmusic32(void);
BOOL LoadKsUser(void);

DEFINE_GUID(GUID_Mapper,					 0x58d58418, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_SysClock,					 0x58d58419, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortNotify,		 0x58d5841a, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortPrivate,	 0x58d5841c, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_KsClock,					 0x58d5841d, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IMasterClockPrivate,         0x58d5841e, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_KsClockHandle,              0x58d5841f, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_WDMSynth,                   0x490a03e8, 0x742f, 0x11d2, 0x8f, 0x8a, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(GUID_DsClock,                    0x58d58420, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_ExtClock,                   0x58d58421, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);


#if 0
// List o' unused UUID's
58d58422-71b4-11d1-a74c-0000f875ac12
58d58423-71b4-11d1-a74c-0000f875ac12
58d58424-71b4-11d1-a74c-0000f875ac12
58d58425-71b4-11d1-a74c-0000f875ac12
58d58426-71b4-11d1-a74c-0000f875ac12
58d58427-71b4-11d1-a74c-0000f875ac12
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmusic.cpp ===
//
// DMusic.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
// @module DirectMusic | DirectMusic core services
//
// Provides the code DirectMusic services for delivering time-stamped data and managing
// DLS collections.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#define INITGUID
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "debug.h"
#include <mmsystem.h>
#include "dlsstrm.h"
#include <regstr.h>
#include "oledll.h"

#include "dmusicp.h"
#include "..\dmusic32\dmusic32.h"
#include "debug.h"
#include "dmdlinst.h"
#include "dminstru.h"
#include "validate.h"
#include "dmusprop.h"

#include <string.h>

#ifdef UNICODE
#ifndef XBOX
#error This module cannot compile with UNICODE defined.
#endif // ! XBOX
#endif // UNICODE



// @globalv:(INTERNAL) Registry key for description of synth
//
const char cszDescription[] = "Description";
const WCHAR cwszDescription[] = L"Description";

// @globalv:(INTERNAL) Format string for output ports under the legacy subtree
const char cszPortOut[] = "%s\\Out";
const WCHAR cwszPortOut[] = L"%s\\Out";

// @globalv:(INTERNAL) Format string for input ports under the legacy subtree
const char cszPortIn[] = "%s\\In";
const WCHAR cwszPortIn[] = L"%s\\In";

// @globalv:(INTERNAL) Key for the DirectMusic GUID anywhere in the registry
const char cszGUID[]   = "DMPortGUID";

// @globalv:(INTERNAL) Value for storing default output port
//
const char cszDefaultOutputPort[] = "DefaultOutputPort";

// @globalv:(INTERNAL) Value for turning off hw acceleration
//
const char cszDisableHWAcceleration[] = "DisableHWAcceleration";

// 
//
const char cszDefaultToKernelSynth[] = "DefaultToMsKernelSynth";

// @globalv:(INTERNAL) Filename of the sysaudio device from Ring 3
const char cszSADName[] = "\\\\.\\sysaudio";

// @globalv:(INTERNAL) Entry point into Dmusic32.dll for enumeration of legacy devices
const char cszEnumLegacyDevices[] = "EnumLegacyDevices";

// @globalv:(INTERNAL) Entry point into Dmusic32.dll for creation of emulated port
const char cszCreateEmulatePort[] = "CreateCDirectMusicEmulatePort";

const GUID guidZero = {0};
static const int CLSID_STRING_SIZE = 39;

LONG CDirectMusic::m_lInstanceCount = 0;


// @doc EXTERNAL



// @mfunc:(INTERNAL) Constructor for <c CDirectMusic>
//
// @comm Just increments the global count of components.
//
CDirectMusic::CDirectMusic() : 
    m_pMasterClock(NULL),
    m_cRef(1), 
    m_fDirectSound(0),
    m_cRefDirectSound(0),
    m_pDirectSound(NULL),
    m_fCreatedDirectSound(FALSE),
    m_nVersion(7),
    m_MemTrack(DMTRACK_DMUSIC)
{
    TraceI(2, "CDirectMusic::CDirectMusic()\n");
    InterlockedIncrement(&g_cComponent);
    InterlockedIncrement(&m_lInstanceCount);
}


// @mfunc:(INTERNAL) Destructor for <c CDirectMusic>
//
// @comm Decrements the global component counter and frees the port list.
//
CDirectMusic::~CDirectMusic()
{
    CNode<PORTENTRY *> *pNode;
    CNode<PORTENTRY *> *pNext;
    CNode<PORTDEST *> *pDest;
    CNode<PORTDEST *> *pNextDest;

    TraceI(2, "CDirectMusic::~CDirectMusic\n");

	InterlockedDecrement(&g_cComponent);
    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNext)
    {
        for (pDest = pNode->data->lstDestinations.GetListHead(); pDest; pDest = pNextDest)
        {
            pNextDest = pDest->pNext;
            delete[] pDest->data->pstrInstanceId;
            delete pDest->data;
            
            pNode->data->lstDestinations.RemoveNodeFromList(pDest);
            pDest = pNextDest;
        }
                    
        pNext = pNode->pNext;
        delete pNode->data;
        m_lstDevices.RemoveNodeFromList(pNode);
    }

/*    CNode<IDirectMusicPort *> *pOpenNode;
    CNode<IDirectMusicPort *> *pOpenNext;

    // HACK HACK Close unreleased ports at exit HACK HACK
    //    
    for (pOpenNode = m_lstOpenPorts.GetListHead(); pOpenNode; pOpenNode = pOpenNext)
    {   
        pOpenNext = pOpenNode->pNext;
        IDirectMusicPort *pPort = pOpenNode->data;

        IDirectMusicPortPrivate *pPrivate;
        HRESULT hr = pPort->QueryInterface(IID_IDirectMusicPortPrivate, (LPVOID*)&pPrivate);

        if (SUCCEEDED(hr))
        {
            pPrivate->Close();
            pPrivate->Release();
        }

        m_lstOpenPorts.RemoveNodeFromList(pOpenNode);        
    }*/

    if (m_pMasterClock)
    {
#ifdef DXAPI
        m_pMasterClock->ReleasePrivate();
#else
        m_pMasterClock->Release();
#endif
    }

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
    }

#ifndef XBOX
    if (InterlockedDecrement(&m_lInstanceCount) == 0 && g_hModuleKsUser)
    {
        HMODULE h = g_hModuleKsUser;
        g_hModuleKsUser  = NULL;

        FreeLibrary(h);
    }
#endif
}

// CDirectMusic::QueryInterface
//
//
STDMETHODIMP CDirectMusic::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusic || iid == IID_IDirectMusic2)
    {
        *ppv = static_cast<IDirectMusic*>(this);
    }
    else if (iid == IID_IDirectMusic8)
    {
        *ppv = static_cast<IDirectMusic8*>(this);
        m_nVersion = 8;
    }
    else if (iid == IID_IDirectMusicPortNotify)
    {
        *ppv = static_cast<IDirectMusicPortNotify*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CDirectMusic::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusic::AddRef()
{
//    DebugBreak();
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusic::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusic::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        if (m_lstOpenPorts.GetNodeCount() == 0) 
        {
            delete this;
            return 0;
        }
    }

    return m_cRef;
}


// @mfunc:(INTERNAL) Initialization.
//
// Enumerate the WDM and legacy devices into the port list.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag E_NOINTERFACE | If there were no ports detected
// @flag E_OUTOFMEMORY | If there was insufficient memory to create the list
//      
HRESULT CDirectMusic::Init()
{
    HRESULT hr = S_OK;
#ifdef DXAPI
    m_pMasterClock = new CMasterClock;
    if (m_pMasterClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_pMasterClock->AddRefPrivate();

    hr = m_pMasterClock->Init();
    if (FAILED(hr)) 
    {
        TraceI(0, "Could not initialize clock stuff [%08X]\n", hr);
        return hr;
    }

    // Cache default port behavior
    //
    m_fDefaultToKernelSwSynth = FALSE;
    m_fDisableHWAcceleration = FALSE;

    HKEY hk;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      REGSTR_PATH_DIRECTMUSIC,
                      0L,
                      KEY_READ,
                      &hk))
    {
        DWORD dw;
        DWORD dwValue;

        DWORD cb = sizeof(dwValue);

        if (!RegQueryValueExA(
            hk, 
            cszDefaultToKernelSynth, 
            NULL, 
            &dw, 
            (LPBYTE)&dwValue, 
            &cb)) 
        {
            if (dwValue) 
            {
                Trace(0, "Default port set to Microsoft kernel synth by registry key\n");
                m_fDefaultToKernelSwSynth = TRUE;
            }
        }

        cb = sizeof(dwValue);

        if (!RegQueryValueExA(
            hk, 
            cszDisableHWAcceleration, 
            NULL, 
            &dw, 
            (LPBYTE)&dwValue, 
            &cb)) 
        {
            if (dwValue) 
            {
                Trace(0, "Hardware acceleration and kernel synthesizers disabled by registry key\n");
                m_fDisableHWAcceleration = TRUE;
            }
        }

        RegCloseKey(hk);
    }
 #endif // ! XBOX   

    return hr == S_OK ? S_OK : E_NOINTERFACE;
}

// @mfunc:(INTERNAL) Update the port list.
//
// Enumerate the WDM and legacy devices into the port list.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no ports detected
// @flag E_OUTOFMEMORY | If there was insufficient memory to create the list
//
HRESULT CDirectMusic::UpdatePortList()
{
    CNode<PORTENTRY *> *pNode;
    CNode<PORTENTRY *> *pNext;
    CNode<PORTDEST *> *pDest;
    CNode<PORTDEST *> *pNextDest;
    HRESULT hr;

    TraceI(2, "UpdatePortList()\n");

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pNode->data->fIsValid = FALSE;
    }

#ifndef XBOX
    // Only look for WDM devices if KS is around.
    //
    if (LoadKsUser())
    {
        TraceI(2, "Adding WDM devices\n");

        hr = AddWDMDevices();
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
    }
#endif // ! XBOX

    hr = AddLegacyDevices();
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = AddSoftwareSynths();
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNext)
    {
        pNext = pNode->pNext;

		// Validate data
		if(pNode->data == NULL)
		{
			return DMUS_E_NOT_INIT;
		}

        if (!pNode->data->fIsValid)
        {
            for (pDest = pNode->data->lstDestinations.GetListHead(); pDest; pDest = pNextDest)
            {
                pNextDest = pDest->pNext;
				
				if(pNextDest == NULL)
				{
					return DMUS_E_NOT_INIT;
				}

				if(pNextDest->data == NULL)
				{
					return DMUS_E_NOT_INIT;
				}


                delete[] pNextDest->data->pstrInstanceId;
                delete pNextDest->data;
                
                pNode->data->lstDestinations.RemoveNodeFromList(pDest);
                pDest = pNextDest;
            }

            delete pNode->data;
            m_lstDevices.RemoveNodeFromList(pNode);
        }
    }

    TraceI(1, "UpdatePortList() end: %d devices\n", m_lstDevices.GetNodeCount());

    return m_lstDevices.GetNodeCount() ? S_OK : S_FALSE;
}


// @mfunc:(INTERNAL) Update the port list with WDM devices enumerated via the
// System Audio Device (SAD).
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
// @comm This must be implemented.
//
const GUID guidMusicFormat = KSDATAFORMAT_TYPE_MUSIC;
const GUID guidMIDIFormat  = KSDATAFORMAT_SUBTYPE_DIRECTMUSIC;

HRESULT CDirectMusic::AddWDMDevices()
{
#ifdef USE_WDM_DRIVERS
    return EnumerateWDMDevices(this);
#else
    return S_FALSE;
#endif
}

static HRESULT AddDeviceCallback(
    VOID *pInstance,		   // @parm 'this' pointer								 
    DMUS_PORTCAPS &dmpc,        // @parm The already filled in portcaps
    PORTTYPE pt,               // @parm The port type								 
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The Node ID of the synthesizer node; ignored if this is a legacy device
    HKEY hkPortsRoot)          // @parm Where port information is stored in the registry
{
    CDirectMusic *pdm = (CDirectMusic*)pInstance;

    //This should never be called to add a WDM device
    assert(pt != ptWDMDevice);
    
    return pdm->AddDevice(dmpc, 
                          pt, 
                          idxDev, 
                          idxPin, 
                          idxNode, 
                          FALSE,        // Legacy device is never the preferred device
                          hkPortsRoot,
                          NULL,
                          NULL);
}


// @mfunc:(INTERNAL) Update the port list with legacy devices enumerated via 
// the WinMM MIDI API.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
// @comm This function needs to update the list rather than just add.
//
HRESULT CDirectMusic::AddLegacyDevices()
{
#ifdef XBOX
    return S_FALSE;
#else
#ifdef WINNT
	return EnumLegacyDevices(this, AddDeviceCallback);
#else
    if ((!(g_fFlags & DMI_F_WIN9X)) ||
        (!LoadDmusic32()))
    {
        return S_FALSE;
    }

    PENUMLEGACYDEVICES peld = (PENUMLEGACYDEVICES)GetProcAddress(g_hModuleDM32,
                                                                 cszEnumLegacyDevices);

    if (NULL == peld)
    {
        TraceI(0, "Could not get EnumLegacyDevice entry point from DMusic32.dll!");
        return S_FALSE;
    }

    return (*peld)(this, AddDeviceCallback);
#endif
#endif // !XBOX
}

// @mfunc:(INTERNAL) Add software synthesizers from the registry.
//
// 
HRESULT CDirectMusic::AddSoftwareSynths()
{
#ifdef XBOX

    // Create a synth instance
    //
    HRESULT hr;
    IDirectMusicSynth *pSynth;
    hr = DirectMusicCreateInstance(CLSID_DirectMusicSynth,NULL,
                          IID_IDirectMusicSynth,
                          (LPVOID*)&pSynth);
    if (FAILED(hr))
    {
       TraceI(1, "Enum: Failed creation of synth hr=%08lX\n", hr);
       return S_OK;
    }


	DMUS_PORTCAPS dmpc;

    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);
    dmpc.guidPort = CLSID_DirectMusicSynth;
    dmpc.dwType = DMUS_PORT_USER_MODE_SYNTH;
    
	hr = pSynth->GetPortCaps(&dmpc);
    
    if (SUCCEEDED(hr))
    {
		AddDevice(dmpc,
				  ptSoftwareSynth,
				  -1,
				  -1,
				  -1,
				  FALSE,
				  NULL,
				  NULL,
				  NULL);
	}

	pSynth->Release();

#endif // XBOX

#ifndef XBOX
    HKEY hk;
    DWORD idxSynth;
    char szSynthGUID[256];
    HRESULT hr;
    CLSID clsid;
	DMUS_PORTCAPS dmpc;
    IDirectMusicSynth *pSynth;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      REGSTR_PATH_SOFTWARESYNTHS,
                      0L,
                      KEY_READ,
                      &hk))
    {
        for (idxSynth = 0; !RegEnumKey(hk, idxSynth, szSynthGUID, sizeof(szSynthGUID)); ++idxSynth)
        {
            hr = StrToCLSID(szSynthGUID, clsid, sizeof(szSynthGUID));
            if (!SUCCEEDED(hr))
            {
                continue;
            }

            // Create a synth instance
            //
            hr = DirectMusicCreateInstance(clsid,NULL,IID_IDirectMusicSynth,(LPVOID*)&pSynth);
            if (FAILED(hr))
            {
                TraceI(1, "Enum: Failed creation of synth %s hr=%08lX\n", szSynthGUID, hr);
                continue;
            }

            ZeroMemory(&dmpc, sizeof(dmpc));
            dmpc.dwSize = sizeof(dmpc);
            dmpc.guidPort = clsid;
            dmpc.dwType = DMUS_PORT_USER_MODE_SYNTH;
            
            hr = pSynth->GetPortCaps(&dmpc);
            if (FAILED(hr))
            {
                TraceI(1, "Enum: Synth %s returned %08lX for GetPortCaps\n", szSynthGUID, hr);
                pSynth->Release();
                continue;
            }

            if (dmpc.guidPort != clsid)
            {
                TraceI(0, "Enum: WARNING: Synth %s changed its CLSID!\n", szSynthGUID);
            }

            AddDevice(dmpc,
                      ptSoftwareSynth,
                      -1,
                      -1,
                      -1,
                      FALSE,
                      NULL,
                      NULL,
                      NULL);

            pSynth->Release();
        }

        RegCloseKey(hk);
    }
#endif // ! XBOX

    return S_OK;
}


// @mfunc:(INTERNAL) Add one device to the master device list, possibly updating an existing
// entry.
//
// @rdesc One of the following
// @flag S_OK | On success
//
HRESULT CDirectMusic::AddDevice(
    DMUS_PORTCAPS &dmpc,        // @parm Already filled in port caps
    PORTTYPE pt,               // @parm The port type
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The pin # if this is a WDM device								
    int idxNode,               // @parm The node # of the synth node if this is a WDM device
    BOOL fPrefDev,             // @parm This is on the preferred device
    HKEY hkPortsRoot,          // @parm Where port information is stored in the registry                                         
    LPWSTR wszDIName,          // @parm The Device Interface name if this is a WDM Device.
    LPSTR pstrInstanceId       // @parm The InstanceID if the device is a WDM device.
    )          {
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pPort;
    BOOL fFound;
    HKEY hkPort;
    char szRegKey[sizeof(cszPortOut) + DMUS_MAX_DESCRIPTION + 1];
    WCHAR wszRegKey[sizeof(cszPortOut) + DMUS_MAX_DESCRIPTION + 1];
    DWORD cb;
    DWORD dw;
    BOOL fGotGUID;
    HRESULT hr;
    char sz[256];
    BOOL fGotRegKey;

    // First find out if this device is already in the list
    //
#ifdef DEBUG
    SafeWToA(sz, dmpc.wszDescription);
    
    TraceI(1, "AddDevice: Adding [%s] index %d class %d\n",
		  sz,
		  idxDev,
		  dmpc.dwClass);
#endif
    
    for (pNode = m_lstDevices.GetListHead(), fFound = FALSE; pNode && !fFound; pNode = pNode->pNext)
    {
        pPort = pNode->data;

		if (pPort->type != pt || pPort->pc.dwClass != dmpc.dwClass)
		{
			continue;
		}
		
		switch(pt)
		{
			case ptWDMDevice:
				if (dmpc.guidPort == pPort->pc.guidPort)
				{
					fFound = TRUE;
				}
				break;
					
			case ptLegacyDevice:
				if (!_wcsicmp(dmpc.wszDescription, pPort->pc.wszDescription))
				{
					fFound = TRUE;
				}
				break;

			case ptSoftwareSynth:
				if (dmpc.guidPort == pPort->pc.guidPort)
				{
					fFound = TRUE;
				}
				break;

			default:
				assert(FALSE);
		}
	}

    if (fFound)
    {
        // Already have an entry - just update the device index
        //
        TraceI(1, "AddDevice: Reusing entry\n");
        pPort->idxDevice = idxDev;
		pPort->idxPin = idxPin;
        pPort->fIsValid = TRUE;
        pPort->fPrefDev = fPrefDev;
		
        return S_OK;
    }

    // No existing entry - need to create a new one plus a GUID.
    //
    pPort = new PORTENTRY;
    if (NULL == pPort)
    {
        return E_OUTOFMEMORY;
    }

    //clean up the junk in the wszDIName member
    ZeroMemory(pPort->wszDIName,256 * sizeof(WCHAR));

	CopyMemory(&pPort->pc, &dmpc, sizeof(DMUS_PORTCAPS));

    fGotGUID = (dmpc.guidPort != guidZero) ? TRUE : FALSE;

#ifndef XBOX
    if (hkPortsRoot)
    {
        if (g_fFlags & DMI_F_WIN9X)
        {
            SafeWToA(sz, dmpc.wszDescription);
            wsprintfA(szRegKey,
                      dmpc.dwClass == DMUS_PC_INPUTCLASS ? cszPortIn : cszPortOut,
                      sz);
            fGotRegKey = !RegCreateKeyA(hkPortsRoot, szRegKey, &hkPort);
        }
        else
        {
            wsprintfW(wszRegKey,
                      dmpc.dwClass == DMUS_PC_INPUTCLASS ? cwszPortIn : cwszPortOut,
                      dmpc.wszDescription);
            fGotRegKey = !RegCreateKeyW(hkPortsRoot, wszRegKey, &hkPort);
        }

        if (fGotRegKey)
        {
            cb = sizeof(pPort->pc.guidPort);
            if (fGotGUID)
            {
                RegSetValueExA(hkPort, cszGUID, 0, REG_BINARY, (LPBYTE)&pPort->pc.guidPort, sizeof(pPort->pc.guidPort));
            }
            else if (RegQueryValueExA(hkPort, cszGUID, NULL, &dw, (LPBYTE)&pPort->pc.guidPort, &cb))
            {
                // No GUID yet for this device - create one
                //
                hr = UuidCreate(&pPort->pc.guidPort);
                if (SUCCEEDED(hr))
                {
                    TraceI(1, "AddDevice: Setting GUID in registry\n");
                    RegSetValueExA(hkPort, cszGUID, 0, REG_BINARY, (LPBYTE)&pPort->pc.guidPort, sizeof(pPort->pc.guidPort));
                    fGotGUID = TRUE;
                }
            }
            else
            {
                TraceI(1, "AddDevice: Pulled GUID from registry\n");
                fGotGUID = TRUE;
            }
            
            RegCloseKey(hkPort);
        }
    }
#endif // ! XBOX

    if (!fGotGUID)
    {
        // Some registry call failed - get a one-time guid anyway
        //
#ifdef XBOX
        // We'll be removing this code, but this will get it to compile for NOW...
        pPort->pc.guidPort = GUID_NULL;
        hr = S_OK;
#else  // XBOX
        hr = UuidCreate(&pPort->pc.guidPort);
        if (SUCCEEDED(hr))
#endif // XBOX
        {
            TraceI(1, "AddDevice: Registry failed, getting dynamic GUID\n");
            fGotGUID = TRUE;
        }
    }

    if (!fGotGUID)
    {
        TraceI(0, "AddDevice: Ignoring [%s]; could not get GUID!\n", dmpc.wszDescription);
        // Something really strange is failing
        //
        delete pPort;
        return E_OUTOFMEMORY;
    }

    TraceI(1, "AddDevice: Adding new list entry.\n");
    // We have an entry and a GUID, add other fields and put in the list
    //
	pPort->type = pt;
    pPort->fIsValid = TRUE;
    pPort->idxDevice = idxDev;
	pPort->idxPin = idxPin;
    pPort->idxNode = idxNode;
    pPort->fPrefDev = fPrefDev;
    pPort->fAudioDest = FALSE;

    //if we get a Device Interface name, copy it
    if (wszDIName != NULL)
    {
        wcscpy(pPort->wszDIName,wszDIName);
    }

    if (NULL == m_lstDevices.AddNodeToList(pPort))
    {
        delete pPort;
        return E_OUTOFMEMORY;
    }

    //One final piece of work.
    //If the device we added was a WDM Software Synth -- we need to check that the
    //destination port is up to date.

    if ((pt == ptWDMDevice) && (dmpc.dwFlags & SYNTH_PC_SOFTWARESYNTH))
    {
        pPort->fAudioDest = TRUE;

        CNode<PORTDEST *> *pNode = NULL;
        PORTDEST *pDest = NULL;
        fFound = FALSE;

        for (pNode = pPort->lstDestinations.GetListHead(), fFound = FALSE; 
                 pNode && !fFound; 
                 pNode = pNode->pNext)
            {
                pDest = pNode->data;
                if (!strcmp(pDest->pstrInstanceId, pstrInstanceId))
                {
                    fFound = TRUE;
                }
            }

            if (!fFound)
            {
                pDest = new PORTDEST;
                
                pDest->idxDevice = idxDev;
                pDest->idxPin = idxPin;
                pDest->idxNode = idxNode;
                pDest->fOnPrefDev = fPrefDev;

                pDest->pstrInstanceId = new char[strlen(pstrInstanceId) + 1];
                if (NULL == pDest->pstrInstanceId)
                {
                    delete pDest;
                    return E_OUTOFMEMORY;
                }
                strcpy(pDest->pstrInstanceId, pstrInstanceId);

                if (NULL == pPort->lstDestinations.AddNodeToList(pDest))
                {
                    delete[] pDest->pstrInstanceId;
                    delete pDest;
                    return E_OUTOFMEMORY;
                }

                TraceI(1, "  This synth instance is on instance id %s\n", pstrInstanceId);
            }
    }
            
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusic | EnumPort | Enumerates the available ports.
//
// @comm
//
// The IDirectMusic::EnumPort method enumerates and retrieves the
// capabilities of each DirectMusic port on the system.  Each time it is
// called, EnumPort returns information about a single port.
// Applications should not rely on or store the index number of a port.
// Rebooting, as well as adding and removing ports could cause the index
// number of a port to change.  The GUID identifying the port, however,
// does not change.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag S_FALSE | Invalid index number
// @flag E_POINTER | If the pPortCaps parameter was invalid
// @flag E_NOINTERFACE | If there were no ports to enumerate
// @flag E_INVALIDARG | If the <p lpPortCaps> struct is not the correct size
//
STDMETHODIMP CDirectMusic::EnumPort(
    DWORD dwIndex,						// @parm Specifies the index of the port for which the capabilities are to be returned.
                                        // This parameter should be zero on the first call and then incremented by one in each
                                        // subsequent call until S_FALSE is returned.  
    LPDMUS_PORTCAPS lpPortCaps)			// @parm Pointer to the <c DMUS_PORTCAPS>a structure to receive the capabilities of the port.
{

	CNode<PORTENTRY *> *pNode;

    V_INAME(IDirectMusic::EnumPort);
    V_STRUCTPTR_READ(lpPortCaps, DMUS_PORTCAPS);

	pNode = m_lstDevices.GetListHead();
	if (dwIndex == 0 || pNode == NULL)
	{
		UpdatePortList();
	}
    
    pNode = m_lstDevices.GetListHead();
    if (NULL == pNode)
    {
        return E_NOINTERFACE;
    }

	while (dwIndex-- && pNode)
	{
		pNode = pNode->pNext;
	}

	if (pNode == NULL)
	{
		return S_FALSE;
	}

	*lpPortCaps = pNode->data->pc;

	return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | CreateMusicBuffer | Creates a buffer which holds music data for input or output.
//
// @comm
//
// The IDirectMusic::CreateMusicBuffer method creates a
// DirectMusicBuffer object.  This buffer is then filled with music
// events to be sequenced or passed to IDirectMusicPort::Read to be
// filled with incoming music event.  
//
//
// @rdesc Returns one of the following
//  
// @flag S_OK | On success
// @flag E_POINTER | If any of the passed pointers is invalid.
// @flag E_INVALIDARG | If any of the other arguments is invalid
// 
//
STDMETHODIMP CDirectMusic::CreateMusicBuffer(
    LPDMUS_BUFFERDESC pBufferDesc,           // @parm Address of the <c DMUS_BUFFERDESC> structure that contains
                                            // the description of the music buffer to be created.
    LPDIRECTMUSICBUFFER *ppBuffer,          // @parm Address of the IDirectMusicBuffer interface pointer if successful.
    LPUNKNOWN pUnkOuter)                    // @parm Address of the controlling object's IUnknown interface for COM
                                            // aggregation, or NULL if the interface is not aggregated. Most callers will pass NULL.
{
    V_INAME(IDirectMusic::CreateMusicBuffer);
    V_STRUCTPTR_READ(pBufferDesc, DMUS_BUFFERDESC);
    V_PTRPTR_WRITE(ppBuffer);
    V_PUNKOUTER_NOAGG(pUnkOuter);

    *ppBuffer = NULL;

    CDirectMusicBuffer *pBuffer = new CDirectMusicBuffer(*pBufferDesc);
    if (NULL == pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pBuffer->Init();
    if (!SUCCEEDED(hr))
    {
        delete pBuffer;
        return hr;
    }

    *ppBuffer = pBuffer;

    return S_OK;
}

/*
 @method:(EXTERNAL) HRESULT | IDirectMusic | CreatePort | Creates a port to a hardware or software device for music input or output

 @comm

The IDirectMusic::CreatePort method is used to create a port object
for a particular DirectMusic port based on the GUID obtained through
the <om IDirectMusic::EnumPort> call.

The <p pPortParams> structure specifies parameters for the newly created port. If all parameters could not
be obtained, then the passed <p pPortParams> structure will be changed as follows to match the available
parameters of the port.

On entry, the dwValidParams field of the structure indicates which fields in the structure are valid. CreatePort
will never set flags in this field that the application did not set before the call. However, if the requested port
does not support a requested feature at all, then a flag may be cleared in dwValidParams, indicating that the
given field was ignored. In this case S_FALSE will be returned from the method instead of S_OK.

If the port supports a specified parameter, but the given value for the parameter is out of range, then the 
parameter value in <p pPortParams> will be changed. In this case, the flag in dwValidParams will remain set, but
S_FALSE will be returned to indicate that the struct has been changed.

@ex For example, to request reverb and determine if it was obtained, an application might execute the following code:

    DMUS_PORTPARAMS params;
    ZeroMemory(&params, sizeof(params));
    params.dwSize = sizeof(params);
    params.dwValidParams = DMUS_PORTPARAMS_REVERB;
    params.fReverb = TRUE;

    HRESULT hr = pDirectMusic->CreatePort(guidPort, NULL, &params, &port, NULL);
    if (SUCCEEDED(hr))
    {
        fGotReverb = TRUE;

        if (hr == S_FALSE)
        {
            if (!(params.dwValidParams & DMUS_PORPARAMS_REVERB))
            {
                // Device does not know what reverb is
                //
                fGotReverb = FALSE;
            }
            else if (!params.fReverb)
            {
                // Device understands reverb, but could not allocate it
                //
                fGotReverb = FALSE;
            }
        }
    }
                

@rdesc Returns one of the following

@flag S_OK | On success
@flag S_FALSE | If the port was created, but some requested paramter is not available
@flag E_POINTER | If any of the passed pointers is invalid
@flag E_INVALIDARG | If the <p lpPortParams> struct is not the correct size
*/
STDMETHODIMP CDirectMusic::CreatePort(
    REFGUID rguidPort,              // @parm Reference to (C++) or address of (C) the GUID that identifies the
                                    // port for which the IDirectMusicPort interface is to be created.  This
                                    // parameter must be a GUID returned by <om IDirectMusic::EnumPort>.  If it
                                    // is GUID_NULL, then the returned port will be the port specified in
                                    // the registry.
                                    //
                                      
    LPDMUS_PORTPARAMS pPortParams,   // @parm The <c DMUS_PORTPARAMS> struct which contains open parameters for the port.
                                      
    LPDIRECTMUSICPORT *ppPort,      // @parm Address of the <i IDirectMusicPort> interface pointer if successful.
                                      
    LPUNKNOWN pUnkOuter)            // @parm Address of the controlling object's IUnknown interface for COM
                                    // aggregation, or NULL if the interface is not aggregated. Most callers will pass NULL.
{
	HRESULT                         hr;
    HRESULT                         hrInit;
#ifndef WINNT
    PCREATECDIRECTMUSICEMULATEPORT  pcdmep;
#endif
    DWORD                           dwParamsVer;

    V_INAME(IDirectMusic::CreatePort);
    V_PTRPTR_WRITE(ppPort);
    V_PUNKOUTER_NOAGG(pUnkOuter);
    V_REFGUID(rguidPort);

    V_STRUCTPTR_WRITE_VER(pPortParams, dwParamsVer);
    V_STRUCTPTR_WRITE_VER_CASE(DMUS_PORTPARAMS, 7);
    V_STRUCTPTR_WRITE_VER_CASE(DMUS_PORTPARAMS, 8);
    V_STRUCTPTR_WRITE_VER_END(DMUS_PORTPARAMS, pPortParams);

    GUID guid;

    if (!m_fDirectSound)
    {
        return DMUS_E_DSOUND_NOT_SET;
    }

    // First check for default port
    //
    if (rguidPort == GUID_NULL)
    {
        GetDefaultPortI(&guid);
    }
    else
    {
        guid = rguidPort;
    }
	
    *ppPort = NULL;
    
    // Find DMPORTCAP entry if there is one.
    //
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pCap = NULL;

    // If they used a cached GUID w/o calling EnumPort first, make sure we have
    // the list of ports up to date.
    //
    if (!m_lstDevices.GetListHead())
    {
        UpdatePortList();
    }

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data->pc.guidPort == guid)
        {
            pCap = pNode->data;
            break;
        }
    }

    if (!pCap)
    {
        return E_NOINTERFACE;
    }

    // Now create the correct port implementation
    //
	switch(pCap->type)
	{
#ifdef USE_WDM_DRIVERS
		case ptWDMDevice:
            hrInit = CreateCDirectMusicPort(pCap, this, pPortParams, ppPort);
			break;
#endif

#ifndef XBOX
		case ptLegacyDevice:
#ifdef WINNT
			hrInit = CreateCDirectMusicEmulatePort(pCap, this, pPortParams, ppPort);
#else
			TraceI(1, "Create legacy device\n");
            if ((!(g_fFlags & DMI_F_WIN9X)) ||
                (!LoadDmusic32()))
			{
				return E_NOINTERFACE;
			}

			pcdmep =
				(PCREATECDIRECTMUSICEMULATEPORT)GetProcAddress(g_hModuleDM32,
				                                               cszCreateEmulatePort);

			if (NULL == pcdmep)
			{
				TraceI(0, "Could not get CreateCDirectMusicEmulatePort from DMusic32.dll");
				return E_NOINTERFACE;
			}
			
			hrInit = (*pcdmep)(pCap, this, pPortParams, ppPort);
#endif			
			break;
#endif // ! XBOX

			case ptSoftwareSynth:
			TraceI(1, "Create software synth\n");

            hrInit = CreateCDirectMusicSynthPort(
                pCap, 
                this, 
                dwParamsVer,
                pPortParams, 
                ppPort);

			break;

		default:
			TraceI(0, "Attempt to create a port with an unknown type %u\n", pCap->type);
			return E_NOINTERFACE;
	}

    if (FAILED(hrInit))
    {
        return hrInit;
    }

    // Only synth supports dwFeatures
    //
    if (pCap->type != ptSoftwareSynth && dwParamsVer >= 8)
    {
        DMUS_PORTPARAMS8 *pp8 = (DMUS_PORTPARAMS8*)pPortParams;

        if ((pp8->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pp8->dwFeatures != 0))
        {
            pp8->dwFeatures = 0;
            hrInit = S_FALSE;                        
        }
    }

    // Add port to the list of open ports
    //
    m_lstOpenPorts.AddNodeToList(*ppPort);

    // Set default volume setting
    //
    IKsControl *pControl;
    hr = (*ppPort)->QueryInterface(IID_IKsControl, (void**)&pControl);
    if (SUCCEEDED(hr)) 
    {
        KSPROPERTY ksp;
        LONG lVolume = 0;
        ULONG cb;

        ZeroMemory(&ksp, sizeof(ksp));
        ksp.Set   = KSPROPSETID_Synth;
        ksp.Id    = KSPROPERTY_SYNTH_VOLUME;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                             sizeof(ksp),
                             (LPVOID)&lVolume,
                             sizeof(lVolume),
                             &cb);
        pControl->Release();
    }

    // Possibly return S_FALSE if port initialization was not able to get all paramters
    //    
    return hrInit;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | SetDirectSound | Sets the default DirectSound for
// audio output.
//
// @comm
//
// This method must be called once and only once per instance of DirectMusic. The specified DirectSound
// will be the default used for rendering audio on all ports. This default can be overridden using
// the <om IDirectMusicPort::SetDirectSound> method.
//
// @rdesc Returns one of the following
// @flag S_OK | On success
// @flag E_POINTER | If pguidPort does not point to valid memory
//
STDMETHODIMP CDirectMusic::SetDirectSound(
    LPDIRECTSOUND pDirectSound,             // @parm Points to the DirectSound interface to use.
                                            // If this parameter is NULL, then SetDirectSound will
                                            // create a DirectSound to use. If a DirectSound interface
                                            // is provided, then the caller is responsible for 
                                            // managing the DirectSound cooperative level.
    HWND hwnd)                              // @parm If <p pDirectSound> is NULL, then this parameter
                                            // will be used as the hwnd for DirectSound focus managment.
                                            // If the parameter is NULL, then the current foreground
                                            // window will be set as the focus window.
{
    V_INAME(IDirectMusic::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
#ifndef XBOX
    V_HWND_OPT(hwnd);
#endif // ! XBOX

    if (m_cRefDirectSound)
    {
        return DMUS_E_DSOUND_ALREADY_SET;
    }

    m_fDirectSound = 1;

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
    }

    if (pDirectSound)
    {
        pDirectSound->AddRef();       
    }
     
    m_pDirectSound = pDirectSound;

    m_hWnd = hwnd;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// SetExternalMasterClock
//
// Let the caller specify their own IReferenceClock, overriding the default
// system one.
//
STDMETHODIMP CDirectMusic::SetExternalMasterClock(
    IReferenceClock *pClock)
{
    V_INAME(IDirectMusic::SetEsternalMasterClock);
    V_INTERFACE(pClock);
#ifdef DXAPI
    return m_pMasterClock->SetMasterClock(pClock);
#else
    if (m_pMasterClock) 
    {
        m_pMasterClock->Release();
    }
    m_pMasterClock = pClock;
    if (pClock)
    {
        pClock->AddRef();
    }
    return S_OK;
#endif
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | GetDefaultPort | Get the default output port
//
// @comm
//
// The IDirectMusic::GetDefaultPort method is used to determine what what port will be created if 
// GUID_DMUS_DefaultPort is passed to <om IDirectMusic::CreatePort>. 
//
// If the port specified in the registry does not
// exist, then the default output port will be the Microsoft Software Synthesizer. Otherwise,
// the port specified by the last call to SetDefaultPort will be returned. This setting is
// persistent across sessions.
//
// @rdesc Returns one of the following
// @flag S_OK | On success
// @flag E_POINTER | If pguidPort does not point to valid memory
//
STDMETHODIMP CDirectMusic::GetDefaultPort(
    LPGUID pguidPort)        // @parm Points to a GUID which will contain the default port GUID on success
{
    V_INAME(IDirectMusic::GetDefaultPort);
    V_PTR_WRITE(pguidPort, GUID);

    GetDefaultPortI(pguidPort);
    return S_OK;
}   

// @method:(INTERNAL) HRESULT | CDirectMusic | GetDefaultPortI | Internal implementation of
// <om IDirectMusic::GetDefaultPort>.
//
// Internal implementation without parameter validation so <om IDirectMusic::CreatePort> can 
// share the same code.
//
// This function cannot fail; it will just return CLSID_DirectMusicSynth on any error.
//
void CDirectMusic::GetDefaultPortI(
    GUID *pguidPort)
{
    CNode<PORTENTRY *> *pNode;
    BOOL fGotKernelSynth;


    // If they used a cached GUID w/o calling EnumPort first, make sure we have
    // the list of ports up to date.
    //
    if (!m_lstDevices.GetListHead())
    {
        UpdatePortList();
    }

    // If hardware acceleration is disabled, revert to 6.1 behavior -
    // just use our UM software synth
    //
    // If we have DX8, we must have an audio path synth. Since we have no
    // HW acceleration yet, this means forcing our SW Synth.
    //
    if (m_fDisableHWAcceleration || (m_nVersion >= 8))
    {
        *pguidPort = CLSID_DirectMusicSynth;
        return;
    }

    fGotKernelSynth = FALSE;
    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data->fPrefDev && 
            (pNode->data->pc.dwFlags & DMUS_PC_DLS))
        {
            *pguidPort = pNode->data->pc.guidPort;
            return;
        }

        if (pNode->data->pc.guidPort == GUID_WDMSynth && 
            m_fDefaultToKernelSwSynth)
        {
           fGotKernelSynth = TRUE;
        }
    }

    *pguidPort = fGotKernelSynth ? GUID_WDMSynth : CLSID_DirectMusicSynth;
}    

// @method:(EXTERNAL) HRESULT | IDirectMusic | Activate |
// Activates or deactivates all output ports created from this interface.
//
// @comm
//
// The IDirectMusic::Activate method tells DirectMusic when the ports
// allocated by the application should be enabled or disabled.
// Applications should call Activate(FALSE) when they lose input focus
// if they do not need to play music in the background.  This will allow
// another application that may have the input focus to have access to
// these port resources.  Once the application has input focus again, it
// should call Activate(TRUE) to enable all of its allocated ports.
// When the DirectMusic object is first created, its default state is
// set to active.  The state of any ports created with
// <om IDirectMusic::CreatePort> will reflect the current state of the
// DirectMusic object.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully
//
STDMETHODIMP
CDirectMusic::Activate(
    BOOL fActivate)                 // @parm Informs DirectMusic whether the allocated ports should be activated or deactivated.
                                    // @flag TRUE | Activate all port objects created with this instance of DirectMusic.
                                    // @flag FALSE | Deactivate all of the port objects created with this instance of DirectMusic.

{
	CNode<IDirectMusicPort*> *pNode;
	HRESULT hr = S_OK;
	HRESULT hrFirst = S_OK;

    for (pNode = m_lstOpenPorts.GetListHead(); pNode; pNode = pNode->pNext)
    {
		hr = pNode->data->Activate(fActivate);

		//record the first failure
		if (FAILED(hr) & SUCCEEDED(hrFirst))
		{
		    hrFirst = hr;
		}
		
    }

    //if we are a post 7 version we'll return the hr of the 
    //first failure.  If there were no failurs than we will
    //return S_OK.  Pre 7 versions, we'll return S_OK always.
    if (m_nVersion >= 8)
        return hrFirst;
    else
        return S_OK;
}
   

STDMETHODIMP
CDirectMusic::NotifyFinalRelease(
    IDirectMusicPort *pPort)
{
    CNode<IDirectMusicPort *> *pNode;
    
    TraceI(2, "CDirectMusic::NotifyFinalRelease\n");

    for (pNode = m_lstOpenPorts.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data == pPort)
        {
            // NOTE: We DON'T Release here, because the matching Release to the port create AddRef
            // was the application Release which caused the port to turn around and call THIS function.
            //
            m_lstOpenPorts.RemoveNodeFromList(pNode);
            
            // If the last port just went away and DirectMusic was held open
            // by the ports, delete it
            //
            if (m_lstOpenPorts.GetNodeCount() == 0 && m_cRef == 0)
            {
                delete this;
            }

            return S_OK;
        }
    }

    TraceI(0, "CDirectMusic::NotifyFinalRelease(%p) - port not in list!", pPort);
    return E_INVALIDARG;
}




// @method:(EXTERNAL) HRESULT | IDirectMusic | EnumMasterClock | Enumerates the possible time sources for DirectMusic.
//
// @comm
//
// The IDirectMusic::EnumMasterClock method is used to enumerate and get
// the description of the clocks that DirectMusic can use as the master
// clock.  Each time it is called, this method retrieves information
// about a single clock.  Applications should not rely or store the
// index number of a clock.  Rebooting, as well as adding and removing
// hardware could cause the index number of a clock to change.  
//
// The master clock is a high-resolution timer that is shared by all
// processes, devices, and applications that are using DirectMusic. The
// clock is used to synchronize all music playback in the system.  It is
// a standard <i IReferenceClock> that stores time as a 64-bit integer in
// increments of 100 nanoseconds. The <om IReferenceClock::GetTime> method
// returns the current time. The master clock must derive from a
// continuously running hardware source, usually the system crystal, but
// optionally a crystal on a hardware I/O device, for example the
// crystal used by a wave card for audio playback. All DirectMusic ports
// synchronize to this master clock.
//
// This sample code shows how to use this method. Similar code can be used to wrap
// the <om IDirectMusic::EnumPorts> method.
//
// DWORD idx;
// HRESULT hr;
// DMUS_CLOCKCAPS dmcc;
//
// for (;;)
// {
//     hr = pDirectMusic->EnumMasterClock(idx, &dmcc);
//     if (FAILED(hr))
//     {
//         // Something went wrong
//         break;
//     }
//
//     if (hr == S_FALSE)
//     {
//         // End of enumeration
//         break;
//     }
//
//     // Use dmcc
// }
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully
// @flag S_FALSE | Invalid index number
// @flag E_POINTER | If the pClockInfo pointer is invalid
// @flag E_INVALIDARG | If the <p lpClockInfo> struct is not the correct size
//
STDMETHODIMP    
CDirectMusic::EnumMasterClock(
    DWORD           dwIndex,              // @parm Specifies the index of the clock for which the description is
                                        // to be returned.  This parameter should be zero on the first call
                                        // and then incremented by one in each subsequent call until S_FALSE is returned.  
    LPDMUS_CLOCKINFO lpClockInfo)        // @parm Pointer to the <c DMUS_CLOCKINFO> structure to receive the description of the clock.
{
#ifdef DXAPI
    DWORD dwVer;

    V_INAME(IDirectMusic::EnumMasterClock);

    V_STRUCTPTR_READ_VER(lpClockInfo, dwVer);
    V_STRUCTPTR_READ_VER_CASE(DMUS_CLOCKINFO, 7);
    V_STRUCTPTR_READ_VER_CASE(DMUS_CLOCKINFO, 8);
    V_STRUCTPTR_READ_VER_END(DMUS_CLOCKINFO, lpClockInfo);

    return m_pMasterClock->EnumMasterClock(dwIndex, lpClockInfo, dwVer);
#else
    return S_FALSE;
#endif
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | GetMasterClock | Returns the GUID of and an <i IReferenceClock> interface to the current master clock.
//
// @comm
//
// The IDirectMusic::GetMasterClock method returns the GUID and/or the
// address of the <i IReferenceClock> interface pointer for the clock that
// is currently set as the DirectMusic master clock.  If a null pointer
// is passed for either of the pointer parameters below, this method
// assumes that that pointer value is not desired.  The <i IReferenceClock>
// interface pointer must be released once the application has finished
// using the interface.  See <om IDirectMusic::EnumMasterClock> for more
// information about the master clock.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If either pointer was invalid
//
STDMETHODIMP
CDirectMusic::GetMasterClock(
    LPGUID pguidClock,               // @parm Pointer to the memory to be filled in with the master clock's GUID.
    IReferenceClock **ppClock)      // @parm Address of the <i IReferenceClock> interface pointer for this clock.
{
#ifdef DXAPI
    V_INAME(IDirectMusic::GetMasterClock);
    V_PTR_WRITE_OPT(pguidClock, GUID);
    V_PTRPTR_WRITE_OPT(ppClock);

    return m_pMasterClock->GetMasterClock(pguidClock, ppClock);
#else
    if (m_pMasterClock)
    {
        m_pMasterClock->AddRef();
    }
    *ppClock = m_pMasterClock;
    return S_OK;
#endif
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | SetMasterClock | Sets the global DirectMusic master clock.
//
// @comm
//
// The IDirectMusic::SetMasterClock sets the DirectMusic master clock to
// a specific clock based on a given GUID obtained through the
// <om IDirectMusic::EnumMasterClock> call.  There is only one master clock
// for all DirectMusic applications.  If another running application is
// also using DirectMusic, it will not be possible to change the master
// clock until that application is shut down.  See
// <om IDirectMusic::EnumMasterClock> for more information about the master
// clock.
//
// Most applications will not need to call SetMasterClock. It should not be called
// unless there is a compelling reason, such as a need to have very tight synchornization
// with a hardware timebase other than the system clock.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.  
//
STDMETHODIMP
CDirectMusic::SetMasterClock(
    REFGUID rguidClock)     // @parm Reference to (C++) or address of (C) the GUID that identifies the clock to
                            // set as the master clock for DirectMusic.  This parameter must be a GUID returned
                            // by <om IDirectMusic::EnumMasterClock>.
{
#ifdef DXAPI
    V_INAME(IDirectMusic::SetMasterClock);
    V_REFGUID(rguidClock);
    return m_pMasterClock->SetMasterClock(rguidClock);
#else
    return E_NOTIMPL;
#endif

}

HRESULT CDirectMusic::GetDirectSoundI(
    LPDIRECTSOUND *ppDirectSound)
{
    if (InterlockedIncrement(&m_cRefDirectSound) == 1)
    {
        m_fCreatedDirectSound = FALSE;

        // If one is already created or given to us, use it
        //
        if (m_pDirectSound == NULL)
        {
            // No interface yet, create it
            //
            LPDIRECTSOUND8 pds = NULL;
            HRESULT hr = DirectSoundCreate8(NULL,
                                           &pds,
                                           NULL);
            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: CreateDirectSound failed! %08X\n", hr);
                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }

#ifndef XBOX
            hr = pds->QueryInterface(IID_IDirectSound, (void**)&m_pDirectSound);
            pds->Release();
            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: CreateDirectSound failed! %08X\n", hr);
                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }
            HWND hWnd = m_hWnd;
            if (!hWnd)
            {
                hWnd = GetForegroundWindow();

                if (!hWnd)
                {
                    hWnd = GetDesktopWindow();
                }
            }

            assert(hWnd);

            hr = m_pDirectSound->SetCooperativeLevel(
                hWnd,
                DSSCL_PRIORITY);

            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: SetCooperativeLevel (DSCCL_PRIORITY) failed!\n");
                m_pDirectSound->Release();
                m_pDirectSound = NULL;

                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }          

#else // XBOX
			m_pDirectSound = pds;
			hr = S_OK;
#endif // XBOX
            m_fCreatedDirectSound = TRUE;
        }
    }

    m_pDirectSound->AddRef();
    *ppDirectSound = m_pDirectSound;

    return S_OK;
}

void CDirectMusic::ReleaseDirectSoundI()
{
    if (m_pDirectSound == NULL) 
    {
        // Hitting this assert means a port released one too many times
        //
        assert(m_pDirectSound);
        return;
    }

    // Release reference held by port
    //
    m_pDirectSound->Release();
    
    if (InterlockedDecrement(&m_cRefDirectSound) == 0 && m_fCreatedDirectSound)
    {
        // This was the last reference. If we created the DirectSound, release it
        //
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
}

// CDirectMusic::GetPortByGUID
//
PORTENTRY *CDirectMusic::GetPortByGUID(GUID guid)
{
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pPort;

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pPort = pNode->data;

        if (pPort->pc.guidPort == guid)
        {
            return pPort;         
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmvoice.cpp ===
//
// dmvoice.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
//

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include "debug.h"
#include "dmusicp.h"
#include "validate.h"
#include "dmvoice.h"
#include "dswave.h"

// Class global: next available voice ID
//
DWORD CDirectMusicVoice::m_dwNextVoiceId = 1;

// Class global Voice Service Thread 
//
LONG CDirectMusicVoice::m_cRefVST           = 0;
#ifdef DXAPI
HANDLE CDirectMusicVoice::m_hVSTWakeUp      = (HANDLE)NULL;
HANDLE CDirectMusicVoice::m_hVSTThread      = (HANDLE)NULL;
DWORD CDirectMusicVoice::m_dwVSTThreadId    = 0;
bool CDirectMusicVoice::m_fVSTStopping      = false;
DWORD WINAPI VoiceServiceThreadThk(LPVOID lpParameter);
#else
extern CBossMan g_BossMan;
CWorker *CDirectMusicVoice::m_pVoiceWorker = NULL;
void WINAPI _VoiceService(LPVOID lpParam,REFERENCE_TIME *prtWakeUp);
#endif
CVSTClientList CDirectMusicVoice::m_ClientList;
CRITICAL_SECTION CDirectMusicVoice::m_csVST; 


//#############################################################################
//
// CDirectMusicVoice
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::QueryInterface
//
//
STDMETHODIMP CDirectMusicVoice::QueryInterface(
    const IID &iid,
    void **ppv) 
{
    V_INAME(IDirectMusicVoice::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicVoiceP)
    {
        *ppv = static_cast<IDirectMusicVoiceP*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusicVoice::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusicVoice::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::CDirectMusicVoice
//
//
CDirectMusicVoice::CDirectMusicVoice(
    CDirectMusicPortDownload *pPortDL,
    IDirectSoundDownloadedWaveP *pWave,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtReadAhead,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd) :
    m_cRef(1)
{
    assert(pPortDL);
    assert(pWave);

    HRESULT hr = pPortDL->QueryInterface(IID_IDirectMusicPort, (void**)&m_pPort);
    assert(SUCCEEDED(hr));
    
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    m_nChannels         = pDSWave->GetNumChannels();
    m_dwVoiceId         = AllocVoiceId(m_nChannels);
    m_pPortDL           = pPortDL;
    m_pDSDLWave         = pWave;
    m_dwChannel         = dwChannel;
    m_dwChannelGroup    = dwChannelGroup;
    m_stStart           = pDSWave->RefToSampleTime(rtStart);
    m_stReadAhead       = pDSWave->RefToSampleTime(rtReadAhead);
    m_stLoopStart       = stLoopStart;
    m_stLoopEnd         = stLoopEnd;


    // HACKHACK make sure we fit into streaming buffers
    //
    SAMPLE_TIME stStream = pDSWave->GetStreamSize();
    
    if (stStream < 4 * m_stReadAhead)
    {
        m_stReadAhead = stStream / 4;
    }

    // rtReadAhead must fit in 32-bits worth of milliseconds (49 days)
    //
    m_msReadAhead       = (DWORD)(rtReadAhead / (10 * 1000));

    m_pDSWD             = NULL;

    //m_pPort->AddRef();
    m_pDSDLWave->AddRef();

    m_pPortPrivate      = NULL;

    m_fIsPlaying        = false;
    m_fIsStreaming      = pDSWave->IsStreaming();

    if (m_fIsStreaming)
    {
        m_stLoopStart = 0;
        m_stLoopEnd = 0;
    }
}
        
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Init
//
//
HRESULT CDirectMusicVoice::Init()
{
    HRESULT hr = S_OK;

    CDirectSoundWave *pDSWave = (CDirectSoundWave*)m_pDSDLWave;

    m_fRunning = false; // Have not started running yet.
    if (m_fIsStreaming)
    {
        TraceI(2, "Voice doing streaming init\n");
        m_pDSWD = new CDirectSoundWaveDownload(
            static_cast<CDirectSoundWave*>(m_pDSDLWave),
            m_pPortDL,
            m_stStart,
            m_stReadAhead);
        
        hr = HRFromP(m_pDSWD);

        if (SUCCEEDED(hr))
        {
            // We download only the required wave data
            // So set the start time to 0
            m_stStart = 0;
            hr = m_pDSWD->Init();
        }

        if (SUCCEEDED(hr))
        {
             hr = m_pDSWD->Download();
        }

        if (SUCCEEDED(hr))
        {
            m_dwDLId = m_pDSWD->GetDLId();
        }
    }
    else
    {   
        // One-shot case
        //
        m_dwDLId = pDSWave->GetDLId();
        TraceI(2, "Got download ID %d from pDSWave %d\n", m_dwDLId);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pPort->QueryInterface(
            IID_IDirectMusicPortPrivate, 
            (void**)&m_pPortPrivate);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::~CDirectMusicVoice
//
//
CDirectMusicVoice::~CDirectMusicVoice()
{
    if(m_pDSWD)
    {
        // Voice is going away so unload the downloaded wave
        m_pDSWD->Unload();
        delete m_pDSWD;
    }

    RELEASE(m_pPortPrivate);
    RELEASE(m_pPort);
    RELEASE(m_pDSDLWave);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Play
//
//
STDMETHODIMP CDirectMusicVoice::Play(
    REFERENCE_TIME rtStart,
    LONG prPitch,
    LONG vrVolume)
{
    HRESULT                 hr = S_OK;
    CVSTClient             *pClient = FindClientByPort(m_pPort);

    TraceI(2, "Starting voice %d [%p] using DLID %d\n", m_dwVoiceId, this, m_dwDLId);

//    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(m_pDSDLWave);

    //Check that FindClientByPort returned a clinet
    if (pClient == NULL)
    {
    	hr = E_FAIL;
    	return hr;
    }

    if (m_fIsStreaming)
    {
        EnterCriticalSection(&m_csVST);
    
        if (m_fIsPlaying) 
        {
            // XXX Error code
            //
            hr = E_INVALIDARG;
        }            
        else
        {
            // Add this voice to the proper client list.
            // This will cause the thread to be kicked to update
            // its wakeup interval.
            //
            if (pClient == NULL) 
            {
                TraceI(0, "Play: Port voice is to be played on has disappeared!\n");
                hr = E_FAIL;
            }                                    
            else
            {
                pClient->AddTail(this);
                hr = pClient->BuildVoiceIdList();
                if (FAILED(hr))
                {
                    pClient->Remove(this);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        UpdateVoiceServiceThread();

        DWORD i;

        for (i = 0; SUCCEEDED(hr) && i < m_nChannels; i++) 
        {
            // Voice ID's and wave articulation download ID's are 
            // allocated sequentially, one per channel
            //
            hr = m_pPortPrivate->StartVoice(
                m_dwVoiceId + i,
                m_dwChannel,
                m_dwChannelGroup,
                rtStart,
                m_dwDLId + i,
                prPitch,
                vrVolume,
                m_stStart,
                m_stLoopStart,
                m_stLoopEnd);
        }
        if (FAILED(hr))
        {
            for (i = 0; i < m_nChannels; i++) 
            {
                m_pPortPrivate->StopVoice(
                    m_dwVoiceId + i,
                    rtStart + 1);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // NOTE: We should still be in the critical section whenever this
        // is changed since the VST will change it as well.
        //
        m_fIsPlaying = true;
    }

    if (m_fIsStreaming)
    {
        if (FAILED(hr))
        {
            pClient->Remove(this);
        }

        LeaveCriticalSection(&m_csVST);
    }

    return hr;
}
    
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Stop
//
//
STDMETHODIMP CDirectMusicVoice::Stop(
    REFERENCE_TIME rtStop)
{
    HRESULT                 hr = S_OK;

    if (m_fIsStreaming)
    {
        EnterCriticalSection(&m_csVST);
    
        if (!m_fIsPlaying)
        {
            // XXX Error code
            //
            hr = E_INVALIDARG;
        }
        else
        {
            CVSTClient *pClient = FindClientByPort(m_pPort);
            if (pClient == NULL) 
            {
                TraceI(0, "Play: Port voice is to be stopped on has disappeared!\n");
                hr = E_FAIL;
            }                                    
            else
            {
                pClient->Remove(this);
                pClient->BuildVoiceIdList();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        UpdateVoiceServiceThread();

        DWORD i;

        for (i = 0; i < m_nChannels; i++)
        {
            HRESULT hrTemp;

            hrTemp = m_pPortPrivate->StopVoice(
                m_dwVoiceId + i,
                rtStop);

            if (FAILED(hrTemp))
            {
                hr = hrTemp;
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // NOTE: We should still be in the critical section whenever this
        // is changed since the VST will change it as well.
        //
        m_fIsPlaying = false;
    }

    if (m_fIsStreaming)
    {
        LeaveCriticalSection(&m_csVST);
    }

    return hr;                
}

#ifdef DXAPI
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::VoiceServiceThread
//
//
DWORD WINAPI VoiceServiceThreadThk(LPVOID lpParameter)
{
    CDirectMusicVoice::VoiceServiceThread();
    return 0;
}

void CDirectMusicVoice::VoiceServiceThread()
{
    DWORD                   dwTimeout = 500;    // Force it to recalculate the timeout after 500ms.
    DWORD                   dwWFSO;
    bool                    fService;
    bool                    fRecalcTimeout;

    for(;;)
    {
        dwWFSO = WaitForSingleObject(m_hVSTWakeUp, dwTimeout);
        if (m_fVSTStopping) 
        {
            break;
        }

        fService = false;
        fRecalcTimeout = false;
        switch(dwWFSO)
        {
            // If the timeout was hit, it's time to service voices.
            //
            case WAIT_TIMEOUT:
                fService = true;
                break;
        
            // If the event was triggered, we've received a request to 
            // either die (m_fVSTStopping will be set) or the voice list
            // changed, so we're supposed to recalculate the wakeup time.
            //
            case WAIT_OBJECT_0:
                if (!m_fVSTStopping) 
                {
                    fRecalcTimeout = true;  // Need to recalculate time out.
                    fService = true;        // Make sure any buffer refilling that
                                            // needs to be done is taken care of.
                }
                break;

            // These two should never happen.
            //            
            case WAIT_FAILED:
                TraceI(1, "VST: WaitForSingleObject failed %d; rewaiting.\n",
                    GetLastError());
                continue;
                
            default:
                TraceI(0, "VST: WaitForSingleObject: Unexpected return %d\n", 
                    dwWFSO);                
                continue;
        }

        EnterCriticalSection(&m_csVST);
        
        if (fService)
        {
            // If voices stop, then we should recalc the timeout.
            //
            ServiceVoiceQueue(&fRecalcTimeout);
        }                        

        if (fRecalcTimeout)
        {
            dwTimeout = (VoiceQueueMinReadahead() / 2);
        }
        LeaveCriticalSection(&m_csVST);
    }
}
#else
static void WINAPI _VoiceService(LPVOID lpParam,REFERENCE_TIME *prtWakeUp)
{
    bool fRecalcTimeout;
    EnterCriticalSection(&CDirectMusicVoice::m_csVST);
    CDirectMusicVoice::ServiceVoiceQueue(&fRecalcTimeout);
    LeaveCriticalSection(&CDirectMusicVoice::m_csVST);
}

#endif
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::StartVoiceServiceThread
//
//
HRESULT CDirectMusicVoice::StartVoiceServiceThread(
    IDirectMusicPort *pPort)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwError;
    CVSTClient              *pClient = NULL;
    bool                    fShutdownOnFail = false;
    
    EnterCriticalSection(&m_csVST);

    pClient = new CVSTClient(pPort);
    hr = HRFromP(pClient);

    if (SUCCEEDED(hr) && ++m_cRefVST == 1) 
    {
        // This is the first time a port has requested the service thread,
        // so start it for real.
        //
#ifdef DXAPI
        fShutdownOnFail = true;

        m_hVSTWakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hVSTWakeUp == (HANDLE)NULL)
        {
            dwError = GetLastError();
            TraceI(0, "VoiceServiceThread: CreateEvent failed %d\n", dwError);

            hr = WIN32ERRORtoHRESULT(dwError);
        }

        m_fVSTStopping = false;
        if (SUCCEEDED(hr))
        {
            m_hVSTThread = CreateThread(
                NULL,               // Attributes
                0,                  // Stack size
                ::VoiceServiceThreadThk,
                0,
                0,                  // Flags
                &m_dwVSTThreadId);
            if (m_hVSTThread == (HANDLE)NULL)
            {
                dwError = GetLastError();
                TraceI(0, "VoiceServiceThread: CreateThread failed %d\n", dwError);

                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
        }
#else
        m_pVoiceWorker = g_BossMan.InstallWorker(_VoiceService,NULL,15,"DM Worker: Streamed Wave IO (MilsPerSecond)");
#endif
    }

    if (SUCCEEDED(hr))
    {
        m_ClientList.AddTail(pClient);        
    }
#ifdef DXAPI
    if (FAILED(hr))
    {
        if (fShutdownOnFail)
        {
            if (m_hVSTWakeUp) 
            {
                CloseHandle(m_hVSTWakeUp);
                m_hVSTWakeUp = NULL;
            }

            assert(!m_hVSTThread);
        
            m_cRefVST = 0;        
        }

        delete pClient;
    }
#endif
    LeaveCriticalSection(&m_csVST);
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::StopVoiceServiceThread
//
//
HRESULT CDirectMusicVoice::StopVoiceServiceThread(IDirectMusicPort *pPort)
{
    HRESULT                 hr = S_OK;

    EnterCriticalSection(&m_csVST);

    CVSTClient *pClient = FindClientByPort(pPort);

    if (pClient == NULL) 
    {
        TraceI(0, "Port %p tried to stop the voice service thread without starting it\n", pPort);
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        // XXX Clean up still playing voices 
        //
        m_ClientList.Remove(pClient);
        delete pClient;
    }

    if (SUCCEEDED(hr) && --m_cRefVST == 0)
    {
#ifdef DXAPI
        // Last user is releasing. Try to shut down the thread.
        //
        assert(m_hVSTWakeUp);
        assert(m_hVSTThread);

        TraceI(2, "Killing Voice Service Thread\n");
        m_fVSTStopping = true;
        SetEvent(m_hVSTWakeUp);

        if (WaitForSingleObject(m_hVSTThread, 5000) == WAIT_TIMEOUT)
        {
            TraceI(0, "Voice Service Thread refused to die!\n");
        }   

        CloseHandle(m_hVSTWakeUp);
        CloseHandle(m_hVSTThread);
#else
        if (m_pVoiceWorker)
        {
            m_pVoiceWorker->PinkSlip();
            m_pVoiceWorker = NULL;
        }
#endif
    }

    LeaveCriticalSection(&m_csVST);
    return hr;
}



////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::ServiceVoiceQueue
//
// Called from VoiceServiceThread() to walk the queue and see which voices
// need servicing. Assumes caller has the voice service critical section.
//
//
void CDirectMusicVoice::ServiceVoiceQueue(bool *pfRecalcTimeout)
{
    HRESULT                 hr;
    DMUS_VOICE_STATE       *psp;
    CDirectMusicVoice      *pVoice;

    for (CVSTClient *pClient = m_ClientList.GetHead(); pClient; pClient = pClient->GetNext()) 
    {
        hr = pClient->GetVoiceState(&psp);
        if (FAILED(hr))
        {
            continue;
        }

        // The DMUS_VOICE_STATE array returned by GetVoicePosition lines up
        // with the order of voices in the CVSTClient's voice list
        //
        bool fClientVoiceListChanged = false;

        for (pVoice = pClient->GetVoiceListHead();
             pVoice;
             pVoice = pVoice->GetNext(), psp++)
        {
#ifdef DBG
            pClient->DebugCheckId(pVoice->m_dwVoiceId, psp);
#endif
            if (psp->bExists)
            {
                hr = pVoice->m_pDSWD->RefreshThroughSample(psp->spPosition);
                if (FAILED(hr))
                {
                    TraceI(0, "VST: RefreshThroughSample failed %08X\n", hr);
                    continue;
                }
                pVoice->m_fRunning = true; // Now that we've started writing data, 
                                           // psp->bExists failing will safely mean synth terminated it,
                                           // as opposed to not started yet.
            }
            
            // S_FALSE indicates that the end of data has been reached
            // on this voice. Also kill it if the synth has terminated
            // it.
            //
            if (hr == S_FALSE || (!psp->bExists && pVoice->m_fRunning))
            {
                pVoice->Stop(0);
                pVoice->m_fIsPlaying = false;
                fClientVoiceListChanged = true;
            }
        }

        // If anything changed in this client's voice list,
        // update it now.
        //
        if (!fClientVoiceListChanged)
        {
            continue;
        }

        // Something's changed, recalc the wakeup time before going
        // back to sleep
        //
        *pfRecalcTimeout = true;

        // Yank out the voices which have completed.
        //
        for (pVoice = pClient->GetVoiceListHead(); pVoice; )
        {
            // Voice is still playing, do nothing
            //
            if (pVoice->m_fIsPlaying)
            {
                pVoice = pVoice->GetNext();
                continue;
            }

            // Just finished, remove from list
            //
            CDirectMusicVoice *pNext = pVoice->GetNext();
            pClient->Remove(pVoice);
            pVoice = pNext;
        }

        // This call cannot fail because the only way it can is to run out of
        // memory, and memory allocation is not done when the list shrinks.
        //
        pClient->BuildVoiceIdList();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::VoiceQueueMinReadahead
//
// Called from VoiceServiceThread() to walk the queue and determine the
// minimum readahead in milliseconds. Assumes caller has the voice service
// critical section.
//
DWORD CDirectMusicVoice::VoiceQueueMinReadahead()
{
    DWORD                   dwMin = INFINITE;
    for (CVSTClient *pClient = m_ClientList.GetHead(); pClient; pClient = pClient->GetNext()) 
    {
        for (CDirectMusicVoice *pVoice = pClient->GetVoiceListHead(); pVoice; pVoice = pVoice->GetNext())
        {
            dwMin = min(dwMin, pVoice->m_msReadAhead);            
        }
    }

    return dwMin;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::FindClientByPort
//
// Given a port pointer, find the matching CVSTClient if there is one.
//
CVSTClient *CDirectMusicVoice::FindClientByPort(IDirectMusicPort *pPort)
{
    CVSTClient *pCurr = m_ClientList.GetHead();

    while (pCurr)
    {
		IDirectMusicPort *pCurrPort = pCurr->GetPort();

        if (pCurrPort == pPort)
        {   
            break;
        }

        pCurr = pCurr->GetNext();
    }

    return pCurr;
}

//#############################################################################
//
// CVSTClient
//
//#############################################################################

const UINT CVSTClient::m_cAllocSize = 32;

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::CVSTClient
//
//
CVSTClient::CVSTClient(IDirectMusicPort *pPort)
{
    m_pPort = pPort;

    m_pdwVoiceIds = NULL;
    m_pspVoices   = NULL;
    m_cVoiceIdsAlloc = 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::~CVSTClient
//
//
CVSTClient::~CVSTClient()
{
    delete[] m_pdwVoiceIds;
    delete[] m_pspVoices;
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::BuildVoiceIdList
//
// Build the voice ID array, and make sure it and the sample position array 
// are big enough for all voices. These arrays are used to call into the
// synth to figure out how far each voice has rendered.
//
// The caller must have taken the voice service thread critical section.
//
// This method guarantees that on failure, the existing list will not be
// touched.
//
HRESULT CVSTClient::BuildVoiceIdList()
{
    // To minimize allocations, the arrays are allocated in chunks and never
    // shrink. (The amount of memory here is extremely small... 12 bytes per 
    // voice).
    //
    if (m_VoiceList.GetCount() > m_cVoiceIdsAlloc)
    {
        LONG cNewAlloc = ((m_VoiceList.GetCount() / m_cAllocSize) + 1) * m_cAllocSize;

        DWORD *pdw = new DWORD[cNewAlloc];
        DMUS_VOICE_STATE *psp = new DMUS_VOICE_STATE[cNewAlloc];

        // Check allocation
        if (pdw == NULL || psp == NULL) 
        {
        	delete[] pdw;
        	delete[] psp;
            return E_OUTOFMEMORY;
        }

        memset(pdw, 0, cNewAlloc * sizeof(DWORD));
        memset(psp, 0, cNewAlloc * sizeof(SAMPLE_POSITION));

        m_cVoiceIdsAlloc = cNewAlloc;

        delete[] m_pdwVoiceIds;
        delete[] m_pspVoices;
        
        m_pdwVoiceIds = pdw;
        m_pspVoices = psp;
    }

    // We know there's enough space now. Walk the voice list and
    // fill in the voice Id's.
    //
    // This assumes that the list order will not change and that 
    // the array is kept in sync with the list.
    //
    DWORD *pdwIds = m_pdwVoiceIds;

    CDirectMusicVoice *pVoice = GetVoiceListHead();
    for (; pVoice; pVoice = pVoice->GetNext())
    {
        *pdwIds++ = pVoice->GetVoiceId();
    }

    m_cVoiceIds = m_VoiceList.GetCount();

    return S_OK;  
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::GetVoiceState
//
// Wraps the port GetVoiceState call with the voice list the CVSTClient 
// maintains.
//
HRESULT CVSTClient::GetVoiceState(DMUS_VOICE_STATE **ppsp)
{
    HRESULT                 hr;
    IDirectMusicPortPrivate *pPrivate;

    if (m_pdwVoiceIds)
    {

        hr = m_pPort->QueryInterface(IID_IDirectMusicPortPrivate, (void**)&pPrivate);

        if (SUCCEEDED(hr))
        {
            hr = pPrivate->GetVoiceState(
                m_pdwVoiceIds,
                m_cVoiceIds,
                m_pspVoices);
            pPrivate->Release();
        }

        if (SUCCEEDED(hr))
        {
            *ppsp = m_pspVoices;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmwavobj.cpp ===
//
// dmwaveobj.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "debug.h"
#include "dlsstrm.h"
#include <mmreg.h>
#include <msacm.h>
#include "debug.h"
#include "dmcollec.h"
#include "dmcrchk.h"
#include "dmwavobj.h"
#include "dmportdl.h"

#ifdef XBOX
#define NO_COMPRESSION_SUPPORT
#define IGNORE_ACM(wFormatTag) ((wFormatTag == WAVE_FORMAT_PCM) || (wFormatTag == WAVE_FORMAT_XBOX_ADPCM)) 
#else
#define IGNORE_ACM(wFormatTag) (wFormatTag == WAVE_FORMAT_PCM) 
#endif // XBOX
#define USE_ACM(format) (!IGNORE_ACM(format))

//////////////////////////////////////////////////////////////////////
// Class CWaveObj
 
//////////////////////////////////////////////////////////////////////
// CWaveObj::CWaveObj

CWaveObj::CWaveObj() :
m_pExtractWaveFormatData(NULL),
m_dwDataOffset(0),
m_dwDataSizeWrite(0),
m_dwDataSizeRead(0),
m_dwId(0),
m_pParent(NULL),
m_cbSizeOffsetTable(0),
#ifdef DXAPI
m_pCopyright(NULL),
m_dwCountExtChk(0),
#endif
m_dwSize(0),
m_fCSInitialized(FALSE),
m_fReadDecompressionFormat(FALSE)
#ifdef DBG
,
m_bLoaded(false)
#endif
{
	InitializeCriticalSection(&m_DMWaveCriticalSection);
    m_fCSInitialized = TRUE;
	ZeroMemory(&m_WaveFormatRead, sizeof(m_WaveFormatRead));
	ZeroMemory(&m_WaveFormatWrite, sizeof(m_WaveFormatWrite));
}

//////////////////////////////////////////////////////////////////////
// CWavebj::~CWavebj

CWaveObj::~CWaveObj()
{
    if (m_fCSInitialized)
    {
    	Cleanup();
	    DeleteCriticalSection(&m_DMWaveCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Load

HRESULT CWaveObj::Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent)
{
	// Argument validation
	assert(pParent);

#ifdef DBG
	if(dwId >= CDirectMusicPortDownload::sNextDLId)
	{
		assert(FALSE);
	}
#endif

	m_dwId = dwId;
	m_pParent = pParent;
	m_pParent->AddRef();

	HRESULT hr = S_OK;
	
	RIFFIO ck;
	EnterCriticalSection(&m_DMWaveCriticalSection);
	
    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
		switch(ck.ckid)
		{
			case mmioFOURCC('w','a','v','u') :
			{
				// Read the flag which indiactes Runtime or Designtime File
				bool bTemp = false;;
				hr = pParser->Read(&bTemp, sizeof(bool));
				if(SUCCEEDED(hr))
				{
					// Read the flag that indicates compression
					hr = pParser->Read(&bTemp, sizeof(bool));
					if(SUCCEEDED(hr))
					{
						// this is a compressed wave file
						if(bTemp == true)
						{
							hr = pParser->Read(&m_WaveFormatDecompress, sizeof(WAVEFORMATEX));

							if(FAILED(hr))
							{
								hr = E_FAIL;
								m_fReadDecompressionFormat = FALSE;
							}
							else
							{
								m_WaveFormatDecompress.nAvgBytesPerSec = m_WaveFormatDecompress.nSamplesPerSec * m_WaveFormatDecompress.nBlockAlign;
								m_fReadDecompressionFormat = TRUE;
							}
						}
					}
				}

				break;
			}
#ifdef DXAPI
			case FOURCC_LIST :
				switch(ck.fccType)
				{
                case mmioFOURCC('I','N','F','O') :
					m_pCopyright = new CCopyright;
					if(m_pCopyright)
					{
						hr = m_pCopyright->Load(pParser);
						if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0)
						{
							delete m_pCopyright;
							m_pCopyright = NULL;
						}
					}
					else
					{
						hr =  E_OUTOFMEMORY;
					}
					break;
				default :
					// If we get here we have an unknown chunk
					CExtensionChunk* pExtensionChunk = new CExtensionChunk;
					if(pExtensionChunk)
					{
						hr = pExtensionChunk->Load(pParser);
						m_ExtensionChunkList.AddHead(pExtensionChunk);
						m_dwCountExtChk++;
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
					break;
                }
				break;
#endif
			case mmioFOURCC('f','m','t',' ') :
				hr = pParser->Read(&m_WaveFormatRead, sizeof(WAVEFORMATEX));
				if(SUCCEEDED(hr))
				{
					if(USE_ACM(m_WaveFormatRead.wFormatTag))
					{
#ifdef NO_COMPRESSION_SUPPORT
						hr = E_FAIL;
#else  // NO_COMPRESSION_SUPPORT
                        if(m_WaveFormatRead.cbSize)
                        {
							m_pExtractWaveFormatData = new BYTE[m_WaveFormatRead.cbSize];
							if(m_pExtractWaveFormatData)
							{
								hr = pParser->Read(m_pExtractWaveFormatData, m_WaveFormatRead.cbSize);
							}
                        }
						if(SUCCEEDED(hr))
                        {
							hr = CanDecompress();
                        }
#endif // NO_COMPRESSION_SUPPORT
					}
					else
					{
						// If WAVE_FORMAT_PCM this member should be zero
						m_WaveFormatRead.cbSize = 0;
						CopyMemory(&m_WaveFormatWrite, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
					}
				}
				break;
			case mmioFOURCC('d','a','t','a') :
                pParser->MarkPosition();
				m_dwDataOffset = (DWORD) ck.liPosition.QuadPart;
				m_dwDataSizeRead = ck.cksize;
				hr = m_pParent->ValidateOffset(m_dwDataOffset + m_dwDataSizeRead);
				break;

			default :
#ifdef DXAPI
				// If we get here we have an unknown chunk
				CExtensionChunk* pExtensionChunk = new CExtensionChunk;
				if(pExtensionChunk)
				{
					hr = pExtensionChunk->Load(pParser);
					m_ExtensionChunkList.AddHead(pExtensionChunk);
					m_dwCountExtChk++;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
#endif
				break;
            }
	}
    pParser->LeaveList();
	
#ifdef DBG
	if(SUCCEEDED(hr))
	{
		m_bLoaded = true;
	}
#endif

	if(FAILED(hr))
	{
		Cleanup();
	}
	
	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Cleanup

void CWaveObj::Cleanup()
{
	EnterCriticalSection(&m_DMWaveCriticalSection);

	delete [] m_pExtractWaveFormatData;
	m_pExtractWaveFormatData = NULL;
#ifdef DXAPI
	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		delete pExtChk;
	}
	delete m_pCopyright;
	m_pCopyright = NULL;
#endif
	
	if(m_pParent)
	{
		m_pParent->Release();
		m_pParent = NULL;
	}

#ifdef DBG
	m_bLoaded = false;
#endif
	
	LeaveCriticalSection(&m_DMWaveCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Size
#ifdef DXAPI
HRESULT CWaveObj::Size(DWORD* pdwSize,DWORD *pdwSampleSize)
{
	// Assumption validation
#ifdef DBG
	assert(m_bLoaded);
#endif
 	assert(pdwSize);

	// If have already calculated the size we do not need to do it again
	if(m_dwSize)
	{
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
		return S_OK;
	}
	
	HRESULT hr = S_OK;
	
	DWORD dwTotalSize = 0;
	DWORD dwOffsetCount = 0;
	DWORD dwCountExtChk = 0;

	EnterCriticalSection(&m_DMWaveCriticalSection);

	// Calculate the space needed for DMUS_DOWNLOADINFO 
	dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	// Calculate the space needed for Wave's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwTotalSize += pExtChk->Size();
		dwOffsetCount += pExtChk->Count();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk == dwCountExtChk)
    {
		// Calculate the space needed for wave's copyright
		if(m_pCopyright)
		{
			dwTotalSize += m_pCopyright->Size();
			dwOffsetCount += m_pCopyright->Count();
		}
		// If wave does not have one use collection's
		else if(m_pParent && m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
		{
			dwTotalSize += (m_pParent->m_pCopyright)->Size();
			dwOffsetCount += (m_pParent->m_pCopyright)->Count();
		}
		// Calculate space needed for WAVE and WAVEDATA
		dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_WAVE)) + 
			CHUNK_ALIGN(sizeof(DMUS_WAVEDATA));
		dwOffsetCount += 2;

		// Calculate space needed for offset table
		m_cbSizeOffsetTable = dwOffsetCount * sizeof(ULONG);
		dwTotalSize += m_cbSizeOffsetTable;

		// Calculate space needed for wave data
		// We allocated DMUS_MIN_DATA_SIZE worth when we allocated for DMUS_WAVEDATA
		m_dwDataSizeWrite = m_dwDataSizeRead;
		
		if(USE_ACM(m_WaveFormatRead.wFormatTag))
		{
#ifdef NO_COMPRESSION_SUPPORT
			hr = E_FAIL;
#else  // NO_COMPRESSION_SUPPORT
			hr = CalcDataSize(&m_dwDataSizeWrite);
#endif // NO_COMPRESSION_SUPPORT
		}
		
		
		if(SUCCEEDED(hr) && m_dwDataSizeWrite > DMUS_MIN_DATA_SIZE)
		{
			dwTotalSize += (m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE);		
		}
		dwTotalSize = CHUNK_ALIGN(dwTotalSize);
	}
	else
	{
		hr = E_FAIL;
	}
	
	// If everything went well, we have the size
	if(SUCCEEDED(hr))
	{
		m_dwSize = dwTotalSize;
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
	}

	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}
#else
HRESULT CWaveObj::Size(DWORD* pdwSize,DWORD *pdwSampleSize)
{
	// Assumption validation
#ifdef DBG
	assert(m_bLoaded);
#endif
 	assert(pdwSize);

	// If have already calculated the size we do not need to do it again
	if(m_dwSize)
	{
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
		return S_OK;
	}
	
	HRESULT hr = S_OK;
	
	DWORD dwTotalSize = 0;
	DWORD dwOffsetCount = 0;

	EnterCriticalSection(&m_DMWaveCriticalSection);

	// Calculate the space needed for DMUS_DOWNLOADINFO 
	dwTotalSize = CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	// Calculate the space needed for Wave's extension chunks
    {
		// Calculate space needed for WAVE and WAVEDATA
		dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_WAVE)) + 
			CHUNK_ALIGN(sizeof(DMUS_WAVEDATA));
		dwOffsetCount += 2;

		// Calculate space needed for offset table
		m_cbSizeOffsetTable = dwOffsetCount * sizeof(ULONG);
		dwTotalSize += m_cbSizeOffsetTable;

		// Calculate space needed for wave data
		// We allocated DMUS_MIN_DATA_SIZE worth when we allocated for DMUS_WAVEDATA
		m_dwDataSizeWrite = m_dwDataSizeRead;
		
		if(USE_ACM(m_WaveFormatRead.wFormatTag))
		{
#ifdef NO_COMPRESSION_SUPPORT
			hr = E_FAIL;
#else  // NO_COMPRESSION_SUPPORT
			hr = CalcDataSize(&m_dwDataSizeWrite);
#endif // NO_COMPRESSION_SUPPORT
		}
		
		
		if(SUCCEEDED(hr) && m_dwDataSizeWrite > DMUS_MIN_DATA_SIZE)
		{
			dwTotalSize += (m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE);		
		}
		dwTotalSize = CHUNK_ALIGN(dwTotalSize);
	}
	
	// If everything went well, we have the size
	if(SUCCEEDED(hr))
	{
		m_dwSize = dwTotalSize;
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
	}

	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}
#endif

//////////////////////////////////////////////////////////////////////
// CWaveObj::Write

HRESULT CWaveObj::Write(void* pvoid)
{
	// Assumption and argument validation
#ifdef DBG
	assert(m_bLoaded);
#endif

	assert(pvoid);

	DWORD dwSize;
	DWORD dwSampleSize;

	HRESULT hr = Size(&dwSize,&dwSampleSize);
	
	if(FAILED(hr))
	{       
		return hr;
	}

	EnterCriticalSection(&m_DMWaveCriticalSection);

	DWORD dwCurIndex = 0;   // Used to determine what index to store offset in Offset Table
	DWORD dwCurOffset = 0;  // Offset relative to beginning of passed in memory

	// Write DMUS_DOWNLOADINFO
	DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
	pDLInfo->dwDLType = DMUS_DOWNLOADINFO_WAVE;
	pDLInfo->dwDLId = m_dwId;
	pDLInfo->dwNumOffsetTableEntries = (m_cbSizeOffsetTable/sizeof(DWORD));
	pDLInfo->cbSize = dwSize;
	
	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);
	
	// Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(m_cbSizeOffsetTable);

	// First entry in ulOffsetTable is the first data chunk - the DMUS_WAVE in this case.
	pDMOffsetTable->ulOffsetTable[0] = dwCurOffset;

	dwCurIndex = 2;		// First two items are DMUS_WAVE and DMUS_WAVEDATA;

	DMUS_WAVE* pDMWave = (DMUS_WAVE*)(((BYTE*)pvoid) + dwCurOffset);
	pDMWave->ulWaveDataIdx = 1;		// Point to the DMUS_WAVEDATA chunk.

	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_WAVE));

	DMUS_WAVEDATA* pDMWaveData = (DMUS_WAVEDATA*)(((BYTE*)pvoid) + dwCurOffset);
	pDMOffsetTable->ulOffsetTable[1] = dwCurOffset;
	
	DWORD dwPos = 0;
	DWORD dwRead = 0;
	
	m_dwDataSizeAfterACM = m_dwDataSizeWrite;
	hr = GetData(pDMWaveData->byData, m_dwDataSizeWrite, &dwPos, &dwRead);

	pDMWaveData->cbSize = m_dwDataSizeAfterACM; 
	
	if(SUCCEEDED(hr))
	{
		if(m_dwDataSizeWrite < DMUS_MIN_DATA_SIZE)
		{
			dwCurOffset += sizeof(DMUS_WAVEDATA);
		}
		else
		{
			dwCurOffset += sizeof(DMUS_WAVEDATA) + m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE;
		}
		dwCurOffset = CHUNK_ALIGN(dwCurOffset);

		CopyMemory(&(pDMWave->WaveformatEx), &m_WaveFormatWrite, sizeof(WAVEFORMATEX));	

#ifdef DXAPI
		// Write extension chunks
		CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
		if(pExtChk)
		{
			pDMWave->ulFirstExtCkIdx = dwCurIndex;
		}
		else
		{
			// If no extension chunks set to zero
			pDMWave->ulFirstExtCkIdx = 0;
		}

		DWORD dwCountExtChk = m_dwCountExtChk;
		DWORD dwIndexNextExtChk = 0;
		
		for(; pExtChk && SUCCEEDED(hr); pExtChk = pExtChk->GetNext())
		{
		
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = dwCurIndex + 1;
			}
			
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			hr = pExtChk->Write(((BYTE *)pvoid + dwCurOffset), 
								&dwCurOffset,
								dwIndexNextExtChk);
			
			dwCountExtChk--;
			dwCurIndex++;
		}
#endif
    }
#ifdef DXAPI
	if(SUCCEEDED(hr))
	{
		// Write copyright information
		if(m_pCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			hr = m_pCopyright->Write(((BYTE *)pvoid + dwCurOffset),
									 &dwCurOffset);
			dwCurIndex++;
		}
		// If instrument does not have one use collection's
		else if(m_pParent && m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			hr = (m_pParent->m_pCopyright)->Write(((BYTE *)pvoid + dwCurOffset), 
												  &dwCurOffset);
			dwCurIndex++;
		}
		else
		{
			pDMWave->ulCopyrightIdx = 0;
		}
	}
	if(FAILED(hr))
	{
		ZeroMemory(pvoid, dwSize);
	}
#endif
	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::GetData

HRESULT CWaveObj::GetData(BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif

	if(*pdwPos > (m_dwDataOffset + m_dwDataSizeWrite))
	{
		return DMUS_E_INVALIDPOS;
	}

    assert(m_pParent);

	IStream* pStream = m_pParent->m_pStream;

	// Validation
	assert(pStream);
	
	HRESULT hr = S_OK;

	LARGE_INTEGER li;
	li.QuadPart = m_dwDataOffset + *pdwPos;
	hr = pStream->Seek(li, STREAM_SEEK_SET,NULL);
	if(SUCCEEDED(hr))
	{
		if(IGNORE_ACM(m_WaveFormatRead.wFormatTag))
		{
			hr = ReadData(pStream, pbBuffer, dwSize, pdwPos, pdwRead);
		}
		else
		{
#ifdef NO_COMPRESSION_SUPPORT
			hr = E_FAIL;
#else  // NO_COMPRESSION_SUPPORT
			hr = ReadCompressedData(pStream, pbBuffer, dwSize, pdwPos, pdwRead);
#endif // NO_COMPRESSION_SUPPORT
		}
	}
	return hr;
}

#ifndef NO_COMPRESSION_SUPPORT


//////////////////////////////////////////////////////////////////////
// CWaveObj::ReadCompressedData

HRESULT CWaveObj::ReadCompressedData(IStream* pStream, BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);
	assert(pStream);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif
	HRESULT hr = E_FAIL;

	DWORD dwRead = 0;

	DWORD dwLeftToRead = m_dwDataSizeRead - *pdwPos;

	DWORD dwToRead  = dwLeftToRead < dwSize ? dwLeftToRead : dwSize;

	BYTE *pbCompressedBuffer = new  BYTE[dwToRead];
	
	if(pbCompressedBuffer == NULL)
	{
		return hr;
	}
	
	hr = pStream->Read(pbCompressedBuffer, dwToRead, &dwRead);
	
	DWORD temp = m_dwDataSizeWrite;
	
	if(SUCCEEDED(hr))
	{
		WAVEFORMATEX* pwfx = NULL;
		if(m_WaveFormatRead.wFormatTag == MSAUDIO_FORMAT_TAG || m_WaveFormatRead.wFormatTag == WMAUDIO_FORMAT_TAG)
		{
			if(FAILED(hr = AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
			{
				delete[] pbCompressedBuffer;
				return hr;
			}
		}
		else
		{
			pwfx = (WAVEFORMATEX*) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];
			if(pwfx == NULL)
			{
				delete[] pbCompressedBuffer;
				return E_OUTOFMEMORY;
			}
		
			CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
			if(m_pExtractWaveFormatData)
			{
				CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
			}
		}

		assert(pwfx);

		hr = DecompressWave(pwfx, 
							&m_WaveFormatWrite, 
							pbCompressedBuffer,
							pbBuffer,
							dwToRead, 
							temp);

		if(SUCCEEDED(hr))
		{
			*pdwPos += dwRead;
		}

		if(pdwRead)
		{
			if(SUCCEEDED(hr))
			{
				*pdwRead = dwRead;
			}
			else
			{
				*pdwRead = 0;
			}
		}

		if(pwfx)
		{
			delete[] pwfx;
		}
	}
	else
	{
		if(pdwRead)
		{
			*pdwRead = 0;
		}
	}

	delete[] pbCompressedBuffer;

	return hr;
}

#endif // ! NO_COMPRESSION_SUPPORT

//////////////////////////////////////////////////////////////////////
// CWaveObj::ReadData

HRESULT CWaveObj::ReadData(IStream* pStream, BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);
	assert(pStream);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif

	HRESULT hr = E_FAIL;

	DWORD dwRead = 0;

	DWORD dwLeftToRead = m_dwDataSizeRead - *pdwPos;

	DWORD dwToRead  = dwLeftToRead < dwSize ? dwLeftToRead : dwSize;

	hr = pStream->Read(pbBuffer, dwToRead, &dwRead);

	if(SUCCEEDED(hr))
	{
		if(pdwRead)
		{
			*pdwRead = dwRead;
		}

		*pdwPos += dwRead;
	}
	else
	{
		if(pdwRead)
		{
			*pdwRead = 0;
		}
	}

	return hr;
}


#ifndef NO_COMPRESSION_SUPPORT

//////////////////////////////////////////////////////////////////////
// CWaveObj::CalcDataSize

HRESULT CWaveObj::CalcDataSize(DWORD *pdwSize)
{
	assert(pdwSize);

    WAVEFORMATEX *pwfx = NULL;
    if(m_WaveFormatRead.wFormatTag == MSAUDIO_FORMAT_TAG || m_WaveFormatRead.wFormatTag == WMAUDIO_FORMAT_TAG)
	{
		if(FAILED(AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
		{
			return E_FAIL;
		}
	}
    else
    {
	    pwfx = (WAVEFORMATEX *) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];

	    if(pwfx == NULL)
	    {
		    *pdwSize = 0;		
		    return E_FAIL;
	    }
	    
	    CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
	    if(m_pExtractWaveFormatData)
	    {
		    CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
	    }
    }

    assert(pwfx);

	HACMSTREAM has;
	MMRESULT mmr = acmStreamOpen(&has, NULL, pwfx, &m_WaveFormatWrite, NULL, 0, 0, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		*pdwSize = 0;
		delete [] (BYTE *)pwfx;
		return E_FAIL;	
	}

	mmr = acmStreamSize(has, m_dwDataSizeRead, pdwSize, ACM_STREAMSIZEF_SOURCE);

	if(mmr != MMSYSERR_NOERROR || *pdwSize == 0)
	{
		*pdwSize = 0;
		acmStreamClose(has, 0);
		delete [] (BYTE *)pwfx;
		return E_FAIL;	
	}

	mmr = acmStreamClose(has, 0);

	if(mmr != MMSYSERR_NOERROR)
	{
		*pdwSize = 0;
		delete [] (BYTE *)pwfx;
		return E_FAIL;
	}

	delete [] (BYTE *)pwfx;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::CanDecompress

HRESULT CWaveObj::CanDecompress()
{
	HRESULT hr = E_FAIL;

	ZeroMemory(&m_WaveFormatWrite, sizeof(m_WaveFormatWrite));
	m_WaveFormatWrite.wFormatTag = WAVE_FORMAT_PCM;
	m_WaveFormatWrite.nChannels = 1;
	m_WaveFormatWrite.wBitsPerSample = 16;

	WAVEFORMATEX* pwfx = NULL; 
	
	if(SUCCEEDED(hr = AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
	{
		pwfx = (WAVEFORMATEX *) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];
		if(pwfx == NULL)
		{
			return E_OUTOFMEMORY;
		}
		
		CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
		if(m_pExtractWaveFormatData)
		{
			CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
		}
	}
	else
	{
	    pwfx = &m_WaveFormatRead;
	}

	assert(pwfx);

	if(m_fReadDecompressionFormat == TRUE)
    {
        CopyMemory(&m_WaveFormatWrite, &m_WaveFormatDecompress, sizeof(m_WaveFormatDecompress));
        hr = S_OK;
    }
    else
    {
		// We first try to find a driver that can support wBitsPerSample == 16 if we can not find one 
		// then we try to find a driver that can support wBitsPerSample == 8. If we do not find either we 
		// return an error since we can not decompress.
		MMRESULT mmr = acmFormatSuggest(NULL,
										pwfx,
										&m_WaveFormatWrite,
										sizeof(WAVEFORMATEX),
										ACM_FORMATSUGGESTF_NCHANNELS 
										| ACM_FORMATSUGGESTF_WBITSPERSAMPLE 
										| ACM_FORMATSUGGESTF_WFORMATTAG);


		if(mmr != MMSYSERR_NOERROR)
		{
			m_WaveFormatWrite.wBitsPerSample = 8;
			
			MMRESULT mmr = acmFormatSuggest(NULL,
											pwfx,
											&m_WaveFormatWrite,
											sizeof(WAVEFORMATEX),
											ACM_FORMATSUGGESTF_NCHANNELS 
											| ACM_FORMATSUGGESTF_WBITSPERSAMPLE 
											| ACM_FORMATSUGGESTF_WFORMATTAG);
		}

		if(mmr == MMSYSERR_NOERROR) 
		{
			hr = S_OK;
		}
	}

	if (pwfx && pwfx != &m_WaveFormatRead)
	{
		delete[] (BYTE*)pwfx;
	}

	return hr; 
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::DecompressWave

HRESULT CWaveObj::DecompressWave(WAVEFORMATEX *pwfxSrc, 
								 WAVEFORMATEX *pwfxDst, 
								 BYTE *pbCompressedBuffer,
								 BYTE *pbDecompressBuffer,
								 DWORD dwSizeCompressed, 
								 DWORD dwSizeDecompressed)
{
	// We're just fooling the compressor!
    WORD wOriginalSampleRate = (WORD)pwfxDst->nSamplesPerSec;
    if(pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
    {
        pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
        pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec * pwfxDst->nBlockAlign;
    }

	HACMSTREAM has;
	MMRESULT mmr = acmStreamOpen(&has, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		return E_FAIL;	
	}

	ACMSTREAMHEADER ashdr;
	ZeroMemory(&ashdr, sizeof(ashdr));
	ashdr.cbStruct = sizeof(ashdr);
	ashdr.pbSrc = pbCompressedBuffer;
	ashdr.cbSrcLength = dwSizeCompressed;
	ashdr.cbDstLength = dwSizeDecompressed;
	ashdr.pbDst = pbDecompressBuffer;
	
	mmr = acmStreamPrepareHeader(has, &ashdr, 0);
	
	if(mmr != MMSYSERR_NOERROR || (ashdr.fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED) == 0)
	{
		acmStreamClose(has, 0);
		return E_FAIL;	
	}

	mmr = acmStreamConvert(has, &ashdr, 0);

	DWORD dwTemp = ashdr.cbDstLength;
    m_dwDataSizeAfterACM = ashdr.cbDstLengthUsed;

	// Need to reset or acmStreamUnprepareHeader will return with an error
	ashdr.cbSrcLength = dwSizeCompressed;
	ashdr.cbDstLength = dwSizeDecompressed;

	if(mmr != MMSYSERR_NOERROR)
	{
		acmStreamUnprepareHeader(has, &ashdr, 0);
		acmStreamClose(has, 0);
		return E_FAIL;	
	}

	mmr = acmStreamUnprepareHeader(has, &ashdr, 0);
	if(mmr != MMSYSERR_NOERROR)
	{
		acmStreamClose(has, 0);		
		return E_FAIL;	
	}
	
	m_dwDataSizeWrite = dwTemp;

	mmr = acmStreamClose(has, 0);

	return mmr == MMSYSERR_NOERROR ? S_OK : E_FAIL;
}



HRESULT CWaveObj::AllocWMAudioFormat(const WAVEFORMATEX* pwfxSrc, WAVEFORMATEX** ppwfxWMAudioWave)
{
	assert(pwfxSrc);
	if(pwfxSrc == NULL)
	{
		return E_POINTER;
	}

	if(pwfxSrc->wFormatTag != 352 && pwfxSrc->wFormatTag != 353)
	{
		return E_FAIL;
	}

	// The new WAVEFORMATEX growsby the length of the key strings
	int nKeyLength = sizeof(MSAUDIO_DEC_KEY);
	DWORD nWaveFormatSize = sizeof(WAVEFORMATEX) + pwfxSrc->cbSize + nKeyLength;

	WAVEFORMATEX* pwfxTemp = (WAVEFORMATEX*)(new BYTE[nWaveFormatSize]);
    if(pwfxTemp == NULL)
    {
        return E_OUTOFMEMORY;
    }
	
	ZeroMemory(pwfxTemp, nWaveFormatSize);

	// Copy the old values
	CopyMemory(pwfxTemp, pwfxSrc, sizeof(WAVEFORMATEX));
	CopyMemory((((BYTE*)pwfxTemp) + sizeof(WAVEFORMATEX)), m_pExtractWaveFormatData, pwfxSrc->cbSize); 

	// Copy the key string 
	strcpy((char*)(pwfxTemp) + sizeof(WAVEFORMATEX) + pwfxTemp->cbSize, MSAUDIO_DEC_KEY);
	pwfxTemp->cbSize += sizeof(MSAUDIO_DEC_KEY);

	*ppwfxWMAudioWave = pwfxTemp;

	return S_OK;
}

#endif // ! NO_COMPRESSION_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dsutil.cpp ===
//
// dsutil.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Note: Utility routines for DirectSound
//
// @doc EXTERNAL
//
//

// Be careful what headers get included here. We have to make sure we get
// the DSound IKsPropertySet definition rather than the incorrect Ks one.
//

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#include <objbase.h>
#endif // XBOX

#include <initguid.h>       // Bring in guids from dsprv.h
#include <mmsystem.h>
#include <dsound.h>
#include <dsprv.h>

class CDirectSoundPrivate
{
public:
    CDirectSoundPrivate();
    ~CDirectSoundPrivate();
    HRESULT Init();

    // IKsPropertySet methods
    //
    HRESULT Get(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG);
    HRESULT Set(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
    HRESULT QuerySupport(REFGUID, ULONG, PULONG);

private:
    HINSTANCE m_hDSound;
    IKsPropertySet *m_pKsPropertySet;
};

CDirectSoundPrivate::CDirectSoundPrivate()
{
    m_hDSound = NULL;
    m_pKsPropertySet = NULL;
}

typedef HRESULT (*PDLLGETCLASSOBJECT)(const CLSID &clsid, const IID &iid, void **ppv);
HRESULT CDirectSoundPrivate::Init()
{
    PDLLGETCLASSOBJECT pDllGetClassObject;
    IClassFactory *pClassFactory;
    HRESULT hr;

    m_hDSound = LoadLibrary("dsound.dll");
    if (m_hDSound == NULL)
    {
        return E_NOINTERFACE;
    }

    pDllGetClassObject = (PDLLGETCLASSOBJECT)GetProcAddress(m_hDSound, "DllGetClassObject");
    if (pDllGetClassObject == NULL)
    {
        return E_NOINTERFACE;
    }

    hr = (*pDllGetClassObject)(CLSID_DirectSoundPrivate, 
                               IID_IClassFactory,
                               (void**)&pClassFactory);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    hr = pClassFactory->CreateInstance(NULL, IID_IKsPropertySet, (void**)&m_pKsPropertySet);
    pClassFactory->Release();

    return hr;
}

CDirectSoundPrivate::~CDirectSoundPrivate()
{
    if (m_pKsPropertySet) {
        m_pKsPropertySet->Release();
        m_pKsPropertySet = NULL;
    }

    if (m_hDSound) 
    {
        FreeLibrary(m_hDSound);
        m_hDSound = NULL;
    }
}

HRESULT CDirectSoundPrivate::Get(REFGUID rguidSet, ULONG ulItem, LPVOID pvInstance, ULONG cbInstance, LPVOID pvData, ULONG cbData, PULONG pcbData)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->Get(rguidSet, ulItem, pvInstance, cbInstance, pvData, cbData, pcbData);
    }

    return E_NOINTERFACE;
}

HRESULT CDirectSoundPrivate::Set(REFGUID rguidSet, ULONG ulItem, LPVOID pvInstance, ULONG cbInstance, LPVOID pvData, ULONG cbData)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->Set(rguidSet, ulItem, pvInstance, cbInstance, pvData, cbData);
    }

    return E_NOINTERFACE;
}

HRESULT CDirectSoundPrivate::QuerySupport(REFGUID rguidSet, ULONG ulItem, PULONG pulSupport)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->QuerySupport(rguidSet, ulItem, pulSupport);
    }

    return E_NOINTERFACE;
}


// DirectSoundDevice
//
// Given an LPDIRECTSOUND, determine the device interface name associated with
// it.
//
HRESULT DirectSoundDevice(
    LPDIRECTSOUND                                   pDirectSound,
    LPSTR                                           *pstrInterface)
{
    HRESULT                                         hr;
    DSBUFFERDESC                                    BufferDesc;
    LPDIRECTSOUNDBUFFER                             pBuffer = NULL;
    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA      DeviceId;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   DeviceDesc;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   *pDeviceDesc;
    ULONG                                           cb;
	PCMWAVEFORMAT                                   wfx;

    CDirectSoundPrivate                             DSPriv;
    
    hr = DSPriv.Init();

    if (FAILED(hr)) 
    {
        return hr;
    }


	ZeroMemory(&wfx, sizeof(wfx));
	wfx.wf.wFormatTag = WAVE_FORMAT_PCM;
	wfx.wf.nChannels = 1;
	wfx.wf.nSamplesPerSec = 22050;
	wfx.wf.nAvgBytesPerSec = 22050;
	wfx.wf.nBlockAlign = 1;
	wfx.wBitsPerSample = 8;

    ZeroMemory(&BufferDesc, sizeof(BufferDesc));
    BufferDesc.dwSize  = sizeof(BufferDesc);
    BufferDesc.dwBufferBytes = 32768;
    BufferDesc.lpwfxFormat = (LPWAVEFORMATEX)&wfx;
    
    hr = pDirectSound->CreateSoundBuffer(&BufferDesc, &pBuffer, NULL);
    if (FAILED(hr)) 
    {
        pBuffer = NULL;
        goto Cleanup;
    }
    
    DeviceId.Buffer = pBuffer;
    hr = DSPriv.Get(DSPROPSETID_DirectSoundBuffer,
                    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID,
                    NULL,
                    0,
                    &DeviceId,
                    sizeof(DeviceId),
                    &cb);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    memset(&DeviceDesc, 0, sizeof(DeviceDesc));
    DeviceDesc.DeviceId = DeviceId.DeviceId;
    hr = DSPriv.Get(DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                    NULL,
                    0,
                    &DeviceDesc,
                    sizeof(DeviceDesc),
                    &cb);
    if (FAILED(hr)) 
    {
        goto Cleanup;
    } 

	pDeviceDesc = &DeviceDesc;
    if (cb > sizeof(DeviceDesc)) 
    {
        pDeviceDesc = (DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA*) new BYTE[cb];
        if (!pDeviceDesc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memset(pDeviceDesc, 0, cb);

        CopyMemory(pDeviceDesc, &DeviceDesc, sizeof(DeviceDesc));

        hr = DSPriv.Get(DSPROPSETID_DirectSoundDevice,
                        DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                        NULL,
                        0,
                        pDeviceDesc,
                        cb,
                        &cb);
    }

    if (pDeviceDesc->Interface == NULL)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    cb = strlen(pDeviceDesc->Interface);
    
    *pstrInterface = new char[cb + 1];
    if (!*pstrInterface)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    strcpy(*pstrInterface, pDeviceDesc->Interface);

Cleanup:
    if (pBuffer)        pBuffer->Release();
    if (pDeviceDesc && pDeviceDesc != &DeviceDesc)    
		delete[] (BYTE*)pDeviceDesc;

    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmvoice.h ===
//
// dmvoice.h
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for IDirectMusicVoice
//
//
#ifndef _DMVOICE_H_
#define _DMVOICE_H_

class CDirectMusicVoice;
class CVSTClient;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoiceList
//
// Type-safe wrapper for AList of CDirectMusicVoice's
//
class CDirectMusicVoiceList : public AList
{
public:
    inline CDirectMusicVoice *GetHead();
    inline void AddTail(CDirectMusicVoice *pdmv);
    inline void Remove(CDirectMusicVoice *pdmv);
};

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClientList
//
// Type-safe wrapper for AList of CVSTClient's
//
class CVSTClientList : public AList
{
public:
    inline CVSTClient *GetHead();
    inline void AddTail(CVSTClient *pc);
    inline void Remove(CVSTClient *pc);
};

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient
//
// Tracks one client (port) of the voice service thread.
//
class CVSTClient : public AListItem
{
public:
    // NOTE: No reference count to avoid circular count
    // Port will free its client before shutdown
    //
    CVSTClient(IDirectMusicPort *pPort);
    ~CVSTClient();
    
    HRESULT BuildVoiceIdList();
    
    HRESULT GetVoiceState(DMUS_VOICE_STATE **ppsp);
    
    inline CDirectMusicVoice *GetVoiceListHead() 
    { return static_cast<CDirectMusicVoice*>(m_VoiceList.GetHead()); }
    
    inline void AddTail(CDirectMusicVoice *pVoice);
    inline void Remove(CDirectMusicVoice *pVoice);
    
    inline IDirectMusicPort *GetPort() const 
    { return m_pPort; }
    
    inline CVSTClient *GetNext()
    { return static_cast<CVSTClient*>(AListItem::GetNext()); }
    
#ifdef DBG
    // Debug-only function used by CDirectMusicVoice::ServiceVoiceQueue to check consistency
    // of the data structures as it walks m_VoiceList and m_pspVoices.
    void DebugCheckId(DWORD dwVoiceId, DMUS_VOICE_STATE *psp)
    {
        int iVoicePos = psp - m_pspVoices;
        assert(iVoicePos >= 0 && iVoicePos < m_cVoiceIds); // psp must be inside m_pspVoices
        assert(dwVoiceId == m_pdwVoiceIds[iVoicePos]); // voice id's must match
    }
#endif
    
private:
    IDirectMusicPort       *m_pPort;            // Client pointer
    CDirectMusicVoiceList   m_VoiceList;        // List of playing voices
    DWORD                  *m_pdwVoiceIds;      // Voice IDs of this client
    DMUS_VOICE_STATE       *m_pspVoices;        // Queried sample position
    LONG                    m_cVoiceIds;        // How many voice ID's
    LONG                    m_cVoiceIdsAlloc;   // How many slots allocated
    
    static const UINT       m_cAllocSize;       // Allocation block size
};

// Base class for IDirectMusicVoice. Contains the functionality for
// being in the voice service list.
//
class CDirectMusicVoice : public IDirectMusicVoiceP, public AListItem
{
public:
   
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IDirectMusicVoice
    //
    STDMETHODIMP Play
        (THIS_
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG veVolume                          // Initial volume
        );
    
    STDMETHODIMP Stop
        (THIS_
          REFERENCE_TIME rtStop                 // When to stop
        );
    
    // Class
    //        
    CDirectMusicVoice(
        CDirectMusicPortDownload *pPortDL,
        IDirectSoundDownloadedWaveP *pWave,
        DWORD dwChannel,
        DWORD dwChannelGroup,
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtReadAhead,
        SAMPLE_TIME stLoopStart,
        SAMPLE_TIME stLoopEnd);    
    ~CDirectMusicVoice();        

    HRESULT Init();        
    
    inline DWORD GetVoiceId() const
    { return m_dwVoiceId; } 
        
    inline CDirectMusicVoice *GetNext() 
    { return static_cast<CDirectMusicVoice*>(AListItem::GetNext()); }
    
    
    static DWORD m_dwNextVoiceId;                      // Global: Next voice ID
    
    static inline DWORD AllocVoiceId(DWORD nIDs)
    {
        EnterCriticalSection(&m_csVST);
            DWORD dwID = m_dwNextVoiceId;
            m_dwNextVoiceId += nIDs;
        LeaveCriticalSection(&m_csVST);

        return dwID;
    }
    
    static HRESULT StartVoiceServiceThread(IDirectMusicPort *pPort);
    static HRESULT StopVoiceServiceThread(IDirectMusicPort *pPort);
#ifdef DXAPI
    static inline void UpdateVoiceServiceThread()
    { assert(m_hVSTWakeUp); SetEvent(m_hVSTWakeUp); }
#else
    static inline void UpdateVoiceServiceThread() { m_pVoiceWorker->WakeUp(); };
#endif

private:
    LONG                        m_cRef;             // Reference count
    DWORD                       m_dwVoiceId;        // Voice id
    DWORD                       m_dwDLId;           // Download ID to trigger
    IDirectMusicPort            *m_pPort;           // What port attached to
    CDirectMusicPortDownload    *m_pPortDL;         //  and its download
    IDirectMusicPortPrivate     *m_pPortPrivate;    //  its private interface
    IDirectSoundDownloadedWaveP *m_pDSDLWave;       // Downloaded wave
    DWORD                       m_dwChannel;        // Channel and channel group
    DWORD                       m_dwChannelGroup;   //  to play on
    SAMPLE_TIME                 m_stStart;          // Starting point
    SAMPLE_TIME                 m_stReadAhead;      // Read ahead (buffer length)
    DWORD                       m_msReadAhead;      // Read ahead in milliseconds
    SAMPLE_TIME                 m_stLoopStart;      // Loop points
    SAMPLE_TIME                 m_stLoopEnd;

    CDirectSoundWaveDownload    *m_pDSWD;           // Download instance    
    DWORD                       m_nChannels;        // Channels in wave
    bool                        m_fIsPlaying;       // Is this voice playing?       
                                                    // (streaming voices)
    bool                        m_fRunning;         // Has streamed voice started playing?
    bool                        m_fIsStreaming;     // Cached from owning wave                                                    
    
#ifdef DXAPI
    // Voice service thread
    //
    friend DWORD WINAPI VoiceServiceThreadThk(LPVOID);
    static void VoiceServiceThread();
    
    static HANDLE               m_hVSTWakeUp;       // Wake up for any reason
    static HANDLE               m_hVSTThread;       // Thread handle
    static DWORD                m_dwVSTThreadId;    //  and id                                                        
    static bool                 m_fVSTStopping;     // Time to kill the VST
#else
    static CWorker *            m_pVoiceWorker;
#endif
    static LONG                 m_cRefVST;          // Voice Service Thread 
                                                    // refcount (1 per open port)
    static CVSTClientList       m_ClientList;       // List of open ports which
                                                    //  want VST services
  

public:    
    static CRITICAL_SECTION     m_csVST;            // VST Critical section
    
    // Override GetNext list operator
    //    
    static void ServiceVoiceQueue(bool *pfRecalcTimeout);
private:
    static DWORD VoiceQueueMinReadahead();
    static CVSTClient *FindClientByPort(IDirectMusicPort *pPort);
};

inline CDirectMusicVoice *CDirectMusicVoiceList::GetHead()
{ return (CDirectMusicVoice*)AList::GetHead(); }

inline void CDirectMusicVoiceList::AddTail(CDirectMusicVoice *pdmv)
{ AList::AddTail(static_cast<AListItem*>(pdmv)); }

inline void CDirectMusicVoiceList::Remove(CDirectMusicVoice *pdmv)
{ AList::Remove(static_cast<AListItem*>(pdmv)); }

inline CVSTClient *CVSTClientList::GetHead()
{ return static_cast<CVSTClient*>(AList::GetHead()); }

inline void CVSTClientList::AddTail(CVSTClient *pc)
{ AList::AddTail(static_cast<AListItem*>(pc)); }

inline void CVSTClientList::Remove(CVSTClient *pc)
{ AList::Remove(static_cast<AListItem*>(pc)); }

inline void CVSTClient::AddTail(CDirectMusicVoice *pVoice)
{
    assert(pVoice);
    pVoice->AddRef();
    m_VoiceList.AddTail(pVoice);
}

inline void CVSTClient::Remove(CDirectMusicVoice *pVoice)
{
    assert(pVoice);
    m_VoiceList.Remove(pVoice);
    pVoice->Release();
}

#endif // _DMVOICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dswave.cpp ===
//
// dswave.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for streaming or oneshot waves from IDirectSoundWaveObject
//
//

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include "dmusicp.h"
#include "DsWave.h"
#include "dmdls.h"
#include "dls1.h"
#include "dls2.h"

#ifdef XBOX
#define IS_PCM(format) ((format->wFormatTag == WAVE_FORMAT_PCM) || (format->wFormatTag == WAVE_FORMAT_XBOX_ADPCM)) 
#else
#define IS_PCM(format) (format->wFormatTag == WAVE_FORMAT_PCM) 
#endif // XBOX

const DWORD gnRefTicksPerSecond = 10 * 1000 * 1000;

// Global list of all CDirectSoundWave objects in this process
//
CDirectSoundWaveList CDirectSoundWave::sDSWaveList;
CRITICAL_SECTION CDirectSoundWave::sDSWaveCritSect;

//#############################################################################
//
// CDirectSoundWaveDownload
// 
// This class contains all the code to maintain one downloaded instance of a
// wave object. It is abstracted away from CDirectSoundWave (which represents
// an IDirectSoundDownloadedWave to the application) because of the case
// of streaming waves. Here's how it works:
//
// In the case of a one-shot download, there is only one set of buffers (one
// per channel in the source wave) for all voices playing the wave. Each
// buffer contains one channel of data for the entire length of the source
// wave. Since there is a one-to-one mapping of a buffer set (and associated
// download ID's) with the application-requested download, this case is 
// handled by having CDirectSoundWave own one CDirectSoundWaveDownload.
//
// In the case of a streaming wave, what a download really does is to set up
// a ring of buffers that are kept full and refreshed by the voice service
// thread. There is one set of buffers (three buffer sets, each containing
// as many channels as the original source wave) per voice. Now there is a 
// one-to-one correspondence between the downloaded buffer set and the voice,
// so the CDirectSoundWaveDownload is owned by each voice object playing
// the CDirectSoundWave. 
// 
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::CDirectSoundWaveDownload
//
CDirectSoundWaveDownload::CDirectSoundWaveDownload(
    CDirectSoundWave            *pDSWave,
    CDirectMusicPortDownload    *pPortDL,
    SAMPLE_TIME                 stStart,
    SAMPLE_TIME                 stReadAhead) : CMemTrack(DMTRACK_WAVE_DOWNLOAD)
{
    m_pDSWave = pDSWave;
    m_pPortDL = pPortDL;
    
    m_ppWaveBuffer     = NULL;
	m_ppWaveBufferData = NULL;
    m_ppArtBuffer      = NULL;

    m_cDLRefCount  = 0;

    // Allocate download ID's
    //
    m_cSegments   = pDSWave->IsStreaming() ? gnDownloadBufferPerStream : 1;
    m_cWaveBuffer = m_cSegments * pDSWave->GetNumChannels();

    CDirectMusicPortDownload::GetDLIdP(&m_dwDLIdWave, m_cWaveBuffer);
    CDirectMusicPortDownload::GetDLIdP(&m_dwDLIdArt,  pDSWave->GetNumChannels());

    TraceI(2, "CDirectSoundWaveDownload: Allocating IDs: wave [%d..%d], art [%d..%d]\n",
        m_dwDLIdWave, m_dwDLIdWave + m_cWaveBuffer - 1, 
        m_dwDLIdArt, m_dwDLIdArt + pDSWave->GetNumChannels() - 1);
    
    // Cache sample positions of where to start and how long the buffers are,
    // based on whether or not this is a streaming wave.
    //
    if (pDSWave->IsStreaming())
    {
        m_stStart     = stStart;
        m_stReadAhead = stReadAhead;
        if(pDSWave->GetWaveFormat()->wFormatTag == WAVE_FORMAT_XBOX_ADPCM){
            // pDSWave->GetWaveFormat()->nBlockAlign doesn't seem to be set correctly yet.
            DWORD dwBlockAlign = 36 * pDSWave->GetWaveFormat()->nChannels;
            m_stReadAhead = m_stReadAhead / dwBlockAlign * dwBlockAlign;
        }
    }
    else
    {
        m_stStart     = 0;
        m_stReadAhead = ENTIRE_WAVE;
    }    
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::~CDirectSoundWaveDownload
//
CDirectSoundWaveDownload::~CDirectSoundWaveDownload()
{
    if (m_cDLRefCount)
    {
        TraceI(0, "CDirectSoundWaveDownload %p: Released with download count %d\n",
            this,
            m_cDLRefCount);
    }

    if (m_ppWaveBuffer) 
    {
        for (UINT idxWaveBuffer = 0; idxWaveBuffer < m_cWaveBuffer; idxWaveBuffer++)
        {
            RELEASE(m_ppWaveBuffer[idxWaveBuffer]);
        }
    
        delete[] m_ppWaveBuffer;
    }

    if (m_ppArtBuffer)
    {
        for (UINT idxArtBuffer = 0; idxArtBuffer < m_pDSWave->GetNumChannels(); idxArtBuffer++)
        {
            RELEASE(m_ppArtBuffer[idxArtBuffer]);
        }

		delete[] m_ppArtBuffer;
    }

	if(m_ppWaveBufferData)
	{
		delete[] m_ppWaveBufferData;
	}


	if(m_pWaveArt)
	{
		delete[] m_pWaveArt;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Init
//
HRESULT CDirectSoundWaveDownload::Init()
{
    HRESULT hr = S_OK;

    m_pWaveArt = new CDirectSoundWaveArt[m_pDSWave->GetNumChannels()];

    hr = HRFromP(m_pWaveArt);

    //For the time being, assume the channel and BusId is the same
    //  Works for stereo.
    DWORD dwFlags = 0;
    if (m_pDSWave->GetNumChannels() > 1) 
    {
        dwFlags = F_WAVELINK_MULTICHANNEL;
    }

    for (UINT idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
    {
        // XXX WAVEFORMATEXTENSIBLE parsing to get channel mappings should go here.
        //
        hr = m_pWaveArt[idx].Init(m_pDSWave, m_cSegments, (DWORD)idx, dwFlags);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Download
//
HRESULT CDirectSoundWaveDownload::Download()
{
    HRESULT                 hr;

    hr = DownloadWaveBuffers();

    if (SUCCEEDED(hr))
    {
        hr = DownloadWaveArt();
    }

    if (SUCCEEDED(hr))
    {
        InterlockedIncrement(&m_cDLRefCount);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Unload
//
HRESULT CDirectSoundWaveDownload::Unload()
{
    HRESULT                 hr;

    if (InterlockedDecrement(&m_cDLRefCount) != 0) 
    {
        return S_OK;
    }

    hr = UnloadWaveArt();

    if (SUCCEEDED(hr))
    {
        hr = UnloadWaveBuffers();
    }

    if (FAILED(hr))
    {
        InterlockedIncrement(&m_cDLRefCount);        
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::RefreshThroughSample
//
HRESULT CDirectSoundWaveDownload::RefreshThroughSample(SAMPLE_POSITION sp)
{
    int cBuffersLeft;
    
    // Make sample position be in terms of the stream
    //
    sp += m_stStart;

    TraceI(0, "RTS: Adjusted sp %I64d m_stWrote %I64d m_stReadAhead %I64d m_stLength %I64d\n", 
        sp, m_stWrote, m_stReadAhead, m_stLength);

    if (sp > m_stLength)
    {
        TraceI(0, "Wave is over\n");
        return S_FALSE;
    }

#ifndef XBOX
    // There seems to be an off-by-one error here, at least
    // for hardware mixing.
    // When sp == m_stReadAhead it means we've just finished
    // mixing the first buffer, and haven't yet finished
    // mixing the second buffer. By the time the "<=" test fails,
    // the hardware's already onto the third buffer.

    // I don't understand the purpose of this test in the first
    // place. It means "Don't try to queue any more buffers if
    // we have we completed mixing less than two buffers,
    // and we've already queued at least one buffer."
    //
    // This guarentees a glitch with hardware mixing, because
    // the third buffer isn't queued until the second buffer is
    // completed. So I've #ifdef'd it out.

    if(sp <= m_stReadAhead && m_stWrote >= m_stReadAhead)
    {
        TraceI(0, "\nAlready have enough data in the buffers\n");
        return S_OK;
    }
#endif

    if(m_stWrote >= m_stLength)
    {
        TraceI(0, "Entire wave already in the buffer\n");
        return S_OK;
    }

    // How many buffers left to play?
    //
    if (sp >= m_stWrote)
    {
        TraceI(0, "RTS: Glitch!\n");
        // Glitch! Play cursor has gone beyond end of read buffers.
        //
        cBuffersLeft = 0;
    }
    else
    {
        // Calculate buffers left to play, including partial buffers
        //
        cBuffersLeft = (int)((m_stWrote - sp + m_stReadAhead - 1) / m_stReadAhead);
        assert(cBuffersLeft <= (int)m_cSegments);
        TraceI(0, "RTS: %d buffers left\n", cBuffersLeft);
    }

    HRESULT hr = S_OK;
    
    int cBuffersToFill = m_cSegments - cBuffersLeft;
    TraceI(0, "RTS: %d buffers to fill\n", cBuffersToFill);

    while (0 < cBuffersToFill--) // "0 < cBuffersToFill--" is used instead of just "cBuffersToFill--" as defensive programming.  this should never happen and the assert will fire in debug, but we don't want to chance retail going into an infinite loop.
    {
#ifdef XBOX
        // We have hardware voices. Stereo waves are split into two buffers.
        // Because the hardware buffers complete independently, it's possible
        // that one buffer has finished playing, while the other buffer has not.
        // In this situation, we can't fill in either buffer. (We could fill in
        // one of the buffers, but then we'd have to store the other buffer's data
        // somewhere, and remember to fill it in later.)
        {
            DWORD nChannels = m_pDSWave->GetNumChannels();
            DWORD dwDLId = m_dwDLIdWave + m_pDSWave->GetNumChannels() * m_nNextBuffer;
            bool bAllChannelsReady = true;
            for(DWORD i = 0; i < nChannels; i++){
                if(m_pPortDL->IsReadyForData(dwDLId++) != S_OK){
                    bAllChannelsReady = false;
                    break;
                }
            }
            if(!bAllChannelsReady){
                break;
            }
        }
#endif
        TraceI(0, "Refilling buffer %d\n", m_nNextBuffer);
        hr = m_pDSWave->RefillBuffers(
            &m_ppWaveBufferData[m_nNextBuffer * m_pDSWave->GetNumChannels()],
            m_stWrote,
            m_stReadAhead,
            m_stReadAhead);

        TraceI(0, "Refill buffers returned %08X\n", hr);
            
        if (SUCCEEDED(hr))
        {
            DWORD dwDLId = m_dwDLIdWave + m_pDSWave->GetNumChannels() * m_nNextBuffer;

            for (UINT idxChannel = 0; 
                 idxChannel < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); 
                 idxChannel++, dwDLId++) 
            {
                // Need to preserve a return code of S_FALSE from RefillBuffers
                // across this call
                //
                TraceI(0, "Marking %d as valid.\n", dwDLId);
                HRESULT hrTemp = m_pPortDL->Refresh(
                    dwDLId, 
                    0);
                if (FAILED(hrTemp))
                {
                    hr = hrTemp;
                }
            }                                                                      

            if (SUCCEEDED(hr))
            {
                m_stWrote += m_stReadAhead;
                m_nNextBuffer = (m_nNextBuffer + 1) % m_cSegments;
            }
        }
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::DownloadWaveBuffers
//
HRESULT CDirectSoundWaveDownload::DownloadWaveBuffers()
{
    HRESULT                 hr = S_OK;
    bool                    fUnloadOnFail = false;
    UINT                    nChannels = m_pDSWave->GetNumChannels();
    DWORD                   dwDownloadType;

    dwDownloadType = 
        (m_pDSWave->IsStreaming()) ? 
            DMUS_DOWNLOADINFO_STREAMINGWAVE : 
            DMUS_DOWNLOADINFO_ONESHOTWAVE;

    // Allocate space to hold the buffers we're going to download
    //
    if (m_ppWaveBuffer == NULL)
    {
        m_ppWaveBuffer = new IDirectMusicDownload*[m_cWaveBuffer];
        hr = HRFromP(m_ppWaveBuffer);
        if (SUCCEEDED(hr)) 
        {
            memset(m_ppWaveBuffer, 0, m_cWaveBuffer * sizeof(IDirectMusicDownload*));

            // Cache pointers into buffers so we don't continually have to 
            // get them.
            //
            assert(!m_ppWaveBufferData);
            m_ppWaveBufferData = new LPVOID[m_cWaveBuffer];
            hr = HRFromP(m_ppWaveBufferData);
        }    
    }    

    // Figure out how much to add to each buffer
    //
    DWORD                   dwAppend;

    if (SUCCEEDED(hr))
    {    
        hr = m_pPortDL->GetCachedAppend(&dwAppend);
    }

    if (SUCCEEDED(hr))
    {
        // Retrieved value is in samples. Convert to bytes.
        //
        dwAppend *= ((m_pDSWave->GetWaveFormat()->wBitsPerSample + 7) / 8);
    }

    // Seek to the start position in the stream
    //
    if (SUCCEEDED(hr))
    {
        m_pDSWave->Seek(m_stStart);
    }

    // Make sure the buffers are all allocated
    //
    if (SUCCEEDED(hr))
    {
        DWORD cbSize;

        m_pDSWave->GetSize(m_stReadAhead, &cbSize);
        cbSize += dwAppend;

        for (UINT idxBuffer = 0; (idxBuffer < m_cWaveBuffer) && SUCCEEDED(hr); idxBuffer++) 
        {
            if (m_ppWaveBuffer[idxBuffer]) 
            {
                continue;
            }
            
            hr = m_pPortDL->AllocateBuffer(cbSize, &m_ppWaveBuffer[idxBuffer]);

            if (SUCCEEDED(hr))
            {
                DWORD cb;
                hr = m_ppWaveBuffer[idxBuffer]->GetBuffer(
                    &m_ppWaveBufferData[idxBuffer], &cb);
            }
        }
    }

    // We have all the buffers. Try to download if needed.
    //
    if (SUCCEEDED(hr))
    {
        SAMPLE_TIME             stStart = m_stStart;
        SAMPLE_TIME             stRead;
        DWORD                   dwDLId = m_dwDLIdWave;
        IDirectMusicDownload  **ppBuffers = &m_ppWaveBuffer[0];
        UINT                    idxSegment;
        UINT                    idxChannel;
        void                  **ppv = m_ppWaveBufferData;
         
        m_stLength    = m_pDSWave->GetStreamSize();
        m_stWrote     = m_stStart;
        m_nNextBuffer = 0;

        for (idxSegment = 0; 
             idxSegment < m_cSegments; 
             idxSegment++, dwDLId += nChannels, ppBuffers += nChannels, ppv += nChannels)
        {
            // Since we guarantee that if one buffer gets downloaded, all
            // get downloaded, we only need to check the first download ID
            // to see if all channels of this segment are already downloaded
            //
            IDirectMusicDownload *pBufferTemp;
            HRESULT hrTemp = m_pPortDL->GetBufferInternal(dwDLId, &pBufferTemp);
            if (SUCCEEDED(hrTemp))
            {
                TraceI(1, "Looks like buffer %d is already downloaded.", dwDLId);
                pBufferTemp->Release();
                continue;
            }

            // There is at least one buffer not downloaded, so yank back
            // everything on failure to guarantee all or nothing.
            //
            fUnloadOnFail = true; 

            // We need to download. Get the buffer pointers and fill them with
            // wave data.
            //
            if (SUCCEEDED(hr))
            {
                stRead = min(m_stLength - m_stWrote, m_stReadAhead);
				hr = m_pDSWave->Write(ppv, stStart, stRead, dwDLId, dwDownloadType);
            }

            if (SUCCEEDED(hr))
            {
                // Now try to do the actual downloads
                //
                for (idxChannel = 0; 
                     (idxChannel < nChannels) && SUCCEEDED(hr);
                     idxChannel++) 
                {
                    hr = m_pPortDL->Download(ppBuffers[idxChannel]);
                }
            }

            TraceI(2, "Downloading wave buffers with dlid %d\n", dwDLId);

            if (SUCCEEDED(hr))
            {
                stStart += stRead;
                m_stWrote += stRead;
                m_nNextBuffer = (m_nNextBuffer + 1) % m_cSegments;
            }
        }
    }

    if (FAILED(hr) && fUnloadOnFail)
    {
        UnloadWaveBuffers();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::UnloadWaveBuffers
//
HRESULT CDirectSoundWaveDownload::UnloadWaveBuffers()
{
    HRESULT                 hr = S_OK;

    if (m_ppWaveBuffer)
    {
        for (UINT idxWaveBuffer = 0; idxWaveBuffer < m_cWaveBuffer; idxWaveBuffer++)
        {
            if (m_ppWaveBuffer[idxWaveBuffer])
            {
                HRESULT hrTemp = m_pPortDL->Unload(m_ppWaveBuffer[idxWaveBuffer]);
				m_ppWaveBuffer[idxWaveBuffer]->Release();
				m_ppWaveBuffer[idxWaveBuffer] = NULL; // Since we unloaded the buffer, zero out the contents


                if (FAILED(hrTemp) && hrTemp != DMUS_E_NOT_DOWNLOADED_TO_PORT)
                {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::DownloadWaveArt
//
HRESULT CDirectSoundWaveDownload::DownloadWaveArt()
{
    HRESULT                 hr = S_OK;
    UINT                    idx;

    // First see if there are wave articulation buffers already downloaded
    //
    if (m_ppArtBuffer == NULL)
    {
        m_ppArtBuffer = new IDirectMusicDownload*[m_pDSWave->GetNumChannels()];

        hr = HRFromP(m_ppArtBuffer);

        if (SUCCEEDED(hr))
        {
            memset(m_ppArtBuffer, 0, sizeof(IDirectMusicDownload*) * m_pDSWave->GetNumChannels());

            for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
            {
                hr = m_pPortDL->AllocateBuffer(m_pWaveArt[idx].GetSize(), &m_ppArtBuffer[idx]);
            }
        }

        if (FAILED(hr))
        {
            if (m_ppArtBuffer)
            {
                for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++) 
                {
                    RELEASE(m_ppArtBuffer[idx]);
                }
                
                delete[] m_ppArtBuffer;
                m_ppArtBuffer = NULL;
            }
        }
    }

    // Make sure the buffers are all allocated
    //
    if (SUCCEEDED(hr))
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
        {
            if (m_ppArtBuffer[idx]) 
            {
                continue;
            }

            hr = m_pPortDL->AllocateBuffer(m_pWaveArt[idx].GetSize(), &m_ppArtBuffer[idx]);
        }

        if (FAILED(hr))
        {
            for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++) 
            {
                RELEASE(m_ppArtBuffer[idx]);
            }
            
            delete[] m_ppArtBuffer;
            m_ppArtBuffer = NULL;
        }
    }

    // We have all the buffers. Try to download if needed.
    //
    if (SUCCEEDED(hr))
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
        {
            IDirectMusicDownload *pBufferTemp;

            HRESULT hrTemp = m_pPortDL->GetBufferInternal(m_dwDLIdArt + idx, &pBufferTemp);
            if (SUCCEEDED(hrTemp))
            {
                pBufferTemp->Release();
            }
            else
            {
                assert(hrTemp == DMUS_E_NOT_DOWNLOADED_TO_PORT);

                LPVOID          pv;
                DWORD           cb;

                hr = m_ppArtBuffer[idx]->GetBuffer(&pv, &cb);

                if (SUCCEEDED(hr))
                {
                    m_pWaveArt[idx].Write(pv, m_dwDLIdArt + idx, m_dwDLIdWave + idx, m_dwDLIdArt);
                }

                if (SUCCEEDED(hr))
                {
                    hr = m_pPortDL->Download(m_ppArtBuffer[idx]);

                    if (FAILED(hr))
                    {
                        UnloadWaveArt();
                    }
                    else
                    {
                        TraceI(0, "Downloading wave art DLID %d\n", m_dwDLIdArt);
                    }
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::UnloadWaveArt
//
HRESULT CDirectSoundWaveDownload::UnloadWaveArt()
{
    HRESULT                     hr = S_OK;
    UINT                        idx;

    if (m_ppArtBuffer)
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++) 
        {
            if (m_ppArtBuffer[idx])
            {
                HRESULT hrTemp = m_pPortDL->Unload(m_ppArtBuffer[idx]);
                m_ppArtBuffer[idx]->Release();
                m_ppArtBuffer[idx] = NULL; // Since we unloaded the buffer, zero out the contents

                if (FAILED(hrTemp) && hrTemp != DMUS_E_NOT_DOWNLOADED_TO_PORT)
                {
                    hr = hrTemp;
                }
            }
        }
    }        

    return hr;
}

//#############################################################################
//
// CDirectSoundWave
//
// This class represents a downloaded wave object from the application's 
// perspective. It is the implementation of the IDirectSoundDownloadedWave
// object returned to the application from CDirectMusicPort::DownloadWave.
//
// The actual download mechanism will either be delegated to a 
// CDirectSoundWaveDownload object and done when the application requests 
// the download (one-shot case) or deferred until a voice is allocated on
// the wave (streaming case). See the comments for CDirectSoundWaveDownload.
// 
//#############################################################################


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::CDirectSoundWave
//
CDirectSoundWave::CDirectSoundWave(
    IDirectSoundWave *pIDSWave,
    bool fStreaming,
    REFERENCE_TIME rtReadAhead,
    bool fUseNoPreRoll,
    REFERENCE_TIME rtStartHint) :
    m_cRef(1),
    m_fStreaming(fStreaming),
    m_rtReadAhead(rtReadAhead),
    m_fUseNoPreRoll(fUseNoPreRoll),
    m_rtStartHint(rtStartHint),
    m_pDSWD(NULL),
    m_rpv(NULL),
    m_rpbPrecache(NULL),
	m_pSource(NULL)
{
    m_pIDSWave = pIDSWave;
    m_pIDSWave->AddRef();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::~CDirectSoundWave
//
CDirectSoundWave::~CDirectSoundWave()
{
    delete[] m_rpv;
    delete m_pDSWD;

    if (m_rpbPrecache)
    {
        // NOTE: Memory is allocated into first array element and the other
        // elements just point at offsets into the block, so only free
        // the first element.
        //
        delete[] m_rpbPrecache[0];
        delete[] m_rpbPrecache;
        m_rpbPrecache = NULL;
    }

    if (m_pwfex)
    {
        BYTE *pb = (BYTE*)m_pwfex;
        delete[] pb;
        m_pwfex = NULL;
    }


    RELEASE(m_pSource);
    RELEASE(m_pIDSWave);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::QueryInterface
//
STDMETHODIMP CDirectSoundWave::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(IDirectSoundWave::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundDownloadedWaveP)
    {
        *ppv = static_cast<IDirectSoundDownloadedWaveP*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::AddRef
//
STDMETHODIMP_(ULONG) CDirectSoundWave::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Release
//
STDMETHODIMP_(ULONG) CDirectSoundWave::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        EnterCriticalSection(&sDSWaveCritSect);
        sDSWaveList.Remove(this);
        LeaveCriticalSection(&sDSWaveCritSect);

        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::GetMatchingDSWave
//
// See if there's an object yet matching this IDirectSoundWave
//
CDirectSoundWave *CDirectSoundWave::GetMatchingDSWave(
    IDirectSoundWave *pIDSWave)
{
    CDirectSoundWave *pDSWave;

    EnterCriticalSection(&sDSWaveCritSect);

    for (pDSWave = sDSWaveList.GetHead(); pDSWave; pDSWave = pDSWave->GetNext())
    {
        if (pDSWave->m_pIDSWave == pIDSWave)
        {
            break;
        }
    }
    
    LeaveCriticalSection(&sDSWaveCritSect);        

    if (pDSWave) 
    {
        pDSWave->AddRef();
    }

    return pDSWave;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Init
//
// Save the wave format of the source wave, and verify that it's a PCM format.
//                                                                              
//
HRESULT CDirectSoundWave::Init(
    CDirectMusicPortDownload *pPortDL)
{
    HRESULT hr = S_OK;

    DWORD cbwfex;
    
    // Get the format of the wave
    //
    if (SUCCEEDED(hr))
    {
        cbwfex = 0;
        hr = m_pIDSWave->GetFormat(NULL, 0, &cbwfex);
    }

    if (SUCCEEDED(hr))
    {
        BYTE *pb = new BYTE[cbwfex];
        m_pwfex = (LPWAVEFORMATEX)pb;

        hr = HRFromP(pb);
    }

    if (SUCCEEDED(hr)) 
    {
        hr = m_pIDSWave->GetFormat(m_pwfex, cbwfex, NULL);
    }

    // Synthesizers currently only support PCM format data
    //
    if (SUCCEEDED(hr) && !IS_PCM(m_pwfex))
    {
        hr = DMUS_E_NOTPCM;    
    }

    // Figure out bytes per sample to avoid lots of divisions later
    //
    if (SUCCEEDED(hr))
    {
        m_nBytesPerSample = ((m_pwfex->wBitsPerSample + 7) / 8);
    }
    // Allocate working pointers. These are used for passing 
    // to the wave object to get n channels worth of data for
    // one buffer segment. Keeping this around help us not
    // fail from out-of-memory while streaming.
    //
    if (SUCCEEDED(hr))
    {
        m_rpv = new LPVOID[GetNumChannels()];
        hr = HRFromP(m_rpv);
    }

    // Get a viewport
    //
    if (SUCCEEDED(hr))
    {
        // This is bytes per sample in one channel only.
        //
        m_cbSample = (m_pwfex->wBitsPerSample + 7) / 8;

        DWORD dwFlags = IsStreaming() ? DMUS_DOWNLOADINFO_STREAMINGWAVE : DMUS_DOWNLOADINFO_ONESHOTWAVE;
        hr = m_pIDSWave->CreateSource(&m_pSource, m_pwfex, dwFlags);
    }            

    // Get the length of the wave in samples
    //
    ULONGLONG ullStreamSize;
    if (SUCCEEDED(hr))
    {
        hr = m_pSource->GetSize(&ullStreamSize);
    }

    if (SUCCEEDED(hr))
    {
        m_stLength = BytesToSamples((LONG)(ullStreamSize / GetNumChannels()));
    }

    // If a one-shot voice, this object owns the actual download 
    // structures as well.
    //
    // This has to happen last because it assumes the CDirectSoundWave
    // object passed is initialized.
    //
    if (SUCCEEDED(hr) && !IsStreaming())
    {
        m_pDSWD = new CDirectSoundWaveDownload(
            this,
            pPortDL,
            0, 
            ENTIRE_WAVE);
        hr = HRFromP(m_pDSWD);

        if (SUCCEEDED(hr))
        {
            hr = m_pDSWD->Init();
        }
    }

    // If this is a streaming wave, then preread starting at rtStartHint
    // so that we won't have to do this at download time.
    //
    if (SUCCEEDED(hr) && IsStreaming() && m_fUseNoPreRoll == false)
    {
        // Allocate precache pointers. This is used to
        // preread wave data so we don't have to do it
        // at download time.
        //
        SAMPLE_TIME stReadAhead = RefToSampleTime(m_rtReadAhead);
        stReadAhead *= gnDownloadBufferPerStream;
        DWORD cb = SamplesToBytes(stReadAhead);
        // Need to block align for ADPCM. Do worse case: Stereo
        cb += (72 - 1);
        cb /= 72;
        cb *= 72;

        m_rpbPrecache = new LPBYTE[GetNumChannels()];
        hr = HRFromP(m_rpbPrecache);

        // Now get the actual precache buffers
        //
        if (SUCCEEDED(hr))
        {
            m_rpbPrecache[0] = new BYTE[cb * GetNumChannels()];
            hr = HRFromP(m_rpbPrecache[0]);    
        }

        if (SUCCEEDED(hr))
        {
            for (UINT i = 1; i < GetNumChannels(); i++)
            {
                m_rpbPrecache[i] = m_rpbPrecache[i - 1] + cb;
            }
        }

        if (SUCCEEDED(hr))
        {
            m_stStartHint = RefToSampleTime(m_rtStartHint);
            hr = Seek(m_stStartHint);
        }

        if (SUCCEEDED(hr))
        {
            LONG lReadPrecache = 2;
            ULONGLONG cbRead = cb;
            hr = m_pSource->Read((LPVOID*)m_rpbPrecache, NULL, NULL, &lReadPrecache, GetNumChannels(), &cbRead);            

            if (FAILED(hr) || (((DWORD)cbRead) < cb))
            {
                // Read completed but with less sample data than we expected.
                // Fill the rest of the buffer with silence.
                // 
                cb -= (DWORD)cbRead;
                BYTE bSilence = (m_pwfex->wBitsPerSample == 8) ? 0x80 : 0x00;

                for (UINT i = 0; i < GetNumChannels(); i++) 
                {
                    memset(m_rpbPrecache[i] + cbRead, bSilence, cb);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            m_stStartLength = stReadAhead;
        }
    }

    if (SUCCEEDED(hr) && !IsStreaming())
    {
        // Everything constructed. Put this object on the global list of 
        // waves
        //
        EnterCriticalSection(&sDSWaveCritSect);
        sDSWaveList.AddTail(this);
        LeaveCriticalSection(&sDSWaveCritSect);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::GetSize
//
void CDirectSoundWave::GetSize(
    SAMPLE_TIME             stLength,
    PULONG                  pcbSize) const
{
    HRESULT                 hr = S_OK;

    // Since we're only dealing with PCM formats here, this is easy to compute
    // and is time invariant.
    //
    
    // If stLength is ENTIRE_WAVE, stStart must be zero.
    //
    if (stLength == ENTIRE_WAVE)
    {
        // We cached the length of the wave in Init
        //
        stLength = m_stLength;
    }

    // This is a workaround to not fail when downloading 
    // the buffers to the synth. The synth will complain
    // if the buffer has no wave data so we pretend we have one sample.
    // The buffer is always aloocated to be the ReadAhead size so this
    // shouldn't cause any major problems
    if(stLength == 0)
    {
        stLength = 1;
    }

    // Bytes for one channel's worth of data
    //
    // XXX Overflow?
    //
    DWORD cbChannel = (DWORD)(stLength * m_cbSample);

    // We need:
    // 1. Download header
    // 2. Offset table (one entry per channel)
    // 3. Enough samples per each channel
    //        
    *pcbSize = 
        CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)) + 
        2*sizeof(DWORD) +                       // Offset table. DWORD's are
                                                // by definition chunk aligned
        CHUNK_ALIGN(sizeof(DMUS_WAVEDL)) +
        CHUNK_ALIGN(cbChannel);
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Write
//
//
HRESULT CDirectSoundWave::Write(
    LPVOID                  rpv[], 
    SAMPLE_TIME             stStart, 
    SAMPLE_TIME             stLength,
    DWORD                   dwDLId,
    DWORD                   dwDLType) const
{
    HRESULT                 hr = S_OK;
    DWORD                   cbWaveData;
    ULONGLONG               cbBytesRead = 0;
    bool                    fUsingPrecache = false;
    bool                    fPartialPreCache = false;
    DWORD                   offPrecache;

    if (IsStreaming() && 
        m_fUseNoPreRoll == false &&
        m_stStartHint <= stStart &&
        stStart <= m_stStartHint + m_stStartLength)
    {
        fUsingPrecache = true;
        offPrecache = SamplesToBytes(stStart - m_stStartHint);
    }

    if((stStart + stLength > m_stStartHint + m_stStartLength) && fUsingPrecache)
    {
        fPartialPreCache = true;
    }


    cbWaveData = SamplesToBytes(stLength);

    for (UINT idxChannel = 0; 
         idxChannel < GetNumChannels() && SUCCEEDED(hr);
         idxChannel++) 
    {
        unsigned char *pdata = (unsigned char *)rpv[idxChannel];

        // First we have the download header
        //
        DMUS_DOWNLOADINFO *pdmdli = (DMUS_DOWNLOADINFO *)pdata;
    
        memset(pdmdli, 0, sizeof(DMUS_DOWNLOADINFO));
        pdmdli->dwDLType                = dwDLType;
        pdmdli->dwDLId                  = dwDLId + idxChannel;
        pdmdli->dwNumOffsetTableEntries = 2;
        
        GetSize(stLength, &pdmdli->cbSize);

        pdata += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

        // Offset table 
        //
        DMUS_OFFSETTABLE *pot = (DMUS_OFFSETTABLE*)pdata;
        pdata += CHUNK_ALIGN(sizeof(ULONG) * 2);

        // Wave header chunk
        //
        pot->ulOffsetTable[0] = (ULONG)(pdata - (unsigned char*)rpv[idxChannel]);

        // Wave data chunk 
        //
        DMUS_WAVEDL *pwdl = (DMUS_WAVEDL *)pdata;
        pdata += CHUNK_ALIGN(sizeof(DMUS_WAVEDL));

        pwdl->cbWaveData = cbWaveData;

        // Save off pointer to this channel's wave data
        //
        pot->ulOffsetTable[1] = (ULONG)(pdata - (unsigned char*)rpv[idxChannel]);
        m_rpv[idxChannel] = (LPVOID)pdata;
    }

    // Fill in the wave data
    //
    if (SUCCEEDED(hr))
    {
        DWORD cbPreCache = cbWaveData;  
        cbBytesRead = cbPreCache;
        ULONGLONG cbRead = 0;

        if(fPartialPreCache)
        {
            SAMPLE_TIME stPreCache = (m_stStartHint + m_stStartLength) - stStart;
            cbPreCache = SamplesToBytes(stPreCache);
            cbRead = cbWaveData - cbPreCache;
        }

        if (fUsingPrecache)
        {
            for (UINT i = 0; i < GetNumChannels(); i++)
            {
                memcpy(m_rpv[i], m_rpbPrecache[i] + offPrecache, cbPreCache);
            }
            
            // Cache doesn't have enough data so we read the rest
            if(fPartialPreCache)
            {          
                // Allocate a temporary pool of buffers to read data into
                LPBYTE* ppbData = new LPBYTE[GetNumChannels()];
                hr = HRFromP(ppbData);
                
                if(SUCCEEDED(hr))
                {
                    ppbData[0] = new BYTE[(DWORD)(cbRead * GetNumChannels())];
	                hr = HRFromP(ppbData[0]);   
                }

                if (SUCCEEDED(hr))
                {
                    for (UINT nChannel = 1; nChannel < GetNumChannels(); nChannel++)
                    {
                        ppbData[nChannel] = ppbData[nChannel - 1] + cbRead;
                    }
                }

                if(SUCCEEDED(hr))
                {              
                    // Seek to precache position 
                    DWORD cbNewPos = SamplesToBytes(m_stStartHint + m_stStartLength) * GetNumChannels();
                    hr = m_pSource->Seek(cbNewPos);

                    // And read the required number of bytes from there
                    // We use the LPLONG plPitchShifts in the read method as a boolean
                    // this is a HACK!! We need to change this...
                    LONG lPreCacheRead = 1;
                    hr = m_pSource->Read((void**)ppbData, NULL, NULL, &lPreCacheRead, GetNumChannels(), &cbRead);
                }

                if(SUCCEEDED(hr))
                {
                    cbBytesRead += cbRead;            

                    // Copy all the data to the actual buffer
                    for (UINT i = 0; i < GetNumChannels(); i++)
                    {
                        memcpy((BYTE*)m_rpv[i] + cbPreCache, ppbData[i], (DWORD)cbRead);
                    }
                }

                if(ppbData)
                {
                    delete[] ppbData[0];
                    delete[] ppbData;
                }
            }
            else if(stStart + stLength >= m_stStartHint + m_stStartLength)
            {
                // Seek is exactly after the precached samples
                DWORD cbNewPos = SamplesToBytes(m_stStartHint + m_stStartLength) * GetNumChannels();
                hr = m_pSource->Seek(cbNewPos);
            }
            else
            {
                // We might have a wave that's shorter than the read-ahead time
                DWORD cbNewPos = SamplesToBytes(stStart + stLength) * GetNumChannels();
                hr = m_pSource->Seek(cbNewPos);
            }
        }
        else
        {
            cbRead = cbWaveData;
            hr = m_pSource->Read(m_rpv, NULL, NULL, NULL, GetNumChannels(), &cbRead);
        }
    }
    
    if (SUCCEEDED(hr) && cbWaveData != cbBytesRead)
    {
        // Read completed but with less sample data than we expected.
        // 
        hr = S_FALSE;
    }        

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::RefillBuffers
//
// rpv[] points to one sample buffer per channel
// stStart is the sample starting position within the stream
// stLength is how many samples to read
// stBufferSize is how big the buffers actually are (>= stLength)
//
// If stLength < stBufferSize or there is not enough data left
// in the stream, then fill with PCM silence for the rest of
// the buffer.
//
// Returns S_FALSE if we padded with silence (and therefore
// are past the end of the stream).
//
HRESULT CDirectSoundWave::RefillBuffers(
    LPVOID                  rpv[], 
    SAMPLE_TIME             stStart, 
    SAMPLE_TIME             stLength,
    SAMPLE_TIME             stBufferSize)
{
    HRESULT                 hr = S_OK;
    ULONGLONG               cbRead;
    DWORD                   cbLength = SamplesToBytes(stLength);
    DWORD                   cbBuffer = SamplesToBytes(stBufferSize);
    UINT                    idxChannel;

    for (idxChannel = 0; 
         idxChannel < GetNumChannels() && SUCCEEDED(hr);
         idxChannel++) 
    {
        unsigned char *pdata = (unsigned char *)rpv[idxChannel];
        DMUS_OFFSETTABLE *pot = 
            (DMUS_OFFSETTABLE *)(pdata + CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)));

        // Update length of data in buffer
        //
        DMUS_WAVEDL *pwdl = (DMUS_WAVEDL*)(pdata + pot->ulOffsetTable[0]);
        pwdl->cbWaveData = SamplesToBytes(stLength);

        // Where to put it
        //
        m_rpv[idxChannel] = pdata + pot->ulOffsetTable[1];
    }
    
    cbRead = 0;
    if (SUCCEEDED(hr))
    {
        cbRead = cbLength;
        if(stStart == m_stStartHint + m_stStartLength)
        {
            // We use the LPLONG plPitchShifts in the read method as a boolean
            // this is a HACK!! We need to change this...
            LONG lPreCacheRead = 1;
            hr = m_pSource->Read(m_rpv, NULL, NULL, &lPreCacheRead, GetNumChannels(), &cbRead);
        }
        else
        {
            hr = m_pSource->Read(m_rpv, NULL, NULL, NULL, GetNumChannels(), &cbRead);
        }
    }

    TraceI(0, "Wave: RefillBuffer read %d buffer %d bytes hr %08X\n", (DWORD)cbRead, (DWORD)cbBuffer, hr);

    if (FAILED(hr) || (SUCCEEDED(hr) && (cbRead < cbBuffer)))
    {
        // Read completed but with less sample data than we expected.
        // Fill the rest of the buffer with silence.
        // 
        cbBuffer -= (DWORD)cbRead;
        BYTE bSilence = (m_pwfex->wBitsPerSample == 8) ? 0x80 : 0x00;

        for (idxChannel = 0; idxChannel < GetNumChannels(); idxChannel++) 
        {
            memset(((LPBYTE)m_rpv[idxChannel]) + cbRead, bSilence, cbBuffer);
        }

        TraceI(0, "Wave: RefillBuffer padded with silence\n");
        hr = S_FALSE;
    }        

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::RefToSampleTime
//
SAMPLE_TIME CDirectSoundWave::RefToSampleTime(REFERENCE_TIME rt) const
{
    // For PCM, the samples per second metric in the waveformat is exact.
    //
    return (rt * m_pwfex->nSamplesPerSec) / gnRefTicksPerSecond;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Download
//
HRESULT CDirectSoundWave::Download()
{
    if (m_pDSWD) 
    {
        return m_pDSWD->Download();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Unload
//
HRESULT CDirectSoundWave::Unload()
{
    if (m_pDSWD) 
    {
        return m_pDSWD->Unload();
    }

    return S_OK;
}

//#############################################################################
//
// CDirectSoundWaveArt
//
// Implements calculating and writing the wave articulation header into a
// download buffer.
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::CDirectSoundWaveArt
//
//
CDirectSoundWaveArt::CDirectSoundWaveArt()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::CDirectSoundWaveArt
//
//
CDirectSoundWaveArt::~CDirectSoundWaveArt()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::Init
//
//
HRESULT CDirectSoundWaveArt::Init(
    CDirectSoundWave        *pDSWave, 
    UINT                    nSegments,
    DWORD                   dwBus,
    DWORD                   dwFlags) 
{
    HRESULT                 hr = S_OK;

    m_pDSWave = pDSWave;
    const LPWAVEFORMATEX    pwfex = pDSWave->GetWaveFormat();

    // Cache wave format size 
    //
    m_cbWaveFormat = sizeof(WAVEFORMATEX);
    if (!IS_PCM(pwfex))             
    {
        m_cbWaveFormat = sizeof(WAVEFORMATEX) + pwfex->cbSize;
    }

    if (SUCCEEDED(hr))
    {
        // This stuff in the wave articulation never changes
        //
        m_WaveArtDL.ulDownloadIdIdx = 1;
        m_WaveArtDL.ulBus           = dwBus;
        m_WaveArtDL.ulBuffers       = nSegments;
        m_WaveArtDL.usOptions       = (USHORT)dwFlags;

        m_nDownloadIds = nSegments;
        DWORD cbDLIds = sizeof(DWORD) * m_nDownloadIds;

        m_cbSize =
            CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)) +
            CHUNK_ALIGN(3 * sizeof(ULONG)) +            // 3 entry offset table
            CHUNK_ALIGN(sizeof(DMUS_WAVEARTDL)) + 
            CHUNK_ALIGN(m_cbWaveFormat) + 
            CHUNK_ALIGN(cbDLIds);
    }

   return hr;    
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::Write
//
// Write the wave articulation into the buffer
//
//
void CDirectSoundWaveArt::Write(
    void                    *pv,                // To pack into
    DWORD                   dwDLIdArt,          // Articulation chunk DLID
    DWORD                   dwDLIdWave,         // First wave DLId
    DWORD                   dwMasterDLId)       // DLId of group master
{
    unsigned char *pdata = (unsigned char *)pv;
    DMUS_DOWNLOADINFO *pdmdli = (DMUS_DOWNLOADINFO *)pdata;
    
    memset(pdmdli, 0, sizeof(DMUS_DOWNLOADINFO));
    pdmdli->dwDLType                = DMUS_DOWNLOADINFO_WAVEARTICULATION;
    pdmdli->dwDLId                  = dwDLIdArt;
    pdmdli->dwNumOffsetTableEntries = 3;
    pdmdli->cbSize                  = GetSize();

    pdata += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    DMUS_OFFSETTABLE *pot = (DMUS_OFFSETTABLE*)pdata;
    pdata += CHUNK_ALIGN(3 * sizeof(ULONG));

    pot->ulOffsetTable[0] = (ULONG)(pdata - (unsigned char *)pv);
    m_WaveArtDL.ulMasterDLId = dwMasterDLId;
    memcpy(pdata, &m_WaveArtDL, sizeof(DMUS_WAVEARTDL));

    pdata += sizeof(DMUS_WAVEARTDL);
    pot->ulOffsetTable[1] = (ULONG)(pdata - (unsigned char *)pv);

    const LPWAVEFORMATEX     pwfex = m_pDSWave->GetWaveFormat();
    memcpy(pdata, pwfex, m_cbWaveFormat);

    pdata += CHUNK_ALIGN(m_cbWaveFormat);
    pot->ulOffsetTable[2] = (ULONG)(pdata - (unsigned char *)pv);

    // Get the download ID's. The download ID's for each buffer are
    // grouped together.
    //

    DWORD nChannels = pwfex->nChannels;
    DWORD dwLastWaveDLId = dwDLIdWave + nChannels * m_WaveArtDL.ulBuffers;
    DWORD dwDLId;
    DWORD *pdw = (DWORD*)pdata;

    for (dwDLId = dwDLIdWave; dwDLId < dwLastWaveDLId; dwDLId += nChannels, pdw++) 
    {
        *pdw = dwDLId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dmwavobj.h ===
//
// dmwavobj.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMWAVOBJ_H
#define DMWAVOBJ_H

#include "dmextchk.h"

// Windows Media Audio codec Format Tags
#define MSAUDIO_FORMAT_TAG	352	// V1
#define WMAUDIO_FORMAT_TAG	353	// V2

// Key required for Windows Media Audio codecs
#define MSAUDIO_DEC_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"


class CCopyright;
class CRiffParser;

class CWaveObj : public AListItem      
{       
friend class CCollection;
friend class CInstrument;
friend class CWaveObjList;

private:
	CWaveObj();
	~CWaveObj();

	CWaveObj* GetNext(){return (CWaveObj*)AListItem::GetNext();}
	HRESULT Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent);

	void Cleanup();
	HRESULT Size(DWORD* pdwSize, DWORD * pdwSampleSize);
	HRESULT Write(void* pvoid);

	HRESULT GetData(BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT ReadData(IStream* pStream, BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT ReadCompressedData(IStream* pStream, BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT CanDecompress();
	HRESULT CalcDataSize(DWORD *pdwSize);
	HRESULT DecompressWave(WAVEFORMATEX *pwfxSrc, 
						   WAVEFORMATEX *pwfxDst, 
						   BYTE *pbCompressedBuffer,
						   BYTE *pbDecompressBuffer,
						   DWORD dwSizeCompressed, 
						   DWORD dwSizeDecompressed);

	HRESULT AllocWMAudioFormat(const WAVEFORMATEX* pwfxSrc, WAVEFORMATEX** ppwfxWMAudioWave);
	
private:
	CRITICAL_SECTION			m_DMWaveCriticalSection;
    BOOL                        m_fCSInitialized;
	BOOL                        m_fReadDecompressionFormat;
	WAVEFORMATEX				m_WaveFormatRead;
	WAVEFORMATEX				m_WaveFormatWrite;
	WAVEFORMATEX                m_WaveFormatDecompress;
	BYTE*						m_pExtractWaveFormatData;
#ifdef DXAPI
	CExtensionChunkList			m_ExtensionChunkList;
	CCopyright*					m_pCopyright;
	DWORD						m_dwCountExtChk;
#endif
    DWORD                       m_dwDataOffset;
	DWORD						m_dwDataSizeWrite;      // Calculated size of wave buffer.
    DWORD                       m_dwDataSizeAfterACM;   // Actual size after decompression.
	DWORD						m_dwDataSizeRead;
	DWORD						m_dwId;

	CCollection*		        m_pParent;

	DWORD						m_cbSizeOffsetTable;
	DWORD						m_dwSize;
	bool						m_bLoaded;
};      

class CWaveObjList : public AList
{
friend class CInstrument;
	
private:
	CWaveObjList(){}
	~CWaveObjList() 
	{
		while(!IsEmpty())
		{
			CWaveObj* pWaveObj = RemoveHead();
			delete pWaveObj;
		}
	}

    CWaveObj *GetHead(){return (CWaveObj *)AList::GetHead();}
	CWaveObj *GetItem(LONG lIndex){return (CWaveObj*)AList::GetItem(lIndex);}
    CWaveObj *RemoveHead(){return (CWaveObj *)AList::RemoveHead();}
	void Remove(CWaveObj *pWaveObj){AList::Remove((AListItem *)pWaveObj);}
	void AddTail(CWaveObj *pWaveObj){AList::AddTail((AListItem *)pWaveObj);}
};

#endif // #ifndef DMWAVOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\oledll.cpp ===
// oledll.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Handle standard stuff for OLE server DLL
//

#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#ifndef XBOX
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif // ! XBOX
#endif // ! UNDER_CE
#endif // UNICODE

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
#ifndef XBOX
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

#endif // ! XBOX

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
#ifndef XBOX
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

#endif // ! XBOX

    return S_OK;
}

#ifndef XBOX

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}

#endif // ! XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\resource.h ===
// resource.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
#define IDS_SYSTEMCLOCK         1000
#define IDS_DSOUNDCLOCK         1001
#define IDS_EXTCLOCK            1002
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\opnew.cpp ===
// OpNew.cpp
//
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\oledll.h ===
//
// OleDLL.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\ltcg\makefile.inc ===
# obj\$(TARGET_DIRECTORY)\xapi.def: xapi.src
#     $(TARGET_CPP) /EP $(CDEFINES) xapi.src > obj\$(TARGET_DIRECTORY)\xapi.def

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

# $(XDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib: $(SDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib
#     copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\normal\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\dswave.h ===
//
// dswave.h
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for streaming or oneshot waves from IDirectSoundWaveObject
//
//
#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include "alist.h"

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

#define MAX_CHANNELS    32                      // XXX Is this ok?

// Number of download buffers per streaming wave
//
#ifdef XBOX
const UINT gnDownloadBufferPerStream = 2;
#else
const UINT gnDownloadBufferPerStream = 3;
#endif

class CDirectSoundWave;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt
//
// Wraps wave articulation data
//
class CDirectSoundWaveArt
{
public:
    CDirectSoundWaveArt();
    ~CDirectSoundWaveArt();
    
    HRESULT Init(CDirectSoundWave *pDSWave, UINT nSegments, DWORD dwBus, DWORD dwFlags);

    inline DWORD GetSize() const
    { return m_cbSize; }
   
    void Write(void *pvoid, DWORD dwDLIdArt, DWORD dwDLIdWave, DWORD dwMasterDLId);
    
private:    
    CDirectSoundWave   *m_pDSWave;              // Owning CDirectSoundWave
    DMUS_WAVEARTDL      m_WaveArtDL;            // Wave articulation
    DWORD               m_cbSize;               // Size of download
    UINT                m_nDownloadIds;         // Expected # of download ID's
    DWORD               m_cbWaveFormat;         // Size needed to pack wave format
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload
//
// Tracks a set of downloaded wave buffers.
//
//
class CDirectSoundWaveDownload : CMemTrack
{
public:
    CDirectSoundWaveDownload(
        CDirectSoundWave           *pDSWave, 
        CDirectMusicPortDownload   *pPortDL,
        SAMPLE_TIME                 stStart,
        SAMPLE_TIME                 stReadAhead);
        
    ~CDirectSoundWaveDownload();
    
    // Initialize
    //
    HRESULT Init();

    // Download wave buffers and articulation. In the case of streaming this
    // means downloading readahead data.
    //    
    HRESULT Download();                         
    
    // Unload everything
    //
    HRESULT Unload();
    
    // Notification that the stream has reached a certain sample position;
    // refresh the buffers as needed. (Streaming only)
    //
    HRESULT RefreshThroughSample(SAMPLE_POSITION sp);
    
    // Return the articulation download ID
    //
    inline DWORD GetDLId()
    { return m_dwDLIdArt; }
    
private:
    CDirectSoundWave           *m_pDSWave;          // Wave object
    CDirectMusicPortDownload   *m_pPortDL;          // Port download object
    
    CDirectSoundWaveArt        *m_pWaveArt;         // Wave articulation wrapper
    DWORD                       m_dwDLIdWave;       // First wave buffer DLID
    DWORD                       m_dwDLIdArt;        // Articulation DLID
    UINT                        m_cSegments;        // How many segments? 
    UINT                        m_cWaveBuffer;      // Number of wave buffers
    IDirectMusicDownload      **m_ppWaveBuffer;     // Wave download buffers
    void                      **m_ppWaveBufferData; //  and their data
    IDirectMusicDownload      **m_ppArtBuffer;      // Articulation buffers (one per channel)
    SAMPLE_TIME                 m_stStart;          // Starting sample
    SAMPLE_TIME                 m_stReadAhead;      // Read ahead (buffer length)
    LONG                        m_cDLRefCount;      // Download reference count
    SAMPLE_TIME                 m_stLength;         // How many samples to 
                                                    //  process? (Lenth of
                                                    //  stream - start pos)
    SAMPLE_TIME                 m_stWrote;          // Buffer-aligned sample
                                                    //  written through                                                    
    UINT                        m_nNextBuffer;      // Next buffer that should
                                                    // be filled.                                                    
    
private:
    HRESULT DownloadWaveBuffers();
    HRESULT UnloadWaveBuffers();
    HRESULT DownloadWaveArt();
    HRESULT UnloadWaveArt();
};

class CDirectSoundWaveList;

#define ENTIRE_WAVE ((SAMPLE_TIME)0x7FFFFFFFFFFFFFFF)

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave
//
// Internal wrapper for an external IDirectSoundWave.
//
class CDirectSoundWave : public IDirectSoundDownloadedWaveP, public AListItem
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG,AddRef)        (THIS);
    STDMETHOD_(ULONG,Release)       (THIS);
    
    CDirectSoundWave(
        IDirectSoundWave            *pIDSWave, 
        bool                        fStreaming, 
        REFERENCE_TIME              rtReadAhead,
        bool                        fUseNoPreRoll,
        REFERENCE_TIME              rtStartHint);
    ~CDirectSoundWave();


    // Find a CDirectSoundWave matching an IDirectSoundWave
    //
    static CDirectSoundWave *GetMatchingDSWave(IDirectSoundWave *pIDSWave);
    
    // General initialization. 
    //
    HRESULT Init(CDirectMusicPortDownload *pPortDL);

    // Write a piece of the wave or the whole wave into the buffer
    // Writes all channels for a single segment
    //
    HRESULT Write(
        LPVOID                  pvBuffer[], 
        SAMPLE_TIME             stStart, 
        SAMPLE_TIME             stLength,
        DWORD                   dwDLId,
        DWORD                   dwDLType) const;
        
    // Refill an already downloaded buffer with new wave data
    //        
    HRESULT RefillBuffers(
        LPVOID                  rpv[], 
        SAMPLE_TIME             stStart, 
        SAMPLE_TIME             stLength,
        SAMPLE_TIME             stBufferLength);
        
    // Convert reference time to samples 
    //
    SAMPLE_TIME RefToSampleTime(REFERENCE_TIME rt) const;                        
    
    // Download and unload all buffers if this is a one-shot
    //
    HRESULT Download();
    HRESULT Unload();
    
    // Override GetNext list operator
    //    
    inline CDirectSoundWave *GetNext() 
    { return (CDirectSoundWave*)AListItem::GetNext(); }
    
    // Determine if this wave is a streaming or one-shot
    //
    inline bool IsStreaming() const
    { return m_fStreaming; }
    
    // Figure out how much buffer to read a piece of the wave
    //
    void GetSize(SAMPLE_TIME stLength, PULONG pcb) const;
    
    // Returns the number of channels
    //

    inline UINT GetNumChannels() const
    { return m_pwfex->nChannels; }


    // Seek to a sample position
    //
    inline HRESULT Seek(SAMPLE_TIME st)
    { return m_pSource->Seek(st * m_nBytesPerSample * GetNumChannels()); }

    // Returns the wrapped IDirectSoundWave
    //
    inline IDirectSoundWave *GetWrappedIDSWave() 
    { m_pIDSWave->AddRef(); return m_pIDSWave; }    
    
    // Returns the wrapped wave format
    //
    inline const LPWAVEFORMATEX GetWaveFormat() const
    { return m_pwfex; }
    
    // Return the length of the stream in samples
    //
    inline SAMPLE_TIME GetStreamSize() const
    { return m_stLength; }
    
    // Get the download ID of the articulation if one-shot
    //
    inline DWORD GetDLId()
    { assert(!m_fStreaming); assert(m_pDSWD); 
      TraceI(1, "CDirectSoundWave::GetDLId() -> %d\n", m_pDSWD->GetDLId());
      return m_pDSWD->GetDLId(); }
      
    inline REFERENCE_TIME GetReadAhead()
    { return m_rtReadAhead; }      
      
    // Convert number of samples to number of bytes for this wave format
    // (assuming PCM). Truncates to a DWORD, so shouldn't be used for
    // huge number of samples.
    //
    inline DWORD SamplesToBytes(SAMPLE_TIME st) const
    { LONGLONG cb = st * m_nBytesPerSample; 
      assert(!(cb & 0xFFFFFFFF00000000));
      return (DWORD)cb; }
      
    inline SAMPLE_TIME BytesToSamples(DWORD cb) const
    { return cb / m_nBytesPerSample; }

    inline SAMPLE_TIME GetPrecacheStart() const
    { assert(IsStreaming()); return m_stStartHint; }

    inline LPBYTE *GetPrecache() const
    { assert(IsStreaming()); return m_rpbPrecache; }

          
    
    static CDirectSoundWaveList sDSWaveList;        // List of all wave objects
    static CRITICAL_SECTION sDSWaveCritSect;        //  and critical section
   
private:
    
    LONG                    m_cRef;                 // COM reference count
    IDirectSoundWave       *m_pIDSWave;             // Wrapped IDirectSoundWave
    bool                    m_fStreaming;           // Is this a streaming wave?
    bool                    m_fUseNoPreRoll;
    REFERENCE_TIME          m_rtReadAhead;          // If so, buffering amount    
    LPWAVEFORMATEX          m_pwfex;                // Native format of wave
    UINT                    m_cbSample;             // Bytes per sample
    SAMPLE_TIME             m_stLength;             // Length of entire wave
    IDirectSoundSource     *m_pSource;              // Source interface
    
    CDirectSoundWaveDownload    
                           *m_pDSWD;                // Wave download wrapper if 
                                                    //  not streaming
    UINT                    m_nBytesPerSample;      // Bytes per sample from wfex
    LPVOID                 *m_rpv;                  // Working space - one pv 
                                                    //  per channel
    LPBYTE                 *m_rpbPrecache;          // Samples starting at start hint
    REFERENCE_TIME          m_rtStartHint;          //  and where it starts
    SAMPLE_TIME             m_stStartHint;          //  in samples as well 
    SAMPLE_TIME             m_stStartLength;        // How many samples in precache?
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveList
//
// Type-safe wrapper for AList of CDirectSoundWave's
//
class CDirectSoundWaveList : public AList
{
public:
    inline CDirectSoundWave *GetHead()
    { return static_cast<CDirectSoundWave*>(AList::GetHead()); }
    
    inline void AddTail(CDirectSoundWave *pdsw)
    { AList::AddTail(static_cast<AListItem*>(pdsw)); }
    
    inline void Remove(CDirectSoundWave *pdsw)
    { AList::Remove(static_cast<AListItem*>(pdsw)); }
};


#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\profile\makefile.inc ===
# obj\$(TARGET_DIRECTORY)\xapi.def: xapi.src
#     $(TARGET_CPP) /EP $(CDEFINES) xapi.src > obj\$(TARGET_DIRECTORY)\xapi.def

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

# $(XDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib: $(SDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib
#     copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmusic_core$(LIBEXT)

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj

USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -D_DMUSIC_USER_MODE_ -DXBOX -DUNICODE

!if defined(INTERNAL)
C_DEFINES= $(C_DEFINES) -DDMUSIC_INTERNAL
!endif

USE_LIBCMT=1

#

INCLUDES= \
        ..\..\..\misc;  \
        ..\..\shared;   \
        ..\..\includes; \
        ..\..\xprivate; \
        ..

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
alist.cpp   \
debug.cpp           \
dmart.cpp           \
dmbuffer.cpp        \
dmclock.cpp         \
dmcollec.cpp        \
dmdlinst.cpp        \
dmdll.cpp           \
dmdload.cpp         \
dminsobj.cpp        \
dminstru.cpp        \
dmportdl.cpp        \
dmregion.cpp        \
dmsport.cpp         \
dmsysclk.cpp        \
dmusic.cpp          \
dmwavobj.cpp        \
dmsport8.cpp        \
dswave.cpp          \
dmvoice.cpp         \
dmdsclk.cpp         \
dmport.cpp			\
sysaudio.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\suwrap.cpp ===
//
// suwrap.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrap needed SetupAPI calls through LoadLibrary so they are only
// called on a platform that supports them.
//

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include "debug.h"
#include <setupapi.h>

#include "debug.h"
#include "suwrap.h"

static const char szSetupAPI[]                  = "setupapi.dll";

static const char szDestroyDeviceInfoList[]     = "SetupDiDestroyDeviceInfoList";
static const char szEnumDeviceInterfaces[]      = "SetupDiEnumDeviceInterfaces";
static const char szGetClassDevs[]              = "SetupDiGetClassDevsA";
static const char szGetDeviceInterfaceDetail[]  = "SetupDiGetDeviceInterfaceDetailA";
static const char szGetDeviceInstanceId[]       = "SetupDiGetDeviceInstanceIdA";

SetupAPI::SetupAPI()
{
    m_fValid = FALSE;
    m_hmodule = LoadLibrary(szSetupAPI);
    if (m_hmodule == (HMODULE)NULL)
    {
        TraceI(0, "SetupAPI: Could not LoadLibrary; error %d", GetLastError());
        goto Cleanup;
    }

    m_pfnGetClassDevs = (PSETUPDIGETCLASSDEVS)GetProcAddress(m_hmodule, szGetClassDevs);
    if (!m_pfnGetClassDevs)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetClassDevs);
        goto Cleanup;
    }

    m_pfnEnumDeviceInterfaces = (PENUMDEVICEINTERFACES)GetProcAddress(m_hmodule, szEnumDeviceInterfaces);
    if (!m_pfnEnumDeviceInterfaces)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szEnumDeviceInterfaces);
        goto Cleanup;
    }

    m_pfnDestroyDeviceInfoList = (PDESTROYDEVICEINFOLIST)GetProcAddress(m_hmodule, szDestroyDeviceInfoList);
    if (!m_pfnDestroyDeviceInfoList)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szDestroyDeviceInfoList);
        goto Cleanup;
    }
    
    m_pfnGetDeviceInterfaceDetail = (PSETUPDIGETDEVICEINTERFACEDETAIL)GetProcAddress(m_hmodule, szGetDeviceInterfaceDetail);
    if (!m_pfnGetDeviceInterfaceDetail)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetDeviceInterfaceDetail);
        goto Cleanup;
    }

    // SetupDiGetDeviceInstanceId is not available on Win9x, so succeed w/o it
    //
    m_pfnGetDeviceInstanceId = (PSETUPDIGETDEVICEINSTANCEID)GetProcAddress(m_hmodule, szGetDeviceInstanceId);
    if (!m_pfnGetDeviceInstanceId)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetDeviceInstanceId);
    }

    m_fValid = TRUE;

Cleanup:
    if (!m_fValid && m_hmodule != (HMODULE)NULL)
    {
        FreeLibrary(m_hmodule);
        m_hmodule = NULL;                                
    }
}

SetupAPI::~SetupAPI()
{
    if (m_hmodule)
    {
        FreeLibrary(m_hmodule);
    }
}

BOOL SetupAPI::IsValid()
{
    return (BOOL)(m_hmodule != (HMODULE)NULL);
}

BOOL SetupAPI::SetupDiDestroyDeviceInfoList(
    HDEVINFO DeviceInfoSet)
{
    assert(m_fValid);

    return (*m_pfnDestroyDeviceInfoList)(DeviceInfoSet);
}

BOOL SetupAPI::SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet,
                                           PSP_DEVINFO_DATA DeviceInfoData,
                                           LPGUID InterfaceClassGuid,
                                           DWORD MemberIndex,
                                           PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData)
{
    assert(m_fValid);

    return (*m_pfnEnumDeviceInterfaces)(DeviceInfoSet,
                                        DeviceInfoData,
                                        InterfaceClassGuid,
                                        MemberIndex,
                                        DeviceInterfaceData);
}                                           


HDEVINFO SetupAPI::SetupDiGetClassDevs(
    LPGUID ClassGuid, 
    PCSTR Enumerator, 
    HWND hwndParent, 
    DWORD Flags)
{
    assert(m_fValid);

    return (*m_pfnGetClassDevs)(ClassGuid, Enumerator, hwndParent, Flags);
}

BOOL SetupAPI::SetupDiGetDeviceInterfaceDetail(HDEVINFO DeviceInfoSet,
                                               PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                               PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
                                               DWORD DeviceInterfaceDetailDataSize,
                                               PDWORD RequiredSize,
                                               PSP_DEVINFO_DATA DeviceInfoData)
{
    assert(m_fValid);

    return (*m_pfnGetDeviceInterfaceDetail)(DeviceInfoSet,
                                            DeviceInterfaceData,
                                            DeviceInterfaceDetailData,
                                            DeviceInterfaceDetailDataSize,
                                            RequiredSize,
                                            DeviceInfoData);
}

BOOL SetupAPI::SetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet,
                                          PSP_DEVINFO_DATA DeviceInfoData,
                                          PSTR DeviceInstanceId,
                                          DWORD DeviceInstanceIdSize,
                                          PDWORD RequiredSize)
{
    if (!m_pfnGetDeviceInstanceId)
    {
        SetLastError(ERROR_BAD_COMMAND);
        return FALSE;
    }

    return (*m_pfnGetDeviceInstanceId)(DeviceInfoSet,
                                       DeviceInfoData,
                                       DeviceInstanceId,
                                       DeviceInstanceIdSize,
                                       RequiredSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\suwrap.h ===
//
// suwrap.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
//
//
//
#ifndef _SUWRAP_
#define _SUWRAP_

#include <setupapi.h>

typedef BOOL (*PDESTROYDEVICEINFOLIST)(
    IN HDEVINFO DeviceInfoSet
    );

typedef BOOL (*PENUMDEVICEINTERFACES)(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
    IN  LPGUID                    InterfaceClassGuid,
    IN  DWORD                     MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


typedef HDEVINFO (*PSETUPDIGETCLASSDEVS)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
);

typedef BOOL (*PSETUPDIGETDEVICEINTERFACEDETAIL)(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );
    
typedef BOOL (*PSETUPDIGETDEVICEINSTANCEID)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );


class SetupAPI
{
public:
    SetupAPI();
    ~SetupAPI();

    BOOL IsValid();

    BOOL        SetupDiDestroyDeviceInfoList(HDEVINFO DeviceInfoSet);

    BOOL        SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet,
                                            PSP_DEVINFO_DATA DeviceInfoData,
                                            LPGUID InterfaceClassGuid,
                                            DWORD MemberIndex,
                                            PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData);
    
    HDEVINFO    SetupDiGetClassDevs(LPGUID ClassGuid, PCSTR Enumerator, HWND hwndParent, DWORD Flags);

    BOOL        SetupDiGetDeviceInterfaceDetail(HDEVINFO DeviceInfoSet,
                                                PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
                                                DWORD DeviceInterfaceDetailDataSize,
                                                PDWORD RequiredSize,
                                                PSP_DEVINFO_DATA DeviceInfoData);
    BOOL        SetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet,
                                           PSP_DEVINFO_DATA DeviceInfoData,
                                           PSTR DeviceInstanceId,
                                           DWORD DeviceInstanceIdSize,
                                           PDWORD RequiredSize);
                                                

private:
    HMODULE                     m_hmodule;
    BOOL                        m_fValid;

    PDESTROYDEVICEINFOLIST              m_pfnDestroyDeviceInfoList;
    PENUMDEVICEINTERFACES               m_pfnEnumDeviceInterfaces;
    PSETUPDIGETCLASSDEVS                m_pfnGetClassDevs;
    PSETUPDIGETDEVICEINTERFACEDETAIL    m_pfnGetDeviceInterfaceDetail;
    PSETUPDIGETDEVICEINSTANCEID         m_pfnGetDeviceInstanceId;
};

#endif // _SUWRAP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\tlist.h ===
/***************************************************************************
 *
 *  Copyright (c) 1995-1999 Microsoft Corporation
 *
 *  File:       tlist.h
 *  Content:    Linked-list template classes.  There's some seriously
 *              magical C++ in here, so be forewarned all ye C
 *              programmers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/12/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __TLIST_H__
#define __TLIST_H__

#ifdef __cplusplus

template<class type> class CNode
{
public:
    CNode<type> *       pPrev;          // Previous node in the list
    CNode<type> *       pNext;          // Next node in the list
    type                data;           // Node data

public:
    CNode(CNode<type> *, CNode<type> *, const type&);
};

template<class type> CNode<type>::CNode(CNode<type> *pInitPrev, CNode<type> *pInitNext, const type& rInitData)
{
    pPrev = pInitPrev;
    pNext = pInitNext;
    data = rInitData;
}

template<class type> class CList
{
private:
    CNode<type> *       m_pHead;        // Pointer to the head of the list
    CNode<type> *       m_pTail;        // Pointer to the tail of the list
    UINT                m_uCount;       // Count of nodes in the list

public:
    CList(void);
    virtual ~CList(void);

public:
    virtual CNode<type> *AddNodeToList(const type&);
    virtual void RemoveNodeFromList(CNode<type> *);
    virtual void RemoveDataFromList(const type&);
    virtual CNode<type> *IsDataInList(const type&);
    virtual CNode<type> *GetListHead(void);
    virtual UINT GetNodeCount(void);
};

template<class type> CList<type>::CList(void)
{
    m_pHead = NULL;
    m_pTail = NULL;
    m_uCount = 0;
}

template<class type> CList<type>::~CList(void)
{
    CNode<type> *       pNext;

    while(m_pHead)
    {
        pNext = m_pHead->pNext;
        delete m_pHead;
        m_pHead = pNext;
    }
}

template<class type> CNode<type> *CList<type>::AddNodeToList(const type& data)
{
    CNode<type> *       pNode;

    pNode = new CNode<type>(m_pTail, NULL, data);

    if(pNode)
    {
        if(pNode->pPrev)
        {
            pNode->pPrev->pNext = pNode;
        }

        if(!m_pHead)
        {
            m_pHead = pNode;
        }

        m_pTail = pNode;
        m_uCount++;
    }

    return pNode;
}

template<class type> void CList<type>::RemoveNodeFromList(CNode<type> *pNode)
{
//    ASSERT(pNode);

#ifdef DEBUG

    CNode<type> *pNext;

    for(pNext = m_pHead; pNext && pNext != pNode; pNext = pNext->pNext);
//    ASSERT(pNext == pNode);

#endif // DEBUG

    if(pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }

    if(pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }

    if(pNode == m_pHead)
    {
        m_pHead = pNode->pNext;
    }

    if(pNode == m_pTail)
    {
        m_pTail = pNode->pPrev;
    }

    delete pNode;
    m_uCount--;
}

template<class type> void CList<type>::RemoveDataFromList(const type& data)
{
    CNode<type> *       pNode;

    if(pNode = IsDataInList(data))
    {
        RemoveNodeFromList(pNode);
    }
}

template<class type> CNode<type> *CList<type>::IsDataInList(const type& data)
{
    CNode<type> *       pNode;

    for(pNode = m_pHead; pNode && !memcmp(&data, &pNode->data, sizeof(data)); pNode = pNode->pNext);

    return pNode;
}

template<class type> CNode<type> *CList<type>::GetListHead(void) 
{ 
    return m_pHead; 
}

template<class type> UINT CList<type>::GetNodeCount(void) 
{ 
    return m_uCount; 
}

#endif // __cplusplus

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic\sysaudio.cpp ===
//
// SysAudio.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Interfaces to the WDM System Audio Device
//
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>

#include <devioctl.h>
#ifndef XBOX
#include <setupapi.h>
#include <mmsystem.h>
#include <mmddkp.h>
#endif // ! XBOX
#include <regstr.h>

#include <stdio.h>

#ifndef DRVM_MAPPER_PREFERRED_GET
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#endif

#include "dmusicp.h"
#include "debug.h"

#ifndef XBOX
#include "suwrap.h"
#endif // ! XBOX

static int  GetPreferredAudioPlaybackDeviceId();
static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId);

#ifdef DBG
extern void _TraceIGuid(int iLevel, GUID *pGUID);
#define TraceIGuid _TraceIGuid
#else
#define TraceIGuid(x,y)
#endif


typedef struct tag_KSPROPERTYDEVICEINDEX
{
    KSPROPERTY Property;
    ULONG      DeviceIndex;
}   KSPROPERTYDEVICEINDEX, 
    *PKSPROPERTYDEVICEINDEX;


// OpenDefaultDevice
//
// Use the SetupDi API's to retrieve the path of the SysAudio filter and open
// a handle to it.
//
// Handle should be closed with CloseHandle when done using it.
//
// Returns TRUE on success
//
BOOL OpenDefaultDevice(
    IN REFGUID           rguidCategory,
    OUT HANDLE          *pHandle)
{
#ifdef XBOX
    // BUGBUG: Open the device
    *pHandle = NULL;
    return FALSE;
#else  // XBOX
    BOOL fResult = FALSE;
    SetupAPI suwrap;

    if (!suwrap.IsValid()) 
    {
        return FALSE;
    }

    *pHandle = (HANDLE)NULL;

    // Get the device class for KSCATEGORY_SYSAUDIO
    //
	GUID *pClassGuid = const_cast<GUID*>(&rguidCategory);  //KSCATEGORY_SYSAUDIO);
	HDEVINFO hDevInfo = suwrap.SetupDiGetClassDevs(pClassGuid,
											NULL,
											NULL,
											DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
	{
		TraceI(0, "Could not open SetupDiGetClassDevs\n");
        return FALSE;
	}

    // Get device details. There should only be one SysAudio.
    //
	SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	DevInterfaceData.cbSize = sizeof(DevInterfaceData);

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];
	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

	if (suwrap.SetupDiEnumDeviceInterfaces(hDevInfo, NULL, pClassGuid, 0, &DevInterfaceData))
    {
		if (suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo, 
		                                    &DevInterfaceData, 
		                                    pDevInterfaceDetails,
 										    sizeof(rgbStorage), 
 										    NULL, 
 										    NULL))
        {
            // Have to convert this since there's no CreateFileW on Win9x.
            //
            HANDLE hFilter = CreateFile(pDevInterfaceDetails->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                        NULL);
            if (hFilter != NULL && hFilter != INVALID_HANDLE_VALUE)
            {
                *pHandle = hFilter;
                fResult = TRUE;
            }
            else
            {
                TraceI(0, "Open of SysAudio filter failed.\n");
            }
        }
        else
        {
            TraceI(0, "SetUpDiGetDeviceInterfaceDetail failed\n");
        }
    }
    else
    {
        TraceI(0, "SetUpDiEnumDeviceInterfaces failed\n");
    }

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    return fResult;
#endif // XBOX
}

// IsEqualInterface
//
// Check the equality of two KS pin interfaces
//
BOOL IsEqualInterface(
    const KSPIN_INTERFACE *pInterface1,
    const KSPIN_INTERFACE *pInterface2)
{
    return ( IsEqualGUID(pInterface1->Set, pInterface2->Set) &&
             (pInterface1->Id    == pInterface2->Id)           &&
             (pInterface1->Flags == pInterface2->Flags) );
}

// CreatePin
//
// Given a handle to SysAudio with the default device set, create a handle to the given pin.
//
HRESULT CreatePin(
    IN      HANDLE          handleFilter,
    IN      ULONG           ulPinId,
    OUT     HANDLE          *pHandle)
{
    static char szKsCreatePin[] = "KsCreatePin";

    DWORD (WINAPI *pKsCreatePin)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE);
    PKSPIN_CONNECT  pKsPinConnect;
    PKSDATAFORMAT   pKsDataFormat;

    *pHandle = NULL;

#ifdef XBOX
    if (TRUE)
#else // XBOX
    if (!LoadKsUser())
//#endif // XBOX
    {
        TraceI(0, "CDirectMusicPort::Init() -> No KSUSER.DLL handle");
        return E_NOINTERFACE;
    }

    pKsCreatePin = (DWORD (WINAPI *)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE))
                   GetProcAddress(g_hModuleKsUser, szKsCreatePin);
    if (!pKsCreatePin)
    {
        TraceI(0, "CDirectMusicPort::Init() -> No entry point");
        return E_NOINTERFACE;
    }

    pKsPinConnect = (PKSPIN_CONNECT)LocalAlloc(LPTR, sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT));

    if (!pKsPinConnect)
    {
        TraceI(0, "LocalAlloc failed in CreatePin\n");
        return E_OUTOFMEMORY;
    }

    pKsPinConnect->Interface.Set              = KSINTERFACESETID_Standard;
    pKsPinConnect->Interface.Id               = KSINTERFACE_STANDARD_STREAMING;
    pKsPinConnect->Interface.Flags            = 0;
    pKsPinConnect->Medium.Set                 = KSMEDIUMSETID_Standard;
    pKsPinConnect->Medium.Id                  = KSMEDIUM_TYPE_ANYINSTANCE;
    pKsPinConnect->Medium.Flags               = 0;
    pKsPinConnect->PinId                      = ulPinId;
    pKsPinConnect->PinToHandle                = NULL;
    pKsPinConnect->Priority.PriorityClass     = KSPRIORITY_NORMAL;
    pKsPinConnect->Priority.PrioritySubClass  = 1;

    pKsDataFormat = PKSDATAFORMAT(pKsPinConnect + 1);
    pKsDataFormat->FormatSize     = sizeof(KSDATAFORMAT);
    pKsDataFormat->Reserved       = 0;
    pKsDataFormat->MajorFormat    = KSDATAFORMAT_TYPE_MUSIC;
    pKsDataFormat->SubFormat      = KSDATAFORMAT_SUBTYPE_DIRECTMUSIC;
    pKsDataFormat->Specifier      = KSDATAFORMAT_SPECIFIER_NONE;

    
    DWORD dwRes = (*pKsCreatePin)(handleFilter,
                                  pKsPinConnect,
                                  GENERIC_WRITE | GENERIC_READ,
                                  pHandle);
    if (dwRes != ERROR_SUCCESS)
    {
        LocalFree(pKsPinConnect);
        return WIN32ERRORtoHRESULT(dwRes);
    }

    LocalFree(pKsPinConnect);
#endif
    return S_OK;
}

// GetSizedProperty
//
// Retrieve a property of which the size is unknown. 
//
BOOL GetSizedProperty(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    OUT     PVOID *     ppvBuffer,
    OUT     PULONG      pulBytesReturned)
{
    *ppvBuffer = NULL;

    // determine size of data we are attempting to retrieve
    //
    ULONG ulSize;

    BOOL fResult = SyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            NULL,
            0,
            &ulSize);

    if (fResult)
    {
        *ppvBuffer = LocalAlloc(LPTR, ulSize);

        if (!*ppvBuffer)
        {
            //If we are going to fail, at least say we are returning
            //zero bytes.
            *pulBytesReturned = 0;
            return FALSE;
        }

        fResult = Property(handle,
                           ulPropSize,
                           pKsProperty,
                           ulSize,
                           *ppvBuffer,
                           pulBytesReturned);

        if (fResult && (*pulBytesReturned != ulSize))
        {
            TraceI(0, "GetSizedProperty: Property returned %lu bytes, asked for %lu\n", 
                *pulBytesReturned, ulSize);
            LocalFree(*ppvBuffer);
            *ppvBuffer = NULL;

            fResult = FALSE;
        }
    }
    else
    {
        TraceI(0, "GetSizedProperty: Size query failed\n");
    }

    return fResult;
}

// Property
// 
//
BOOL Property(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    IN      ULONG       ulBufferSize,
    IN OUT  PVOID       pvBuffer,
    OUT     PULONG      pulBytesReturned)
{
    ULONG   ulReturned = 0;
    PULONG  pulReturned = pulBytesReturned ? pulBytesReturned : &ulReturned;


    BOOL fResult = SyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            pvBuffer,
            ulBufferSize,
            pulReturned);

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());

        TraceI(0, "KS Item: ");
        TraceIGuid(0, &pKsProperty->Set);
        TraceI(0, "\t#%d\n", pKsProperty->Id);
        TraceI(0, "\tFlags: %08X\n", pKsProperty->Flags);
    }
#endif // DBG

    return fResult;
}

#ifdef XBOX
BOOL AsyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned,
	OUT		PHANDLE	phOverLappedEvent);
#endif

BOOL PropertyAsync(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    IN      ULONG       ulBufferSize,
    IN OUT  PVOID       pvBuffer,
    OUT     PULONG      pulBytesReturned,
	OUT		PHANDLE		phOverLappedEvent)
{
    ULONG   ulReturned = 0;
    PULONG  pulReturned = pulBytesReturned ? pulBytesReturned : &ulReturned;


    BOOL fResult = AsyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            pvBuffer,
            ulBufferSize,
            pulReturned,
			phOverLappedEvent);

    return fResult;
}

// AsyncIoctl
//
//
BOOL AsyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned,
	OUT		PHANDLE	phOverLappedEvent)
{
	OVERLAPPED overlapped;
    ZeroMemory(&overlapped, sizeof(overlapped));
    overlapped.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    *phOverLappedEvent = overlapped.hEvent;

	if (!overlapped.hEvent)
    {
        return FALSE;
    }

    BOOL fResult = DeviceIoControl(handle, 
                                   ulIoctl, 
                                   pvInBuffer, 
                                   ulInSize, 
                                   pvOutBuffer, 
                                   ulOutSize, 
                                   pulBytesReturned, 
                                   &overlapped);

	return fResult;
}

// SyncIoctl
//
//
BOOL SyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned)
{
    OVERLAPPED overlapped;
    memset(&overlapped,0,sizeof(overlapped));
    overlapped.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!overlapped.hEvent)
    {
        return FALSE;
    }

    BOOL fResult = DeviceIoControl(handle, 
                                   ulIoctl, 
                                   pvInBuffer, 
                                   ulInSize, 
                                   pvOutBuffer, 
                                   ulOutSize, 
                                   pulBytesReturned, 
                                   &overlapped);

    if ((!fResult) && (ERROR_IO_PENDING == GetLastError())) 
    {
        // XXX Infinite is scary
        //
        if (WaitForSingleObject(overlapped.hEvent, INFINITE) != WAIT_FAILED)
        {
            fResult = TRUE;
        }
    }
    else if (!fResult)
    {
        if  (   (ulIoctl == IOCTL_KS_PROPERTY) 
            &&  (ulOutSize == 0)
            &&  (GetLastError() == ERROR_MORE_DATA)
            )
        {
            fResult = TRUE;
        }
        else
        {
            *pulBytesReturned = 0;
        }
    }

    CloseHandle(overlapped.hEvent);

    return fResult;
}

// GetSysAudioDeviceCount
//
BOOL GetSysAudioDeviceCount(
    HANDLE              hSysAudio,
    PULONG              pulDeviceCount)
{
    ULONG               ulBytesReturned;
    KSP_PIN             ksp;
    BOOL                fStatus;

    ksp.Property.Set   = KSPROPSETID_Sysaudio;
    ksp.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_COUNT;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = 0;
    ksp.Reserved       = 0;

    fStatus = Property(hSysAudio,
                       sizeof(ksp),
                       (PKSIDENTIFIER)&ksp,
                       sizeof(ULONG),
                       pulDeviceCount,
                       &ulBytesReturned);
    if ((!fStatus) || (ulBytesReturned < sizeof(ULONG)))
    {
        return FALSE;
    }

    return TRUE;
}


// SetDefaultDevice
//
// Set the default SysAudio device to the given index
//
BOOL SetSysAudioDevice(
    HANDLE              hSysAudio,
    ULONG               idxDevice)
{
    SYSAUDIO_INSTANCE_INFO  saInstInfo;
    ZeroMemory(&saInstInfo, sizeof(saInstInfo));

    saInstInfo.Property.Set     = KSPROPSETID_Sysaudio;
    saInstInfo.Property.Id      = KSPROPERTY_SYSAUDIO_INSTANCE_INFO;
    saInstInfo.Property.Flags   = KSPROPERTY_TYPE_SET;
    saInstInfo.Flags            = SYSAUDIO_FLAGS_DONT_COMBINE_PINS;
    saInstInfo.DeviceNumber     = idxDevice;

    return Property(hSysAudio,
                    sizeof(saInstInfo),
                    (PKSIDENTIFIER)&saInstInfo,
                    0,
                    NULL,
                    NULL);
}

// CreateVirtualSource
//
// Create a SysAudio virtual source for controlling volume on this device.
// 
BOOL CreateVirtualSource(
    HANDLE              hSysAudio, 
    PULONG              pulSourceIndex)
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE  CreateVirtualSource;

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;
    
    CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
    CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

    ULONG BytesReturned;

    BOOL fRet = Property(hSysAudio,
                         sizeof(CreateVirtualSource),
                         (PKSIDENTIFIER)&CreateVirtualSource,
                         sizeof(ULONG),
                         pulSourceIndex,
                         &BytesReturned);
    if (!fRet || BytesReturned != sizeof(ULONG)) 
    {
        return FALSE;
    }

    return TRUE;
}

// AttachVirtualSource
//
// Attach the given virtual source to the pin
//
BOOL AttachVirtualSource(
    HANDLE              hPin,
    ULONG               ulSourceIndex)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;

    AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
    AttachVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;

    AttachVirtualSource.MixerPinId = ulSourceIndex;
    AttachVirtualSource.Reserved = 0;

    return Property(hPin,
                    sizeof(AttachVirtualSource),
                    (PKSIDENTIFIER)&AttachVirtualSource,
                    sizeof(ulSourceIndex),
                    &ulSourceIndex,
                    NULL);
}

// FindGuidNode
//
// Give a handle to SysAudio, find the first node ID within the current device's topology having
// the given GUID.
//
// Returns the node ID or -1 if there is no synthesizer node.
//
int FindGuidNode(
    HANDLE              hSysAudio, 
    ULONG               ulPinId,
    REFGUID             rguid)
{
    KSPROPERTY ksProp;
    LPVOID pvProp;
    ULONG  ulProp;

    // Get node list
    //
    ZeroMemory(&ksProp, sizeof(ksProp));
    ksProp.Set  = KSPROPSETID_Topology;
    ksProp.Id   = KSPROPERTY_TOPOLOGY_NODES;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    if (!GetSizedProperty(hSysAudio, 
                          sizeof(ksProp),
                          &ksProp,
                          &pvProp,
                          &ulProp))
    {
        TraceI(0, "FindGuidNode: Could not get node topology list\n");
        return -1;
    }                                              

    if (ulProp < sizeof(KSMULTIPLE_ITEM))
    {
        TraceI(0, "FindGuidNode: Node list size smaller than header size!\n");
        LocalFree(pvProp);
        return -1;
    }

    PKSMULTIPLE_ITEM pksmiNodes = (PKSMULTIPLE_ITEM)pvProp;

    // Get connection list
    //
    ZeroMemory(&ksProp, sizeof(ksProp));
    ksProp.Set  = KSPROPSETID_Topology;
    ksProp.Id   = KSPROPERTY_TOPOLOGY_CONNECTIONS;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    if (!GetSizedProperty(hSysAudio, 
                          sizeof(ksProp),
                          &ksProp,
                          &pvProp,
                          &ulProp))
    {
        TraceI(0, "FindGuidNode: Could not get connection topology list\n");
        LocalFree(pksmiNodes);
        return -1;
    }                                              

    if (ulProp < sizeof(KSMULTIPLE_ITEM))
    {
        TraceI(0, "FindGuidNode: Connection list size smaller than header size!\n");
        LocalFree(pksmiNodes);
        LocalFree(pvProp);
        return -1;
    }

    PKSMULTIPLE_ITEM pksmiConnections = (PKSMULTIPLE_ITEM)pvProp;
    PKSTOPOLOGY_CONNECTION pConnection = PKSTOPOLOGY_CONNECTION(pksmiConnections + 1);
    ULONG idxNodeRet = -1;
    
    // Search connection list for pin ID & guid
    //
    for (ULONG idxConnection = 0; idxConnection < pksmiConnections->Count; ++idxConnection)
    {
        if (pConnection->FromNode == -1 && // filter node
            pConnection->FromNodePin == ulPinId) 
        {
            // REVIEW: walk the topology paths which start from this connection
            
            idxNodeRet = pConnection->ToNode;
        }
        else if (pConnection->ToNode == -1 &&
                 pConnection->ToNodePin == ulPinId)
        {
            idxNodeRet = pConnection->FromNode;
        }
        else 
        {
            idxNodeRet = -1;
        }                    

        if (idxNodeRet != -1)
        {
            ULONG idxNode;
            LPGUID guidNode = LPGUID(pksmiNodes + 1);

            // See if node for connection has the desired guid
            //
            for (idxNode = 0; idxNode < pksmiNodes->Count; ++idxNode)
            {
                if (idxNode == idxNodeRet)
                {
                    break;
                }

                guidNode = LPGUID(PBYTE(guidNode) + ((sizeof(GUID) + 7) & ~7));
            }

            if (idxNode == pksmiNodes->Count ||
                *guidNode != rguid)
            {
                idxNodeRet = -1;
            }
            else
            {
                break;
            }
        }

        pConnection = PKSTOPOLOGY_CONNECTION(PBYTE(pConnection) + ((sizeof(KSTOPOLOGY_CONNECTION) + 7) & ~7));
    }

    LocalFree(pksmiNodes);
    LocalFree(pksmiConnections);
    return idxNodeRet;
}

// GetFilterCaps
//
// Attempts to retrieve the filter caps for this synth filter.
//
BOOL GetFilterCaps(
    HANDLE              hSysAudio,
    ULONG               idxNode,
    PSYNTHCAPS          pcaps)
{
    KSP_NODE ksNodeProp;
    
    ZeroMemory(&ksNodeProp, sizeof(ksNodeProp));
    ksNodeProp.Property.Set     = KSPROPSETID_Synth;
    ksNodeProp.Property.Id      = KSPROPERTY_SYNTH_CAPS;
    ksNodeProp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksNodeProp.NodeId           = idxNode;

    if (!Property(hSysAudio,
                  sizeof(ksNodeProp),
                  (PKSPROPERTY)&ksNodeProp,
                  sizeof(SYNTHCAPS),
                  pcaps,
                  NULL))
    {
        TraceI(0, "Could not get caps\n");
        return FALSE;
    }

    return TRUE;    
}

// GetNumPinTypes
//
// Retrieve the number of supported pin types on the current SysAudio device.
// 
BOOL GetNumPinTypes(
    HANDLE              hSysAudio,
    PULONG              pulPinTypes)
{
    ULONG   BytesReturned;
    KSP_PIN ksp;
    BOOL    Status;
    
    ksp.Property.Set   = KSPROPSETID_Pin;
    ksp.Property.Id    = KSPROPERTY_PIN_CTYPES;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = 0;
    ksp.Reserved       = 0;

    Status = Property(hSysAudio,
                      sizeof(ksp),
                      (PKSIDENTIFIER)&ksp,
                      sizeof(ULONG),
                      pulPinTypes,
                      &BytesReturned);
    
    if ((!Status) || (BytesReturned < sizeof(ULONG)))
    {
        TraceI(0, "GetNumPinTypes failed\n");
        return FALSE;
    }
    
    return TRUE;
}


// PinSupportsInterface
//
// Given a pin, return TRUE if the given interface is supported. Assumes the
// default device on SysAudio.
//
BOOL PinSupportsInterface(
    HANDLE              hSysAudio,
    ULONG               ulPinId, 
    REFGUID             rguidInterface, 
    ULONG               ulId)
{
    KSP_PIN             ksp;
    PKSMULTIPLE_ITEM    pksmi; 
    ULONG               ulBytesReturned;

    ksp.Property.Set    = KSPROPSETID_Pin;
    ksp.Property.Id     = KSPROPERTY_PIN_INTERFACES;
    ksp.Property.Flags  = KSPROPERTY_TYPE_GET;
    ksp.PinId           = ulPinId;
    ksp.Reserved        = 0;

    if ( (!GetSizedProperty(hSysAudio,
                           sizeof(ksp),
                           (PKSIDENTIFIER)&ksp,
                           (void**)&pksmi,
                           &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(KSMULTIPLE_ITEM)))
    {
        TraceI(0, "PinSupportsInterface: GetSizedProperty failed!\n");
        return FALSE;
    }

    KSPIN_INTERFACE ksInterface;
    
    ksInterface.Set      = rguidInterface;
    ksInterface.Id       = ulId;
    ksInterface.Flags    = 0;

    PCHAR pchProperty = (PCHAR)(pksmi + 1);

    for (ULONG idxInterface = 0; idxInterface < pksmi->Count; ++idxInterface)
    {
        PKSIDENTIFIER pksi = (PKSIDENTIFIER)pchProperty;
        if (IsEqualInterface(pksi, &ksInterface))
        {
            LocalFree(pksmi);
            return TRUE;
        }

        pchProperty += ((sizeof(KSIDENTIFIER) + 7) & ~7);
    }

    LocalFree(pksmi);
    return FALSE;
}

// PinSupportsDataRange
//
BOOL PinSupportsDataRange(
    HANDLE              hSysAudio, 
    ULONG               ulPinId, 
    REFGUID             rguidFormat, 
    REFGUID             rguidSubformat)
{
    KSP_PIN             ksp;
    PKSMULTIPLE_ITEM    pksmi;
    ULONG               ulBytesReturned;

    ksp.Property.Set    = KSPROPSETID_Pin;
    ksp.Property.Id     = KSPROPERTY_PIN_DATARANGES;
    ksp.Property.Flags  = KSPROPERTY_TYPE_GET;
    ksp.PinId           = ulPinId;
    ksp.Reserved        = 0;

    if ((!GetSizedProperty(hSysAudio,
                           sizeof(ksp),
                           (PKSIDENTIFIER)&ksp,
                           (void**)&pksmi,
                           &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(KSMULTIPLE_ITEM)))
    {
        TraceI(0, "PinSupportsInterface: GetSizedProperty failed!\n");
        return FALSE;
    }

    PCHAR pchPropData = (PCHAR)(pksmi + 1);

    for (ULONG idxDataRange = 0; idxDataRange < pksmi->Count; ++idxDataRange)
    {
        PKSDATARANGE pksdr = (PKSDATARANGE)(pchPropData);

        if (IsEqualGUID(pksdr->MajorFormat, rguidFormat) &&
            IsEqualGUID(pksdr->SubFormat,   rguidSubformat))
        {
            LocalFree(pksmi);
            return TRUE;
        }

        pchPropData += pksdr->Alignment;
    }

    LocalFree(pksmi);
    return FALSE;
}

// PinGetDataFlow
// 
BOOL PinGetDataFlow(
    HANDLE              hSysAudio, 
    ULONG               ulPinId, 
    PKSPIN_DATAFLOW     pkspdf)
{
    KSP_PIN             ksp;
    BOOL                Status;
    ULONG               ulBytesReturned;

    ksp.Property.Set   = KSPROPSETID_Pin;
    ksp.Property.Id    = KSPROPERTY_PIN_DATAFLOW;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = ulPinId;
    ksp.Reserved       = 0;

    Status = Property(hSysAudio,
                      sizeof(ksp),
                      (PKSIDENTIFIER)&ksp,
                      sizeof(KSPIN_DATAFLOW),
                      pkspdf,
                      &ulBytesReturned);

    if ((!Status) || (ulBytesReturned < sizeof(KSPIN_DATAFLOW)))
    {
        TraceI(0, "PinGetDataFlow: Property failed!\n");
        return FALSE;
    }

    return TRUE;
}

// GetDeviceFriendlyName
//
// Assumes the default device is already set.
//
BOOL GetDeviceFriendlyName(
    HANDLE              hSysAudio, 
    ULONG               ulDeviceIndex,
    PWCHAR              pwch, 
    ULONG               cbwch)
{
    KSPROPERTYDEVICEINDEX   kspdi;

    if (cbwch < sizeof(WCHAR))
    {
        return FALSE;
    }

    kspdi.Property.Set   = KSPROPSETID_Sysaudio;
    kspdi.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME;
    kspdi.Property.Flags = KSPROPERTY_TYPE_GET;
    kspdi.DeviceIndex    = ulDeviceIndex;

    if (!Property(hSysAudio,
                  sizeof(kspdi),
                  (PKSIDENTIFIER)&kspdi,
                  cbwch,
                  pwch,
                  NULL))
    {
        return FALSE;
    }

    pwch[(cbwch / sizeof(WCHAR)) - 1] = ((WCHAR)0);

    return TRUE;
}

// GetDeviceFriendlyName
//
// Assumes the default device is already set.
//
BOOL GetDeviceInterfaceName(
    HANDLE              hSysAudio, 
    ULONG               ulDeviceIndex,
    PWCHAR              pwch, 
    ULONG               cbwch)
{
    KSPROPERTYDEVICEINDEX   kspdi;

    if (cbwch < sizeof(WCHAR))
    {
        return FALSE;
    }

    kspdi.Property.Set   = KSPROPSETID_Sysaudio;
    kspdi.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME;
    kspdi.Property.Flags = KSPROPERTY_TYPE_GET;
    kspdi.DeviceIndex    = ulDeviceIndex;

    if (!Property(hSysAudio,
                  sizeof(kspdi),
                  (PKSIDENTIFIER)&kspdi,
                  cbwch,
                  pwch,
                  NULL))
    {
        return FALSE;
    }

    pwch[(cbwch / sizeof(WCHAR)) - 1] = ((WCHAR)0);

    return TRUE;
}

#ifndef XBOX

// GetPreferredAudioPlaybackDevice
//
//
BOOL InstanceIdOfPreferredAudioDevice(char **ppInstanceId)
{
    // Determine the device ID of the preferred audio device
    //
    int iDeviceId = GetPreferredAudioPlaybackDeviceId();
    if (iDeviceId == -1)
    {
        TraceI(0, "Could not determine preferred device ID\n");
        return FALSE;
    }
    
    return WaveOutIdToInstanceId(iDeviceId, ppInstanceId);
}



#ifdef WINNT

// GetPreferredAudioPlaybackDeviceId
//
// Returns the WinMM device ID of the preferred audio playback device, or -1
// if the device could not be found.
//
static int GetPreferredAudioPlaybackDeviceId()
{
    MMRESULT    mmr;
    UINT        uPreferredId;
    DWORD       dwFlags;

    // Use the new improved NT WinMM service for determining the preferred 
    // audio device 
    //
    mmr = waveOutMessage((HWAVEOUT)-1,        // Mapper
                         DRVM_MAPPER_PREFERRED_GET,
                         (DWORD_PTR)&uPreferredId,
                         (DWORD_PTR)&dwFlags);
    if (mmr != MMSYSERR_NOERROR)
    {
        TraceI(0, "GetPreferredAudioPlaybackDeviceId: Mapper returned %d\n", mmr);
        return -1;
    }

    // May still be -1 if there is no preferred device
    //
    return (int)uPreferredId;
}

#else /* Win9x */

// GetPreferredAudioPlaybackDeviceId
//
// Returns the WinMM device ID of the preferred audio playback device, or -1
// if the device could not be found.
//
// Works on both Win9x.
//
#define REGSTR_PREFERRED_AUDIO  "Software\\Microsoft\\Multimedia\\Sound Mapper"
#define PLAYBACK                "Playback"

static int GetPreferredAudioDeviceReg();
static int GetFirstMappableDevice();

// GetPreferredAudioPlaybackDeviceId
//
// Determine the preferred audio playback device as a wave out device ID.
// If the registry has been set, use that setting;
// otherwise, use the first mappable device
//
static int GetPreferredAudioPlaybackDeviceId()
{
    int id = GetPreferredAudioDeviceReg();

    if (id != -1) 
    {
        return id;
    }

    // If the registry method failed, it could be because the control panel
    // has not been run yet and there is nothing written in the registry.
    // In this case the mapper picks the first mappable device.
    //
    // This will return -1 if there are no mappable devices.
    //
    return GetFirstMappableDevice();
}

// GetPreferredAudioDeviceReg
//
// Find the preferred wave out device in the registry if it has been written
// there.
//
static int GetPreferredAudioDeviceReg()
{
    HKEY hk;

    // Save how many wave devices are loaded. If none, no need to continue.
    //
    int nWaveOutDevs = waveOutGetNumDevs();
    if (nWaveOutDevs == 0) 
    {
        return -1;
    }

    // Get the preferred audio playback device from the registry. This is the 
    // name of the audio device.
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     REGSTR_PREFERRED_AUDIO,
                     0,                         // Reserved
                     KEY_READ,
                     &hk) != ERROR_SUCCESS)
    {
        return -1;
    }        

    CHAR szPName[MAXPNAMELEN];
    DWORD cb;
    LONG lResult;

    cb = sizeof(szPName);
    lResult = RegQueryValueEx(hk,
                              PLAYBACK,
                              NULL,                   // Reserved
                              NULL,                   // Type
                              (LPBYTE)szPName,
                              &cb) != ERROR_SUCCESS;
    RegCloseKey(hk);

    if (lResult != ERROR_SUCCESS)
    {
        return -1;
    }

    // Loop through all the loaded wave devices and look for one with the same name
    // as the preferred device name.
    //
    int iWaveOutDev;
    WAVEOUTCAPS woc;

    for (iWaveOutDev = 0; iWaveOutDev < nWaveOutDevs; iWaveOutDev++)
    {
        MMRESULT mmr = waveOutGetDevCaps(iWaveOutDev, &woc, sizeof(woc));
        if (mmr != MMSYSERR_NOERROR) 
        {
            continue;
        }            

        if (!strcmp(szPName, woc.szPname))
        {
            break;
        }
    }

    if (iWaveOutDev >= nWaveOutDevs)
    {
        return -1;
    }

    return iWaveOutDev;
}

// GetFirstMappableDevice
//
// Find the first mappable wave out device, which is what wave mapper is supposed
// to do in the absence of registry settings.
//
static int GetFirstMappableDevice()
{
    int nWaveOutDevs = waveOutGetNumDevs();

    if (nWaveOutDevs == 0) 
    {
        return -1;
    }

    for (int iDeviceId = 0; iDeviceId < nWaveOutDevs; iDeviceId++)
    {
        MMRESULT mmr = waveOutMessage((HWAVEOUT)iDeviceId,
                                      DRV_QUERYMAPPABLE,
                                      0, 0);
        if (mmr == MMSYSERR_NOERROR)
        {
            // This device ID is mappable
            //
            return iDeviceId;
        }                                          
    }
    
    return -1;
}

#endif /* Win9x */

#ifdef WINNT
static BOOL GetDINameFromWaveOutId(int iDeviceId, char **ppDIName);

static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId)
{
    char *pstrDIName;

    if (!GetDINameFromWaveOutId(iDeviceId, &pstrDIName))
    {
        return FALSE;
    }

    BOOL bRet = DINameToInstanceId(pstrDIName, ppInstanceId);

    delete[] pstrDIName;
    return bRet;
}

// GetDINameFromWaveOutId
//
// Given a WaveOut device ID, determine the matching device interface
// name.
//
static BOOL GetDINameFromWaveOutId(int iDeviceId, char **ppDIName)
{
    ULONG cb;
    
    // Ask how many bytes (NOT WCHAR's the name is)
    //
    MMRESULT mmr = waveOutMessage((HWAVEOUT)(UINT64)iDeviceId,
                                  DRV_QUERYDEVICEINTERFACESIZE,
                                  (DWORD_PTR)(PULONG)&cb,
                                  0);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    // Allocate and ask for the name
    //
    ULONG  cwch = (cb + sizeof(WCHAR) - 1) / sizeof(WCHAR);
    PWCHAR pwstrDeviceInterfaceName = new WCHAR[cwch];
    if (pwstrDeviceInterfaceName == NULL)
    {
        return FALSE;
    }

    mmr = waveOutMessage((HWAVEOUT)(UINT64)iDeviceId,
                         DRV_QUERYDEVICEINTERFACE,
                         (DWORD_PTR)pwstrDeviceInterfaceName,
                         cb);
    if (mmr != MMSYSERR_NOERROR)
    {
        delete[] pwstrDeviceInterfaceName;
        return FALSE;
    }

    // We want to name as a multibyte string
    //    
    LPSTR pstrDeviceInterfaceName = new CHAR[cwch];
    if (pstrDeviceInterfaceName == NULL)
    {
        delete[] pwstrDeviceInterfaceName;
        return FALSE;
    }

    wcstombs(pstrDeviceInterfaceName, pwstrDeviceInterfaceName, cwch);

    // Clean up and return it
    //
    *ppDIName = pstrDeviceInterfaceName;
    delete[] pwstrDeviceInterfaceName;

    return TRUE;
}

#else /* Win9x */
static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId)
{
    BOOL bRet = FALSE;

    MMRESULT mmr;
    char szDrvEntry[256];
    char szKey[512];
    HKEY hk;
    DWORD cb;

    *ppInstanceId = NULL;

    mmr = waveOutMessage((HWAVEOUT)iDeviceId,
                         DRV_QUERYDRVENTRY,
                         (DWORD)(LPSTR)szDrvEntry,
                         sizeof(szDrvEntry));
    if (mmr) 
    {
        TraceI(1, "DRV_QUERYDRVENTRY: %d\n", mmr);
        return FALSE;
    }

    wsprintf(szKey, "%s\\%s",
             REGSTR_PATH_MEDIARESOURCES TEXT("\\Wave"),
             szDrvEntry);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szKey,
                     0,
                     KEY_READ,
                     &hk) != ERROR_SUCCESS)
    {
        TraceI(1, "WaveOutIdToInstanceId: RegOpenKeyEx failed\n");
        TraceI(2, "[%s]\n", szKey);
        return FALSE;
    }

    cb = sizeof(szDrvEntry);
    if (RegQueryValueEx(hk,
                        "DeviceID",
                        NULL,
                        NULL,
                        (LPBYTE)szDrvEntry,
                        &cb) == ERROR_SUCCESS)
    {
        *ppInstanceId = new char[strlen(szDrvEntry) + 1];
        if (*ppInstanceId) 
        {
            strcpy(*ppInstanceId, szDrvEntry);
            bRet = TRUE;
        }
    }
    else
    {
        TraceI(1, "WaveOutIdToInstanceId: No DeviceID key, not WDM device\n");
    }

    RegCloseKey(hk);

    return bRet;
}
#endif /* Win9x */



// DINameToInstanceId
//
// Determine the device interface which implements this 
// ID
//
// Walk device list looking for the interface name.
//
//

// The first 4 characters of the DI name are different between setupapi and
// sysaudio, even though the paths match (\\?\ versus \??\). This is how
// much to ignore when matching the paths.
//
#define DI_PATH_PREFIX_LEN 4
static char gszDosDevices[] = "\\DosDevices\\";

BOOL DINameToInstanceId(char *pstrDIName, char **ppInstanceId)
{
    BOOL     bRet = FALSE;

    SetupAPI suwrap;
    long     lErr;
	HDEVINFO hDevInfo;

    if (!suwrap.IsValid())
    {
        return FALSE;
    }

#ifdef WINNT
    // We can get the empty string here, which obviously
    // matches nothing.
    //
    if (strlen(pstrDIName) < DI_PATH_PREFIX_LEN)
    {
        return FALSE;
    }
    pstrDIName += DI_PATH_PREFIX_LEN;
#else
    if (!_strnicmp(pstrDIName, "\\DosDevices\\", strlen(gszDosDevices)))
    {
        pstrDIName += strlen(gszDosDevices);
    }
    else if (!_strnicmp(pstrDIName, "\\\\.\\", DI_PATH_PREFIX_LEN))
    {
        // Already prepended, don't want to see that.
        pstrDIName += DI_PATH_PREFIX_LEN;
    }
#endif       

    *ppInstanceId = NULL;

    if (strlen(pstrDIName) < DI_PATH_PREFIX_LEN)
    {
        return FALSE;
    }
	
	hDevInfo = suwrap.SetupDiGetClassDevs(const_cast<GUID*>(&KSCATEGORY_AUDIO),
										  NULL,
										  NULL,
										  DIGCF_DEVICEINTERFACE);
    if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
    {
        TraceI(0, "SetupDiGetClassDevs %d\n", GetLastError());
        return FALSE;
    }

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];

	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = 
	    (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

    SP_DEVINFO_DATA DevInfo;
    DevInfo.cbSize = sizeof(DevInfo);

    DWORD   dwRequiredInstanceIdSize;

    for (DWORD MemberIndex = 0; ; MemberIndex++)
    {
	    SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	    DevInterfaceData.cbSize = sizeof(DevInterfaceData);

        if (!suwrap.SetupDiEnumDeviceInterfaces(hDevInfo,
                                                NULL,
                                                const_cast<GUID*>(&KSCATEGORY_AUDIO),
                                                MemberIndex,
                                                &DevInterfaceData))
        {
            TraceI(0, "SetupDiEnumDeviceInterfaces %d\n", GetLastError());
            break;
        }

        if (!suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                                    &DevInterfaceData,
                                                    pDevInterfaceDetails,
        								  	  	    sizeof(rgbStorage), 
 										            NULL, 
 										            &DevInfo))
        {
            TraceI(0, "SetupDiGetDeviceInterfaceDetail %d\n", GetLastError());
            break;
        }
    
        // Look for a case insensitive match, ignoring the first 
        // DI_PATH_PREFIX_LEN characters.
        //
        if (strlen(pDevInterfaceDetails->DevicePath) < DI_PATH_PREFIX_LEN)
        {
            continue;
        }
                    
        if (_stricmp(pDevInterfaceDetails->DevicePath + DI_PATH_PREFIX_LEN, 
                     pstrDIName))
        {
            continue;
        }

        // We have a match. Get the device instance ID
        //
        lErr = 0;
        char c;
        suwrap.SetupDiGetDeviceInstanceId(hDevInfo,
                                          &DevInfo,
                                          &c,
                                          sizeof(c),
                                          &dwRequiredInstanceIdSize);

        lErr = GetLastError();
        if (lErr != ERROR_INSUFFICIENT_BUFFER)
        {   
            TraceI(0, "SetupDiGetDeviceInstanceId %d\n", lErr);
            break;
        }

        *ppInstanceId = new char[dwRequiredInstanceIdSize];
        if (!*ppInstanceId)
        {
            TraceI(0, "Out of memory determining preferred audio device\n");
            break;
        }

        if (!suwrap.SetupDiGetDeviceInstanceId(hDevInfo,
                                               &DevInfo,
                                               *ppInstanceId,
                                               dwRequiredInstanceIdSize,
                                               &dwRequiredInstanceIdSize))
        {
            TraceI(0, "SetupDiGetDeviceInstanceId %d\n", GetLastError());
            break;
        }

        bRet = TRUE;
        break;
    }                                              

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    if (!bRet && *ppInstanceId)
    {
        delete[] *ppInstanceId;
        *ppInstanceId = NULL;
    }
    
    return bRet;        
}

#endif // ! XBOX

#ifdef DBG
void _TraceIGuid(int iLevel, GUID *pGUID)
{
    char sz[256];
    char *psz = sz;
    
    psz += sprintf(psz, "%08X-%04X-%04X-", pGUID->Data1, pGUID->Data2, pGUID->Data3);
    for (int i = 0; i < 8; i++) 
    {
        psz += sprintf(psz, "%02X", pGUID->Data4[i]);
        if (i < 7)
        {
            *psz++ = '-';
        }
    }    

    TraceI(iLevel, sz);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\cmphlp.inc ===
;***
;cmphlp.inc - include to aid in generating compiler helpers
;
;	Copyright (c) 1987-1998 Microsoft Corporation
;
;Purpose:
;	This file is a compiler helper include to aid in generating
;	backwards compatible compiler helpers.
;
;*******************************************************************************


callnahlpr MACRO nm		;;call non-assigning helper
if	sizeC
	push	cs
	call	near ptr __aF&nm
else
	call	near ptr __aN&nm
endif
ENDM


DFLT	MACRO	tag,prfx,nm
externP _a&prfx&tag&nm
cProc	_&tag&nm,<PUBLIC>,<>
cBegin	nogen
	jmp	_a&prfx&tag&nm
cEnd	nogen
ENDM

DFLT2	MACRO	tag,prfx,nm
externP _a&prfx&tag&nm
cProc	_&tag&u&nm,<PUBLIC>,<>
cBegin	nogen
cEnd	nogen
cProc	_&tag&nm,<PUBLIC>,<>
cBegin	nogen
	jmp	_a&prfx&tag&nm
cEnd	nogen
ENDM

ASGN	MACRO	nm		;;macro to fix up entry sequence of non
				;;assigning code helpers
if	sizeC
cProc	_aF&nm,<PUBLIC>,<>
cBegin

else
cProc	_aN&nm,<PUBLIC>,<>
cBegin
endif
ENDM



aASGN	MACRO	nm		;;macro to fix up entry sequence of assigning
				;;code helpers
if	memL	eq 1
externP _aF&nm
cProc	_aFFa&nm,<PUBLIC>,<>
cBegin
endif
if	memM	eq 1
externP _aF&nm
cProc	_aFNa&nm,<PUBLIC>,<>
cBegin
endif
if	memC	eq 1
externP _aN&nm
cProc	_aNFa&nm,<PUBLIC>,<>
cBegin
endif
if	memS	eq 1
externP _aN&nm
cProc	_aNNa&nm,<PUBLIC>,<>
cBegin
endif
ENDM


OLDSLEAZ MACRO

ifdef	lhdiff
OLDASGN hdiff
endif

ifdef	llshl
OLDASGN lshl
endif

ifdef	llshr
OLDASGN lshr
endif

ifdef	lulshr
OLDASGN ulshr
endif

ifdef	lldiv
OLDASGN ldiv
endif

ifdef	llmul
OLDASGN2 lmul
endif

ifdef	llrem
OLDASGN lrem
endif

ifdef	luldiv
OLDASGN uldiv
endif

ifdef	lulrem
OLDASGN ulrem
endif
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1991-1998 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//  win.ini
//  [debug]
//  MIDIMAP=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        "debug"        // section name for 
#define  ASSERT_BREAK         "AssertBreak"  // Key for break on assert
#define  DEBUG_MODULE_NAME    "DMUSIC16"     // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255            // max line length (bytes)

#define  K_DEFAULT_LOGMEM     32
#define  K_MAX_LOGMEM         63
    
#define  DRV_ENABLE_DEBUG     (DRV_USER+1)   // Enable/disable debug message
#define  DRV_SET_DEBUG_LEVEL  (DRV_USER+2)   // Message to set the debug level

#define WM_DEBUGUPDATE          (WM_USER+1000)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI DbgAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI DbgRegisterCallback(HWND hWnd);
    BOOL WINAPI DbgGetNextLogEntry(LPSTR lpstrBuffer, UINT cbBuffer);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : DbgAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\dmhelp.asm ===
; Copyright (c) 1998 Microsoft Corporation
;
; @Doc DMusic16
;
; @Module  DMHelp.asm - Helper functions |
;
; Thunk helpers for DMusic16.DLL
;

        page    ,132

        TITLE   $dos\usa\dmhelp.asm

        .386
        OPTION READONLY
        OPTION OLDSTRUCTS

        OPTION SEGMENT:USE16
        .model LARGE,PASCAL

;?MEDIUM=1
;?QUIET=1

externDef TileBuffer:far16
externDef UntileBuffer:far16
externDef OutputDebugString:far16

;===========================================================================
;
; 64-bit integer struct as passed in from C routines
;
; This must match the definition in dmusic16.h
;
;
;===========================================================================
QUADWORD	struc
qwLow		dd			?
qwHigh		dd			?
QUADWORD	ends

        .code dmhelp


;===========================================================================

EAXtoDXAX       macro
        shld    edx, eax, 16            ; move HIWORD(eax) to dx
endm

DXAXtoEAX       macro
        ror     eax, 16                 ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax, edx, 16            ; move LOWORD(edx) to HIWORD(eax)
endm

;===========================================================================
public dmTileBuffer
public dmUntileBuffer
public QuadwordDiv

externDef       __FLATDS:abs

_DATA SEGMENT WORD USE16 PUBLIC 'DATA'
FlatData                dw      __FLATDS
ifdef DEBUG
szNotOwner              db      'Critical section released by other than owner', 0
endif
_DATA ENDS

;===========================================================================
;
; @func DWORD | dmTileBuffer | Tile a 32-bit linear address as selectors
;
; @comm 
;
; Take the 32-bit virtual address in <p dwFlatMemory> of length <p dwLength> and create
; tiled selectors for it. This is used to pass a region of memory to a 16 bit thunk
; as a huge pointer.
;
; @rdesc
; 
; Returns a DWORD of tiling information, or 0 if the tiling could not be completed.
; The tiling information consists of a 16 bit selector in the high word and the
; number of tiled selectors in the low word. To make a 16:16 pointer to the 
; block of memory, mask the low 16 bits of the tiling information to zero.
;
; @parm DWORD | dwFlatMemory | The linear address of the memory to tile
;
; @parm DWORD | dwLength | The length in bytes of the region to tile
;
align
dmTileBuffer proc far16 public,
        dwFlatMemory:dword, dwLength:dword
        
        push    edi
        push    esi

        mov     eax, dwFlatMemory
        mov     ecx, dwLength
        call    TileBuffer
        mov     eax, ecx
        EAXtoDXAX

        pop     esi
        pop     edi
        ret
dmTileBuffer endp

;===========================================================================
;
; @func VOID | dmUntileBuffer | Untile a buffer
;
; @comm
;
; Free the tiled selectors allocated by dmTileBuffer. The buffer must have
; been previously tiles with <f dmTileBuffer>.
;
; @parm DWORD | dwTilingInfo | The tiling info returned by a previous call 
; to <f dmTileBuffer>.
;
align
dmUntileBuffer proc far16 public,
        dwTilingInfo:dword

        push    esi
        push    edi
        mov     ecx, dwTilingInfo
        call    UntileBuffer
        pop     edi
        pop     esi
        ret
dmUntileBuffer endp

;===========================================================================
;
; @func VOID PASCAL |  InitializeCriticalSection | Initialize a critical section
;
; @comm
;
; Initialize the critical section to not-in.
;
; @parm LPWORD | lpwCritSect | The critical section to initialize.
;
align
InitializeCriticalSection proc far16 public,
        lpwCritSect:dword

        push    es
        push    di

        les     di, [lpwCritSect]
        mov     word ptr es:[di], 1

        pop     di
        pop     es
        ret

InitializeCriticalSection endp

;===========================================================================
;
; @func WORD PASCAL | EnterCriticalSection | Enter a critical section
;
; @comm
;
; If fBlocking is set, then spin until we can get the critical section.
; Otherwise, return failure if we could not get it. 
;
; @rdesc
; Returns 
;  0 if we did not get the critical section
;  A non-zero ID if we did get the critical section
;
; @parm LPWORD | lpwCritSect | A pointer to the critical section to enter
; @parm WORD | fBlocking | A flag to indicate that the function should block if the 
; critical section is not immediately available
;
align
EnterCriticalSection proc far16 public,
        lpwCritSect:dword,
        fBlocking:word
        
        push    es
        push    di

        les     di, [lpwCritSect]       ; -> critical section
        mov     cx, [fBlocking]

ecs_check:
        dec     word ptr es:[di]        ; 1 -> 0 means we got it
                                        ; atomic on non-MP 
        jz      short ecs_success

        inc     word ptr es:[di]        ; Return to previous state

        or      cx, cx                  ; Blocking?
        jnz     short ecs_check         ; Yes

        xor     ax, ax                  ; Non-blocking and failed
        jmp     ecs_done

ecs_success: 
        mov     ax, 1

ecs_done:
        pop     di
        pop     es
        ret

EnterCriticalSection endp

;===========================================================================
;
; @func VOID PASCAL | LeaveCriticalSection | Leave a critical section
;
; @comm
;
; Leave the critical section. wCritSectID must be the critical section ID returned
; by the matching call to <f EnterCriticalSection> (used to verify nesting in debug
; versions).
;
; @parm LPWORD | lpwCritSect | The critical section to leave
;
align
LeaveCriticalSection proc far16 public,
        lpwCritSect:dword
                
        push    es
        push    di

        les     di, [lpwCritSect]       ; -> critical section
        inc     word ptr es:[di]        ; Reset to default value of 1

        pop     di
        pop     es
        ret

LeaveCriticalSection endp

;===========================================================================
;
; @func WORD PASCAL | DisableInterrupts | Disable interrupts
;
; @comm
;
; Disable interrupts and return the previous status for a call to
; <f RestoreInterrupts>
; 
; @rdesc
;
; Returns the previous state of the interrupt flag
;
;
DisableInterrupts proc far16 public
        
        pushf
        pop     ax                      ; Get state
        and     ax, 0200h               ; Already disabled?
        jz      short @F                ; Don't do it again
        cli
@@:
        ret

DisableInterrupts endp

;===========================================================================
;
; @func VOID PASCAL | RestoreInterrupts | Restore the interrupt state
;
; @comm
;
; Restore interrupts if they were enabled when <f DisableInterrupts> was
; called.
;
; @parm WORD | wIntStat | The previous interrupt state as returned from a 
; call to <f DisableInterrupts> 
;
RestoreInterrupts proc far16 public,
        wIntStat : word
        
        mov     ax, [wIntStat]          ; Previous state
        test    ax, 0200h               ; Enabled before?
        jz      short @F                ; No, don't re-enable now
        sti
@@:
        ret

RestoreInterrupts endp

;===========================================================================
;
; @func WORD PASCAL | InterlockedIncrement | Increment the given word
; atomically and return the result.
;
; @comm
;
; Disable interrupts to guarantee increment-and-read as an atomic 
; operation.
;
; @parm LPWORD | lpw | The word to increment.
;
InterlockedIncrement proc far16 public,
        lpw : dword
        
        pushf
        pop     cx
        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        cli                             ; Yes, disable
@@:
        les     bx, [lpw]   
        inc     word ptr es:[bx]
        mov     ax, word ptr es:[bx]

        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        sti                             ; Yes, reenable
@@:
        ret

InterlockedIncrement endp

;===========================================================================
;
; @func WORD PASCAL | InterlockedDecrement | Decrement the given word
; atomically and return the result.
;
; @comm
;
; Disable interrupts to guarantee decrement-and-read as an atomic 
; operation.
;
; @parm LPWORD | lpw | The word to decrement.
;
InterlockedDecrement proc far16 public,
        lpw : dword
        
        pushf
        pop     cx
        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        cli                             ; Yes, disable
@@:
        les     bx, [lpw]   
        dec     word ptr es:[bx]
        mov     ax, word ptr es:[bx]

        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        sti                             ; Yes, reenable
@@:
        ret

InterlockedDecrement endp

;===========================================================================
;
; @func void PASCAL | QuadwordMul | Multiply using 64-bit precision
;
; @comm
;
; Multiply the two 32-bit numbers in <p m1> and <p m2> giving a 64-bit result
; in <p lpqwResult>.
;
; @rdesc 
; Returns m1 * m2
;
; @parm DWORD | m1 | First multiplicand
; @parm DWORD | m2 | Second multiplicand
; @parm LPQUADWORD | lpqwResult | 64-bit result
;
QuadwordMul proc far16 public,
        m1 : dword,
        m2 : dword,
        lpqwResult : dword

        mov     edx, [m1]
        mov     eax, [m2]
        mul     edx

        les     bx, [lpqwResult]
        mov     es:[bx.qwLow], eax
        mov     es:[bx.qwHigh], edx

        ret
QuadwordMul endp

;===========================================================================
;
; @func DWORD PASCAL | QuadwordDiv | Divide using 64-bit precision
;
; @comm
;
; Divide the 64-bit number in <p ull> by the 32-bit number in <p dwDivisor> and
; return the result. May throw a divide by zero exception.
;
; @rdesc 
; Returns ull / dwDivisor
;
; @parm QUADWORD | ull | The unsigned long dividend
; @parm DWORD | dwDivisor | The divisor
;
;
QuadwordDiv proc far16 public,
        qwDividend : QUADWORD,
        dwDivisor : dword

        mov     edx, [qwDividend.qwHigh]
        mov     eax, [qwDividend.qwLow]
        mov     ebx, [dwDivisor]
        
        div     ebx
        
        ; Result in eax, needs to be dx:ax for 16-bit code

        ror     eax, 16
        mov     dx, ax
        ror     eax, 16
        
        ret
QuadwordDiv endp

;===========================================================================
;
; @func DWORD PASCAL | QuadwordLT | Compare two quadwords for less than (unsigned)
;
; @rdesc 
; Returns TRUE if qwLValue < qwRValue
;
; @parm QUADWORD | qwLValue | The first operand of less-than
; @parm QUADWORD | qwRValue | The second operand of less-than
;
;
QuadwordLT proc far16 public,
		qwLValue : QUADWORD,
		qwRValue : QUADWORD

		mov		ebx, [qwLValue.qwHigh]
		sub		ebx, [qwRValue.qwHigh]
		jz 		short @F
		sbb		eax, eax
		ret
		
@@:		mov		ebx, [qwLValue.qwLow]
		sub		ebx, [qwRValue.qwLow]
		sbb		eax, eax
		ret			
QuadwordLT endp
         
;===========================================================================
;
; @func DWORD PASCAL | QuadwordAdd | Add two unsigned quadwords
;
; @parm QUADWORD | qwOp1 | The first operand 
; @parm QUADWORD | qwOp2 | The second operand
; @parm LPQUADWORD | lpwqResult | The result
;
;
QuadwordAdd proc far16 public,
		qwOp1 : QUADWORD,
		qwOp2 : QUADWORD,
		lpdwResult : DWORD

		mov		eax, [qwOp1.qwLow]
		add		eax, [qwOp2.qwLow]
		mov		edx, [qwOp1.qwHigh]
		adc		edx, [qwOp2.qwHigh]
		les		bx, [lpdwResult]
		mov		es:[bx.qwLow], eax
		mov		es:[bx.qwHigh], edx

		ret			
QuadwordAdd endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\device.c ===
/*
 * @Doc DMusic16
 *
 * @Module Device.c - Device management routines |
 *
 * This module manages handles and handle instances to the legacy MIDI device.
 *
 * Each open device is represented by a handle (which is 
 * an <c OPENHANDLE> struct). This struct contains all of the information
 * concerning the state of the device, including a reference count of the
 * number of clients using the device.
 *
 * Each client use of one device is represented by a handle instance (which
 * is an <c OPENHANDLINSTANCE> struct). A near pointer to this struct is
 * the actual handle seen by the client. These handle instances are used
 * to hold any client-specific information, and to dereference client
 * handles to the proper <c OPENHANDLE> struct.
 *
 * Currently we support multiple clients on the same output device but
 * only one client per input device.
 *
 * @globalv NPLINKNODE | gOpenHandleInstanceList | The master list of all
 * open handle instances.
 *
 * @globalv NPLINKNODE | gOpenHandleList | The master list of all open
 * handles.
 *
 * @globalv UINT | gcOpenInputDevices | A reference count of open MIDI
 * in devices.
 *
 * @globalv UINT | gcOpenOutputDevices | A reference count of open MIDI
 * out devices.
 */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

NPLINKNODE gOpenHandleInstanceList;  
NPLINKNODE gOpenHandleList;          
UINT gcOpenInputDevices;             
UINT gcOpenOutputDevices;            

STATIC VOID PASCAL UpdateSegmentLocks(BOOL fIsOutput);

#pragma alloc_text(INIT_TEXT, DeviceOnLoad)
#pragma alloc_text(FIX_COMM_TEXT, IsValidHandle)

/* @func Called at DLL LibInit 
 *
 * @comm
 *
 * Initialize the handle lists to empty and clear the device reference counts.
 */
VOID PASCAL
DeviceOnLoad(VOID)
{
   gOpenHandleInstanceList = NULL;
   gOpenHandleList = NULL;

   gcOpenInputDevices = 0;
   gcOpenOutputDevices = 0;
}

/* @func Open a device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * This function allocates an <c OPENHANDLEINSTANCE> struct on behalf of the caller.
 * If the requested device is already open and is an output device, the device's
 * reference count will be incremented an no other action is taken. If the requested
 * device is already open and is an input device, then the open will fail.
 *
 * If a non-DirectMusic application has the requested device open, then the
 * open will fail regardless of device type.
 *
 * If this open is the first input or output device opened, then it will
 * page lock the appropriate segments containing callback code and data.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_NOMEM | If there was insufficient memory to allocate
 * the tracking structure.
 *
 * @flag MMSYSERR_BADDEVICEID | If the given device ID was out of range.
 * @flag MMSYSERR_ALLOCATED | The specified device is already open.
 *
 */
MMRESULT WINAPI
OpenLegacyDevice(
    UINT id,            /* @parm MMSYSTEM id of device to open */
    BOOL fIsOutput,     /* @parm TRUE if this is an output device */
    BOOL fShare,        /* @parm TRUE if the device should be shareable */
    LPHANDLE ph)        /* @parm Pointer where handle will be returned */
                        /*       on success. */
{
    NPOPENHANDLEINSTANCE pohi;
    NPLINKNODE pLink;
    NPOPENHANDLE poh;
    MMRESULT mmr;

    DPF(2, "OpenLegacyDevice(%d,%s,%s)",
        (UINT)id,
        (LPSTR)(fIsOutput ? "Output" : "Input"),
        (LPSTR)(fShare ? "Shared" : "Exclusive"));
        
    *ph = (HANDLE)NULL;

    /* Sharing capture device is not allowed.
     */
    if ((!fIsOutput) && (fShare))
    {
        return MMSYSERR_ALLOCATED;
    }

    /* Make sure id is in the valid range of devices
     */
    if (fIsOutput)
    {
        if (id != MIDI_MAPPER &&
            id >= midiOutGetNumDevs())
        {
            return MMSYSERR_BADDEVICEID;
        }
    }
    else
    {
        if (id >= midiInGetNumDevs())
        {
            return MMSYSERR_BADDEVICEID;
        }
    }

    /* Create an open handle instance. This will be returned to
     * Win32 as the handle.
     */
    pohi = (NPOPENHANDLEINSTANCE)LocalAlloc(LPTR, sizeof(OPENHANDLEINSTANCE));
    if (NULL == pohi)
    {
        return MMSYSERR_NOMEM;
    }

    /* Search through the handles we already have open and try
     * to find the handle already open.
     */
    mmr = MMSYSERR_NOERROR;
    for (pLink = gOpenHandleList; pLink; pLink = pLink->pNext)
    {   
        poh = (NPOPENHANDLE)pLink;

        if (poh->id != id)
        {
            continue;
        }

        if ((fIsOutput    && (!(poh->wFlags & OH_F_MIDIIN))) ||
            ((!fIsOutput) && (poh->wFlags & OH_F_MIDIIN)))
        {
            break;
        }
    }

    /* If we didn't find it, try to allocate it.
     *
     */
    if (NULL == pLink)
    {
        poh = (NPOPENHANDLE)LocalAlloc(LPTR, sizeof(OPENHANDLE));
        if (NULL == poh)
        {
            LocalFree((HLOCAL)pohi);
            return MMSYSERR_NOMEM;
        }

        poh->uReferenceCount = 1;
        poh->id = id;
        poh->wFlags = (fIsOutput ? 0 : OH_F_MIDIIN);
        if (fShare)
        {
            poh->wFlags |= OH_F_SHARED;
        }
        InitializeCriticalSection(&poh->wCritSect);
    }
    else
    {
        poh = (NPOPENHANDLE)pLink;
        
        /* Validate sharing modes match.
         * If they want exclusive mode, fail. 
         * If the device is already open in exclusive mode, fail.
         */
        if (!fShare)
        {
            DPF(0, "Legacy open failed: non-shared open request, port already open.");
            LocalFree((HLOCAL)pohi);
            return MIDIERR_BADOPENMODE;
        }

        if (!(poh->wFlags & OH_F_SHARED))
        {
            DPF(0, "Legacy open failed: Port already open in exclusive mode.");
            LocalFree((HLOCAL)pohi);
            return MIDIERR_BADOPENMODE;
        }

        ++poh->uReferenceCount;
    }

    pohi->pHandle = poh;
    pohi->fActive = FALSE;
    pohi->wTask = GetCurrentTask();

    /* We lock segments here so we minimize the impacy of activation. However,
     * actual device open is tied to activation.
     */
    if (fIsOutput)
    {
        ++gcOpenOutputDevices;
        mmr = MidiOutOnOpen(pohi);
        if (mmr)
        {
            --gcOpenOutputDevices;
        }
        UpdateSegmentLocks(fIsOutput);
    }
    else
    {
        ++gcOpenInputDevices;
        mmr = MidiInOnOpen(pohi);
        if (mmr)
        {
            --gcOpenInputDevices;
        }
        UpdateSegmentLocks(fIsOutput);
    }

    if (poh->uReferenceCount == 1)
    {
        ListInsert(&gOpenHandleList, &poh->link);
    }

    ListInsert(&gOpenHandleInstanceList, &pohi->link);
    ListInsert(&poh->pInstanceList, &pohi->linkHandleList);

    *ph = (HANDLE)(DWORD)(WORD)pohi;

    return MMSYSERR_NOERROR;
}

/* @func Close a legacy device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * It just validates the handle and calls the internal close device API.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 *
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 *
 */
MMRESULT WINAPI
CloseLegacyDevice(
    HANDLE h)       /* @parm The handle to close. */
{
    NPOPENHANDLEINSTANCE pohi = (NPOPENHANDLEINSTANCE)(WORD)h;

    DPF(2, "CloseLegacyDevice %04X\n", h);

    if (!IsValidHandle(h, VA_F_EITHER, &pohi))
    {
        DPF(0, "CloseLegacyDevice: Invalid handle\n");
        return MMSYSERR_INVALHANDLE;
    }

    return CloseLegacyDeviceI(pohi);
}

/* @func Activate or deactivate a legacy device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * Validate parameters and pass the call to the internal activate.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 * Any other MMRESULT that a midiXxx call might return.
 *
 */
MMRESULT WINAPI
ActivateLegacyDevice(
    HANDLE h,
    BOOL fActivate)
{
    NPOPENHANDLEINSTANCE pohi;

    if (!IsValidHandle(h, VA_F_EITHER, &pohi))
    {
        DPF(0, "Activate: Invalid handle\n");
        return MMSYSERR_INVALHANDLE;
    }

    return ActivateLegacyDeviceI(pohi, fActivate);
}

/* @func Close a legacy device (internal)
 *
 * @comm
 *
 * This function deallocates the referenced <c OPENHANDLEINSTANCE> struct.
 * If it is the last reference to the device, then the device will be closed
 * as well.
 *
 * If this is the last input or output device being closed, then the
 * appropriate segments containing callback code and data will be
 * unlocked.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 *
 */
MMRESULT PASCAL
CloseLegacyDeviceI(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh;

    /* Deactivate this device. This might result in the device being closed.
     */
    ActivateLegacyDeviceI(pohi, FALSE);

    poh = pohi->pHandle;
    ListRemove(&gOpenHandleInstanceList, &pohi->link);
    ListRemove(&poh->pInstanceList, &pohi->linkHandleList);

    --poh->uReferenceCount;
    if (poh->wFlags & OH_F_MIDIIN)
    {
        --gcOpenInputDevices;
        MidiInOnClose(pohi);
        UpdateSegmentLocks(FALSE /*fIsOutput*/);
    }
    else
    {
        --gcOpenOutputDevices;
        MidiOutOnClose(pohi);
        UpdateSegmentLocks(TRUE  /*fIsOutput*/);
    }

    if (0 == poh->uReferenceCount)
    {
        ListRemove(&gOpenHandleList, &poh->link);
        LocalFree((HLOCAL)poh);
    }

    LocalFree((HLOCAL)pohi);

    return MMSYSERR_NOERROR;
}

/* @func Activate or deactivate a legacy device (internal)
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * Handle open and close of the device on first activate and last deactivate.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 * Any other MMRESULT that a midiXxx call might return.
 *
 */
MMRESULT PASCAL
ActivateLegacyDeviceI(
    NPOPENHANDLEINSTANCE pohi,
    BOOL fActivate)
{
    NPOPENHANDLE poh;
    MMRESULT mmr;

    poh = pohi->pHandle;

    if (fActivate)
    {
        if (pohi->fActive)
        {
            DPF(0, "Activate: Activating already active handle %04X", pohi);
            return MMSYSERR_NOERROR;
        }

        poh->uActiveCount++;
    
        if (poh->wFlags & OH_F_MIDIIN)
        {
            mmr = MidiInOnActivate(pohi);
        }
        else
        {
            mmr = MidiOutOnActivate(pohi);
        }

        if (mmr == MMSYSERR_NOERROR) 
        {
            pohi->fActive = TRUE;
        }
        else
        {
            --poh->uActiveCount;
        }
    }
    else
    {
        if (!pohi->fActive)
        {
            DPF(0, "Activate: Deactivating already inactive handle %04X", pohi);
            return MMSYSERR_NOERROR;
        }

        pohi->fActive = TRUE;
        poh->uActiveCount--;

        if (poh->wFlags & OH_F_MIDIIN)
        {
            mmr = MidiInOnDeactivate(pohi);
        }
        else
        {
            mmr = MidiOutOnDeactivate(pohi);
        }

        if (mmr == MMSYSERR_NOERROR) 
        {
            pohi->fActive = FALSE;
        }
        else
        {
            --poh->uActiveCount;
        }
    }

    return mmr;    
}

/* @func Validate the given handle
 *
 * @comm
 *
 * Determine if the given handle is valid, and if so, return the open handle instance.
 *
 * The handle is merely a pointer to an <c OPENHANDLEINSTANCE> struct. This function,
 * in the debug build, will verify that the handle actually points to a struct allocated
 * by this DLL. In all builds, the handle type will be verified.
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the given handle is invalid or of the wrong type.
 *
 */
BOOL PASCAL
IsValidHandle(
    HANDLE h,                           /* @parm The handle to verify */
    WORD wType,                         /* @parm The required type of handle. One of the following: */
                                        /* @flag VA_F_INPUT  | If the handle must specify an input device */
                                        /* @flag VA_F_OUTPUT | If the handle must specify an output device */
                                        /* @flag VA_F_EITHER | If either type of handle is acceptable */
    NPOPENHANDLEINSTANCE FAR *lppohi)   /* @parm Will contain the open handle instance on return */
{
#ifdef DEBUG
    NPLINKNODE pLink;
#endif
    NPOPENHANDLEINSTANCE pohi = (NPOPENHANDLEINSTANCE)(WORD)h;

#ifdef DEBUG
    /* Find the handle instance in the global list
     */
    for (pLink = gOpenHandleInstanceList; pLink; pLink = pLink->pNext)
    {
        DPF(2, "IsValidHandle: Theirs %04X mine %04X", (WORD)h, (WORD)pLink);
        if (pLink == (NPLINKNODE)(WORD)h)
        {
            break;
        }
    }

    if (NULL == pLink)
    {
        return FALSE;
    }
#endif

    DPF(2, "IsValidHandle: Got handle, flags are %04X", pohi->pHandle->wFlags);

    *lppohi = pohi;
    
    /* Verify the handle type
     */
    if (pohi->pHandle->wFlags & OH_F_MIDIIN)
    {
        if (wType & VA_F_INPUT)
        {
            return TRUE;
        }
    }
    else
    {
        if (wType & VA_F_OUTPUT)
        {
            return TRUE;
        }
    }

    *lppohi = NULL;

    return FALSE;
}


/* @func Lock or unlock segments as need be.
 *
 * @comm
 *
 * This function calls the DLL's Lock and Unlock functions to bring the lock status
 * of the segments containing callback code and data into sync with the actual types
 * of devices currently open. This prevents having too much memory page locked when
 * it is not actually being used.
 *
 */
STATIC VOID PASCAL
UpdateSegmentLocks(
    BOOL fIsOutput)     /* @parm TRUE if the last device opened or closed was an output device */
{
    if (fIsOutput)
    {
        switch(gcOpenOutputDevices)
        {
            case 0:
                if (gcOpenInputDevices)
                {
                    DPF(2, "Unlocking output");
                    UnlockCode(LOCK_F_OUTPUT);
                }
                else
                {
                    DPF(2, "Unlocking output+common");
                    UnlockCode(LOCK_F_OUTPUT | LOCK_F_COMMON);
                }
                break;

            case 1:
                if (gcOpenInputDevices)
                {
                    DPF(2, "Locking output");
                    LockCode(LOCK_F_OUTPUT);
                }
                else
                {
                    DPF(2, "Locking output+common");
                    LockCode(LOCK_F_OUTPUT | LOCK_F_COMMON);
                }
                break;
        }
    }
    else
    {
        switch(gcOpenInputDevices)
        {
            case 0:
                if (gcOpenOutputDevices)
                {
                    DPF(2, "Unlocking input");
                    UnlockCode(LOCK_F_INPUT);
                }
                else
                {
                    DPF(2, "Unlocking input+common");
                    UnlockCode(LOCK_F_INPUT | LOCK_F_COMMON);
                }
                break;

            case 1:
                if (gcOpenOutputDevices)
                {
                    DPF(2, "Locking input");
                    LockCode(LOCK_F_INPUT);
                }
                else
                {
                    DPF(2, "Locking input+common");
                    LockCode(LOCK_F_INPUT | LOCK_F_COMMON);
                }
                break;
        }
    }
}

/* @func Clean up all open handles held by a given task
 *
 * @comm This function is called when a task terminates. It will clean up resources left
 * behind by a process which did not terminate cleanly, and therefore did not tell
 * this DLL to unload in its context.
 */
VOID PASCAL
CloseDevicesForTask(
    WORD wTask)
{
    NPLINKNODE pLink;
    NPOPENHANDLEINSTANCE pohi;

    for (pLink = gOpenHandleInstanceList; pLink; pLink = pLink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)pLink;

        if (pohi->wTask != wTask)
        {
            continue;
        }

        DPF(0, "CloseDevicesForTask: Closing %04X", (WORD)pohi);
        /* NOTE: This will free pohi
         */
        CloseLegacyDeviceI(pohi);

        pLink = gOpenHandleInstanceList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\debug.c ===
//==========================================================================; 
//
//      Copyright (c) 1991-1999 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <stdarg.h>

#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_TEXT"))
#endif


#define WSPRINTF_LIMIT 1024

typedef struct tagLOG
{
     LPBYTE             lpbQueue;
     UINT               cbBuffer;
     UINT               idxRead;
     UINT               idxWrite;
} LOG, FAR *LPLOG;

#define LOG_INCIDX(pl,x) ((++(x) >= pl->cbBuffer) ? x = 0 : x)

VOID FAR CDECL DbgVPrintF(LPSTR szFmt, LPSTR va) ;

BOOL NEAR PASCAL LogInit(LPLOG lpLog, UINT ckBuffer);
VOID NEAR PASCAL LogWrite(LPLOG lpLog, LPSTR lpstrEvent);
BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPSTR lpstrBuffer, UINT cbBuffer);

#ifdef ISRDEBUG
int wivsprintf(LPSTR lpOut, LPCSTR lpFmt, VOID FAR* lpParms) ;

LPCSTR  NEAR PASCAL SP_GetFmtValue(LPCSTR lpch, LPWORD lpw) ;
UINT    NEAR PASCAL SP_PutNumber(LPSTR lpb, DWORD n, UINT limit, UINT radix, UINT icase) ;
VOID    NEAR PASCAL SP_Reverse(LPSTR lpFirst, LPSTR lpLast) ;
UINT    NEAR PASCAL ilstrlen(LPSTR lpstr) ;
VOID    NEAR PASCAL ilstrcat(LPSTR lpstrDest, LPSTR lpstrSrc) ;
#endif

//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#define wvsprintfA           wvsprintf
#define GetProfileIntA       GetProfileInt
#define OutputDebugStringA   OutputDebugString

#ifdef ISRDEBUG
   #define wvsprintf        wivsprintf
   #define lstrcatA         ilstrcat
   #define lstrlenA         ilstrlen    
#else
   #define lstrcatA         lstrcat
   #define lstrlenA         lstrlen
#endif

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level
BOOL    __gfLogging     = 0;        // Are we logging as well?
BOOL    __gfAssertBreak = 0;        // Break on assert?

HWND    ghWndCB         = (HWND)NULL;
LOG     gLog;
WORD    wDebugLevel     = 0;

//************************************************************************
//**
//**  DbgAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine  
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************
VOID WINAPI DbgAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static char BCODE szFormat[] =
        "Assert:%s@%lu %s";
    dprintf(0, szFormat, lpstrFile, dwLine, lpstrExp);
    if (__gfAssertBreak)
        DebugBreak();
}

//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID FAR CDECL DbgVPrintF(
   LPSTR szFmt, 
   LPSTR va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, (LPSTR)va);

    if (fCRLF)
        lstrcatA(ach, "\r\n");

    if (__gfLogging)
    {
        LogWrite(&gLog, ach);
        if (ghWndCB)
            PostMessage(ghWndCB, WM_DEBUGUPDATE, 0, 0);
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**     
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     ICSAMPLE=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

VOID FAR CDECL dprintf(
   UINT     uDbgLevel, 
   LPSTR   szFmt, 
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, (LPSTR)va);
    va_end(va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = wDebugLevel = uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(VOID)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;


UINT WINAPI DbgInitialize(BOOL fEnable)
{
    char            szTemp[64];
    LPSTR           pstr;
    UINT            uLevel;
    UINT            uLogMem;
    
    __gfAssertBreak = GetProfileInt(DEBUG_SECTION, ASSERT_BREAK, 0);

    GetProfileString(DEBUG_SECTION, DEBUG_MODULE_NAME, "", szTemp, sizeof(szTemp));

    pstr = szTemp;
    uLevel = 0;
    while (*pstr >= '0' && *pstr <= '9')
    {
        uLevel = uLevel*10 + (UINT)(*pstr - '0');
        pstr++;
    }

    __gfLogging = FALSE;
    if (*pstr == ',')
    {
        pstr++;
        uLogMem = 0;
        while (*pstr >= '0' && *pstr <= '9')
        {
            uLogMem = uLogMem*10 + (UINT)(*pstr - '0');
            pstr++;
        }

        if (0 == uLogMem) uLogMem = K_DEFAULT_LOGMEM;
        if (uLogMem > K_MAX_LOGMEM) uLogMem = K_MAX_LOGMEM;

        __gfLogging = TRUE;
    }
    
    if (__gfLogging)
        __gfLogging = LogInit(&gLog, uLogMem);
    
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

VOID WINAPI DbgRegisterCallback(HWND hWnd)
{
    ghWndCB = hWnd;
}

BOOL WINAPI DbgGetNextLogEntry(LPSTR lpstrBuffer, UINT cbBuffer)
{
    if (!__gfLogging)
        return FALSE;

    return LogRead(&gLog, lpstrBuffer, cbBuffer);
}

BOOL NEAR PASCAL LogInit(LPLOG lpLog, UINT ckMem)
{
    DWORD               cbMem;

    cbMem = 1024L * ckMem;

    lpLog->lpbQueue = GlobalAllocPtr(GPTR, cbMem);
    if (NULL == lpLog->lpbQueue)
        return FALSE;

    if (!GlobalSmartPageLock(HIWORD(lpLog->lpbQueue)))
    {
        GlobalFreePtr(lpLog->lpbQueue);
        return FALSE;
    }

    lpLog->cbBuffer = (UINT)cbMem;
    lpLog->idxRead = 0;
    lpLog->idxWrite = 0;

    return TRUE;
}

VOID NEAR PASCAL LogWrite(LPLOG lpLog, LPSTR lpstrEvent)
{
    if (!*lpstrEvent)
        return;

    while (*lpstrEvent)
    {
        lpLog->lpbQueue[lpLog->idxWrite] = *lpstrEvent++;
        LOG_INCIDX(lpLog,lpLog->idxWrite);
    }

    lpLog->idxRead = lpLog->idxWrite;

    while (lpLog->lpbQueue[lpLog->idxRead])
    {
        lpLog->lpbQueue[lpLog->idxRead] = '\0';
        LOG_INCIDX(lpLog,lpLog->idxRead);
    }
    
    LOG_INCIDX(lpLog,lpLog->idxRead);
    LOG_INCIDX(lpLog,lpLog->idxWrite);
}

BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPSTR lpstrBuffer, UINT cbBuffer)
{
    BYTE                    c;
    UINT                    idx;

    if (!cbBuffer)
        return FALSE;
    
    idx = lpLog->idxRead;

    while ('\0' == lpLog->lpbQueue[idx])
    {
        LOG_INCIDX(lpLog,idx);
        if (idx == lpLog->idxRead)
            return FALSE;
    }

    cbBuffer--;
    while (0 != (c = lpLog->lpbQueue[idx]))
    {
        if (cbBuffer)
        {
            *lpstrBuffer++ = c;
            cbBuffer--;
        }
            
        lpLog->lpbQueue[idx] = '\0';
        LOG_INCIDX(lpLog,idx);
    }

    *lpstrBuffer = '\0';

    LOG_INCIDX(lpLog,idx);

    lpLog->idxRead = idx;
    return TRUE;
}



//--------------------------------------------------------------------------;
//
// The rest of the code is only needed if we're in Win16 and need to be
// interrupt callable.
//
//--------------------------------------------------------------------------;

#ifdef ISRDEBUG

#define OUT(ch) if (--cchLimit) *lpOut++=(ch); else goto error_Out

//************************************************************************
//**
//**  wivsprintf();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of wvsprintf() 
//**
//**
//**  ARGUMENTS:
//**     LPSTR       lpOut    -  Buffer to format into.
//**     LPCSTR      lpFmt    -  Format string.
//**     VOID FAR*   lpParms  -  Points to the first of args 
//**                             described by lpFmt.
//**
//**  RETURNS:
//**     int   -  Number of characters stored.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

int wivsprintf(
    LPSTR       lpOut,
    LPCSTR      lpFmt,
    VOID FAR*   lpParms)
{
    int         left ;
    char        prefix ;
    int         width ;
    int         prec ;
    char        fillch ;
    int         size ;
    int         sign ;
    int         radix ;
    int         upper ;
    int         cchLimit = WSPRINTF_LIMIT;
    int         cch ;
    LPSTR       lpT ;
    union
    {
        long            l ;
        unsigned long   ul ;
        char sz[sizeof(long)] ;
    } val;
                
    while (*lpFmt)
    {
        if (*lpFmt=='%')
        {
            //
            // Read the format flags. 
            //
            left   = 0 ;
            prefix = 0 ;

            while (*++lpFmt)
            {
                if (*lpFmt=='-')
                {    
                    left++;
                }
                else if (*lpFmt=='#')
                {
                    prefix++;
                }
                else
                {
                    break;
                }
            }

            //
            // Find the fill character (either '0' or ' ')
            //
            if (*lpFmt=='0')
            {
                fillch = '0' ;
                lpFmt++ ;
            }
            else
            {
                fillch = ' ' ;
            }

            //
            // Now parse [width[.precision]]
            //
            lpFmt = SP_GetFmtValue(lpFmt,&cch);
            width = cch;

            if (*lpFmt=='.')
            {
                lpFmt = SP_GetFmtValue(++lpFmt,&cch);
                prec = cch;
            }
            else
            {
                prec = (UINT)-1 ;
            }

            //
            // Get the operand size modifier
            //
            if (*lpFmt=='l')
            {
                size = 1 ;
                lpFmt++ ;
            }
            else
            {
                size = 0 ;
                if (*lpFmt=='h')
                {
                    lpFmt++ ;
                }
            }
            
            //
            // We've gotten all the modifier; now format the output
            // based on the type (which should now be pointed at
            // by lpFmt).
            //
            upper = 0 ;
            sign = 0 ;
            radix = 10 ;

            switch (*lpFmt)
            {
                case 0:
                    goto error_Out ;

                case 'i' :
                case 'd' :
                    sign++ ;

                case 'u':
                    //
                    // Don't show a prefix for decimal formats
                    // 
                    prefix=0 ;
do_Numeric:
                    //
                    // Special cases to act like MSC v5.10
                    //
                    if (left || prec>=0)
                    {
                        fillch = ' ';
                    }

                    //
                    // Get value from parm list into val union 
                    // 
                    if (size)
                    {
                        val.l=*((long far *)lpParms)++;
                    }
                    else
                    {
                        if (sign)
                        {
                            val.l=(long)*((short far *)lpParms)++;
                        }
                        else
                        {
                            val.ul=(unsigned long)*((unsigned far *)lpParms)++;
                        }
                    }

                    //
                    // Save sign of val.l in sign and set val.l positive.
                    //
                    if (sign && val.l<0L)
                    {
                        val.l=-val.l;
                    }
                    else
                    {
                        sign=0;
                    }

                    //
                    // Save start of output stream for later reverse
                    //
                    lpT = lpOut;

                    //
                    // Blast the number backwards into the user buffer 
                    //
                    cch = SP_PutNumber(lpOut,val.l,cchLimit,radix,upper) ;
                    if (!(cchLimit-=cch))
                        goto error_Out ;

                    lpOut += cch ;
                    width -= cch ;
                    prec -= cch ;

                    if (prec>0)
                    {
                        width -= prec ;
                    }

                    //
                    // Fill in up to precision
                    //
                    while (prec-- > 0)
                    {
                        OUT('0') ;
                    }

                    if (width>0 && !left)
                    {
                        //
                        // If we're filling with spaces, put sign first 
                        //
                        if (fillch != '0')
                        {
                            if (sign)
                            {
                                sign = 0 ;
                                OUT('-') ;
                                width-- ;
                            }

                            if (prefix)
                            {
                                OUT(prefix) ;
                                OUT('0') ;
                                prefix = 0 ;
                            }
                        }

                        if (sign)
                        {
                            width-- ;
                        }

                        //
                        // Now fill to width
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        //
                        // Still have a sign? 
                        //
                        if (sign)
                        {
                            OUT('-') ;
                        }

                        if (prefix)
                        {
                            OUT(prefix) ;
                            OUT('0') ;
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);
                    }
                    else
                    {
                        //
                        // Add the sign character
                        //
                        if (sign)
                        {
                            OUT('-') ;
                            width-- ;
                        }

                        if (prefix)
                        {
                            OUT(prefix);
                            OUT('0');
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);

                        //
                        // Pad to the right of the string in case left aligned 
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    break ;

                case 'X':
                    upper++ ;
                    //
                    // Falling through...
                    //

                case 'x':
                    radix=16 ;
                    if (prefix)
                    {
                        prefix = upper ? 'X' : 'x' ;
                    }
                    goto do_Numeric ;

                case 'c':
                    //
                    // Save as one character string and join common code
                    // 
                    val.sz[0] = *((char far*)lpParms) ;
                    val.sz[1]=0 ;
                    lpT = val.sz ;
                    cch = 1 ;  
                    (BYTE far*)lpParms += sizeof(WORD) ;

                    goto put_String ;

                case 's':
                    lpT = *((LPSTR FAR *)lpParms)++ ;
                    cch = ilstrlen(lpT) ;
put_String:
                    if (prec>=0 && cch>prec)
                    {
                        cch = prec ;
                    }

                    width -= cch ;

                    if (left)
                    {
                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }

                        while (width-->0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    else
                    {
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }
                    }
                    break ;

                default:
                    //
                    // An unsupported type character was given. We just
                    // print the character and go on. 
                    //
                    OUT(*lpFmt) ;
                    break ;

            } // switch(*lpfmt)
        } // if (*lpfmt == '%')
        else
        {
            //
            // Normal not-format character
            //
            OUT(*lpFmt) ;
        }
                
        lpFmt++ ;
    } // while (*lpFmt) 

error_Out:
    *lpOut = 0 ;

    return WSPRINTF_LIMIT-cchLimit ;
} //** wivsprintf()


//************************************************************************
//**
//**  SP_GetFmtValue();
//**
//**  DESCRIPTION:
//**     Parse a decimal integer forming part of a format string.
//**
//**
//**  ARGUMENTS:
//**     LPCSTR   lpch  -  Points to the string to parse.
//**     LPWORD   lpw   -  Points to a word where the value will be 
//**                       returned.
//**
//**  RETURNS:
//**     LPCSTR   -  Pointer of first character past the format value.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

LPCSTR NEAR PASCAL SP_GetFmtValue(
   LPCSTR   lpch,
   LPWORD   lpw)
{
    WORD        i = 0 ;

    while (*lpch>='0' && *lpch<='9')
    {
        i *= 10;
        i += (UINT)(*lpch++-'0');
    }     

    *lpw = i;

    return(lpch); 
} //** SP_GetFmtValue()

//************************************************************************
//**
//**  SP_PutNumber();
//**
//**  DESCRIPTION:
//**     Formats the given number in the given radix into the buffer
//**     *backwards*. The entire string will be reversed after printf
//**     has added sign, prefix, etc. to it.
//**
//**  
//**  ARGUMENTS:
//**     LPSTR lpb   -  Points to the output buffer.
//**     DWORD n     -  Number to convert.
//**     UINT  limit -  Maximum number of characters to store.
//**     UINT  radix -  Base to format in.
//**     UINT  icase -  Non-zero if the string should be upper case (hex).
//**
//**  RETURNS:
//**     UINT  -  Number of characters output.
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL SP_PutNumber(
   LPSTR lpb,
   DWORD n,
   UINT  limit,
   UINT  radix,
   UINT  icase)
{
   BYTE  bTemp;
   UINT  cchStored = 0;

   //
   // Set icase to the offset to add to the character if it
   // represents a value > 10
   //
   icase = (icase ? 'A' : 'a') - '0' - 10 ;

   while (limit--)
   {
//
//    AVOID a call to __aFulrem
//    This code words because radix is only a word
//
//    bTemp = '0' + (BYTE)(n%radix) ;
//
      _asm
      {
         mov     cx, radix
         mov     ax, word ptr n+2
         xor     dx, dx
         div     cx
         mov     ax, word ptr n
         div     cx
         add     dl, '0'
         mov     bTemp, dl
      }

      if (bTemp > '9')
      {
         bTemp += icase ;
      }

      *lpb++ = bTemp ;
      ++cchStored ;

//       
//    AVOID a call to __aFFauldiv
//    This code words because radix is only a word
//
//    n /= radix
//
      _asm
      {
         push    bx
         mov     cx, radix
         mov     ax, word ptr n+2
         xor     dx, dx
         div     cx
         mov     bx, ax
         mov     ax, word ptr n
         div     cx
         mov     word ptr n+2, bx
         mov     word ptr n, ax
         pop     bx
      }

      if (n == 0)
      {
         break ;
      }    
   }

   return cchStored ;
} //** SP_PutNumber()


//************************************************************************
//**
//**  SP_Reverse();
//**
//**  DESCRIPTION:
//**     Reverse string in place.
//**
//**  ARGUMENTS:
//**     LPSTR pFirst
//**     LPSTR pLast
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL SP_Reverse(
   LPSTR pFirst,
   LPSTR pLast)
{
   UINT  uSwaps = (pLast - pFirst + 1) / 2;
   BYTE  bTemp;

   while (uSwaps--)
   {
      bTemp   = *pFirst;
      *pFirst = *pLast;
      *pLast  = bTemp;

      pFirst++, pLast--;
   }
} //** SP_Reverse()

//************************************************************************
//**
//**  ilstrlen();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of strlen().
//**
//**  ARGUMENTS:
//**     LPSTR   pstr
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL ilstrlen(
    LPSTR   pstr)
{
   UINT    cch = 0 ;

   while (*pstr++)
      ++cch;

   return(cch);
} //** ilstrlen()

//************************************************************************
//**
//**  ilstrcat();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of lstrcat().
//**
//**  ARGUMENTS:
//**     LPSTR   pstrDest
//**     LPSTR   pstrSrc
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL ilstrcat(
    LPSTR   pstrDest,
    LPSTR   pstrSrc)
{
   while (*pstrDest)
      pstrDest++;

   while (*pstrDest++ = *pstrSrc++)
      ;

} //** ilstrcat()

#endif // #ifdef ISRDEBUG

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\alloc.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/* @doc DMusic16
 *
 * @module Alloc.c - Memory allocation routines |
 *
 * This module provides memory allocation routines for DMusic16.DLL. It allows the MIDI input and
 * output modules to allocated and free <c EVENT> structures.
 *
 * The allocated recognizes two types of events by size. If an event is create with 4 or less bytes
 * of data, then it is allocated as a channel message. Channel message events are allocated one
 * page at a time and kept in a free list.
 *
 * If the event size is greater than 4 bytes, then the event is a system exclusive message (or long
 * data in the legacy API nomenclature). These events are allocated individually, one per page.
 *
 * All allocated memory is preceded with a <c SEGHDR>, which is used to identify the size and type
 * of the segment and to keep it in a list. Since all events will be accessed at event time (in
 * either a MIDI input callback or a timeSetEvent callback), all memory is automatically page
 * locked.
 *
 * @globalv WORD | gsSegList |Selector of first segment in allocated list
 * @globalv LPEVENT | glpFreeEventList | List of free 4-byte events 
 * @globalv LPEVENT | glpFreeBigEventList | List of free 4-byte events 
 */
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>

#include "dmusic16.h"
#include "debug.h"

STATIC WORD gsSegList;
STATIC LPEVENT glpFreeEventList;        
STATIC LPEVENT glpFreeBigEventList;     

/* Given a far pointer, get its selector.
 */
#define SEL_OF(lp) (WORD)((((DWORD)lp) >> 16) & 0xffff)

/* Given a far event pointer, get the far pointer to its segment headear.
 */
#define SEGHDR_OF(lp)   ((LPSEGHDR)(((DWORD)lp) & 0xffff0000l))

STATIC BOOL RefillEventList(VOID);
STATIC LPSEGHDR AllocSeg(WORD cbSeg);
STATIC VOID FreeBigEvents(VOID);
STATIC VOID FreeSeg(LPSEGHDR lpSeg);

/* @func Called at DLL LibInit
 *
 * @comm
 * Initializes all free lists to empty.
 *
 */
VOID PASCAL
AllocOnLoad(VOID)
{
    gsSegList = 0;
    glpFreeEventList = NULL;
    glpFreeBigEventList = NULL;
}

/* @func Called at DLL LibExit
 *
 * @comm
 * Unlock and free all of the memory allocated.
 *
 * AllocOnUnload jettisons all memory the allocator has ever allocated. 
 * It assumes that all pointers to events will no longer ever be touched (i.e. all callbacks must
 * have already been disabled by this point).
 */
VOID PASCAL
AllocOnExit(VOID)
{
    WORD sSel;
    WORD sSelNext;
    LPSEGHDR lpSeg;

    sSel = gsSegList;

    while (sSel)
    {
        lpSeg = (LPSEGHDR)(((DWORD)sSel) << 16);
        sSelNext = lpSeg->selNext;
        
        FreeSeg(lpSeg);

        sSel = sSelNext;
    }
    
    /* This just invalidated both free lists as well as the segment list
     */
    gsSegList = 0;
    glpFreeEventList = NULL;
    glpFreeBigEventList = NULL;
}

/* @func Allocate an event of a given size
 *
 * @rdesc Returns a far pointer to the event or NULL if memory could not be allocated.
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This function is called to allocate a single event. The event will be allocated from
 * page-locked memory and filled with the given event data.
 *
 * Events are classified as normal events, which contain channel messages, and big events,
 * which contain SysEx data. The two are distinguished by their size: any event containing
 * a DWORD of data or less is a normal event.
 *
 * Since channel messages comprise most of the MIDI stream, allocation of these events is optimized.
 * A segment is allocated containing approximately one page worth (4k) of 4-byte events. These
 * events are doled out of a free pool, which only occasionally needs to be refilled from system
 * memory.
 *
 * Big events are allocated on an as-needed basis. When they have been free'd by a call to FreeEvent,
 * they are placed on a special free list. This list is used to find memory for future big events,
 * and is occasionally free'd back to Windows on a call to AllocEvent in order to minimize the
 * amount of page-locked memory in use.
 */
LPEVENT PASCAL
AllocEvent(
    DWORD msTime,           /* @parm The absolute time based on timeGetTime() of the event */
    QUADWORD rtTime,        /* @parm The absolute time based on the IRferenceClock in 100ns units */
    WORD cbEvent)           /* @parm The number of bytes of event data in pbData */
{
    LPEVENT lpEvent;
    LPEVENT lpEventPrev;
    LPEVENT lpEventCurr;
    LPSEGHDR lpSeg;
    
    /* Check for big event first (Sysex)
     */
    if (cbEvent > sizeof(DWORD))
    {
        /* First see if we have an event that will work already
         */
        lpEventPrev = NULL;
        lpEventCurr = glpFreeBigEventList;
        
        while (lpEventCurr)
        {
            if (SEGHDR_OF(lpEventCurr)->cbSeg >= sizeof(EVENT) + cbEvent)
            {
                break;
            }
            lpEventPrev = lpEventCurr;
            lpEventCurr = lpEventCurr->lpNext;
        }

        if (lpEventCurr)
        {
            /* Remove this event from the list and use it
             */
            if (lpEventPrev)
            {
                lpEventPrev->lpNext = lpEventCurr->lpNext;
            }
            else
            {
                glpFreeBigEventList = lpEventCurr->lpNext;
            }

            lpEventCurr->lpNext = NULL;
        }
        else
        {
            /* Nope, need to allocate one
             */
            lpSeg = AllocSeg(sizeof(EVENT) + cbEvent);
            if (NULL == lpSeg)
            {
                return NULL;
            }

            lpEventCurr = (LPEVENT)(lpSeg + 1);
        }

        lpEventCurr->msTime = msTime;
        lpEventCurr->rtTime = rtTime;
        lpEventCurr->wFlags = 0;
        lpEventCurr->cbEvent = cbEvent;

        return lpEventCurr;
    }

    /* BUGBUG How often???
     */
    FreeBigEvents();

    /* Normal event. Pull it off the free list (refill if needed) and fill it in.
     */
    if (NULL == glpFreeEventList)
    {
        if (!RefillEventList())
        {
            return NULL;
        }
    }

    lpEvent = glpFreeEventList;
    glpFreeEventList = lpEvent->lpNext;

    lpEvent->msTime = msTime;
    lpEvent->rtTime = rtTime;
    lpEvent->wFlags = 0;
    lpEvent->cbEvent = cbEvent;

    return lpEvent;
}

/* @func Free an event back to its appropriate free list
 *
 * @comm
 *
 * FreeEvent makes no system calls; it simply places the given event back on the correct
 * free list. If the event needs to be actually free'd, that will be done at a later time
 * in user mode.
 */
VOID PASCAL
FreeEvent(
    LPEVENT lpEvent)            /* @parm The event to free */
{
    LPSEGHDR lpSeg;

    lpSeg = SEGHDR_OF(lpEvent);
    if (lpSeg->wFlags & SEG_F_4BYTE_EVENTS)
    {
        lpEvent->lpNext = glpFreeEventList;
        glpFreeEventList = lpEvent;
    }
    else
    {
        lpEvent->lpNext = glpFreeBigEventList;
        glpFreeBigEventList = lpEvent;
    }
}

/* @func Refill the free list of normal events
 *
 * @rdesc Returns TRUE if the list was refilled or FALSE if there was no memory.
 *
 * @comm
 *
 * This routine is not callable from interrupt time.
 *
 * Allocate one page-sized segment of normal events and add them to the free list.
 *
 */
STATIC BOOL
RefillEventList(VOID)
{
    LPSEGHDR lpSeg;
    LPEVENT lpEvent;
    UINT cbEvent;
    UINT idx;

    cbEvent = sizeof(EVENT) + sizeof(DWORD);
    lpSeg = AllocSeg(C_PER_SEG * cbEvent);
    if (NULL == lpSeg)
    {
        return FALSE;
    }

    lpSeg->wFlags = SEG_F_4BYTE_EVENTS;

    /* Put the events into the free pool
     */
    lpEvent = (LPEVENT)(lpSeg + 1);

    for (idx = C_PER_SEG - 1; idx; --idx)
    {
        lpEvent->lpNext = (LPEVENT)(((LPBYTE)lpEvent) + cbEvent);
        lpEvent = lpEvent->lpNext;
    }

    lpEvent->lpNext = glpFreeEventList;
    glpFreeEventList = (LPEVENT)(lpSeg + 1);
                                 
    return TRUE;
}

/* @func Free all big events
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This function frees all big events on the free big event list. Free big events are those
 * with event data sizes of more than one DWORD; they are allocated one event per segment
 * as needed rather than being pooled like channel messages.
 *
 * This function is called every now and then as a side effect of AllocEvent in order to
 * free up the page-locked memory associated with completed big events.
 *
 */ 
STATIC VOID
FreeBigEvents(VOID)
{
    LPEVENT lpEvent;
    LPEVENT lpEventNext;
    LPSEGHDR lpSeg;

    lpEvent = glpFreeBigEventList;
    while (lpEvent)
    {
        lpEventNext = lpEvent->lpNext;

        lpSeg = SEGHDR_OF(lpEvent);
        FreeSeg(lpSeg);

        lpEvent = lpEventNext;
    }

    glpFreeBigEventList = NULL;
}

/* @func Allocate a segment and put it into the list of allocated segments.
 *
 * @rdesc A far pointer to the segment header or NULL if the memory could not be allocated.
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This is the lowest-level allocation routine which actually calls Windows to allocate the memory.
 * The caller is responsible for carving the memory into one or more events.
 *
 * The data area of the segment will be filled with zeroes.
 *
 * Since events are accessed at interrupt time (timeSetEvent callback), the memory is allocated and
 * page locked.
 *
 * This routine also inserts the segment into the global list of allocated segments for cleanup.
 */
STATIC LPSEGHDR
AllocSeg(
    WORD cbSeg)                 /* @parm The size of data needed in the segment, excluding the segment header */
{
    HANDLE hSeg;
    WORD sSegHdr;
    LPSEGHDR lpSeg;

    /* Allocate and page-lock a segment
     * NOTE: GPTR contains zero-init
     */
    cbSeg += sizeof(SEGHDR);
    hSeg = GlobalAlloc(GPTR | GMEM_SHARE, cbSeg);
    if (0 == hSeg)
    {
        return NULL;
    }

    lpSeg = (LPSEGHDR)GlobalLock(hSeg);
    if (NULL == lpSeg)
    {
        GlobalFree(sSegHdr);
        return NULL;
    }

    sSegHdr = SEL_OF(lpSeg);
    if (!GlobalSmartPageLock(sSegHdr))
    {
        GlobalUnlock(sSegHdr);
        GlobalFree(sSegHdr);
        return NULL;
    }

    lpSeg->hSeg = hSeg;
    lpSeg->cbSeg = cbSeg;

    lpSeg->selNext  = gsSegList;
    gsSegList = sSegHdr;
    
    return lpSeg;
}

/* @func Free a segment back to Windows
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * Just unlock the segment and free it. The calling cleanup code is assumed to have removed
 * the segment from the global list of allocated segments.
 *
 */
STATIC VOID FreeSeg(
    LPSEGHDR lpSeg)         /* @parm The segment to free */
{
    WORD sSel = SEL_OF(lpSeg);
    HANDLE hSeg;
    
    hSeg = lpSeg->hSeg;
    
    GlobalSmartPageUnlock(sSel);
    GlobalUnlock(hSeg);
    GlobalFree(hSeg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\dmusic16.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* @Doc DMusic16
 *
 * @Module DMusic16.h - Internal definitions for DMusic16.DLL |
 */

#ifndef __DMUSIC16__
#define __DMUSIC16__

#undef  WINAPI                                 
#define WINAPI            _loadds FAR PASCAL   

#ifdef WIN32
   #define  BCODE
   #define  BSTACK
#else
   #define  BCODE                   __based(__segname("_CODE"))
   #define  BSTACK                  __based(__segname("_STACK"))
#endif

/* Make symbols show up in debug builds
 */
#ifdef DEBUG
#define STATIC 
#else
#define STATIC static
#endif

/* MIDI defines 
 */
#define MIDI_CHANNELS           16
 

#define SZCODE const char BCODE

/* Quadword alignment for event lengths in DMEVENT's
 */
#define QWORD_ALIGN(x) (((x) + 7) & ~7)         /* Next highest */

#define QWORD_TRUNC(x) ((x) & ~7)               /* Next lowest */

/* Multiplier to convert between reftime and milliseconds
 */
#define REFTIME_TO_MS (10L*1000L)


/* Number of events we want in the capture pool. Based on about a second's worth of high
 * concentration data
 */
#define CAP_HIGHWATERMARK 1024

/* How often user-mode timer ticks happen (milliseconds)
 */
#define MS_USERMODE 1000

/* Typedefs for everyone. Woohoo!
 */
typedef struct QUADWORD       QUADWORD;
typedef struct QUADWORD NEAR *NPQUADWORD;
typedef struct QUADWORD FAR  *LPQUADWORD;

typedef struct LINKNODE       LINKNODE;
typedef struct LINKNODE NEAR *NPLINKNODE;
typedef struct LINKNODE FAR  *LPLINKNODE;

typedef struct DMEVENT       DMEVENT;
typedef struct DMEVENT NEAR *NPDMEVENT;
typedef struct DMEVENT FAR  *LPDMEVENT;

typedef struct EVENT       EVENT;
typedef struct EVENT NEAR *NPEVENT;
typedef struct EVENT FAR  *LPEVENT;

typedef struct EVENTQUEUE       EVENTQUEUE;
typedef struct EVENTQUEUE NEAR *NPEVENTQUEUE;
typedef struct EVENTQUEUE FAR  *LPEVENTQUEUE;

typedef struct OPENHANDLEINSTANCE        OPENHANDLEINSTANCE;
typedef struct OPENHANDLEINSTANCE NEAR *NPOPENHANDLEINSTANCE;
typedef struct OPENHANDLEINSTANCE FAR  *LPOPENHANDLEINSTANCE;

typedef struct OPENHANDLE       OPENHANDLE;
typedef struct OPENHANDLE NEAR *NPOPENHANDLE;
typedef struct OPENHANDLE FAR  *LPOPENHANDLE;

typedef struct THRUCHANNEL       THRUCHANNEL;
typedef struct THRUCHANNEL NEAR *NPTHRUCHANNEL;
typedef struct THRUCHANNEL FAR  *LPTHRUCHANNEL;

/* 64-bit integer used w/ assembly helpers
 */
struct QUADWORD
{
    DWORD dwLow;
    DWORD dwHigh;
};

/* @struct Holds things in doubly linked lists
 */ 
struct LINKNODE {
    NPLINKNODE pPrev;           /* @field NPLINKNODE | pPrev |
                                   Pointer to the previous node in the list */
    
    NPLINKNODE pNext;           /* @field NPLINKNODE | pNext |
                                   Pointer to the next node in the list */
};

/* @struct DirectMusic event as packed by IDirectMusic
 */
struct DMEVENT {
    DWORD cbEvent;              /* @field DWORD | cbEvent |
                                   Unrounded number of event bytes */
    
    DWORD dwChannelGroup;       /* @field DWORD | dwChannelGroup |
                                   This field determines which channel group (set of 16 MIDI channels) receives the event. */

    QUADWORD rtDelta;			/* @field QUADWORD | rtDelta | Offset from buffer header in 100 ns units */
    
    DWORD dwFlags;              /* @field DWORD | dwFlags | DMEVENT_xxx */
    
    BYTE  abEvent[0];           /* @field BYTE | abEvent[] |
                                   Actual event data, rounded up to be an even number 
                                   of QWORD's (8 bytes) */
};

                                /* Total size of an event needed to hold cb bytes of data */
                                
#define DMEVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMEVENT) + (cb))      

                                /* If we have cb for event + data, how much data can we fit? */
                                
#define DMEVENT_DATASIZE(cb) (QWORD_TRUNC(cb) - sizeof(DMEVENT))

#define DMEVENT_STRUCTURED  0x00000001

#define EVENT_F_MIDIHDR     0x0001

/* @struct Event as stored in an <c EVENTQUEUE>.
 */
struct EVENT {
    LPEVENT lpNext;             /* @field LPEVENT | lpNext |
                                   Next event in queue */
    
    DWORD msTime;               /* @field DWORD | msTime |
                                   Absolute ms time in stream time (i.e. timeSetEvent) */

    QUADWORD rtTime;			/* @field QUADWORD | rtTime |
								   Absolute time in 100ns units relative to reference clock. Use for sorting event queue. */
    
    WORD  wFlags;               /* @field WORD | wFlags |
                                   A bitwise combination of the following flags: 
                                   @flag EVENT_F_MIDIHDR | The event data starts with a MIDIHDR */
    
    WORD  cbEvent;              /* @field WORD | cbEvent |
                                   The unrounded number of bytes in the event data */
    
    BYTE  abEvent[0];           /* @field BYTE | abEvent[] |
                                   The actual event data, rounded up to be an even number of DWORD's */
};

/* @struct A queue of <c EVENT> structs.
 *
 * @comm
 * This is not the same as the generic list in list.c because we don't need
 * the overhead of a prev pointer here and we don't need the overhead of a far
 * pointer there.
 */
struct EVENTQUEUE {
    LPEVENT pHead;              /* @field LPEVENT | pHead | Pointer to the first event */
    LPEVENT pTail;              /* @field LPEVENT | pTail | Pointer to the last event */
    UINT    cEle;               /* @field UINT | cEle | The number of events currently in queue */
};

/* @struct An instance of an open device
 *
 * @comm
 *
 * Since multiple Win32 processes can hold a single MMSYSTEM handle open,
 * we need to track them. There is one of these structs per Win32 client
 * per open handle. It simply refers to the OPENHANDLE which contains
 * all the actual handle data.
 *
 */
struct OPENHANDLEINSTANCE {
    LINKNODE link;               /* @field LINKNODE | link | Holds this handle in gOpenHandleInstanceList */
    LINKNODE linkHandleList;     /* @field LINKNODE | linkHandleList |
                                    Holds this handle in the list maintained in the <c OPENHANDLE> struct for this device. */
                                    
    NPOPENHANDLE pHandle;        /* @field NPOPENHANDLE | pHandle |
                                    Pointer to the <c OPENHANDLE> struct for this device. */
    
    DWORD dwVxDEventHandle;      /* @field DWORD | dwVxDEventHandle |
                                    VxD Event handle for signalling input on this device for this client. */

    BOOL fActive;                /* @field BOOL | fActive | Indicates if the port is active or not. This is used for per-instance
                                    focus management. If the port is flagged as inactive, then the underlying device is not opened. */

    WORD wTask;                  /* @field WORD | wTask | Task which opened the handle. This is used to clean up if the task
                                    terminates abnormally. */

    NPTHRUCHANNEL pThru;         /* @field NPTHRUCHANNEL | pThru If an input device, an array of 16 thru
                                    entries, one per input channel. */
};

/* OPENHANDLE.wFlags
 */
#define OH_F_MIDIIN  0x0001     /* This is a MIDI input device */
#define OH_F_CLOSING 0x0002     /* This device is being closed */
#define OH_F_SHARED  0x0004     /* This device is shareable */

/* @struct An open device
 *
 * @comm
 *
 * There is a one-to-one relationship between open handles and <c OPENHANDLE> structs.
 *
 * All of the following event queues are either
 *  Protected - means it is accessible at callback time and user time, and is
 *              protected by wCritSect
 *  Callback  - Means it is unprotected by a critical section and is only accessible
 *              at callback time. Callbacks, per handle, are not reentered.
 *
 * In the MIDI in callback, we *cannot* just go away if we don't get wCritSect,
 * as we can on output. Hence the multiple input queues below.
 *
 * When the user mode refill algorithm runs, it puts events in qFree, protected
 * by the critical section. (The one exception to this is preloading qFreeCB before
 * midiInStart is called on the handle). When the callback runs, it tried to get the
 * critical section. If it can, it moves the free events from qFree to qFreeCB.
 *
 * In any case, the callback can now use qFreeCB even if it didn't get the critical
 * section. It pulls a free event from the queue, fills it, and puts it back onto
 * the tail of qDoneCB. If the critical section is held, it then transfers the
 * entire contents of qDoneCB to qDone.
 *
 * These transfers are not time consuming; they are merely the manipulation of
 * a couple of pointers.
 */
struct OPENHANDLE {
    LINKNODE link;              /* @field LINKNODE | link |
                                   Holds this handle in gOpenHandles */

    NPLINKNODE pInstanceList;   /* @field NPLINKLINK | pInstanceList |
                                   Points to the first element in the list of open handle instances using
                                   this device. */
    
    UINT uReferenceCount;       /* @field UINT | uReferenceCount |
                                   The number of clients using this device; i.e., the number of elements in the
                                   pInstanceList. */
    UINT uActiveCount;          /* @field UINT | uActiveCount |
                                   The number of clients that have activated this device */                                   

    UINT id;                    /* @field UINT | id | The MMSYSTEM device ID of this device */
    WORD wFlags;                /* @field WORD | wFlags | Some combination of the following flags:
                                   @flag OH_F_MIDIIN | This device is a MIDI input device
                                   @flag OH_F_CLOSING | This device is being closed. 
                                   @flag OH_F_SHARE | This device is opened in shared mode */
    
    HMIDIOUT hmo;               /* @field HMIDIOUT | hmo | MIDI output handle if an output device */
    HMIDIIN  hmi;               /* @field HMIDIIN | hmi | MIDI input handle if an input device */

    WORD wCritSect;             /* @field WORD | wCritSect | Critical section protecting protected queues */
    DWORD msStartTime;          /* @field DWORD | msStartTime | <f timeGetTime()> Time we started input */
    
    EVENTQUEUE qPlay;           /* @field EVENTQUEUE | qPlay |
                                   Output: Queue of events to play (protected) */
    
    EVENTQUEUE qDone;           /* @field EVENTQUEUE | qDone |
                                   Input/Output: Events already done (played or received) (protected) */

    EVENTQUEUE qFree;           /* @field EVENTQUEUE | qFree |
                                   Input: Queue of free events (protected) */
                                   
    EVENTQUEUE qFreeCB;         /* @field EVENTQUEUE | qFreeCB |
                                   Input: Queue of free events used by callback */
     
    EVENTQUEUE qDoneCB;         /* @field EVENTQUEUE | qDoneCB |
                                   Input: Queue of received events used by callback */
                                   
    WORD wPostedSysExBuffers;   /* @field WORD | cPostedSysExBuffers |
                                   Input: Buffers posted in MMSYSTEM for recording SysEx */                                           
};

#define CLASS_MIDI              0 /* dwEventClass */

/* Close to our page size
 */
#define SEG_SIZE 4096
#define C_PER_SEG ((SEG_SIZE - sizeof(SEGHDR)) / (sizeof(EVENT) + sizeof(DWORD)))

#define SEG_F_4BYTE_EVENTS 0x0001

typedef struct SEGHDR SEGHDR;
typedef struct SEGHDR FAR * LPSEGHDR;

/* @struct The header for one segment of allocated memory
 */
struct SEGHDR {
    WORD selNext; /* @field WORD | selNext |
                     The selector of the next block of memory in the allocated list */
    
    WORD hSeg;    /* @field WORD | hSeg |
                     The global handle of the memory block */
    
    WORD wFlags;  /* @field WORD | wFlags |
                     A bitwise combination of the following flags:
                     
                     @flag SEG_F_4BYTE_EVENTS | This segment contains multiple 
                     channel messages */
    
    WORD cbSeg;   /* @field WORD | cbSeg |
                     The size of the segment, less the <c SEGHDR> */
};

/* @struct Thru information for one channel
 *
 * @comm 
 *
 * Each input device handle instance contains an array of 16 of these structures containing
 * the thru destination for data that arrives on that channel.
 *
 */
struct THRUCHANNEL {
    WORD wChannel;              /* @field WORD | wChannel | The destination channel */
    NPOPENHANDLEINSTANCE pohi;  /* @field NPOPENHANDLEINSTANCE | pohi | The output handle instance
                                   to receive the thru'ed data. */
}; 

/* globals */
extern HINSTANCE ghInst;
extern NPLINKNODE gOpenHandleInstanceList;
extern NPLINKNODE gOpenHandleList;
extern UINT gcOpenInputDevices;
extern UINT gcOpenOutputDevices;

/* device.c */
#define VA_F_INPUT  0x0001
#define VA_F_OUTPUT 0x0002
#define VA_F_EITHER (VA_F_INPUT | VA_F_OUTPUT)

extern VOID PASCAL DeviceOnLoad(VOID);
extern MMRESULT PASCAL CloseLegacyDeviceI(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL ActivateLegacyDeviceI(NPOPENHANDLEINSTANCE pohi, BOOL fActivate);

extern BOOL PASCAL IsValidHandle(HANDLE h, WORD wType, NPOPENHANDLEINSTANCE FAR *lppohi);
extern VOID PASCAL CloseDevicesForTask(WORD wTask);


/* list.c */
extern VOID PASCAL ListInsert(NPLINKNODE *pHead, NPLINKNODE pNode);
extern VOID PASCAL ListRemove(NPLINKNODE *pHead, NPLINKNODE pNode);

/* eventq.c */
extern VOID PASCAL QueueInit(NPEVENTQUEUE pQueue);
extern VOID PASCAL QueueAppend(NPEVENTQUEUE pQueue, LPEVENT pEvent);
extern VOID PASCAL QueueCat(NPEVENTQUEUE pDest, NPEVENTQUEUE pSource);
extern LPEVENT PASCAL QueueRemoveFromFront(NPEVENTQUEUE pQueue);

#define QUEUE_FILTER_KEEP   (0)
#define QUEUE_FILTER_REMOVE (1)

typedef int (PASCAL *PFNQUEUEFILTER)(LPEVENT pEvent, DWORD dwInstance);
extern VOID PASCAL QueueFilter(NPEVENTQUEUE pQueue, DWORD dwInstance, PFNQUEUEFILTER pfnFilter);
extern LPEVENT PASCAL QueuePeek(NPEVENTQUEUE pQueue);

#ifdef DEBUG
#define AssertQueueValid(pQueue) _AssertQueueValid((pQueue), __FILE__, __LINE__)
extern VOID PASCAL _AssertQueueValid(NPEVENTQUEUE pQueue, LPSTR pstrFile, UINT uLine);
#else
#define AssertQueueValid
#endif

/* locks.c */
#define LOCK_F_INPUT  0x0001
#define LOCK_F_OUTPUT 0x0002
#define LOCK_F_COMMON 0x0004
extern VOID PASCAL LockCode(WORD wFlags);
extern VOID PASCAL UnlockCode(WORD wFlags);

/* dmhelp.asm */
extern VOID PASCAL InitializeCriticalSection(LPWORD lpwCritSect);

#define CS_NONBLOCKING  (0)
#define CS_BLOCKING     (1)
extern WORD PASCAL EnterCriticalSection(LPWORD lpwCritSect, WORD fBlocking);
extern VOID PASCAL LeaveCriticalSection(LPWORD lpwCritSect);
extern WORD PASCAL DisableInterrupts(VOID);
extern VOID PASCAL RestoreInterrupts(WORD wIntStat);
extern WORD PASCAL InterlockedIncrement(LPWORD pw);
extern WORD PASCAL InterlockedDecrement(LPWORD pw);

extern DWORD PASCAL QuadwordDiv(QUADWORD qwDividend, DWORD dwDivisor);
extern VOID PASCAL QuadwordMul(DWORD m1, DWORD m2, LPQUADWORD qwResult);
extern BOOL PASCAL QuadwordLT(QUADWORD qwLValue, QUADWORD qwRValue);
extern VOID PASCAL QuadwordAdd(QUADWORD qwOp1, QUADWORD qwOp2, LPQUADWORD lpqwResult);

/* alloc.c */
extern VOID PASCAL AllocOnLoad(VOID);
extern VOID PASCAL AllocOnExit(VOID);
extern LPEVENT PASCAL AllocEvent(DWORD msTime, QUADWORD rtTime, WORD cbEvent);
extern VOID PASCAL FreeEvent(LPEVENT lpEvent);

/* midiout.c */
extern VOID PASCAL MidiOutOnLoad(VOID);
extern VOID PASCAL MidiOutOnExit(VOID);
extern MMRESULT PASCAL MidiOutOnOpen(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiOutOnClose(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiOutOnActivate(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiOutOnDeactivate(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL SetOutputTimerRes(BOOL fOnOpen);
extern VOID PASCAL FreeDoneHandleEvents(NPOPENHANDLE poh, BOOL fClosing);
extern VOID PASCAL MidiOutThru(NPOPENHANDLEINSTANCE pohi, DWORD dwMessage);

/* midiin.c */
extern VOID PASCAL MidiInOnLoad(VOID);
extern VOID PASCAL MidiInOnExit(VOID);
extern MMRESULT PASCAL MidiInOnOpen(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiInOnClose(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiInOnActivate(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiInOnDeactivate(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiInRefillFreeLists(VOID);
extern VOID PASCAL MidiInUnthruToInstance(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL FreeAllQueueEvents(NPEVENTQUEUE peq);

/* mmdevldr.asm */
extern MMRESULT CDECL SetWin32Event(DWORD dwVxDEvent); /* Must be CDECL! */

/* timerwnd.c */
extern BOOL PASCAL CreateTimerTask(VOID);
extern VOID PASCAL DestroyTimerTask(VOID);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\dmusic16.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic
 *
 * @Module DMusic16.c - Startup code |
 *
 * 16-bit Dll for DirectMusic sequencing on legacy devices (Win95/Win98 non-WDM drivers)
 *
 * This Dll is the 16-bit thunk peer for DMusic32.Dll
 *
 * @globalv HINSTANCE | ghInst | The instance handle for the DLL.
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

HINSTANCE ghInst;
HDRVR ghDrvr;
UINT guReferenceCount = 0;

/* @func LibMain system entry point
 *
 * @comm
 *
 * This entry point is called when the DLL is first loaded (NOT every time).
 *
 * Saves the global instance handle and initializes all the other modules.
 *
 */
int PASCAL
LibMain(
    HINSTANCE   hInst,              /* @parm Instance handle for the DLL */
    WORD        cbHeap,             /* @parm Initial size of the local heap */
    LPSTR       lpszCmdLine)        /* @parm Command-line parameters */
{
    UINT        uLev;
    char        szFilename[260];

    if (GetModuleFileName(hInst, szFilename, sizeof(szFilename)))
    {
        DPF(2, "%s", (LPSTR)szFilename);
    }

    ghDrvr = OpenDriver(szFilename, NULL, 0L);
               
    DPF(1, "DMusic16.DLL task %04X hdrvr %04X", GetCurrentTask(), (WORD)ghDrvr);


    ghInst = hInst;
    uLev = DbgInitialize(TRUE);
    DPF(0, "DMusic16: Debug level is %u", uLev);

    if (uLev > 2)
    {
        DPF(0, "DMusic16: Break in LibMain");
        DebugBreak();
    }
    
    DeviceOnLoad();
    AllocOnLoad();
    MidiOutOnLoad();

#if 0
    // This causes problems at terminate time. Find out later if we really need it.
    //
    if (!CreateTimerTask())
    {
        DPF(0, "CreateTimerTask() failed");
    }


    if (NULL == (LoadLibrary("dmusic16")))
    {
        DPF(0, "Could not LoadLibrary ourselves!");
    }
#endif

    return 1;
}

/* @func LibExit system call
 *
 * @comm
 *
 * This entry point is called just before the DLL is unloaded.
 *
 * Uninitialize all the other modules
 */

VOID PASCAL __loadds
LibExit(VOID)
{
    DPF(2, "LibExit start");
#if 0
    DestroyTimerTask();
#endif
    MidiOutOnExit();
    AllocOnExit();
    DPF(2, "LibExit end, going away now.");
}

extern BOOL FAR PASCAL dmthunk_ThunkConnect16(LPCSTR, LPCSTR, HINSTANCE, DWORD);
STATIC char pszDll16[] = "DMUSIC16.DLL";
STATIC char pszDll32[] = "DMUSIC.DLL";

/* @func DLLEntryPoint system entry point
 *
 * @comm
 *
 * This entry point is called each time the DLL is loaded or unloaded
 *
 * It is used here to initialize the peer connection for the thunk layer.
 */
#define PROCESS_DETACH          0
#define PROCESS_ATTACH          1

BOOL WINAPI
DllEntryPoint(
    DWORD       dwReason,           /* @parm Is the DLL being loaded or unloaded? */
    HINSTANCE   hi,                 /* @parm The instance handle */
    HGLOBAL     hgDS,               /* @parm The global handle of the DLL's (shared) DS */
    WORD        wHeapSize,          /* @parm The initial size of the local heap */
    LPCSTR      lszCmdLine,         /* @parm The command line (always NULL) */
    WORD        wCmdLine)           /* @parm Unused */
{
    // DllEntryPoint is called before LibEntry in a 4.x dll, so we have to LocalInit here if we're
    // going to use LocalAlloc
    //
    if (guReferenceCount == 0 && wHeapSize)
    {
        LocalInit(0, 0, wHeapSize);
    }

    switch(dwReason)
    {
        case PROCESS_ATTACH:
            DPF(2, "ProcessAttach task %04X", GetCurrentTask());
            ++guReferenceCount;
            dmthunk_ThunkConnect16(pszDll16, pszDll32, ghInst, 1);
            break;

        case PROCESS_DETACH:
            DPF(2, "ProcessDetach task %04X", GetCurrentTask());

            /* Clean up after them if they didn't close handles. We must do this here as well as
             * in DriverProc because on the last exit, we will go away before the DriverProc cleanup
             * gets called if the process termination is normal.
             */
            CloseDevicesForTask(GetCurrentTask());
            
            /* NOTE: We close on reference count of 1 since the initial OpenDriver call
               causes one more PROCESS_ATTACH to happen. */
            if (1 == --guReferenceCount)
            {
                CloseDriver(ghDrvr, 0, 0);
            }
            
            break;
    }

    return TRUE;
}

        
/* @func DriverProc entry point for ourselves as a loadable driver.
 *
 * @comm This entry points allows us to know when a task has gone away and therefore to clean
 * up after it even though we don't properly get notified that our thunk peer has gone away.
 */
LRESULT WINAPI DriverProc(
    DWORD               dwID,
    HDRVR               hdrvr,
    UINT                umsg,
    LPARAM              lParam1,
    LPARAM              lParam2)
{
    //
    //  NOTE DS is not valid here.
    //
    switch (umsg) 
    {
        case DRV_LOAD:
            return(1L);

        case DRV_FREE:
            return(0L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return(1L);

        case DRV_EXITAPPLICATION:
            DPF(2, "Cleaning up handles for task %04X", GetCurrentTask());
            CloseDevicesForTask(GetCurrentTask());
            break;

        default:
            return(DefDriverProc(dwID, hdrvr, umsg, lParam1, lParam2));
    }
} //** DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) 1989-1998 Microsoft Corporation
;
;   This module contains the entry point for MidiMap.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LibMain
        externFP LocalInit
        externFP LibExit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
        __acrtused = 1

sEnd        Data

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;       SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;       None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        ;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
        ;
        push    di
        push    cx
        push    es
        push    si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
        ParmW   fSystemExit
cBegin nogen
        mov     ax, fSystemExit
        cCall   LibExit, <ax>
        mov     ax, 1
        retf    2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\equeue.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @DOC DMusic16
 *
 * @MODULE EQueue.c - Event queue routines |
 *
 * These routines maintain queues of events. It is expected that other routines will operate
 * directly on the queue. The following invariants must be maintained:
 *
 * If the queue is empty, then the head and tail pointers must be NULL and the element count must be zero.
 *
 * The queue must not contain circular links.
 *
 * An event may only be on one queue.
 *
 * The element count must be equal to the number of events in the queue.
 */
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>

#include "dmusic16.h"
#include "debug.h"

/* @func Initialize an event queue to be empty
 *
 * @comm
 *
 * Any previous contents of the queue will be lost (NOT freed).
 */
VOID PASCAL
QueueInit(
    NPEVENTQUEUE pQueue)        /* @parm Pointer to the queue to initialize */
{
    DPF(4, "QueueInit(%04X)", (WORD)pQueue);
    
    pQueue->pHead = NULL;
    pQueue->pTail = NULL;
    pQueue->cEle  = 0;

    AssertQueueValid(pQueue);
}

/* @func Append an event to the end of the queue
 *
 */
VOID PASCAL
QueueAppend(
    NPEVENTQUEUE pQueue,        /* @parm Pointer to the queue */
    LPEVENT pEvent)             /* @parm Pointer to the event to tack on the end of the queue */
{
    DPF(4, "QueueAppend(%04X,%08lX)", (WORD)pQueue, (DWORD)pEvent);
    
    if (pQueue->cEle)
    {
        assert(pQueue->pHead);
        assert(pQueue->pTail);

        pQueue->pTail->lpNext = pEvent;
    }
    else
    {
        assert(NULL == pQueue->pHead);
        assert(NULL == pQueue->pTail);
        
        pQueue->pHead = pEvent;
    }
    
    pEvent->lpNext = NULL;
    pQueue->pTail = pEvent;
    ++pQueue->cEle;

    AssertQueueValid(pQueue);
}

/* @func Concatenate two queues
 *
 * @comm
 *
 * This function tacks the contents of <p pSrc> onto the end of <p pDest> in very short constant time.
 * <p pSrc> is left empty after the operation.
 */
VOID PASCAL
QueueCat(
    NPEVENTQUEUE pDest,     /* @parm The queue to receive new events */
    NPEVENTQUEUE pSrc)      /* @parm The queue which will lost all its events */
{
    DPF(4, "QueueCat(%04X,%04X)", (WORD)pDest, (WORD)pSrc);
    
    if (0 == pSrc->cEle)
    {
        assert(NULL == pSrc->pHead);
        assert(NULL == pSrc->pTail);

        return;
    }

    assert(pSrc->pHead);
    assert(pSrc->pTail);

    if (0 != pDest->cEle)
    {
        assert(pDest->pHead);
        assert(pDest->pTail);
        
        pDest->cEle += pSrc->cEle;
        pDest->pTail->lpNext = pSrc->pHead;
        pDest->pTail = pSrc->pTail;
    }
    else
    {
        assert(NULL == pDest->pHead);
        assert(NULL == pDest->pTail);

        *pDest = *pSrc;
    }

    pSrc->pHead = NULL;
    pSrc->pTail = NULL;
    pSrc->cEle  = 0;
    
    AssertQueueValid(pDest);
    AssertQueueValid(pSrc);
}

/* @func Dequeue an element from the front of the queue
 *
 * @rdesc Returns an event pointer or NULL if the queue is empty
 *
 */
LPEVENT PASCAL
QueueRemoveFromFront(
    NPEVENTQUEUE pQueue)        /* @parm The queue to dequeue from */
{
    LPEVENT pEvent;
    
    DPF(4, "QueueRemoveFromFront(%04X)", (WORD)pQueue);

    if (0 == pQueue->cEle)
    {
        assert(NULL == pQueue->pHead);
        assert(NULL == pQueue->pTail);
        
        return NULL;
    }

    assert(pQueue->pHead);
    assert(pQueue->pTail);

    pEvent = pQueue->pHead;

    if (0 != --pQueue->cEle)
    {
        assert(pQueue->pHead != pQueue->pTail);
        
        pQueue->pHead = pQueue->pHead->lpNext;
    }
    else
    {
        assert(pQueue->pHead == pQueue->pTail);

        pQueue->pHead = NULL;
        pQueue->pTail = NULL;
    }

    AssertQueueValid(pQueue);

    return pEvent;
}

/* @func Enumerate the events in a queue, possibly deleting some or all of them
 *
 * @comm
 *
 * This function calls the function pointed to by <p pfnFilter> once for each event in
 * the queue, starting at the front and working towards the back.
 *
 * The function <p pfnFilter> may return one of two values:
 * @flag QUEUE_FILTER_KEEP | If the event is to be kept
 * @flag QUEUE_FILTER_REMOVE | If the event is to be removed from the queue
 */
VOID PASCAL
QueueFilter(
    NPEVENTQUEUE pQueue,        /* @parm The queue to enumerate */
    DWORD dwInstance,           /* @parm Instance data which will be passed to
                                   <p pfnFilter> on each call. */
    PFNQUEUEFILTER pfnFilter)   /* @parm The function to call with each event */
{
    LPEVENT pPrev;
    LPEVENT pCurr;
    LPEVENT pNext;

    DPF(4, "QueueFilter(%04X, %08lX, %08lX)", (WORD)pQueue, (DWORD)dwInstance, (DWORD)pfnFilter);

    pPrev = NULL;
    pCurr = pQueue->pHead;

    while (pCurr)
    {
        /* Callback is allowed to relink into another queue, so save the next
         * pointer now.
         */
        pNext = pCurr->lpNext;

        switch((*pfnFilter)(pCurr, dwInstance))
        {
            case QUEUE_FILTER_REMOVE:
                if (pPrev)
                {
                    pPrev->lpNext = pNext;
                }
                else
                {
                    pQueue->pHead = pNext;
                }

                if (pNext == NULL)
                {
                    pQueue->pTail = pPrev;
                }

                --pQueue->cEle;
                
                AssertQueueValid(pQueue);
                
                pCurr = pNext;
                break;

            case QUEUE_FILTER_KEEP:
                pPrev = pCurr;
                pCurr = pNext;
                break;
                
            default:
                assert(0);
        }
    }

    AssertQueueValid(pQueue);
}

/* @func Peek at the head of the event queue to see what's next
 *
 * @comm
 *
 * Non-destructively return the first event in the queue
 *
 * @rdesc
 * Returns the event pointer or NULL if the queue is empty
 */
LPEVENT PASCAL
QueuePeek(
    NPEVENTQUEUE pQueue)
{
    DPF(4, "QueuePeek(%04X)", (WORD)pQueue);
            
    return pQueue->pHead;
}

/* @func Look at the queue and make sure it's internally consistent.
 *
 * @comm
 *
 * Walk the queue and make sure it isn't circularly linked. Also make sure the count
 * is correct.
 *
 * Asserts into debugger if queue is corrupt.
 *
 * Called by the AssertQueueValid macro in debug builds.
 *
 * Disables interrupts to avoid false reports of corruption based on the queue changing under
 * the routine.
 *
 */
#ifdef DEBUG
void PASCAL
_AssertQueueValid(
    NPEVENTQUEUE pQueue,
    LPSTR szFile,
    UINT uLine)
{
    LPEVENT pEventSlow;
    LPEVENT pEventFast;
    UINT cEle;
    WORD wIntStat;
    BOOL fTrace = FALSE;

    wIntStat = DisableInterrupts();
    
    if (!pQueue)
    {
        DPF(0, "_AssertQueueValid %s@%u: Passed NULL!", szFile, uLine);
        assert(FALSE);
        goto cleanup;
    }

    pEventFast = pEventSlow = pQueue->pHead;

    cEle = 0;

    while (pEventSlow)
    {
        ++cEle;
        pEventSlow = pEventSlow->lpNext;
        
        if (pEventFast)
        {
            pEventFast = pEventFast->lpNext;
        }

        if (pEventFast)
        {
            pEventFast = pEventFast->lpNext;
        }
        
        if (pEventSlow && pEventFast && pEventSlow == pEventFast)
        {
            DPF(0, "_AssertQueueValid %s@%u: Queue %04X is circularly linked!",
                szFile,
                uLine,
                (WORD)pQueue);
            assert(FALSE);
            fTrace = TRUE;
            break;
        }
    }
    
    if (cEle != pQueue->cEle)
    {
        DPF(0, "_AssertQueueValid %s@%u: Queue %04X has incorrect element count!",
            szFile,
            uLine,
            (WORD)pQueue);
        assert(FALSE);
        fTrace = TRUE;
    }
    
    if ((pQueue->pHead && !pQueue->pTail) ||
        (pQueue->pTail && !pQueue->pHead))
    {
        DPF(0, "_AssertQueueValid %s@%u: Queue %04X head XOR tail is NULL!",
            szFile,
            uLine,
            (WORD)pQueue);
        assert(FALSE);
        fTrace = TRUE;
    }

    if (fTrace)
    {
        DPF(0, "Queue %04X: head %08lX tail %08lX count %u",
            (WORD)pQueue,
            (DWORD)pQueue->pHead,
            (DWORD)pQueue->pTail,
            (WORD)pQueue->cEle);
        
        for (pEventSlow = pQueue->pHead; pEventSlow; pEventSlow = pEventSlow->lpNext)
        {
            DPF(2, "  Event %08lX: lpNext %08lX msTime %lu wFlags %04X cbEvent %04X",
                (DWORD)pEventSlow,
                (DWORD)pEventSlow->lpNext,
                (DWORD)pEventSlow->msTime,
                (WORD)pEventSlow->wFlags,
                (WORD)pEventSlow->cbEvent);
        }
    }

cleanup:
    RestoreInterrupts(wIntStat);
}
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\locks.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @module locks.c - Manage page-locking the code which will be accessed via callbacks from MMSYSTEM |
 *
 */
#include <windows.h>
#include <mmsystem.h>
#include "dmusic16.h"
#include "debug.h"

#define SINTEXT     __segname("FIX_IN_TEXT")
#define SOUTTEXT    __segname("FIX_OUT_TEXT")
#define SCOMMTEXT   __segname("FIX_COMM_TEXT")
#define SDATA       __segname("_DATA")

static VOID PASCAL NEAR
ForcePresent(
    WORD wSegment)
{
    LPBYTE lpb = (LPBYTE)MAKELP(wSegment, 0);

    _asm 
    {
        les bx, [lpb]
        mov al, es:[bx]
    }
}


/* @func Page lock needed segments 
 *
 */
VOID PASCAL
LockCode(
    WORD wFlags)            /* @parm What to lock: Any combination of: */
                            /* @flag LOCK_F_INPUT  | To lock the MIDI input code segments */
                            /* @flag LOCK_F_OUTPUT | To lock the MIDI output code segments */
                            /* @flag LOCK_F_COMMON | To lock the common code segments */

{
    if (wFlags & LOCK_F_INPUT)
    {
        ForcePresent(SINTEXT);
        if (!GlobalSmartPageLock(SINTEXT))
        {
            DPF(0, "Could not lock input text");
        }
    }
    
    if (wFlags & LOCK_F_OUTPUT)
    {
        ForcePresent(SOUTTEXT);
        if (!GlobalSmartPageLock(SOUTTEXT))
        {
            DPF(0, "Could not lock output text");
        }
    }

    if (wFlags & LOCK_F_COMMON)
    {
        ForcePresent(SCOMMTEXT);
        if (!GlobalSmartPageLock(SCOMMTEXT))
        {
            DPF(0, "Could not lock common text");
        }

        ForcePresent(SDATA);
        if (!GlobalSmartPageLock(SDATA))
        {
            DPF(0, "Could not lock data segment");
        }
    }
}

/* @func Page unlock needed segments 
 *
 * @comm
 */
VOID PASCAL
UnlockCode(
    WORD wFlags)            /* @parm What to unlock: Any combination of: */
                            /* @flag LOCK_F_INPUT  | To unlock the MIDI input code segments */
                            /* @flag LOCK_F_OUTPUT | To unlock the MIDI output code segments */
                            /* @flag LOCK_F_COMMON | To unlock the common code segments */

{
    if (wFlags & LOCK_F_INPUT)
    {
        if (!GlobalSmartPageUnlock(SINTEXT))
        {
            DPF(0, "Could not unlock input text");
        }
    }
    
    if (wFlags & LOCK_F_OUTPUT)
    {
        if (!GlobalSmartPageUnlock(SOUTTEXT))
        {
            DPF(0, "Could not unlock output text");
        }
    }

    if (wFlags & LOCK_F_COMMON)
    {
        if (!GlobalSmartPageUnlock(SCOMMTEXT))
        {
            DPF(0, "Could not unlock common text");
        }

        if (!GlobalSmartPageUnlock(SDATA))
        {
            DPF(0, "Could not unlock data");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\list.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @DOC DMusic16
 *
 * @MODULE List.c - Generic list management |
 */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

#ifdef DEBUG
STATIC BOOL PASCAL IsNodeInList(NPLINKNODE pHead, NPLINKNODE pNode);
#endif

/* @func Insert a node into a linked list.
 *
 */
VOID PASCAL
ListInsert(
    NPLINKNODE *pHead,      /* @parm A pointer to the list head */
    NPLINKNODE pNode)       /* @parm A pointer to the node to insert */
{
    assert(!IsNodeInList(*pHead, pNode));
    
    if (*pHead)
    {
        (*pHead)->pPrev = pNode;
    }

    pNode->pNext = *pHead;
    pNode->pPrev = NULL;
    *pHead = pNode;
}

/* @func Remove a node into a linked list.
 *
 * @comm
 *
 * The node must exist in the list. The debug version which check for this.
 */
VOID PASCAL
ListRemove(
    NPLINKNODE *pHead,      /* @parm A pointer to the list head */
    NPLINKNODE pNode)       /* @parm A pointer to the node to delete */
{
    assert(IsNodeInList(*pHead, pNode));

    if (pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }
    else
    {
        *pHead = pNode->pNext;
    }

    if (pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }
}


#ifdef DEBUG
/* @func Determine if a node is in a linked list.
 *
 */
STATIC BOOL PASCAL
IsNodeInList(
    NPLINKNODE pHead,       /* @parm A pointer to the first node in the list */
    NPLINKNODE pNode)       /* @parm A pointer to the node to look for in the list */
{
    for (; pHead; pHead = pHead->pNext)
    {
        if (pHead == pNode)
        {
            return TRUE;
        }
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\locks.h ===
// Copyright (c) 1998 Microsoft Corporation
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\makefile.inc ===
!if 0
Copyright (c) 1998 Microsoft Corporation
!endif

dmusic16.dll: 
	nmake -f makefile.16 OBJDIR=.\obj\i386
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;	Copyright (c) 1987-1998 Microsoft Corporation
;
;Purpose:
;	This file contains definitions of a number of macros which
;	make the writing of memory model dependent code for the
;	8086 a little easier and more portable.
;
;*******************************************************************************

; the macro below is used by the assigning long arithmetic routines (almul,
; etc) to handle the model dependent data addressing - in small and middle
; models data addresses default to short (2 byte) addresses. in large model,
; data address are long (4 bytes).

LOAD	macro	to,from
if	sizeD
	lds	to,from
else
	mov	to,from
endif
	endm


; general code & data size constants & macros

if	sizeD			; 4 byte data addresses
DAT_ADDR_SZ =	4
BDAT_ADDR_SZ =	2
else				; 2 byte data addresses
DAT_ADDR_SZ =	2
BDAT_ADDR_SZ =	4
endif

if	sizeC			; 4 byte code addresses
TXT_ADDR_SZ =	4
else				; 2 byte code addresses
TXT_ADDR_SZ =	2
endif


; Big/Little Endian Definitions for Long Integers

LOWORD	equ	[0]
HIWORD	equ	[2]


; All Model Definitions

BPARGBAS equ	TXT_ADDR_SZ+2	; offset from BP to first argument


; macro for windows fixup with retf #

return	macro	n
	org	$-1
if	sizeC
	db	0cah
else
	db	0c2h
endif
	dw	n
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\midiout.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @Module MIDIOut.c - Legacy MIDI output emulation for DirectMusic |
 *
 * @comm
 *
 * BUGBUG Need to deal with timer wraparound
 *
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

#define MIDI_CHANMSG_STATUS_CMD_MASK    (0xF0)
#define MIDI_NOTE_ON                    (0x90)

/* How far past the current time do we send events?
 */
#define MS_TIMER_SLOP           (3)

STATIC TIMECAPS gTimeCaps;
STATIC BOOL gbTimerRunning;
STATIC DWORD gdwTimerDue;
STATIC UINT guTimerID;
STATIC UINT gcActiveOutputDevices;

int PASCAL IsEventDone(LPEVENT pEvent, DWORD dwInstance);
VOID SetNextTimer();
VOID CALLBACK __loadds midiOutProc(HMIDIOUT hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
VOID CALLBACK __loadds RunTimer(UINT uTimerID, UINT wMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
STATIC VOID NEAR PASCAL MidiOutFlushQueues(NPOPENHANDLE poh);
STATIC VOID NEAR PASCAL MidiOutSendAllNow(NPOPENHANDLE poh);

#pragma alloc_text(INIT_TEXT, MidiOutOnLoad)
#pragma alloc_text(FIX_OUT_TEXT, midiOutProc)
#pragma alloc_text(FIX_OUT_TEXT, RunTimer)

/* @func Called at DLL <f LibInit>
 *
 * @comm
 *
 * Get the timer caps.
 * Initialize globals.
 */
VOID PASCAL
MidiOutOnLoad()
{
    /* This cannot fail
     */
    timeGetDevCaps(&gTimeCaps, sizeof(gTimeCaps));

    gbTimerRunning = FALSE;
}

/* @func Called at DLL <f LibExit>
 *
 * @comm
 *
 * The DLL is unloading, so kill any future timer callback.
 */
VOID PASCAL
MidiOutOnExit()
{
    WORD wIntStat;

    wIntStat = DisableInterrupts();

    if (gbTimerRunning)
    {
        DPF(1, "DLL unloading, killing timer interrupts");
        timeKillEvent(guTimerID);
        gbTimerRunning = FALSE;
    }
    
    RestoreInterrupts(wIntStat);
}

/* @func Open a handle instance
 *
 * @comm
 *
 */
MMRESULT PASCAL
MidiOutOnOpen(
    NPOPENHANDLEINSTANCE pohi)
{
    return MMSYSERR_NOERROR;
}

/* @func Close a MIDI device
 *
 * @comm
 *
 */
VOID PASCAL
MidiOutOnClose(
    NPOPENHANDLEINSTANCE pohi)
{
    /* Give MIDI input a chance to turn off thruing to this handle.
     */

    MidiInUnthruToInstance(pohi);
}

/* @func Activate a MIDI device
 *
 * @comm
 *
 * If this is the first activation of the device, open it using the <f midiOutOpen> legacy API.
 */
MMRESULT PASCAL
MidiOutOnActivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;
    HINSTANCE hInstance;
    WORD sel;
    WORD off;
    HTASK FAR *lph;

    DPF(1, "MidiOutActivate poh %04X device %d refcount %u", 
        (WORD)poh,
        poh->id,
        poh->uReferenceCount);

    /* Only open on the first activation 
     */    
    if (1 == poh->uActiveCount)
    {
        mmr = midiOutOpen(&poh->hmo,
                          poh->id,
                          (DWORD)midiOutProc,
                          (DWORD)(LPOPENHANDLE)poh,
                          CALLBACK_FUNCTION);
        if (mmr)
        {
            return mmr;
        }

        /* Since mapper can't be open shared, and we don't want the first instance that opens
         * mapper to take it with it on exit (due to mmsystem appexit), we do really nasty 
         * stuff here. 
         * 
         * The WORD immediately PRECEDING the handle in MMSYSTEM's data segment is the task
         * owner of the handle. We nuke it to NULL (which is all MIDI_IO_SHARED does anyway)
         * to make AppExit ignore us.
         *
         * God help us if anyone changes HNDL in mmsysi.h
         *
         */
        hInstance = LoadLibrary("mmsystem.dll");
        sel = (WORD)hInstance;

        /* hInstance <= 32 means LoadLibrary failed; in this case we just live with it.
         */
        if (sel > 32)
        {
            off = ((WORD)poh->hmo) - sizeof(WORD);
            lph = (HTASK FAR *)MAKELP(sel, off);
            *lph = (HTASK)NULL;
            FreeLibrary(hInstance);
        }

        /* If this is the first output device, bump up timer resolution
         */
        ++gcActiveOutputDevices;
        if (gcActiveOutputDevices == 1)
        {
            SetOutputTimerRes(TRUE);
        }

    }

    return MMSYSERR_NOERROR;
}

/* @func Deactivate a MIDI device
 *
 * @comm
 *
 * If the last client using the device is closing, then close the actual device.
 * If closing the last actual device, then shut down the high precision timer
 *
 */
MMRESULT PASCAL
MidiOutOnDeactivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    DPF(1, "MidiOutOnDeactivate poh %04X device %d refcount %u",
        (WORD)poh,
        poh->id,
        poh->uReferenceCount);

    if (poh->uActiveCount)
    {
        /* Still open instances out there
         */
        return MMSYSERR_NOERROR;
    }

	MidiOutSendAllNow(poh);
    midiOutReset(poh->hmo);
    midiOutClose(poh->hmo);
    MidiOutFlushQueues(poh);

    /* If this was the last output device, shut down precision timer resolution
     */
    --gcActiveOutputDevices;
    if (gcActiveOutputDevices == 0)
    {
        SetOutputTimerRes(FALSE);
    }

	return MMSYSERR_NOERROR;
}
             
/* @func Set the timer resolution
 *
 * @comm
 *
 * Set the resolution of the timer callbacks using the <f timeBeginPeriod> and <f timeEndPeriod>
 * API's.
 *
 * If <p fOnOpen> is TRUE, then the timer resolution will be changed to 1 millisecond. Otherwise, it
 * will be set to its previous value.
 *
 */
VOID PASCAL
SetOutputTimerRes(
    BOOL fOnOpen)           /* @parm TRUE if we are supposed to raise precision */
{
    MMRESULT mmr;
    
    if (fOnOpen)
    {
        mmr = timeBeginPeriod(gTimeCaps.wPeriodMin);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Could not timeBeginPeriod() -> %u", (UINT)mmr);
        }
    }
    else
    {
        mmr = timeEndPeriod(gTimeCaps.wPeriodMin);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Could not timeEndPeriod() -> %u", (UINT)mmr);
        }
    }
}
   

/* @func Submit a buffer to a device for playback
 *
 * @rdesc Returns one of the following
 * @flag MMSYSERR_NOERROR | If the buffer was successfully queued
 * @flag MMSYSERR_INVALPARAM | If the buffer is incorrectly packed or the handle is invalid
 * @flag MMSYSERR_NOMEM | If there was no memory available to queue the events
 *
 * @comm
 *
 * This function is thunked to DMusic32.
 *
 * The DirectMusic port interface specifies that a submitted buffer not be
 * kept by the system past the time of the call which submits it.
 *
 * This routine parses the buffer into individual events and copies them into
 * local event structures, which are then queued onto the handle of the device
 * specified by <p h>. The queue for each device is kept in time-increasing order.
 * All local event memory is page-locked (see alloc.c) so that it can be accessed
 * at interrupt time.
 *
 * The time stamps in the buffer are millisecond resolution and are relative to
 * the absolute time <p msStartTime>.
 *
 */
MMRESULT WINAPI
MidiOutSubmitPlaybackBuffer(
    HANDLE h,                   /* @parm The handle of the device to queue these events for */
    LPBYTE lpBuffer,            /* @parm A pointer to the buffer as packed by the IDirectMusicBuffer interface */
    DWORD cbBuffer,             /* @parm The number of bytes of data in the buffer */
    DWORD msStartTime,          /* @parm The starting time of the buffer in absolute time */
    DWORD rtStartTimeLow,       /* @parm Low DWORD of starting reference time */
    DWORD rtStartTimeHigh)      /* @parm High DWORD of starting reference time */
{
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLE poh;
    LPDMEVENT lpEventHdr;
    DWORD cbEvent;
    DWORD msTime;
    LPEVENT pPrev;
    LPEVENT pCurr;
    LPEVENT pNew;
    WORD    wCSID;
    MMRESULT mmr;
    LPMIDIHDR lpmh;
    QUADWORD rtStartTime;
    QUADWORD rtTime;

#ifdef DUMP_EVERY_BUFFER
    UINT idx;
    LPDWORD lpdw;
#endif //DUMP_EVERY_BUFFER
    
    rtStartTime.dwLow = rtStartTimeLow;
    rtStartTime.dwHigh = rtStartTimeHigh;

    DPF(2, "Buffer @ %08lX msStartTime %lu", (DWORD)lpBuffer, (DWORD)msStartTime);
    DPF(2, "At the tone the time will be... %lu <BEEP>", (DWORD)timeGetTime());

#ifdef DUMP_EVERY_BUFFER
    cbEvent = cbBuffer & 0xFFFFFFF0;

    lpdw = (LPDWORD)lpBuffer;
    for (idx = 0; idx < cbEvent; idx += 16) {
        DPF(3, "%04X: %08lX %08lX %08lX %08lX",
            (UINT)idx,
            lpdw[0],
            lpdw[1],
            lpdw[2],
            lpdw[3]);
        lpdw += 4;
    }

    cbEvent = cbBuffer - (cbBuffer & 0xFFFFFFF0);

    if (cbEvent >= 12) {
        DPF(3, "%04x: %08lX %08lX %08lX",
            (UINT)idx, lpdw[0], lpdw[1], lpdw[2]);
    } else if (cbEvent >= 8) {
        DPF(3, "%04x: %08lX %08lX",
            (UINT)idx, lpdw[0], lpdw[1]);
    } else if (cbEvent >= 8) {
        DPF(3, "%04x: %08lX",
            (UINT)idx, lpdw[0]);
    }
#endif // DUMP_EVERY_BUFFER
    
    if (!IsValidHandle(h, VA_F_OUTPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    /* Get the handle and lock its list
     */
    poh = pohi->pHandle;

    /* Dequeue and free all completed events on this handle
     */
    FreeDoneHandleEvents(poh, FALSE);

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    /* Get the time of the first event and position ourselves in the list
     */
    if (0 == poh->qPlay.cEle)
    {
        pPrev = NULL;
        pCurr = NULL;
    }
    else if (!QuadwordLT(rtStartTime, poh->qPlay.pTail->rtTime))
    {
        pPrev = poh->qPlay.pTail;
        pCurr = NULL;
    }
    else
    {
        pPrev = NULL;
        pCurr = poh->qPlay.pHead;
    }
    
    /* Walk the buffer and add the events to the handle's queue
     */
    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMEVENT))
        {
            return MMSYSERR_INVALPARAM;
        }

        lpEventHdr = (LPDMEVENT)lpBuffer;
        cbEvent = DMEVENT_SIZE(lpEventHdr->cbEvent);
        DPF(2, "cbEvent now %u", (UINT)cbEvent);
        if (cbEvent > cbBuffer)
        {
            DPF(0, "Event past end of buffer");
            return MMSYSERR_INVALPARAM;
        }
        
        lpBuffer += cbEvent;
        cbBuffer -= cbEvent;

        /* We only play events on channel group 1 (0 is broadcast, so we
         * play that as well).
         */
        if (lpEventHdr->dwChannelGroup > 1)
        {
            continue;
        }

        // Time here is in 100ns for queue sorting
        //
        QuadwordAdd(rtStartTime, lpEventHdr->rtDelta, &rtTime);
        
        // Also need msTime for scheduling
        //
        msTime = msStartTime + QuadwordDiv(lpEventHdr->rtDelta, REFTIME_TO_MS);


        // BUGBUG: >64k??
        //
        DPF(2, "Schedule event %02X%02X%02X%02X at %lu",
            (BYTE)lpEventHdr->abEvent[0],
            (BYTE)lpEventHdr->abEvent[1],
            (BYTE)lpEventHdr->abEvent[2],
            (BYTE)lpEventHdr->abEvent[3],
            msTime);

        if (lpEventHdr->cbEvent <= sizeof(DWORD))
        {
            pNew = AllocEvent(msTime, rtTime, (WORD)lpEventHdr->cbEvent);
            if (!pNew)
            {
                return MMSYSERR_NOMEM;
            }
            
            hmemcpy(pNew->abEvent, lpEventHdr->abEvent, lpEventHdr->cbEvent);
        }
        else
        {
            pNew = AllocEvent(msTime, rtTime, (WORD)(lpEventHdr->cbEvent + sizeof(MIDIHDR)));
            if (!pNew)
            {   
                return MMSYSERR_NOMEM;
            }

            pNew->wFlags |= EVENT_F_MIDIHDR;

            lpmh = (LPMIDIHDR)&pNew->abEvent;

            lpmh->lpData =          (LPSTR)(lpmh + 1);
            lpmh->dwBufferLength =  lpEventHdr->cbEvent;
            lpmh->dwUser =          0;  /* Flag if MMSYSTEM owns this buffer */
            lpmh->dwFlags =         0;

            hmemcpy(lpmh->lpData, lpEventHdr->abEvent, lpEventHdr->cbEvent);
            mmr = midiOutPrepareHeader(poh->hmo, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {
                DPF(2, "midiOutPrepareHeader %u", mmr);
                FreeEvent(pNew);
                return mmr;
            }
        }

        while (pCurr)
        {
            if (QuadwordLT(rtTime, pCurr->rtTime))
            {
                break;
            }

            pPrev = pCurr;
            pCurr = pCurr->lpNext;
        }

        if (pPrev)
        {
            pPrev->lpNext = pNew;
        }
        else
        {
            poh->qPlay.pHead = pNew;
        }

        pNew->lpNext = pCurr;
        if (NULL == pCurr)
        {
            poh->qPlay.pTail = pNew;
        }

        pPrev = pNew;
        pCurr = pNew->lpNext;

        ++poh->qPlay.cEle;

        AssertQueueValid(&poh->qPlay);
    }

    LeaveCriticalSection(&poh->wCritSect);

    SetNextTimer();
    
    return MMSYSERR_NOERROR;
}

/* @func VOID PASCAL | FreeDoneHandleEvents | Free events that have already been played, but are still sitting in the done queue
 * on this handle.
 *
 * @comm
 *
 * If fClosing is TRUE, then the events will be free'd regardless of whether they are marked as completed.
 *
 */
typedef struct {
    NPOPENHANDLE poh;
    BOOL fClosing;
} ISEVENTDONEPARMS, FAR *LPISEVENTDONEPARMS;

VOID PASCAL
FreeDoneHandleEvents(
    NPOPENHANDLE poh,       /* @parm What handle? */
    BOOL fClosing)          /* @parm TRUE if the device is being closed. */
{
    ISEVENTDONEPARMS iedp;
    WORD wCSID;

    iedp.poh = poh;
    iedp.fClosing = fClosing;
    
    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    QueueFilter(&poh->qDone, (DWORD)(LPVOID)&iedp, IsEventDone);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func
 *
 * @comm
 */
int PASCAL
IsEventDone(
    LPEVENT pEvent,
    DWORD dwInstance)
{
    LPISEVENTDONEPARMS piedp = (LPISEVENTDONEPARMS)dwInstance;
    MMRESULT mmr;
    
    if (piedp->fClosing ||
        pEvent->cbEvent <= sizeof(DWORD) ||
        ((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser == 0)
    {
        /* Ok to free this event
         */
        
        if (pEvent->cbEvent > sizeof(DWORD))
        {
            mmr = midiOutUnprepareHeader(piedp->poh->hmo, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
            if (mmr)
            {
                DPF(0, "FreeOldEvents: midiOutUnprepareHeader returned %u", (UINT)mmr);
            }
        }
        
        FreeEvent(pEvent);

        return QUEUE_FILTER_REMOVE;
    }   

    return QUEUE_FILTER_KEEP;
}

/* @func Thru the given message on the given output port
 *
 * @comm
 *
 */
VOID PASCAL 
MidiOutThru(
    NPOPENHANDLEINSTANCE pohi, 
    DWORD dwMessage)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    /* !!! Verify that VMM will not interrupt a timer callback with another event
     */
    mmr = midiOutShortMsg(poh->hmo, dwMessage);
    if (mmr)
    {
        DPF(0, "Thru: midiOutShortMsg() -> %d", mmr);
    }    
}


/* @func Set the timer to schedule the next pending event
 *
 * @comm
 *
 * Walk the list of output handles and look at the first scheduled event on each. Save the time
 * of the nearest event. If there is such an event, schedule a timer callback at that time to call
 * <f RunTimer>; otherwise, schedule no callback.
 * 
 * Any pending timer callback will be killed before the new callback is scheduled.
 */
VOID
SetNextTimer(VOID)
{
    WORD wIntStat;

    NPLINKNODE npLink;
    NPOPENHANDLE poh;
    DWORD dwLowTime;
    BOOL fNeedTimer;
    DWORD dwNow;
    LONG lWhen;
    UINT uWhen;

    /* We actually need to disable interrupts here as opposed to just entering a critical section
     * because we don't want the timer callback to fire.
     */
    wIntStat = DisableInterrupts();

    /* BUGBUG: wrap
     */
    fNeedTimer = FALSE;
    dwLowTime = (DWORD)(0xFFFFFFFFL);
    for (npLink = gOpenHandleList; npLink; npLink = npLink->pNext)
    {
        poh = (NPOPENHANDLE)npLink;

        if (0 == poh->qPlay.cEle)
        {
            continue;
        }
        
        assert(poh->qPlay.pHead);
        

        if (poh->qPlay.pHead->msTime < dwLowTime)
        {
            fNeedTimer = TRUE;
            dwLowTime = poh->qPlay.pHead->msTime;
        }
    }

    if (fNeedTimer)
    {
        if ((!gbTimerRunning) || dwLowTime < gdwTimerDue)
        {
            /* We need to set the timer. Kill it now so there's no chance of it
             * firing before being killed
             */
            if (gbTimerRunning)
            {
                timeKillEvent(guTimerID);
                gbTimerRunning = FALSE;
            }
        }
        else
        {
            fNeedTimer = FALSE;
        }
    }

    RestoreInterrupts(wIntStat);

    if (fNeedTimer)
    {
        /* Guaranteed that current timer expired or dead. Reschedule.
         */

        dwNow = timeGetTime();
        gbTimerRunning = TRUE;
        gdwTimerDue = dwLowTime;

        lWhen = gdwTimerDue - dwNow;
        if (lWhen < (LONG)gTimeCaps.wPeriodMin)
        {
            uWhen = gTimeCaps.wPeriodMin;
        }
        else if (lWhen > (LONG)gTimeCaps.wPeriodMax)
        {
            uWhen = gTimeCaps.wPeriodMax;
        }
        else
        {
            uWhen = (UINT)lWhen;
        }

        DPF(2, "SetNextTimer: Now %lu, setting timer for %u ms from now. dwLowTime %lu",
           (DWORD)dwNow, (UINT)uWhen, (DWORD)dwLowTime);
        guTimerID = timeSetEvent(uWhen,
                                 gTimeCaps.wPeriodMin,
                                 RunTimer,
                                 NULL,
                                 TIME_ONESHOT);
        if (0 == guTimerID)
        {
            gbTimerRunning = FALSE;
        }
    }
    else
    {
        DPF(2, "SetNextTimer: Timer cancelled; no pending events.");
    }
}

/* @func Process a high precision timer callback
 *
 * @comm
 *
 * This is a standard callback for the <f timeSetEvent> API.
 *
 * Walk the list of open output handles. For each handle, look at the event queue. Play all
 * the events that are due.
 *
 * Events are pulled from the qPlay queue on each handle. This queue (as well as the qDone queue) are
 * protected by the handle's critical section. If we cannot get the critical section, then the events
 * that may be due on that handle will not be played.
 *
 * If we do get the critical section and play events, then the events will be moved to the qDone
 * queue, where they will later be returned to the free list.
 *
 * This intermediate step is needed because we cannot call <f FreeEvent> at interrupt time. We cannot
 * just protect the free list with a critical section, because we cannot afford to fail getting the
 * critical section. If we did, we would lost the memory for the event we were about to free.
 *
 */
VOID CALLBACK __loadds
RunTimer(
    UINT        uTimerID,           /* @parm The ID of the timer which fired */
    UINT        wMsg,               /* @parm The type of callback (unused) */
    DWORD       dwUser,             /* @parm User instance data */
    DWORD       dw1,                /* @parm Message specific data (unused) */
    DWORD       dw2)                /* @parm Message specific data (unused) */
{    
    NPLINKNODE npLink;
    NPOPENHANDLE poh;
    WORD wCSID;
    WORD wIntStat;
    DWORD msNow;
    DWORD msFence;
    LPEVENT pEvent;
    DWORD dwEvent;
    MMRESULT mmr;


    /* Walk the event queues and send out pending events.
     */
    msNow = timeGetTime();
    msFence = msNow + MS_TIMER_SLOP;
    
    for (npLink = gOpenHandleList; npLink; npLink = npLink->pNext)
    {
        poh = (NPOPENHANDLE)npLink;

        /* If we can't get the critical section, don't sweat it - just reschedule
         */
        wCSID = EnterCriticalSection(&poh->wCritSect, CS_NONBLOCKING);
        if (!wCSID)
        {
            DPF(1, "Timer: Could not get critical section for '%04x'; next time.", (UINT)poh);
            continue;
        }

        /* Now safe against foreground messing with this handle
         */

        for(;;)
        {
            pEvent = poh->qPlay.pHead;
            if (NULL == pEvent || pEvent->msTime > msFence)
            {
                break;
            }

            if (pEvent->msTime > msNow)
            {
                DPF(2, "Late!");
            }

            QueueRemoveFromFront(&poh->qPlay);
            
            if (pEvent->cbEvent <= 4)
            {
                dwEvent = (pEvent->abEvent[0]) |
                          (((DWORD)pEvent->abEvent[1]) << 8) |
                          (((DWORD)pEvent->abEvent[2]) << 16);
                mmr = midiOutShortMsg(poh->hmo, dwEvent);
                if (mmr)
                {
                    DPF(0, "midiOutShortMsg(%04X,%08lX) -> %u",
                        (UINT)poh->hmo,
                        dwEvent,
                        (UINT)mmr);
                }
                else
                {
                    DPF(2, "midiOutShortMsg(%04X,%08lX) ",
                        (UINT)poh->hmo,
                        dwEvent);
                }
            }
            else
            {
                /* Data contains an already prepared long message.
                 * DON'T leave interrupts disabled here! Most legacy MIDI drivers
                 * do this synchronously.
                 *
                 */
                RestoreInterrupts(wIntStat);
                ((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser = 1;
                mmr = midiOutLongMsg(poh->hmo,
                                     (LPMIDIHDR)(&pEvent->abEvent[0]),
                                     sizeof(MIDIHDR));
                if (mmr)
                {
                    DPF(0, "midiOutLongMsg(%04X, %08lX, %04X) -> %u\n",
                        (UINT)poh->hmo,
                        (DWORD)(LPMIDIHDR)(&pEvent->abEvent[0]),
                        (UINT)sizeof(MIDIHDR),
                        (UINT)mmr);
                }
                DisableInterrupts();
            }
            

            /* We're done with this event; back to the free list with ya!
             *
             * Since we can't protect the free list with a critical section (what
             * would we do if getting the critical section failed here?) we keep
             * a temporary free list in the handle. Free events are moved from
             * the handle to the master free list in user time.
             */
            QueueAppend(&poh->qDone, pEvent);
        }

        LeaveCriticalSection(&poh->wCritSect);
    }

    /* Now reschedule ourselves if needed.
     */
    gbTimerRunning = FALSE;
    SetNextTimer();

}


VOID CALLBACK _loadds
midiOutProc(
    HMIDIOUT hMidiIn,
    UINT wMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2)
{
    LPOPENHANDLE poh = (LPOPENHANDLE)dwInstance;

    switch(wMsg)
    {
        case MOM_DONE:
            /* Buffer is already queued for free on the device's queue. dwUser flags if it
             * is still in use by MMSYSTEM/driver.
             */
            ((LPMIDIHDR)dwParam1)->dwUser = 0;
            break;
    }
}

/* @func Return all memory from all queues to the free event list.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiOutFlushQueues(
    NPOPENHANDLE poh)
{
    WORD wCSID;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    FreeAllQueueEvents(&poh->qPlay);
    FreeAllQueueEvents(&poh->qDone);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func Send all pending messages (other than note on) in preperation
 * to close the port.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiOutSendAllNow(
	NPOPENHANDLE poh)
{
	LPEVENT pEvent;
	DWORD dwEvent;
	MMRESULT mmr;
	WORD wCSID;
	
	wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
	assert(wCSID);

	/* Now safe against foreground messing with this handle
	 */

	for(;;)
	{
    	pEvent = poh->qPlay.pHead;
	    if (NULL == pEvent)
	    {
	    	DPF(2,"MidiOutSendAllNow: No queued Messages.");
	        break;
	    }

	    QueueRemoveFromFront(&poh->qPlay);
    
	    if (pEvent->cbEvent <= 4)
	    {
	        dwEvent = (pEvent->abEvent[0]) |
	                 (((DWORD)pEvent->abEvent[1]) << 8) |
                  (((DWORD)pEvent->abEvent[2]) << 16);

			// We aren't going to process MIDI_NOTE_ON with a
			// velocity of zero

			//There are two kinds of short messages,  Two Byte and 
			//Three Byte..  They pack differently in MIDI Short message

			//If the first bit if the High Byte of the Low Word is SET we are
			//looking at a 3 byte message.

			//MIDI status messages begin with a 
			//set bit, and every other part of the same message starts with an
			//unset bit.
			if (HIBYTE(LOWORD(dwEvent) & 0x80) )
			{
				//This is a THREE BYTE message

				// note on with a non-zero velocity is skipped
				if ( (HIBYTE(LOWORD(dwEvent)) & MIDI_NOTE_ON) && (LOBYTE(LOWORD(dwEvent)) != 0 ))
				{
					QueueAppend(&poh->qDone, pEvent);
					continue;
				}
			}
			else
			{
				//This is a THREE BYTE Message

				// Any note-on is skiped
				if (LOBYTE(LOWORD(dwEvent)) & MIDI_NOTE_ON)
				{
					QueueAppend(&poh->qDone, pEvent);
					continue;
				}
			}
            
    	    mmr = midiOutShortMsg(poh->hmo, dwEvent);
        	if (mmr)
        	{
            	DPF(0, "midiOutShortMsg(%04X,%08lX) -> %u",
                (UINT)poh->hmo,
                dwEvent,
                (UINT)mmr);
        	}
        	else
        	{
            DPF(2, "midiOutShortMsg(%04X,%08lX) ",
                (UINT)poh->hmo,
                dwEvent);
        	}
    	}
    	else
    	{
        	/* Data contains an already prepared long message.
         	* DON'T leave interrupts disabled here! Most legacy MIDI drivers
         	* do this synchronously.
         	*
         	*/
        	((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser = 1;
        	mmr = midiOutLongMsg(poh->hmo,
                             (LPMIDIHDR)(&pEvent->abEvent[0]),
                             sizeof(MIDIHDR));
        	if (mmr)
        	{	
            	DPF(0, "midiOutLongMsg(%04X, %08lX, %04X) -> %u\n",
               		(UINT)poh->hmo,
               	 	(DWORD)(LPMIDIHDR)(&pEvent->abEvent[0]),
                	(UINT)sizeof(MIDIHDR),
                	(UINT)mmr);
        	}
    	}
    

    	/* We're done with this event; back to the free list with ya!
     	*
     	* Since we can't protect the free list with a critical section (what
     	* would we do if getting the critical section failed here?) we keep
     	* a temporary free list in the handle. Free events are moved from
     	* the handle to the master free list in user time.
     	*/
    	QueueAppend(&poh->qDone, pEvent);
	}

	LeaveCriticalSection(&poh->wCritSect);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\midiin.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @Module MIDIIn.c - Legacy MIDI capture emulation for DirectMusic |
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <mmsystem.h>
#include <stddef.h>

#include "dmusic16.h"
#include "debug.h"

#define IS_STATUS_BYTE(x)     ((x) & 0x80)
#define IS_CHANNEL_MSG(x)     (((x) & 0xF0) != 0xF0)
#define IS_SYSEX(x)           ((x) == 0xF0)

#define SYSEX_SIZE            4096  
                            /* (65535 - sizeof(MIDIHDR) - sizeof(EVENT) - sizeof(SEGHDR)) */
#define SYSEX_BUFFERS         8                     /* Keep 2 buffers outstanding */

static unsigned cbChanMsg[16] =
{
    0, 0, 0, 0, 0, 0, 0, 0, /* Running status */
    3, 3, 3, 3, 2, 2, 3, 0
};

static unsigned cbSysCommData[16] =
{
    1, 2, 3, 2, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
};

VOID CALLBACK _loadds midiInProc(HMIDIIN hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
STATIC BOOL NEAR PASCAL RecordShortEvent(NPOPENHANDLE poh, DWORD dwMessage, DWORD dwTime);
STATIC BOOL NEAR PASCAL RecordSysExEvent(NPOPENHANDLE poh, LPMIDIHDR lpmh, DWORD dwTime);
STATIC VOID NEAR PASCAL NotifyClientList(LPOPENHANDLE poh);
STATIC VOID NEAR PASCAL ThruClientList(LPOPENHANDLE poh, DWORD dwMessage);
STATIC VOID NEAR PASCAL RefillFreeEventList(NPOPENHANDLE poh);
STATIC VOID NEAR PASCAL MidiInFlushQueues(NPOPENHANDLE poh);

#pragma alloc_text(INIT_TEXT, MidiOutOnLoad)
#pragma alloc_text(FIX_IN_TEXT, midiInProc)
#pragma alloc_text(FIX_IN_TEXT, RecordShortEvent)
#pragma alloc_text(FIX_IN_TEXT, RecordSysExEvent)
#pragma alloc_text(FIX_IN_TEXT, NotifyClientList)
#pragma alloc_text(FIX_IN_TEXT, ThruClientList)

/* @func Called at DLL <f LibInit>
 *
 * @comm
 *
 * Currently does nothing.
 *
 */
VOID PASCAL
MidiInOnLoad(VOID)
{
}

/* @func Called at DLL <f LibExit>
 *
 * @comm
 *
 * Currently does nothing
 */
VOID PASCAL
MidiInOnExit()
{
}

/* @func Open a MIDI in device
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | on success
 * @flag MMSYSERR_NOMEM | on out of memory
 *
 * @comm
 *
 * Makes sure only one client is opening the device.
 *
 * Opens the device and starts MIDI input on it, noting the time of the start for timestamp calculations.
 */
MMRESULT PASCAL
MidiInOnOpen(
    NPOPENHANDLEINSTANCE pohi)      /* @parm The open handle instance to fulfill */
{
    NPOPENHANDLE poh = pohi->pHandle;

    int iChannel;    
    MMRESULT mmr;

    /* Protect here against more than one client opening an input device.
     */
    if (poh->uReferenceCount > 1) 
    {
        return MMSYSERR_ALLOCATED;
    }
    
    /* Per client initialize thruing to NULL. 
     */
    pohi->pThru = (NPTHRUCHANNEL)LocalAlloc(LPTR, MIDI_CHANNELS * sizeof(THRUCHANNEL));
    if (pohi->pThru == NULL)
    {
        return MMSYSERR_NOMEM;
    }

    DPF(2, "MidiInOnOpen: pohi %04X pThru %04X", pohi, pohi->pThru);

    for (iChannel = 0; iChannel < MIDI_CHANNELS; iChannel++)
    {
        pohi->pThru[iChannel].pohi = (HANDLE)NULL;
    }

    return MMSYSERR_NOERROR;
}

/* @func Close a MIDI in device
 *
 * @comm
 *
 * Close the device using the <f midiInClose> API.
 */
VOID PASCAL
MidiInOnClose(
    NPOPENHANDLEINSTANCE pohi)      /* @parm The open handle instance to close */
{
}

/* @func Activate a MIDI in device
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | on success
 * @flag MMSYSERR_ALLOCATED | if the device is already in use
 *
 * May also return any of the possible return codes from the <f midiInOpen> API call.
 *
 * @comm
 *
 * Opens the device and starts MIDI input on it, noting the time of the start for timestamp calculations.
 */
MMRESULT PASCAL
MidiInOnActivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    if (1 == poh->uActiveCount)
    {
        poh->wFlags &= ~OH_F_CLOSING;
        mmr = midiInOpen(&poh->hmi,
                         poh->id,
                         (DWORD)midiInProc,
                         (DWORD)(LPOPENHANDLE)poh,
                         CALLBACK_FUNCTION);
        if (mmr)
        {
            return mmr;
        }

        mmr = midiInStart(poh->hmi);
        poh->msStartTime = timeGetTime();
        if (mmr)
        {   
            midiInClose(poh->hmi);
        }

        /* NOTE: poh memory is guaranteed zeroed by allocator, so we have
         * no event count and NULL pointers right now.
         */
        RefillFreeEventList(poh);
    }

    return MMSYSERR_NOERROR;
}

/* @func Deactivate a MIDI in device
 *
 * @comm
 *
 * Close the device using the <f midiInClose> API.
 */
MMRESULT PASCAL
MidiInOnDeactivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    if (0 == poh->uActiveCount)
    {
        poh->wFlags |= OH_F_CLOSING;
        mmr = midiInStop(poh->hmi);
        if (mmr)
        {
            return mmr;
        }

        if (MMSYSERR_NOERROR == midiInReset(poh->hmi))
        {
            while (poh->wPostedSysExBuffers)
            {
            }
        }

        midiInClose(poh->hmi);
        MidiInFlushQueues(poh);
    }

    return MMSYSERR_NOERROR;
}


/* @func Set the event handle to signal
 *
 * @rdesc Always returns MMSYSERR_NOERROR.
 *
 * @comm
 *
 * This function is exported through the thunk layer to DMusic32.DLL
 *
 * This handle is already the VxD handle that can be passed to VWin32 via MMDEVLDR using
 * <f SetWin32Event>.
 *
 * Input notification is delivered to the Win32 application using events. The application creates
 * an event using the <f CreateEvent> API and gives it to the DirectMusic port. The port code
 * for legacy emulation calls the undocumented Win9x kernel API <f OpenVxDHandle> to retrieve
 * an equivalent event handle that is valid in any kernel context. That handle is passed to
 * this function.
 *
 * The event handle is stored in our per-client data (<c OPENHANDLEINSTANCE>). When MIDI data
 * arrives, the event will be set. This is done using MMDEVLDR, which already has semantics
 * in place to do the same sort of notification for WinMM event callbacks.
 *
 */
MMRESULT WINAPI
MidiInSetEventHandle(
    HANDLE hMidiIn,             /* @parm The handle of the input device which desires notification */
    DWORD dwEvent)              /* @parm The VxD handle of the event to set when new data arrives */
{
    NPOPENHANDLEINSTANCE pohi;
    
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    pohi->dwVxDEventHandle = dwEvent;

    return MMSYSERR_NOERROR;
}

/* @func Read MIDI input data into a buffer
 *
 * @rdesc Returns one of the following
 *
 * @comm
 *
 * This function is thunked to the 32-bit DLL
 *
 * Take as much data from the given event list as will fit and put it into the buffer.
 */
MMRESULT WINAPI
MidiInRead(
    HANDLE hMidiIn,         /* @parm The handle of the input device to read */
    LPBYTE lpBuffer,        /* @parm A pointer to memory to pack, in DMEVENT format */
    LPDWORD pcbData,        /* @parm On input, the max size of <p lpBuffer> in bytes.
                                     On return, will contain the number of bytes of data packed into the buffer */
    LPDWORD pmsTime)        /* @parm On return, will contain the starting time of the buffer */ 
{
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLE poh;
    WORD wCSID;
    LPEVENT pEvent;
    LPEVENT pEventRemoved;
    LPBYTE pbEventData;
    DWORD cbLength;
    DWORD cbPaddedLength;
    DWORD cbLeft;
    LPBYTE lpNextEvent;
    LPDMEVENT pdm;
    DWORD msFirst;
    MMRESULT mmr;
    LPMIDIHDR lpmh;
            
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    poh = pohi->pHandle;

    lpNextEvent = lpBuffer;
    cbLeft = *pcbData;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);
    msFirst = 0;

    while (NULL != (pEvent = QueuePeek(&poh->qDone)))
    {
        lpmh = NULL;

        if (cbLeft < sizeof(DMEVENT))
        {
            break;
        }

        if (pEvent->wFlags & EVENT_F_MIDIHDR)
        {
            /* This event is a SysEx message starting with a MIDIHDR, which contains
             * the recorded length of the message.
             */
            lpmh = (LPMIDIHDR)(&pEvent->abEvent[0]);

            cbLength = lpmh->dwBytesRecorded - lpmh->dwOffset;
            pbEventData = lpmh->lpData + lpmh->dwOffset;
            cbPaddedLength = DMEVENT_SIZE(cbLength);

            /* For SysEx, split out as much as will fit if the whole message can't.
             */
            if (cbPaddedLength > cbLeft)
            {
                cbLength = DMEVENT_DATASIZE(cbLeft);
                cbPaddedLength = DMEVENT_SIZE(cbLength);        
            }
        }
        else
        {
            /* The data for this event is directly contained in the event.
             */
            cbLength = pEvent->cbEvent;
            pbEventData = &pEvent->abEvent[0];
            cbPaddedLength = DMEVENT_SIZE(cbLength);

            if (cbPaddedLength > cbLeft)
            {
                break;
            }
        }

        assert(cbPaddedLength <= cbLeft);

        pdm = (LPDMEVENT)lpNextEvent;

        pdm->cbEvent = cbLength;
        pdm->dwChannelGroup = 1;
        pdm->dwFlags = 0;

        if (msFirst)
        {
            QuadwordMul( pEvent->msTime - msFirst,
                         REFTIME_TO_MS,
                         &pdm->rtDelta);
        }
        else
        {
            *pmsTime = pEvent->msTime;
            msFirst = pEvent->msTime;

            pdm->rtDelta.dwLow  = 0;
            pdm->rtDelta.dwHigh = 0;
        }
        
        hmemcpy(pdm->abEvent, pbEventData, cbLength);

        lpNextEvent += cbPaddedLength;
        cbLeft -= cbPaddedLength;

        if (lpmh)
        {
            lpmh->dwOffset += cbLength;
            assert(lpmh->dwOffset <= lpmh->dwBytesRecorded);

            if (lpmh->dwOffset == lpmh->dwBytesRecorded)
            {
                pEventRemoved = QueueRemoveFromFront(&poh->qDone);
                assert(pEventRemoved == pEvent);

                InterlockedIncrement(&poh->wPostedSysExBuffers);

                lpmh->dwOffset = 0;
                mmr = midiInAddBuffer(poh->hmi, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
                if (mmr)
                {
                    InterlockedDecrement(&poh->wPostedSysExBuffers);
                    DPF(0, "midiInAddBuffer failed with mmr=%d", mmr);
                    mmr = midiInUnprepareHeader(poh->hmi, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
                    if (mmr)
                    {
                        DPF(0, "...midiInUnprepareHeader failed too %d, memory leak!", mmr);
                    }
                    else
                    {
                        FreeEvent(pEvent);
                    }
                }
            }
        }
        else
        {
            pEventRemoved = QueueRemoveFromFront(&poh->qDone);
            assert(pEventRemoved == pEvent);

            QueueAppend(&poh->qFree, pEvent);
        }
    }

    *pcbData = lpNextEvent - lpBuffer;

    DPF(1, "MidiInRead: Returning %ld bytes", (DWORD)*pcbData);

    LeaveCriticalSection(&poh->wCritSect);
    return MMSYSERR_NOERROR;
}

/* @func Enable thruing to a MIDI output port
 *
 * @comm For the given channel group and channel, enable (or disable, if the
 * output handle is NULL) thruing to the given output handle, channel group, and
 * channel.
 */
MMRESULT WINAPI
MidiInThru(
    HANDLE hMidiIn,             /* @parm The handle of the input device to thru */
    DWORD dwFrom,               /* @parm The channel of the input stream to thru */
    DWORD dwTo,                 /* @parm Desination channel */
    HANDLE hMidiOut)            /* The output handle to receive the thru'ed data. */
{
    NPOPENHANDLEINSTANCE pohiInput;
    NPOPENHANDLEINSTANCE pohiOutput;
    
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohiInput) ||
        ((hMidiOut != NULL) && !IsValidHandle(hMidiOut, VA_F_OUTPUT, &pohiOutput)))
    {
        return MMSYSERR_INVALHANDLE;
    }    

    /* Note that since only 1 channel group is supported on legacy drivers, 
     * we don't need any channel group information.
     */
    if (dwFrom > 15 || dwTo > 15) 
    {
        return MMSYSERR_INVALPARAM;
    }

    DPF(1, "Thru: Sending <%04X,%u> to <%04X,%u>", 
        (WORD)hMidiIn, (UINT)dwFrom, (WORD)hMidiOut, (UINT)dwTo);
        
    pohiInput->pThru[(WORD)dwFrom].wChannel = (WORD)dwTo;
    pohiInput->pThru[(WORD)dwFrom].pohi = hMidiOut ? pohiOutput : NULL;    

    return MMSYSERR_NOERROR;
}

/* @func MIDI in data callback
 *
 * @comm
 *
 * This is a standard MIDI input callback from MMSYSYTEM. It calls the correct record routine
 * and notifies the client that data has arrived.
 *
 * For a description of event notification of clients, see <f MidiInSetEventHandle>.
 */
VOID CALLBACK _loadds
midiInProc(
    HMIDIIN hMidiIn,            /* @parm The MMSYSTEM handle of the device which received data */
    UINT wMsg,                  /* @parm The type of callback */
    DWORD dwInstance,           /* @parm Instance data; in our case, a pointer to an <c OPENHANDLE> matching <p hMidiIn> */
    DWORD dwParam1,             /* @parm Message-specific parameters */
    DWORD dwParam2)             /* @parm Message-specific parameters */
{
    NPOPENHANDLE poh = (NPOPENHANDLE)(WORD)dwInstance;
    BOOL bIsNewData = FALSE;
    
    WORD wCSID;


    /* If we can get the critical section we can do all sorts of fun stuff like
     * transfer the lists over.
     */
    wCSID = EnterCriticalSection(&poh->wCritSect, CS_NONBLOCKING);
    if (wCSID)
    {
        /* We now have exclusive access to all the queues.
         *
         * Move any new free events into our internal free list.
         */
        QueueCat(&poh->qFreeCB, &poh->qFree);
    }

    switch(wMsg)
    {
        case MIM_DATA:
            DPF(1, "MIM_DATA %08lX %08lX", dwParam1, dwParam2);
            bIsNewData = RecordShortEvent(poh, dwParam1, dwParam2);
            break;

        case MIM_LONGDATA:
            DPF(1, "MIM_LONGDATA %08lX %08lX", dwParam1, dwParam2);
            bIsNewData = RecordSysExEvent(poh, (LPMIDIHDR)dwParam1, dwParam2);
            break;

        default:
            break;
    }

    if (wCSID)
    {
        /* It's safe to move events over to the shared list.
         */
        QueueCat(&poh->qDone, &poh->qDoneCB);
        LeaveCriticalSection(&poh->wCritSect);
    }

    /* Let clients know there is new data
     */
    if (bIsNewData && (!(poh->wFlags & OH_F_CLOSING)))
    {
        NotifyClientList(poh);
    }
}

/* @func Record a short message (channel messsage or system message).
 *
 * @comm
 *
 * Queue the incoming data as quickly as possible.
 *
 * For a description of the queues used for incoming data, see the <c OPENHANDLE> struct.
 *
 * @rdesc
 * Returns TRUE if the data was successfully recorded; FALSE otherwise.
 */
STATIC BOOL NEAR PASCAL 
RecordShortEvent(
    NPOPENHANDLE poh,           /* @parm The handle to record this data to */
    DWORD dwMessage,            /* @parm The short message to record */
    DWORD dwTime)               /* @parm The time stamp of the message */
{
    LPEVENT pEvent;
    LPBYTE pb;
    BYTE b;

    pEvent = QueueRemoveFromFront(&poh->qFreeCB);
    if (pEvent == NULL)
    {
        DPF(0, "midiInProc: Missed a short event!!!");
        return FALSE;
    }
        
    pEvent->msTime = poh->msStartTime + dwTime;
    pEvent->wFlags = 0;

    /* Now we have to parse and rebuild the channel message.
     *
     * NOTE: Endian specific code ahead
     */
    pb = (LPBYTE)&dwMessage;

    assert(!IS_SYSEX(*pb));         /* This should *always* be in MIM_LONGDATA */
    assert(IS_STATUS_BYTE(*pb));    /* API guarantees no running status */

    /* Copying over all the bytes is harmless (we have a DWORD in both
     * source and dest) and is faster than checking to see if we have to.
     */
    b = pEvent->abEvent[0] = *pb++;
    pEvent->abEvent[1] = *pb++;
    pEvent->abEvent[2] = *pb++;

    if (IS_CHANNEL_MSG(b))
    {
        /* 8x, 9x, Ax, Bx, Cx, Dx, Ex */
        /* 0x..7x invalid, that would need running status */
        /* Fx handled below */
        
        pEvent->cbEvent = cbChanMsg[(b >> 4) & 0x0F];

        /* This is also our criteria for thruing
         */
        ThruClientList(poh, dwMessage);
    }
    else
    {
        /* F1..FF */
        /* F0 is sysex, should never see it here */
        pEvent->cbEvent = cbSysCommData[b & 0x0F];
    }

    /* Now we have something to save
     */
    QueueAppend(&poh->qDoneCB, pEvent);

    return TRUE;
}

/* @func Record a SysEx message.
 *
 * @comm
 *
 * Queue the incoming data as quickly as possible.
 *
 * For a description of the queues used for incoming data, see the <c OPENHANDLE> struct.
 *
 * @rdesc
 * Returns TRUE if the data was successfully recorded; FALSE otherwise.
 */
STATIC BOOL NEAR PASCAL 
RecordSysExEvent(
    NPOPENHANDLE poh,           /* @parm The handle to record this data to */
    LPMIDIHDR lpmh,             /* @parm The SysEx message to record */
    DWORD dwTime)               /* @parm The time stamp of the message */
{
    LPEVENT pEvent;
    
    /* Get back the event header for this MIDIHDR. While buffers are in MMSYSTEM, they are not 
     * in any queue.
     */
    InterlockedDecrement(&poh->wPostedSysExBuffers);

    /* dwOffset in the MIDIHDR is used to indicate the start of data to send
     * up to Win32. It is incremented by MidiInRead until the buffer has been
     * emptied, at which time it will be put back into the pool.
     */
    lpmh->dwOffset = 0;

    pEvent = (LPEVENT)(lpmh->dwUser);
    pEvent->msTime = poh->msStartTime + dwTime;
    QueueAppend(&poh->qDoneCB, pEvent);
    
    return TRUE;
}

/* @func Notify all clients of a device that data has arrived.
 *
 * @comm
 *
 * Walks the list of clients for the device and sets the notification event for each one.
 *
 * This function is now overkill since we no longer support multiple input clients per device.
 */
STATIC VOID NEAR PASCAL
NotifyClientList(
    LPOPENHANDLE poh)           /* @parm The handle of the device that has received data */
{
    NPLINKNODE plink;
    NPOPENHANDLEINSTANCE pohi;

    for (plink = poh->pInstanceList; plink; plink = plink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)(((PBYTE)plink) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

        if (!pohi->dwVxDEventHandle)
        {
            /* No notification event registered for this handle yet.
             */
            continue;
        }

        SetWin32Event(pohi->dwVxDEventHandle);
    }
}

/* @func Thru this message based on the settings of all clients of a device.
 *
 * @comm
 *
 * Walks the list of clients for the device and looks at the thru settings of each one.
 *
 * This function is now overkill since we no longer support multiple input clients per device.
 */
STATIC VOID NEAR PASCAL 
ThruClientList(
    LPOPENHANDLE poh, 
    DWORD dwMessage)
{
    NPLINKNODE plink;
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLEINSTANCE pohiDest;
    int iChannel;

    iChannel = (int)(dwMessage & 0x0000000Fl);
    dwMessage &= 0xFFFFFFF0l;

    for (plink = poh->pInstanceList; plink; plink = plink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)(((PBYTE)plink) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

        pohiDest = pohi->pThru[iChannel].pohi;
        if (pohiDest == NULL || !pohiDest->fActive)
        {
            continue;
        }

        MidiOutThru(pohiDest,
                    dwMessage & 0xFFFFFFF0l | pohi->pThru[iChannel].wChannel);
    }
}

/* @func Refill the free lists
 *
 * @comm
 *
 * This function is called periodically from user mode to ensure that there are enough free
 * events available for the input callback. 
 */
VOID PASCAL
MidiInRefillFreeLists(VOID)
{
    NPLINKNODE plink;
    NPOPENHANDLE poh;
    
    for (plink = gOpenHandleList;
         (poh = (NPOPENHANDLE)plink) != NULL;
         plink = plink->pNext)
    {
        /* Only refill MIDI in devices which are not in the process of closing
         */
        if ((poh->wFlags & (OH_F_MIDIIN | OH_F_CLOSING)) != OH_F_MIDIIN)
        {
            continue;
        }

        RefillFreeEventList(poh);
    }
}
                 
/* @func Terminate thruing to this output handle
 *
 * @comm
 *
 * This function is called before the given output handle is closed.
 */
VOID PASCAL 
MidiInUnthruToInstance(
    NPOPENHANDLEINSTANCE pohiClosing)   /* @parm NPOPENHANDLE | pohClosing | 
                                           The handle which is closing. */
{
    NPLINKNODE plink;
    NPOPENHANDLE poh;
    NPLINKNODE plinkInstance;
    NPOPENHANDLEINSTANCE pohiInstance;
    int iChannel;

    for (plink = gOpenHandleList; (poh = (NPOPENHANDLE)plink) != NULL; plink = plink->pNext)
    {
        DPF(2, "Unthru: poh <%04X>", (WORD)poh);

        if (!(poh->wFlags & OH_F_MIDIIN)) 
        {
            DPF(2, "...not input");
            continue;
        }

        for (plinkInstance = poh->pInstanceList; plinkInstance; plinkInstance = plinkInstance->pNext)
        {
            pohiInstance = (NPOPENHANDLEINSTANCE)(((PBYTE)plinkInstance) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

            DPF(2, "pohiInstance <%04X>", (WORD)pohiInstance);
            
            for (iChannel = 0; iChannel < MIDI_CHANNELS; iChannel++)
            {
                DPF(2, "Channel 0 @ <%04X>", (WORD)&pohiInstance->pThru[iChannel]);
                if (pohiInstance->pThru[iChannel].pohi == pohiClosing)
                {
                    DPF(1, "Thru: Closing output handle %04X which is in use!", (WORD)pohiClosing);
                    pohiInstance->pThru[iChannel].pohi = NULL;
                }
            }
        }
    }        
}

/* @func Allocate enough free events to refill the pool to CAP_HIGHWATERMARK
 *
 * @comm
 *
 * BUGBUG call this on a window timer callback
 *
 */
STATIC VOID NEAR PASCAL
RefillFreeEventList(
    NPOPENHANDLE poh)           /* @parm The device to refill the free list of */
{
    int idx;
    LPEVENT pEvent;
    UINT cFree;
    WORD wCSID;
    QUADWORD rt = {0, 0};
    int cNewBuffers;
    LPMIDIHDR lpmh;
    MMRESULT mmr;
    WORD wIntStat;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);
    
    /* NOTE: Technically not allowed to access qFreeCB here, but this is an approximation
     */
    cFree = poh->qFree.cEle + poh->qFreeCB.cEle;
    if (cFree < CAP_HIGHWATERMARK)
    {
        DPF(1, "RefillFreeEventList poh %.4x free %u highwater %u",
            (WORD)poh,
            (UINT)cFree,
            (UINT)CAP_HIGHWATERMARK);
        
        for (idx = CAP_HIGHWATERMARK - cFree; idx; --idx)
        {
            pEvent = AllocEvent(0, rt, sizeof(DWORD));
            if (NULL == pEvent)
            {
                DPF(0, "AllocEvent returned NULL in RefillFreeEventList");
                break;
            }

            QueueAppend(&poh->qFree, pEvent);
        }
    }

    LeaveCriticalSection(&poh->wCritSect);

    if (poh->wPostedSysExBuffers < SYSEX_BUFFERS)
    {
        for (idx = SYSEX_BUFFERS - cFree; idx; --idx)
        {
            pEvent = AllocEvent(0, rt, sizeof(MIDIHDR) + SYSEX_SIZE);
            if (NULL == pEvent)
            {
                break;
            }

            pEvent->wFlags |= EVENT_F_MIDIHDR;

            lpmh = (LPMIDIHDR)(&pEvent->abEvent[0]);
            lpmh->lpData = (LPSTR)(lpmh + 1);
            lpmh->dwBufferLength = SYSEX_SIZE;
            lpmh->dwUser = (DWORD)pEvent;

            mmr = midiInPrepareHeader(poh->hmi, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {   
                DPF(0, "midiInPrepareHeader: %u\n", mmr);
                FreeEvent(pEvent);
                break;
            }

            InterlockedIncrement(&poh->wPostedSysExBuffers);
            mmr = midiInAddBuffer(poh->hmi, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {
                InterlockedDecrement(&poh->wPostedSysExBuffers);

                DPF(0, "midiInAddBuffer: %u\n", mmr);
                midiInUnprepareHeader(poh->hmi, lpmh, sizeof(MIDIHDR));
                FreeEvent(pEvent);
                break;
            }
        }
    }
}

/* @func Return all memory from all queues to the free event list.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiInFlushQueues(
    NPOPENHANDLE poh)
{
    WORD wCSID;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    FreeAllQueueEvents(&poh->qDone);
    FreeAllQueueEvents(&poh->qDoneCB);
    FreeAllQueueEvents(&poh->qFree);
    FreeAllQueueEvents(&poh->qFreeCB);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func Free all events in the given event queue.
 *
 * @comm
 *
 * Assumes that the queue's critical section has already been taken by the caller.
 *
 */
VOID PASCAL
FreeAllQueueEvents(
    NPEVENTQUEUE peq)
{
    LPEVENT lpCurr;
    LPEVENT lpNext;
    
    lpCurr = peq->pHead;
    while (lpCurr)
    {
        lpNext = lpCurr->lpNext;
        FreeEvent(lpCurr);
        lpCurr = lpNext;
    }

    peq->pHead = peq->pTail = NULL;
    peq->cEle = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\mmdevldr.asm ===
; Copyright (c) 1998 Microsoft Corporation

;;MMDEVLDR.ASM

        page    ,132
;-----------------------------Module-Header-----------------------------;
;
; @Doc DMusic16
;
; @Module MMDevLdr.asm - Interface routines for MMDevLdr |
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        include windows.inc
        include mmdevldr.inc
        include mmsystem.inc
        .list

externFP        AllocCStoDSAlias        ;(UINT sel);
externFP        FreeSelector            ;(UINT sel);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   equates
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OFFSEL struc
        off     dw  ?
        sel     dw  ?
OFFSEL ends

GetDeviceAPI            EQU     1684h                   ; int 2Fh query

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segmentation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;createSeg %SEGNAME, CodeSeg, word, public, CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Remember, we are still 16bit.

    .model medium
        .386

;sBegin CodeSeg
         .code

;        assumes cs, _text

        MMDEVLDR_Entry  dd      ?       ; the api entry point for mmdevldr


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; @func BOOL CDECL | SetWin32Event | Set a Win32 event from any context
;
; @comm
; 
; Given the VxD handle to an event, set the event. This function calls the MMDevLdr
; VxD API entry, which in turn calls the VWin32 function to perform the set.
;
; @rdesc
; Returns TRUE on success, or FALSE if MMDevLdr could not be found.
;
; @parm DWORD | dwRing0Event | The VxD handle of the event as returned
; from the <f OpenVxDHandle> kernel API.
;
;

cProc _SetWin32Event <FAR, CDECL, PUBLIC> <>
        ParmD  dwRing0Evt
cBegin nogen
        mov    dx, MMDEVLDR_API_SetEvent
        jmp    short MMDEVLDR_Call
cEnd nogen

;
;
;
cProc MMDEVLDR_Call <FAR, CDECL> <>
cBegin nogen
        mov     ecx, [MMDEVLDR_Entry]
        jecxz   short mmdevldr_load
        jmp     [MMDEVLDR_Entry]
mmdevldr_load:
        push    dx                      ; save MMDEVLDR command ID
        push    di
        push    si
        cCall   AllocCStoDSAlias, <cs>
        mov     si, ax
        xor     di, di                  ; zero ES:DI before call
        mov     es, di
        mov     ax, GetDeviceAPI        ; get device API entry point
        mov     bx, MMDEVLDR_Device_ID  ; virtual device ID
        int     2Fh                     ; call WIN/386 INT 2F API
        mov     ax, es
        mov     es, si
;        assumes es, CodeSeg
        mov     es:MMDEVLDR_Entry.off, di
        mov     es:MMDEVLDR_Entry.sel, ax
        assumes es, nothing
        push    ax
        cCall   FreeSelector, <si>
        pop     ax
        or      ax, di
        pop     si
        pop     di
        pop     dx
        jz      short mmdevldr_fail
        jmp     [MMDEVLDR_Entry]
mmdevldr_fail:
        mov     ax, MMSYSERR_NODRIVER;
        retf
cEnd nogen


;sEnd CodeSeg

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\preclude.h ===
// Copyright (c) 1998 Microsoft Corporation

// MMSYSTEM precludes
//
 
#define     MMNOSOUND
#define     MMNOWAVE
#define     MMNOSEQ
#define     MMNOTIMER
#define     MMNOJOY
////#define     MMNOMCI
#define     MMNOTASK

// MMDDK precludes
//
#define     MMNOWAVEDEV
#define     MMNOAUXDEV
#define     MMNOTIMERDEV
#define     MMNOJOYDEV
/////#define     MMNOMCIDEV
#define     MMNOTASKDEV

// WINDOWS precludes
//

#define     NOGDICAPMASKS        //- CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#define     NOVIRTUALKEYCODES    //- VK_*
#define     NOICONS              //- IDI_*
#define     NOKEYSTATES          //- MK_*
#define     NOSYSCOMMANDS        //- SC_*
#define     NORASTEROPS          //- Binary and Tertiary raster ops
#define     OEMRESOURCE          //- OEM Resource values
#define     NOCLIPBOARD          //- Clipboard routines
#define     NOMETAFILE           //- typedef METAFILEPICT
//#define     NOOPENFILE           //- OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define     NOSOUND              //- Sound driver routines
#define     NOWH                 //- SetWindowsHook and WH_*
#define     NOCOMM               //- COMM driver routines
#define     NOKANJI              //- Kanji support stuff.
//#define     NOHELP               //- Help engine interface.
#define     NOPROFILER           //- Profiler interface.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\mmdevldr.inc ===
;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   (C) Copyright (c) 1993-1998 Microsoft Corporation
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

MMDEVLDR_API_MMSystem_Up        equ 0			;Internal
MMDEVLDR_API_Continue		equ 1			;Internal
MMDEVLDR_API_QueryVxD           equ 2                   ;Internal
MMDEVLDR_API_QueueCallback32    equ 3                   ;Internal
MMDEVLDR_API_SetEvent           equ 4                   ;Internal
MMDEVLDR_API_PageAllocate       equ 5                   ;Internal
MMDEVLDR_API_PageFree           equ 6                   ;Internal
MMDEVLDR_APIS                   equ 7                   ;Internal

ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	_MMDEVLDR_SetDevicePresence
        MMDEVLDR_Service        _MMDEVLDR_SetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_GetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_RemoveEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_AddEnvironmentString
End_Service_Table MMDEVLDR	

MMDEVLDR_IOCTL_GETVERSION       equ     0		;Internal
MMDEVLDR_IOCTL_LINPAGELOCK      equ     1		;Internal
MMDEVLDR_IOCTL_LINPAGEUNLOCK    equ     2		;Internal
MMDEVLDR_IOCTL_RING0THREADHANDLE equ    3		;Internal
MMDEVLDR_IOCTL_QUEUEAPC         equ     4		;Internal
MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR equ   5		;Internal
MMDEVLDR_IOCTL_CLOSEVXDHANDLE   equ     6		;Internal
MMDEVLDR_IOCTL_PAGEALLOCATE     equ     7		;Internal
MMDEVLDR_IOCTL_PAGEFREE         equ     8		;Internal
MMDEVLDR_IOCTL_GETDEVICESTATUS  equ     9		;Internal
							;Internal
MM_DEVSTATUS_ERROR          equ 0			;Internal
MM_DEVSTATUS_STARTED        equ 1			;Internal
MM_DEVSTATUS_UNKNOWNPROB    equ 2			;Internal
MM_DEVSTATUS_DISABLED       equ 3			;Internal
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\res.h ===
/**********************************************************************

    Copyright (c) 1992-1998 Microsoft Corporation

    res.h

    DESCRIPTION:

*********************************************************************/

#ifndef _RES_
#define _RES_

#define IDS_DMUSIC16    1000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\mmsystem.inc ===
; Copyright (c) 1998-1999 Microsoft Corporation

; general constants
MAXPNAMELEN	EQU	32     ; max product name length (including NULL)
MAXERRORLENGTH	EQU	256    ; max error text length (including NULL)
MAX_JOYSTICKOEMVXDNAME	EQU	260 ; max oem vxd name length (including NULL)

MMTIME	STRUC
mmt_wType	DW	?
mmt_TimeUnion	DD	?
MMTIME	ENDS

SMPTE	STRUC
smpte_hour	DB	?
smpte_min	DB	?
smpte_sec	DB	?
smpte_frame	DB	?
smpte_fps	DB	?
smpte_reserved	DB	?
SMPTE	ENDS
; types for wType field in MMTIME struct
TIME_MS	EQU	0001H  ; time in milliseconds
TIME_SAMPLES	EQU	0002H  ; number of wave samples
TIME_BYTES	EQU	0004H  ; current byte offset
TIME_SMPTE	EQU	0008H  ; SMPTE time
TIME_MIDI	EQU	0010H  ; MIDI time
TIME_TICKS	EQU	0020H  ; Ticks within MIDI stream
MM_JOY1MOVE	EQU	3A0H           ; joystick
MM_JOY2MOVE	EQU	3A1H
MM_JOY1ZMOVE	EQU	3A2H
MM_JOY2ZMOVE	EQU	3A3H
MM_JOY1BUTTONDOWN	EQU	3B5H
MM_JOY2BUTTONDOWN	EQU	3B6H
MM_JOY1BUTTONUP	EQU	3B7H
MM_JOY2BUTTONUP	EQU	3B8H
MM_MCINOTIFY	EQU	3B9H           ; MCI
						;internal; 0x3BA is open
MM_WOM_OPEN	EQU	3BBH           ; waveform output
MM_WOM_CLOSE	EQU	3BCH
MM_WOM_DONE	EQU	3BDH
MM_WIM_OPEN	EQU	3BEH           ; waveform input
MM_WIM_CLOSE	EQU	3BFH
MM_WIM_DATA	EQU	3C0H
MM_MIM_OPEN	EQU	3C1H           ; MIDI input
MM_MIM_CLOSE	EQU	3C2H
MM_MIM_DATA	EQU	3C3H
MM_MIM_LONGDATA	EQU	3C4H
MM_MIM_ERROR	EQU	3C5H
MM_MIM_LONGERROR	EQU	3C6H
MM_MOM_OPEN	EQU	3C7H           ; MIDI output
MM_MOM_CLOSE	EQU	3C8H
MM_MOM_DONE	EQU	3C9H
MMSYSERR_BASE	EQU	0
WAVERR_BASE	EQU	32
MIDIERR_BASE	EQU	64
TIMERR_BASE	EQU	96
JOYERR_BASE	EQU	160
MCIERR_BASE	EQU	256
MIXERR_BASE	EQU	1024
MCI_STRING_OFFSET	EQU	512
MCI_VD_OFFSET	EQU	1024
MCI_CD_OFFSET	EQU	1088
MCI_WAVE_OFFSET	EQU	1152
MCI_SEQ_OFFSET	EQU	1216
;***************************************************************************
;	General error return values
;*************************************************************************
; general error return values
MMSYSERR_NOERROR	EQU	0                    ; no error
MMSYSERR_ERROR	EQU	(MMSYSERR_BASE+1)  ; unspecified error
MMSYSERR_BADDEVICEID	EQU	(MMSYSERR_BASE+2)  ; device ID out of range
MMSYSERR_NOTENABLED	EQU	(MMSYSERR_BASE+3)  ; driver failed enable
MMSYSERR_ALLOCATED	EQU	(MMSYSERR_BASE+4)  ; device already allocated
MMSYSERR_INVALHANDLE	EQU	(MMSYSERR_BASE+5)  ; device handle is invalid
MMSYSERR_NODRIVER	EQU	(MMSYSERR_BASE+6)  ; no device driver present
MMSYSERR_NOMEM	EQU	(MMSYSERR_BASE+7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED	EQU	(MMSYSERR_BASE+8)  ; function isn't supported
MMSYSERR_BADERRNUM	EQU	(MMSYSERR_BASE+9)  ; error value out of range
MMSYSERR_INVALFLAG	EQU	(MMSYSERR_BASE+10) ; invalid flag passed
MMSYSERR_INVALPARAM	EQU	(MMSYSERR_BASE+11) ; invalid parameter passed
MMSYSERR_HANDLEBUSY	EQU	(MMSYSERR_BASE+12) ; handle being used
						   ; simultaneously on another
						   ; thread (eg callback)
MMSYSERR_INVALIDALIAS	EQU	(MMSYSERR_BASE+13) ; specified alias not found
MMSYSERR_BADDB	EQU	(MMSYSERR_BASE+14) ; bad registry database
MMSYSERR_KEYNOTFOUND	EQU	(MMSYSERR_BASE+15) ; registry key not found
MMSYSERR_READERROR	EQU	(MMSYSERR_BASE+16) ; registry read error
MMSYSERR_WRITEERROR	EQU	(MMSYSERR_BASE+17) ; registry write error
MMSYSERR_DELETEERROR	EQU	(MMSYSERR_BASE+18) ; registry delete error
MMSYSERR_VALNOTFOUND	EQU	(MMSYSERR_BASE+19) ; registry value not found
MMSYSERR_NODRIVERCB	EQU	(MMSYSERR_BASE+20) ; driver does not call DriverCallback
MMSYSERR_LASTERROR	EQU	(MMSYSERR_BASE+20) ; last error in range
ifndef MMNODRV                                                 ;both
ifndef DRV_RESERVED
DRV_RESERVED	EQU	0800H
DRV_USER	EQU	4000H
endif
DRV_MCI_FIRST	EQU	DRV_RESERVED
DRV_MCI_LAST	EQU	(DRV_RESERVED+0FFFH)
endif                                      ;both; ifndef MMNODRV
;***************************************************************************
;	  Driver callback support
;*************************************************************************
; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK	EQU	00070000H    ; callback type mask
CALLBACK_NULL	EQU	00000000H    ; no callback
CALLBACK_WINDOW	EQU	00010000H    ; dwCallback is a HWND
CALLBACK_TASK	EQU	00020000H    ; dwCallback is a HTASK
CALLBACK_FUNCTION	EQU	00030000H    ; dwCallback is a FARPROC
CALLBACK_THUNK	EQU	00040000H    	;internal; dwCallback is a Ring0 Thread Handle
ifdef _WIN32
CALLBACK_THREAD	EQU	(CALLBACK_TASK); thread ID replaces 16 bit task
CALLBACK_EVENT	EQU	00050000H    ; dwCallback is an EVENT Handle
endif
CALLBACK_EVENT16	EQU	00060000H    	;internal; dwCallback is an EVENT under Win16
SND_SYNC	EQU	0000H  ; play synchronously (default)
SND_ASYNC	EQU	0001H  ; play asynchronously
SND_NODEFAULT	EQU	0002H  ; silence (!default) if sound not found
SND_MEMORY	EQU	0004H  ; pszSound points to a memory file
SND_LOOP	EQU	0008H  ; loop the sound until next sndPlaySound
SND_NOSTOP	EQU	0010H  ; don't stop any currently playing sound
ifndef MMNOWAVE                                                 ;both
;***************************************************************************
;	Waveform audio support
;*************************************************************************
; waveform audio error return values
WAVERR_BADFORMAT	EQU	(WAVERR_BASE+0)    ; unsupported wave format
WAVERR_STILLPLAYING	EQU	(WAVERR_BASE+1)    ; still something playing
WAVERR_UNPREPARED	EQU	(WAVERR_BASE+2)    ; header not prepared
WAVERR_SYNC	EQU	(WAVERR_BASE+3)    ; device is synchronous
WAVERR_LASTERROR	EQU	(WAVERR_BASE+3)    ; last error in range
; wave callback messages
WOM_OPEN	EQU	MM_WOM_OPEN
WOM_CLOSE	EQU	MM_WOM_CLOSE
WOM_DONE	EQU	MM_WOM_DONE
WIM_OPEN	EQU	MM_WIM_OPEN
WIM_CLOSE	EQU	MM_WIM_CLOSE
WIM_DATA	EQU	MM_WIM_DATA
; device ID for wave device mapper
WAVE_MAPPER	EQU	(-1)
; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY	EQU	0001H
WAVE_ALLOWSYNC	EQU	0002H
WAVE_VALID	EQU	800FH			;internal

WAVEHDR	STRUC
lpWaveData	DD	?
dwWaveBufferLength	DD	?
dwWaveBytesRecorded	DD	?
dwWaveUser	DD	?
dwWaveFlags	DD	?
dwWaveLoops	DD	?
lpWaveNext	DD	?
Wavereserved	DD	?
WAVEHDR	ENDS
; flags for dwFlags field of WAVEHDR
WHDR_DONE	EQU	00000001H  ; done bit
WHDR_PREPARED	EQU	00000002H  ; set if this header has been prepared
WHDR_BEGINLOOP	EQU	00000004H  ; loop start block
WHDR_ENDLOOP	EQU	00000008H  ; loop end block
WHDR_INQUEUE	EQU	00000010H  ; reserved for driver
WHDR_MAPPED	EQU	00001000H  	;internal; thunked header
WHDR_VALID	EQU	0000101FH  		;internal; valid flags

WAVEOUTCAPS	STRUC
woc_wMid	DW	?
woc_wPid	DW	?
woc_vDriverVersion	DW	?
woc_szPname	DB	MAXPNAMELEN DUP (?)
woc_dwFormats	DD	?
woc_wChannels	DW	?
woc_dwSupport	DD	?
WAVEOUTCAPS	ENDS
; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH	EQU	0001H   ; supports pitch control
WAVECAPS_PLAYBACKRATE	EQU	0002H   ; supports playback rate control
WAVECAPS_VOLUME	EQU	0004H   ; supports volume control
WAVECAPS_LRVOLUME	EQU	0008H   ; separate left-right volume control
WAVECAPS_SYNC	EQU	0010H
WAVECAPS_SAMPLEACCURATE	EQU	0020H
WAVECAPS_DIRECTSOUND	EQU	0040H

WAVEINCAPS	STRUC
wic_wMid	DW	?
wic_wPid	DW	?
wic_vDriverVersion	DW	?
wic_szPname	DB	MAXPNAMELEN DUP (?)
wic_dwFormats	DD	?
wic_wChannels	DW	?
WAVEINCAPS	ENDS
; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT	EQU	00000000H       ; invalid format
WAVE_FORMAT_1M08	EQU	00000001H       ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08	EQU	00000002H       ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16	EQU	00000004H       ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16	EQU	00000008H       ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08	EQU	00000010H       ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08	EQU	00000020H       ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16	EQU	00000040H       ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16	EQU	00000080H       ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08	EQU	00000100H       ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08	EQU	00000200H       ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16	EQU	00000400H       ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16	EQU	00000800H       ; 44.1   kHz, Stereo, 16-bit

WAVEFORMAT	STRUC
wfmt_wFormatTag	DW	?
wfmt_nChannels	DW	?
wfmt_nSamplesPerSec	DD	?
wfmt_nAvgBytesPerSec	DD	?
wfmt_nBlockAlign	DW	?
WAVEFORMAT	ENDS
; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM	EQU	1

PCMWAVEFORMAT	STRUC
pcm_wf	DB	SIZE WAVEFORMAT DUP (?)
pcm_wBitsPerSample	DW	?
PCMWAVEFORMAT	ENDS
endif                                      ;both; ifndef MMNOWAVE
ifndef MMNOMIDI                               ;both
;***************************************************************************
;	    MIDI audio support
;*************************************************************************
; MIDI error return values
MIDIERR_UNPREPARED	EQU	(MIDIERR_BASE+0)   ; header not prepared
MIDIERR_STILLPLAYING	EQU	(MIDIERR_BASE+1)   ; still something playing
MIDIERR_NOMAP	EQU	(MIDIERR_BASE+2)   ; no configured instruments
MIDIERR_NOTREADY	EQU	(MIDIERR_BASE+3)   ; hardware is still busy
MIDIERR_NODEVICE	EQU	(MIDIERR_BASE+4)   ; port no longer connected
MIDIERR_INVALIDSETUP	EQU	(MIDIERR_BASE+5)   ; invalid MIF
MIDIERR_BADOPENMODE	EQU	(MIDIERR_BASE+6)   ; operation unsupported w/ open mode
MIDIERR_DONT_CONTINUE	EQU	(MIDIERR_BASE+7)   ; thru device 'eating' a message
MIDIERR_LASTERROR	EQU	(MIDIERR_BASE+7)   ; last error in range
MIDIPATCHSIZE	EQU	128
; MIDI callback messages
MIM_OPEN	EQU	MM_MIM_OPEN
MIM_CLOSE	EQU	MM_MIM_CLOSE
MIM_DATA	EQU	MM_MIM_DATA
MIM_LONGDATA	EQU	MM_MIM_LONGDATA
MIM_ERROR	EQU	MM_MIM_ERROR
MIM_LONGERROR	EQU	MM_MIM_LONGERROR
MOM_OPEN	EQU	MM_MOM_OPEN
MOM_CLOSE	EQU	MM_MOM_CLOSE
MOM_DONE	EQU	MM_MOM_DONE
; device ID for MIDI mapper
MIDIMAPPER	EQU	(-1)
MIDI_MAPPER	EQU	(-1)
; flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches()
MIDI_CACHE_ALL	EQU	1
MIDI_CACHE_BESTFIT	EQU	2
MIDI_CACHE_QUERY	EQU	3
MIDI_UNCACHE	EQU	4
MIDI_CACHE_VALID	EQU	(MIDI_CACHE_ALL OR MIDI_CACHE_BESTFIT OR MIDI_CACHE_QUERY OR MIDI_UNCACHE)     ;internal

MIDIOUTCAPS	STRUC
moc_wMid	DW	?
moc_wPid	DW	?
moc_vDriverVersion	DW	?
moc_szPname	DB	MAXPNAMELEN DUP (?)
moc_wTechnology	DW	?
moc_wVoices	DW	?
moc_wNotes	DW	?
moc_wChannelMask	DW	?
moc_dwSupport	DD	?
MIDIOUTCAPS	ENDS
; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT	EQU	1  ; output port
MOD_SYNTH	EQU	2  ; generic internal synth
MOD_SQSYNTH	EQU	3  ; square wave internal synth
MOD_FMSYNTH	EQU	4  ; FM internal synth
MOD_MAPPER	EQU	5  ; MIDI mapper
; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME	EQU	0001H  ; supports volume control
MIDICAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
MIDICAPS_CACHE	EQU	0004H

MIDIINCAPS	STRUC
mic_wMid	DW	?
mic_wPid	DW	?
mic_vDriverVersion	DW	?
mic_szPname	DB	MAXPNAMELEN DUP (?)
MIDIINCAPS	ENDS

MIDIHDR	STRUC
lpMidiData	DD	?
dwMidiBufferLength	DD	?
dwMidiBytesRecorded	DD	?
dwMidiUser	DD	?
dwMidiFlags	DD	?
lpMidiNext	DD	?
Midireserved	DD	?
MididwOffset	DD	?
MididwReserved	DD	4 DUP (?)
MIDIHDR	ENDS

MIDIHDR31	STRUC
w31lpMidiData	DD	?
w31dwMidiBufferLength	DD	?
w31dwMidiBytesRecorded	DD	?
w31dwMidiUser	DD	?
w31dwMidiFlags	DD	?
w31lpMidiNext	DD	?
w31Midireserved	DD	?
MIDIHDR31	ENDS
; flags for dwFlags field of MIDIHDR structure
MHDR_DONE	EQU	00000001H       ; done bit
MHDR_PREPARED	EQU	00000002H       ; set if header prepared
MHDR_INQUEUE	EQU	00000004H       ; reserved for driver
MHDR_ISSTRM	EQU	00000008H       ; Buffer is stream buffer
MHDR_SENDING	EQU	00000020H       ;internal
MHDR_MAPPED	EQU	00001000H       	;internal; thunked header
MHDR_SHADOWHDR	EQU	00002000H        ;internal; MIDIHDR is 16-bit shadow
MHDR_VALID	EQU	0000302FH       	;internal; valid flags
	;internal */;#define MHDR_VALID      0xFFFF000F       /* valid flags
MHDR_SAVE	EQU	00003000H         ;internal; Save these flags
                                          ;internal; past driver calls
endif                                     ;both; ifndef MMNOMIDI
ifndef MMNOAUX                                                  ;both
;***************************************************************************
;	Auxiliary audio support
;*************************************************************************
; device ID for aux device mapper
AUX_MAPPER	EQU	(-1)

AUXCAPS	STRUC
acaps_wMid	DW	?
acaps_wPid	DW	?
acaps_vDriverVersion	DW	?
acaps_szPname	DB	MAXPNAMELEN DUP (?)
acaps_wTechnology	DW	?
acaps_dwSupport	DD	?
AUXCAPS	ENDS
; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO	EQU	1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN	EQU	2       ; audio from auxiliary input jacks
; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME	EQU	0001H  ; supports volume control
AUXCAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
endif                                       ;both; ifndef MMNOAUX
ifndef MMNOTIMER                                               ;both
ifndef _WIN32_VXD
;***************************************************************************
;	    Timer support
;*************************************************************************
; timer error return values
TIMERR_NOERROR	EQU	(0)                  ; no error
TIMERR_NOCANDO	EQU	(TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT	EQU	(TIMERR_BASE+33)     ; time struct size
; flags for fuEvent parameter of timeSetEvent() function
TIME_ONESHOT	EQU	0000H   ; program timer for single event
TIME_PERIODIC	EQU	0001H   ; program for continuous periodic event
ifdef _WIN32
TIME_CALLBACK_FUNCTION	EQU	0000H  ; callback is function
TIME_CALLBACK_EVENT_SET	EQU	0010H  ; callback is event - use SetEvent
TIME_CALLBACK_EVENT_PULSE	EQU	0020H  ; callback is event - use PulseEvent
TIME_CALLBACK_TYPEMASK	EQU	00F0H  ;internal
endif

TIMECAPS	STRUC
tc_wPeriodMin	DW	?
tc_wPeriodMax	DW	?
TIMECAPS	ENDS
endif  ; ifndef _WIN32_VXD
endif                                    ;both; ifndef MMNOTIMER
ifndef MMNOJOY                                                 ;both
;***************************************************************************
;	    Joystick support
;*************************************************************************
; joystick error return values
JOYERR_NOERROR	EQU	(0)                  ; no error
JOYERR_PARMS	EQU	(JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO	EQU	(JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED	EQU	(JOYERR_BASE+7)      ; joystick is unplugged
; constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages
JOY_BUTTON1	EQU	0001H
JOY_BUTTON2	EQU	0002H
JOY_BUTTON3	EQU	0004H
JOY_BUTTON4	EQU	0008H
JOY_BUTTON1CHG	EQU	0100H
JOY_BUTTON2CHG	EQU	0200H
JOY_BUTTON3CHG	EQU	0400H
JOY_BUTTON4CHG	EQU	0800H
; constants used with JOYINFOEX
JOY_BUTTON5	EQU	00000010H
JOY_BUTTON6	EQU	00000020H
JOY_BUTTON7	EQU	00000040H
JOY_BUTTON8	EQU	00000080H
JOY_BUTTON9	EQU	00000100H
JOY_BUTTON10	EQU	00000200H
JOY_BUTTON11	EQU	00000400H
JOY_BUTTON12	EQU	00000800H
JOY_BUTTON13	EQU	00001000H
JOY_BUTTON14	EQU	00002000H
JOY_BUTTON15	EQU	00004000H
JOY_BUTTON16	EQU	00008000H
JOY_BUTTON17	EQU	00010000H
JOY_BUTTON18	EQU	00020000H
JOY_BUTTON19	EQU	00040000H
JOY_BUTTON20	EQU	00080000H
JOY_BUTTON21	EQU	00100000H
JOY_BUTTON22	EQU	00200000H
JOY_BUTTON23	EQU	00400000H
JOY_BUTTON24	EQU	00800000H
JOY_BUTTON25	EQU	01000000H
JOY_BUTTON26	EQU	02000000H
JOY_BUTTON27	EQU	04000000H
JOY_BUTTON28	EQU	08000000H
JOY_BUTTON29	EQU	10000000H
JOY_BUTTON30	EQU	20000000H
JOY_BUTTON31	EQU	40000000H
JOY_BUTTON32	EQU	80000000H
; constants used with JOYINFOEX structure
JOY_POVCENTERED	EQU	-1
JOY_POVFORWARD	EQU	0
JOY_POVRIGHT	EQU	9000
JOY_POVBACKWARD	EQU	18000
JOY_POVLEFT	EQU	27000
JOY_RETURNX	EQU	00000001H
JOY_RETURNY	EQU	00000002H
JOY_RETURNZ	EQU	00000004H
JOY_RETURNR	EQU	00000008H
JOY_RETURNU	EQU	00000010H	; axis 5
JOY_RETURNV	EQU	00000020H	; axis 6
JOY_RETURNPOV	EQU	00000040H
JOY_RETURNBUTTONS	EQU	00000080H
JOY_RETURNRAWDATA	EQU	00000100H
JOY_RETURNPOVCTS	EQU	00000200H
JOY_RETURNCENTERED	EQU	00000400H
JOY_USEDEADZONE	EQU	00000800H
JOY_RETURNALL	EQU	(JOY_RETURNX OR JOY_RETURNY OR JOY_RETURNZ OR JOY_RETURNR OR JOY_RETURNU OR JOY_RETURNV OR JOY_RETURNPOV OR JOY_RETURNBUTTONS)
JOY_CAL_READALWAYS	EQU	00010000H
JOY_CAL_READXYONLY	EQU	00020000H
JOY_CAL_READ3	EQU	00040000H
JOY_CAL_READ4	EQU	00080000H
JOY_CAL_READXONLY	EQU	00100000H
JOY_CAL_READYONLY	EQU	00200000H
JOY_CAL_READ5	EQU	00400000H
JOY_CAL_READ6	EQU	00800000H
JOY_CAL_READZONLY	EQU	01000000H
JOY_CAL_READRONLY	EQU	02000000H
JOY_CAL_READUONLY	EQU	04000000H
JOY_CAL_READVONLY	EQU	08000000H
; joystick ID constants
JOYSTICKID1	EQU	0
JOYSTICKID2	EQU	1
; joystick driver capabilites
JOYCAPS_HASZ	EQU	0001H
JOYCAPS_HASR	EQU	0002H
JOYCAPS_HASU	EQU	0004H
JOYCAPS_HASV	EQU	0008H
JOYCAPS_HASPOV	EQU	0010H
JOYCAPS_POV4DIR	EQU	0020H
JOYCAPS_POVCTS	EQU	0040H

JOYCAPS	STRUC
jcaps_wMid	DW	?
jcaps_wPid	DW	?
jcaps_szPname	DB	MAXPNAMELEN DUP (?)
jcaps_wXmin	DW	?
jcaps_wXmax	DW	?
jcaps_wYmin	DW	?
jcaps_wYmax	DW	?
jcaps_wZmin	DW	?
jcaps_wZmax	DW	?
jcaps_wNumButtons	DW	?
jcaps_wPeriodMin	DW	?
jcaps_wPeriodMax	DW	?
jcaps_wRmin	DW	?
jcaps_wRmax	DW	?
jcaps_wUmin	DW	?
jcaps_wUmax	DW	?
jcaps_wVmin	DW	?
jcaps_wVmax	DW	?
jcaps_wCaps	DW	?
jcaps_wMaxAxes	DW	?
jcaps_wNumAxes	DW	?
jcaps_wMaxButtons	DW	?
jcaps_szRegKey	DB	MAXPNAMELEN DUP (?)
jcaps_szOEMVxD	DB	MAX_JOYSTICKOEMVXDNAME DUP (?)
JOYCAPS	ENDS

JOYINFO	STRUC
jinfo_wXpos	DW	?
jinfo_wYpos	DW	?
jinfo_wZpos	DW	?
jinfo_wButtons	DW	?
JOYINFO	ENDS

JOYINFOEX	STRUC
jinfoex_dwSize	DD	?
jinfoex_dwFlags	DD	?
jinfoex_dwXpos	DD	?
jinfoex_dwYpos	DD	?
jinfoex_dwZpos	DD	?
jinfoex_dwRpos	DD	?
jinfoex_dwUpos	DD	?
jinfoex_dwVpos	DD	?
jinfoex_dwButtons	DD	?
jinfoex_dwButtonNumber	DD	?
jinfoex_dwPOV	DD	?
jinfoex_dwReserved1	DD	?
jinfoex_dwReserved2	DD	?
JOYINFOEX	ENDS
endif                                       ;both; ifndef MMNOJOY
ifndef MMNOMMIO                                                ;both
ifndef _WIN32_VXD
;***************************************************************************
;	Multimedia File I/O support
;*************************************************************************
; MMIO error return values
MMIOERR_BASE	EQU	256
MMIOERR_FILENOTFOUND	EQU	(MMIOERR_BASE+1)  ; file not found
MMIOERR_OUTOFMEMORY	EQU	(MMIOERR_BASE+2)  ; out of memory
MMIOERR_CANNOTOPEN	EQU	(MMIOERR_BASE+3)  ; cannot open
MMIOERR_CANNOTCLOSE	EQU	(MMIOERR_BASE+4)  ; cannot close
MMIOERR_CANNOTREAD	EQU	(MMIOERR_BASE+5)  ; cannot read
MMIOERR_CANNOTWRITE	EQU	(MMIOERR_BASE+6)  ; cannot write
MMIOERR_CANNOTSEEK	EQU	(MMIOERR_BASE+7)  ; cannot seek
MMIOERR_CANNOTEXPAND	EQU	(MMIOERR_BASE+8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND	EQU	(MMIOERR_BASE+9)  ; chunk not found
MMIOERR_UNBUFFERED	EQU	(MMIOERR_BASE+10) ;
MMIOERR_PATHNOTFOUND	EQU	(MMIOERR_BASE+11) ; path incorrect
MMIOERR_ACCESSDENIED	EQU	(MMIOERR_BASE+12) ; file was protected
MMIOERR_SHARINGVIOLATION	EQU	(MMIOERR_BASE+13) ; file in use
MMIOERR_NETWORKERROR	EQU	(MMIOERR_BASE+14) ; network not responding
MMIOERR_TOOMANYOPENFILES	EQU	(MMIOERR_BASE+15) ; no more file handles
MMIOERR_INVALIDFILE	EQU	(MMIOERR_BASE+16) ; default error file error
; MMIO constants
CFSEPCHAR	EQU	<'+'>             ; compound file name separator char.

MMIOINFO	STRUC
mmio_dwFlags	DD	?
mmio_fccIOProc	DD	?
mmio_pIOProc	DD	?
mmio_wErrorRet	DW	?
mmio_htask	DW	?
mmio_cchBuffer	DD	?
mmio_pchBuffer	DD	?
mmio_pchNext	DD	?
mmio_pchEndRead	DD	?
mmio_pchEndWrite	DD	?
mmio_lBufOffset	DD	?
mmio_lDiskOffset	DD	?
mmio_adwInfo	DD	3 DUP (?)
mmio_dwReserved1	DD	?
mmio_dwReserved2	DD	?
mmio_hmmio	DW	?
MMIOINFO	ENDS
; bit field masks
MMIO_RWMODE	EQU	00000003H      ; open file for reading/writing/both
MMIO_SHAREMODE	EQU	00000070H      ; file sharing mode number
; constants for dwFlags field of MMIOINFO
MMIO_CREATE	EQU	00001000H      ; create new file (or truncate file)
MMIO_PARSE	EQU	00000100H      ; parse new file returning path
MMIO_DELETE	EQU	00000200H      ; create new file (or truncate file)
MMIO_EXIST	EQU	00004000H      ; checks for existence of file
MMIO_ALLOCBUF	EQU	00010000H      ; mmioOpen() should allocate a buffer
MMIO_GETTEMP	EQU	00020000H      ; mmioOpen() should retrieve temp name
MMIO_DIRTY	EQU	10000000H      ; I/O buffer is dirty
; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ	EQU	00000000H      ; open file for reading only
MMIO_WRITE	EQU	00000001H      ; open file for writing only
MMIO_READWRITE	EQU	00000002H      ; open file for reading and writing
; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT	EQU	00000000H      ; compatibility mode
MMIO_EXCLUSIVE	EQU	00000010H      ; exclusive-access mode
MMIO_DENYWRITE	EQU	00000020H      ; deny writing to other processes
MMIO_DENYREAD	EQU	00000030H      ; deny reading to other processes
MMIO_DENYNONE	EQU	00000040H      ; deny nothing to other processes
; various MMIO flags
MMIO_FHOPEN	EQU	0010H  ; mmioClose: keep file handle open
MMIO_EMPTYBUF	EQU	0010H  ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER	EQU	0010H  ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC	EQU	00010000H  ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC	EQU	10000000H  ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC	EQU	00020000H  ; mmioInstallIOProc: remove MMIOProc
MMIO_UNICODEPROC	EQU	01000000H  ; mmioInstallIOProc: Unicode MMIOProc
MMIO_FINDPROC	EQU	00040000H  ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK	EQU	0010H  ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF	EQU	0020H  ; mmioDescend: find a LIST chunk
MMIO_FINDLIST	EQU	0040H  ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF	EQU	0020H  ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST	EQU	0040H  ; mmioCreateChunk: make a RIFF chunk
; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ	EQU	MMIO_READ       ; read
MMIOM_WRITE	EQU	MMIO_WRITE       ; write
MMIOM_SEEK	EQU	2       ; seek to a new position in file
MMIOM_OPEN	EQU	3       ; open file
MMIOM_CLOSE	EQU	4       ; close file
MMIOM_WRITEFLUSH	EQU	5       ; write and flush
MMIOM_RENAME	EQU	6       ; rename specified file
MMIOM_USER	EQU	8000H       ; beginning of user-defined messages
; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET	EQU	0               ; seek to an absolute position
SEEK_CUR	EQU	1               ; seek relative to current position
SEEK_END	EQU	2               ; seek relative to end of file
endif  ; ifndef SEEK_SET
; other constants
MMIO_DEFAULTBUFFER	EQU	8192    ; default buffer size
endif  ; ifndef _WIN32_VXD
endif                                     ;both; ifndef MMNOMMIO
ifndef MMNOMCI                                                 ;both
ifndef _WIN32_VXD
; MCI error return values
MCIERR_INVALID_DEVICE_ID	EQU	(MCIERR_BASE+1)
MCIERR_UNRECOGNIZED_KEYWORD	EQU	(MCIERR_BASE+3)
MCIERR_UNRECOGNIZED_COMMAND	EQU	(MCIERR_BASE+5)
MCIERR_HARDWARE	EQU	(MCIERR_BASE+6)
MCIERR_INVALID_DEVICE_NAME	EQU	(MCIERR_BASE+7)
MCIERR_OUT_OF_MEMORY	EQU	(MCIERR_BASE+8)
MCIERR_DEVICE_OPEN	EQU	(MCIERR_BASE+9)
MCIERR_CANNOT_LOAD_DRIVER	EQU	(MCIERR_BASE+10)
MCIERR_MISSING_COMMAND_STRING	EQU	(MCIERR_BASE+11)
MCIERR_PARAM_OVERFLOW	EQU	(MCIERR_BASE+12)
MCIERR_MISSING_STRING_ARGUMENT	EQU	(MCIERR_BASE+13)
MCIERR_BAD_INTEGER	EQU	(MCIERR_BASE+14)
MCIERR_PARSER_INTERNAL	EQU	(MCIERR_BASE+15)
MCIERR_DRIVER_INTERNAL	EQU	(MCIERR_BASE+16)
MCIERR_MISSING_PARAMETER	EQU	(MCIERR_BASE+17)
MCIERR_UNSUPPORTED_FUNCTION	EQU	(MCIERR_BASE+18)
MCIERR_FILE_NOT_FOUND	EQU	(MCIERR_BASE+19)
MCIERR_DEVICE_NOT_READY	EQU	(MCIERR_BASE+20)
MCIERR_INTERNAL	EQU	(MCIERR_BASE+21)
MCIERR_DRIVER	EQU	(MCIERR_BASE+22)
MCIERR_CANNOT_USE_ALL	EQU	(MCIERR_BASE+23)
MCIERR_MULTIPLE	EQU	(MCIERR_BASE+24)
MCIERR_EXTENSION_NOT_FOUND	EQU	(MCIERR_BASE+25)
MCIERR_OUTOFRANGE	EQU	(MCIERR_BASE+26)
MCIERR_FLAGS_NOT_COMPATIBLE	EQU	(MCIERR_BASE+28)
MCIERR_FILE_NOT_SAVED	EQU	(MCIERR_BASE+30)
MCIERR_DEVICE_TYPE_REQUIRED	EQU	(MCIERR_BASE+31)
MCIERR_DEVICE_LOCKED	EQU	(MCIERR_BASE+32)
MCIERR_DUPLICATE_ALIAS	EQU	(MCIERR_BASE+33)
MCIERR_BAD_CONSTANT	EQU	(MCIERR_BASE+34)
MCIERR_MUST_USE_SHAREABLE	EQU	(MCIERR_BASE+35)
MCIERR_MISSING_DEVICE_NAME	EQU	(MCIERR_BASE+36)
MCIERR_BAD_TIME_FORMAT	EQU	(MCIERR_BASE+37)
MCIERR_NO_CLOSING_QUOTE	EQU	(MCIERR_BASE+38)
MCIERR_DUPLICATE_FLAGS	EQU	(MCIERR_BASE+39)
MCIERR_INVALID_FILE	EQU	(MCIERR_BASE+40)
MCIERR_NULL_PARAMETER_BLOCK	EQU	(MCIERR_BASE+41)
MCIERR_UNNAMED_RESOURCE	EQU	(MCIERR_BASE+42)
MCIERR_NEW_REQUIRES_ALIAS	EQU	(MCIERR_BASE+43)
MCIERR_NOTIFY_ON_AUTO_OPEN	EQU	(MCIERR_BASE+44)
MCIERR_NO_ELEMENT_ALLOWED	EQU	(MCIERR_BASE+45)
MCIERR_NONAPPLICABLE_FUNCTION	EQU	(MCIERR_BASE+46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN	EQU	(MCIERR_BASE+47)
MCIERR_FILENAME_REQUIRED	EQU	(MCIERR_BASE+48)
MCIERR_EXTRA_CHARACTERS	EQU	(MCIERR_BASE+49)
MCIERR_DEVICE_NOT_INSTALLED	EQU	(MCIERR_BASE+50)
MCIERR_GET_CD	EQU	(MCIERR_BASE+51)
MCIERR_SET_CD	EQU	(MCIERR_BASE+52)
MCIERR_SET_DRIVE	EQU	(MCIERR_BASE+53)
MCIERR_DEVICE_LENGTH	EQU	(MCIERR_BASE+54)
MCIERR_DEVICE_ORD_LENGTH	EQU	(MCIERR_BASE+55)
MCIERR_NO_INTEGER	EQU	(MCIERR_BASE+56)
MCIERR_WAVE_OUTPUTSINUSE	EQU	(MCIERR_BASE+64)
MCIERR_WAVE_SETOUTPUTINUSE	EQU	(MCIERR_BASE+65)
MCIERR_WAVE_INPUTSINUSE	EQU	(MCIERR_BASE+66)
MCIERR_WAVE_SETINPUTINUSE	EQU	(MCIERR_BASE+67)
MCIERR_WAVE_OUTPUTUNSPECIFIED	EQU	(MCIERR_BASE+68)
MCIERR_WAVE_INPUTUNSPECIFIED	EQU	(MCIERR_BASE+69)
MCIERR_WAVE_OUTPUTSUNSUITABLE	EQU	(MCIERR_BASE+70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE	EQU	(MCIERR_BASE+71)
MCIERR_WAVE_INPUTSUNSUITABLE	EQU	(MCIERR_BASE+72)
MCIERR_WAVE_SETINPUTUNSUITABLE	EQU	(MCIERR_BASE+73)
MCIERR_SEQ_DIV_INCOMPATIBLE	EQU	(MCIERR_BASE+80)
MCIERR_SEQ_PORT_INUSE	EQU	(MCIERR_BASE+81)
MCIERR_SEQ_PORT_NONEXISTENT	EQU	(MCIERR_BASE+82)
MCIERR_SEQ_PORT_MAPNODEVICE	EQU	(MCIERR_BASE+83)
MCIERR_SEQ_PORT_MISCERROR	EQU	(MCIERR_BASE+84)
MCIERR_SEQ_TIMER	EQU	(MCIERR_BASE+85)
MCIERR_SEQ_PORTUNSPECIFIED	EQU	(MCIERR_BASE+86)
MCIERR_SEQ_NOMIDIPRESENT	EQU	(MCIERR_BASE+87)
MCIERR_NO_WINDOW	EQU	(MCIERR_BASE+90)
MCIERR_CREATEWINDOW	EQU	(MCIERR_BASE+91)
MCIERR_FILE_READ	EQU	(MCIERR_BASE+92)
MCIERR_FILE_WRITE	EQU	(MCIERR_BASE+93)
MCIERR_NO_IDENTITY	EQU	(MCIERR_BASE+94)
; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE	EQU	(MCIERR_BASE+256)
MCI_FIRST	EQU	DRV_MCI_FIRST   ; 0x0800
; MCI command message identifiers
MCI_OPEN	EQU	0803H
MCI_CLOSE	EQU	0804H
MCI_ESCAPE	EQU	0805H
MCI_PLAY	EQU	0806H
MCI_SEEK	EQU	0807H
MCI_STOP	EQU	0808H
MCI_PAUSE	EQU	0809H
MCI_INFO	EQU	080AH
MCI_GETDEVCAPS	EQU	080BH
MCI_SPIN	EQU	080CH
MCI_SET	EQU	080DH
MCI_STEP	EQU	080EH
MCI_RECORD	EQU	080FH
MCI_SYSINFO	EQU	0810H
MCI_BREAK	EQU	0811H
MCI_SOUND	EQU	0812H    ;internal
MCI_SAVE	EQU	0813H
MCI_STATUS	EQU	0814H
MCI_CUE	EQU	0830H
MCI_REALIZE	EQU	0840H
MCI_WINDOW	EQU	0841H
MCI_PUT	EQU	0842H
MCI_WHERE	EQU	0843H
MCI_FREEZE	EQU	0844H
MCI_UNFREEZE	EQU	0845H
MCI_LOAD	EQU	0850H
MCI_CUT	EQU	0851H
MCI_COPY	EQU	0852H
MCI_PASTE	EQU	0853H
MCI_UPDATE	EQU	0854H
MCI_RESUME	EQU	0855H
MCI_DELETE	EQU	0856H
MCI_WIN32CLIENT	EQU	0857H	;internal
; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES	EQU	(DRV_MCI_FIRST+400H)
MCI_LAST	EQU	0FFFH
MCI_ALL_DEVICE_ID	EQU	-1
; constants for predefined MCI device types
MCI_DEVTYPE_VCR	EQU	513 ; (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC	EQU	514 ; (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY	EQU	515 ; (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO	EQU	516 ; (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT	EQU	517 ; (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER	EQU	518 ; (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION	EQU	519 ; (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO	EQU	520 ; (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER	EQU	521 ; (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO	EQU	522 ; (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER	EQU	523 ; (MCI_STRING_OFFSET + 11)
MCI_DEVTYPE_FIRST	EQU	MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST	EQU	MCI_DEVTYPE_SEQUENCER
MCI_DEVTYPE_FIRST_USER	EQU	1000H
; return values for 'status mode' command
MCI_MODE_NOT_READY	EQU	(MCI_STRING_OFFSET+12)
MCI_MODE_STOP	EQU	(MCI_STRING_OFFSET+13)
MCI_MODE_PLAY	EQU	(MCI_STRING_OFFSET+14)
MCI_MODE_RECORD	EQU	(MCI_STRING_OFFSET+15)
MCI_MODE_SEEK	EQU	(MCI_STRING_OFFSET+16)
MCI_MODE_PAUSE	EQU	(MCI_STRING_OFFSET+17)
MCI_MODE_OPEN	EQU	(MCI_STRING_OFFSET+18)
; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS	EQU	0
MCI_FORMAT_HMS	EQU	1
MCI_FORMAT_MSF	EQU	2
MCI_FORMAT_FRAMES	EQU	3
MCI_FORMAT_SMPTE_24	EQU	4
MCI_FORMAT_SMPTE_25	EQU	5
MCI_FORMAT_SMPTE_30	EQU	6
MCI_FORMAT_SMPTE_30DROP	EQU	7
MCI_FORMAT_BYTES	EQU	8
MCI_FORMAT_SAMPLES	EQU	9
MCI_FORMAT_TMSF	EQU	10
; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL	EQU	0001H
MCI_NOTIFY_SUPERSEDED	EQU	0002H
MCI_NOTIFY_ABORTED	EQU	0004H
MCI_NOTIFY_FAILURE	EQU	0008H
; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY	EQU	00000001H
MCI_WAIT	EQU	00000002H
MCI_FROM	EQU	00000004H
MCI_TO	EQU	00000008H
MCI_TRACK	EQU	00000010H
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE	EQU	00000100H
MCI_OPEN_ELEMENT	EQU	00000200H
MCI_OPEN_ALIAS	EQU	00000400H
MCI_OPEN_ELEMENT_ID	EQU	00000800H
MCI_OPEN_TYPE_ID	EQU	00001000H
MCI_OPEN_TYPE	EQU	00002000H
; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START	EQU	00000100H
MCI_SEEK_TO_END	EQU	00000200H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM	EQU	00000100H
MCI_STATUS_START	EQU	00000200H
; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH	EQU	00000001H
MCI_STATUS_POSITION	EQU	00000002H
MCI_STATUS_NUMBER_OF_TRACKS	EQU	00000003H
MCI_STATUS_MODE	EQU	00000004H
MCI_STATUS_MEDIA_PRESENT	EQU	00000005H
MCI_STATUS_TIME_FORMAT	EQU	00000006H
MCI_STATUS_READY	EQU	00000007H
MCI_STATUS_CURRENT_TRACK	EQU	00000008H
; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT	EQU	00000100H
MCI_INFO_FILE	EQU	00000200H
MCI_INFO_MEDIA_UPC	EQU	00000400H
MCI_INFO_MEDIA_IDENTITY	EQU	00000800H
MCI_INFO_NAME	EQU	00001000H
MCI_INFO_COPYRIGHT	EQU	00002000H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM	EQU	00000100H
; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD	EQU	00000001H
MCI_GETDEVCAPS_HAS_AUDIO	EQU	00000002H
MCI_GETDEVCAPS_HAS_VIDEO	EQU	00000003H
MCI_GETDEVCAPS_DEVICE_TYPE	EQU	00000004H
MCI_GETDEVCAPS_USES_FILES	EQU	00000005H
MCI_GETDEVCAPS_COMPOUND_DEVICE	EQU	00000006H
MCI_GETDEVCAPS_CAN_EJECT	EQU	00000007H
MCI_GETDEVCAPS_CAN_PLAY	EQU	00000008H
MCI_GETDEVCAPS_CAN_SAVE	EQU	00000009H
; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY	EQU	00000100H
MCI_SYSINFO_OPEN	EQU	00000200H
MCI_SYSINFO_NAME	EQU	00000400H
MCI_SYSINFO_INSTALLNAME	EQU	00000800H
; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN	EQU	00000100H
MCI_SET_DOOR_CLOSED	EQU	00000200H
MCI_SET_TIME_FORMAT	EQU	00000400H
MCI_SET_AUDIO	EQU	00000800H
MCI_SET_VIDEO	EQU	00001000H
MCI_SET_ON	EQU	00002000H
MCI_SET_OFF	EQU	00004000H
; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL	EQU	00000000H
MCI_SET_AUDIO_LEFT	EQU	00000001H
MCI_SET_AUDIO_RIGHT	EQU	00000002H
; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY	EQU	00000100H
MCI_BREAK_HWND	EQU	00000200H
MCI_BREAK_OFF	EQU	00000400H
; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT	EQU	00000100H
MCI_RECORD_OVERWRITE	EQU	00000200H
	;internal; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME	EQU	00000100H		;internal
								;internal
; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE	EQU	00000100H
; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE	EQU	00000100H

MCI_GENERIC_PARMS	STRUC
mcigen_dwCallback	DD	?
MCI_GENERIC_PARMS	ENDS

MCI_OPEN_PARMS	STRUC
mciopen_dwCallback	DD	?
mciopen_wDeviceID	DW	?
mciopen_wReserved0	DW	?
mciopen_lpstrDeviceType	DD	?
mciopen_lpstrElementName	DD	?
mciopen_lpstrAlias	DD	?
MCI_OPEN_PARMS	ENDS

MCI_PLAY_PARMS	STRUC
mciplay_dwCallback	DD	?
mciplay_dwFrom	DD	?
mciplay_dwTo	DD	?
MCI_PLAY_PARMS	ENDS

MCI_SEEK_PARMS	STRUC
mciseek_dwCallback	DD	?
mciseek_dwTo	DD	?
MCI_SEEK_PARMS	ENDS

MCI_STATUS_PARMS	STRUC
mcistat_dwCallback	DD	?
mcistat_dwReturn	DD	?
mcistat_dwItem	DD	?
mcistat_dwTrack	DD	?
MCI_STATUS_PARMS	ENDS

MCI_INFO_PARMS	STRUC
mciinfo_dwCallback	DD	?
mciinfo_lpstrReturn	DD	?
mciinfo_dwRetSize	DD	?
MCI_INFO_PARMS	ENDS

MCI_GETDEVCAPS_PARMS	STRUC
mcigdc_dwCallback	DD	?
mcigdc_dwReturn	DD	?
mcigdc_dwItem	DD	?
MCI_GETDEVCAPS_PARMS	ENDS

MCI_SYSINFO_PARMS	STRUC
mcisi_dwCallback	DD	?
mcisi_lpstrReturn	DD	?
mcisi_dwRetSize	DD	?
mcisi_dwNumber	DD	?
mcisi_wDeviceType	DW	?
mcisi_wReserved0	DW	?
MCI_SYSINFO_PARMS	ENDS

MCI_SET_PARMS	STRUC
mciset_dwCallback	DD	?
mciset_dwTimeFormat	DD	?
mciset_dwAudio	DD	?
MCI_SET_PARMS	ENDS

MCI_BREAK_PARMS	STRUC
mcibreak_dwCallback	DD	?
mcibreak_nVirtKey	DW	?
mcibreak_wReserved0	DW	?
mcibreak_hwndBreak	DW	?
mcibreak_wReserved1	DW	?
MCI_BREAK_PARMS	ENDS

MCI_SAVE_PARMS	STRUC
mcisave_dwCallback	DD	?
mcisave_lpfilename	DD	?
MCI_SAVE_PARMS	ENDS

MCI_LOAD_PARMS	STRUC
mciload_dwCallback	DD	?
mciload_lpfilename	DD	?
MCI_LOAD_PARMS	ENDS

MCI_RECORD_PARMS	STRUC
mcirec_dwCallback	DD	?
mcirec_dwFrom	DD	?
mcirec_dwTo	DD	?
MCI_RECORD_PARMS	ENDS
; MCI extensions for videodisc devices
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK	EQU	(MCI_VD_OFFSET+1)
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV	EQU	(MCI_VD_OFFSET+2)
MCI_VD_MEDIA_CAV	EQU	(MCI_VD_OFFSET+3)
MCI_VD_MEDIA_OTHER	EQU	(MCI_VD_OFFSET+4)
MCI_VD_FORMAT_TRACK	EQU	4001H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE	EQU	00010000H
MCI_VD_PLAY_FAST	EQU	00020000H
MCI_VD_PLAY_SPEED	EQU	00040000H
MCI_VD_PLAY_SCAN	EQU	00080000H
MCI_VD_PLAY_SLOW	EQU	00100000H
; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE	EQU	00010000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED	EQU	00004002H
MCI_VD_STATUS_FORWARD	EQU	00004003H
MCI_VD_STATUS_MEDIA_TYPE	EQU	00004004H
MCI_VD_STATUS_SIDE	EQU	00004005H
MCI_VD_STATUS_DISC_SIZE	EQU	00004006H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV	EQU	00010000H
MCI_VD_GETDEVCAPS_CAV	EQU	00020000H
MCI_VD_SPIN_UP	EQU	00010000H
MCI_VD_SPIN_DOWN	EQU	00020000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE	EQU	00004002H
MCI_VD_GETDEVCAPS_FAST_RATE	EQU	00004003H
MCI_VD_GETDEVCAPS_SLOW_RATE	EQU	00004004H
MCI_VD_GETDEVCAPS_NORMAL_RATE	EQU	00004005H
; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES	EQU	00010000H
MCI_VD_STEP_REVERSE	EQU	00020000H
; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING	EQU	00000100H

MCI_VD_PLAY_PARMS	STRUC
mcivdplay_dwCallback	DD	?
mcivdplay_dwFrom	DD	?
mcivdplay_dwTo	DD	?
mcivdplay_dwSpeed	DD	?
MCI_VD_PLAY_PARMS	ENDS

MCI_VD_STEP_PARMS	STRUC
mcivdstep_dwCallback	DD	?
mcivdstep_dwFrames	DD	?
MCI_VD_STEP_PARMS	ENDS

MCI_VD_ESCAPE_PARMS	STRUC
mcivcesc_dwCallback	DD	?
mcivcesc_lpstrCommand	DD	?
MCI_VD_ESCAPE_PARMS	ENDS
; MCI extensions for CD audio devices
; flags for the dwItem field of the MCI_STATUS_PARMS parameter block
MCI_CDA_STATUS_TYPE_TRACK	EQU	00004001H
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK)
MCI_CDA_TRACK_AUDIO	EQU	(MCI_CD_OFFSET+0)
MCI_CDA_TRACK_OTHER	EQU	(MCI_CD_OFFSET+1)
; MCI extensions for waveform audio devices
MCI_WAVE_PCM	EQU	(MCI_WAVE_OFFSET+0)
MCI_WAVE_MAPPER	EQU	(MCI_WAVE_OFFSET+1)
; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER	EQU	00010000H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG	EQU	00010000H
MCI_WAVE_SET_CHANNELS	EQU	00020000H
MCI_WAVE_SET_SAMPLESPERSEC	EQU	00040000H
MCI_WAVE_SET_AVGBYTESPERSEC	EQU	00080000H
MCI_WAVE_SET_BLOCKALIGN	EQU	00100000H
MCI_WAVE_SET_BITSPERSAMPLE	EQU	00200000H
; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT	EQU	00400000H
MCI_WAVE_OUTPUT	EQU	00800000H
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG	EQU	00004001H
MCI_WAVE_STATUS_CHANNELS	EQU	00004002H
MCI_WAVE_STATUS_SAMPLESPERSEC	EQU	00004003H
MCI_WAVE_STATUS_AVGBYTESPERSEC	EQU	00004004H
MCI_WAVE_STATUS_BLOCKALIGN	EQU	00004005H
MCI_WAVE_STATUS_BITSPERSAMPLE	EQU	00004006H
MCI_WAVE_STATUS_LEVEL	EQU	00004007H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT	EQU	04000000H
MCI_WAVE_SET_ANYOUTPUT	EQU	08000000H
; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS	EQU	00004001H
MCI_WAVE_GETDEVCAPS_OUTPUTS	EQU	00004002H

MCI_WAVE_OPEN_PARMS	STRUC
mciwopen_dwCallback	DD	?
mciwopen_wDeviceID	DW	?
mciwopen_wReserved0	DW	?
mciwopen_lpstrDeviceType	DD	?
mciwopen_lpstrElementName	DD	?
mciwopen_lpstrAlias	DD	?
mciwopen_dwBufferSeconds	DD	?
MCI_WAVE_OPEN_PARMS	ENDS

MCI_WAVE_DELETE_PARMS	STRUC
mciwdel_dwCallback	DD	?
mciwdel_dwFrom	DD	?
mciwdel_dwTo	DD	?
MCI_WAVE_DELETE_PARMS	ENDS

MCI_WAVE_SET_PARMS	STRUC
mciwset_dwCallback	DD	?
mciwset_dwTimeFormat	DD	?
mciwset_dwAudio	DD	?
mciwset_wInput	DW	?
mciwset_wReserved0	DW	?
mciwset_wOutput	DW	?
mciwset_wReserved1	DW	?
mciwset_wFormatTag	DW	?
mciwset_wReserved2	DW	?
mciwset_nChannels	DW	?
mciwset_wReserved3	DW	?
mciwset_nSamplesPerSec	DW	?
mciwset_nAvgBytesPerSec	DW	?
mciwset_nBlockAlign	DW	?
mciwset_wReserved4	DW	?
mciwset_wBitsPerSample	DW	?
mciwset_wReserved5	DW	?
MCI_WAVE_SET_PARMS	ENDS
; MCI extensions for MIDI sequencer devices
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN	EQU	(0+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24	EQU	(1+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25	EQU	(2+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP	EQU	(3+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30	EQU	(4+MCI_SEQ_OFFSET)
; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR	EQU	4001H
MCI_SEQ_FILE	EQU	4002H
MCI_SEQ_MIDI	EQU	4003H
MCI_SEQ_SMPTE	EQU	4004H
MCI_SEQ_NONE	EQU	65533
MCI_SEQ_MAPPER	EQU	65535
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO	EQU	00004002H
MCI_SEQ_STATUS_PORT	EQU	00004003H
MCI_SEQ_STATUS_SLAVE	EQU	00004007H
MCI_SEQ_STATUS_MASTER	EQU	00004008H
MCI_SEQ_STATUS_OFFSET	EQU	00004009H
MCI_SEQ_STATUS_DIVTYPE	EQU	0000400AH
MCI_SEQ_STATUS_NAME	EQU	0000400BH
MCI_SEQ_STATUS_COPYRIGHT	EQU	0000400CH
; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO	EQU	00010000H
MCI_SEQ_SET_PORT	EQU	00020000H
MCI_SEQ_SET_SLAVE	EQU	00040000H
MCI_SEQ_SET_MASTER	EQU	00080000H
MCI_SEQ_SET_OFFSET	EQU	01000000H

MCI_SEQ_SET_PARMS	STRUC
mcisset_dwCallback	DD	?
mcisset_dwTimeFormat	DD	?
mcisset_dwAudio	DD	?
mcisset_dwTempo	DD	?
mcisset_dwPort	DD	?
mcisset_dwSlave	DD	?
mcisset_dwMaster	DD	?
mcisset_dwOffset	DD	?
MCI_SEQ_SET_PARMS	ENDS
; MCI extensions for animation devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS	EQU	00010000H
MCI_ANIM_OPEN_PARENT	EQU	00020000H
MCI_ANIM_OPEN_NOSTATIC	EQU	00040000H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED	EQU	00010000H
MCI_ANIM_PLAY_REVERSE	EQU	00020000H
MCI_ANIM_PLAY_FAST	EQU	00040000H
MCI_ANIM_PLAY_SLOW	EQU	00080000H
MCI_ANIM_PLAY_SCAN	EQU	00100000H
; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE	EQU	00010000H
MCI_ANIM_STEP_FRAMES	EQU	00020000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED	EQU	00004001H
MCI_ANIM_STATUS_FORWARD	EQU	00004002H
MCI_ANIM_STATUS_HWND	EQU	00004003H
MCI_ANIM_STATUS_HPAL	EQU	00004004H
MCI_ANIM_STATUS_STRETCH	EQU	00004005H
; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE	EQU	00004001H
MCI_ANIM_GETDEVCAPS_FAST_RATE	EQU	00004002H
MCI_ANIM_GETDEVCAPS_SLOW_RATE	EQU	00004003H
MCI_ANIM_GETDEVCAPS_NORMAL_RATE	EQU	00004004H
MCI_ANIM_GETDEVCAPS_PALETTES	EQU	00004006H
MCI_ANIM_GETDEVCAPS_CAN_STRETCH	EQU	00004007H
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS	EQU	00004008H
; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM	EQU	00010000H
MCI_ANIM_REALIZE_BKGD	EQU	00020000H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND	EQU	00010000H
MCI_ANIM_WINDOW_STATE	EQU	00040000H
MCI_ANIM_WINDOW_TEXT	EQU	00080000H
MCI_ANIM_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_ANIM_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT	EQU	00010000H
MCI_ANIM_PUT_SOURCE	EQU	00020000H
MCI_ANIM_PUT_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE	EQU	00020000H
MCI_ANIM_WHERE_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC	EQU	00020000H

MCI_ANIM_OPEN_PARMS	STRUC
mciaopen_dwCallback	DD	?
mciaopen_wDeviceID	DW	?
mciaopen_wReserved0	DW	?
mciaopen_lpstrDeviceType	DD	?
mciaopen_lpstrElementName	DD	?
mciaopen_lpstrAlias	DD	?
mciaopen_dwStyle	DD	?
mciaopen_hWndParent	DW	?
mciaopen_wReserved1	DW	?
MCI_ANIM_OPEN_PARMS	ENDS

MCI_ANIM_PLAY_PARMS	STRUC
mciaplay_dwCallback	DD	?
mciaplay_dwFrom	DD	?
mciaplay_dwTo	DD	?
mciaplay_dwSpeed	DD	?
MCI_ANIM_PLAY_PARMS	ENDS

MCI_ANIM_STEP_PARMS	STRUC
mciastep_dwCallback	DD	?
mciastep_dwFrames	DD	?
MCI_ANIM_STEP_PARMS	ENDS

MCI_ANIM_WINDOW_PARMS	STRUC
mciawin_dwCallback	DD	?
mciawin_hWnd	DW	?
mciawin_wReserved1	DW	?
mciawin_nCmdShow	DW	?
mciawin_wReserved2	DW	?
mciawin_lpstrText	DD	?
MCI_ANIM_WINDOW_PARMS	ENDS

MCI_ANIM_RECT_PARMS	STRUC
mciarect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciarect_ptOffset	DB	SIZE POINT DUP (?)
mciarect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciarect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS	ENDS

MCI_ANIM_UPDATE_PARMS	STRUC
mciaupd_dwCallback	DD	?
mciaupd_rc	DB	SIZE RECT DUP (?)
mciaupd_hDC	DW	?
MCI_ANIM_UPDATE_PARMS	ENDS
; MCI extensions for video overlay devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS	EQU	00010000H
MCI_OVLY_OPEN_PARENT	EQU	00020000H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND	EQU	00004001H
MCI_OVLY_STATUS_STRETCH	EQU	00004002H
; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH	EQU	00004001H
MCI_OVLY_GETDEVCAPS_CAN_FREEZE	EQU	00004002H
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS	EQU	00004003H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND	EQU	00010000H
MCI_OVLY_WINDOW_STATE	EQU	00040000H
MCI_OVLY_WINDOW_TEXT	EQU	00080000H
MCI_OVLY_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_OVLY_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT	EQU	00010000H
MCI_OVLY_PUT_SOURCE	EQU	00020000H
MCI_OVLY_PUT_DESTINATION	EQU	00040000H
MCI_OVLY_PUT_FRAME	EQU	00080000H
MCI_OVLY_PUT_VIDEO	EQU	00100000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE	EQU	00020000H
MCI_OVLY_WHERE_DESTINATION	EQU	00040000H
MCI_OVLY_WHERE_FRAME	EQU	00080000H
MCI_OVLY_WHERE_VIDEO	EQU	00100000H

MCI_OVLY_OPEN_PARMS	STRUC
mcioopen_dwCallback	DD	?
mcioopen_wDeviceID	DW	?
mcioopen_wReserved0	DW	?
mcioopen_lpstrDeviceType	DD	?
mcioopen_lpstrElementName	DD	?
mcioopen_lpstrAlias	DD	?
mcioopen_dwStyle	DD	?
mcioopen_hWndParent	DW	?
mcioopen_wReserved1	DW	?
MCI_OVLY_OPEN_PARMS	ENDS

MCI_OVLY_WINDOW_PARMS	STRUC
mciowin_dwCallback	DD	?
mciowin_hWnd	DW	?
mciowin_wReserved1	DW	?
mciowin_nCmdShow	DW	?
mciowin_wReserved2	DW	?
mciowin_lpstrText	DD	?
MCI_OVLY_WINDOW_PARMS	ENDS

MCI_OVLY_RECT_PARMS	STRUC
mciorect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciorect_ptOffset	DB	SIZE POINT DUP (?)
mciorect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciorect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS	ENDS

MCI_OVLY_SAVE_PARMS	STRUC
mciosave_dwCallback	DD	?
mciosave_lpfilename	DD	?
mciosave_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_SAVE_PARMS	ENDS

MCI_OVLY_LOAD_PARMS	STRUC
mcioload_dwCallback	DD	?
mcioload_lpfilename	DD	?
mcioload_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_LOAD_PARMS	ENDS
endif  ; ifndef _WIN32_VXD
endif                                      ;both; ifndef MMNOMCI
;***************************************************************************
;	DISPLAY Driver extensions
;*************************************************************************
ifndef NEWTRANSPARENT
NEWTRANSPARENT	EQU	3           ; use with SetBkMode()
QUERYROPSUPPORT	EQU	40          ; use to determine ROP support
endif  ; ifndef NEWTRANSPARENT
;***************************************************************************
;	DIB Driver extensions
;*************************************************************************
SELECTDIB	EQU	41                      ; DIB.DRV select dib escape
ifndef SC_SCREENSAVE
SC_SCREENSAVE	EQU	0F140H
endif  ; ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\timerwnd.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @module 
 * TimerWnd.C -
 *
 * Create and manage user mode timer callbacks based on a window callback |
 *
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>

#include "dmusic16.h"
#include "debug.h"

STATIC VOID FAR PASCAL __loadds TimerTask(DWORD dwInstance);
STATIC BOOL NEAR PASCAL CreateTimerWindow(VOID);
LRESULT CALLBACK __loadds timerWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

STATIC SZCODE gszTimerWindowClass[] = "DM16TW";
STATIC HTASK  ghtaskTimer;
STATIC HWND   ghwndTimer;
STATIC UINT   guTimerID;

/* Timer window functions called by message crackers
 */
BOOL NEAR PASCAL  Timer_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
VOID NEAR PASCAL  Timer_OnTimer(HWND hwnd, UINT id);
VOID NEAR PASCAL  Timer_OnClose(HWND hwnd);

/* @func
 *
 * @comm
 */
BOOL PASCAL
CreateTimerTask(
    VOID)
{
    UINT rc;
    /* Already up and running?
     */
    if (IsWindow(ghwndTimer))
    {
        return TRUE;
    }

    /* In some undefined state?
     */
    if (IsTask(ghtaskTimer))
    {
        DPF(0, "CreateTimerTask: In some weird state; bailing");
        return FALSE;
    }

    /* The task is not already running. Create it.
     */
    ghwndTimer = NULL;
    ghtaskTimer = NULL;
    rc = mmTaskCreate(TimerTask, NULL, 0); 
    if (rc)
    {
        DPF(0, "CreateTimerTask: mmTaskCreate() -> %u", rc);
        return FALSE;
    }

    /* Give away CPU to other tasks until the timer task starts up.
     * It will set ghtaskTimer to non-zero when it is up or if it fails.
     */
    while (!ghtaskTimer)
    {
        Yield();
    }

    /* Did it fail?
     */
    if (ghtaskTimer != (HTASK)-1)
    {
        return TRUE;
    }

    DPF(0, "CreateTimerTask: Task startup failed.");

    ghwndTimer = NULL;
    ghtaskTimer = NULL;

    DPF(1, "CreateTimerTask: htask %.4X hwnd %.4x",
        (WORD)ghtaskTimer,
        (WORD)ghwndTimer);
    
    /* Something went wrong and the task terminated.
     */
    return FALSE;
}

/* @func
 *
 * @comm
 */
VOID PASCAL
DestroyTimerTask(
    VOID)
{
    if (!IsWindow(ghwndTimer))
    {
        /* Nothing to kill.
         */
        return;
    }

    //FORWARD_WM_CLOSE(ghwndTimer, PostMessage);
    SendMessage(ghwndTimer, WM_CLOSE, (WPARAM)0, (LPARAM)0);

    /* Wait for task to terminate
     */
    DPF(2, "About to wait for MMTASK(%04X) to go away...", (WORD)ghtaskTimer);
    while (IsTask(ghtaskTimer))
    {
        Yield();
    }
    DPF(2, "Done waiting for MMTASK to go away...");
    
    ghwndTimer = NULL;
}

/* @func
 *
 * @comm
 */
STATIC VOID FAR PASCAL __loadds
TimerTask(
    DWORD dwInstance)
{
    MSG msg;

    /* Create the hidden callback window
     */
    if (!CreateTimerWindow())
    {
        ghtaskTimer = (HTASK)-1;
        return;
    }

    /* On success, set our task handle and tell the system we're a
     * service process
     */
    ghtaskTimer = mmGetCurrentTask();
//    RegisterServiceProcess(NULL, RSP_SIMPLE_SERVICE);

    /* The ever-present message loop
     */
    while (GetMessage(&msg, NULL, 0, 0))
    {
        DispatchMessage(&msg);
    }
    DPF(2, "Out of MMTASK!");

    /* Someome threw us a WM_CLOSE.
     */
//   RegisterServiceProcess(NULL, RSP_UNREGISTER_SERVICE);
//    UnregisterClass(gszTimerWindowClass, ghInst);

//    WaitEvent(ghtaskTimer);
}

STATIC BOOL NEAR PASCAL
CreateTimerWindow(
    VOID)
{
    WNDCLASS cls;

    cls.hCursor        = NULL;
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = gszTimerWindowClass;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = ghInst;
    cls.style          = CS_GLOBALCLASS;
    cls.lpfnWndProc    = (WNDPROC)timerWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if (RegisterClass(&cls))
    {
        ghwndTimer = CreateWindowEx(0, gszTimerWindowClass, NULL, WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL, ghInst, NULL);
        if (ghwndTimer)
        {
            DPF(1, "Timer Window (%.4Xh)", ghwndTimer);
            return TRUE;
        }
    }

    UnregisterClass(gszTimerWindowClass, ghInst);

    return FALSE;
}

LRESULT CALLBACK __loadds
timerWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch(msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         Timer_OnCreate);
        HANDLE_MSG(hwnd, WM_TIMER,          Timer_OnTimer);
        HANDLE_MSG(hwnd, WM_CLOSE,          Timer_OnClose);
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL NEAR PASCAL
Timer_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct)
{
    DPF(2, "Timer_OnCreate");
//    guTimerID = SetTimer(hwnd, 1, MS_USERMODE, NULL);

    return /*(BOOL)(guTimerID != 0);*/ TRUE; 
}

VOID NEAR PASCAL
Timer_OnTimer(
    HWND hwnd,
    UINT id)
{
    MidiInRefillFreeLists();
}


VOID NEAR PASCAL
Timer_OnClose(
    HWND hwnd)
{
    DPF(2,"Timer_OnClose");
//    KillTimer(hwnd, guTimerID);
    DestroyWindow(hwnd);
    PostQuitMessage(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic16\uldiv.asm ===
page	,132
	title	uldiv - unsigned long divide routine
;***
;uldiv.asm - unsigned long divide routine
;
;	Copyright (c) 1985-1998 Microsoft Corporation
;
;Purpose:
;	defines the unsigned long divide routine
;	the following routines are created:
;	    __aFuldiv	(large, medium models)
;	    __aNuldiv	(small, compact models)
;
;*******************************************************************************

.xlist

        ?PLM = 0
        ?WIN = 1
	PMODE= 1
        memM = 1


include cmacros.inc
include cmphlp.inc
include mm.inc
.list

CreateSeg       FIXMIDI,        MidiFix, word, public, CODE

sBegin	MidiFix
	assumes cs,MidiFix
	assumes ds,data

page
;***
;uldiv - unsigned long divide
;
;Purpose:
;	Does a unsigned long divide of the arguments.  Arguments are
;	not changed.
;
;Entry:
;	Arguments are passed on the stack:
;		1st pushed: divisor (DWORD)
;		2nd pushed: dividend (DWORD)
;
;Exit:
;	DX:AX contains the quotient (dividend/divisor)
;	NOTE: this routine removes the parameters from the stack.
;
;Uses:
;	CX
;
;Exceptions:
;
;*******************************************************************************

;	ASGN	uldiv
if	sizeC
cProc	_aFuldiv,<PUBLIC>,<>

else
cProc	_aNuldiv,<PUBLIC>,<>
endif

ParmD	DVND1
ParmD   DVSR1
cBegin

	push	bx
	push	si

; Set up the local stack and save the index registers.	When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to uldiv(a, b)):
;
;		-----------------
;		|		|
;		|---------------|
;		|		|
;		|--divisor (b)--|
;		|		|
;		|---------------|
;		|		|
;		|--dividend (a)-|
;		|		|
;		|---------------|
;		| return addr** |
;		|---------------|
;	BP----->|    old BP	|
;		|---------------|
;		|      BX	|
;		|---------------|
;	SP----->|      SI	|
;		-----------------
;
; ** - 2 bytes if small/compact model; 4 bytes if medium/large model

DVND	equ	BPARGBAS[bp]	; stack address of dividend (a)
DVSR	equ	BPARGBAS+4[bp]	; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 64K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

	mov	ax,HIWORD(DVSR) ; check to see if divisor < 64K
	or	ax,ax
	jnz	L1		; nope, gotta do this the hard way
	mov	cx,LOWORD(DVSR) ; load divisor
	mov	ax,HIWORD(DVND) ; load high word of dividend
	xor	dx,dx
	div	cx		; get high order bits of quotient
	mov	bx,ax		; save high bits of quotient
	mov	ax,LOWORD(DVND) ; dx:ax <- remainder:lo word of dividend
	div	cx		; get low order bits of quotient
	mov	dx,bx		; dx:ax <- quotient hi:quotient lo
	jmp	short L2	; restore stack and return

;
; Here we do it the hard way.  Remember, ax contains DVSRHI
;

L1:
	mov	cx,ax		; cx:bx <- divisor
	mov	bx,LOWORD(DVSR)
	mov	dx,HIWORD(DVND) ; dx:ax <- dividend
	mov	ax,LOWORD(DVND)
L3:
	shr	cx,1		; shift divisor right one bit; hi bit <- 0
	rcr	bx,1
	shr	dx,1		; shift dividend right one bit; hi bit <- 0
	rcr	ax,1
	or	cx,cx
	jnz	L3		; loop until divisor < 64K
	div	bx		; now divide, ignore remainder
	mov	si,ax		; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**32 and the quotient is off by 1.
;

	mul	word ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
	xchg	cx,ax		; "mov cx,ax" but only 1 byte
	mov	ax,LOWORD(DVSR)
	mul	si		; QUOT * LOWORD(DVSR)
	add	dx,cx		; DX:AX = QUOT * DVSR
	jc	L4		; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in dx:ax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

	cmp	dx,HIWORD(DVND) ; compare hi words of result and original
	ja	L4		; if result > original, do subtract
	jb	L5		; if result < original, we are ok
	cmp	ax,LOWORD(DVND) ; hi words are equal, compare lo words
	jbe	L5		; if less or equal we are ok, else subtract
L4:
	dec	si		; subtract 1 from quotient
L5:
	xor	dx,dx		; dx:ax <- quotient
	xchg	ax,si		; "mov ax,si" but only 1 byte

;
; Just the cleanup left to do.	dx:ax contains the quotient.
; Restore the saved registers and return.
;

L2:

	pop	si
	pop	bx

cEnd	<nolocals>
return	8

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);
#define Trace DebugTrace
#define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )
#else
#define Trace
#define assert(exp)	((void)0)
#endif
#endif // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\dm32dll.cpp ===
// Copyright (c) 1998 Microsoft Corporation
// dm32dll.cpp
//
// Dll entry points 
//
#include <objbase.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "debug.h"

#include "dmusic32.h"
#include "dm32p.h"

// Globals
//

// Dll's hModule
//
HMODULE g_hModule = NULL;

extern "C" BOOL PASCAL dmthunk_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);

static CONST TCHAR pszDll16[] = "DMUSIC16.DLL";
static CONST TCHAR pszDll32[] = "DMUSIC32.DLL";

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

// Standard Win32 DllMain
//
BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    HANDLE ph;
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        Trace(2, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(2, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif
                if (!DisableThreadLibraryCalls(hModule))
                {
                    Trace(0, "DisableThreadLibraryCalls failed.\n");
                }

                if (!OpenMMDEVLDR())
                {
                    Trace(0, "OpenMMDEVLDR failed.\n");
                }
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                Trace(1, "Last process detach\n");
                CloseMMDEVLDR();
            }
            break;

        default:
            Trace(-1, "Got a non-process at/detach!\n");
            break;
    }


    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = hModule;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
        {
            return FALSE;
        }
    }


    if (!dmthunk_ThunkConnect32(pszDll16, pszDll32, hModule, dwReason))
    {
        Trace(-1, "Could not connect to thunk layer! - not loading.\n");
        return FALSE;
    }       

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\dm32p.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/*
 * Internal function prototypes for DMusic32.dll
 */
#ifndef _DM32P_
#define _DM32P_

#include "..\shared\dmusiccp.h"
#include "tpool.h"

#define THREAD_KILL_TIMEOUT         5000
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#define MIDI_CHANNELS               16

/* DevIoctl.c - MMDEVLDR hooks we use
 */
extern BOOL WINAPI OpenMMDEVLDR(void);
extern VOID WINAPI CloseMMDEVLDR(void);
extern VOID WINAPI CloseVxDHandle(DWORD hVxDHandle);

/* From Win32 kernel
 */
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hEvent);

// 10 ms in 100ns units
//
#define FIXED_LEGACY_LATENCY_OFFSET (10L * 10L * 1000L)

class CEmulateLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CEmulateLatencyClock(IReferenceClock *pMasterClock);
    ~CEmulateLatencyClock();

    void Close();

private:
    long m_cRef;
    IReferenceClock *m_pMasterClock;
};

// Struct for holding a property item supported by the synth
//

class CDirectMusicEmulatePort;

typedef HRESULT (CDirectMusicEmulatePort::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};






class CDirectMusicEmulatePort : 
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicThru,
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument*,
                                            IDirectMusicDownloadedInstrument**,
                                            DMUS_NOTERANGE*,
                                            DWORD);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument*);
    
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwNumChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwNumChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
        
    // IDirectMusicThru
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);
    
    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave    
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBuses,
         IN DWORD cBusCount
        );        
        
    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
    );

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
    );

    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();
	STDMETHODIMP Report();
    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG veVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd
        );

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop
        );
    
    STDMETHODIMP GetVoicePosition(   
         DWORD dwVoice[], 
         DWORD cbVoice,
         SAMPLE_POSITION dwVoicePos[] 
        );
        
    STDMETHODIMP Refresh(
         DWORD dwDownloadID,
         DWORD dwFlags
         );        
         
    // Class
    //
    CDirectMusicEmulatePort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulatePort();
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

    DWORD InputWorker();
    DWORD TimerWorker();
    
   

private:
    long                    m_cRef;
    UINT                    m_id;
    BOOL                    m_fIsOutput;
    HANDLE                  m_hDevice;
    CDirectMusic            *m_pDM;
    DWORD                   m_hVxDEvent;
    DMUS_PORTCAPS           dmpc;
    IReferenceClock         *m_pMasterClock;
    CEmulateLatencyClock    *m_pLatencyClock;
    IDirectMusicPortNotify  *m_pNotify;
    
    HANDLE                  m_hAppEvent;
    HANDLE                  m_hDataReady;
    HANDLE                  m_hKillThreads;
    HANDLE                  m_hCaptureThread;
    BYTE                    m_WorkBuffer[THREAD_WORK_BUFFER_SIZE];
    DWORD                   m_dwWorkBufferTileInfo;
    DWORD                   m_p1616WorkBuffer;
    EVENT_POOL              m_FreeEvents;        
    EVENT_QUEUE             m_ReadEvents;
    CRITICAL_SECTION        m_csEventQueues;
    BOOL                    m_fCSInitialized;
    
    IDirectMusicBuffer      *m_pThruBuffer;
    LPDMUS_THRU_CHANNEL     m_pThruMap;

    long                    m_lActivated;    
    
    BOOL                    m_fSyncToMaster;
    LONGLONG                m_lTimeOffset;
    
private:
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    
private:
    HRESULT InitializeClock();
    HRESULT InitializeCapture();
    void InputWorkerDataReady();    
    void ThruEvent(DMEVENT *pEvent);
    void MasterToSlave(REFERENCE_TIME *prt);
    void SlaveToMaster(REFERENCE_TIME *prt);
    void SyncClocks();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\devioctl.cpp ===
// Copyright (c) 1998 Microsoft Corporation
#include <windows.h>

#include <objbase.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "mmdevldr.h"

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "dmusic32.h"
#include "dm32p.h"

static CONST TCHAR cszMMDEVLDR[] = "\\\\.\\MMDEVLDR.VXD";

static HANDLE ghMMDEVLDR = INVALID_HANDLE_VALUE;

BOOL WINAPI OpenMMDEVLDR(
    void)
{
    ghMMDEVLDR = CreateFile(
        cszMMDEVLDR,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return ghMMDEVLDR != INVALID_HANDLE_VALUE;
}


VOID WINAPI CloseMMDEVLDR(
    void)
{
    if (ghMMDEVLDR != INVALID_HANDLE_VALUE)
    {
        CloseHandle(ghMMDEVLDR);
        ghMMDEVLDR = INVALID_HANDLE_VALUE;
    }
}
                          
                          

VOID WINAPI CloseVxDHandle(
    DWORD hVxDHandle)                           
{
    DWORD cb;

    DeviceIoControl(ghMMDEVLDR,
                    MMDEVLDR_IOCTL_CLOSEVXDHANDLE,
                    NULL,
                    0,
                    &hVxDHandle,
                    sizeof(hVxDHandle),
                    &cb,
                    NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMUSIC32"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\dmthunk.h ===
// Copyright (c) 1998 Microsoft Corporation
/*
 * Prototypes for thunked functions between DMusic32.dll and DMusic16.dll
 */
#ifndef _DMTHUNK_
#define _DMTHUNK_

#ifdef __cplusplus
extern "C" {
#endif

extern void PASCAL dmUntileBuffer(DWORD dwTilingInfo);
extern DWORD PASCAL dmTileBuffer(DWORD dwFlatMemory, DWORD dwLength);
extern MMRESULT PASCAL OpenLegacyDevice(DWORD dwId, BOOL fIsOutput, BOOL fShare, HANDLE *pHandle);
extern MMRESULT PASCAL CloseLegacyDevice(HANDLE h);
extern MMRESULT PASCAL ActivateLegacyDevice(HANDLE h, DWORD fActivate);

extern MMRESULT PASCAL MidiOutSubmitPlaybackBuffer(HANDLE hMidiOut, DWORD pbBuffer, DWORD cbBuffer, DWORD msStartTime,
												   DWORD rtStartTimeLow, DWORD rtStartTimeHigh);

extern MMRESULT PASCAL MidiInSetEventHandle(HANDLE hMidiIn, DWORD hEvent);
extern MMRESULT PASCAL MidiInRead(HANDLE hMidiIn, DWORD pbBuffer, DWORD *cbBuffer, DWORD *msStartTime);
extern MMRESULT PASCAL MidiInThru(HANDLE hMidiIn, DWORD dwFrom, DWORD dwTo, HANDLE hMidiOut);

#ifdef __cplusplus
};
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\dmeport.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmeport.cpp
//
// CDirectMusicEmulatePort
// Implements the MMSYSTEM API version of IDirectMusicPort.
//
#define INITGUID
#include <objbase.h>
#include <ks.h>
#include <ksproxy.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "debug.h"
#include "dmusic32.h"
#include "dm32p.h"
#include "dmthunk.h"
#include "..\shared\validate.h"

#include <ks.h>             // KSDATAFORMAT_SUBTYPE_MIDI

#pragma warning(disable:4530)

#define CLOCK_UPDATE_INTERVAL   100         // milliseconds

#define MS_TO_REFERENCE_TIME    (10 * 1000)

static HRESULT MMRESULTToHRESULT(
    MMRESULT mmr);

static DWORD InputWorker(LPVOID lpv);

// @func API call into DLL to get a new port
//
HRESULT
CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    CDirectMusicEmulatePort **pPort)
{
    HRESULT hr;
    
    *pPort = new CDirectMusicEmulatePort(pPE, pDM);
    if (NULL == *pPort)
    {
        return E_OUTOFMEMORY;
    }

    hr = (*pPort)->Init(pPortParams);
    if (!SUCCEEDED(hr))
    {
        delete *pPort;
        *pPort = NULL;
        return hr;
    }

    return hr;
}
   

// @mfunc Constructor for CDirectMusicEmulatePort
//
CDirectMusicEmulatePort::CDirectMusicEmulatePort(
                                                 PORTENTRY *pPE,    // @parm The portentry of this device
                                                 CDirectMusic *pDM):// @parm The CDirectMusic implementation which created this port
                                                 m_cRef(1),
                                                 m_id(pPE->idxDevice),
                                                 m_pDM(pDM),
                                                 m_hKillThreads(NULL),
                                                 m_hDataReady(NULL),
                                                 m_hAppEvent(NULL),
                                                 m_dwWorkBufferTileInfo(0),
                                                 m_pThruBuffer(NULL),
                                                 m_pThruMap(NULL),
                                                 m_lActivated(0),
                                                 m_hCaptureThread(NULL),
                                                 m_pMasterClock(NULL),
                                                 m_fCSInitialized(FALSE)
{
    m_fIsOutput = (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS) ? TRUE : FALSE;
    m_hDevice = NULL;
    m_pLatencyClock = NULL;
    dmpc = pPE->pc;
}

// @mfunc Destructor for CDirectMusicEmulatePort
//
CDirectMusicEmulatePort::~CDirectMusicEmulatePort()
{
    Close();
}

// @mfunc Initialization of CDirectMusicEmulatePort
//
// @comm Call through the thunk layer to open the requested device. 
//

// Flags we recognize 
//
#define DMUS_ALL_FLAGS (DMUS_PORTPARAMS_VOICES |            \
                        DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_AUDIOCHANNELS |     \
                        DMUS_PORTPARAMS_SAMPLERATE |        \
                        DMUS_PORTPARAMS_EFFECTS |           \
                        DMUS_PORTPARAMS_SHARE)

// Of those, which do we actually look at?
//
#define DMUS_SUP_FLAGS (DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_SHARE)

HRESULT
CDirectMusicEmulatePort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    MMRESULT mmr;
    HRESULT hr;
    BOOL fChangedParms;

    // Get, but don't hold onto, the notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pNotify->Release();

    // Munge the portparams to match what we support.
    //
    fChangedParms = FALSE;
    if (pPortParams->dwValidParams & ~DMUS_ALL_FLAGS) 
    {
        Trace(0, "Undefined flags in port parameters: %08X\n", pPortParams->dwValidParams & ~DMUS_ALL_FLAGS);
        // Flags set we don't recognize.
        //
        pPortParams->dwValidParams &= DMUS_ALL_FLAGS;
        fChangedParms = TRUE;
    }

    // We recognize these flags but don't support them.
    //
    if (pPortParams->dwValidParams & ~DMUS_SUP_FLAGS)
    {
        pPortParams->dwValidParams &= DMUS_SUP_FLAGS;
        fChangedParms = TRUE;
    }

    // Channel groups better be one.
    //
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
    {
        if (pPortParams->dwChannelGroups != 1)
        {
            pPortParams->dwChannelGroups = 1;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
        pPortParams->dwChannelGroups = 1;
    }

    BOOL fShare = FALSE;
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
    {
        if (m_fIsOutput)
        {
            fShare = pPortParams->fShare;
        }
        else
        {
            pPortParams->fShare = FALSE;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_SHARE;
        pPortParams->fShare = fShare;
    }

    mmr = OpenLegacyDevice(m_id, m_fIsOutput, fShare, &m_hDevice);
    if (mmr)
    {
        return MMRESULTToHRESULT(mmr);
    }

    // Set up the master clock and our latency clock
    //
    hr = InitializeClock();
    if (FAILED(hr))
    {
        return hr;
    }

    // If an input port, initialize capture specific stuff like thruing
    //    
    if (!m_fIsOutput)
    {
        hr = InitializeCapture();
        if (FAILED(hr))
        {  
            return hr;
        }
    }

    return fChangedParms ? S_FALSE : S_OK;
}

HRESULT CDirectMusicEmulatePort::InitializeClock()
{
    HRESULT hr;
    GUID guidMasterClock;
    DWORD dwThreadID;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hr = m_pDM->GetMasterClock(&guidMasterClock, &m_pMasterClock);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pLatencyClock = new CEmulateLatencyClock(m_pMasterClock);

    if (NULL == m_pLatencyClock)
    {
        return E_OUTOFMEMORY;
    }

#if 0
    if (guidMasterClock == GUID_SysClock)
    {
        m_fSyncToMaster = FALSE;
        return S_OK;
    }
#endif

    m_fSyncToMaster = TRUE;
    // Read both clocks 
    //
    hr = m_pMasterClock->GetTime(&rtMasterClock);
    rtSlaveClock = MS_TO_REFERENCE_TIME * ((ULONGLONG)timeGetTime());
    
    if (FAILED(hr))
    {
        return hr;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;

    return S_OK;
}

HRESULT CDirectMusicEmulatePort::InitializeCapture()
{
    HRESULT hr;
    MMRESULT mmr;
    DWORD dwThreadID;

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Create thruing buffer
    //
    // XXX Defer this until the first call to thru?
    //
    // Note: guaranteed by dmusic16 this is the biggest event ever to be returned
    // (thunk api asking?)
    //
    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hr = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hr))
    {
        Trace(0, "Failed to create thruing buffer\n");
        return hr;
    }

    // Create events
    //
    m_hDataReady = CreateEvent(NULL,        // Event attributes
                               FALSE,       // Manual reset
                               FALSE,       // Not signalled
                               NULL);       // Name

    m_hKillThreads = CreateEvent(NULL,       // Event attributes
                                 FALSE,      // Manual reset
                                 FALSE,      // Not signalled
                                 NULL);      // Name

    if (m_hDataReady == (HANDLE)NULL || m_hKillThreads == (HANDLE)NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Set our data ready event for dmusic16 
    //
    m_hVxDEvent = OpenVxDHandle(m_hDataReady);

    Trace(2, "Setting event handle; hDevice %08x hEvent=%08X hVxDEvent=%08X\n",
          (DWORD)m_hDevice,
          (DWORD)m_hDataReady,
          (DWORD)m_hVxDEvent);
    
    mmr = MidiInSetEventHandle(m_hDevice, m_hVxDEvent);
    if (mmr)
    {
        Trace(0, "MidiInSetEventHandle returned [%d]\n", mmr);
        return MMRESULTToHRESULT(mmr);
    }

    // Create a tiling for our work buffer so we only need to do it once
    //
    m_dwWorkBufferTileInfo = dmTileBuffer((DWORD)m_WorkBuffer, sizeof(m_WorkBuffer));
    m_p1616WorkBuffer = TILE_P1616(m_dwWorkBufferTileInfo);
    if (m_p1616WorkBuffer == NULL)
    {
        Trace(0, "Could not tile work buffer\n");
        return E_OUTOFMEMORY;
    }

    // Initialize cs to protect event queues.
    //
    // Unfortunately this can throw an exception if out of memory.
    //
    _try 
    {
        InitializeCriticalSection(&m_csEventQueues);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_OUTOFMEMORY;
    }
    
    m_fCSInitialized = TRUE;

    m_hCaptureThread = CreateThread(NULL,          // Thread attributes
                                    0,             // Stack size
                                    ::InputWorker,
                                    this,
                                    0,             // Flags
                                    &dwThreadID);
    if (m_hCaptureThread == NULL)
    {
        Trace(0, "CreateThread failed with error %d\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

static DWORD WINAPI InputWorker(LPVOID lpv)
{
    CDirectMusicEmulatePort *pPort = (CDirectMusicEmulatePort*)lpv;

    return pPort->InputWorker();
}



// @mfunc
//
// @comm Standard QueryInterface
//
STDMETHODIMP
CDirectMusicEmulatePort::QueryInterface(const IID &iid,
                                        void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


// CDirectMusicEmulatePort::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicEmulatePort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicEmulatePort::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicEmulatePort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }
        
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::Compact

STDMETHODIMP
CDirectMusicEmulatePort::Compact()
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::GetCaps

STDMETHODIMP
CDirectMusicEmulatePort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::DeviceIoControl

STDMETHODIMP 
CDirectMusicEmulatePort::DeviceIoControl(
    DWORD dwIoControlCode, 
    LPVOID lpInBuffer, 
    DWORD nInBufferSize, 
    LPVOID lpOutBuffer, 
    DWORD nOutBufferSize, 
    LPDWORD lpBytesReturned, 
    LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CDirectMusicEmulatePort::SetNumChannelGroups(
    DWORD   dwNumChannelGroups)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (dwNumChannelGroups != 1)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetNumChannelGroups(
    LPDWORD   pdwChannelGroups)
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = 1;
    
    return S_OK;
}




// @mfunc Queue a buffer for playback
//
#define REFTIME_TO_MS (10L*1000L)

STDMETHODIMP
CDirectMusicEmulatePort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    CDirectMusicBuffer *pBuffer = reinterpret_cast<CDirectMusicBuffer *>(pIBuffer);

    REFERENCE_TIME rt;
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  dwTileInfo;
    LONGLONG msTime;
    MMRESULT mmr;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    if (!m_lActivated)
    {
        return DMUS_E_SYNTHINACTIVE;
    }
    
    // Make sure the object doesn't disappear out from under us while we're in Win16
    //
    pBuffer->AddRef();
    pBuffer->GetUsedBytes(&cbData);
    if (cbData == 0)
    {
        pBuffer->Release();
        return S_OK;
    }

    pBuffer->GetRawBufferPtr(&pbData);
    assert(pbData);
    pBuffer->GetStartTime(&rt);

    // Adjust timebase if we are not using the timeGetTime clock
    //

    Trace(2, "Buffer base time %I64d timeGetTime %u\n", rt, timeGetTime());
    SyncClocks();
    MasterToSlave(&rt);
    Trace(2, "Buffer adjusted base time %I64d\n", rt);



    msTime = rt / REFTIME_TO_MS;

    // Send it through the thunk
    //
    dwTileInfo = dmTileBuffer((DWORD)pbData, cbData);
    mmr = MidiOutSubmitPlaybackBuffer(m_hDevice,
                               TILE_P1616(dwTileInfo),
                               cbData,
                               (DWORD)msTime,
                               (DWORD)(rt & 0xFFFFFFFF),                  // RefTime low
                               (DWORD)((rt >> 32) & 0xFFFFFFFF));       // RefTime high
    dmUntileBuffer(dwTileInfo);

    pBuffer->Release();
    
    return MMRESULTToHRESULT(mmr);
}

STDMETHODIMP
CDirectMusicEmulatePort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    LPBYTE pbBuffer;
    hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    Trace(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        Trace(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {               
        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;

        DWORD cbQueuedEvent = DMUS_EVENT_SIZE(pQueuedEvent->e.cbEvent);
        Trace(2, "Read: cbEvent %u  cbQueuedEvent %u\n", 
            pQueuedEvent->e.cbEvent,
            cbQueuedEvent);

        if (cbQueuedEvent > cbBuffer)
        {
            Trace(2, "Read: No more room for events in buffer.\n");
            break;
        }

        Trace(2, "Read: Got an event!\n");

        pQueuedEvent->e.rtDelta -= rtStart;

        CopyMemory(pbData, 
                   &pQueuedEvent->e,
                   sizeof(DMEVENT) - sizeof(DWORD) + pQueuedEvent->e.cbEvent);

        pbData += cbQueuedEvent;
        cbBuffer -= cbQueuedEvent;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.cbEvent <= sizeof(DWORD))
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
        else
        {
            // This event was allocated via new char[]
            //
            char *pOriginalMemory = (char*)pQueuedEvent;
            delete[] pOriginalMemory;
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    Trace(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes(pbData - pbBuffer);

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    m_hAppEvent = hEvent;

    return S_OK;    
}

STDMETHODIMP
CDirectMusicEmulatePort::DownloadInstrument(
    IDirectMusicInstrument *pInstrument,
    IDirectMusicDownloadedInstrument **pDownloadedInstrument,
    DMUS_NOTERANGE *pRange,
    DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::UnloadInstrument(
    IDirectMusicDownloadedInstrument *pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pLatencyClock->AddRef();
    *ppClock = m_pLatencyClock;
    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::Activate(
    BOOL fActivate)
{
    MMRESULT mmr;

	V_INAME(IDirectMusicPort::Activate);
	
	if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1)) 
        {
            Trace(0, "Activate: Already active\n");
            // Already activated
            //
            return S_FALSE;
        }    

        mmr = ActivateLegacyDevice(m_hDevice, TRUE);
        if (mmr)
        {
            Trace(0, "Activate: Activate mmr %d\n", mmr);
            m_lActivated = 0;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            Trace(0, "Activate: Already inactive\n");
            // Already deactivated
            //
            return S_FALSE;
        }

        mmr = ActivateLegacyDevice(m_hDevice, FALSE);
        if (mmr)
        {
            Trace(0, "Activate: Deactivate mmr %d\n", mmr);
            m_lActivated = 1;
        }
    }

    return MMRESULTToHRESULT(mmr);
}

STDMETHODIMP 
CDirectMusicEmulatePort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP 
CDirectMusicEmulatePort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    return E_NOTIMPL;
}    


STDMETHODIMP
CDirectMusicEmulatePort::Close()
{
    if (m_hCaptureThread)
    {
        SetEvent(m_hKillThreads);
        if (WaitForSingleObject(m_hCaptureThread, THREAD_KILL_TIMEOUT) == WAIT_TIMEOUT)
        {
            Trace(0, "Warning: Input thread timed out; exit anyway.\n");
        }

        m_hCaptureThread = NULL;
    }

    if (m_pThruMap)
    {
        for (int iChannel = 0; iChannel < 16; iChannel++)
        {
            if (m_pThruMap[iChannel].pDestinationPort == NULL)
            {
                continue;
            }

            if (m_pThruMap[iChannel].fThruInWin16)
            {
                MMRESULT mmr = MidiInThru(m_hDevice,
                                          (DWORD)iChannel,
                                          0,
                                          NULL);
            }

            m_pThruMap[iChannel].pDestinationPort->Release();
        }

        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    if (m_hDataReady)
    {
        CloseHandle(m_hDataReady);
        m_hDataReady = NULL;
    }

    if (m_hKillThreads)
    {
        CloseHandle(m_hKillThreads);
        m_hKillThreads = NULL;
    }

    if (m_hAppEvent)
    {
        m_hAppEvent = NULL;
    }

    if (m_dwWorkBufferTileInfo)
    {
        dmUntileBuffer(m_dwWorkBufferTileInfo);
        m_dwWorkBufferTileInfo = 0;
        m_p1616WorkBuffer = NULL; 
    }

    if (m_hVxDEvent)
    {
        CloseVxDHandle(m_hVxDEvent);
        m_hVxDEvent = NULL;
    }
    
    if (m_hDevice)
    {
        CloseLegacyDevice(m_hDevice);
        m_hDevice = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pLatencyClock)
    {
        m_pLatencyClock->Close();
        m_pLatencyClock->Release();
        m_pLatencyClock = NULL;
    }

    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_csEventQueues);
    }

    m_pDM = NULL;
    m_pNotify = NULL;

    
    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::Report()
{
    return S_OK;
}

// StartVoice and StopVoice don't work on legacy devices
//
STDMETHODIMP CDirectMusicEmulatePort::StartVoice(          
     DWORD dwVoiceId,
     DWORD dwChannel,
     DWORD dwChannelGroup,
     REFERENCE_TIME rtStart,
     DWORD dwDLId,
     LONG prPitch,
     LONG veVolume,
     SAMPLE_TIME stVoiceStart,
     SAMPLE_TIME stLoopStart,
     SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}    

STDMETHODIMP CDirectMusicEmulatePort::StopVoice(
     DWORD dwVoiceID,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDirectMusicEmulatePort::GetVoicePosition(   
     DWORD dwVoice[], 
     DWORD cbVoice,
     SAMPLE_POSITION dwVoicePos[])
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CDirectMusicEmulatePort::Refresh(
     DWORD dwDownloadID,
     DWORD dwFlags)
{
    return E_NOTIMPL;
}


// CDirectMusicEmulatePort::ThruChannel
//
STDMETHODIMP 
CDirectMusicEmulatePort::ThruChannel(
    DWORD dwSourceChannelGroup, 
    DWORD dwSourceChannel, 
    DWORD dwDestinationChannelGroup,
    DWORD dwDestinationChannel,
    LPDIRECTMUSICPORT pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }    

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        return E_INVALIDARG;
    }
    
    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            Trace(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups) 
        {
            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;
        m_pThruMap[dwSourceChannel].fThruInWin16 = FALSE;

        // Is the destination also a legacy port?
        //
        if (dmpc.dwType == DMUS_PORT_WINMM_DRIVER)
        {
            // Woohoo! We can do native thruing in Win16!
            //
            m_pThruMap[dwSourceChannel].fThruInWin16 = TRUE;

            Trace(2, "32: Thruing <%d> -> <%d> in Win16\n", 
                dwSourceChannel,
                dwDestinationChannel);

            MMRESULT mmr = MidiInThru(m_hDevice,
                                      dwSourceChannel,
                                      dwDestinationChannel,
                                      ((CDirectMusicEmulatePort*)pDestinationPort)->m_hDevice);
            if (mmr)
            {
                Trace(0, "ThruChannel: MidiInThru returned %d\n", mmr);
                return MMRESULTToHRESULT(mmr);

            }
        }
        else
        { 
            Trace(2, "ThruChannel: From (%u,%u) -> (%u,%u,%p)\n",
                dwSourceChannelGroup,
                dwSourceChannel,
                dwDestinationChannelGroup,
                dwDestinationChannel,
                pDestinationPort);
        }

        pDestinationPort->AddRef();
    } 
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            if (m_pThruMap[dwSourceChannel].fThruInWin16)
            {
                MMRESULT mmr = MidiInThru(m_hDevice,
                                          dwSourceChannel,
                                          0,
                                          (HANDLE)NULL);
            
                if (mmr)
                {
                    Trace(0, "ThruChannel: MidiInThru returned %d\n", mmr);
                    return MMRESULTToHRESULT(mmr);

                }
            }

            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

STDMETHODIMP 
CDirectMusicEmulatePort::SetDirectSound(
    LPDIRECTSOUND pDirectSound, 
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CDirectMusicEmulatePort::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx, 
    LPDWORD pdwWaveFormatExSize, 
    LPDWORD pdwBufferSize)
{
    return E_NOTIMPL;
}

// CDirectMusicEmulatePort::DownloadWave
//
STDMETHODIMP 
CDirectMusicEmulatePort::DownloadWave(
    IDirectSoundWave *pWave,               
    IDirectSoundDownloadedWaveP **ppWave)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

// CDirectMusicEmulatePort::UnloadWave
//
STDMETHODIMP 
CDirectMusicEmulatePort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

            
// CDirectMusicEmulatePort::AllocVoice
//
STDMETHODIMP 
CDirectMusicEmulatePort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}        

// CDirectMusicEmulatePort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicEmulatePort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}        

STDMETHODIMP
CDirectMusicEmulatePort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}        

STDMETHODIMP
CDirectMusicEmulatePort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}        

GENERICPROPERTY CDirectMusicEmulatePort::m_aProperty[] = 
{      
    { &GUID_DMUS_PROP_LegacyCaps,           // Set
      0,                                    // Item
      KSPROPERTY_SUPPORT_GET,               // KS support flags
      GENPROP_F_FNHANDLER,                  // GENPROP flags
      NULL, 0,                              // static data and size
      CDirectMusicEmulatePort::LegacyCaps   // Handler
    }
};

const int CDirectMusicEmulatePort::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);


HRESULT CDirectMusicEmulatePort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIINCAPS  mic;
    MIDIOUTCAPS moc;
    LPBYTE      pbData;
    ULONG       cbData;

    if (m_fIsOutput)
    {    
        MMRESULT mmr = midiOutGetDevCaps(m_id, &moc, sizeof(moc));
        if (mmr)
        {
            Trace(0, "midiOutGetDevCaps failed!\n");
            return MMRESULTToHRESULT(mmr);
        }

        pbData = (LPBYTE)&moc;
        cbData = sizeof(moc);
    }
    else
    {
        MMRESULT mmr = midiInGetDevCaps(m_id, &mic, sizeof(mic));
        if (mmr)
        {
            Trace(0, "midiInGetDevCaps failed!\n");
            return MMRESULTToHRESULT(mmr);
        }

        pbData = (LPBYTE)&mic;
        cbData = sizeof(mic);
    }

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

// 
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CDirectMusicEmulatePort::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CDirectMusicEmulatePort::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;
    if ((dwFlags == 0) || (dwFlags == (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET)))
    {
    }

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_GET, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_SET, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(-1, "%s: Flags must contain one of\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CDirectMusicEmulatePort::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CDirectMusicEmulatePort::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}

#define OFFSET_DATA_READY   0
#define OFFSET_KILL_THREAD  1

DWORD CDirectMusicEmulatePort::InputWorker()
{
    HANDLE h[2];

    h[OFFSET_DATA_READY]  = m_hDataReady;
    h[OFFSET_KILL_THREAD] = m_hKillThreads;

    UINT uWait;

    for(;;) 
    {
        uWait = WaitForMultipleObjects(2, h, FALSE, INFINITE);

        switch(uWait)
        {
            case WAIT_OBJECT_0 + OFFSET_DATA_READY:
                // m_hDataReady set
                //
                InputWorkerDataReady();
                if (m_hAppEvent)
                {
                    try
                    {
                        SetEvent(m_hAppEvent);
                    } 
                    catch (...)
                    {
                        Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
                    }
                }
                break;

            case WAIT_OBJECT_0 + OFFSET_KILL_THREAD:
                // m_hKillThread set
                //
                Trace(0, "CDirectMusicEmulateWorker::InputWorker thread exit\n");
                return 0;

            case WAIT_FAILED:
                Trace(0, "WaitForMultipleObjects failed %d killing thread\n", GetLastError());
                return 0;

            default:
                break;
        }            
    }

    return 0;
}

// CDirectMusicEmulatePort::InputWorkerDataReady()
//
// The input worker thread has been notified that there is data available. 
// Read any pending events from the 16-bit DLL, perform needed thruing, and
// save the data in a queue so we can repackage it on the read request
// from the client.
//
void CDirectMusicEmulatePort::InputWorkerDataReady()
{
    MMRESULT mmr;
    DWORD cbData;
    DWORD msTime;
    LPBYTE pbData;
    DMEVENT *pEvent;
    DWORD cbRounded;
    REFERENCE_TIME rtStart;
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;

    Trace(0, "Enter InputWorkerDataReady()\n");
    for(;;)
    {
        // Fill temporary buffer
        //
        cbData = sizeof(m_WorkBuffer);
        mmr = MidiInRead(m_hDevice,
                         m_p1616WorkBuffer,
                         &cbData,
                         &msTime);

        rtStart = ((ULONGLONG)msTime) * REFTIME_TO_MS;
        SyncClocks();
        SlaveToMaster(&rtStart);
        
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (mmr)
        {
            Trace(2, "InputWorkerDataReady: MidiInRead returned %d\n", mmr);
            return;
        }

        if (cbData == 0)
        {
            Trace(2, "MidiInRead returned no data\n");
            return;
        }

        // Copy temporary buffer as events into queue
        //
        pbData = m_WorkBuffer;
        while (cbData)
        {
            pEvent = (DMEVENT*)pbData;
            cbRounded = DMUS_EVENT_SIZE(pEvent->cbEvent);

            Trace(2, "cbData %u  cbRounded %u\n", cbData, cbRounded);

            if (cbRounded > cbData)
            {
                Trace(0, "InputWorkerDataReady: Event ran off end of buffer\n");
                break;
            }

            cbData -= cbRounded;
            pbData += cbRounded;

            EnterCriticalSection(&m_csEventQueues);

            QUEUED_EVENT *pQueuedEvent;
            int cbEvent;

            
            if (pEvent->cbEvent <= sizeof(DWORD))
            {
                // Channel message or other really small event, take from
                // free pool.
                //
                pQueuedEvent = m_FreeEvents.Alloc();
                cbEvent = sizeof(DMEVENT);

                Trace(2, "Queue [%02X %02X %02X %02X]\n",
                    pEvent->abEvent[0],
                    pEvent->abEvent[1],
                    pEvent->abEvent[2],
                    pEvent->abEvent[3]);
            }
            else
            {
                // SysEx or other long event, just allocate it
                //
                cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);
                pQueuedEvent = (QUEUED_EVENT*)new char[QUEUED_EVENT_SIZE(pEvent->cbEvent)];
            }

            if (pQueuedEvent)
            {

                CopyMemory(&pQueuedEvent->e, pEvent, cbEvent);

                // rtDelta is the absolute time of the event while it's in our queue
                //
                pQueuedEvent->e.rtDelta += rtStart;
                ThruEvent(&pQueuedEvent->e);

        
                if (m_ReadEvents.pFront)
                {
                    m_ReadEvents.pRear->pNext = pQueuedEvent;
                }
                else
                {
                    m_ReadEvents.pFront = pQueuedEvent;   
                }

                m_ReadEvents.pRear = pQueuedEvent;
                pQueuedEvent->pNext = NULL;
            }
            else
            {
                Trace(1, "InputWorker: Failed to allocate event; dropping\n");
            }        
            LeaveCriticalSection(&m_csEventQueues);
        }
    }    
    Trace(2, "Leave InputWorkerDataReady()\n");
}

void CDirectMusicEmulatePort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify 
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    // Note: legacy driver assures no running status
    //
    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        Trace(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        Trace(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        Trace(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }
    
    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        Trace(0, "Thru: buffer setup failed\n");
    }

    pEvent->rtDelta = 50000;
    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}

void CDirectMusicEmulatePort::MasterToSlave(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt -= m_lTimeOffset;
    }
}

void CDirectMusicEmulatePort::SlaveToMaster(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt += m_lTimeOffset;
    }
}

void CDirectMusicEmulatePort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);
        rtSlaveClock = ((ULONGLONG)timeGetTime()) * MS_TO_REFERENCE_TIME;
        if (FAILED(hr))
        {
            return;
        }


        drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;
        m_lTimeOffset -= drift / 100;
    }
}




/////////////////////////////////////////////////////////////////////
//
// CEmulateLatencyClock
//
// Latency clock for emulated ports, which is just a fixed offset from
// the DirectMusic master clock
//
CEmulateLatencyClock::CEmulateLatencyClock(IReferenceClock *pMasterClock) :
   m_cRef(1),
   m_pMasterClock(pMasterClock)
{
    pMasterClock->AddRef();
}

CEmulateLatencyClock::~CEmulateLatencyClock()
{
    Close();
}

STDMETHODIMP
CEmulateLatencyClock::QueryInterface(
    const IID &iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CEmulateLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEmulateLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CEmulateLatencyClock::GetTime(
    REFERENCE_TIME *pTime)
{
    REFERENCE_TIME rt;

    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    if (!m_pMasterClock)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
    
    HRESULT hr = m_pMasterClock->GetTime(&rt);

    rt += FIXED_LEGACY_LATENCY_OFFSET;          // Default : 10 ms
    *pTime = rt;
    
    return hr;
}

STDMETHODIMP
CEmulateLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP
CEmulateLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP
CEmulateLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}


void
CEmulateLatencyClock::Close()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }
}

static HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DMUS_E_DEVICE_IN_USE;

    case MIDIERR_BADOPENMODE:
        return DMUS_E_ALREADYOPEN;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\dmusic32.h ===
// Copyright (c) 1998 Microsoft Corporation
//
    //
//
#ifndef _DMUSIC32_
#define _DMUSIC32_

typedef HRESULT (*PORTENUMCB)(
    LPVOID pInstance,          // @parm Callback instance data
    DMUS_PORTCAPS &dmpc,                              
    PORTTYPE pt,                              
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The node ID of the device's synth node (unused for legacy)
    HKEY hkPortsRoot);         // @parm Where port information is stored in the registry


extern HRESULT EnumLegacyDevices(
    LPVOID pInstance,          // @parm Callback instance data
    PORTENUMCB cb);            // @parm Pointer to callback function

typedef HRESULT (__stdcall *PENUMLEGACYDEVICES)(
    LPVOID pInstance,          // @parm Callback instance data
    PORTENUMCB cb);            // @parm Pointer to callback function

extern HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    IDirectMusicPort **pPort);

typedef HRESULT (__stdcall *PCREATECDIRECTMUSICEMULATEPORT)(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    IDirectMusicPort **pPort);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\enumport.cpp ===
// Copyright (c) 1998 Microsoft Corporation
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <regstr.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"

#include "dmusic32.h"


// @globalv Registry location of legacy driver port definitions
const char cszPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\Ports";

// @mfunc:(INTERNAL) Update the port list with legacy devices enumerated via 
// the WinMM MIDI API.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
//
HRESULT EnumLegacyDevices(
    LPVOID pInstance,
    PORTENUMCB cb)                          
{
    MIDIOUTCAPS moc;
    MIDIINCAPS mic;
    int idxDev;
    int cDev;
    UINT cAdded;
    HRESULT hr;
    HKEY hkPortsRoot;
    DMUS_PORTCAPS dmpc;

    // Initialize caps with stuff that doesn't change
    //
    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);
    dmpc.dwMaxChannelGroups = 1;


    // Try to open the port registry key. We will continue even if this fails and use
    // non-persistent GUID's.
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE, cszPortsRoot, &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    cAdded = 0;
    
    // MIDI output devices
    //
    // Starts at -1 == MIDI mapper
    //
    cDev = (int)midiOutGetNumDevs();
    for (idxDev = -1; idxDev < cDev; ++idxDev)
    {
        if (midiOutGetDevCaps((UINT)idxDev, &moc, sizeof(moc)))
        {
            continue;
        }

        // NOTE: Since this DLL is only Win9x, we know that moc.szPname
        // is from midiOutGetDevCapsA
        //
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            moc.szPname,
            -1,
            dmpc.wszDescription,
            sizeof(dmpc.wszDescription));

        dmpc.dwClass = DMUS_PC_OUTPUTCLASS;
        dmpc.dwType  = DMUS_PORT_WINMM_DRIVER;
        dmpc.dwFlags = DMUS_PC_SHAREABLE;

        if (moc.wTechnology == MOD_MIDIPORT)
        {
            dmpc.dwFlags |= DMUS_PC_EXTERNAL;
        }
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,
                   -1,          
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    // MIDI input devices
    //
    // NOTE: Starts at 0, no input mapper
    //
    cDev = (int)midiInGetNumDevs();
    for (idxDev = 0; idxDev < cDev; ++idxDev)
    {
        if (midiInGetDevCaps((UINT)idxDev, &mic, sizeof(mic)))
        {
            continue;
        }
                   
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            mic.szPname,
            -1,
            dmpc.wszDescription,
            sizeof(dmpc.wszDescription));

        
        dmpc.dwClass = DMUS_PC_INPUTCLASS;
        dmpc.dwFlags = DMUS_PC_EXTERNAL;
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,        // PinID -1 flags as legacy device
                   -1,
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    return cAdded ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        Trace(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        Trace(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        Trace(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\basicmxf.h ===
/*  Base definition of MIDI Transform Filter object 

    05/06/98    Martin Puryear      Created this file

*/

#ifndef __BasicMXF_H__
#define __BasicMXF_H__

#include "MXF.h"
#include "AllocatorMXF.h"


class CBasicMXF : public CMXF
{
public:
    CBasicMXF(CAllocatorMXF *allocatorMXF);    //  must provide a default sink/source
    ~CBasicMXF(void);

    HRESULT ConnectOutput(CMXF *sinkMXF);
    HRESULT DisconnectOutput(CMXF *sinkMXF);

    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);

protected:
    HRESULT UnrollAndProcess(PDMUS_KERNEL_EVENT pDMKEvt);
    HRESULT DoProcessing(PDMUS_KERNEL_EVENT pDMKEvt);

protected:
    CMXF          *m_sinkMXF;
};

#endif  //  __BasicMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\basicmxf.cpp ===
/*  Base implementation of MIDI Transform Filter object

    05/06/98    Martin Puryear      Created this file

*/
#include "stdafx.h"
#include "BasicMXF.h"

CBasicMXF::CBasicMXF(CAllocatorMXF *allocatorMXF)
: CMXF(allocatorMXF)
{
    m_sinkMXF = NULL;
}

/*  Artfully remove this filter from the chain  */
CBasicMXF::~CBasicMXF(void)
{
    (void) DisconnectOutput(m_sinkMXF);
}

HRESULT CBasicMXF::ConnectOutput(CMXF *sinkMXF)
{
    if ((m_sinkMXF != NULL) || (sinkMXF == NULL))
    {
        return S_FALSE;
    }

    m_sinkMXF = sinkMXF;
    return S_OK;
}

HRESULT CBasicMXF::DisconnectOutput(CMXF *sinkMXF)
{
    if ((m_sinkMXF == sinkMXF) || (sinkMXF == NULL))
    {
        m_sinkMXF = NULL;
        return S_OK;
    }
    return S_FALSE;
}

//  Process and forward this message to the next filter in the chain.
HRESULT CBasicMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    if (m_sinkMXF)
    {
        (void) UnrollAndProcess(pDMKEvt);
        m_sinkMXF->PutMessage(pDMKEvt);
    }
    else
    {
        m_allocatorMXF->PutMessage(pDMKEvt);
    }
    return S_OK;
}

//  example --  transposes up by one semitone
HRESULT CBasicMXF::UnrollAndProcess(PDMUS_KERNEL_EVENT pDMKEvt)
{
    if (COMPLETE_EVT(pDMKEvt))
    {
        if (pDMKEvt->cbEvent <= sizeof(PBYTE))  //  short message
        {
            (void) DoProcessing(pDMKEvt);
        }
        else if (PACKAGE_EVT(pDMKEvt))          //  deal with packages
        {
            (void) UnrollAndProcess(pDMKEvt->uData.pPackageEvt);
        }
    }
    if (pDMKEvt->pNextEvt)                      //  deal with successors
    {
        (void) UnrollAndProcess(pDMKEvt->pNextEvt);
    }
    return S_OK;
}

HRESULT CBasicMXF::DoProcessing(PDMUS_KERNEL_EVENT pDMKEvt)
{
    if (  (pDMKEvt->uData.abData[0] & 0xE0 == 0x80)     //  if NoteOn/NoteOff
       || (pDMKEvt->uData.abData[0] & 0xF0 == 0xA0))    //  if After-Pressure
    {
        (pDMKEvt->uData.abData[1])++;                   //  increment the noteNum
        (pDMKEvt->uData.abData[1]) &= 0x7F;             //  rollover to 0 if too high
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\allocatormxf.cpp ===
/*  
    Base implementation of MIDI Transform Filter object for DMUS_KERNEL_EVENT struct allocation.

    05/08/98    Martin Puryear      Created this file

*/

#include "stdafx.h"
#include "AllocatorMXF.h"

//  create the pool
CAllocatorMXF::CAllocatorMXF(void)
: CMXF(NULL)
{
    PDMUS_KERNEL_EVENT  pDMKEvt;
    PDMUS_KERNEL_EVENT  pEvtList;

    m_numFreeMessages = 0;

//    pDMKEvt = (PDMUS_KERNEL_EVENT)ExAllocatePoolWithTag(
//                NonPagedPool,
//                sizeof(DMUS_KERNEL_EVENT),
//                ' FXM');    //  'MXF '
    pDMKEvt = new DMUS_KERNEL_EVENT;

    if (pDMKEvt)
    {
        pDMKEvt->cbEvent = 0;
        pDMKEvt->usFlags = 0;
        pDMKEvt->ulChannelGroup = 0;
        pDMKEvt->ullPresTime100Ns = 0;
        pDMKEvt->pNextEvt = NULL;
        pDMKEvt->uData.pbData = NULL;

        m_numFreeMessages++;
        
        m_pFreeList = pDMKEvt;
        pEvtList = pDMKEvt;
    }
    else
    {
        return;
    }
    
    while (pDMKEvt && m_numFreeMessages < kNumMsgsInFreePool)
    {
//        pDMKEvt = (PDMUS_KERNEL_EVENT)ExAllocatePoolWithTag(
//                            NonPagedPool,
//                            sizeof(DMUS_KERNEL_EVENT),
//                            ' FXM');    //  'MXF '
        pDMKEvt = new DMUS_KERNEL_EVENT;
        if (pDMKEvt)
        {
//            InitializeListHead(&(pDMKEvt->listEntry));
            pDMKEvt->cbEvent = 0;
            pDMKEvt->usFlags = 0;
            pDMKEvt->ulChannelGroup = 0;
            pDMKEvt->ullPresTime100Ns = 0;
            pDMKEvt->pNextEvt = NULL;
            pDMKEvt->uData.pbData = NULL;

            m_numFreeMessages++;

            pEvtList->pNextEvt = pDMKEvt;
            pEvtList = pDMKEvt;
        }
    }
}

CAllocatorMXF::~CAllocatorMXF(void)
{
    PDMUS_KERNEL_EVENT  pEvtList;
    //  destroy the pool
    while (m_pFreeList)
    {
        pEvtList = m_pFreeList->pNextEvt;
        m_pFreeList->pNextEvt = NULL;
        delete m_pFreeList;
        m_pFreeList = pEvtList;
    }
}

HRESULT CAllocatorMXF::GetMessage(PDMUS_KERNEL_EVENT *pDMKEvt)
{
    if (m_numFreeMessages > 0)
    {
        //  manufacture a message
        //  take it off the free list
        *pDMKEvt = m_pFreeList;
        m_pFreeList = m_pFreeList->pNextEvt;
        (*pDMKEvt)->pNextEvt = NULL;
        m_numFreeMessages--;
    }
    else
    {
        *pDMKEvt = NULL;
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//  dispose of a message list
HRESULT CAllocatorMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT  pEvtList;
    
    if (pDMKEvt->pNextEvt == NULL)
    {
        if (!(PACKAGE_EVT(pDMKEvt)))
        {
            pDMKEvt->ulChannelGroup = 0;
            pDMKEvt->ullPresTime100Ns = 0;
//        if (pDMKEvt->cbEvent > sizeof(PBYTE))
//        {
//            free(pDMKEvt->uData.pbData);
//        }
            pDMKEvt->uData.pbData = NULL;
            pDMKEvt->cbEvent = 0;
            pDMKEvt->usFlags = 0;
            pDMKEvt->pNextEvt = m_pFreeList;

            m_pFreeList = pDMKEvt;

            m_numFreeMessages++;
        }
        else
        {
            pEvtList = pDMKEvt->uData.pPackageEvt;
            pDMKEvt->uData.pPackageEvt = NULL;
            PutMessage(pDMKEvt);
            PutMessage(pEvtList);
        }
    }
    else
    {
        pEvtList = pDMKEvt->pNextEvt;
        pDMKEvt->pNextEvt = NULL;
        (void) PutMessage(pDMKEvt);
        (void) PutMessage(pEvtList);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmusic32\mmdevldr.h ===
/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 *  Copyright (c) 1994-1998 Microsoft Corporation
 *
 */

#ifdef _WIN32                                                           /* ;BeginInternal */
#define MMDEVLDR_IOCTL_GETVERSION           0
#define MMDEVLDR_IOCTL_LINPAGELOCK          1
#define MMDEVLDR_IOCTL_LINPAGEUNLOCK        2
#define MMDEVLDR_IOCTL_RING0THREADHANDLE    3
#define MMDEVLDR_IOCTL_QUEUEAPC             4
#define MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR   5
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
#define MMDEVLDR_IOCTL_PAGEALLOCATE         7
#define MMDEVLDR_IOCTL_PAGEFREE             8
#define MMDEVLDR_IOCTL_GETDEVICESTATUS      9

#define MM_DEVSTATUS_ERROR          0
#define MM_DEVSTATUS_STARTED        1
#define MM_DEVSTATUS_UNKNOWNPROB    2
#define MM_DEVSTATUS_DISABLED       3


typedef struct tagLOCKUNLOCKPARMS
{
    DWORD           dwStartPage;
    DWORD           dwPageCount;
    DWORD           fdwOperation;
}   LOCKUNLOCKPARMS;

typedef struct tagQUEUEAPCPARMS
{
    DWORD           fnCallback;
    DWORD           dwUser;
    DWORD           hRing0Thd;
}   QUEUEAPCPARMS;

typedef struct tagPAGEALLOCATEPARMS
{
    DWORD           dwFlags;
    DWORD           dwPageCount;
} PAGEALLOCATEPARMS;

typedef struct tagPAGEALLOCATERETURN
{
    VOID *          lpvBase;
    DWORD           hMem;
    DWORD           dwPageCount;
    DWORD           dwPhysBase;
} PAGEALLOCATERETURN;

#endif

#ifdef MMDEVLDR_VXD
#define MM_STOP         0
#define MM_START        1
#define MM_MMDEVLDR_UP  3
#define MM_REMOVE       4

#define CONFIG_QUERYSTART       0x01000

#define MAXLEN  256

typedef struct tagMMDEVNODE
{
   DEVNODE      dn ;
   DWORD        dwDevStatus ;
   VMMLIST      hlDrivers ;
   BOOL         IsWDMDriver ;

} MMDEVNODE, *PMMDEVNODE ;


typedef struct tagMMDRVNODE
{
   CMCONFIGHANDLER  pConfigHandler ;
   DWORD            dwRefData ;

} MMDRVNODE, *PMMDRVNODE ;

//
// macros
//

#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

#if defined(DEBUG_RETAIL) || defined(DEBUG)
#define DBG_TRACE(strings) {\
        _Debug_Printf_Service( "MMDEVLDR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");}
#ifdef DEBUG
#define DBG_ERROR(strings) {\
        _Debug_Printf_Service( "MMDEVLDR ERROR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");\
        {_asm   int     3}}
#else
#define DBG_ERROR(strings) {\
        _Debug_Printf_Service( "MMDEVLDR ERROR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");}
#endif
#else
   #define DBG_TRACE(strings)
   #define DBG_ERROR(strings)
#endif

#ifdef DEBUG
#define DPF( strings ) _Debug_Printf_Service##strings;

void __cdecl _my_assert(void *, void *, unsigned);

#define ASSERT(exp) (void)( (exp) || (_my_assert(#exp, __FILE__, __LINE__), 0) )

#else

#define DPF( strings )
#define ASSERT( exp )

#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

//
// internal function prototypes
//

void MMDEVLDR_Call_MMSystem(DEVNODE dnDevNode, DWORD fLoad);
void MMDEVLDR_CheckForMMSystem(void);
DWORD StringLen(PCHAR psz);
PCHAR StringCopy(PCHAR pszDst, PCHAR pszSrc);
PCHAR StringCat(PCHAR pszDst, PCHAR pszSrc);

#pragma warning (disable:4035)          // turn off no return code warning
PSTR VXDINLINE Get_Environment_String
(
    PSTR            pszName
)
{
    _asm push esi
    _asm mov esi, pszName
    VMMCall( Get_Environment_String ) ;
    _asm mov   eax, edx
    _asm pop   esi
}
#pragma warning (default:4035)     // turn on no return code warning

BOOL _InitGlobalEnvironment() ;

VOID MMDEVLDR_SetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

BOOL MMDEVLDR_GetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue,
    UINT            uBufSize
) ;

VOID MMDEVLDR_RemoveEnvironmentString
(
    PSTR            pszName
) ;

VOID    MMDEVLDR_AddEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

#else                                                           /* ;EndInternal */


#define Multimedia_OEM_ID   0x0440      //            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10      //;MMDEVLDR's device ID

#ifdef Begin_Service_Table              // define only if vmm.h is included

#define MMDEVLDR_Service        Declare_Service
#pragma warning (disable:4003)          // turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service        (MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service        (MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS

#pragma warning (default:4003)          // turn on not enough params warning

#pragma warning (disable:4035)          // turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD           dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    Touch_Register(edx)
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)          // turn on no return code warning

#endif // Begin_Service_Table

#endif                  /* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\allocatormxf.h ===
/*  Base definition of MIDI Transform Filter object 

    05/08/98    Martin Puryear      Created this file

*/

#ifndef __AllocatorMXF_H__
#define __AllocatorMXF_H__

#include "MXF.h"


const int kNumMsgsInFreePool = 50;

class CAllocatorMXF : public CMXF
{
public:
    CAllocatorMXF(void);
    ~CAllocatorMXF(void);

    HRESULT GetMessage(PDMUS_KERNEL_EVENT *pDMKEvt);
    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);
    
    virtual HRESULT ConnectOutput(CMXF *)
    {   return S_FALSE;    };
    virtual HRESULT DisconnectOutput(CMXF *) 
    {   return S_FALSE;    };
    
private:
    short               m_numFreeMessages;
    PDMUS_KERNEL_EVENT  m_pFreeList;
};


#endif  //  __AllocatorMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\dmcoretest.h ===
// DMCoreTest.h : main header file for the DMCORETEST application
//

#if !defined(AFX_DMCORETEST_H__9A7470E5_D2F8_11D1_819E_0060083316C1__INCLUDED_)
#define AFX_DMCORETEST_H__9A7470E5_D2F8_11D1_819E_0060083316C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestApp:
// See DMCoreTest.cpp for the implementation of this class
//

class CDMCoreTestApp : public CWinApp
{
public:
	CDMCoreTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDMCoreTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDMCoreTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DMCORETEST_H__9A7470E5_D2F8_11D1_819E_0060083316C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\dmcoretest.cpp ===
// DMCoreTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "DMCoreTest.h"
#include "DMCoreTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestApp

BEGIN_MESSAGE_MAP(CDMCoreTestApp, CWinApp)
	//{{AFX_MSG_MAP(CDMCoreTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestApp construction

CDMCoreTestApp::CDMCoreTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDMCoreTestApp object

CDMCoreTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestApp initialization

BOOL CDMCoreTestApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CDMCoreTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\mxf.h ===
/*  Base definition of MIDI Transform Filter object 

    05/06/98    Martin Puryear      Created this file

*/

#ifndef __MXF_H__
#define __MXF_H__

//#include "wdm.h"

typedef unsigned __int64 ULONGLONG;
typedef struct _DMUS_KERNEL_EVENT
{
//    LIST_ENTRY  listEntry;
    USHORT      cbEvent;
    USHORT      usFlags;
    ULONG       ulChannelGroup;
    ULONGLONG   ullPresTime100Ns;
    _DMUS_KERNEL_EVENT *pNextEvt;
    union
    {
        BYTE    abData[sizeof(PBYTE)];
        PBYTE   pbData;
        _DMUS_KERNEL_EVENT *pPackageEvt;
    } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;

//------------------------------------------

#define DMUS_KEF_PACKAGE_EVENT          0x0001  //  This event is a package. The uData.pPackageEvt
                                                //  field contains a pointer to a chain of events.
#define DMUS_KEF_EVENT_INCOMPLETE       0x0002  //  This event is an incomplete package or sysex. 
                                                //  Do not use this data.
#define INCOMPLETE_EVT(evt) ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE)
#define COMPLETE_EVT(evt)   ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE == 0)
#define PACKAGE_EVT(evt)    ((evt)->usFlags & DMUS_KEF_PACKAGE_EVENT)

#pragma warning (disable : 4100)

class CAllocatorMXF;

class CMXF
{
public:
    CMXF(CAllocatorMXF *allocatorMXF) { m_allocatorMXF = allocatorMXF;};
    virtual ~CMXF(void) {};

    virtual HRESULT ConnectOutput(CMXF *sinkMXF) = 0;
    virtual HRESULT DisconnectOutput(CMXF *sinkMXF) = 0;

    virtual HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt) = 0;
protected:
    CAllocatorMXF *m_allocatorMXF;
};

#pragma warning (default : 4100)
#endif  //  __MXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\dmcoretestdlg.cpp ===
// DMCoreTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "DMCoreTest.h"
#include "DMCoreTestDlg.h"
#include "MXF.h"
#include "BasicMXF.h"
#include "AllocatorMXF.h"
#include "SplitterMXF.h"
#include "SequencerMXF.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestDlg dialog

CDMCoreTestDlg::CDMCoreTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDMCoreTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDMCoreTestDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDMCoreTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDMCoreTestDlg)
	DDX_Control(pDX, IDC_COMBO_MXF_TYPE, m_MXF_COMBO);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDMCoreTestDlg, CDialog)
	//{{AFX_MSG_MAP(CDMCoreTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_CONNECT, OnButtonConnect)
	ON_BN_CLICKED(IDC_BUTTON_PROCESS, OnButtonProcess)
	ON_BN_CLICKED(IDC_BUTTON_UNPACK, OnButtonUnpack)
	ON_BN_CLICKED(IDC_BUTTON_PACK, OnButtonPack)
	ON_BN_CLICKED(IDC_BUTTON1, OnSequence)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestDlg message handlers

BOOL CDMCoreTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDMCoreTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDMCoreTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDMCoreTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CDMCoreTestDlg::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

/*
typedef struct 
{
    ULONG cbEvent;
    ULONG ulChannelGroup;
    ULONGLONG ullPresTime100Ns;
    SINGLE_LIST_ENTRY sleEventList;
    union
    {
        PBYTE pbData;
        BYTE abData[sizeof(PBYTE)];
    } uActionData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;
*/

void CDMCoreTestDlg::OnButtonConnect() 
{
    CBasicMXF     *aSourceMXF,*aSource2MXF,*aSinkMXF;
    CSplitterMXF  *aSplitterMXF;
    CAllocatorMXF *allocatorMXF;
    PDMUS_KERNEL_EVENT  pDMKEvt;
    short count;

    for (ULONG count2 = 0;count2 < 10000; count2++)
    {
        allocatorMXF    = new CAllocatorMXF;
        aSourceMXF      = new CBasicMXF(allocatorMXF);
        aSource2MXF     = new CBasicMXF(allocatorMXF);
        aSinkMXF        = new CBasicMXF(allocatorMXF);

        aSplitterMXF    = new CSplitterMXF(allocatorMXF);

        aSourceMXF->ConnectOutput(aSplitterMXF);    //  tell src where to put
        aSplitterMXF->ConnectOutput(aSource2MXF);
        aSplitterMXF->ConnectOutput(aSinkMXF);
        aSource2MXF->ConnectOutput(aSinkMXF);   //  tell src2 where to put
        aSinkMXF->ConnectOutput(allocatorMXF);  //  tell snk where to put

        allocatorMXF->GetMessage(&pDMKEvt);
        pDMKEvt->cbEvent = 1;
        pDMKEvt->uData.abData[0] = (BYTE)count;

        aSourceMXF->PutMessage(pDMKEvt);

//      src
//       |
//     split
//       |  \
//       |   src2
//       |  /
//      sink
//       |
//  (allocator)

        aSplitterMXF->DisconnectOutput(aSource2MXF);
        aSplitterMXF->DisconnectOutput(aSinkMXF);
        aSplitterMXF->ConnectOutput(aSourceMXF);

        aSourceMXF->DisconnectOutput(aSplitterMXF);
        aSourceMXF->ConnectOutput(aSinkMXF);

//     split
//    /  |  \
// src   |   src2
//    \  |  /
//      sink
//       |
//  (allocator)

        allocatorMXF->GetMessage(&pDMKEvt);
        pDMKEvt->cbEvent = 4;
        pDMKEvt->pNextEvt = NULL;
        *(PULONG(pDMKEvt->uData.abData)) = 0xbeefbabe;

        aSplitterMXF->PutMessage(pDMKEvt);

    
        delete aSourceMXF;
        delete aSource2MXF;
        delete aSinkMXF;
        delete aSplitterMXF;
        delete allocatorMXF;
    }
}

void CDMCoreTestDlg::OnButtonProcess() 
{
    CBasicMXF     *aSourceMXF,*aSource2MXF,*aSinkMXF;
    CSplitterMXF  *aSplitterMXF;
    CAllocatorMXF *allocatorMXF;
    short count;
#define kNumMessages    3
    PDMUS_KERNEL_EVENT  pDMKEvt[kNumMessages];
    
    for (ULONG count2 = 0;count2 < 5000; count2++)
    {
        allocatorMXF    = new CAllocatorMXF;
        aSourceMXF      = new CBasicMXF(allocatorMXF);
        aSource2MXF     = new CBasicMXF(allocatorMXF);
        aSinkMXF        = new CBasicMXF(allocatorMXF);

        aSplitterMXF    = new CSplitterMXF(allocatorMXF);

        aSourceMXF->ConnectOutput(aSplitterMXF);    //  tell src where to put
        aSplitterMXF->ConnectOutput(aSource2MXF);
        aSplitterMXF->ConnectOutput(aSinkMXF);
        aSource2MXF->ConnectOutput(aSinkMXF);   //  tell src2 where to put
        aSinkMXF->ConnectOutput(allocatorMXF);  //  tell snk where to put

        allocatorMXF->GetMessage(&(pDMKEvt[0]));
        pDMKEvt[0]->uData.pbData = (unsigned char *)malloc(13);
        for (count = 0;count < 13;count++)
        {
            pDMKEvt[0]->cbEvent = 13;
            pDMKEvt[0]->uData.pbData[count] = (unsigned char)count;
        }
        for (count = 1; count < kNumMessages; count++)
        {
            allocatorMXF->GetMessage(&(pDMKEvt[count]));
            pDMKEvt[count]->cbEvent = 1;
            pDMKEvt[count]->uData.abData[0] = (BYTE)count;
        }
        pDMKEvt[1]->pNextEvt = pDMKEvt[0];

        aSourceMXF->PutMessage(pDMKEvt[1]);
        aSource2MXF->PutMessage(pDMKEvt[2]);

//      src
//       |
//     split
//       |  \
//       |   src2
//       |  /
//      sink
//       |
//  (allocator)

        aSplitterMXF->DisconnectOutput(aSource2MXF);
        aSplitterMXF->DisconnectOutput(aSinkMXF);
        aSplitterMXF->ConnectOutput(aSourceMXF);

        aSourceMXF->DisconnectOutput(aSplitterMXF);
        aSourceMXF->ConnectOutput(aSinkMXF);

//     split
//    /  |  \
// src   |   src2
//    \  |  /
//      sink
//       |
//  (allocator)

        allocatorMXF->GetMessage(&(pDMKEvt[0]));
        allocatorMXF->GetMessage(&(pDMKEvt[1]));

        pDMKEvt[0]->cbEvent = 1;
        pDMKEvt[1]->cbEvent = 4;

        pDMKEvt[0]->ulChannelGroup = 0x01234567;
        pDMKEvt[1]->ulChannelGroup = 0x89abcdef;
    
        pDMKEvt[0]->ullPresTime100Ns = (0xfedcba9876543210);
        pDMKEvt[1]->ullPresTime100Ns = (0x0123456789abcdef);
    
        pDMKEvt[0]->pNextEvt = NULL;
        pDMKEvt[1]->pNextEvt = pDMKEvt[0];
    
        pDMKEvt[0]->uData.abData[0] = 0xa5;
        *(PULONG(pDMKEvt[1]->uData.abData)) = 0xbeefbabe;

        aSplitterMXF->PutMessage(pDMKEvt[1]);

        delete aSourceMXF;
        delete aSource2MXF;
        delete aSinkMXF;
        delete aSplitterMXF;
        delete allocatorMXF;
    }
}

extern void TestUnpacker();
void CDMCoreTestDlg::OnButtonUnpack() 
{
	TestUnpacker();	
}

extern void TestPacker();
void CDMCoreTestDlg::OnButtonPack() 
{
	TestPacker();	
}

//extern void TestSequencer();
void CDMCoreTestDlg::OnSequence() 
{
//    TestSequencer();	
    CSequencerMXF *aSequencerMXF;
    CAllocatorMXF *allocatorMXF;

    short count;
#define kNumSeqMessages    5
    PDMUS_KERNEL_EVENT  pDMKEvt[kNumSeqMessages];
    
    allocatorMXF  = new CAllocatorMXF;
    aSequencerMXF = new CSequencerMXF(allocatorMXF);
    //  don't ConnectOutput -- Sequencer can feed to allocator

    short timeArray[5] = {1,0,0,3,2};

    for (count = 0; count < kNumSeqMessages; count++)
    {
        allocatorMXF->GetMessage(&(pDMKEvt[count]));
        pDMKEvt[count]->ullPresTime100Ns = (ULONGLONG)timeArray[count];
        aSequencerMXF->PutMessage(pDMKEvt[count]);
    }
    (void) aSequencerMXF->DisconnectOutput(allocatorMXF);

    delete aSequencerMXF;
    delete allocatorMXF;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\packermxf.h ===
/*  Base definition of MIDI event packer

    05/22/98    Jim Geist           Created this file

*/

#ifndef __PackerMXF_H__
#define __PackerMXF_H__

#include "MXF.h"
#include "AllocatorMXF.h"


class CIrp
{
public:
    LPBYTE              m_pbBuffer;
    DWORD               m_cbBuffer;
    DWORD               m_cbLeft;
    ULONGLONG           m_ullPresTime100Ns;
    CIrp               *m_pNext;

    virtual void Notify(void) = 0;
    virtual void Complete(HRESULT hr) = 0;
};

class CPackerMXF : public CMXF
{
public:
    CPackerMXF(CAllocatorMXF *allocatorMXF);
    virtual ~CPackerMXF();

    // CMXF interface
    //
    HRESULT ConnectOutput(CMXF *sinkMXF);
    HRESULT DisconnectOutput(CMXF *sinkMXF);

    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);

    // Upper edge interface
    //
    void SubmitIrp(CIrp *irp);

    // Subclass interface
    //
    virtual ULONG GetEventByteCount(ULONG ulBytesLeftInBuffer) = 0;
    virtual void  StartBuffer(ULONGLONG ullPresentationTime) = 0;
    virtual LPBYTE FillHeader(LPBYTE pbHeader, ULONGLONG ullPresentationTime, ULONG ulChannelGroup, ULONG cbEvent,
                              PULONG pcbTotalEvent) = 0;

private:
    CIrp                *m_irpHead;
    CIrp                *m_irpTail;
    PDMUS_KERNEL_EVENT  m_evtHead;
    PDMUS_KERNEL_EVENT  m_evtTail;
    ULONG               m_evtOffset;
    ULONGLONG           m_ullLastTime;

private:
    void ProcessQueues();
    HRESULT CompleteHeadIrp(HRESULT hr);
};

class CDMusPackerMXF : public CPackerMXF
{
public:
    CDMusPackerMXF(CAllocatorMXF *allocatorMXF);
    ~CDMusPackerMXF();

    ULONG GetEventByteCount(ULONG ulBytesLeftInBuffer);
    void  StartBuffer(ULONGLONG ullPresentationTime);
    LPBYTE FillHeader(LPBYTE pbHeader, ULONGLONG ullPresentationTime, ULONG ulChannelGroup, ULONG cbEvent, 
                      PULONG pcbTotalEvent);

private:
    ULONGLONG m_ullBufferBaseTime;
};

class CKsPackerMXF : public CPackerMXF
{
public:
    CKsPackerMXF(CAllocatorMXF *allocatorMXF);
    ~CKsPackerMXF();

    ULONG GetEventByteCount(ULONG ulBytesLeftInBuffer);
    void  StartBuffer(ULONGLONG ullPresentationTime);
    LPBYTE FillHeader(LPBYTE pbHeader, ULONGLONG ullPresentationTime, ULONG ulChannelGroup, ULONG cbEvent,
                      PULONG pcbTotalEvent);

private:
    ULONGLONG m_ullLastTime;
};

#endif // __PackerMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\pool.cpp ===
/*  Memory pool manager

    05/26/98    Jim Geist           Created this file

*/

#include "stdafx.h"
#include <assert.h>
#include "Pool.h"

// CMemoryPool::CMemoryPool
// 
CMemoryPool::CMemoryPool(ULONG cbObject, ULONG cbAllocationChunk, ULONG cAlignBits)
{
    if (!cbAllocationChunk)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        cbAllocationChunk = si.dwPageSize;
    }

    if (cbObject < sizeof(PoolNode))
    {
        cbObject = sizeof(PoolNode);
    }

    // XXX What is the alignment of memory returned by ExAllocatePoolTag? This stuff is only going
    // to be that good unless we really play games.
    //
    ULONG alignMask = (1 << cAlignBits) - 1;
    cbObject = (cbObject + alignMask) & ~alignMask;

    m_cbObject = cbObject;

    ULONG cbHeader = sizeof(PoolBlock);
    cbHeader = (cbHeader + alignMask) & ~alignMask;
    
    m_cbHeader = cbHeader; 
    
    for (;;)
    {
        m_nodesInBlock = (cbAllocationChunk - cbHeader) / cbObject;
        if (m_nodesInBlock >= 8)
        {
            break;
        }

        cbAllocationChunk *= 2;
    }

    //Trace("cbObject %d  cbAllocationChunk %d", cbObject, cbAllocationChunk);
    //    

    m_poolBlocks        = NULL;
    m_freeList          = NULL;
    m_freeNodes         = 0;
    m_freeLowWaterMark  = m_nodesInBlock / 10;
    if (m_freeLowWaterMark < 4)
    {
        m_freeLowWaterMark = 4;
    }

    Refill();
}

// CMemoryPool::~CMemoryPool
//
CMemoryPool::~CMemoryPool()
{
    while (m_poolBlocks)
    {
        PoolBlock *next = m_poolBlocks->next;

        // XXX ExAllocatePoolTag
        //
        delete[] m_poolBlocks;
        m_poolBlocks = next;
    }    
}

// CMemoryPool::Alloc
//
PVOID CMemoryPool::Alloc()
{
    if (m_freeNodes < m_freeLowWaterMark)
    {
        Refill(); 
    }

    PoolNode *pNew = m_freeList;
    if (pNew)
    {
        m_freeList = pNew->next;
        assert(m_freeNodes);
        m_freeNodes--;
    }

    return (PVOID)pNew;
}

// CMemoryPool::Free
//
void CMemoryPool::Free(PVOID pObject)
{
    PoolNode *pNode = (PoolNode*)pObject;

    pNode->next = m_freeList;
    m_freeList = pNode;
    m_freeNodes++;
}

// CMemoryPool::Refill
//
void CMemoryPool::Refill(void)
{
    // XXX Kernel check at passive level here
    //

    // XXX ExAllocatePoolTag
    //
    LPBYTE pbBlock = new BYTE[m_cbHeader + m_nodesInBlock * m_cbObject];

    if (!pbBlock)
    {
        return; 
    }

    // Link block into block chain so we can free it.
    //    
    PoolBlock *pBlock = (PoolBlock*)pbBlock;
    pBlock->next = m_poolBlocks;
    m_poolBlocks = pBlock;

    // Now walk the block and add nodes to the free list.
    //
    pbBlock += m_cbHeader;
    LPBYTE pbBlockEnd = pbBlock + (m_nodesInBlock - 1) * m_cbObject;

    PoolNode *pChainHead = (PoolNode*)pbBlock;    

    while (pbBlock != pbBlockEnd)
    {
        ((PoolNode*)pbBlock)->next = (PoolNode*)(pbBlock + m_cbObject);

        pbBlock += m_cbObject;
    }

    ((PoolNode*)pbBlock)->next = m_freeList;
    m_freeList = pChainHead;
    m_freeNodes += m_nodesInBlock;                
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\dmcoretestdlg.h ===
// DMCoreTestDlg.h : header file
//

#if !defined(AFX_DMCORETESTDLG_H__9A7470E7_D2F8_11D1_819E_0060083316C1__INCLUDED_)
#define AFX_DMCORETESTDLG_H__9A7470E7_D2F8_11D1_819E_0060083316C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDMCoreTestDlg dialog

class CDMCoreTestDlg : public CDialog
{
// Construction
public:
	CDMCoreTestDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDMCoreTestDlg)
	enum { IDD = IDD_DMCORETEST_DIALOG };
	CComboBox	m_MXF_COMBO;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDMCoreTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

    PVOID m_MXFGraph;

    // Generated message map functions
	//{{AFX_MSG(CDMCoreTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	afx_msg void OnButtonConnect();
	afx_msg void OnButtonProcess();
	afx_msg void OnButtonUnpack();
	afx_msg void OnButtonPack();
	afx_msg void OnSequence();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DMCORETESTDLG_H__9A7470E7_D2F8_11D1_819E_0060083316C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\packermxf.cpp ===
/*  Base implementation of MIDI event packer

    05/22/98    Jim Geist           Created this file

*/

#include "stdafx.h"
#include <assert.h>
#include "PackerMXF.h"
#include "Ks.h"
#include "KsMedia.h"

// Alignment macros
//
#define DWORD_ALIGN(x) (((x) + 3) & ~3)     // Pad to next DWORD
#define DWORD_TRUNC(x) ((x) & ~3)           // Trunc to DWORD's that will fit
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define QWORD_TRUNC(x) ((x) & ~7)


///////////////////////////////////////////////////////////////////////
//
// CPackerMXF
//
// Code which is common to all packers
//

// CPackerMXF::CPackerMXF
//
// XXX Might want one m_evtNodePool per PortClass, not per graph instance.
//
CPackerMXF::CPackerMXF(CAllocatorMXF *allocatorMXF) 
    : CMXF(allocatorMXF)

{
    m_irpHead       = NULL;
    m_irpTail       = NULL;
    m_evtHead       = NULL;
    m_evtTail       = NULL;
    m_ullLastTime   = 0;
}

// CPackerMXF::~CPackerMXF
//
CPackerMXF::~CPackerMXF()
{
}

// CPackerMXF::ConnectOutput
//
// Fail; this filter is an MXF sink only
//
HRESULT CPackerMXF::ConnectOutput(CMXF *)
{
    return E_FAIL;
}

// CPackerMXF::DisconnectOutput
//
// Fail; this filter is an MXF sink only
//
HRESULT CPackerMXF::DisconnectOutput(CMXF *)
{
    return E_FAIL;
}

// CPackerMXF::SubmitIrp
//
void CPackerMXF::SubmitIrp(CIrp *irp)
{
    // Reject out of hand IRP's that would be too small. This avoids
    // having to wade through them during queue processing.
    //
    if (GetEventByteCount(irp->m_cbBuffer) < sizeof(DWORD))
    {
        irp->Complete(E_OUTOFMEMORY);
        return;
    }

    // Queue the IRP at the tail so they stay queued for a minimum of time
    // 
    irp->m_cbLeft = irp->m_cbBuffer;
    irp->m_ullPresTime100Ns = 0;
    irp->m_pNext = NULL;

    if (m_irpHead)
    {
        assert(m_irpTail);
        m_irpTail->m_pNext  = irp;
    }
    else
    {
        m_irpHead = irp;
    }
    m_irpTail = irp;

    if (m_evtHead)
    {
        // Waiting to send up some pending events
        //
        ProcessQueues();
    }
}

// CPackerMXF::PutMessage
//
// Call the appropriate translate function with a buffer to pack
//
HRESULT CPackerMXF::PutMessage(PDMUS_KERNEL_EVENT pevtHead)
{
    PDMUS_KERNEL_EVENT pevtTail;

    // If the sysex chain bit is set, then the next pointer points
    // to a hypothetical next buffer which hasn't been filled in yet.
    // In this case, just link this node at the tail of the queue.
    // Otherwise the next pointers could form a chain of events
    // to queue.
    //
    pevtTail = pevtHead;
    if (COMPLETE_EVT(pevtHead))
    {
        while (pevtTail->pNextEvt)
        {
            pevtTail = pevtTail->pNextEvt;
        }
    }

    pevtTail->pNextEvt = NULL;
    
    if (m_evtHead)
    {
        // Event queue not empty
        //
        assert(m_evtTail);

        m_evtTail->pNextEvt = pevtHead;
        m_evtTail = pevtHead;

        // Already waiting on an IRP to fill or queue would be empty, so 
        // don't bother trying to process
        //
    }
    else
    {
        // Event queue empty
        //
        m_evtHead   = pevtHead;
        m_evtTail   = pevtHead;
        m_evtOffset = 0;            

        ProcessQueues();
    }

    return S_OK;
}

// CPackerMXF::ProcessQueues
//
void CPackerMXF::ProcessQueues()
{
    ULONG cbEventBytes;
    ULONG cbToCopy;
    LPBYTE pbSource;
    LPBYTE pbDest;

    while (m_irpHead && m_evtHead)
    {
        CIrp *pirp = m_irpHead;

        cbEventBytes = GetEventByteCount(pirp->m_cbLeft);
        assert(cbEventBytes >= sizeof(DWORD));
        assert(m_evtOffset < m_evtHead->cbEvent);

        cbToCopy = m_evtHead->cbEvent - m_evtOffset;
        if (cbToCopy > cbEventBytes)
        {
            cbToCopy = cbEventBytes;
        }

        pbSource = &m_evtHead->uData.abData[0];
        if (m_evtHead->cbEvent > sizeof(PBYTE))
        {
            pbSource = m_evtHead->uData.pbData;
        }

        if (pirp->m_cbLeft == pirp->m_cbBuffer)
        {
            // Irp is empty, start a new buffer
            //
            StartBuffer(m_evtHead->ullPresTime100Ns);
            pirp->m_ullPresTime100Ns = m_evtHead->ullPresTime100Ns;
        }
        else if (m_evtHead->ullPresTime100Ns < m_ullLastTime)
        {
            // Event before we started this irp. This is illegal for KSMUSICFORMAT
            //
            // Flush it and start with the next one
            //
            CompleteHeadIrp(S_OK);
            continue;
        }

        m_ullLastTime = m_evtHead->ullPresTime100Ns;

        ULONG cbTotalEvent;
        pbDest = FillHeader(pirp->m_pbBuffer + pirp->m_cbBuffer - pirp->m_cbLeft, 
                            m_evtHead->ullPresTime100Ns, 
                            m_evtHead->ulChannelGroup, 
                            cbToCopy,
                            &cbTotalEvent);

        /*Rtl*/CopyMemory(pbDest, pbSource + m_evtOffset, cbToCopy);

        assert(cbTotalEvent <= pirp->m_cbLeft);
        pirp->m_cbLeft -= cbTotalEvent;

        if (GetEventByteCount(pirp->m_cbLeft) < sizeof(DWORD))
        {
            CompleteHeadIrp(S_OK);
        }
    
        m_evtOffset += cbToCopy;
        assert(m_evtOffset <= m_evtHead->cbEvent);

        if (m_evtOffset == m_evtHead->cbEvent)
        {
            PDMUS_KERNEL_EVENT pEvent = m_evtHead;
            m_evtHead = pEvent->pNextEvt;

            m_allocatorMXF->PutMessage(pEvent);
        }
    }
}

// CPackerMXF::CompleteHeadIrp 
//
HRESULT CPackerMXF::CompleteHeadIrp(HRESULT hr)
{
    CIrp *irp = m_irpHead;

    m_irpHead = irp->m_pNext;
    if (m_irpHead == NULL)
    {
        m_irpTail = NULL;
    }

    irp->Complete(hr);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////
//
// CDMusPackerMXF
//
// Code to pack into DirectMusic buffer format
//

// CDMusPackerMXF::CDMusPackerMXF
//
CDMusPackerMXF::CDMusPackerMXF(CAllocatorMXF *allocatorMXF) 
    : CPackerMXF(allocatorMXF)
{
    m_ullBufferBaseTime = 0;
}

// CDMusPackerMXF::~CDMusPackerMXF
//
CDMusPackerMXF::~CDMusPackerMXF()
{
}

// CDMusPackerMXF::Translate
//

// DirectMusic event as packed by IDirectMusic
//
struct DMEVENT 
{
    DWORD               cbEvent;                // Unrounded number of event bytes 
    DWORD               dwChannelGroup;         // This field determines which channel group 
                                                // (set of 16 MIDI channels) receives the event. 
    ULONGLONG           rtDelta;                // Offset from buffer header in 100 ns units 
    BYTE                abEvent[4];             // Actual event data, rounded up to be an even number 
                                                // of QWORD's (8 bytes) 
};

#define DMEVENT_SIZE(cbData)    (QWORD_ALIGN(sizeof(DMEVENT) + (cbData) - 4))


// CDMusPackerMXF::GetEventByteCount
//
ULONG CDMusPackerMXF::GetEventByteCount(ULONG ulBytesLeftInBuffer)
{
    ulBytesLeftInBuffer = QWORD_TRUNC(ulBytesLeftInBuffer);

    if (ulBytesLeftInBuffer < offsetof(DMEVENT, abEvent))
    {
        return 0;
    }

    return ulBytesLeftInBuffer - offsetof(DMEVENT, abEvent);
}

// CDMusPackerMXF::StartBuffer
//
void CDMusPackerMXF::StartBuffer(ULONGLONG ullPresentationTime)
{
    m_ullBufferBaseTime = ullPresentationTime;
}

// CDMusPackerMXF::FillHeader
//
LPBYTE CDMusPackerMXF::FillHeader(LPBYTE pbHeader, ULONGLONG ullPresentationTime, ULONG ulChannelGroup, ULONG cbEvent,
                                  PULONG pcbTotalEvent)
{
    DMEVENT *pEvent = (DMEVENT*)pbHeader;

    pEvent->cbEvent           = cbEvent;
    pEvent->dwChannelGroup    = ulChannelGroup;

    assert(ullPresentationTime >= m_ullBufferBaseTime);
    pEvent->rtDelta           = ullPresentationTime - m_ullBufferBaseTime;

    *pcbTotalEvent = offsetof(DMEVENT, abEvent) + QWORD_ALIGN(cbEvent);       

    return (LPBYTE)&pEvent->abEvent[0];
}

///////////////////////////////////////////////////////////////////////
//
// CKsPackerMXF
//
// Code to pack into KSMUSICFORMAT
//

// CKsPackerMXF::CKsPackerMXF
//
CKsPackerMXF::CKsPackerMXF(CAllocatorMXF *allocatorMXF) 
    : CPackerMXF(allocatorMXF)
{
    m_ullLastTime = 0;
}

// CKsPackerMXF::~CKsPackerMXF
//
CKsPackerMXF::~CKsPackerMXF()
{
}

// CKsPackerMXF::GetEventByteCount
//
ULONG CKsPackerMXF::GetEventByteCount(ULONG ulBytesLeftInBuffer)
{
    ulBytesLeftInBuffer = DWORD_TRUNC(ulBytesLeftInBuffer);

    if (ulBytesLeftInBuffer < sizeof(KSMUSICFORMAT))
    {
        return 0;
    }

    return ulBytesLeftInBuffer - sizeof(KSMUSICFORMAT);
}

// CKsPackerMXF::StartBuffer
//
void CKsPackerMXF::StartBuffer(ULONGLONG ullPresentationTime)
{
    m_ullLastTime = ullPresentationTime;
}

// CKsPackerMXF::FillHeader
//
LPBYTE CKsPackerMXF::FillHeader(LPBYTE pbHeader, ULONGLONG ullPresentationTime, ULONG ulChannelGroup, ULONG cbEvent,
                                PULONG pcbTotalEvent)
{
    assert(ulChannelGroup <= 1);

    KSMUSICFORMAT *pEvent = (KSMUSICFORMAT*)pbHeader;

    assert(ullPresentationTime >= m_ullLastTime);

    pEvent->TimeDeltaMs         = (DWORD)((ullPresentationTime - m_ullLastTime) / 10000);
    m_ullLastTime = ullPresentationTime;
    pEvent->ByteCount           = cbEvent;

    *pcbTotalEvent = sizeof(KSMUSICFORMAT) + DWORD_ALIGN(cbEvent);

    return (LPBYTE)(pEvent + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\ksmiditest.cpp ===
#include <stdio.h>
#include "stdafx.h"
#include "AllocatorMXF.h"
#include "MXF.h"
#include "UnpackerMXF.h"
#include "PackerMXF.h"
#include "Ks.h"
#include "KsMedia.h"

void HexDump(FILE *fout, LPBYTE pbData, ULONG cbData);

// Some data in KSMUSICFORMAT
//
static BYTE abKSMusicData[] =
{
    // Delta time             Length                    Message
    0x00, 0x00, 0x00, 0x00,   0x02, 0x00, 0x00, 0x00,   0xC0, 0x02, 0x00, 0x00,     // C0 02 patch change
    
    0x01, 0x00, 0x00, 0x00,   0x01, 0x00, 0x00, 0x00,   0x05, 0x00, 0x00, 0x00,     // xx 05 patch change, running status

    0x01, 0x00, 0x00, 0x00,   0x04, 0x00, 0x00, 0x00,   0x90, 0xFE, 0x50, 0x7F,     // Note on, active sense

    0x01, 0x00, 0x00, 0x00,   0x03, 0x00, 0x00, 0x00,   0xFE, 0x53, 0x7F, 0x00,     // Note on, active sense, running status

    0x01, 0x00, 0x00, 0x00,   0x01, 0x00, 0x00, 0x00,   0x80, 0x00, 0x00, 0x00,     // Note off, split across packets
    0x01, 0x00, 0x00, 0x00,   0x02, 0x00, 0x00, 0x00,   0x50, 0x7F, 0x00, 0x00,

    0x01, 0x00, 0x00, 0x00,   0x07, 0x00, 0x00, 0x00,   0xF0, 0x00, 0x00, 0x41,     // Complete SysEx   
                                                        0x00, 0x5F, 0xF7, 0x00,

    
    0x01, 0x00, 0x00, 0x00,   0x04, 0x00, 0x00, 0x00,   0xF0, 0x00, 0x00, 0x41,     // SysEx across packets
    0x01, 0x00, 0x00, 0x00,   0x03, 0x00, 0x00, 0x00,   0x00, 0x5F, 0xF7, 0x00,

    0x01, 0x00, 0x00, 0x00,   0x04, 0x00, 0x00, 0x00,   0xF0, 0x00, 0x00, 0x41,     // Incomplete SysEx

    0x01, 0x00, 0x00, 0x00,   0x03, 0x00, 0x00, 0x00,   0x80, 0x53, 0x7F, 0x00,     // Note off


    0x01, 0x00, 0x00, 0x00,   0x08, 0x00, 0x00, 0x00,   0xF0, 0x00, 0x00, 0x41,     // Complete SysEx w/ active sense
                                                        0xFE, 0x00, 0x5F, 0xF7,
};


class CSinkMXF : public CMXF
{
public:
    CSinkMXF(CAllocatorMXF *allocatorMXF);
    ~CSinkMXF(void);

    HRESULT ConnectOutput(CMXF *sinkMXF);
    HRESULT DisconnectOutput(CMXF *sinkMXF);

    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);

private:
    FILE *m_fout;
    PDMUS_KERNEL_EVENT m_expectedEvent;

};

CSinkMXF::CSinkMXF(CAllocatorMXF *allocatorMXF) 
    : CMXF(allocatorMXF)
{
    m_fout = fopen("c:\\ksmtest.log", "w");
    m_expectedEvent = NULL;
}

CSinkMXF::~CSinkMXF()
{
    if (m_expectedEvent)
    {
        fprintf(m_fout, "\nNever received last expected event\n");
    }

    fclose(m_fout);
}

HRESULT CSinkMXF::ConnectOutput(CMXF *)
{
    return E_FAIL;
}

HRESULT CSinkMXF::DisconnectOutput(CMXF *)
{
    return E_FAIL;
}

HRESULT CSinkMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKevt)
{
    fprintf(m_fout, 
            "Sink: Event at 0x%08X%08X ",
            (DWORD)((pDMKevt->ullPresTime100Ns >> 32) & 0xFFFFFFFF),
            (DWORD)(pDMKevt->ullPresTime100Ns & 0xFFFFFFFF));

    BOOL fNextPiece = (BOOL)(pDMKevt == m_expectedEvent);
    if (fNextPiece)
    {
        m_expectedEvent = NULL;
    }
    fprintf(m_fout, "\n");

    fprintf(m_fout,"      Length %5u Channel Group %5u %c%c%c\n",
            (unsigned)pDMKevt->cbEvent, 
            pDMKevt->ulChannelGroup,
            fNextPiece ? 'N' : 'n',
            (INCOMPLETE_EVT(pDMKevt)) ? 'C' : 'c',
            pDMKevt->pNextEvt ? 'P' : 'p');
    fprintf(m_fout, "\n");

    if (INCOMPLETE_EVT(pDMKevt))
    {
        if (m_expectedEvent)
        {
            fprintf(m_fout, "NOTE: Received new expected event without completion of the last\n");
        }

        m_expectedEvent = pDMKevt->pNextEvt;
        if (m_expectedEvent == NULL)
        {
            fprintf(m_fout, "NOTE: Continued bit set but next pointer NULL\n");
        }
    }

    LPBYTE pbData = pDMKevt->cbEvent > sizeof(PBYTE) ? pDMKevt->uData.pbData : &pDMKevt->uData.abData[0];

    HexDump(m_fout, pbData, pDMKevt->cbEvent);

    return S_OK;
}

class CWyatt : public CIrp
{
public:
    CWyatt(ULONG ulBufferSize, void (*)(CWyatt*), FILE *);
    ~CWyatt();
    void Notify(void);
    void Complete(HRESULT hr);

private:
    void (*m_AppComplete)(CWyatt *);
    FILE *m_fout;
};

CWyatt::CWyatt(ULONG ulBufferSize, void (*AppComplete)(CWyatt*), FILE *fout)
{
    m_pbBuffer          = new BYTE[ulBufferSize];
    m_cbBuffer          = ulBufferSize;
    m_cbLeft            = ulBufferSize;
    m_ullPresTime100Ns  = 0;
    m_pNext             = NULL;
    m_AppComplete       = AppComplete;
    m_fout              = fout;
}

CWyatt::~CWyatt()
{
    if (m_pbBuffer)
    {
        delete[] m_pbBuffer;
    }
}

void CWyatt::Notify()
{
    fprintf(m_fout, "IRP %08X: Notify. cbBuffer %u; used %d\n", 
        (DWORD)this,
        m_cbBuffer,
        m_cbBuffer - m_cbLeft);
}

void CWyatt::Complete(HRESULT hr)
{
    fprintf(m_fout, "IRP %08p: Completed with hr %08x\n", this, hr);
    (*m_AppComplete)(this);
}

void TestUnpacker()
{
    CAllocatorMXF *allocatorMXF = new CAllocatorMXF;
    CKsUnpackerMXF *unpackerMXF = new CKsUnpackerMXF(allocatorMXF);
    CSinkMXF *sinkMXF = new CSinkMXF(allocatorMXF);

    HRESULT hr = unpackerMXF->ConnectOutput(sinkMXF);
   
    if (SUCCEEDED(hr))
    {
        unpackerMXF->SinkIRP(abKSMusicData, sizeof(abKSMusicData), 0);
            
        // Build a SysEx IRP that's big enought for a forced split
        //
        SYSTEM_INFO si;
        GetSystemInfo(&si);

        ULONG cbData = 2 * si.dwPageSize + 5;
        cbData = (cbData + 3) & ~3;

        PKSMUSICFORMAT pksmf = (PKSMUSICFORMAT)new BYTE[sizeof(KSMUSICFORMAT) + cbData];

        pksmf->TimeDeltaMs  = 0;
        pksmf->ByteCount    = cbData;

        LPBYTE pbData = (LPBYTE)(pksmf + 1);
        pbData[0] = 0xF0;
        pbData[1] = 0x00;
        pbData[2] = 0x00;
        pbData[3] = 0x41;
        pbData[cbData - 1] = 0xF7;

        BYTE bData = 0;
        for (ULONG idx = 4; idx < cbData - 1; idx++)
        {
            pbData[idx] = bData;
            bData = (BYTE)((bData + 1) & 0x7F);
        }

        unpackerMXF->SinkIRP((LPBYTE)pksmf, sizeof(KSMUSICFORMAT) + cbData, 0);

        delete[] ((LPBYTE)pksmf);

        unpackerMXF->DisconnectOutput(sinkMXF);
    }

    delete sinkMXF;
    delete unpackerMXF;
    delete allocatorMXF;
}

CIrp *pIrpCompleteHead;
CIrp *pIrpCompleteTail;

void TestPackerIrpComplete(CWyatt *pirp)
{
    if (pIrpCompleteHead)
    {
        pIrpCompleteTail->m_pNext = pirp;
        pIrpCompleteTail = pirp;
    }
    else
    {
        pIrpCompleteHead = pirp;
        pIrpCompleteTail = pirp;
    }

    pirp->m_pNext = NULL;
}

void TestPacker()
{
    FILE *fout = fopen("c:\\ksmtest.log", "w");

    CAllocatorMXF *allocatorMXF = new CAllocatorMXF;
    CKsUnpackerMXF *unpackerMXF = new CKsUnpackerMXF(allocatorMXF);
    CPackerMXF *packerMXF = new CDMusPackerMXF(allocatorMXF);

    HRESULT hr = unpackerMXF->ConnectOutput(packerMXF);

    for (int cirp = 0; cirp < 32; cirp++)
    {
        CWyatt *pirp = new CWyatt(64, TestPackerIrpComplete, fout);
        packerMXF->SubmitIrp(pirp);
    }

    pIrpCompleteHead = NULL;
    pIrpCompleteTail = NULL;
   
    if (SUCCEEDED(hr))
    {
        unpackerMXF->SinkIRP(abKSMusicData, sizeof(abKSMusicData), 0);
            
        // Build a SysEx IRP that's big enought for a forced split
        //
        SYSTEM_INFO si;
        GetSystemInfo(&si);

        ULONG cbData = 2 * si.dwPageSize + 5;
        cbData = (cbData + 3) & ~3;

        PKSMUSICFORMAT pksmf = (PKSMUSICFORMAT)new BYTE[sizeof(KSMUSICFORMAT) + cbData];

        pksmf->TimeDeltaMs  = 0;
        pksmf->ByteCount    = cbData;

        LPBYTE pbData = (LPBYTE)(pksmf + 1);
        pbData[0] = 0xF0;
        pbData[1] = 0x00;
        pbData[2] = 0x00;
        pbData[3] = 0x41;
        pbData[cbData - 1] = 0xF7;

        BYTE bData = 0;
        for (ULONG idx = 4; idx < cbData - 1; idx++)
        {
            pbData[idx] = bData;
            bData = (BYTE)((bData + 1) & 0x7F);
        }

        unpackerMXF->SinkIRP((LPBYTE)pksmf, sizeof(KSMUSICFORMAT) + cbData, 0);

        delete[] ((LPBYTE)pksmf);

        unpackerMXF->DisconnectOutput(packerMXF);
    }

    while (pIrpCompleteHead)
    {
        CIrp *pirp = pIrpCompleteHead;
        pIrpCompleteHead = pirp->m_pNext;

        fprintf(fout, "IRP: %08p  ", pirp);
        fprintf(fout, "%I64X\n",  (__int64)pirp->m_ullPresTime100Ns);
        HexDump(fout, pirp->m_pbBuffer, pirp->m_cbBuffer - pirp->m_cbLeft);
    }   

    delete packerMXF;
    delete unpackerMXF;
    delete allocatorMXF;

    fclose(fout);
}

void HexDump(FILE *fout, LPBYTE pbData, ULONG cbData)
{
    for (ULONG idxLine = 0; idxLine < cbData; idxLine += 16)
    {
        ULONG cbThisLine = cbData - idxLine;
        if (cbThisLine > 16) 
            cbThisLine = 16;

        fprintf(fout, "       ");
        for (ULONG idxByte = 0; idxByte < cbThisLine; idxByte++)
            fprintf(fout, "%02X ", *pbData++);
        fprintf(fout, "\n");
    }
    fprintf(fout, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\pool.h ===
/*  Memory pool manager

    05/26/98    Jim Geist           Created this file

*/

#ifndef __Pool_H__
#define __Pool_H__

class CMemoryPool
{
public:
    CMemoryPool(ULONG cbObject, ULONG cbAllocationChunk = 0, ULONG cAlignBits = 0);
    ~CMemoryPool();

    PVOID Alloc();
    void  Free(PVOID pObject);

private:
    
    struct PoolNode
    {
        PoolNode        *next;
    };

    struct PoolBlock
    {
        PoolBlock       *next;
    };

    ULONG               m_cbObject;
    ULONG               m_cbHeader;
    ULONG               m_nodesInBlock;

    PoolBlock          *m_poolBlocks;
    PoolNode           *m_freeList;
    ULONG               m_freeNodes;
    ULONG               m_freeLowWaterMark;

private:
    void Refill();
};

#endif // __Pool_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DMCoreTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DMCORETEST_DIALOG           102
#define IDR_MAINFRAME                   128
#define IDC_CURSOR1                     129
#define IDC_BUTTON_CONNECT              1001
#define IDC_COMBO_MXF_TYPE              1002
#define IDC_BUTTON_PROCESS              1003
#define IDC_BUTTON_UNPACK               1004
#define IDC_BUTTON_PACK                 1005
#define IDC_BUTTON1                     1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\sequencermxf.h ===
/*  Base definition of MIDI Transform Filter object 

    05/06/98    Martin Puryear      Created this file

*/

#ifndef __SequencerMXF_H__
#define __SequencerMXF_H__

#include "MXF.h"
#include "AllocatorMXF.h"


class CSequencerMXF : public CMXF
{
public:
    CSequencerMXF(CAllocatorMXF *allocatorMXF);    //  must provide a default sink/source
    ~CSequencerMXF(void);

    HRESULT ConnectOutput(CMXF *sinkMXF);
    HRESULT DisconnectOutput(CMXF *sinkMXF);

    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);

protected:
    HRESULT InsertEvtIntoQueue(PDMUS_KERNEL_EVENT pDMKEvt);
    HRESULT ScheduleQueueEvents(void);

    CMXF                *m_sinkMXF;
    PDMUS_KERNEL_EVENT  m_evtQueue;
};

#endif  //  __SequencerMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\splittermxf.cpp ===
/*  Base implementation of MIDI Transform Filter object 

    05/10/98    Martin Puryear      Created this file

*/

#include "stdafx.h"
#include "SplitterMXF.h"

CSplitterMXF::CSplitterMXF(CAllocatorMXF *allocatorMXF)
: CMXF(allocatorMXF)
{
    short count;

    m_sinkMXFBitMap = 0;
    for (count = 0;count < kNumSinkMXFs;count++)
    {
        m_sinkMXF[count] = NULL;
    }
}

/*  Artfully remove this filter from the chain  */
CSplitterMXF::~CSplitterMXF(void)
{
}

HRESULT CSplitterMXF::ConnectOutput(CMXF *sinkMXF)
{
    DWORD   bitmap;
    short   count;

    if (m_sinkMXFBitMap == 0xFFFFFFFF)
        return S_FALSE;
    
    bitmap = m_sinkMXFBitMap;
    count = 0;
    
    for (count = 0;count < kNumSinkMXFs;count++)
    {
        if ((bitmap & 1) == 0)
        {
            break;
        }
        bitmap >>= 1;
    }    
    m_sinkMXF[count] = sinkMXF;
    m_sinkMXFBitMap |= (1 << count);
    
    return S_OK;
}

HRESULT CSplitterMXF::DisconnectOutput(CMXF *sinkMXF)
{
    DWORD bitmap;
    
    if (m_sinkMXFBitMap == 0)
    {
        return S_FALSE;
    }
    
    bitmap = m_sinkMXFBitMap;
    for (short count = 0;count < kNumSinkMXFs;count++)
    {
        if ((bitmap & 1) && (m_sinkMXF[count] == sinkMXF))
        {
            m_sinkMXF[count] = NULL;
            m_sinkMXFBitMap &= ~(1 << count);
        }
        bitmap >>= 1;
    }
    return S_OK;
}

HRESULT CSplitterMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    DWORD               bitmap;
    PDMUS_KERNEL_EVENT  pDMKEvt2;

    if (m_sinkMXFBitMap)
    {
        bitmap = m_sinkMXFBitMap;
        for (short count = 0;count < kNumSinkMXFs;count++)
        {
            if (bitmap & 1)
            {
                pDMKEvt2 = MakeDMKEvtCopy(pDMKEvt);
                if (pDMKEvt2 != NULL)
                {
                    m_sinkMXF[count]->PutMessage(pDMKEvt2);
                }
            }
            bitmap >>= 1;
        }
    }
    m_allocatorMXF->PutMessage(pDMKEvt);

    return S_OK;
}

PDMUS_KERNEL_EVENT CSplitterMXF::MakeDMKEvtCopy(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT  pDMKEvt2;

    if (m_allocatorMXF != NULL)
    {
        m_allocatorMXF->GetMessage(&pDMKEvt2);
        if (pDMKEvt2 != NULL)
        {
            (void) memcpy(pDMKEvt2,pDMKEvt, sizeof(DMUS_KERNEL_EVENT));
            if (pDMKEvt->cbEvent > sizeof(PBYTE))
            {
//
//BUGBUG!!  This is a no-no at DPC time.  Do it with a pre-allocated pool.
//
//              pDMKEvt = (PDMUS_KERNEL_EVENT)ExAllocatePoolWithTag(
//                                    NonPagedPool,
//                                    pDMKEvt->cbEvent,
//                                    ' FXM');    //  'MXF '
                pDMKEvt2->uData.pbData = (unsigned char *)malloc(pDMKEvt->cbEvent);

                if (pDMKEvt2->uData.pbData)
                {
                    (void) memcpy(  pDMKEvt2->uData.pbData,
                                    pDMKEvt->uData.pbData,
                                    pDMKEvt->cbEvent);
                }
                else
                {
                    m_allocatorMXF->PutMessage(pDMKEvt2);
                    pDMKEvt2 = NULL;
                }
            }
            if (pDMKEvt->pNextEvt != NULL)
            {
                pDMKEvt2->pNextEvt = MakeDMKEvtCopy(pDMKEvt->pNextEvt);
            }
        }
    }
    else
    {
        pDMKEvt2 = NULL;
    }
    return pDMKEvt2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\splittermxf.h ===
/*  Base definition of MIDI Transform Filter object

    05/10/98    Martin Puryear      Created this file

*/

#ifndef __SplitterMXF_H__
#define __SplitterMXF_H__

#include "MXF.h"
#include "AllocatorMXF.h"


#define kNumSinkMXFs    32

class CSplitterMXF : public CMXF
{
public:
    CSplitterMXF(CAllocatorMXF *allocatorMXF);
    ~CSplitterMXF(void);

    HRESULT ConnectOutput(CMXF *sinkMXF);
    HRESULT DisconnectOutput(CMXF *sinkMXF);

    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);
    
private:
    PDMUS_KERNEL_EVENT  MakeDMKEvtCopy(PDMUS_KERNEL_EVENT pDMKEvt);

    CMXF           *m_sinkMXF[kNumSinkMXFs];
    DWORD           m_sinkMXFBitMap;
};

#endif  //  __SplitterMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DMCoreTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9A7470E9_D2F8_11D1_819E_0060083316C1__INCLUDED_)
#define AFX_STDAFX_H__9A7470E9_D2F8_11D1_819E_0060083316C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9A7470E9_D2F8_11D1_819E_0060083316C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\sequencermxf.cpp ===
/*  Base implementation of MIDI Transform Filter object

    05/06/98    Martin Puryear      Created this file

*/
#include "stdafx.h"
#include "SequencerMXF.h"

//  Must furnish an allocator.
//  Perhaps must furnish a clock as well?
CSequencerMXF::CSequencerMXF(CAllocatorMXF *allocatorMXF
                         //, CClockObject *clockObj
                             )
: CMXF(allocatorMXF)
{
    m_sinkMXF = NULL;
    m_evtQueue = NULL;
    //m_clock = clockObj;
}

//  Artfully remove this filter from the chain
CSequencerMXF::~CSequencerMXF(void)
{
    (void) DisconnectOutput(m_sinkMXF);

    if (m_evtQueue != NULL)
    {
        m_allocatorMXF->PutMessage(m_evtQueue);
    }
}

//  Furnish a sink.  The allocator is default (events are destroyed).
HRESULT CSequencerMXF::ConnectOutput(CMXF *sinkMXF)
{
    if ((m_sinkMXF != NULL) || (sinkMXF == NULL))
    {
        return S_FALSE;
    }

    m_sinkMXF = sinkMXF;
    return S_OK;
}

//  Pull the plug.  The sequencer should now put into the allocator.
HRESULT CSequencerMXF::DisconnectOutput(CMXF *sinkMXF)
{
    if ((m_sinkMXF == sinkMXF) || (sinkMXF == NULL))
    {
        m_sinkMXF = NULL;
        return S_OK;
    }
    return S_FALSE;
}

//  Receive event from above.  Insert in queue and check timer.
HRESULT CSequencerMXF::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    (void) InsertEvtIntoQueue(pDMKEvt);
    (void) ScheduleQueueEvents();
    
    return S_OK;
}

//  Maintain the sorted list, using only the forward 
//  links already in the DMUS)KERNEL_EVENT struct.
//
//  MGP-TODO
//  BUGBUG I haven't yet dealt with a) multi-part SysEx,
//  and b) passing in a chain of unsorted events.
HRESULT CSequencerMXF::InsertEvtIntoQueue(PDMUS_KERNEL_EVENT pDMKEvt)
{
    PDMUS_KERNEL_EVENT pEvt;
    
/*
    if (  (pDMKEvt->pNextEvt) 
       && (0 == (pDMKEvt->usFlags & DMUS_KEF_SYSEX_CONTINUED)))
    {
        pEvt = pDMKEvt->NextEvt;
        pDMKEvt->NextEvt = NULL;                        //  disconnect the first
        (void) InsertEvtIntoQueue(pDMKEvt);             //  queue it
        (void) InsertEvtIntoQueue(pDMKEvt->pNextEvt);   //  queue the rest
        return S_OK;
    }
*/
    if (!m_evtQueue)
    {
        m_evtQueue = pDMKEvt;
        return S_OK;
    }
    if (m_evtQueue->ullPresTime100Ns > pDMKEvt->ullPresTime100Ns)
    {
        pDMKEvt->pNextEvt = m_evtQueue;
        m_evtQueue = pDMKEvt;
        return S_OK;
    }

    //  go through each message in the queue looking at timestamps
    pEvt = m_evtQueue;
    while (pEvt->pNextEvt)
    {
        if (pEvt->pNextEvt->ullPresTime100Ns <= pDMKEvt->ullPresTime100Ns)
        {
            pEvt = pEvt->pNextEvt;
        }
        else
        {
            pDMKEvt->pNextEvt = pEvt->pNextEvt;
            pEvt->pNextEvt = pDMKEvt;
            return S_OK;
        }
    }
    pEvt->pNextEvt = pDMKEvt;
    return S_OK;
}

//  Get the current time and emit those messages whose time have come.
//  Make only one PutMessage with a sorted chain.
HRESULT CSequencerMXF::ScheduleQueueEvents(void)
{
    ULONGLONG   ullCurrentPresTime100ns;

//  MGP-TODO Get clock information
    //    ullCurrentPresTime100ns = GetCurrentTime100Ns();
    ullCurrentPresTime100ns = 0;

    //  if queue is not empty
    if (m_evtQueue)
    {
        if (m_evtQueue->ullPresTime100Ns <= ullCurrentPresTime100ns)
        //  if we are going to send down at least one event....
        {
            PDMUS_KERNEL_EVENT pEvt, pNewQueueHeadEvt;
            pEvt = m_evtQueue;
            //  figure out how many events are good to go
            while (pEvt->pNextEvt) 
            {
                if (pEvt->pNextEvt->ullPresTime100Ns <= ullCurrentPresTime100ns)
                {
                    pEvt = pEvt->pNextEvt;
                }
                else    
                    break;
            }
            //  send m_evtQueue, and set the new m_evtQueue to pEvt->pNextEvt
            //  so if the queue only had one item, m_evtQueue is set to NULL
            pNewQueueHeadEvt = pEvt->pNextEvt;
            pEvt->pNextEvt = NULL;
        
            if (m_sinkMXF)
            {
                m_sinkMXF->PutMessage(m_evtQueue);
            }
            else
            {
                m_allocatorMXF->PutMessage(m_evtQueue);
            }
            m_evtQueue = pNewQueueHeadEvt;
        }   //  if we sent at least one event
        
        //  MGP-TODO: if there's anything left in the queue, set up a timer DPC

    }   //  if queue is not empty
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\unpackermxf.h ===
/*  Base definition of MIDI event unpacker

    05/19/98    Jim Geist           Created this file

*/

#ifndef __UnpackerMXF_H__
#define __UnpackerMXF_H__

#include "MXF.h"
#include "AllocatorMXF.h"


class CUnpackerMXF : public CMXF
{
public:
    CUnpackerMXF(CAllocatorMXF *allocatorMXF);
    virtual ~CUnpackerMXF();

    HRESULT ConnectOutput(CMXF *sinkMXF);
    HRESULT DisconnectOutput(CMXF *sinkMXF);

    HRESULT PutMessage(PDMUS_KERNEL_EVENT pDMKEvt);

    // NOTE: All of these things will eventually be pulled out of the IRP
    //
    virtual HRESULT SinkIRP(LPBYTE bufferData, ULONG bufferSize, ULONGLONG ullBaseTime) = 0;

    // Common code for allocating and queueing an event
    //
    HRESULT QueueShortEvent(LPBYTE pbData, USHORT cbData, ULONGLONG ullPresTime, ULONG dwChannelGroup);
    HRESULT QueueSysEx(LPBYTE pbData, USHORT cbData, ULONGLONG ullPresTime, ULONG dwChannelGroup, BOOL fIsContinued);

    inline DWORD PageSize() const { return m_pageSize; }

    HRESULT UnpackEventBytes(ULONGLONG ullCurrenTime, ULONG ulChannelGroup, LPBYTE pbData, ULONG cbData);

private:
    CMXF                   *m_sinkMXF;
    DWORD                   m_pageSize;
    PDMUS_KERNEL_EVENT      m_nextSysExEvent;

    ULONGLONG               m_ullEventTime;
    BYTE                    m_bRunningStatus;

    enum
    {
        stateNone,
        stateInShortMsg,
        stateInSysEx
    }                       m_state;
    ULONG                   m_cbShortMsgLeft;
    BYTE                    m_abShortMsg[4];
    LPBYTE                  m_pbShortMsg;
};

class CDMusUnpackerMXF : public CUnpackerMXF
{
public:
    CDMusUnpackerMXF(CAllocatorMXF *allocatorMXF);
    ~CDMusUnpackerMXF();

    // NOTE: All of these things will eventually be pulled out of the IRP
    //
    HRESULT SinkIRP(LPBYTE bufferData, ULONG bufferSize, ULONGLONG ullBaseTime);
};

class CKsUnpackerMXF : public CUnpackerMXF
{
public:
    CKsUnpackerMXF(CAllocatorMXF *allocatorMXF);
    ~CKsUnpackerMXF();

    // NOTE: All of these things will eventually be pulled out of the IRP
    //
    HRESULT SinkIRP(LPBYTE bufferData, ULONG bufferSize, ULONGLONG ullBaseTime);
};
#endif // __UnpackerMXF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dsseqtest\dsswrapper.cpp ===
// Copyright Microsoft, Inc. All Rights Reserved.

#include "dsoundsequencer.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dsseqtest\dsstest.cpp ===
// Copyright Microsoft, Inc. All Rights Reserved.

#include "dsoundsequencer.h"

extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);

HRESULT ReportError(HRESULT hr,  const char *filename, int linenumber ){
	if ( FAILED(hr) ) {
		DbgPrint("%s(%d) : Failure 0x%08x\n", filename, linenumber, hr);
		__asm int 3
	}
	return hr;
}

#define REPORT(X) ReportError(X, __FILE__, __LINE__)

class SoundSource {
public:
    virtual ~SoundSource() {}
    virtual void GenerateData(LPVOID pData, DWORD lengthInBytes){}
};

// Converts a floating point value to a long.
static _declspec(naked) long FloatToLong(float f)
{
    _asm
    {
        // Note that this does a truncate, not a floor:

        cvttss2si eax, [esp+4]
        ret 4
    }
}

// Cosine.
static _declspec(naked) float Sin(float e)
{
    _asm
    {
        fld [esp+4]
        fsin
        ret 4
    }
}
// 44KHz stereo 16-bit samples

class ToneSource : public SoundSource{
public:
    void GenerateData(LPVOID pData, DWORD toneFreq, DWORD lengthInBytes, double volume){
        GenerateTone(0, toneFreq, 48000, 2, pData, lengthInBytes, volume);
    }
private:
    void
    GenerateTone
    (
        DWORD                   dwSampleBase,
        DWORD                   dwToneFrequency,
        DWORD                   dwPlaybackFrequency,
        DWORD                   dwChannels,
        LPVOID                  pvBuffer,
        DWORD                   dwBufferSize,
        double                  volume // 0.0 .. 1.0
    )
    {
        static const double     pi          = 3.1415926535;
        static const double     iscale      = 2.0 * pi / (double)(dwPlaybackFrequency - 2);
        static const double     datascale   = volume * 32767.0 / 1.0;
        const double             freq        = (float)dwToneFrequency;
        short *                 psBuffer    = (short *)pvBuffer;
        DWORD                   dwSamples   = dwBufferSize / dwChannels / 2;
        short                   sSample;
        DWORD                   a, b;

        for(a = 0; a < dwSamples; a++)
        {
            float phi = (float) (freq * (a + dwSampleBase) * iscale);
            sSample = (short) FloatToLong((float)(Sin(phi) * datascale));

            for(b = 0; b < dwChannels; b++)
            {
                psBuffer[a * dwChannels + b] = sSample;
            }
        }
    }
};

HRESULT PlayNote(LPDIRECTSOUNDSEQUENCER pSequencer, REFERENCE_TIME rtStart, REFERENCE_TIME rtDuration,
                 void* pToneBuffer, size_t dwToneBufferSizeBytes)
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDSEQUENCERBUFFER pBuffer = 0;
    DSBUFFERDESC dsbd;
    WAVEFORMATEX wfxFormat;

    memset(&dsbd, 0, sizeof(dsbd));
    memset(&wfxFormat, 0, sizeof(wfxFormat));
    dsbd.dwFlags = DSBCAPS_LOCDEFER | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLVOLUME;
    dsbd.lpwfxFormat = &wfxFormat;
    wfxFormat.cbSize = sizeof(wfxFormat);
    wfxFormat.nAvgBytesPerSec = 48000 * 2;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = 48000;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;

    if(SUCCEEDED(hr)){
        // DbgPrint("DirectSoundSequencer::CreateBuffer\n");
        hr = pSequencer->CreateBuffer(&dsbd, &pBuffer);
        REPORT(hr);
    }

    if(SUCCEEDED(hr)){
        hr = pBuffer->SetBufferData(0, pToneBuffer, dwToneBufferSizeBytes);
        REPORT(hr);
    }

    if(SUCCEEDED(hr)){
        hr = pBuffer->Play(rtStart, 0, 0, DSBPLAY_LOOPING);
        REPORT(hr);
    }

    if(SUCCEEDED(hr)){
        hr = pBuffer->Stop(rtStart + rtDuration);
        REPORT(hr);
    }

    if(pBuffer) {
        pBuffer->Release();
    }

    return hr;
}


void __cdecl main()
{
    DbgPrint("Start of DirectSoundSequencer test\n");
    HRESULT hr = 0;

    LPDIRECTSOUNDSEQUENCER pSequencer = 0;

    if(SUCCEEDED(hr)){
        DbgPrint("DirectSoundCreateSequencer\n");
        hr = DirectSoundCreateSequencer(0, 500, &pSequencer);
        REPORT(hr);
    }

    const int kToneFreq = 440;
    const int kToneBufferSizeSamples = 48000/(2*kToneFreq);
    const int kToneBufferSizeBytes = kToneBufferSizeSamples*sizeof(WORD);

    WORD* pToneBuffer;

    pToneBuffer = (WORD*) malloc(kToneBufferSizeBytes);
    
    if(!pToneBuffer){
        hr = E_OUTOFMEMORY;
        REPORT(hr);
    }

    ToneSource toneSource;

    if(SUCCEEDED(hr)){
        toneSource.GenerateData(pToneBuffer, kToneFreq, kToneBufferSizeBytes, 0.1);
    }


    REFERENCE_TIME now = 0;
    pSequencer->SetTime(0);
    for(int i = 0; i < 100; i++){
        REFERENCE_TIME rtStart = now + 10000;
        REFERENCE_TIME rtDuration = 2500;
        for(int j = 0; j < 300; j++){
            PlayNote(pSequencer, rtStart, rtDuration, pToneBuffer, kToneBufferSizeBytes);
        }
        Sleep(1000);
        now += 10000;
    }

    if(pSequencer) {
        pSequencer->Release();
    }

    if(pToneBuffer){
        free(pToneBuffer);
    }

    DbgPrint("Exiting dsstest\n");
    XLaunchNewImage( NULL, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dswave\dswave.h ===
// dswave.h
// (c) 1999-2000 Microsoft Corp.

#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "..\shared\debug.h"
#include "dsoundp.h"    // For IDirectSoundWave and IDirectSoundSource
#ifdef XBOX
#include "xsoundp.h"    // For IDirectSoundWave and IDirectSoundSource
#endif
#include "dmusicc.h"
#include "dmusicip.h"
#include "riff.h"

extern long g_cComponent;

#define REF_PER_MIL     10000   // For converting from reference time to mils 
#define CONVERTLENGTH   250

// #define DSWCS_F_DEINTERLEAVED 0x00000001    // Multi-channel data as multiple buffers
// FIXME: unimplemented so far?

typedef struct tCREATEVIEWPORT
{
    IStream            *pStream;
    DWORD               cSamples;
    DWORD               cbStream;
    LPWAVEFORMATEX      pwfxSource;
    LPWAVEFORMATEX      pwfxTarget;
    DWORD               fdwOptions;
} CREATEVIEWPORT, *PCREATEVIEWPORT;


// Private interface for getting the length of a wave
interface IPrivateWave : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(REFERENCE_TIME *prtLength,
        DWORD *dwLoopStart, DWORD *dwLoopEnd) =0;
    virtual HRESULT STDMETHODCALLTYPE SetWaveParams(REFERENCE_TIME rtReadAhead,
        DWORD dwFlags) =0;
};

DEFINE_GUID(IID_IPrivateWave, 0xce6ae366, 0x9d61, 0x420a, 0xad, 0x53, 0xe5, 0xe5, 0xf6, 0xa8, 0x4a, 0xe4);

// Flags for SetWaveBehavior()

#define DSOUND_WAVEF_ONESHOT        1           /* The wave will be played as a one shot */
#define DSOUND_WAVEF_PORT           2           /* The wave will be played via a DMusic port. */
#define DSOUND_WAVEF_SINK           4           /* The wave will be played via a streamed sink interface. */
#define DSOUND_WAVEF_CREATEMASK     0x00000001  /*  Currently only ONESHOT is define for CreateSource  */

#define DSOUND_WVP_NOCONVERT        0x80000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_STREAMEND        0x40000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_CONVERTSTATE_01  0x01000000
#define DSOUND_WVP_CONVERTSTATE_02  0x02000000
#define DSOUND_WVP_CONVERTSTATE_03  0x04000000

#define DSOUND_WVP_CONVERTMASK      0x0f000000

/*  The CWaveViewPort structure represents one instance, or "view", of the
    wave object. It manages the reading of the wave data, ACM decompression,
    and demultiplexing into mono buffers. If a wave object is being
    streamed, each playback instance gets a unique CWaveViewPort. 
    However, in the more typical case where the wave object is being
    played as a one shot, each playback instance uses the same
    CWaveViewPort.
    Each additional CWaveViewPort owns a cloned instance of the IStream.
*/

class CWaveViewPort : CMemTrack,
    public IDirectSoundSource   // Used by a port or sink to pull data. 
{
public:
    CWaveViewPort();            // Constructor receives stream.
    ~CWaveViewPort();           //  Destructor releases memory, streams, etc.

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundSource
    STDMETHODIMP SetSink(IDirectSoundConnect *pSinkConnect);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP Seek(ULONGLONG sp);
    STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwBusIds, LPDWORD pdwFuncIds, LPLONG plPitchShifts, DWORD cpvBuffer, ULONGLONG *pcb);
    STDMETHODIMP GetSize(ULONGLONG *pcb);

    // Misc
    HRESULT Create(PCREATEVIEWPORT pCreate);

private:

    HRESULT acmRead();

    //  General stuff...
    CRITICAL_SECTION    m_CriticalSection;  //  Used to ensure thread safe
    long                m_cRef;             //  COM reference counter.

    //  Details about original data stream...
    IStream *           m_pStream;          //  IStream pointer which is connected to IPersistStream
                                            //  interface to pull data from file. 
    DWORD               m_cSamples;         //  Number of samples (if available)
    DWORD               m_cbStream;         //  Number of bytes in stream.
    DWORD               m_dwStart;          //  Offset into stream where data starts
    //LPWAVEFORMATEX      m_pwfxSource;       //  Do we need to hold on to this?

    //  Details needed for this viewport.
    DWORD               m_dwOffset;   //  Current byte offset into data stream
    DWORD               m_dwStartPos; //  Initial Start Offset
    LPWAVEFORMATEX      m_pwfxTarget; //  Target destination format.
    ACMSTREAMHEADER     m_ash;        //  ACM Stream header (used for conversion)
    HACMSTREAM          m_hStream;    //  ACM Stream handle for conversion
    LPBYTE              m_pDst;       //  Pointer to (decompressed) destination  
    LPBYTE              m_pRaw;       //  Pointer to compressed source buffer
    DWORD               m_fdwOptions; //  Options for viewport

    // Only used to accurately get data after precached data for cDirectSoundWave in DMusic
    DWORD               m_dwPreCacheFilePos;
    DWORD               m_dwFirstPCMSample;
    DWORD               m_dwPCMSampleOut;
};

/*  The CWave2 class represents one instance of a wave object. It
    supports the IDirectSoundWave interface, which the application
    uses to access the wave. It also support IPersistStream and
    IDirectMusicObject, which are used by the loader to load the 
    wave data from a stream into the wave object.
    And, the IDirectSoundSource interface manages the direct 
    transfer of the wave data from the object to the
    synth or DirectSound. This is for internal use, not by the
    application (though it represents an easy way for an app 
    to load wave data and then extract it.) 
    CWave2 maintains a list of CWaveViewPorts, though typically
    there is only one.
*/

class CWave2 : CMemTrack,
    public IDirectSoundWave,    // Standard interface.
    public IPersistStream,      // For file io
    public IDirectMusicObject,  // For DirectMusic loader
    public IPrivateWave         // For GetLength
{
public:
    CWave2();
    ~CWave2();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundWave
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
    STDMETHODIMP GetStreamingParms(LPDWORD pdwFlags, LPREFERENCE_TIME prtReadahread);

    // IPersist functions (base class for IPersistStream)
    STDMETHODIMP GetClassID( CLSID* pClsId );

    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObject 
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPrivateWave
    STDMETHODIMP GetLength(REFERENCE_TIME *prtLength,
        DWORD *dwLoopStart, DWORD *dwLoopEnd);
    STDMETHODIMP SetWaveParams(REFERENCE_TIME rtReadAhead,
        DWORD dwFlags);

private:
    
    // Internal methods.

    BOOL ParseHeader(IStream *pIStream, IRIFFStream* pIRiffStream, LPMMCKINFO pckMain);

    void FallbackStreamingBehavior()
    {
        REFERENCE_TIME rtLength = 0;
        DWORD dwTemp;
        if (SUCCEEDED(GetLength(&rtLength,&dwTemp,&dwTemp)))
        {
            // if > 5000 milliseconds, set to streaming with a 500 ms readahead
            if ((rtLength > 5000) && !m_dwRepeatCount)
            {
                m_rtReadAheadTime = 500 * REF_PER_MIL;
                m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
            }
            else
            {
                m_rtReadAheadTime = 0;
                m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
            }
        }
    }

    CRITICAL_SECTION    m_CriticalSection;      //  Used to ensure thread safe
    LPWAVEFORMATEX      m_pwfxDst;              //  Destination format, if compressed 
    REFERENCE_TIME      m_rtReadAheadTime;      //  Readahead for streaming.
    DWORD               m_fdwFlags;             //  Various flags, including whether this is a one-shot.
    long                m_cRef;                 //  COM reference counter.
    IStream *           m_pStream;              //  IStream pointer which is connected to IPersistStream
    DWORD               m_fdwOptions;           //  Flags set by call to SetWaveBehavior().
    LPWAVEFORMATEX      m_pwfx;                 //  File's format
    DWORD               m_cbStream;
    DWORD               m_cSamples;
    DWORD               m_dwLoopStart; 
    DWORD               m_dwLoopEnd;
    DWORD               m_dwRepeatCount;
    GUID                m_guid;
    FILETIME            m_ftDate;
    DMUS_VERSION        m_vVersion;
    WCHAR               m_wszFilename[DMUS_MAX_FILENAME];
};

class CDirectSoundWaveFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectSoundWaveFactory();

    // Destructor
    ~CDirectSoundWaveFactory(); 

private:
    long m_cRef;
};

#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic\dmwdmtest\unpackermxf.cpp ===
/*  Base implementation of MIDI event unpacker

    05/19/98    Jim Geist           Created this file

*/

#include "stdafx.h"
#include <assert.h>
#include "AllocatorMXF.h"
#include "UnpackerMXF.h"
#include "Ks.h"
#include "KsMedia.h"

// Alignment macros
//
#define DWORD_ALIGN(x) (((x) + 3) & ~3)
#define QWORD_ALIGN(x) (((x) + 7) & ~7)

// MIDI parsing helpers
//
#define IS_DATA_BYTE(x)     (((x) & 0x80) == 0)
#define IS_STATUS_BYTE(x)   ((x) & 0x80)
#define IS_CHANNEL_MSG(x)   (IS_STATUS_BYTE(x) && (((x) & 0xF0) != 0xF0))
#define IS_REALTIME_MSG(x)  (((x) & 0xF8) == 0xF8)
#define IS_SYSTEM_COMMON(x) (((x) & 0xF8) == 0xF0)
#define IS_SYSEX(x)         ((x) == 0xF0)
#define IS_SYSEX_END(x)     ((x) == 0xF7)

#define SYSEX_END           0xF7

static ULONG cbChannelMsgData[] =
{
    2,  /* 0x8x Note off */
    2,  /* 0x9x Note on */
    2,  /* 0xAx Polyphonic key pressure/aftertouch */
    2,  /* 0xBx Control change */
    1,  /* 0xCx Program change */
    1,  /* 0xDx Channel pressure/aftertouch */
    2,  /* 0xEx Pitch change */
    0,  /* 0xFx System message - use cbSystemMsgData */
};

static ULONG cbSystemMsgData[] =
{
    0,  /* 0xF0 SysEx (variable until F7 seen) */
         
        /* System common messages */
    1,  /* 0xF1 MTC quarter frame */
    2,  /* 0xF2 Song position pointer */
    1,  /* 0xF3 Song select */
    0,  /* 0xF4 Undefined */
    0,  /* 0xF5 Undefined */
    0,  /* 0xF6 Tune request */
    0,  /* 0xF7 End of sysex flag */

        /* System realtime messages */
    0,  /* 0xF8 Timing clock */
    0,  /* 0xF9 Undefined */
    0,  /* 0xFA Start */
    0,  /* 0xFB Continue */
    0,  /* 0xFC Stop */
    0,  /* 0xFD Undefined */
    0,  /* 0xFE Active sensing */
    0,  /* 0xFF System reset */
};

#define STATUS_MSG_DATA_BYTES(x)    \
    (IS_CHANNEL_MSG(x) ? cbChannelMsgData[((x) >> 4) & 0x07] : cbSystemMsgData[(x) & 0x0F])

///////////////////////////////////////////////////////////////////////
//
// CUnpackerMXF
//
// Code which is common to all unpackers
//

// CUnpackerMXF::CUnpackerMXF
//
// Get the system page size, which unpackers use as the maximum buffer size.
//
CUnpackerMXF::CUnpackerMXF(CAllocatorMXF *allocatorMXF)
 : CMXF(allocatorMXF)
{
    m_sinkMXF = NULL;

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    m_pageSize = si.dwPageSize;

    HRESULT hr = m_allocatorMXF->GetMessage(&m_nextSysExEvent);
    if (FAILED(hr))
    {
        m_nextSysExEvent = NULL;
    }

    m_bRunningStatus = 0;
    m_state = stateNone;
}

// CUnpackerMXF::~CUnpackerMXF
//
CUnpackerMXF::~CUnpackerMXF()
{
    DisconnectOutput(m_sinkMXF);    
}

// CUnpackerMXF::ConnectOutput
//
// It is an error to connect to nothing (use DisconnectOutput) or to connect
// an unpacker to more than one sink (use a splitter).
//
HRESULT CUnpackerMXF::ConnectOutput(CMXF *sinkMXF)
{
    if (m_sinkMXF || !sinkMXF) 
    {
        return S_FALSE;
    }

    m_sinkMXF = sinkMXF;
    return S_OK;
}

// CUnpackerMXF::DisconnectOutput
//
// Validate that the unpacker is connected and the disconnection applies
// to the correct filter.
//
HRESULT CUnpackerMXF::DisconnectOutput(CMXF *sinkMXF)
{
    if ((m_sinkMXF == sinkMXF) || (sinkMXF == NULL))
    {
        m_sinkMXF = NULL;
        return S_OK;
    }
    return S_FALSE;
}

// CUnpackerMXF::PutMessage
//
// An unpacker's upper edge is type dependent, but it is not by definition an MXF interface.
// Therefore this method should never be called.
//
HRESULT CUnpackerMXF::PutMessage(PDMUS_KERNEL_EVENT)
{       
    return E_FAIL;
}

// CUnpackerMXF::QueueShortEvent
//
// Create and put an MXF event with a short message (anything other than system exclusive data).
// By definition this data must fit in 4 bytes or less.
//
HRESULT CUnpackerMXF::QueueShortEvent(
    LPBYTE pbData, 
    USHORT cbData, 
    ULONGLONG ullPresTime, 
    ULONG dwChannelGroup)
{
    HRESULT hr;

    PDMUS_KERNEL_EVENT  pMXFEvent;

    hr = m_allocatorMXF->GetMessage(&pMXFEvent);
    if (FAILED(hr)) 
    {
        return hr;
    }   

    pMXFEvent->cbEvent          = cbData; 
    pMXFEvent->usFlags          = 0;
    pMXFEvent->ulChannelGroup   = dwChannelGroup;
    pMXFEvent->ullPresTime100Ns = ullPresTime;
    pMXFEvent->pNextEvt         = NULL;
 
    // Short event by definition is < sizeof(PBYTE)
    //
    assert(cbData <= sizeof(PBYTE));
    /*RTL*/CopyMemory(&pMXFEvent->uData.abData[0], pbData, cbData);

    if (FAILED(m_sinkMXF->PutMessage(pMXFEvent)))
    {
        m_allocatorMXF->PutMessage(pMXFEvent);
        return S_FALSE;
    }
    
    return S_OK;
}

// CUnpackerMXF::QueueSysEx
//
// Create and put an MXF event which contains system exclusive data. This data must already
// be truncated into page-sized buffers.
//
HRESULT CUnpackerMXF::QueueSysEx(
    LPBYTE pbData,
    USHORT cbData,
    ULONGLONG ullPresTime,
    ULONG dwChannelGroup,
    BOOL fIsContinued)
{
    assert(cbData <= PageSize());

    // Get the preallocated next sysex event and allocate a new next. This
    // ensures linkage in the chain of sysex we pass along to the
    // graph.
    //
    if (!m_nextSysExEvent)
    {
        return E_OUTOFMEMORY;
    }

    PDMUS_KERNEL_EVENT pMXFEvent = m_nextSysExEvent;
    HRESULT hr = m_allocatorMXF->GetMessage(&m_nextSysExEvent);
    if (FAILED(hr))
    {
        m_allocatorMXF->PutMessage(pMXFEvent);
        m_nextSysExEvent = NULL;

        return E_OUTOFMEMORY;
    }

    // Build the event.
    //
    pMXFEvent->cbEvent          = cbData; 
    pMXFEvent->usFlags          = (USHORT)(fIsContinued ? DMUS_KEF_EVENT_INCOMPLETE : 0);
    pMXFEvent->ulChannelGroup   = dwChannelGroup;
    pMXFEvent->ullPresTime100Ns = ullPresTime;
    pMXFEvent->pNextEvt         = fIsContinued ? m_nextSysExEvent : NULL;
 
    if (cbData <= sizeof(PBYTE)) 
    {
        /*RTL*/CopyMemory(&pMXFEvent->uData.abData[0], pbData, cbData);
    }
    else
    {
        // Event data won't fit in uData, so allocate some memory to
        // hold it.
        //
        pMXFEvent->uData.pbData = /*ExAllocatePool*/new BYTE[cbData];
        if (pMXFEvent->uData.pbData ==  NULL)
        {
            // XXX This is going to cause problems in the stack - the MXF chain
            // will forever be waiting for this event which will never come
            //
            m_allocatorMXF->PutMessage(pMXFEvent);

            return E_OUTOFMEMORY;
        }

        /*RTL*/CopyMemory(pMXFEvent->uData.pbData, pbData, cbData);
    }
    
    if (FAILED(m_sinkMXF->PutMessage(pMXFEvent)))
    {
        m_allocatorMXF->PutMessage(pMXFEvent);
        return S_FALSE;
    }
    
    return S_OK;
}

// CUnpackerMXF::UnpackEventBytes
//
// This is basically a MIDI parser with state. It assumes nothing about alignment of
// events to the buffers that are passed in - a message may cross calls.
//
// QueueEvent's return code is not checked; we don't want to lose state if we 
// can't queue a message.
//
//
HRESULT CUnpackerMXF::UnpackEventBytes(ULONGLONG ullCurrentTime, ULONG ulChannelGroup, LPBYTE pbDataStart, ULONG cbData)
{
    LPBYTE      pbData = pbDataStart;
    LPBYTE      pbSysExStart;
    BYTE        bData;

    if (m_state == stateInSysEx) 
    {
        pbSysExStart = pbData;
    }

    while (cbData)
    {
        bData = *pbData++;
        cbData--;

        // Realtime messages have priority over anything else. They can appear anywhere and 
        // don't change the state of the stream.
        //
        if (IS_REALTIME_MSG(bData))
        {
            QueueShortEvent(&bData, sizeof(bData), ullCurrentTime, ulChannelGroup);

            // Did this interrupt a SysEx? Spit out the contiguous buffer so far
            // and reset the start pointer. State is still in SysEx.
            //
            // Other messages are copied as they are parsed so no need to change their
            // parsing state.
            //
            if (m_state == stateInSysEx)
            {
                USHORT cbSysEx = (USHORT)((pbData - 1) - pbSysExStart);

                if (cbSysEx)
                {
                    QueueSysEx(pbSysExStart, cbSysEx, m_ullEventTime, ulChannelGroup, TRUE);
                }

                pbSysExStart = pbData;
            }

            continue;
        }

        // If we're parsing a SysEx, just pass over data bytes - they will be dealt with
        // when we reach a terminating condition (end of buffer or a status byte).
        //
        if (m_state == stateInSysEx)
        {
            if (!IS_STATUS_BYTE(bData))
            {
                // Don't allow a single buffer to grow to more than the system page size
                //
                USHORT cbSysEx = (USHORT)(pbData - pbSysExStart);
                if (cbSysEx >= PageSize())
                {
                    QueueSysEx(pbSysExStart, cbSysEx, m_ullEventTime, ulChannelGroup, TRUE);
                    pbSysExStart = pbData;
                }

                continue;
            }
       
            // Trickery: We have the end of the SysEx. We always want to plant an F7 in the end of 
            // the sysex so anyone watching the buffers above us will know when it ends, even if
            // it was truncated. XXX Indication of truncation?
            //
            pbData[-1] = SYSEX_END;

            // Unlike the above case, we are guaranteed at least one byte to pack here
            //
            QueueSysEx(pbSysExStart, (USHORT)(pbData - pbSysExStart), m_ullEventTime, ulChannelGroup, FALSE);

            // Restore original data. If this was a real end of sysex, then eat the byte and
            // continue.
            //
            pbData[-1] = bData;

            m_state = stateNone;
            if (IS_SYSEX_END(bData)) 
            {
                continue;
            }
        }                                       

        // If we're starting a SysEx, tag it.
        //
        if (IS_SYSEX(bData))
        {
#ifdef DEBUG
            if (m_state != m_stateNone)
            {
                //Trace("SysEx interrupted another msg. Oh well.");
            }
#endif
            // Note that we've already advanced over the start byte.
            //
            m_ullEventTime = ullCurrentTime;
            pbSysExStart = pbData - 1;
            m_state = stateInSysEx;

            continue;
        }

        if (IS_STATUS_BYTE(bData))
        {
            // We have a status byte. Even if we're already in the middle of a short
            // message, we have to start a new one
            //
#ifdef DEBUG     
            if (state == m_stateInShortMsg)
            {
                //Trace("Short message interrupted by another short msg");
            }
#endif                                

            m_abShortMsg[0]     = bData;
            m_pbShortMsg        = &m_abShortMsg[1];
            m_cbShortMsgLeft    = STATUS_MSG_DATA_BYTES(bData);
            m_ullEventTime      = ullCurrentTime;
            m_state             = stateInShortMsg;

            // Update running status
            // System common -> clear running status
            // Channel message -> change running status
            //
            m_bRunningStatus = 0;
            if (IS_CHANNEL_MSG(bData))
            {
                m_bRunningStatus = bData;
            }
        }
        else
        {
            // Not a status byte. If we're not in a short message,
            // start one with running status. 
            // 
            if (m_state != stateInShortMsg)  
            {
#ifdef DEBUG     
                if (m_state == stateInShortMsg)
                {
                    //Trace("Short message interrupted by another short msg");
                }
#endif                                
                if (m_bRunningStatus == 0) 
                {
                    //Trace("Attempt to use running status with no pending status byte");
                    continue;
                }

                m_abShortMsg[0]     = m_bRunningStatus;
                m_pbShortMsg        = &m_abShortMsg[1];
                m_cbShortMsgLeft    = STATUS_MSG_DATA_BYTES(m_bRunningStatus);
                m_ullEventTime      = ullCurrentTime;
                m_state             = stateInShortMsg;
            }

            // Now we are guaranteed to be in a short message, and can safely add this
            // byte. Note that since running status is only allowed on channel messages,
            // we are also guaranteed at least one byte of expected data, so no need
            // to check for that.
            //
            *m_pbShortMsg++ = bData;
            m_cbShortMsgLeft--;
        }

        // See if we've finished a short message, and if so, queue it.
        //
        if (m_state == stateInShortMsg && m_cbShortMsgLeft == 0)
        {
            QueueShortEvent(m_abShortMsg, (USHORT)(m_pbShortMsg - m_abShortMsg), m_ullEventTime, ulChannelGr