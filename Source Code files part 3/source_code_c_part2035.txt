vr32 CryptoWrapper.dll\"?");
                    throw;
                }
            }
            return m_cryptoWrp.DecryptWithMasterKeyWrp(masterkeyver, encPasswordLength, encPassword);
        }


        public static byte[] StringToHex(string s)
        {
            if (s.StartsWith("0x"))
                s = s.Substring(2);

            if (s.Length % 2 == 1)
                s = "0" + s;

            byte[] hex = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }

            return hex;
        }

        public static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'z')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'Z')
                return (byte)(c - 'A' + 10);
            return 0;
        }

        public static string HexToString(byte[] bytes)
        {
            StringBuilder s = new StringBuilder(bytes.Length * 2);
            for (int i = 0; i < bytes.Length; i++)
            {
                s.AppendFormat("{0:X2}", bytes[i]);
            }
            return s.ToString();
        }

        public static string HexToAscii(byte[] bytes)
        {
            StringBuilder s = new StringBuilder(bytes.Length);
            for (int i = 0; i < bytes.Length; i++)
            {
                s.Append((char)bytes[i]);
            }
            return s.ToString();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DisableSub\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DisableSub\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_disablesub_none_12.4.56.0_none_7cb9148a3ec3724b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=disablesub
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.manifest
XP_MANIFEST_PATH=manifests\msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.cat
XP_CATALOG_PATH=manifests\msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.cat
XP_PAYLOAD_PATH=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=disablesub,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DisableSub\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_disablesub_none_12.4.56.0_none_7cb9148a3ec3724b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=disablesub
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.manifest
XP_MANIFEST_PATH=manifests\msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.cat
XP_CATALOG_PATH=manifests\msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb.cat
XP_PAYLOAD_PATH=msil_disablesub_no-public-key_12.4.56.0_x-ww_79fe76fb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=disablesub,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DisableSub\DisableSub.cs ===
//Disables a given subscription by setting it to a certain status.
//
//NOTE:This relies heavily on ServerTestFramework.  Specifically, it relies on
//ServerTestFramework.dll and stf.xml being in the same directory as wherever it is.


using System;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;
using ServerTestFramework.LiveService.FakeSG;

public class DisableSub {

    public static void InitSTF() {
        XmlDocument config = new XmlDataDocument();
        try
        {
            config.Load("stf.xml");
        }
        catch (System.IO.FileNotFoundException)
        {
            Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
            return;
        }
        CoreGlobal.Initialize(config);

        // We need fakeSG for achievements stuff to work apparently.
        GlobalFakeSG.FakeSG = new FakeSGClient("FakeSGClient");
        if(!GlobalFakeSG.FakeSG.ConnectToService())
        {
            Console.WriteLine("Failed to connect to FakeSG Service... achievement setting will likely fail.");
        }
        else
        {
            GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());
        }
    }

    public static void ParseArgs(string [] args, out ulong userPuid, out ulong offerid, out int status) {
        if (args[0].StartsWith("0x")) {
            userPuid = Convert.ToUInt64(args[0], 16);
        } else {
            userPuid = Convert.ToUInt64(args[0], 10);
        }

        if (args[1].StartsWith("0x")) {
            offerid = (ulong) Convert.ToInt64(args[1], 16);
        } else {
            offerid = (ulong) Convert.ToInt64(args[1], 10);
        }
        
        status = Convert.ToInt32(args[2], 10);
    }

    public static void RunDisableSubscriptionRequest(XRLDisableSubscription request) {
        if (!request.Execute())
            throw new UnexpectedTestResultException("DisableSubscription failed: " + request.GetDumpString());
        if (request.XErr != HResult.S_OK)
            throw new UnexpectedTestResultException(String.Format("DisableSubscription returned XErr=0x{0:x}", request.XErr));
                
        Console.WriteLine("Waiting for SCG to enforce the status change");
        System.Threading.Thread.Sleep(3000);
    }

    //Create a request to modify the status of a user's subscription.  Most of the time this
    //involves disabling it. If execute is true the request is executed as well as returned.
    //One might set execute to false so they could add an emulator, or perform other
    //configuration before execution.
    public static XRLDisableSubscription SetSubscriptionStatus(ulong userPuid, ulong offerId, 
                                                               int status, bool execute) {
        XRLDisableSubscription request = new XRLDisableSubscription();

        request.UserPuid = userPuid;
        request.ServiceInstanceId = UodbWS.GetUsersAndOffersSubscriptionInstanceId(userPuid, offerId);
        request.SubscriptionStatusId = (int)status;
        request.AddViolation = (status == (int) SubscriptionStatus.Suspended); //?

        // need the machine puid match, otherwise AddPaymentInstrument will fail
        request.ManualPopulateSlot();
        request.Slot.machinePuid = 0xfa00000012341234;

        if (execute) {
            RunDisableSubscriptionRequest(request);
            UodbWS.WaitForCallback(userPuid, offerId);
        }
        return request;
    }

    public static void Main(string [] args ) {

        ulong userPuid;
        ulong offerid;
        int status;

        if (args.Length != 3) {
            Console.WriteLine("Usage:DisableSub [userpuid] [offerid] [status]");
            Console.WriteLine("userpuid and offerid can be in hex, if prefixed with 0x");
            Console.WriteLine("Status list:SUSPENDED=2, EXPIRED=3, CANCELED=4");
            return;
        }
        
            ParseArgs(args, out userPuid, out offerid, out status);
            InitSTF();

            Console.WriteLine("Running on puid 0x" + userPuid.ToString("X") + ", offerid 0x" + offerid.ToString("X"));
            try {
                SetSubscriptionStatus(userPuid, offerid, status, true);
                Console.WriteLine("Done!  You can check status in UODB with the following query:");
            } catch (Exception e) {
                Console.WriteLine("Something unexpected occurred--see below.\n\n");
                Console.WriteLine(e);
                Console.WriteLine(e.StackTrace);
            }
            Console.WriteLine("SELECT * from t_subscriptions where bi_primary_puid = 0x" + userPuid.ToString("X") + 
                              " and bi_offer_id = 0x" + offerid.ToString("X"));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dnsd\ansiapi.h ===
#pragma once

#define W2A(w, a, cb)     WideCharToMultiByte(                              \
                                               CP_ACP,                      \
                                               0,                           \
                                               w,                           \
                                               -1,                          \
                                               a,                           \
                                               cb,                          \
                                               NULL,                        \
                                               NULL)

#define A2W(a, w, cb)     MultiByteToWideChar(                              \
                                               CP_ACP,                      \
                                               0,                           \
                                               a,                           \
                                               -1,                          \
                                               w,                           \
                                               cb)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EmulatorSetUP\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dnsd\dnsd.h ===
#pragma once

// #include <windows.h>
#include <winsock2.h>
#include <stdio.h>

#include "events.h"

extern bool g_IsService;

#define VER_SERVICENAME_STRA        "DNSD"
#define VER_SERVICENAME_STR         L"DNSD"
#define VER_SERVICEDISPLAYNAME_STR  L"Xbox DNS Redirector"
#define EVENTLOGPATH                L"System\\CurrentControlSet\\Services\\Eventlog\\Application\\DNSD"
#define DNSD_REGKEY                 L"Software\\Microsoft\\DNSD"
#define EVENTSOURCE                 L"DNSD Server"
// #define ARRAYSIZE(x)                (sizeof(x)/sizeof(x[0]))
struct ServiceArgs
{
    DWORD dwArgStart;
    DWORD dwCount;
    WCHAR **pszArgs;
    volatile LONG dwSignal;
    bool fUseReg;
};


// dnsd.cpp
DWORD WINAPI Initialize(ServiceArgs *args);
DWORD WINAPI MainThread(ServiceArgs *args);

// events.cpp
void InitializeEventSource(void);
DWORD LogEvent(char *functName, char *fileName, unsigned lineNumber, DWORD eventID, CHAR *format, ...);
DWORD LogExceptionPointers(_EXCEPTION_POINTERS *exceptionInfo, char *functName, char *fileName, unsigned lineNumber, DWORD eventID, char *format, ...);
LONG ExceptionHandler(_EXCEPTION_POINTERS *exceptionInfo); // top level exception handler
void __cdecl SEH(unsigned int u, _EXCEPTION_POINTERS* exceptionInfo);

// service.cpp

DWORD ServiceInstall(void);
DWORD ServiceUninstall(void);
DWORD ServiceRestart(void);
void WINAPI ServiceMain(DWORD argc, WCHAR* argv[]);
void WINAPI ServiceHandler(DWORD fdwControl);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\parser\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dnsd\dnsd.cpp ===
// ---------------------------------------------------------------------------------------
// chalmake.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "dnsd.h"
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <winsvc.h>

#include <ansiapi.h>

bool g_IsService = false;

char g_CurrentTime[sizeof("05/05/1975 00:05:00")];

void Syntax();

char * GetTime()
{
    SYSTEMTIME st;

    GetSystemTime(&st);

    sprintf(g_CurrentTime, "%02d/%02d/%04d %02d:%02d:%02d",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

    return g_CurrentTime;
}

#define BIT(b)            (1<<(b))

struct CNameInfo
{
    char * _pchHostName;
    char * _pchOrigName;
    ULONG  _dwHostLen;
    ULONG  _ulAddr;
};

struct CDnsHdr
{
    // Definitions ---------------------------------------------------

    #define DNSF_RESPONSE       BIT(15) // 1 if response; 0 if query
    #define DNSF_QOP_MASK       0x7800  // 4 bits of query opcode
    #define DNSF_QOP_SQRY       0x0000  // Standard query opcode
    #define DNSF_QOP_IQRY       0x0800  // Inverse query opcode
    #define DNSF_QOP_STAT       0x1000  // Server status request
    #define DNSF_AA             BIT(10) // Authoritative answer
    #define DNSF_TC             BIT(9)  // Truncation
    #define DNSF_RD             BIT(8)  // Recursion desired
    #define DNSF_RA             BIT(7)  // Recursion available
    #define DNSF_ROP_MASK       0x000F  // 4 bits of response opcode
    #define DNSF_ROP_OK         0x0000  // No error response code
    #define DNSF_ROP_FMTERR     0x0001  // Format error response code
    #define DNSF_ROP_SRVFAIL    0x0002  // Server failure response code
    #define DNSF_ROP_NAMEERR    0x0003  // Name error response code
    #define DNSF_ROP_NOTIMPL    0x0004  // Not implemented response code
    #define DNSF_ROP_REFUSED    0x0005  // Refused response code

    #define DNSRT_A             1       // a host address
    #define DNSRT_NS            2       // an authoritative name server
    #define DNSRT_MD            3       // a mail destination (Obsolete - use MX)
    #define DNSRT_MF            4       // a mail forwarder (Obsolete - use MX)
    #define DNSRT_CNAME         5       // the canonical name for an alias
    #define DNSRT_SOA           6       // marks the start of a zone of authority
    #define DNSRT_MB            7       // a mailbox domain name (EXPERIMENTAL)
    #define DNSRT_MG            8       // a mail group member (EXPERIMENTAL)
    #define DNSRT_MR            9       // a mail rename domain name (EXPERIMENTAL)
    #define DNSRT_NULL          10      // a null RR (EXPERIMENTAL)
    #define DNSRT_WKS           11      // a well known service description
    #define DNSRT_PTR           12      // a domain name pointer
    #define DNSRT_HINFO         13      // host information
    #define DNSRT_MINFO         14      // mailbox or mail list information
    #define DNSRT_MX            15      // mail exchange
    #define DNSRT_TXT           16      // text strings

    #define DNSQT_AXFR          252     // a transfer of an entire zone
    #define DNSQT_MAILB         253     // mailbox-related records (MB, MG or MR)
    #define DNSQT_MAILA         254     // mail agent RRs (Obsolete - see MX)
    #define DNSQT_ALL           255     // all records

    #define DNSRC_IN            1       // the Internet
    #define DNSRC_CS            2       // the CSNET class (Obsolete)
    #define DNSRC_CH            3       // the CHAOS class
    #define DNSRC_HS            4       // the Hesiod class
    #define DNSRC_ANY           255     // any class

    // Data ----------------------------------------------------------

    WORD _wId;               // DNS message unique identifier
    WORD _wFlags;            // See DNSF_* above
    WORD _cQd;               // Number of entries in questions section
    WORD _cAn;               // Number of entries in answers section
    WORD _cNs;               // Number of entries in authority section
    WORD _cAr;               // Number of entries in additional section
};

void DumpDns(CDnsHdr * pdnshdr, UINT)
{
    WORD wFlags = ntohs(pdnshdr->_wFlags);

    printf("%s [DNS %s %d/%s %d/%s%s%s%s%s %04X %d/Qd %d/An %d/Ns %d/Ar]\n",
           GetTime(),
           (wFlags & DNSF_RESPONSE) ? "RESP" : "QUERY",
           (wFlags & DNSF_QOP_MASK),
           (wFlags & DNSF_QOP_MASK) == DNSF_QOP_SQRY ? "SQRY" :
           (wFlags & DNSF_QOP_MASK) == DNSF_QOP_IQRY ? "IQRY" :
           (wFlags & DNSF_QOP_MASK) == DNSF_QOP_STAT ? "STAT" : "????",
           (wFlags & DNSF_ROP_MASK),
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_OK ? "OK" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_FMTERR ? "FMTERR" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_SRVFAIL ? "SRVFAIL" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NAMEERR ? "NAMEERR" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NOTIMPL ? "NOTIMPL" :
           (wFlags & DNSF_ROP_MASK) == DNSF_ROP_REFUSED ? "REFUSED" : "????",
           (wFlags & DNSF_AA) ? " AA" : "",
           (wFlags & DNSF_TC) ? " TC" : "",
           (wFlags & DNSF_RD) ? " RD" : "",
           (wFlags & DNSF_RA) ? " RA" : "",
           ntohs(pdnshdr->_wId),
           ntohs(pdnshdr->_cQd),
           ntohs(pdnshdr->_cAn),
           ntohs(pdnshdr->_cNs),
           ntohs(pdnshdr->_cAr));


}

static DWORD gNameCount = 0;
static CNameInfo *gNames = 0;
static SOCKET mySock = INVALID_SOCKET;
WSAEVENT hReady = WSA_INVALID_EVENT;


void RewriteRegistry()
{
    CHAR *szData = 0;
    HKEY hKey = NULL;
    DWORD dwRes = RegCreateKey(HKEY_LOCAL_MACHINE, DNSD_REGKEY, &hKey);
    if(dwRes != ERROR_SUCCESS)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_WARNING, "Failed to create the registry key for DNS redirection settings.  Error: %d", dwRes);
        dwRes = 0;
        goto Cleanup;
    }

    // Create the string buffer to send to regsetvalue
    DWORD dwLen = 1;            // +1 for additional trailing null
    CHAR szIP[20];
    
    for(DWORD i = 0; i < gNameCount; ++i)
    {
        BYTE * pbAddr = (BYTE *)&gNames[i]._ulAddr;
        sprintf(szIP, ":%d.%d.%d.%d", pbAddr[0], pbAddr[1], pbAddr[2], pbAddr[3]);
        dwLen += strlen(gNames[i]._pchOrigName) + strlen(szIP) + 1; // + 1 for trailing null
    }
    szData = (CHAR *) malloc(dwLen);
    CCHAR *pos = szData;
    for(DWORD i = 0; i < gNameCount; ++i)
    {
        BYTE * pbAddr = (BYTE *)&gNames[i]._ulAddr;
        sprintf(szIP, ":%d.%d.%d.%d", pbAddr[0], pbAddr[1], pbAddr[2], pbAddr[3]);
        strcpy(pos, gNames[i]._pchOrigName);
        pos += strlen(gNames[i]._pchOrigName);
        strcpy(pos, szIP);
        pos += strlen(szIP) + 1;
    }
    pos[0] = 0;    
    
    dwRes = RegSetValueExA(hKey, "Mapping", 0, REG_MULTI_SZ, (LPBYTE) szData, dwLen);
    if(dwRes != ERROR_SUCCESS)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_WARNING, "Failed to create the registry value for DNS redirection settings.  Error: %d", dwRes);
        dwRes = 0;
        goto Cleanup;
    }

Cleanup:
    if(szData)
        free(szData);
    if(hKey)
        RegCloseKey(hKey);
}


bool TransformHostName(CNameInfo *pinfo, WCHAR *szName, WCHAR *szAddr)
{
    CHAR szIP[16];

    // Get the address
    W2A(szAddr, szIP, ARRAYSIZE(szIP));
    pinfo->_ulAddr = inet_addr(szIP);
 
    DWORD dwCharCount = szAddr - szName + 1; // Ending null and preceding length less the semicolon skipped by szAddr
    pinfo->_pchOrigName = (CHAR *) malloc(dwCharCount - 1);
    pinfo->_pchHostName = (CHAR *) malloc(dwCharCount);
    W2A(szName, pinfo->_pchOrigName, dwCharCount - 1);
    pinfo->_pchOrigName[dwCharCount - 2] = 0;
    strcpy(&pinfo->_pchHostName[1], pinfo->_pchOrigName);
    pinfo->_pchHostName[0] = '.';
    pinfo->_dwHostLen = dwCharCount - 1;

    // Check for duplicates
    for(DWORD dwIdx = 0; &gNames[dwIdx] < pinfo; ++dwIdx)
    {
        if(!_stricmp(gNames[dwIdx]._pchOrigName, pinfo->_pchOrigName))
        {
            free(pinfo->_pchOrigName);
            free(pinfo->_pchHostName);
            gNames[dwIdx]._ulAddr = pinfo->_ulAddr;
            memset(pinfo, 0, sizeof(CNameInfo));
            return false;
        }
    }


    CHAR *lenpos = pinfo->_pchHostName;
    CHAR *curpos = lenpos + 1;
    while(*curpos)
    {
        if(*curpos == '.')
        {
            lenpos[0] = (CHAR) (curpos - lenpos - 1);
            lenpos = curpos;
        }
        curpos++;
    }
    lenpos[0] = (CHAR) (curpos - lenpos - 1);
    return true;
}

DWORD WINAPI Uninitialize();

DWORD WINAPI ProcessCmdLine(DWORD dwArgStart, DWORD dwStart, DWORD dwCount, WCHAR **pszArgs, BOOL fCountOnly)
{
    DWORD dwPos = 0;
    for(DWORD i = dwArgStart; i < dwCount; ++i)
    {
        WCHAR *pos = wcschr(pszArgs[i], ':');
        if(!pos || wcslen(pos + 1) > 15)
        {
            if(fCountOnly)
    			printf("Warning: Skipping parameter: %S\n", pszArgs[i]);
            continue;
        }

        if(!fCountOnly)
        {
            CNameInfo *pinfo = &gNames[dwStart + dwPos];
            if(!TransformHostName(pinfo, pszArgs[i], pos + 1))
                continue;
        }
        
		++dwPos;
    }
    return dwPos;
}

DWORD WINAPI ProcessRegistry(DWORD dwStart, DWORD dwByteCount, WCHAR *szStrings, BOOL fCountOnly)
{
    DWORD dwCount = 0;
    DWORD dwPos = 0;
    WCHAR *pos = 0, *posip = 0;
    while(dwPos * sizeof(WCHAR) < dwByteCount)
    {
        pos = szStrings + dwPos;
        if(pos[0] == 0)
            break;
        posip = wcschr(pos, L':');
        dwPos += wcslen(pos) + 1;

        if(!posip || wcslen(posip + 1) > 15)
        {
            if(fCountOnly)
                printf("Warning: Skipping registry entry: %S\n", pos);
            continue;
        }

        if(!fCountOnly)
        {
            CNameInfo *pinfo = &gNames[dwStart + dwCount];
            if(!TransformHostName(pinfo, pos, posip + 1))
                continue;
        }
        
        ++dwCount;
    }
    return dwCount;
}


DWORD WINAPI ParseArgs(ServiceArgs *args)
{
    DWORD dwRes = 0, dwPos = 0, dwCount = 0, dwDataLen = 0;
    WCHAR *szStrings = 0;
    HKEY hKey = NULL;

    dwCount = ProcessCmdLine(args->dwArgStart, 0, args->dwCount, args->pszArgs, TRUE);

    if(args->fUseReg)
    {
        DWORD dwType = 0;
        
        dwRes = RegOpenKey(HKEY_LOCAL_MACHINE, DNSD_REGKEY, &hKey);
        if(dwRes != ERROR_SUCCESS)
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_WARNING, "Failed to access the registry key to get DNS redirection settings.  Error: %d", dwRes);
            dwRes = 0;
            goto ProcessCommandLine;
        }
        dwRes = RegQueryValueEx(hKey, L"Mapping", 0, &dwType, NULL, &dwDataLen);
        if(dwRes != ERROR_SUCCESS)
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_WARNING, "Failed to access the registry value to get DNS redirection settings.  Error: %d", dwRes);
            dwRes = 0;
            goto ProcessCommandLine;
        }
        else if(dwType != REG_MULTI_SZ)
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "The data type for registry value is incorrect.  Ignoring.  Error: %d", dwRes);
            dwRes = 0;
            goto ProcessCommandLine;
        }

        szStrings = (WCHAR *) malloc(dwDataLen);
        dwRes = RegQueryValueEx(hKey, L"Mapping", 0, &dwType, (LPBYTE) szStrings, &dwDataLen);
        if(dwRes != ERROR_SUCCESS)
        {
            free(szStrings);
            szStrings = 0;
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_WARNING, "Failed to read the registry value to get DNS redirection settings.  Error: %d", dwRes);
            dwRes = 0;
            goto ProcessCommandLine;
        }

        dwPos = 0;
        dwCount += ProcessRegistry(0, dwDataLen, szStrings, TRUE);
    }

ProcessCommandLine:
    if(!dwCount)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "No valid arguments were found to apply dns redirection to.");
		Syntax();
        dwRes = 1;
        goto Cleanup;
    }

    gNameCount = dwCount;
    gNames = (CNameInfo *) malloc(sizeof(CNameInfo) * dwCount);
    memset(gNames, 0, sizeof(CNameInfo) * dwCount);

    dwPos = ProcessRegistry(0, dwDataLen, szStrings, FALSE);
    dwPos += ProcessCmdLine(args->dwArgStart, dwPos, args->dwCount, args->pszArgs, FALSE);
    gNameCount = dwPos; // Update the count.  Commandline options may override registry
    
    // Simple sort for the names in the list--simple==>least bugs
    // Sorting to put "largest" values on top of the list--the goal is to put the most specific values on top so
    // they would get matched first before less specific values.
    for(DWORD i = 0; i < gNameCount; ++i)
    {
        for(DWORD j = i + 1; j < gNameCount && i < gNameCount - 1; ++j)
        {
            if(_stricmp(gNames[i]._pchHostName, gNames[j]._pchHostName) < 0)
            {
                CNameInfo temp;
                memcpy(&temp, &gNames[i], sizeof(CNameInfo));
                memcpy(&gNames[i], &gNames[j], sizeof(CNameInfo));
                memcpy(&gNames[j], &temp, sizeof(CNameInfo));
            }
        }

        BYTE * pbAddr = (BYTE *)&gNames[i]._ulAddr;
           
        printf("%4s: %d.%d.%d.%d\n", gNames[i]._pchOrigName,
               pbAddr[0], pbAddr[1], pbAddr[2], pbAddr[3]);
    }


Cleanup:
    if(szStrings)
        free(szStrings);
    if(hKey != NULL)
        RegCloseKey(hKey);
    return dwRes;
}

DWORD WINAPI Initialize(ServiceArgs *args)
{
    int err;
    WSADATA WSAData;

    if(ParseArgs(args) != 0)
        return 1;

    err = WSAStartup(0x0101, &WSAData);

    if (err != 0)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Couldn't init winsock, err %d\n", err);
        return 1;
    }

    hReady = WSACreateEvent();
    if(hReady == NULL)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Couldn't create event handle %d\n", GetLastError());
        goto Cleanup;
    }
    
    mySock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (mySock == SOCKET_ERROR)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Couldn't create socket %d\n", WSAGetLastError());
        goto Cleanup;
    }

    sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(53);

    err = bind(mySock, (struct sockaddr *)&sin, sizeof(sin));
    if (err != 0)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Couldn't bind socket %d\n", err);
        goto Cleanup;
    }

    err = WSAEventSelect(mySock, hReady, FD_READ);
    if(err != 0)
    {
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Couldn't set socket to asynchronous %d\n", err);
        goto Cleanup;
    }

    return 0;
    
Cleanup:
    Uninitialize();
    return 1;
}

DWORD WINAPI Uninitialize()
{
    if(mySock != INVALID_SOCKET)
        closesocket(mySock);
    if(hReady != WSA_INVALID_EVENT)
        WSACloseEvent(hReady);
    WSACleanup();

    if(gNames)
    {
        for(DWORD i = 0; i < gNameCount; ++i)
        {
            free(gNames[i]._pchHostName);
        }
        free(gNames);
    }
    return 0;
}

CHAR *CleanName(const CHAR *name)
{
    static CHAR buf[256];
    strcpy(buf, name);
    CHAR *pos = buf;

    while(*pos != 0)
    {
        int i = *pos;
        *pos = '.';
        pos += i + 1;
    }
    return &buf[1];
}

DWORD WINAPI MainThread(ServiceArgs *args)
{
    int err = 0;

    sockaddr_in sin;
    int slen = sizeof(sin);
    int cb = 0;

    BYTE abRecv[1500];
    BYTE abAnswer[12] = {0xC0, 0xC, 0, 1, 0, 1, 0, 0, 0xA, 0, 0, 4 };

    while (cb != SOCKET_ERROR)
    {
        DWORD dwRes = WaitForSingleObject(hReady, INFINITE);
        if(InterlockedCompareExchange(&args->dwSignal, 0, 0))       // External exit condition.
            break;
        if(dwRes == WAIT_TIMEOUT)
            continue;
        
        cb = recvfrom(mySock, (char *)abRecv, sizeof(abRecv) - 16, 0,
                      (struct sockaddr *)&sin, &slen);

        if (cb == SOCKET_ERROR)
        {
            err = WSAGetLastError();
            ResetEvent(hReady);
            if(err == WSAEWOULDBLOCK || err == WSAECONNRESET)	// Last one is if the send failed indicating a hard/abortive reset by the target
            {
                cb = 0;

                continue;
            }
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Failed recvfrom.\n");
            cb = 0;

            continue;
        }

        CDnsHdr * pdnshdr = (CDnsHdr *)abRecv;
        DumpDns(pdnshdr, cb);

        if (pdnshdr->_cQd != htons(1))
            continue;

        char * pbName = (char *)(pdnshdr + 1);

        ULONG ulAddr = 0;

        CNameInfo * pinfo = gNames;

        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_INFORMATION, "%s [RESPONSE] for %s", GetTime(), CleanName(pbName));
        for (UINT i = 0; i < gNameCount; i++, pinfo++)
        {
            // Make sure I'm not going to attempt to read over the size of the data in the udp packet
            if (pinfo->_dwHostLen <= cb - sizeof(CDnsHdr) - 1 && 
                strlen(pbName) >= pinfo->_dwHostLen && 
                _strnicmp(pbName, pinfo->_pchHostName, pinfo->_dwHostLen) == 0)
            {
	            BYTE * pbAddr = (BYTE *)&pinfo->_ulAddr;
				
				LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_INFORMATION, " as %s (%d.%d.%d.%d) sent to %d.%d.%d.%d\n", 
					CleanName(pinfo->_pchHostName), pbAddr[0], pbAddr[1], pbAddr[2], pbAddr[3],
					sin.sin_addr.S_un.S_un_b.s_b1, sin.sin_addr.S_un.S_un_b.s_b2, sin.sin_addr.S_un.S_un_b.s_b3, sin.sin_addr.S_un.S_un_b.s_b4);
                ulAddr = pinfo->_ulAddr;
                break;
            }
        }

        if (ulAddr == 0)
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_INFORMATION, " not found.\n");
            continue;
        }
        pdnshdr->_wFlags |= htons(DNSF_RESPONSE);
        pdnshdr->_cAn = htons(1);

        BYTE * pbAnswer = abRecv + cb;
        memcpy(pbAnswer, abAnswer, sizeof(abAnswer));
        pbAnswer += sizeof(abAnswer);
        *(ULONG *)pbAnswer = ulAddr;

        cb = sendto(mySock, (char *)abRecv, cb + 16, 0,
                    (struct sockaddr *)&sin, slen);
        if (cb == SOCKET_ERROR)
        {
            err = WSAGetLastError();
            if(err == WSAEWOULDBLOCK)
            {
                cb = 0;
                continue;
            }
            
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Failed sendto.\n");
            // break;
        }
        cb = 0;
    }

    // LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "socket error %d\n", err = WSAGetLastError());

    Uninitialize();
    return (DWORD) err;
}

int __cdecl wmain(int argc, WCHAR * argv[])
{
	// Do a check here for service control commands to install or uninstall
    bool fUseReg = false;
    DWORD dwArgStart = 1;
    
    SERVICE_TABLE_ENTRY ste[] = 
        {
            {VER_SERVICENAME_STR, ServiceMain},
            {0, 0}
        };

    // Do some mutual initialization.
    InitializeEventSource();
    
    if(!StartServiceCtrlDispatcher(ste))
    {
        DWORD err = GetLastError();
        if(err != ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Main: error from StartServiceCtrlDispatcher %u\n", err);
            return 1;
        }
    }
    else
    {
        // If running as a service, it looks like StartServiceCtrlDispatcher never returns (unless there is an error)
        // so this code never seems to be reached, but just in case...
        g_IsService = true;
        return 0;
    }    
    
	if(argc < 2)
	{
		Syntax();
		return 1;
	}
	
 	if( !_wcsicmp(argv[1], L"-i") || !_wcsicmp(argv[1], L"-install"))
	{
        return ServiceInstall();
	}
	else if(!_wcsicmp(argv[1], L"-u") || !_wcsicmp(argv[1], L"-uninstall"))
	{
        RegDeleteKey(HKEY_LOCAL_MACHINE, DNSD_REGKEY);
        return ServiceUninstall();
	}
    else if(!_wcsicmp(argv[1], L"-a") || !_wcsicmp(argv[1], L"-add"))
    {
        dwArgStart++;
        fUseReg = true;
        ServiceArgs s = 
                {
                    dwArgStart,
                    (DWORD) argc,
                    argv,
                    0,
                    fUseReg
                };
        if(ParseArgs(&s))
            return 1;
        RewriteRegistry();
        Uninitialize();
        return 0;
    }
    else if(!_wcsicmp(argv[1], L"-d") || !_wcsicmp(argv[1], L"-delete"))
    {
        // TODO: Implement delete
        puts("Delete is not implemented yet.");
        return 0;
    }
    else if(!_wcsicmp(argv[1], L"-c") || !_wcsicmp(argv[1], L"-clear"))
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE, DNSD_REGKEY);
        dwArgStart++;
        return 0;
    }
    else if(!_wcsicmp(argv[1], L"-r") || !_wcsicmp(argv[1], L"-registry"))
    {
        dwArgStart++;
        fUseReg = true;
    }
    else if(!_wcsicmp(argv[1], L"-l") || !_wcsicmp(argv[1], L"-list"))
    {
        dwArgStart++;
        fUseReg = true;
        ServiceArgs s = 
                {
                    dwArgStart,
                    (DWORD) argc,
                    argv,
                    0,
                    fUseReg
                };
        if(ParseArgs(&s))
            return 1;
        Uninitialize();
        return 0;
    }

    ServiceArgs s = 
            {
                dwArgStart,
                (DWORD) argc,
                argv,
                0,
                fUseReg
            };

    DWORD res = Initialize(&s);
    if(res != 0)
        return res;
    res = MainThread(&s);
    return (int) res;
}


void Syntax()
{
    puts("usage: dnsd <servicearg>");
    puts("       dnsd <regarg> [<dnsprefix>:<ip>]+");
    puts("       dnsd [<dnsprefix>:<ip>]+");
    puts("\t<servicearg>: -i[nstall] to install service");
    puts("\t              -u[ninstall] to uninstall");
    puts("\t<regarg>: -a[dd] to add ip mappings to the registry");
    puts("\t          -d[elete] to remove specific entries (unimplemented)");
    puts("\t          -c[lear] to remove all entries");
    puts("\t          -l[ist] to list all entries");
    puts("\t          -r[egistry] to run from the command line using the registry values");
    puts("\tOption 3 runs strictly as command line without using the registry values");
    puts("\t<dnsprefix>: DNS prefix to match such as xemacs, xeas, xetgs, and xexds");
    puts("\t             use xemacs.part.xboxlive.com. (with trailing dot) to match a full name");
    puts("\t<ip>: IP address to map the prefix to");
    puts("\tNote: Entering xemacs:<ip> and xemacs.part:<ip> will match most specific first");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\parser\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dnsd\service.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    service.cpp

Abstract:

    Routines for handling the NT service framework

Author:

    jpoley

*/

#include "dnsd.h"
#include <winsock2.h>
#include <winsvc.h>

static ServiceArgs g_ServiceArgs;

SERVICE_STATUS_HANDLE volatile statusHandle = NULL;
DWORD volatile currentStatus = SERVICE_STOPPED;
HANDLE hMainThread = NULL;

DWORD StopService( SC_HANDLE hSCM, SC_HANDLE hService, BOOL fStopDependencies, DWORD dwTimeout );

/*****************************************************************************

Routine Description:

    ServiceMain

    Registers the ServiceHandler and attempts to start the service

Arguments:

    DWORD argc, char* argv[] - main style arguments 

Return Value:

    void

*****************************************************************************/

void WINAPI ServiceMain(DWORD argc, WCHAR* argv[])
{
    DWORD error;
    SERVICE_STATUS status;
    g_ServiceArgs.dwArgStart = 1;
    g_ServiceArgs.dwCount = argc;
    g_ServiceArgs.pszArgs = argv;
    g_ServiceArgs.dwSignal = 0;
    g_ServiceArgs.fUseReg = true;

    g_IsService = true;
    statusHandle = RegisterServiceCtrlHandler(VER_SERVICENAME_STR, &ServiceHandler);
    if(statusHandle == NULL)
    {
        error = GetLastError();
        if(error == 0)
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_WARNING, "Error from RegisterServiceCtrlHandler.  SCM may have given up running this service (such as if a debugger session was started) causing this failure.");
        }
        else
        {
            LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Error from RegisterServiceCtrlHandler: %u", error);
        }
        return;
    }
    
    DWORD res = Initialize(&g_ServiceArgs);

    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    status.dwCurrentState = currentStatus = (res) ? SERVICE_STOPPED : SERVICE_START_PENDING;
    status.dwControlsAccepted = (res) ? 0 : SERVICE_ACCEPT_STOP;
    status.dwWin32ExitCode = res;
    status.dwServiceSpecificExitCode = res;
    status.dwCheckPoint = 0;
    status.dwWaitHint = 0;
    SetServiceStatus(statusHandle, &status);

    if(res)
        return;

    hMainThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) MainThread, &g_ServiceArgs, 0, NULL);

    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    status.dwCurrentState = currentStatus = SERVICE_RUNNING;
    status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    status.dwWin32ExitCode = 0;
    status.dwServiceSpecificExitCode = 0;
    status.dwCheckPoint = 0;
    status.dwWaitHint = 0;
    SetServiceStatus(statusHandle, &status);
}

/*****************************************************************************

Routine Description:

    ServiceHandler

    Handles the stop and interrogate messages from the system

Arguments:

    DWORD fdwControl - Service control code

Return Value:

    void

*****************************************************************************/
extern WSAEVENT hReady;

void WINAPI ServiceHandler(DWORD fdwControl)
{
    SERVICE_STATUS status;

    switch(fdwControl)
    {
        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:
        {
            status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
            status.dwCurrentState = currentStatus = SERVICE_STOP_PENDING;
            status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
            status.dwWin32ExitCode = 0;
            status.dwServiceSpecificExitCode = 0;
            status.dwCheckPoint = 0;
            status.dwWaitHint = 0;
            SetServiceStatus(statusHandle, &status);

            // signal the main thread to close everything down
            InterlockedIncrement(&g_ServiceArgs.dwSignal);
            // Signal to get the loop to stop
            SetEvent(hReady);

            // wait for it...
            WaitForSingleObject(hMainThread, INFINITE);
            CloseHandle(hMainThread);
            hMainThread = NULL;

            status.dwCurrentState = currentStatus = SERVICE_STOPPED;
            status.dwWin32ExitCode = 0;
            status.dwCheckPoint = 0;
            status.dwWaitHint = 0;
            SetServiceStatus(statusHandle, &status);
            break;
        }

        // return the current state of the service
        case SERVICE_CONTROL_INTERROGATE:
        default:
        {
            status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
            status.dwCurrentState = currentStatus;
            status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
            status.dwWin32ExitCode = 0;
            status.dwServiceSpecificExitCode = 0;
            status.dwCheckPoint = 0;
            status.dwWaitHint = 0;
            SetServiceStatus(statusHandle, &status);
            break;
        }
    }

    return;
}


/*****************************************************************************

Routine Description:

    ServiceInstall

    Removes the service from the Services control panel list

Arguments:

    void

Return Value:

    DWORD   win32 error code

*****************************************************************************/
DWORD ServiceInstall(void)
    {
    DWORD error = 0;

    printf("Installing Service...\n");
    SC_HANDLE handle = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if(handle == NULL)
        {
        error = GetLastError();
        printf("Install Error during OpenSCManager %u\n", error);
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Install Error during OpenSCManager %u", error);
        return error;
        }

    // get the location of the exe
    WCHAR moduleName[MAX_PATH+1];
    WCHAR filePath[MAX_PATH+3];
    GetModuleFileNameW(NULL, moduleName, ARRAYSIZE(moduleName));
    wsprintf(filePath, L"\"%s\"", moduleName);

    WCHAR *user = NULL; // NULL for LocalSystem
    WCHAR *pw = L"";    // "" for empty or when user==NULL
    SC_HANDLE service = CreateService(handle, VER_SERVICENAME_STR, VER_SERVICEDISPLAYNAME_STR, GENERIC_READ | GENERIC_EXECUTE, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, filePath, NULL, NULL, NULL, user, pw);
    if(service == NULL)
        {
        error = GetLastError();
        printf("Install Error during CreateService %u\n", error);
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Install Error during CreateService %u", error);
        }
    else
        {
        printf("Install Successful\n");
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_SUCCESS, "Service Installed Successfully");
        }

    CloseServiceHandle(service);
    CloseServiceHandle(handle);

    return error;
    }

/*****************************************************************************

Routine Description:

    ServiceUninstall

    Removes the service from the Services control panel list

Arguments:

    void

Return Value:

    DWORD   win32 error code

*****************************************************************************/
DWORD ServiceUninstall(void)
    {
    DWORD error = 0;

    printf("Uninstalling Service...\n");
    SC_HANDLE handle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if(handle == NULL)
        {
        error = GetLastError();
        printf("Uninstall Error during OpenSCManager %u\n", error);
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Uninstall Error during OpenSCManager %u", error);
        return error;
        }

    // open a handle to the service
    SC_HANDLE service = OpenService(handle, VER_SERVICENAME_STR, DELETE);
    if(service == NULL)
        {
        error = GetLastError();
        printf("Uninstall Error during OpenService %u\n", error);
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Uninstall Error during OpenService %u", error);
        CloseServiceHandle(handle);
        return error;
        }

    // uninstall the service
    if(! DeleteService(service))
        {
        error = GetLastError();
        printf("Uninstall Error during DeleteService %u\n", error);
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Uninstall Error during DeleteService %u", error);
        }
    else
        {
        printf("Uninstall Successful\n");
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_SUCCESS, "Service Uninstalled Successfully");
        }

    CloseServiceHandle(service);
    CloseServiceHandle(handle);
    return error;
    }



/*****************************************************************************

Routine Description:

    ServiceRestart

    Attempts to stop then start the service

Arguments:

    void

Return Value:

    DWORD   win32 error code

*****************************************************************************/
DWORD ServiceRestart(void)
    {
    DWORD error = 0;

    LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_INFORMATION, "Attempting to restart the service");

    // In the case we get here via an unhandled exception, 
    // allow the original process time to exit
    Sleep(1000);
    
    SC_HANDLE handle = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if(handle == NULL)
        {
        error = GetLastError();
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Unable to restart service. OpenSCManager error %u", error);
        return error;
        }

    SC_HANDLE service = OpenService(handle, VER_SERVICENAME_STR, SERVICE_START|SERVICE_STOP);
    if(service == NULL)
        {
        error = GetLastError();
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Unable to restart service. OpenService error %u", error);
        CloseServiceHandle(handle);
        return error;
        }

    StopService(handle, service, TRUE, 5*1000);
    // we dont care if the stop failed (as it might not have been running in the first place)

    if(!StartService(service, 0, NULL))
        {
        error = GetLastError();
        LogEvent(__FUNCTION__, __FILE__, __LINE__, DNSD_EVENT_ERROR, "Unable to restart service. StartService error %u", error);
        }

    CloseServiceHandle(service);
    CloseServiceHandle(handle);

    return error;
    }



/*****************************************************************************

Routine Description:

    StopService

    This function attempts to stop a service. It allows the caller to 
    specify whether dependent services should also be stopped. It also 
    accepts a timeout value, to prevent a scenario in which a service 
    shutdown hangs, then the application stopping the service hangs.

Arguments:

    hSCM - Handle to the service control manager.
    hService - Handle to the service to be stopped.
    fStopDependencies - Indicates whether to stop dependent services.
    dwTimeout - maximum time (in milliseconds) to wait

Return Value:

    DWORD   win32 error code

*****************************************************************************/
DWORD StopService( SC_HANDLE hSCM, SC_HANDLE hService, BOOL fStopDependencies, DWORD dwTimeout ) 
{
   SERVICE_STATUS ss;
   DWORD dwStartTime = GetTickCount();

   // Make sure the service is not already stopped
   if ( !QueryServiceStatus( hService, &ss ) )
      return GetLastError();

   if ( ss.dwCurrentState == SERVICE_STOPPED ) 
      return ERROR_SUCCESS;

   // If a stop is pending, just wait for it
   while ( ss.dwCurrentState == SERVICE_STOP_PENDING ) 
   {
      Sleep( ss.dwWaitHint );
      if ( !QueryServiceStatus( hService, &ss ) )
         return GetLastError();

      if ( ss.dwCurrentState == SERVICE_STOPPED )
         return ERROR_SUCCESS;

      if ( GetTickCount() - dwStartTime > dwTimeout )
         return ERROR_TIMEOUT;
   }

   // If the service is running, dependencies must be stopped first
   if ( fStopDependencies ) 
   {
      DWORD i;
      DWORD dwBytesNeeded;
      DWORD dwCount;

      LPENUM_SERVICE_STATUS   lpDependencies = NULL;
      ENUM_SERVICE_STATUS     ess;
      SC_HANDLE               hDepService;

      // Pass a zero-length buffer to get the required buffer size
      if ( EnumDependentServices( hService, SERVICE_ACTIVE, 
         lpDependencies, 0, &dwBytesNeeded, &dwCount ) ) 
      {
         // If the Enum call succeeds, then there are no dependent
         // services so do nothing
      } 
      else 
      {
         if ( GetLastError() != ERROR_MORE_DATA )
            return GetLastError(); // Unexpected error

         // Allocate a buffer for the dependencies
         lpDependencies = (LPENUM_SERVICE_STATUS) HeapAlloc( 
               GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytesNeeded );

         if ( !lpDependencies )
            return GetLastError();

         __try {
            // Enumerate the dependencies
            if ( !EnumDependentServices( hService, SERVICE_ACTIVE, 
                  lpDependencies, dwBytesNeeded, &dwBytesNeeded,
                  &dwCount ) )
               return GetLastError();

            for ( i = 0; i < dwCount; i++ ) 
            {
               ess = *(lpDependencies + i);

               // Open the service
               hDepService = OpenService( hSCM, ess.lpServiceName, 
                     SERVICE_STOP | SERVICE_QUERY_STATUS );
               if ( !hDepService )
                  return GetLastError();

               __try {
                   // Send a stop code
                  if ( !ControlService( hDepService, 
                           SERVICE_CONTROL_STOP,
                           &ss ) )
                     return GetLastError();

                  // Wait for the service to stop
                  while ( ss.dwCurrentState != SERVICE_STOPPED ) 
                  {
                      Sleep( ss.dwWaitHint );
                     if ( !QueryServiceStatus( hDepService, &ss ) )
                        return GetLastError();

                     if ( ss.dwCurrentState == SERVICE_STOPPED )
                        break;

                     if ( GetTickCount() - dwStartTime > dwTimeout )
                        return ERROR_TIMEOUT;
                  }

               } 
               __finally 
               {
                  // Always release the service handle
                  CloseServiceHandle( hDepService );
               }
            }

         } 
         __finally 
         {
            // Always free the enumeration buffer
            HeapFree( GetProcessHeap(), 0, lpDependencies );
         }
      } 
   }

   // Send a stop code to the main service
   if ( !ControlService( hService, SERVICE_CONTROL_STOP, &ss ) )
      return GetLastError();

   // Wait for the service to stop
   while ( ss.dwCurrentState != SERVICE_STOPPED ) 
   {
      Sleep( ss.dwWaitHint );
      if ( !QueryServiceStatus( hService, &ss ) )
         return GetLastError();

      if ( ss.dwCurrentState == SERVICE_STOPPED )
         break;

      if ( GetTickCount() - dwStartTime > dwTimeout )
         return ERROR_TIMEOUT;
   }

   // Return success
   return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\dnsd\events.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    events.cpp

Abstract:

    Utilities for event logging, along with exception handling and 
    other errors

Author:

    jpoley

*/
#include "dnsd.h"

static BOOL GetLogicalAddress(void* addr, char* szModule, DWORD len, DWORD &section, DWORD &offset);
static CHAR* __stdcall GetExceptionString(DWORD dwCode);

/*****************************************************************************

Routine Description:

    InitializeEventSource

    Adds the necessary registry entries so the event viewer can locate the
    event content

Arguments:

    none

Return Value:

    none

*****************************************************************************/
void InitializeEventSource(void)
    {
    HKEY hKey;
    LONG err;
    DWORD dwVal;
    WCHAR fullPath[MAX_PATH];
    DWORD pathLen;
    DWORD openState = 0;

    GetModuleFileName(NULL, fullPath, MAX_PATH);
    pathLen = wcslen(fullPath);
    
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, EVENTLOGPATH, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &openState);
    if(err != ERROR_SUCCESS)
        {
        return;
        }

    RegSetValueEx(hKey, L"CategoryMessageFile", 0, REG_SZ, (const BYTE*)fullPath, pathLen);
    RegSetValueEx(hKey, L"EventMessageFile", 0, REG_SZ, (const BYTE*)fullPath, pathLen);
    RegSetValueEx(hKey, L"ParameterMessageFile", 0, REG_SZ, (const BYTE*)fullPath, pathLen);

    dwVal = 1; // NOTE: if more categories are added to the .mc file, update this value
    RegSetValueEx(hKey, L"CategoryCount", 0, REG_DWORD, (const BYTE*)&dwVal, sizeof(dwVal));

    dwVal = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE | DNSD_EVENT_SUCCESS;
    RegSetValueEx(hKey, L"TypesSupported", 0, REG_DWORD, (const BYTE*)&dwVal, sizeof(dwVal));

    RegCloseKey(hKey);
    }

/*****************************************************************************

Routine Description:

    LogEvent

    Add an entry to the Application Event Log.

Arguments:

    char *functName
    char *fileName
    unsigned lineNumber
    DWORD eventID
    char *format
    ...

Return Value:

    DWORD       Win32 error

*****************************************************************************/
DWORD LogEvent(char *functName, char *fileName, unsigned lineNumber, DWORD eventID, CHAR *format, ...)
{
    va_list args;
    CHAR szNotes[256];
    CHAR szSource[140];

    szNotes[0] = 0;

    if(format)
    {
        va_start(args, format);
        _vsnprintf(szNotes, ARRAYSIZE(szNotes) - 1, format, args);
        va_end(args);
    }
    szNotes[ARRAYSIZE(szNotes) - 1] = 0;

    _snprintf(szSource, ARRAYSIZE(szSource) - 1, "%s(%u): %s", fileName, lineNumber, functName);
    szSource[ARRAYSIZE(szSource) - 1] = 0;
    
    CHAR *eventStrings[] = { szNotes };

    // set the appropriate entry severity
    WORD status = EVENTLOG_INFORMATION_TYPE;
    DWORD severity = eventID >> 28;
    if(severity == 0x0) status = EVENTLOG_SUCCESS;
    else if(severity == 0x4) status = EVENTLOG_INFORMATION_TYPE;
    else if(severity == 0x8) status = EVENTLOG_WARNING_TYPE;
    else if(severity == 0xC) status = EVENTLOG_ERROR_TYPE;

    // add the entry to the event log
    if(g_IsService)
    {
        HANDLE hEventLog = RegisterEventSource(NULL, EVENTSOURCE);
        if(hEventLog)
        {
            // submit the event to the event log
            ReportEventA(hEventLog, status, DNSD_EVENT_CATEGORY, eventID, NULL, ARRAYSIZE(eventStrings), (DWORD)strlen(szSource), (LPCSTR*)eventStrings, szSource);
            DeregisterEventSource(hEventLog);
            return 0;
        }
    }
    else
    {
        if(status == EVENTLOG_ERROR_TYPE)
        {
            printf("Failure at: %s\n", szSource);
        }
        puts(szNotes);
    }

    return GetLastError();
}

/*****************************************************************************

Routine Description:

    LogExceptionPointers

    Calls into LogEvent, but adds in information pulled from the SEH 
    execption pointers.

Arguments:

    _EXCEPTION_POINTERS *exceptionInfo
    char *functName
    char *fileName
    unsigned lineNumber
    DWORD eventID
    char *format
    ...

Return Value:

    DWORD       Win32 error

*****************************************************************************/
DWORD LogExceptionPointers(_EXCEPTION_POINTERS *exceptionInfo, char *functName, char *fileName, unsigned lineNumber, DWORD eventID, char *format, ...)
{
    va_list args;
    CHAR szMessage[50];
    szMessage[0] = 0;

    if(format)
    {
        va_start(args, format);
        _vsnprintf(szMessage, ARRAYSIZE(szMessage) - 1, format, args);
        va_end(args);
    }
    szMessage[ARRAYSIZE(szMessage) - 1] = 0;

    char szFaultingModule[MAX_PATH];
    DWORD section, offset;

    GetLogicalAddress(exceptionInfo->ExceptionRecord->ExceptionAddress, szFaultingModule, sizeof(szFaultingModule), section, offset);

    // print information about the type of fault + where the fault occured
    return LogEvent(functName, fileName, lineNumber, eventID, "%s:\nException code: 0x%08X %s\nFault address: 0x%08X 0x%02X:0x%08X\nIn: %s",
        szMessage, exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode),
        exceptionInfo->ExceptionRecord->ExceptionAddress, section, offset, szFaultingModule);
}

/*****************************************************************************

Object Description:

    StructuredException

    Class to wrap a the SEH information, this allows for easy translation
    between SEH and C++ exceptions

*****************************************************************************/
class StructuredException
    {
    public:
        unsigned int error;
        _EXCEPTION_POINTERS* exp;

    public:
        StructuredException() { exp = NULL; error = 0; }
        StructuredException(StructuredException& se) { error = se.error; exp = se.exp; }
        StructuredException(unsigned n, _EXCEPTION_POINTERS* p) { error=n; exp=p; }
        ~StructuredException() { exp = NULL; error = 0; }
    };

/*****************************************************************************

Routine Description:

    SEH_Handler

    Translator from SEH into C++ land

Arguments:

    unsigned u
    _EXCEPTION_POINTERS *exceptionInfo

Return Value:

    none

Thrown Values:

    StructuredException

*****************************************************************************/
void __cdecl SEH(unsigned int u, _EXCEPTION_POINTERS* exceptionInfo)
    {
    StructuredException err(u, exceptionInfo);
    throw err;
    }

/*****************************************************************************

Routine Description:

    GetLogicalAddress

    Parses the header and locates where (section:offset) the crash originated

Arguments:

    void* addr      IN  location of error
    char* szModule  OUT name of the module
    DWORD len       IN  buffer size of szModule
    DWORD &section  OUT section address
    DWORD &offset   OUT offset in section

Return Value:

    BOOL

*****************************************************************************/
static BOOL GetLogicalAddress(void* addr, CHAR* szModule, DWORD len, DWORD &section, DWORD &offset)
    {
    MEMORY_BASIC_INFORMATION mbi;
    DWORD hMod;

    if(!VirtualQuery(addr, &mbi, sizeof(mbi))) return FALSE;

    hMod = (DWORD)mbi.AllocationBase;

    if(!GetModuleFileNameA((HMODULE)hMod, szModule, len))
        return FALSE;

    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)hMod;

    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION( pNtHdr );
    DWORD rva = (DWORD)addr - hMod; // RVA is offset from module load address

    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for(unsigned i = 0; i < pNtHdr->FileHeader.NumberOfSections; i++, pSection++)
        {
        DWORD sectionStart = pSection->VirtualAddress;
        DWORD sectionEnd = sectionStart + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);

        // Is the address in this section???
        if((rva >= sectionStart) && (rva <= sectionEnd))
            {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            section = i+1;
            offset = rva - sectionStart;
            return TRUE;
            }
        }

    return FALSE;
    }

/*****************************************************************************

Routine Description:

    Returns the name of the given exception code, for example, it will
    return "ACCESS_VIOLATION" when passed the EXCEPTION_ACCESS_VIOLATION
    value.

Arguments:

    DWORD dwCode - exception code

Return Value:

    char* to a static data buffer

*****************************************************************************/
CHAR* __stdcall GetExceptionString(DWORD dwCode)
{
    #define EXCEPTION_CASE( x ) case EXCEPTION_##x: return #x;

    switch(dwCode)
        {
        EXCEPTION_CASE( ACCESS_VIOLATION )
        EXCEPTION_CASE( DATATYPE_MISALIGNMENT )
        EXCEPTION_CASE( BREAKPOINT )
        EXCEPTION_CASE( SINGLE_STEP )
        EXCEPTION_CASE( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION_CASE( FLT_DENORMAL_OPERAND )
        EXCEPTION_CASE( FLT_DIVIDE_BY_ZERO )
        EXCEPTION_CASE( FLT_INEXACT_RESULT )
        EXCEPTION_CASE( FLT_INVALID_OPERATION )
        EXCEPTION_CASE( FLT_OVERFLOW )
        EXCEPTION_CASE( FLT_STACK_CHECK )
        EXCEPTION_CASE( FLT_UNDERFLOW )
        EXCEPTION_CASE( INT_DIVIDE_BY_ZERO )
        EXCEPTION_CASE( INT_OVERFLOW )
        EXCEPTION_CASE( PRIV_INSTRUCTION )
        EXCEPTION_CASE( IN_PAGE_ERROR )
        EXCEPTION_CASE( ILLEGAL_INSTRUCTION )
        EXCEPTION_CASE( NONCONTINUABLE_EXCEPTION )
        EXCEPTION_CASE( STACK_OVERFLOW )
        EXCEPTION_CASE( INVALID_DISPOSITION )
        EXCEPTION_CASE( GUARD_PAGE )
        EXCEPTION_CASE( INVALID_HANDLE )
        default:
            break;
        }

    #undef EXCEPTION_CASE

    return "Unknown Error";
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\parser\main.cs ===
//Utility to parse out kdcsvc eventlog logs from ops.

using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;

namespace ServerEventparse
{
    //event info
    public class ServerEvent
    {
        public uint eventID;
        public string component; //xmacs, askdc, webstore, etc
        public string level;

        public string messageSample="";
        public bool IsSimilarTo(ServerEvent o)
        {
            return eventID==o.eventID &&
                   component==o.component &&
                   level==o.level;
        }
    };

    //time that en event occured
    public class EventTime
    {
        public uint year;
        public uint month;
        public uint day;
        public uint hour;

        public static int CompareTime(EventTime es1, EventTime es2)
        {
            return CompareTime(es1,es2,true);
        }
        public static int CompareTime(EventTime es1, EventTime es2, bool doHour)
        {
            int cmp=es1.year.CompareTo(es2.year);
            if (cmp!=0) return cmp;

            cmp=es1.month.CompareTo(es2.month);
            if (cmp!=0) return cmp;

            cmp=es1.day.CompareTo(es2.day);
            if (cmp!=0) return cmp;

            if (doHour)
            {
                cmp=es1.hour.CompareTo(es2.hour);
                return cmp;
            }
            else
                return cmp;
        }

        public DateTime GetDate()
        {
            return new DateTime((int)year, (int)month, (int)day, (int)hour, 0, 0, 0);
        }
    };

    //count of events that happened in a specific time
    public class EventCount: EventTime
    {
        public ServerEvent evnt;
        public ulong count;
    };

    //event over some period of time
    public class EventSpan
    {
        public ServerEvent evnt;
        public ulong count;
        public List<EventCount> parts=new List<EventCount>(); //sub-units that make up this unit

        public static int CompareCount(EventSpan e1, EventSpan e2)
        {
            return -e1.count.CompareTo(e2.count);
        }
    };

    //a collection of EventCount's
    public class EventCountCollection
    {
        LinkedList<EventCount> list=new LinkedList<EventCount>();

        //Adds an occurance of an event to the collection
        public void AddOccurance(uint year, uint month, uint day, uint hour, ServerEvent evt)
        {
            //add to existing
            ServerEvent similarEvent=evt;
            int searchIters=0;
            foreach (EventCount eh in list)
            {
                if (evt.IsSimilarTo(eh.evnt))
                {
                    similarEvent=eh.evnt;

                    if (year==eh.year && month==eh.month && day==eh.day && hour==eh.hour)
                    {
                        //update to latest text and inc count
                        ++eh.count;
                        eh.evnt.messageSample=evt.messageSample;

                        //if it was deeper in, move it to the front of the list so groups of similar events process faster
                        if (searchIters>=8)
                        {
                            list.Remove(eh);
                            list.AddFirst(eh);
                        }

                        return;
                    }
                }

                ++searchIters;
            }

            //add new
            EventCount neweh=new EventCount();
            neweh.evnt=similarEvent;
            neweh.year=year;
            neweh.month=month;
            neweh.day=day;
            neweh.hour=hour;
            neweh.count=1;
            list.AddFirst(neweh);
        }

        public List<EventSpan> GetEventsForAllHours()
        {
            //collect them up
            List<EventSpan> spanlist=new List<EventSpan>();

            foreach (EventCount eh in list)
            {
                //see if we already have this event and add it if not
                EventSpan span=null;
                foreach (EventSpan es in spanlist)
                {
                    if (eh.evnt==es.evnt)
                    {
                        es.count+=eh.count;
                        span=es;
                        break;
                    }
                }

                if (span==null)
                {
                    EventSpan es=new EventSpan();
                    es.count=eh.count;
                    es.evnt=eh.evnt;
                    spanlist.Add(es);
                    span=es;
                }

                //now add it to that specific hour
                bool needAddEvent=true;
                foreach (EventCount ec in span.parts)
                {
                    if (eh.year==ec.year && eh.month==ec.month && eh.day==ec.day && eh.hour==ec.hour)
                    {
                        needAddEvent=false;
                        ec.count+=eh.count;
                        break;
                    }
                }

                if (needAddEvent)
                {
                    EventCount ec=new EventCount();
                    ec.evnt=eh.evnt;
                    ec.count=eh.count;
                    ec.year=eh.year;
                    ec.month=eh.month;
                    ec.day=eh.day;
                    ec.hour=eh.hour;

                    span.parts.Add(ec);
                }
            }

            //sort the list by count, and the sub-parts by time
            spanlist.Sort(EventSpan.CompareCount);

            for (int sl=0; sl<spanlist.Count; ++sl)
                    spanlist[sl].parts.Sort(EventCount.CompareTime);

            return spanlist;
        }
    };

    //main app
    class main
    {
        public static DateTime DateNow;
        public static int DayCount=99999;

        //writes a string to a file
        public static void WriteString(System.IO.FileStream f, string s)
        {
            byte []grr=new byte[s.Length];
            for (int i=0; i<s.Length; ++i)
                grr[i]=(byte)s[i];

            f.Write(grr,0,grr.Length);
        }

        //main func
        static void Main(string[] args)
        {
            //hrelp
            if (args.Length<4 || args.Length>5)
            {
                Console.WriteLine("Bad number of arguments.\n");

                Console.WriteLine("parameters: ServerString Mode Source DBServer [Daycount]");
                Console.WriteLine("  ServerString: A substring of the server name to match against or *");
                Console.WriteLine("  Mode: One of: single allzip alltxt");
                Console.WriteLine("    single - Source is the name of a single .txt or .zip file");
                Console.WriteLine("    alltxt - Source is the path containing .txt files to process");
                Console.WriteLine("    allzip - Source is the path containing .zip files to process");
                Console.WriteLine("  DBServer - The name or ip of the server to log to");
                Console.WriteLine("  Daycount - (optional) The number of days going back from today to process");
                Console.WriteLine("");
                Console.WriteLine(".zip files should contain a file that partially matches the server string.");
                Console.WriteLine("");
                Console.WriteLine("Network paths (ie: \\\\box1\\log.txt) will not work.  You must map them to a drive.");
                Console.WriteLine("");
                Console.WriteLine("example:  eventparse xexmacinh single z:\\log.txt devbox");
                Console.WriteLine("example:  eventparse * allzip T:\\ mydevmachine 10");
                return;
            }

            DateNow=System.DateTime.Now;
            System.DateTime DateNowMinusOne=DateNow-new System.TimeSpan(1,0,0,0);

            //process commandline
            LinkedList<System.IO.FileInfo> fileList=new LinkedList<System.IO.FileInfo>();
            string serverNameMatch=args[0];

            {
                if (args[1]=="single")
                    fileList.AddLast(new System.IO.FileInfo(args[2]));
                else if (args[1]=="allzip")
                {
                    System.IO.DirectoryInfo di=new System.IO.DirectoryInfo(args[2]);
                    System.IO.FileInfo []fiList=di.GetFiles("*.zip");
                    foreach (System.IO.FileInfo fi in fiList)
                        fileList.AddLast(fi);
                }
                else if (args[1]=="alltxt")
                {
                    System.IO.DirectoryInfo di=new System.IO.DirectoryInfo(args[2]);
                    System.IO.FileInfo []fiList=di.GetFiles("*.txt");
                    foreach (System.IO.FileInfo fi in fiList)
                        fileList.AddLast(fi);
                }
                else
                {
                    Console.WriteLine("unknown mode: "+args[1]);
                    return;
                }
            }

            string outDatabaseServer=args[3];

            DayCount=999999;
            if (args.Length>4)
            {
                DayCount=int.Parse(args[4]);

                //prune files more than a day off from the files list
                if (fileList.Count>1)
                {
                    LinkedList<System.IO.FileInfo> filteredFileList=new LinkedList<System.IO.FileInfo>();

                    foreach (System.IO.FileInfo fi in fileList)
                    {
                        //parse year-month-day-hour format, and if we don't understand it, just leave it in the list to be safe
                        try
                        {
                            string []parts=fi.Name.Split(new char[]{'-'});
                            int year=int.Parse(parts[0]);
                            int month=int.Parse(parts[1]);
                            int day=int.Parse(parts[2]);

                            System.DateTime fileDate=new DateTime(year,month,day);

                            //if it was within dayCount+1 days, add it to the filtered list, since sometimes loglines spill over between days
                            if ((DateNowMinusOne-fileDate).TotalDays < DayCount)
                            {
                                filteredFileList.AddLast(fi);
                            }
                        }
                        catch
                        {
                            Console.WriteLine("Don't know how to parse filename for date, so including it to be safe: "+fi.Name);
                            filteredFileList.AddLast(fi);
                        }
                    }

                    fileList=filteredFileList;
                }
            }

            //prune files that the db says have already been processed
            SqlConnection con=new SqlConnection("Data Source="+outDatabaseServer+";Initial Catalog=EventCountDB;Integrated Security=SSPI;Connection Timeout=120");
            con.Open();
            bool changed=true;
            while (changed)
            {
                changed=false;
                foreach (System.IO.FileInfo sourceFileInfo in fileList)
                {
                    bool isAlreadyParsedToDB=HasDBIngestedFile(con, sourceFileInfo.Name);
                    if (isAlreadyParsedToDB)
                    {
                        fileList.Remove(sourceFileInfo);
                        changed=true;
                        break;
                    }
                }
            }
            con.Close();

            //process every file
            LinkedList<System.IO.FileInfo> usedFileList=new LinkedList<System.IO.FileInfo>();
            List<ServerEvent> events=new List<ServerEvent>();
            EventCountCollection EventCountList=new EventCountCollection();

            int fileProcessCount=0;
            foreach (System.IO.FileInfo soureFileInfo in fileList)
            {
                //progress indicator
                int progressPercent=100*fileProcessCount/fileList.Count;
                Console.Write(progressPercent+"% - ");

                ++fileProcessCount;

                //
                string sourcefname=soureFileInfo.FullName;

                //get the lines of text to process for this file
                //List<string> lines=new List<string>();

                if (sourcefname.EndsWith(".txt"))
                {
                    Console.WriteLine("Reading "+sourcefname+"...");
                    string []newLines=System.IO.File.ReadAllLines(sourcefname);
                    Console.WriteLine("Processing "+newLines.Length+" lines...");
                    ProcessData(newLines, events, EventCountList, sourcefname);
                    usedFileList.AddLast(soureFileInfo);
                }
                else if (sourcefname.EndsWith(".zip"))
                {
                    string tempdir="temp\\"+soureFileInfo.Name;

                    //unzip it to a temp local place
                    try
                    {
                        string sourceMatch;
                        if (serverNameMatch!="*")
                        {
                            sourceMatch="*"+serverNameMatch+"*";
                        }
                        else
                        {
                            sourceMatch="";
                        }

                        Console.WriteLine("Decompressing "+sourcefname+"...");
                        System.IO.Directory.CreateDirectory(tempdir);
                        System.Diagnostics.Process proc=new System.Diagnostics.Process();
                        proc.StartInfo.FileName="unzip";
                        proc.StartInfo.Arguments="-C -q -j -o \""+sourcefname+"\" "+sourceMatch+" -d \""+tempdir+"\"";
                        proc.StartInfo.CreateNoWindow=true;
                        proc.StartInfo.RedirectStandardOutput = true;
                        proc.StartInfo.RedirectStandardError = true;
                        proc.StartInfo.UseShellExecute=false;
                        proc.Start();
                        proc.WaitForExit();
                        if (proc.ExitCode!=0)
                        {
                            Console.WriteLine("Exit code says unzip failed.. skipping "+sourcefname+".  Arguments to unzip were: "+proc.StartInfo.Arguments);
                            continue;
                        }

                        usedFileList.AddLast(soureFileInfo);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Exception trying to unzip: "+e.Message+"\nWill skip "+sourcefname);
                        continue;
                    }

                    //read those appropriately named files
                    System.IO.DirectoryInfo di=new System.IO.DirectoryInfo(tempdir);
                    System.IO.FileInfo []fiList=di.GetFiles("*"+serverNameMatch+"*.Application.events.txt");
                    if (fiList.Length==0)
                    {
                        Console.WriteLine("No appropriately named files found in "+sourcefname);
                        continue;
                    }

                    Console.WriteLine("Processing lines from "+fiList.Length+" files...");

                    con=new SqlConnection("Data Source="+outDatabaseServer+";Initial Catalog=EventCountDB;Integrated Security=SSPI;Connection Timeout=120");
                    con.Open();

                    int linesProcced=0;
                    foreach (System.IO.FileInfo fi in fiList)
                    {
                        //verify that we haven't already processed a file with both this name and this timestamp before, and record that we have to the db.  This prevents us from ingesting duplicate data when old files are copied into the .zip files, which has been happening randomly lately.
                        string subfileTimeName="zip: "+fi.LastWriteTimeUtc+"*"+fi.Name;
                        if (HasDBIngestedFile(con, subfileTimeName))
                        {
                            continue;
                        }

                        MarkDBIngestedFile(con, subfileTimeName);

                        //process
                        string []newLines=System.IO.File.ReadAllLines(fi.FullName);
                        ProcessData(newLines, events, EventCountList, sourcefname+":"+fi.Name);
                        linesProcced+=newLines.Length;
                    }

                    con.Close();

                    Console.WriteLine(linesProcced+" lines processed.");

                    //delete the temp dir
                    System.IO.Directory.Delete(tempdir,true);
                }
                else
                {
                    Console.WriteLine("Skipping file (unknown extension): "+sourcefname);
                    continue;
                }
            }

            //build the "per hour" view
            Console.WriteLine("Collecting the per-hour data...");
            List<EventSpan> hourData=EventCountList.GetEventsForAllHours();

            //log the parsed files to the db
            if (fileList.Count==0)
            {
                Console.WriteLine("No files parsed to be added.");
                return;
            }

            Console.WriteLine("Writing "+usedFileList.Count+" parsed file(s) to DB...");
            con=new SqlConnection("Data Source="+outDatabaseServer+";Initial Catalog=EventCountDB;Integrated Security=SSPI;Connection Timeout=300");
            con.Open();

            foreach (System.IO.FileInfo sourceFileInfo in usedFileList)
            {
                MarkDBIngestedFile(con, sourceFileInfo.Name);
            }

            //log the events to the db
            if (hourData.Count==0)
            {
                Console.WriteLine("No new data to write to DB.");
                con.Close();
                return;
            }

            Console.WriteLine("Writing data to DB for "+hourData.Count+" events...");
            System.DateTime dbLastMessageTime=System.DateTime.Now;
            int numDone=0;
            foreach (EventSpan evt in hourData)
            {
                if (System.DateTime.Now-dbLastMessageTime > new System.TimeSpan(0,1,0)) //update progress if more than a minute
                {
                    dbLastMessageTime=System.DateTime.Now;
                    Console.WriteLine((100*numDone/hourData.Count)+"%...");
                }
                ++numDone;

                foreach (EventCount cnt in evt.parts)
                {
                    SqlCommand command=con.CreateCommand();
                    command.CommandType=CommandType.StoredProcedure;
                    command.CommandText="p_add_event_count";
                    command.CommandTimeout=300;

                    SqlParameter param=new SqlParameter();
                    param.ParameterName="@par_dt_hourbucket";
                    param.Direction=ParameterDirection.Input;
                    param.DbType=DbType.DateTime;
                    param.Value=cnt.GetDate();
                    command.Parameters.Add(param);

                    param=new SqlParameter();
                    param.Direction=ParameterDirection.Input;
                    param.ParameterName="@par_i_event_number";
                    param.DbType=DbType.Int32;
                    param.Value=(int)evt.evnt.eventID;
                    command.Parameters.Add(param);

                    param=new SqlParameter();
                    param.Direction=ParameterDirection.Input;
                    param.ParameterName="@par_vc_level";
                    param.DbType=DbType.String;
                    param.Value=evt.evnt.level;
                    command.Parameters.Add(param);

                    param=new SqlParameter();
                    param.Direction=ParameterDirection.Input;
                    param.ParameterName="@par_vc_component";
                    param.DbType=DbType.String;
                    param.Value=evt.evnt.component;
                    command.Parameters.Add(param);

                    param=new SqlParameter();
                    param.Direction=ParameterDirection.Input;
                    param.ParameterName="@par_bi_count";
                    param.DbType=DbType.Int64;
                    param.Value=(long)cnt.count;
                    command.Parameters.Add(param);

                    param=new SqlParameter();
                    param.Direction=ParameterDirection.Input;
                    param.ParameterName="@par_tx_sampletext";
                    param.DbType=DbType.String;
                    param.Value=evt.evnt.messageSample;
                    command.Parameters.Add(param);

                    command.ExecuteNonQuery();
                }
            }

            con.Close();

            Console.WriteLine("Done.");
        }

        //checks if the db says we have already processed a specific file
        private static bool HasDBIngestedFile(SqlConnection con, string name)
        {
            SqlCommand com=new SqlCommand("select count(*) from t_parsed_files where vc_filename='"+name.Replace("'","''")+"'", con);
            com.CommandTimeout=120;
            return 0!=(int)com.ExecuteScalar();
        }

        //writes to the db that we have processed a specific file
        private static void MarkDBIngestedFile(SqlConnection con, string name)
        {
            SqlCommand com=new SqlCommand("insert into t_parsed_files (vc_filename) values ('"+name.Replace("'","''")+"')", con);
            com.CommandTimeout=180;
            com.ExecuteNonQuery();
        }

        //
        private static void ProcessData(string []lines, List<ServerEvent> events, EventCountCollection EventCountList, string informationalFileName)
        {
            //process the lines
            foreach (string line in lines)
            {
                try
                {
                    if (line.Trim().Length==0) continue;

                    //most parts are comma seperated
                    string []parts=line.Split(new char[]{','});
                    if (parts.Length<7) throw new Exception("Line had an unexpected format.");

                    ServerEvent ev=new ServerEvent();
                    ev.eventID=System.Convert.ToUInt32(parts[1].Trim());
                    ev.component=parts[3].Trim();
                    ev.level=parts[5].Trim();

                    //parse the date then update occurance list
                    string dateStr=parts[2].Trim(); //like: 5/15/2007 8:00:58 PM
                    string []dateStrSpaceParts=dateStr.Split(new char[]{' '});
                    string []dateDayParts=dateStrSpaceParts[0].Split(new char[]{'/'});
                    uint year=System.Convert.ToUInt32(dateDayParts[2]);
                    uint month=System.Convert.ToUInt32(dateDayParts[0]);
                    uint day=System.Convert.ToUInt32(dateDayParts[1]);
                    string []dateHourParts=dateStrSpaceParts[1].Split(new char[]{':'});
                    uint hour=System.Convert.ToUInt32(dateHourParts[0]);
                    if (dateStrSpaceParts.Length>=3 && dateStrSpaceParts[2].ToLower()=="pm") hour+=12;
                    if (hour==24) hour=0;

                    //if it's outside our date range, ignore it
                    System.DateTime evDate=new System.DateTime((int)year,(int)month,(int)day);
                    if ((DateNow-evDate).TotalDays > DayCount)
                    {
                        continue;
                    }

                    //the last section has the source file and the message, seperated by 4 spaces
                    try
                    {
                        string sourceTemp=parts[6].Trim();
                        sourceTemp=sourceTemp.Replace("    ","\n");
                        string []sourceSplit=sourceTemp.Split(new char[]{'\n'});

                        if (sourceSplit.Length>=2) //2+ parts.. normal kdc line
                        {
                            ev.messageSample=sourceSplit[0]+"\n";
                            ev.messageSample+=parts[6].Trim().Substring(sourceSplit[0].Length+4);
                        }
                        else //unknown type, just put it all into message
                        {
                            ev.messageSample=parts[6].Trim();
                        }
                        for (int i=7; i<parts.Length; ++i) //all the rest
                                ev.messageSample+=","+parts[i];

                        if (ev.messageSample.Length>50*1024) //limit to 50k sample message size
                            ev.messageSample=ev.messageSample.Substring(0,50*1024);
                    }
                    catch (System.OutOfMemoryException)
                    {
                        ev.messageSample="(Event Parser: System.OutOfMemoryException trying to parse the logline for this event)";
                        Console.WriteLine("System.OutOfMemoryException trying to parse message for event "+ev.component+" "+ev.eventID+" on "+dateStr);
                        System.GC.Collect();
                    }

                    //see if we already have a similar event... if not then add it
                    parts=null;
                    bool found=false;
                    foreach (ServerEvent ke in events)
                    {
                        if (ke.IsSimilarTo(ev))
                        {
                            found=true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        events.Add(ev);
                    }

                    EventCountList.AddOccurance(year,month,day,hour,ev);
                }
                catch (Exception e)
                {
                    if (line.Length<4*1024)
                        Console.WriteLine("Error processing line in file "+informationalFileName+": "+e.Message+"\nOffending line: "+line);
                    else
                        Console.WriteLine("Error processing line in file "+informationalFileName+": "+e.Message+"\nStart of offending line: "+line.Substring(0,4*1024)+" ...");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\parser\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_eventcountdbparser_none_12.4.56.0_none_c3b02315b92dcd2f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventcountdbparser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.manifest
XP_MANIFEST_PATH=manifests\msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.cat
XP_CATALOG_PATH=manifests\msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.cat
XP_PAYLOAD_PATH=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventcountdbparser,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\parser\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\DumpUser\DumpUser.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;

namespace DumpUser
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			DumpUserApp app = new DumpUserApp();
			app.Run(args);
			Console.WriteLine("Done.");
		}
	}

	public class DumpUserApp
	{
		public void Run(string[] args)
		{
			// Initialization
			Global.Initialize("stf.xml");
			InitializerInfo.InitializeGlobalResources(GetRequiredResources(), Global.Config);       

			// Parse command line arguments
			ulong puid;
			try
			{
				puid = ParseArguments(args);
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
				Console.WriteLine("");
				Console.WriteLine("Example: CreateUser.exe /puid:2533274790488474");
				return;
			}

			DumpUserInfo(puid);

			// Clean-up
			InitializerInfo.UninitializeGlobalResources();
		}

		public InitializerInfo GetRequiredResources()
		{
			InitializerInfo ii = new InitializerInfo();

			TestSuite suite = new TestSuite();
			suite.ValidateStfRunnerVersion(6);
			ii.UseUodb = true;
			ii.UseFakeSG = true;
			ii.Puids = false;
			ii.CreateUsers = false;
			ii.Certificates = false;

			return ii;
		}

		public ulong ParseArguments(string[] args)
		{
			if (args.Length == 0)
			{
				throw new Exception("A single command line parameter is required.");
			}
			if (args.Length > 1)
			{
				throw new Exception("Only a single command line parameter is allowed.");
			}

			string arg = args[0].ToLower();
			if (!arg.StartsWith("/puid:"))
			{
				throw new Exception("Invalid command line parameter.");
			}
			string puidString = arg.Substring("/puid:".Length);
			ulong puid = ulong.Parse(puidString);

			return(puid);
		}

		public static void DumpUserInfo(ulong Puid)
		{
			UserInfo uinfo;
			bool ret = UodbWS.GetUserInfo(Puid, out uinfo);
			if (!ret)
			{
				throw new UnexpectedTestResultException("Call to GetUserInfo() failed.");
			}
			Console.WriteLine("\tUsername: "+ uinfo.nickname);
			Console.WriteLine("\tPuid: " + uinfo.puid);
			Console.WriteLine("\tOwner puid: " + uinfo.ownerPuid);
			Console.WriteLine("\tQueued: " + uinfo.queued);
			Console.WriteLine("\tServer: " + uinfo.server);

			DateTime	UTCTime=DateTime.Now.ToUniversalTime();
			string s=string.Format("\tLocked:{0} NickBanned:N/A VoiceBanned:{1} MustChange:{2}",
				(uinfo.suspendedUntil>UTCTime),
				(uinfo.voiceBannedUntil>UTCTime),
				(uinfo.nameChangeRequired!=0));
			Console.WriteLine(s);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\parser\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_eventcountdbparser_none_12.4.56.0_none_c3b02315b92dcd2f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventcountdbparser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.manifest
XP_MANIFEST_PATH=manifests\msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.cat
XP_CATALOG_PATH=manifests\msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5.cat
XP_PAYLOAD_PATH=msil_eventcountdbparser_no-public-key_12.4.56.0_x-ww_81df7cd5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventcountdbparser,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EmulatorSetUP\main.cs ===
using System;
using System.Xml;
using System.Collections;
using System.IO;

using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;
using Microsoft.XBox.Live.Server.Emulators.ppsaProfile;
using Microsoft.XBox.Live.Server.Emulators.ppsaCredential;
using Microsoft.XBox.Live.Server.Emulators.ups;

using Microsoft.XBox.Live.Server.Emulators.Framework;

using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework;
using ServerTestFramework.Utilities;



namespace EmulatorSetup
{
    class EmulatorSetup
    {
        public static DMPEmulator DmpEmu = new DMPEmulator();
        public static IDMPTransactionSoap Idmp = null;
        public static BdkEmulator BdkEmu = new BdkEmulator();
        static public IBdkSoap Ibdk = null;
        static public ppsaProfileEmulator ppsaProfileEmu = new ppsaProfileEmulator();
        static public IppsaProfileSoap IppsaProfile = null;
        static public ppsaCredentialEmulator ppsaCredentialEmu = new ppsaCredentialEmulator();
        static public IppsaCredentialSoap IppsaCredential = null;
        static public upsEmulator upsEmu = new upsEmulator();
        static public IUpsSoap Iups = null;


        public static string DmpUrl = "";
        public static string BdkUrl = "";
        public static string ppsaProfileUrl = "";
        public static string ppsaCredentialUrl = "";
        public static string upsUrl = "";

        static string defaultEnvName = "stressnet";

        public static string RetailerId
        {
            get
            {
                return Global.XEnv.GetSetting("musicnet_retailerID");
            }
        }




        public static  void CallUacsppsaProfileStressEmulator(ppsaProfileEmulator ppsaProfileEmu, ref IppsaProfileSoap ppsaProfile, Hashtable responseTimeTbl)
        {
            ppsaProfile = ppsaProfileEmu.StartRecording();

            //CreatePassports   
            string pbstrErrorBlob = "";
            string[] strArray = new string[1];
            string[] retStrArray = new string[1];
            retStrArray[0] = "<Account><pit>PASSID_PUID_SIGNINNAME</pit>\r\n<bstrID><PID><PUID>0003000083537E82</PUID>\r\n<SIGNINNAME>xbltest-709ad541-7c77-4b64-8fc5-074f92e81975@xbltest.com</SIGNINNAME>\r\n</PID>\r\n</bstrID>\r\n<SLT>BGqhGcfkVqOSGj18V7JOZhzIlt1pu0bHtHdvzCGwaEsz3kabzX5d*OWJPD!NdQMEKSlp*CpmkOZufJJBsuqA8QBfZqNDuiCmuaaeNI1oGJB4SO84J8QUZDA10A5tWy*94IiqTlIjhoeAKwzPj6SK*EQt1YCu</SLT>\r\n</Account>\r\n";
            ppsaProfile.CreatePassports(strArray, 0, out pbstrErrorBlob);
            LastCall.On(ppsaProfile).Arguments(Is.Any(), Is.Any());
            LastCall.On(ppsaProfile).Returns(retStrArray);
            LastCall.On(ppsaProfile).ExpectedAnytime();
            LastCall.On(ppsaProfile).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["CreatePassports"]));        // the line added
            LastCall.On(ppsaProfile).OutArguments(null, null, pbstrErrorBlob);

            ppsaProfileEmu.StopRecording(ppsaProfile);
        }

        public static void CallUacsppsaCredentialStressEmulator(ppsaCredentialEmulator ppsaCredentialEmu, ref IppsaCredentialSoap ppsaCredential, Hashtable responseTimeTbl, XeUser user)
        {
            ppsaCredential = ppsaCredentialEmu.StartRecording();

            //UpdateCredential   
            string bstrCredXML = "";

            ppsaCredential.UpdateCredential(bstrCredXML);
            LastCall.On(ppsaCredential).Arguments(Is.Any());
            LastCall.On(ppsaCredential).ExpectedAnytime();
            LastCall.On(ppsaCredential).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["UpdateCredential"]));        // the line added

            //GetNetIDsForSigninNames
            // it can't use random return value because of XePassportGetBuddyGamertag.
            // XePassportGetBuddyGamertag calls GetNetIDsForSigninNames to get passportPuid and then does xcache lookup to find gamer tag from the passportPuid
            // so if the passportPuid is random, it will fail to find gamertag. 
            // So xbox live account linked passportPuid should be used .
            string bstrSigninNames = "";
            string retStr = string.Format("<Name2NETID><SigninName NetID=\"{0:X}\"\r\n CredFlags=\"00000A28\"\r\n>\r\n{1}</SigninName>\r\n</Name2NETID>\r\n", user.PassportUserPuid, user.PassportMemberName);

            ppsaCredential.GetNetIDsForSigninNames(bstrSigninNames);
            LastCall.On(ppsaCredential).Arguments(Is.Any());
            LastCall.On(ppsaCredential).Returns(retStr);
            LastCall.On(ppsaCredential).ExpectedAnytime();
            LastCall.On(ppsaCredential).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetNetIDsForSigninNames"]));        // the line added

            //GetSigninNamesForNetIDs
            string bstrNetIDs = "";
            retStr = string.Format("<NETID2Name><SigninName NetID=\"00037FFF83818F88\"\r\n CredFlags=\"00000A28\"\r\n>\r\nxbltest-709ad541-7c77-4b64-8fc5-074f92e81375@xbltest.com</SigninName>\r\n</NETID2Name>\r\n");

            ppsaCredential.GetSigninNamesForNetIDs(bstrNetIDs);
            LastCall.On(ppsaCredential).Arguments(Is.Any());
            LastCall.On(ppsaCredential).Returns(retStr);
            LastCall.On(ppsaCredential).ExpectedAnytime();
            LastCall.On(ppsaCredential).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetSigninNamesForNetIDs"]));        // the line added

            // GetSigninNamesAndCIDsForNetIDs
            bstrNetIDs = "";
            retStr = string.Format("<NETID2Name><SigninName NetID=\"00037FFF83818F89\"\r\n CID=\"b384e02f801d370d\"\r\n CredFlags=\"00000A28\"\r\n>\r\nxbltest-909ad541-7c77-4b64-8fc5-074f92e81375@xbltest.com</SigninName>\r\n</NETID2Name>\r\n");
            ppsaCredential.GetSigninNamesAndCIDsForNetIDs(bstrNetIDs);
            LastCall.On(ppsaCredential).Arguments(Is.Any());
            LastCall.On(ppsaCredential).Returns(retStr);
            LastCall.On(ppsaCredential).ExpectedAnytime();
            LastCall.On(ppsaCredential).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetSigninNamesAndCIDsForNetIDs"]));        // the line added

            ppsaCredentialEmu.StopRecording(ppsaCredential);
        }

        public  static  void CallUacsupsStressEmulator(upsEmulator upsEmu, ref IUpsSoap ups, Hashtable responseTimeTbl)
        {
            ups = upsEmu.StartRecording();

            //GetProfileByAttributes   
            string[] pbstrNetIDArray = new string[1];
            string bstrAttribList = "";
            System.UInt32 ulFlags = 0;
            string pbstrErrorBlob = null;

            string[] ppbstrProfileXMLArray = new string[1];
            ppbstrProfileXMLArray[0] = "<p:userData\txmlns:p=\"http://schemas.microsoft.com/Passport/User\"><p:dataOwner>00037FFF8381C26D</p:dataOwner><p:propertyCollection name=\"XBOX\"><p:property name=\"DAYPHONE\" datatype=\"nil\"></p:property><p:property name=\"EMAIL\" datatype=\"nil\"></p:property><p:property name=\"GAMERTAG\" datatype=\"bstr\">XENaa33io70o18i</p:property></p:propertyCollection></p:userData>";

            ups.GetProfileByAttributes(pbstrNetIDArray, bstrAttribList, ulFlags, out pbstrErrorBlob);
            LastCall.On(ups).Arguments(Is.Any(), Is.Any(), Is.Any());
            LastCall.On(ups).Returns(ppbstrProfileXMLArray);
            LastCall.On(ups).ExpectedAnytime();
            LastCall.On(ups).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["GetProfileByAttributes"]));        // the line added
            LastCall.On(ups).OutArguments(null, null, null, pbstrErrorBlob);

            // UpdateProfile
            string[] pbstrProfileXMLArray = new string[1];

            ups.UpdateProfile(pbstrProfileXMLArray);
            LastCall.On(ups).Arguments(Is.Any());
            LastCall.On(ups).ExpectedAnytime();
            LastCall.On(ups).Waits(TimeSpan.FromMilliseconds((int)responseTimeTbl["UpdateProfile"]));        // the line added

            upsEmu.StopRecording(ups);
        }
         
        private static Hashtable responseTimeTbl;

        //To do: get the response time from xml file. 
        public static Hashtable GetBillingCallResponseTimeTbl(){
            if (responseTimeTbl != null) return responseTimeTbl;
                responseTimeTbl = new Hashtable();

                responseTimeTbl.Add("CreatePassports", 200);
                responseTimeTbl.Add("UpdateCredential", 200);
                responseTimeTbl.Add("GetNetIDsForSigninNames", 50);
                responseTimeTbl.Add("GetSigninNamesForNetIDs", 50);
                responseTimeTbl.Add("GetSigninNamesAndCIDsForNetIDs", 50);
                responseTimeTbl.Add("GetProfileByAttributes", 50);
                responseTimeTbl.Add("UpdateProfile", 200);


                return responseTimeTbl;        
        }

        public static XeUser CreateXenonUser()
        {
            XeUser user = new XeUser(true);            

            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            Global.RO.Info("User 0x{0:x} created.", user.UserPuid);

            return user;
        }


        // paspsor need to call create user in order to do set up emulator client. So we need to stf initialzation here. 
        public static void InitializeSTF(string envName)
        {
        
            XmlDocument config = new XmlDataDocument();
            
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            ServerTestFramework.Global.Initialize(config);
            
            bool found = false;
            foreach (ServerTestFramework.EnvironmentSetting npdbSetting in ServerTestFramework.Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    ServerTestFramework.Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                throw new Exception("Error - unknown environment '{0}' specified (not in stf.xml?)." + envName);                
            }

            ServerTestFramework.Global.ResetEnvironment();        
        }


        static string GetBehaviorInjectionHeader()
        {
            string passThroughString = ";passThrough=,";

            return "BEHAVIOR_INJECTIONS: AlternatePpCredentialServiceApiUrl;"
                        + ppsaCredentialUrl + passThroughString
                //+" AlternateBillingUrl;" + BdkUrl + passThroughString
                        + " AlternateDmpUrl;" + DmpUrl + passThroughString
                        + " AlternatePpProfileServiceApiUrl;" + ppsaProfileUrl + passThroughString
                        + " AlternateUpsUrl;" + upsUrl + passThroughString
                        + " AlternateBillingUrl;" + BdkUrl + ";passThrough=";
                        //+" AlternateUpsUrl;" + upsUrl + ";passThrough=";
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {

            string envName ="";

            if (args.Length > 0)
            {
                envName = args[0];
            }
            else envName = defaultEnvName;

            Console.WriteLine("use " + envName + " as Environment");

            InitializeSTF(envName);

            XeUser user = null;
            user = CreateXenonUser();


            XeXbos.EmulatorClient.CallBillingStressEmulatorZest(BdkEmu, ref Ibdk, XeXbos.EmulatorClient.GetBillingCallResponseTimeTbl());
            BdkUrl = BdkEmu.GetUrl(Ibdk);
            XeXbos.EmulatorClient.CallDmpStressEmulator(XeXbos.EmulatorClient.GetBillingCallResponseTimeTbl(), DmpEmu, ref Idmp);
            DmpUrl = DmpEmu.GetUrl(Idmp);
           

            CallUacsppsaProfileStressEmulator(ppsaProfileEmu, ref IppsaProfile, GetBillingCallResponseTimeTbl());
            ppsaProfileUrl = ppsaProfileEmu.GetUrl(IppsaProfile);

            //XeUser user = null;
            //user = CreateXenonUser();


            CallUacsppsaCredentialStressEmulator(ppsaCredentialEmu, ref  IppsaCredential, GetBillingCallResponseTimeTbl(), user);
            ppsaCredentialUrl = ppsaCredentialEmu.GetUrl(IppsaCredential);

            CallUacsupsStressEmulator(upsEmu, ref  Iups, GetBillingCallResponseTimeTbl());
            upsUrl = upsEmu.GetUrl(Iups);

            Console.WriteLine("DmpUrl:" + DmpUrl);
            Console.WriteLine("BdkUrl:" + BdkUrl);
            Console.WriteLine("ppsaCredentialUrl: "  + ppsaCredentialUrl);
            Console.WriteLine("ppsaProfileUrl: " + ppsaProfileUrl);
            Console.WriteLine("upsUrl: " + upsUrl);
            string header = GetBehaviorInjectionHeader();
            Console.WriteLine("\r\nBehaviorInjectionHeader: " + header);

            try
                {
                   
                   string fileName = string.Format("BehaviorInjectionHeader.txt");
                   Console.WriteLine("\r\nBehaviorInjectionHeader.txt is located at " + System.Environment.CurrentDirectory);
                   StreamWriter swLog = File.CreateText(Path.Combine(System.Environment.CurrentDirectory, fileName));
                   swLog.AutoFlush = true;
                   swLog.WriteLine(header);
                   swLog.Close();
                }
                catch (Exception e){
                    Console.WriteLine("get SWLog file error with " +  e.Message);
                    throw e;
                }
            
            //Console.WriteLine("input key");
            //Console.ReadLine();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_eventcountdbviewer_none_12.4.56.0_none_10799d571d1dd2e6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventcountdbviewer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.manifest
XP_MANIFEST_PATH=manifests\msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.cat
XP_CATALOG_PATH=manifests\msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.cat
XP_PAYLOAD_PATH=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventcountdbviewer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\Main.cs ===
using System;
using System.Windows.Forms;

namespace EventCountDB
{
    public class MainClass
    {
        //entry point
        [STAThreadAttribute]
        static void Main(string[] args)
        {
            bool useGuiMode=true; //interactive gui?
            int genHours=24*3; //noninteractive: hours to show
            EventCountDB.EventCountDBConnection.TimeBucket genBuckets=EventCountDB.EventCountDBConnection.TimeBucket.Hour;
            string genPath="Output"; //noninteractive: path to dump output files

            //handle args
            foreach (string arg in args)
            {
                string larg=arg.ToLower();
                if (larg.StartsWith("help") || larg.StartsWith("-help") || larg.StartsWith("-?") || larg.StartsWith("/?"))
                {
                    MessageBox.Show("Options:\n  -db:name  -- use database on a specific machine (default is evilsphere)\n  -generate  -- Generate html graphs instead of using interactive mode\n  -genhours:hours  -- number of hours to show in the html graph report\n  -genpath:path  -- location to write all generated html graph files\n  -genbucket:interval  -- how to bucketize counts (hour, day, month)");
                    return;
                }
                else if (larg.StartsWith("-db:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        EventCountDBConnection.HostMachine=parts[1];
                    }
                }
                else if (larg=="-generate")
                {
                    useGuiMode=false;
                }
                else if (larg.StartsWith("-genhours:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        genHours=int.Parse(parts[1]);
                    }
                }
                else if (larg.StartsWith("-genpath:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        genPath=parts[1];
                    }
                }
                else if (larg.StartsWith("-genbucket:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        if (parts[1]=="hour") genBuckets=EventCountDB.EventCountDBConnection.TimeBucket.Hour;
                        if (parts[1]=="day") genBuckets=EventCountDB.EventCountDBConnection.TimeBucket.Day;
                        if (parts[1]=="month") genBuckets=EventCountDB.EventCountDBConnection.TimeBucket.Month;
                    }
                }
            }

            //run gui
            if (useGuiMode)
            {
                MainGui gui=new MainGui();
                gui.Visible=false;
                gui.ShowDialog();
            }
            //run generator task
            else
            {
                HtmlGraphGenerator gen=new HtmlGraphGenerator();
                gen.Generate(genPath, System.DateTime.UtcNow-new System.TimeSpan(genHours, 0, 0), new System.TimeSpan(genHours, 0, 0), genBuckets);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\Gui.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;
using System.Drawing;

using ServerTestFramework.Utilities;

namespace EventCountDB
{
    /// <summary>
    /// The main gui.
    /// </summary>
    public class MainGui: Form
    {
        XmlDocument settings;
        GraphicsCommon.DateCountLineGraph graph;
        GraphicsCommon.GraphScroller graphScroller;
        EventCountDBConnection db;

        ListBox boxComponents;
        ListBox boxLevels;
        ListBox boxIDs;
        ComboBox timeBucketBox;

        Panel panelGraph;
        Panel panelFilter;
        Panel panelInfo;
        Panel panelOptions;
        FlowLayoutPanel fpanelKey;

        ComboBox actChooseBox;
        Button highlightedButton=null;

        EventCountDBConnection.EventEntry []AllEvents;

        //ctor
        public MainGui()
        {
            //load settings from file
            settings=new XmlDocument();
            try
            {
                settings.Load("EventCountDBViewer.xml");
            }
            catch
            {
                //it's ok if it fails, it's probably because it doesn't exist, so we will use defaults.
            }

            //get or create our main settings node
            XmlNode mainNode=settings.SelectSingleNode("EventCountDBViewer");
            if (mainNode==null)
            {
                mainNode=settings.CreateNode(XmlNodeType.Element, "EventCountDBViewer", "");
                settings.AppendChild(mainNode);
            }

            XmlNode groupNode=XmlUtil.GetGroupNode(mainNode, "BaseGui");

            //set up us and our events
            Text="EventCountDB Viewer";
            FormClosing+=Form_Closing;
            Resize+=Form_Resizing;

            Width=XmlUtil.GetChildNodeValue(groupNode, "Width", 800);
            Height=XmlUtil.GetChildNodeValue(groupNode, "Height", 600);
            Show();
            Left=XmlUtil.GetChildNodeValue(groupNode, "LeftPos", 50);
            Top=XmlUtil.GetChildNodeValue(groupNode, "TopPos", 50);
            if (XmlUtil.GetChildNodeValue(groupNode, "IsMaxxed", false))
            {
                WindowState=FormWindowState.Maximized;
            }

            //splitter bars
            SplitContainer splitLeftAndRight=new SplitContainer();
            splitLeftAndRight.FixedPanel=FixedPanel.Panel1;
            splitLeftAndRight.Orientation=Orientation.Vertical;
            splitLeftAndRight.Dock=DockStyle.Fill;
            splitLeftAndRight.Location=new System.Drawing.Point(0, 0);
            splitLeftAndRight.Size=new System.Drawing.Size(3000, 3000);
            splitLeftAndRight.IsSplitterFixed=false;
            Controls.Add(splitLeftAndRight);

            SplitContainer splitBotAndTop=new SplitContainer();
            splitBotAndTop.Orientation=Orientation.Horizontal;
            splitBotAndTop.Dock=DockStyle.Fill;
            splitBotAndTop.Location=new System.Drawing.Point(0, 0);
            splitBotAndTop.Size=new System.Drawing.Size(3000, 3000);
            splitBotAndTop.Panel2MinSize=100;
            splitBotAndTop.SplitterDistance=2950;
            splitBotAndTop.IsSplitterFixed=true;
            splitLeftAndRight.Panel2.Controls.Add(splitBotAndTop);

            SplitContainer splitOptionsInfo=new SplitContainer();
            splitOptionsInfo.FixedPanel=FixedPanel.Panel1;
            splitOptionsInfo.Orientation=Orientation.Vertical;
            splitOptionsInfo.Dock=DockStyle.Fill;
            splitOptionsInfo.Location=new System.Drawing.Point(0, 0);
            splitOptionsInfo.Size=new System.Drawing.Size(3000, 3000);
            splitOptionsInfo.IsSplitterFixed=true;
            splitOptionsInfo.Panel1MinSize=100;
            splitOptionsInfo.SplitterDistance=100;
            splitBotAndTop.Panel2.Controls.Add(splitOptionsInfo);

            //panels
            panelGraph=splitBotAndTop.Panel1;
            panelFilter=splitLeftAndRight.Panel1;
            panelInfo=splitOptionsInfo.Panel2;
            panelOptions=splitOptionsInfo.Panel1;

            //graph
            graph=new GraphicsCommon.DateCountLineGraph();
            graph.MinYRangeAmount=6.0f;
            graph.MinXRangeAmount=GraphicsCommon.DateCountLineGraph.HourWidth*2;
            graph.MinimumResolutionIsHour=true;

            graphScroller=new GraphicsCommon.GraphScroller(graph);
            graphScroller.Dock=DockStyle.Fill;
            graphScroller.YZoomCenter=false;
            panelGraph.Controls.Add(graphScroller);

            //connect to db
            try
            {
                db=new EventCountDBConnection();
            }
            catch (Exception e)
            {
                MessageBox.Show("Failed to connect to db: "+e);
                Close();
                return;
            }

            //get all events
            AllEvents=db.GetEvents();

            //create and populate filters
            boxComponents=new ListBox();
            boxComponents.IntegralHeight=false;
            boxComponents.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            boxComponents.SelectionMode=SelectionMode.MultiExtended;
            boxComponents.Items.AddRange(db.GetComponents());
            for (int i=0; i<boxComponents.Items.Count; ++i) boxComponents.SetSelected(i, true);
            panelFilter.Controls.Add(boxComponents);
            boxComponents.SelectedIndexChanged+=ListFilterChanged;
            new ToolTip().SetToolTip(boxComponents, "Server Components");

            boxLevels=new ListBox();
            boxLevels.IntegralHeight=false;
            boxLevels.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            boxLevels.SelectionMode=SelectionMode.MultiExtended;
            boxLevels.Items.AddRange(db.GetLevels());
            for (int i=0; i<boxLevels.Items.Count; ++i) boxLevels.SetSelected(i, true);
            panelFilter.Controls.Add(boxLevels);
            boxLevels.SelectedIndexChanged+=ListFilterChanged;
            new ToolTip().SetToolTip(boxLevels, "Event Levels");

            boxIDs=new ListBox();
            boxIDs.IntegralHeight=false;
            boxIDs.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            boxIDs.SelectionMode=SelectionMode.MultiExtended;
            FilterEventNumbersToBox();
            for (int i=0; i<boxIDs.Items.Count; ++i) boxIDs.SetSelected(i, true);
            panelFilter.Controls.Add(boxIDs);
            new ToolTip().SetToolTip(boxIDs, "Event Numbers");

            timeBucketBox=new ComboBox();
            timeBucketBox.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            timeBucketBox.DropDownStyle=ComboBoxStyle.DropDownList;
            timeBucketBox.Items.Add("Hour Buckets");
            timeBucketBox.Items.Add("Day Buckets");
            timeBucketBox.Items.Add("Month Buckets");
            timeBucketBox.SelectedIndex=0;
            panelFilter.Controls.Add(timeBucketBox);
            new ToolTip().SetToolTip(timeBucketBox, "Granularity to display data in");

            Form_Resizing(null,null);

            //refresh graph button
            Button butrg=new Button();
            butrg.Text="Update Graph";
            butrg.Size=new System.Drawing.Size(150, 25);
            butrg.Dock=DockStyle.Bottom;
            panelFilter.Controls.Add(butrg);
            butrg.Click+=UpdateButton_Click;
            new ToolTip().SetToolTip(butrg, "Populate the graph with data from the db.");

            //the key colors
            fpanelKey=new FlowLayoutPanel();
            fpanelKey.BackColor=System.Drawing.Color.Black;
            fpanelKey.Size=new System.Drawing.Size(3000, 3000);
            fpanelKey.Dock=DockStyle.Fill;
            fpanelKey.FlowDirection=FlowDirection.TopDown;
            fpanelKey.VerticalScroll.Visible=false;
            fpanelKey.HorizontalScroll.Enabled=true;
            fpanelKey.WrapContents=true;
            fpanelKey.AutoScroll=true;
            fpanelKey.HorizontalScroll.Visible=true;
            fpanelKey.HorizontalScroll.Enabled=true;
            fpanelKey.VerticalScroll.Visible=false;
            fpanelKey.VerticalScroll.Enabled=false;
            Padding grr=new Padding(); grr.All=1; grr.Top=2; grr.Left=2;
            fpanelKey.Padding=grr;
            panelInfo.Controls.Add(fpanelKey);

            //check box options
            CheckBox cb=new CheckBox();
            cb.Location=new System.Drawing.Point(0, 2);
            cb.Size=new System.Drawing.Size(100, 20);
            cb.Text="Antialias Lines";
            cb.Checked=true;
            cb.CheckedChanged+=CheckAlias_Changed;
            panelOptions.Controls.Add(cb);
            new ToolTip().SetToolTip(cb, "Draw lines on the graph using antialiasing.");

            cb=new CheckBox();
            cb.Location=new System.Drawing.Point(0, 2+19);
            cb.Size=new System.Drawing.Size(100, 20);
            cb.Text="Thick Lines";
            cb.Checked=false;
            cb.CheckedChanged+=CheckThick_Changed;
            panelOptions.Controls.Add(cb);
            new ToolTip().SetToolTip(cb, "Draw the graph using thicker lines.");

            cb=new CheckBox();
            cb.Location=new System.Drawing.Point(0, 2+19*2);
            cb.Size=new System.Drawing.Size(140, 20);
            cb.Text="Highlight Values";
            cb.Checked=true;
            cb.CheckedChanged+=CheckSample_Changed;
            panelOptions.Controls.Add(cb);
            new ToolTip().SetToolTip(cb, "When enabled and an event is highlighted, interpolated numeric values for the x mouse location over the graph are shown.");

            //button action chooser
            Label labButAct=new Label();
            labButAct.Location=new System.Drawing.Point(16, 62);
            labButAct.Size=new System.Drawing.Size(90, 16);
            labButAct.Text="Event Button:";
            panelOptions.Controls.Add(labButAct);

            actChooseBox=new ComboBox();
            actChooseBox.Location=new System.Drawing.Point(3, 78);
            actChooseBox.Size=new System.Drawing.Size(96, 20);
            actChooseBox.DropDownStyle=ComboBoxStyle.DropDownList;
            actChooseBox.Items.Add("Event Text");
            actChooseBox.Items.Add("Highlight");
            actChooseBox.Items.Add("View Data");
            actChooseBox.SelectedIndex=1;
            panelOptions.Controls.Add(actChooseBox);
            new ToolTip().SetToolTip(actChooseBox, "Controls what action is taken by clicking on the event buttons to the right");

            //post-init pos of some stuff... since .NET is rather retarded in how it resizes things
            splitLeftAndRight.SplitterDistance=150;
        }

        void FilterEventNumbersToBox()
        {
            boxIDs.Items.Clear();

            //filter list to selection of component and level
            foreach(EventCountDBConnection.EventEntry ee in AllEvents)
            {
                bool hasComp=false, hasLevel=false;

                foreach (string ls in boxLevels.SelectedItems)
                {
                    if (ls==ee.Level)
                    {
                        hasLevel=true;
                        break;
                    }
                }
                if (!hasLevel) continue;

                foreach (string cs in boxComponents.SelectedItems)
                {
                    if (cs==ee.Component)
                    {
                        hasComp=true;
                        break;
                    }
                }
                if (!hasComp) continue;
                
                bool alreadyHas=false;
                foreach (string es in boxIDs.Items)
                {
                    if (es==ee.Number.ToString())
                    {
                        alreadyHas=true;
                        break;
                    }
                }

                if (!alreadyHas)
                {
                    boxIDs.Items.Add(ee.Number.ToString());
                }
            }

            //select all
            for (int i=0; i<boxIDs.Items.Count; ++i)
            {
                boxIDs.SetSelected(i, true);
            }
        }

        #region Menu Options and Events

        private void UpdateButton_Click(object sender, EventArgs e)
        {
            fpanelKey.Controls.Clear();
            graph.DataSets.Clear();

            //pull data from the db for all selected events
            //TODO: de-nest-ize all this so there's less work in the worst case
            foreach (string compName in boxComponents.SelectedItems)
            {
                foreach (string levName in boxLevels.SelectedItems)
                {
                    foreach (string numName in boxIDs.SelectedItems)
                    {
                        //only query it if it's in the valid event list
                        foreach(EventCountDBConnection.EventEntry ee in AllEvents)
                        {
                            if (ee.Component==compName && ee.Level==levName && ee.Number.ToString()==numName)
                            {
                                //add the data
                                EventCountDBConnection.DateValue[] vals=db.GetCounts(ee.Component, ee.Level, ee.Number, (EventCountDB.EventCountDBConnection.TimeBucket)timeBucketBox.SelectedIndex, true);

                                GraphicsCommon.BasicLineGraph.DataSet set=new GraphicsCommon.BasicLineGraph.DataSet();
                                set.Tag=ee;
                                graph.DataSets.Add(set);
                                foreach (EventCountDBConnection.DateValue val in vals)
                                {
                                    graph.AddDateValue(set, val.Date, val.Count);
                                }

                                break;
                            }
                        }
                    }
                }
            }

            //update graph
            graph.HighlightedDataSet=null;
            graph.RefreshGraph(true, true);

            //add the buttons for each event
            fpanelKey.Visible=false;
            panelInfo.Controls.Remove(fpanelKey);
            fpanelKey.SuspendLayout();
            foreach (GraphicsCommon.BasicLineGraph.DataSet set in graph.DataSets)
            {
                EventCountDBConnection.EventEntry ee=(EventCountDBConnection.EventEntry)set.Tag;

                Button but=new Button();
                but.BackColor=System.Drawing.Color.Red;
                but.Text=ee.Component+" "+ee.Number;
                but.MaximumSize=new System.Drawing.Size(150, 20);
                but.AutoSize=true;
                Padding grr=new Padding(); grr.All=0;
                but.Margin=grr;
                but.BackColor=set.Color;
                but.Click+=EventButton_Clicked;
                but.Tag=ee;
                fpanelKey.Controls.Add(but);
            }
            fpanelKey.ResumeLayout();
            fpanelKey.Visible=true;
            panelInfo.Controls.Add(fpanelKey);
        }

        private void ListFilterChanged(object sender, EventArgs e)
        {
            FilterEventNumbersToBox();
        }

        private void Form_Resizing(object sender, EventArgs e)
        {
            //adjust filters
            if (!(boxComponents==null || boxLevels==null || boxIDs==null))
            {
                boxComponents.Size=new System.Drawing.Size(panelFilter.Width, 4*panelFilter.Height/9);
                boxComponents.Location=new System.Drawing.Point(0, 0);

                boxLevels.Size=new System.Drawing.Size(panelFilter.Width, panelFilter.Height/9);
                boxLevels.Location=new System.Drawing.Point(0, 4*panelFilter.Height/9);

                boxIDs.Size=new System.Drawing.Size(panelFilter.Width, 4*panelFilter.Height/9-45);
                boxIDs.Location=new System.Drawing.Point(0, 5*panelFilter.Height/9);

                timeBucketBox.Location=new System.Drawing.Point(0, panelFilter.Height-45);
                timeBucketBox.Size=new System.Drawing.Size(panelFilter.Width, 20);
            }
        }

        private void EventButton_Clicked(object sender, EventArgs e)
        {
            EventCountDBConnection.EventEntry ee=(EventCountDBConnection.EventEntry)((Button)sender).Tag;

            if (actChooseBox.SelectedIndex==0 || actChooseBox.SelectedIndex==2) //sample text or view data
            {
                Form form=new Form();
                form.SetBounds(0,0,600,400,BoundsSpecified.Size);
                form.FormBorderStyle=FormBorderStyle.Sizable;
                form.Text="Loading...";
                form.Show(this);

                TextBox box=new TextBox();
                box.Dock=DockStyle.Fill;
                box.Multiline=true;
                box.ReadOnly=true;
                box.ScrollBars=ScrollBars.Vertical;
                form.Controls.Add(box);

                if (actChooseBox.SelectedIndex==0) //sample text)
                {
                    string text=db.GetSampleText(ee.Component, ee.Level, ee.Number);
                    form.Text="Sample text for "+((Button)sender).Text;
                    box.Text=text.Replace("\n","\r\n");
                }
                else //view data
                {
                    EventCountDBConnection.DateValue[] vals=db.GetCounts(ee.Component, ee.Level, ee.Number, (EventCountDB.EventCountDBConnection.TimeBucket)timeBucketBox.SelectedIndex, false);
                    form.Text="Event Counts for "+((Button)sender).Text;
                    foreach (EventCountDBConnection.DateValue val in vals)
                    {
                        box.Text+=val.Date+": "+val.Count+"\r\n";
                    }
                }
            }
            else if (actChooseBox.SelectedIndex==1) //highlight
            {
                if (highlightedButton!=null) highlightedButton.ForeColor=Color.Black;
                if (highlightedButton!=null && highlightedButton==(Button)sender) //turn off
                {
                    graph.HighlightedDataSet=null;
                    highlightedButton=null;
                }
                else //set or change
                {
                    highlightedButton=(Button)sender;
                    highlightedButton.ForeColor=Color.White;

                    foreach (GraphicsCommon.BasicLineGraph.DataSet ds in graph.DataSets)
                    {
                        if (ds.Tag==ee)
                        {
                            graph.HighlightedDataSet=ds;
                            break;
                        }
                    }
                }

                graph.RefreshGraph(false);
            }
        }

        private void CheckAlias_Changed(object sender, EventArgs e)
        {
            graph.UseAntialiasing=((CheckBox)sender).Checked;
            graph.RefreshGraph(false);
        }

        private void CheckThick_Changed(object sender, EventArgs e)
        {
            graph.UseThickLines=((CheckBox)sender).Checked;
            graph.RefreshGraph(false);
        }

        private void CheckSample_Changed(object sender, EventArgs e)
        {
            graph.ShowMouseSamplesForHighlighted=((CheckBox)sender).Checked;
            graph.RefreshGraph(false);
        }

        //event handler for a request to close the app
        private void Form_Closing(object sender, FormClosingEventArgs e)
        {
            //save our settings
            XmlNode groupNode=settings.DocumentElement.SelectSingleNode("BaseGui");

            if (Height>50 && Width>50 && WindowState==FormWindowState.Normal) //don't save the form size if the form is max'd or min'd
            {
                XmlUtil.SetChildNodeValue(groupNode, "Width", Width);
                XmlUtil.SetChildNodeValue(groupNode, "Height", Height);
                XmlUtil.SetChildNodeValue(groupNode, "LeftPos", Left);
                XmlUtil.SetChildNodeValue(groupNode, "TopPos", Top);
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", false);
            }
            else if (WindowState==FormWindowState.Maximized)
            {
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", true);
            }

            settings.Save("EventCountDBViewer.xml");
        }

        #endregion //Menu Options and Events

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_eventcountdbviewer_none_12.4.56.0_none_10799d571d1dd2e6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventcountdbviewer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.manifest
XP_MANIFEST_PATH=manifests\msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.cat
XP_CATALOG_PATH=manifests\msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728.cat
XP_PAYLOAD_PATH=msil_eventcountdbviewer_no-public-key_12.4.56.0_x-ww_f511a728
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventcountdbviewer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\FakeLogVault\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\Db.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;

namespace EventCountDB
{
    public class EventCountDBConnection
    {
        public static string HostMachine="evilsphere"; //LukeL's server is the default

        public EventCountDBConnection()
        {
            con=new SqlConnection("Data Source="+HostMachine+";Initial Catalog=EventCountDB;Integrated Security=SSPI");
            con.Open();
        }

        //retrieves a list of all components
        public string[] GetComponents()
        {
            SqlCommand com=new SqlCommand("select distinct vc_component_name from t_events order by vc_component_name", con);
            SqlDataReader reader=com.ExecuteReader();
            List<string> list=new List<string>();
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            return list.ToArray();
        }

        //retrieves a list of all levels
        public string[] GetLevels()
        {
            SqlCommand com=new SqlCommand("select distinct vc_level_name from t_events order by vc_level_name", con);
            SqlDataReader reader=com.ExecuteReader();
            List<string> list=new List<string>();
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            return list.ToArray();
        }

        //retrieves a list of all event numbers used by specific components and levels
        public int[] GetEventNumbers(string []components, string []levels)
        {
            //build where filter
            if (components.Length==0 || levels.Length==0) return new int[0];

            string where="(";
            where+="vc_component_name='"+SqlEscape(components[0])+"'";
            for (int i=1; i<components.Length; ++i)
                where+="or vc_component_name='"+SqlEscape(components[i])+"'";
            where+=") and (";
            where+="vc_level_name='"+SqlEscape(levels[0])+"'";
            for (int i=1; i<levels.Length; ++i)
                where+="or vc_level_name='"+SqlEscape(levels[i])+"'";
            where+=")";

            //do it
            SqlCommand com=new SqlCommand("select distinct i_event_number from t_events where "+where+" order by i_event_number", con);
            SqlDataReader reader=com.ExecuteReader();
            List<int> list=new List<int>();
            while (reader.Read())
            {
                list.Add((int)reader[0]);
            }
            reader.Close();
            return list.ToArray();
        }

        //
        public class EventEntry
        {
            public string Component;
            public string Level;
            public int Number;
        };
        
        //retrieves all events
        public EventEntry[] GetEvents()
        {
            SqlCommand com=new SqlCommand("select vc_component_name,vc_level_name,i_event_number from t_events order by i_event_number", con);
            SqlDataReader reader=com.ExecuteReader();
            List<EventEntry> list=new List<EventEntry>();
            while (reader.Read())
            {
                EventEntry ev=new EventEntry();
                ev.Component=reader[0].ToString();
                ev.Level=reader[1].ToString();
                ev.Number=(int)reader[2];
                list.Add(ev);
            }
            reader.Close();
            return list.ToArray();
        }

        //
        public class DateValue
        {
            public DateTime Date;
            public ulong Count;
        };

        public enum TimeBucket
        {
            Hour,
            Day,
            Month
        }

        //retrieves a list of all all dates and counts for an event
        public DateValue[] GetCounts(string component, string level, int eventNumber, TimeBucket timeBucket, bool zeroBlankSpace)
        {
            //grab the per-hour data
            SqlCommand com=new SqlCommand("select dt_hourbucket,bi_count from t_event_counts where i_event_id=(select i_event_id from t_events where vc_component_name='"+SqlEscape(component)+"' and vc_level_name='"+SqlEscape(level)+"' and i_event_number="+eventNumber+") order by dt_hourbucket", con);
            SqlDataReader reader=com.ExecuteReader();
            List<DateValue> list=new List<DateValue>();
            while (reader.Read())
            {
                DateValue dv=new DateValue();
                dv.Date=(DateTime)reader[0];
                dv.Count=(ulong)(long)reader[1];
                list.Add(dv);
            }
            reader.Close();

            //rebucketize it if needed
            if (timeBucket!=TimeBucket.Hour)
            {
                list=new List<DateValue>(RecountTimeBuckets(list.ToArray(), timeBucket));
            }

            //return it
            if (!zeroBlankSpace)
                return list.ToArray();
            else
                return ZeroOutGaps(list.ToArray(), timeBucket);
        }

        public string GetSampleText(string component, string level, int eventNumber)
        {
            string msg="No sample text found.";

            SqlCommand com=new SqlCommand("select top 1 dt_date,tx_message from t_event_text where i_event_id=(select i_event_id from t_events where vc_component_name='"+SqlEscape(component)+"' and vc_level_name='"+SqlEscape(level)+"' and i_event_number="+eventNumber+") order by dt_date desc", con);
            SqlDataReader reader=com.ExecuteReader();
            if (reader.Read())
            {
                msg="Sample from "+((DateTime)reader[0]).ToString()+"\n\n"+reader[1].ToString();
            }
            reader.Close();

            return msg;
        }

        //
        private string SqlEscape(string s)
        {
            return s.Replace("'","''");
        }

        //puts a count of 0 in gaps where there are no events
        EventCountDBConnection.DateValue[] ZeroOutGaps(EventCountDBConnection.DateValue []orig, TimeBucket timeBucket)
        {
            EventCountDBConnection.DateValue fill;

            TimeSpan gapSpan; //the size of the gap at which point we pad with 0's.  2x the time bucket size (plus float fudge).
            if (timeBucket==TimeBucket.Hour) gapSpan=new TimeSpan(0,2,0,1);
            else if (timeBucket==TimeBucket.Day) gapSpan=new TimeSpan(2,0,1,0);
            else gapSpan=new TimeSpan(30*2,1,0,0);

            List<EventCountDBConnection.DateValue> newvals=new List<EventCountDBConnection.DateValue>();
            if (orig.Length>0)
            {
                EventCountDBConnection.DateValue last=orig[0];

                //pad 0 at start
                fill=new EventCountDBConnection.DateValue();
                fill.Count=0;
                fill.Date=orig[0].Date+new TimeSpan(0,0,0,0,-1);
                newvals.Add(fill);

                //middle
                foreach (EventCountDBConnection.DateValue cur in orig)
                {
                    if ((cur.Date-last.Date)>gapSpan) //if more than gapSpan apart add 0 filler after last and before cur
                    {
                        fill=new EventCountDBConnection.DateValue();
                        fill.Count=0;
                        fill.Date=last.Date+new TimeSpan(0,0,0,0,1);
                        newvals.Add(fill);

                        fill=new EventCountDBConnection.DateValue();
                        fill.Count=0;
                        fill.Date=cur.Date+new TimeSpan(0,0,0,0,-1);
                        newvals.Add(fill);
                    }

                    newvals.Add(cur);

                    last=cur;
                }

                //pad 0 at end
                fill=new EventCountDBConnection.DateValue();
                fill.Count=0;
                fill.Date=orig[orig.Length-1].Date+new TimeSpan(0,0,0,0,1);
                newvals.Add(fill);
            }
            return newvals.ToArray();
        }

        //clumps events into a specific time bucket size
        EventCountDBConnection.DateValue[] RecountTimeBuckets(EventCountDBConnection.DateValue[] origVals, TimeBucket timeBucket)
        {
            List<EventCountDBConnection.DateValue> newVals=new List<EventCountDBConnection.DateValue>();

            foreach (EventCountDBConnection.DateValue oval in origVals)
            {
                //copy it and strip date down to the bucket size
                EventCountDBConnection.DateValue workval=new EventCountDBConnection.DateValue();
                workval.Date=oval.Date;
                workval.Count=oval.Count;
                workval.Date=workval.Date.AddMilliseconds(-workval.Date.Millisecond);
                workval.Date=workval.Date.AddSeconds(-workval.Date.Second);
                workval.Date=workval.Date.AddMinutes(-workval.Date.Minute);
                if (timeBucket==TimeBucket.Day || timeBucket==TimeBucket.Month) workval.Date=workval.Date.AddHours(-workval.Date.Hour);
                if (timeBucket==TimeBucket.Month) workval.Date=workval.Date.AddDays(-workval.Date.Day+1);

                EventCountDBConnection.DateValue lastVal=(newVals.Count==0?null:newVals[newVals.Count-1]);
                if (lastVal==null || Math.Abs((workval.Date-lastVal.Date).TotalSeconds)>1) //new bucket needed
                {
                    newVals.Add(workval);
                }
                else //add to previous bucket
                {
                    lastVal.Count+=workval.Count;
                }
            }

            return newVals.ToArray();
        }

        SqlConnection con;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\FakeLogVault\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\EventCountDB\viewer\Generator.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Drawing;

namespace EventCountDB
{
    public class HtmlGraphGenerator
    {
        //generates html/graphic reports for all components for a specific period of time
        public void Generate(string dropPath, System.DateTime startTime, System.TimeSpan duration, EventCountDB.EventCountDBConnection.TimeBucket bucketSize)
        {
            System.IO.Directory.CreateDirectory(dropPath);

            //connect to db
            try
            {
                db=new EventCountDBConnection();
            }
            catch (Exception e)
            {
                MessageBox.Show("Failed to connect to db: "+e);
                return;
            }

            //get the event list and break it down into a per-component list
            System.DateTime generationStartTime=System.DateTime.UtcNow;

            EventCountDBConnection.EventEntry []allEvents=db.GetEvents();
            Dictionary<string, LinkedList<EventCountDBConnection.EventEntry>> componentEvents=new Dictionary<string,LinkedList<EventCountDBConnection.EventEntry>>();
            foreach (EventCountDBConnection.EventEntry ee in allEvents)
            {
                if (!componentEvents.ContainsKey(ee.Component))
                {
                    componentEvents.Add(ee.Component, new LinkedList<EventCountDBConnection.EventEntry>());
                }

                componentEvents[ee.Component].AddLast(ee);
            }

            //generate the per-component pages
            List<string> usedComponents=new List<string>();
            foreach (KeyValuePair<string, LinkedList<EventCountDBConnection.EventEntry>> kvp in componentEvents)
            {
                if (GenerateComponent(kvp.Key, kvp.Value, dropPath, startTime, duration, bucketSize, false))
                {
                    usedComponents.Add(kvp.Key);
                }

                GenerateEventSamplesForComponent(kvp.Key, kvp.Value, dropPath, startTime, duration, bucketSize);
                GenerateEventCountsForComponent(kvp.Key, kvp.Value, dropPath, startTime, duration, bucketSize);
            }

            //generate the "Everything" page
            GenerateComponent("Everything", allEvents, dropPath, startTime, duration, bucketSize, true);

            //generate the summary page
            System.TimeSpan generationTotalTime=System.DateTime.UtcNow-generationStartTime;

            string html="<html>\n<head>\n<title>Summary</title>\n";
            html+="<meta http-equiv=\"cache-control\" content=\"no-cache\">\n</head>\n";
            html+="<body bgcolor=#000000 text=#dddddd link=#aaaaff vlink=#ffaaff alink=#ffccff>\n";

            html+="Generated: "+GetCurrentUserFriedlyTimestamp()+"<br>\n";
            html+="Time to generate: "+generationTotalTime.TotalSeconds+"s<br><br>\n";

            html+="<table>\n";
            html+="<tr><td>-<b>Component</b>-</td> <td> -<b>Event Text</b>-</td></tr>\n";
            html+="<tr><td><a href=\"Everything.html\">Everything</a></td></tr>\n";
            html+="<tr><td>&nbsp;</td> <td>&nbsp;</td></tr>\n";

            usedComponents.Sort();
            foreach (string comp in usedComponents)
            {
                html+="<tr>";
                html+="<td><a href=\""+SanitizeComponentName(comp)+".html\">"+comp+"</a></td> ";
                html+="<td align=center><a href=\""+SanitizeComponentName(comp)+"_samples.html\">samples</a></td>";
                html+="<td align=center><a href=\""+SanitizeComponentName(comp)+"_counts.html\">counts</a></td>";
                html+="</tr>\n";
            }
            html+="</table>\n";

            html+="</body>\n</html>\n";

            System.IO.File.WriteAllText(dropPath+"\\default.htm", html);

            //
            db=null;
        }

        // --

        //does the graph/html generation for a component
        private bool GenerateComponent(string componentName, IEnumerable<EventCountDBConnection.EventEntry> eventList, string dropPath, System.DateTime startTime, System.TimeSpan duration, EventCountDB.EventCountDBConnection.TimeBucket bucketSize, bool showComponentInTable)
        {
            System.DateTime endTime=startTime+duration;

            //pull the data from the db and filter out anything not in our time range
            List<EventDataPair> eventData=new List<EventDataPair>();
            foreach (EventCountDBConnection.EventEntry ee in eventList)
            {
                EventDataPair edp=null;

                EventCountDBConnection.DateValue []data=db.GetCounts(ee.Component, ee.Level, ee.Number, bucketSize, true);
                foreach (EventCountDBConnection.DateValue dv in data)
                {
                    if (dv.Date>=startTime && dv.Date<=endTime) //it has data in range, so use it
                    {
                        if (edp==null)
                        {
                            edp=new EventDataPair();
                            edp.Event=ee;
                            edp.Data=data;
                        }

                        edp.CountInRange+=dv.Count;
                    }
                }

                if (edp!=null)
                {
                    eventData.Add(edp);
                }
            }

            eventData.Sort(EventDataPair.CompareCounts);

            //write the page head
            string html="<html>\n<head>\n<title>"+componentName+"</title>\n";
            html+="<meta http-equiv=\"cache-control\" content=\"no-cache\">\n</head>\n";
            html+="<body bgcolor=#000000 text=#dddddd link=#aaaaff vlink=#ffaaff alink=#ffccff>\n";

            html+="Generated: "+GetCurrentUserFriedlyTimestamp()+"<br><br>\n";
            html+="Component: "+componentName+"<br>\n";
            html+=""+eventData.Count+" unique events in "+(duration.TotalDays<2?""+duration.TotalHours+" hours":""+duration.TotalDays+" days")+"<br>\n";

            //generate the graph
            Bitmap graphBitmap=new Bitmap(800, 400, System.Drawing.Imaging.PixelFormat.Format24bppRgb);
            GraphicsCommon.DateCountLineGraph graph=new GraphicsCommon.DateCountLineGraph(graphBitmap);
            graph.MinYRangeAmount=3.0f;
            graph.MinXRangeAmount=GraphicsCommon.DateCountLineGraph.HourWidth*2;
            graph.MinimumResolutionIsHour=true;

            foreach (EventDataPair edp in eventData)
            {
                //make a data set for this event
                GraphicsCommon.BasicLineGraph.DataSet ds=new GraphicsCommon.BasicLineGraph.DataSet();
                ds.Tag=edp;
                graph.DataSets.Add(ds);

                //populate the data set
                foreach (EventCountDBConnection.DateValue value in edp.Data)
                {
                    graph.AddDateValue(ds, value.Date, value.Count);
                }
            }

            //adjust the graph bounds
            graph.RefreshDataBounds();
            float minX=graph.ConvertDateToX(startTime);
            float maxX=graph.ConvertDateToX(startTime+duration);
            graph.EnforceXViewLimit=false;
            graph.XRange=maxX-minX;
            graph.XOffset=minX;
            graph.YOffset=0;
            graph.FitYBoundToXRange(false, true);

            //render it and save it to a file
            graph.RecalcIntervals(); //TODO: make this automatic (when used as a bitmap)
            graph.RefreshGraph();
            graphBitmap.Save(dropPath+"\\"+SanitizeComponentName(componentName)+".png");

            html+="Showing range: "+startTime+" to "+(startTime+duration)+" (UTC)<br>\n";
            html+="Showing values: "+graph.YOffset+" to "+(graph.YOffset+graph.YRange)+"<br><br>\n";
            html+="<small>(Graph: Events per "+(bucketSize)+")</small><br>\n";
            html+="<img src=\""+SanitizeComponentName(componentName)+".png\" style=\"border: 2px white solid\"><br><br>\n";

            //now add a table for the events
            html+="<table border=1>\n";
            html+="<tr><td>-<b>Count</b>-</td> "+(showComponentInTable?"<td>-<b>Component</b>-</td> ":"")+"<td>-<b>Level</b>-</td> <td>-<b>Event</b>-</td></tr>\n";
            foreach (GraphicsCommon.BasicLineGraph.DataSet ds in graph.DataSets)
            {
                EventDataPair edp=(EventDataPair)ds.Tag;

                html+="<tr>";
                html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+edp.CountInRange+"</font></td> ";
                if (showComponentInTable) html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+edp.Event.Component+"</font></td> ";
                html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+edp.Event.Level+"</font></td> ";
                html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+edp.Event.Number+"</font></td> ";
                html+="<td><a href=\""+edp.Event.Component+"_samples.html#num"+edp.Event.Number+"\">sample</a></td>";
                html+="<td><a href=\""+edp.Event.Component+"_counts.html#num"+edp.Event.Number+"\">counts</a></td>";
                html+="</tr>\n";
            }

            html+="</table>\n";

            //finish page
            html+="</body>\n</html>\n";
            System.IO.File.WriteAllText(dropPath+"\\"+SanitizeComponentName(componentName)+".html", html);

            //
            return eventData.Count>0;
        }

        private void GenerateEventSamplesForComponent(string componentName, IEnumerable<EventCountDBConnection.EventEntry> eventListForComponent, string dropPath, System.DateTime startTime, System.TimeSpan duration, EventCountDB.EventCountDBConnection.TimeBucket bucketSize)
        {
            string html="<html>\n<head>\n<title>"+componentName+" Event Samples</title>\n";
            html+="<meta http-equiv=\"cache-control\" content=\"no-cache\">\n</head>\n";
            html+="<body bgcolor=#000000 text=#dddddd link=#aaaaff vlink=#ffaaff alink=#ffccff>\n";

            html+="Generated: "+GetCurrentUserFriedlyTimestamp()+"<br>\n";
            html+="Component: "+componentName+"<br><br>\n";

            foreach (EventCountDBConnection.EventEntry ee in eventListForComponent)
            {
                html+="<hr><br><a id=\"num"+ee.Number+"\"></a><b><big>"+componentName+" "+ee.Number+"</big></b> ("+ee.Level+")<br>\n";

                string sample=db.GetSampleText(componentName, ee.Level, ee.Number);
                sample=sample.Replace("&","&#38;");
                sample=sample.Replace("<","&#60;");
                sample=sample.Replace(">","&#62;");
                sample=sample.Replace("\n","<br>");
                html+=sample+"<br><br>\n";
            }

            html+="</body>\n</html>\n";
            System.IO.File.WriteAllText(dropPath+"\\"+SanitizeComponentName(componentName)+"_samples.html", html);
        }

        private void GenerateEventCountsForComponent(string componentName, IEnumerable<EventCountDBConnection.EventEntry> eventListForComponent, string dropPath, System.DateTime startTime, System.TimeSpan duration, EventCountDB.EventCountDBConnection.TimeBucket bucketSize)
        {
            string html="<html>\n<head>\n<title>"+componentName+" Event Counts</title>\n";
            html+="<meta http-equiv=\"cache-control\" content=\"no-cache\">\n</head>\n";
            html+="<body bgcolor=#000000 text=#dddddd link=#aaaaff vlink=#ffaaff alink=#ffccff>\n";

            html+="Generated: "+GetCurrentUserFriedlyTimestamp()+"<br>\n";
            html+="Component: "+componentName+"<br><br>\n";

            foreach (EventCountDBConnection.EventEntry ee in eventListForComponent)
            {
                EventCountDBConnection.DateValue []dvList=db.GetCounts(componentName, ee.Level, ee.Number, bucketSize, false);
                System.Collections.Generic.List<EventCountDBConnection.DateValue> dvListInRange=new System.Collections.Generic.List<EventCountDBConnection.DateValue>();
                foreach (EventCountDBConnection.DateValue dv in dvList)
                {
                    if (dv.Date>=startTime && dv.Date<=startTime+duration)
                    {
                        dvListInRange.Add(dv);
                    }
                }

                if (dvListInRange.Count>0)
                {
                    html+="<hr><br><a id=\"num"+ee.Number+"\"></a><b><big>"+componentName+" "+ee.Number+"</big></b> ("+ee.Level+")<br>\n";
                    html+="<br><table border=1>\n";
                    html+="<tr> <td>-Time-</td> <td>-Count per "+bucketSize+"-</td>  </tr>\n";
                    foreach (EventCountDBConnection.DateValue dv in dvListInRange)
                    {
                        html+="<tr> <td>"+dv.Date+"</td> <td>"+dv.Count+"</td>  </tr>\n";
                    }
                    html+="</table>";

                    html+="<br><br>\n";
                }
            }

            html+="</body>\n</html>\n";
            System.IO.File.WriteAllText(dropPath+"\\"+SanitizeComponentName(componentName)+"_counts.html", html);
        }

        //converts a color to an html color string
        string MakeHTMLColor(System.Drawing.Color color)
        {
            return ByteToHex(color.R)+ByteToHex(color.G)+ByteToHex(color.B);
        }

        string ByteToHex(byte b)
        {
            string s="";
            if ((b&0xf) < 0xa)
                s+=b&0xf;
            else
                s+=(char)((b&0xf)-10+(byte)'a');

            b>>=4;

            if ((b&0xf) < 0xa)
                s=(b&0xf)+s;
            else
                s=(char)((b&0xf)-10+(byte)'a')+s;

            return s;
        }

        //for purposes of making a filename from it
        private string SanitizeComponentName(string name)
        {
            name=name.Replace('/',',');
            name=name.Replace('\\',',');
            name=name.Replace('*',',');
            name=name.Replace('?',',');
            name=name.Replace('|',',');
            name=name.Replace('<',',');
            name=name.Replace('>',',');
            return name;
        }

        //returns a string with the current date and time, in both utc and pacific time
        private string GetCurrentUserFriedlyTimestamp()
        {
            DateTime dtNow=System.DateTime.UtcNow;
            string str=dtNow.ToString()+" UTC (";
            //DateTime dtPacific=System.TimeZoneInfo.ConvertTime(dtNow, System.TimeZoneInfo.indSystemTimeZoneById("Pacific Standard Time"));
            str+=dtNow.ToLocalTime().ToString();
            str+=" PST)";
            return str;
        }

        // --

        EventCountDBConnection db;

        class EventDataPair
        {
            public EventCountDBConnection.EventEntry Event;
            public EventCountDBConnection.DateValue []Data;
            public ulong CountInRange; //number of events total in the desired time range

            //to sort by count descending
            public static int CompareCounts(EventDataPair o1, EventDataPair o2)
            {
                return -o1.CountInRange.CompareTo(o2.CountInRange);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\FakeLogVault\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_fakelogvault_none_12.4.56.0_none_52d100134126ff22
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=fakelogvault
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.manifest
XP_MANIFEST_PATH=manifests\msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.cat
XP_CATALOG_PATH=manifests\msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.cat
XP_PAYLOAD_PATH=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=fakelogvault,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\FakeLogVault\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_fakelogvault_none_12.4.56.0_none_52d100134126ff22
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=fakelogvault
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.manifest
XP_MANIFEST_PATH=manifests\msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.cat
XP_CATALOG_PATH=manifests\msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26.cat
XP_PAYLOAD_PATH=msil_fakelogvault_no-public-key_12.4.56.0_x-ww_4d4b1c26
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=fakelogvault,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GetLiveBldVer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GetLiveBldVer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_getlivebldver_none_12.4.56.0_none_88cb282ed613f1d8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=getlivebldver
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_MANIFEST_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_CATALOG_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_PAYLOAD_PATH=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=getlivebldver,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GetLiveBldVer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GraphicsCommon\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GetLiveBldVer\GetLiveBldVer.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.InteropServices;

namespace GetLiveBldVer
{
	/// <summary>
	/// Summary description for SetLiveBldVer.
	/// </summary>
	class AppMain
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
			LiveBldVer app = new LiveBldVer();
            int retVal = app.Run(args);
            return(retVal);
		}
	}

    class LiveBldVer
    {
        const string ENV_VAR_NAME = "_LIVE_BUILD_VERSION";

        private string GetServerName(string[] args)
        {
            if (args.Length == 0)
            {
                return("npdb");
            }
            if (args.Length > 1)
            {
                throw new Exception("Invalid number of arguments.");
            }
            string serverName = args[0];
            if (serverName.IndexOf("?") != -1)
            {
                throw new Exception("Displaying help.");
            }
            try
            {
                System.Net.IPHostEntry host = System.Net.Dns.GetHostEntry(serverName);
            }
            catch(Exception e)
            {
                throw new Exception("Argument '" + args[0] + "' is not a valid NPDB host name.\r\nException: " + e.Message);
            }
            return(serverName);
        }

        private string GetLiveBuildVer(string serverName)
        {
            SqlConnection conn = new SqlConnection();
            conn.ConnectionString = "Data Source=" + serverName + ";Initial Catalog=npdb;Integrated Security=SSPI;";

            SqlCommand cmd = new SqlCommand();
            cmd.Connection = conn;
            cmd.CommandText = "select vc_value from t_settings where vc_setting = 'global_buildVersion'";

            string buildVer;
            try
            {
                conn.Open();
                SqlDataReader reader = null;
                try
                {
                    reader = cmd.ExecuteReader();
                    if (!reader.HasRows)
                    {
                        throw new Exception("Failed to retrieve any data from server.");
                    }
                    if (!reader.Read())
                    {
                        throw new Exception("Failed to read data.");
                    }
                    buildVer = reader.GetString(0);
                }
                finally
                {
                    try
                    {
                        if (reader != null)
                        {
                            if (!reader.IsClosed)
                            {
                                reader.Close();
                            }
                        }
                    }
                    catch {}
                }
            }
            finally
            {
                try
                {
                    conn.Close();
                }
                catch {}
            }
            return(buildVer);
        }

        private void DisplayHelp()
        {
            Console.WriteLine(@"Usage:
GetLiveBldVer <serverName>

Examples:
    Generic:    GetLiveBldVer npdb
    TestNet:    GetLiveBldVer 10.20.206.204
    BvtNet:     GetLiveBldVer 10.20.3.201
");
        }

        public int Run(string[] args)
        {
            string buildVer = "";
            try
            {
                string serverName = GetServerName(args);
                buildVer = GetLiveBuildVer(serverName);
            }
            catch(Exception e)
            {
                Console.WriteLine("FAILED:" + e.Message);
                DisplayHelp();
                return(1);
            }
            Console.WriteLine("SUCCESS:global_buildVersion=" + buildVer);
            return(0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\FakeLogVault\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace FakeLogVaultTool
{
    class FakeLogVaultTool
    {
        [STAThread]
        static void Main(string[] args)
        {
            // Parameters
            string envName="";
            string iface="";
            string component="";
            string path="";
            uint interval=0;
            string []areas=null;


            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse params
            if (args.Length<6)
            {
                Console.WriteLine("Usage: FakeLogVault environment interface component path interval area0 [area1] [area#...]");
                Console.WriteLine("  environment: The envirnoment to poll. (ex: TestNet)");
                Console.WriteLine("  interface:   The interface to retrieve the server list from. (ex: kdcsvc)");
                Console.WriteLine("  component:   The xmgmt component name to listen to. (ex: askdc)");
                Console.WriteLine("  path:        The local path to save files to. (ex: logs)");
                Console.WriteLine("  interval:    How frequently to write new files, in seconds. (ex: 20)");
                Console.WriteLine("  areaN:       A list of one or more areas to pull output from. (ex: log)");
                Console.WriteLine("");
                Console.WriteLine("  example: FakeLogVault TestNet kdcsvc askdc logs 20 log");
                return;
            }

            envName=args[0];
            iface=args[1];
            component=args[2];
            path=args[3];
            interval=uint.Parse(args[4]);

            System.Collections.Generic.List<string> areaList=new System.Collections.Generic.List<string>();
            for (uint i=5; i<args.Length; ++i)
            {
                areaList.Add(args[i]);
            }
            areas=areaList.ToArray();

            // Initialize the STF
            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found = false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                Console.WriteLine("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            //set up to handle interruptions, so that we can clean up afterwards
            FakeLogVault vault=null;
            Console.CancelKeyPress+=
                delegate(object sender, ConsoleCancelEventArgs e)
                {
                    Console.WriteLine("Stopping FakeLogVault...");
                    if (vault!=null)
                    {
                        vault.Dispose();
                        vault=null;
                    }
                };

            //Start the fake logvault processing
            Console.WriteLine("Starting FakeLogVault...");
            vault=new FakeLogVault(iface, component, areas, path, interval);

            //Now await oblivion
            Console.WriteLine("FakeLogVault Started.");
            while (true)
            {
                System.Threading.Thread.Sleep(60000);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GraphicsCommon\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GetLiveBldVer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_getlivebldver_none_12.4.56.0_none_88cb282ed613f1d8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=getlivebldver
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_MANIFEST_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_CATALOG_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_PAYLOAD_PATH=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=getlivebldver,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GraphicsCommon\Grapher.cs ===
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Collections.Generic;

namespace GraphicsCommon
{
    //graphs date and count data, including labels
    public class DateCountLineGraph: LineGraphWithLabels
    {
        //data widths to represent a date (0 year 2000)
        public const float YearWidth=12.0f;
        public const float MonthWidth=YearWidth/12.0f;
        public const float DayWidth=YearWidth/365.0f;
        public const float HourWidth=DayWidth/24.0f;
        public const float MinuteWidth=HourWidth/60.0f;
        public const float SecondWidth=MinuteWidth/60.0f;
        public const float MillisecondWidth=SecondWidth/1000.0f;

        public bool MinimumResolutionIsHour=false;

        //adds a date value to a set, with x=0 being year 2000
        public void AddDateValue(DataSet ds, DateTime date, float value)
        {
            ds.Data.Add(new DataPoint(ConvertDateToX(date), value));
        }

        //converts a date to an x value
        public float ConvertDateToX(DateTime date)
        {
            float x=(date.Year-2000.0f)*YearWidth;
            x+=date.DayOfYear*DayWidth;
            x+=date.Hour*HourWidth;
            x+=date.Minute*MinuteWidth;
            x+=date.Second*SecondWidth;
            x+=date.Millisecond*MillisecondWidth;
            return x;
        }

        //gets a date represented by x, or min value if not possible
        public DateTime ConvertXToDate(float x)
        {
            int year=(int)(x/YearWidth);
            float rem=x-year*YearWidth;
            int day=(int)(rem/DayWidth);
            rem-=day*DayWidth;
            int hour=(int)(rem/HourWidth);
            rem-=hour*HourWidth;
            int minute=(int)(rem/MinuteWidth);
            rem-=minute*MinuteWidth;
            int second=(int)(rem/SecondWidth);
            rem-=second*SecondWidth;
            int milli=(int)(rem/MillisecondWidth+0.5f);

            if (year<0 || year>7999) return DateTime.MinValue;
            year+=2000;

            try
            {
                DateTime dt=new DateTime(year, 1, 1, hour, minute, second);
                dt=dt.AddDays(day-1);
                dt=dt.AddMilliseconds(milli);
                return dt;
            }
            catch
            {
                return DateTime.MinValue;
            }
        }

        //gets the string to display for any given data value
        public override string GetXTickName(float x, bool fullDetails)
        {
            //
            DateTime dt=ConvertXToDate(x);
            if (dt==DateTime.MinValue) return "???";

            if (!fullDetails && XRange>=10*YearWidth) //give only year
                return dt.Year.ToString();
            else if (!fullDetails && XRange>=10*MonthWidth) //give every month
                return dt.Year+"\n"+GetMonthName(dt.Month-1);
            else if (!fullDetails && XRange>=0.5f*MonthWidth) //give every day
                return dt.Year+"\n"+GetMonthName(dt.Month-1)+" "+dt.Day;
            else if (!fullDetails && MinimumResolutionIsHour) //show down to the hour
            {
                string l1=dt.Year+" "+GetMonthName(dt.Month-1);
                string l2=dt.Day+"   "+dt.ToString("HH:00");
                return l1+"\n"+l2;
            }
            else //give down to the ms
            {
                string l1=dt.Year+" "+GetMonthName(dt.Month-1)+" "+dt.Day;
                string l2=dt.ToString("HH:mm:ss.FFF");
                l1=string.Format("{0,"+l2.Length/2+"}", l1);
                return l1+"\n"+l2;
            }
        }
        public override string GetYTickName(float y, bool fullDetails)
        {
            if (fullDetails)
                return y.ToString();
            else
                return string.Format("{0:F1}",y);
        }

        public string GetMonthName(int m)
        {
            string []months={"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
            return months[m%12];
        }

        //ctor
        public DateCountLineGraph()
        {
            ReservedYSpace=29.0f;
            XLabelMargin=30.0f;

            ViewChangedEvent+=RecalcIntervals;
            Resize+=OnResize;
        }

        public DateCountLineGraph(Bitmap bm): base(bm)
        {
            ReservedYSpace=29.0f;
            XLabelMargin=30.0f;
        }

        // -- internals

        //update the tick spacing and locations
        public void RecalcIntervals()
        {
            //y counts
            YTickIntervalOffset=0;

            YTickIntervals=YRange/20;
            if (Height<600) YTickIntervals*=2;
            if (Height<300) YTickIntervals*=2;

            //x date
            XTickIntervalOffset=-HourWidth;

            if (XRange<HourWidth)
                XTickIntervals=XRange*Width/80;
            else if (XRange<0.7f*DayWidth)
                XTickIntervals=HourWidth;
            else if (XRange<4.0f*DayWidth)
                XTickIntervals=6*HourWidth;
            else if (XRange<0.5f*MonthWidth)
                XTickIntervals=DayWidth;
            else if (XRange<2*MonthWidth)
                XTickIntervals=DayWidth*3;
            else if (XRange<6*MonthWidth)
                XTickIntervals=DayWidth*10;
            else if (XRange<3*YearWidth)
                XTickIntervals=MonthWidth;
            else if (XRange<30*YearWidth)
                XTickIntervals=YearWidth;
            else
                XTickIntervals=5*YearWidth;
            
            if (Width<800) XTickIntervals*=2;
            if (Width<400) XTickIntervals*=2;
            if (Width<200) XTickIntervals*=2;
        }

        private void OnResize(object sender, EventArgs e)
        {
            RecalcIntervals();
        }
    }

    //a line graph with x and y labels
    public class LineGraphWithLabels: BasicLineGraph
    {
        public bool ShowXLabels=true;
        public bool ShowYLabels=true;

        //intervals at which to show a tick mark (in data space)
        public float XTickIntervals=1.0f;
        public float YTickIntervals=1.0f;

        //value to which multiples of the interval are added to produce the tick mark locations
        public float XTickIntervalOffset=0.0f;
        public float YTickIntervalOffset=0.0f;

        //distance from the edge of the graph (screen space) to draw the outter labels
        public float XLabelMargin=20.0f;
        public float YLabelMargin=20.0f;

        //gets the string to display for any given data value
        public virtual string GetXTickName(float x, bool fullDetails)
        {
            return x.ToString();
        }
        public virtual string GetYTickName(float y, bool fullDetails)
        {
            return y.ToString();
        }

        //ctor - also sets a default space for labels (you may need to adjust the reserved space to fit what you need)
        public LineGraphWithLabels()
        {
            ReservedXSpace=20.0f;
            ReservedYSpace=20.0f;

            GraphDrawnEvent+=DrawLabelsOnGraph;
            MouseMove+=Graph_MouseMove;
        }

        public LineGraphWithLabels(Bitmap bm): base(bm)
        {
            ReservedXSpace=20.0f;
            ReservedYSpace=20.0f;

            GraphDrawnEvent+=DrawLabelsOnGraph;
        }

        //show specific value on mouse movement for the highlighted sample
        public bool ShowMouseSamplesForHighlighted=true;

        // -- internals

        private int mouseX=0, mouseY=0;

        private void DrawLabelsOnGraph(Graphics g)
        {
            //calc data space edges for points to use
            DataPoint sp=new DataPoint(ReservedXSpace+XLabelMargin, Height-ReservedYSpace);
            DataPoint dpx0=InverseTransformPoint(sp);
            sp=new DataPoint(Width-XLabelMargin, Height-ReservedYSpace);
            DataPoint dpx1=InverseTransformPoint(sp);

            sp=new DataPoint(ReservedXSpace, YLabelMargin);
            DataPoint dpy0=InverseTransformPoint(sp);
            sp=new DataPoint(ReservedXSpace, Height-ReservedYSpace-YLabelMargin);
            DataPoint dpy1=InverseTransformPoint(sp);

            float minX=dpx0.X, maxX=dpx1.X;
            float minY=dpy1.Y, maxY=dpy0.Y;

            //draw x axis labels
            if (ShowXLabels)
            {
                float startX=minX-(float)Math.IEEERemainder(minX+XTickIntervalOffset,XTickIntervals);
                float curX=startX;

                while (curX<=maxX*1.0001f)
                {
                    if (curX>=minX*0.9999f)
                    {
                        sp=TransformPoint(new DataPoint(curX, Height-ReservedYSpace));
                        DrawXLabel(g, sp.X, GetXTickName(curX, false));
                    }
                    curX+=XTickIntervals;
                }
            }

            //draw y axis labels
            if (ShowYLabels)
            {
                float startY=minY-(float)Math.IEEERemainder(minY+YTickIntervalOffset,YTickIntervals);
                float curY=startY;

                while (curY<=maxY*1.0001f)
                {
                    if (curY>=minY*0.9999f)
                    {
                        sp=TransformPoint(new DataPoint(ReservedXSpace, curY));
                        DrawYLabel(g, sp.Y, GetYTickName(curY, false));
                    }
                    curY+=YTickIntervals;
                }
            }

            //draw highlighted sample data
            if (ShowMouseSamplesForHighlighted && HighlightedDataSet!=null)
            {
                //get the dataspace x value
                sp=new DataPoint(mouseX, mouseY);
                DataPoint dp=InverseTransformPoint(sp);
                float sampleX=dp.X;

                //find the data point pairs to sample between
                for (int i=1; i<HighlightedDataSet.Data.Count; ++i)
                {
                    float x0=HighlightedDataSet.Data[i-1].X;
                    float x1=HighlightedDataSet.Data[i].X;
                    float y0=HighlightedDataSet.Data[i-1].Y;
                    float y1=HighlightedDataSet.Data[i].Y;
                    if (sampleX>=x0 && sampleX<x1) //found a pair
                    {
                        float xSubSamplePos=(sampleX-x0)/(x1-x0); //0-1
                        float sampleY=y0+(y1-y0)*xSubSamplePos;

                        //draw text
                        Font drawFont = new Font("Arial", 8);
                        SolidBrush drawBrush = new SolidBrush(Color.White);
                        PointF drawPoint = new PointF(ReservedXSpace+(Width-ReservedXSpace)/3, 1);
                        g.DrawString("X="+GetXTickName(sampleX, true), drawFont, drawBrush, drawPoint);

                        drawPoint = new PointF(ReservedXSpace+2*(Width-ReservedXSpace)/3, 1);
                        g.DrawString("Y="+GetYTickName(sampleY, true), drawFont, drawBrush, drawPoint);

                        break;
                    }
                }
            }
        }

        private void DrawXLabel(Graphics g, float xScreenPos, string value)
        {
            g.DrawLine(new Pen(Color.White), xScreenPos, Height-ReservedYSpace-1, xScreenPos, Height-ReservedYSpace+5);

            Font drawFont = new Font("Arial", 8);
            SolidBrush drawBrush = new SolidBrush(Color.White);
            PointF drawPoint = new PointF(xScreenPos-4*value.Length/(CountBreaks(value)+2), Height-ReservedYSpace+4);
            g.DrawString(value, drawFont, drawBrush, drawPoint);
        }

        private void DrawYLabel(Graphics g, float yScreenPos, string value)
        {
            g.DrawLine(new Pen(Color.White), ReservedXSpace-2, yScreenPos, ReservedXSpace+8, yScreenPos);

            Font drawFont = new Font("Arial", 8);
            SolidBrush drawBrush = new SolidBrush(Color.White);
            PointF drawPoint = new PointF(0, yScreenPos);
            g.DrawString(value, drawFont, drawBrush, drawPoint);
        }

        private int CountBreaks(string s)
        {
            int num=0;
            foreach (char c in s)
            {
                if (c=='\n') ++num;
            }
            return num;
        }

        private void Graph_MouseMove(object sender, MouseEventArgs ea)
        {
            mouseX=ea.X;
            mouseY=ea.Y;
            if (ShowMouseSamplesForHighlighted && HighlightedDataSet!=null)
            {
                RefreshGraph(false);
            }
        }
    }

    //provides rudimentary line graphing ability (no labels or anything special, just data)
    public class BasicLineGraph: Panel
    {
        // -- public

        //enforce that the view don't exceed the data value ranges
        public bool EnforceXViewLimit=true;
        public bool EnforceYViewLimit=true;

        //location and range of data to show (y is meaningless if YDataAutoScale is true)
        public float XOffset
        {
            get {return xOffset;}
            set
            {
                xOffset=value;
                if (EnforceXViewLimit)
                {
                    if (xOffset<DataMinX) xOffset=DataMinX;
                    if (xOffset>DataMaxX-XRange) xOffset=DataMaxX-XRange;
                }
                if (ViewChangedEvent!=null) ViewChangedEvent();
            }
        }
        public float XRange
        {
            get {return xRange;}
            set
            {
                xRange=value;
                if (EnforceXViewLimit)
                {
                    if (xRange<MinXRangeAmount) xRange=MinXRangeAmount;
                    if (xRange>DataMaxX-DataMinX) xRange=DataMaxX-DataMinX;
                    if (xOffset<DataMinX) xOffset=DataMinX;
                    if (xOffset>DataMaxX-XRange) xOffset=DataMaxX-XRange;
                }
                if (ViewChangedEvent!=null) ViewChangedEvent();
            }
        }
        public float YOffset
        {
            get {return yOffset;}
            set
            {
                yOffset=value;
                if (EnforceYViewLimit)
                {
                    if (yOffset<DataMinY) yOffset=DataMinY;
                    if (yOffset>DataMaxY-YRange) yOffset=DataMaxY-YRange;
                }
                if (ViewChangedEvent!=null) ViewChangedEvent();
            }
        }
        public float YRange
        {
            get {return yRange;}
            set
            {
                yRange=value;
                if (EnforceYViewLimit)
                {
                    if (yRange<MinYRangeAmount) yRange=MinYRangeAmount;
                    if (yRange>DataMaxY-DataMinY) yRange=DataMaxY-DataMinY;
                    if (yOffset<DataMinY) yOffset=DataMinY;
                    if (yOffset>DataMaxY-YRange) yOffset=DataMaxY-YRange;
                }
                if (ViewChangedEvent!=null) ViewChangedEvent();
            }
        }

        //if enabled, y-axis data will be scaled to fit the full y range on a per-data-set level
        //public bool YDataAutoScale=false;

        //minimum allowable range to show for each axis
        public float MinXRangeAmount=0.00001f;
        public float MinYRangeAmount=0.00001f;

        //event called when the offset or range changes
        public event ViewChangedDelegate ViewChangedEvent;
        public delegate void ViewChangedDelegate();

        //represents a data point
        public struct DataPoint: IComparable<DataPoint>
        {
            public float X;
            public float Y;

            public DataPoint(float x, float y)
            {
                X=x;
                Y=y;
            }

            public int CompareTo(DataPoint o)
            {
                return X.CompareTo(o.X);
            }
        }

        //a set of data that makes up one element of the graph (Data Points MUST be stored in ascending x order)
        public class DataSet
        {
            public Color Color; //used internally
            public List<DataPoint> Data=new List<DataPoint>();
            public object Tag; //user-defined data
        }

        //the data that makes up the graph
        public List<DataSet> DataSets=new List<DataSet>();

        //automatically calcs the bounds of the graph to match the current entire data set (assumes data has not changed since last RefreshGraph)
        public void FitBoundsToData(bool fitX, bool fitY)
        {
            if (fitX)
            {
                XOffset=DataMinX;
                XRange=DataMaxX-DataMinX;
            }

            if (fitY)
            {
                YOffset=DataMinY;
                YRange=DataMaxY-DataMinY;
            }
        }

        //recalculates the y axis bounds so that they fit the data within the x range
        public void FitYBoundToXRange(bool adjustYOffset, bool adjustYRange)
        {
            //calc the y data bounds in the x range
            float minY=float.MaxValue, maxY=float.MinValue;
            float xHighBound=XOffset+XRange;

            foreach (DataSet ds in DataSets)
            {
                foreach (DataPoint dp in ds.Data)
                {
                    if (dp.X>=XOffset && dp.X<=xHighBound)
                    {
                        if (dp.Y<minY) minY=dp.Y;
                        if (dp.Y>maxY) maxY=dp.Y;
                    }
                }
            }

            //adjust
            if (adjustYOffset)
            {
                YOffset=minY;
            }

            if (adjustYRange)
            {
                YRange=maxY-YOffset;
            }
        }

        //Updated the allowed view bounds, based on the current graph data (derived classes MUST also call the base)
        public virtual void RefreshDataBounds()
        {
            //recalc x
            float minX=float.MaxValue, maxX=float.MinValue;
            foreach (DataSet ds in DataSets)
            {
                if (ds.Data.Count==0) continue;

                float x=ds.Data[0].X;
                if (x<minX) minX=x;
                if (x>maxX) maxX=x;

                x=ds.Data[ds.Data.Count-1].X;
                if (x<minX) minX=x;
                if (x>maxX) maxX=x;
            }

            if (minX==maxX) //0 range is bad
            {
                maxX+=0.0001f;
                minX-=0.0001f;
            }

            dataXMin=minX;
            dataXMax=maxX;

            //recalc y
            float minY=float.MaxValue, maxY=float.MinValue;

            foreach (DataSet ds in DataSets)
            {
                foreach (DataPoint dp in ds.Data)
                {
                    if (dp.Y<minY) minY=dp.Y;
                    if (dp.Y>maxY) maxY=dp.Y;
                }
            }

            if (minY==maxY) //0 range is bad
            {
                maxY+=0.01f;
                minY-=0.01f;
            }

            dataYMin=minY;
            dataYMax=maxY;
        }

        //updates the graph to match the current data and view settings
        public void RefreshGraph()
        {
            RefreshGraph(true);
        }
        public void RefreshGraph(bool recalcDataBounds)
        {
            RefreshGraph(true, false);
        }
        public void RefreshGraph(bool recalcDataBounds, bool fitBoundsToData)
        {
            //update bounds
            if (recalcDataBounds)
            {
                RefreshDataBounds();

                if (fitBoundsToData)
                {
                    FitBoundsToData(true, true);
                }

                if (ViewChangedEvent!=null) ViewChangedEvent();
            }

            //do redraw
            DrawGraphData();

            if (bgfx!=null)
            {
                Refresh();
            }
        }

        //converts a data point into (control-relative) screen space
        public DataPoint TransformPoint(DataPoint p)
        {
            return new DataPoint(ReservedXSpace+(GraphDataWidth-1)*(p.X-XOffset)/XRange,
                                 -ReservedYSpace+Height-(GraphDataHeight-1)*(p.Y-YOffset)/YRange);
        }

        //converts from a screen point to a data point
        public DataPoint InverseTransformPoint(DataPoint p)
        {
            return new DataPoint(XOffset + (p.X*XRange-XRange*ReservedXSpace)/(GraphDataWidth-1),
                                 (-ReservedYSpace*YRange + YRange*Height - p.Y*YRange)/(GraphDataHeight-1) + YOffset);
        }

        //size of the data area of the graph (screen space)
        public float GraphDataWidth
        {
            get {return Width-ReservedXSpace;}
        }
        public float GraphDataHeight
        {
            get {return Height-ReservedYSpace;}
        }

        //the bounds for the current data sets (as calculated on the last refresh)
        public float DataMinX { get{return dataXMin;}}
        public float DataMaxX { get{return dataXMax;}}
        public float DataMinY { get{return dataYMin;}}
        public float DataMaxY { get{return dataYMax;}}

        //event for after a graph has been drawn, so that extra stuff may be added to it
        public event GraphDrawnDelegate GraphDrawnEvent;
        public delegate void GraphDrawnDelegate(Graphics g);

        //drawing options
        public bool UseAntialiasing=true;
        public bool UseThickLines=false;

        public DataSet HighlightedDataSet=null;

        //ctor - for use as a control
        public BasicLineGraph()
        {
            //set us up the ... graphics
            SetStyle(ControlStyles.AllPaintingInWmPaint|ControlStyles.UserPaint|ControlStyles.OptimizedDoubleBuffer, true);

            context=BufferedGraphicsManager.Current;
            context.MaximumBuffer=new Size(Width+1, Height+1);
            bgfx=context.Allocate(CreateGraphics(), new Rectangle(0, 0, Width, Height));
            gfx=bgfx.Graphics;

            DrawGraphData();

            //set up events
            Resize+=OnResize;
        }

        //ctor - for use only as a bitmap renderer
        public BasicLineGraph(Bitmap bitmap)
        {
            gfx=Graphics.FromImage(bitmap);
            autoAllocGraphics=false;
            Width=bitmap.Width;
            Height=bitmap.Height;
        }

        // -- internals

        private BufferedGraphicsContext context=null;
        private BufferedGraphics bgfx=null;
        private Graphics gfx=null;
        bool autoAllocGraphics=true;

        protected float ReservedXSpace=0.0f;
        protected float ReservedYSpace=0.0f;

        private float xOffset=0.0f;
        private float xRange=1.0f;
        private float yOffset=0.0f;
        private float yRange=1.0f;

        private float dataXMin=0.0f;
        private float dataXMax=1.0f;
        private float dataYMin=0.0f;
        private float dataYMax=1.0f;

        //just blit the backbuffer
        protected override void OnPaint(PaintEventArgs e)
        {
            if (bgfx!=null)
            {
                bgfx.Render(e.Graphics);
            }
        }

        //need to resize buffers
        private void OnResize(object sender, EventArgs e)
        {
            if (!autoAllocGraphics)
            {
                return;
            }

            //splat the old
            if(bgfx!=null)
            {
                gfx=null;
                bgfx.Dispose();
            }

            //we refuse to get less than 1 pixel big
            if (Width<1) Width=1;
            if (Height<1) Height=1;

            //remake the new
            context.MaximumBuffer=new Size(Width+1, Height+1);
            bgfx=context.Allocate(CreateGraphics(), new Rectangle(0, 0, Width, Height));
            gfx=bgfx.Graphics;

            RefreshGraph();
        }

        //redraws the graph to the backbuffer
        private void DrawGraphData()
        {
            if(gfx==null)
            {
                return;
            }

            //divide the hsv space up, giving hue a head start
            int totalBuckets=DataSets.Count;
            int hueBuckets=6, valueBuckets=1, satBuckets=1;
            while (hueBuckets*valueBuckets*satBuckets<=totalBuckets)
            {
                if (hueBuckets*valueBuckets*satBuckets<=totalBuckets) ++hueBuckets;
                if (hueBuckets*valueBuckets*satBuckets<=totalBuckets) ++valueBuckets;
                if (hueBuckets*valueBuckets*satBuckets<=totalBuckets) ++satBuckets;
            }

            int num=0;
            foreach (DataSet ds in DataSets)
            {
                int hnum=num%hueBuckets;
                int vnum=(num/hueBuckets)%valueBuckets;
                int snum=(num/(hueBuckets*valueBuckets))%satBuckets;

                ColorConverter.HSV hsv=new ColorConverter.HSV();
                hsv.H=(float)hnum/(hueBuckets-0.5f);
                hsv.V=1-(float)vnum/valueBuckets;
                hsv.S=1-(float)snum/satBuckets;

                ColorConverter.RGB rgb=ColorConverter.HSVToRGB(hsv);
                int ramt=(int)(rgb.R*255);
                int gamt=(int)(rgb.G*255);
                int bamt=(int)(rgb.B*255);

                ds.Color=Color.FromArgb(ramt, gamt, bamt);
                ++num;
            }

            //clear the area
            gfx.FillRectangle(Brushes.Black, 0, 0, Width, Height);

            //draw all the data sets
            if (UseAntialiasing)
                gfx.SmoothingMode=SmoothingMode.AntiAlias;
            else
                gfx.SmoothingMode=SmoothingMode.None;

            for (int dsi=0; dsi<DataSets.Count+1; ++dsi)
            {
                DataSet ds;
                if (DataSets.Count==dsi)
                    ds=HighlightedDataSet;
                else
                    ds=DataSets[dsi];

                if (ds==null || ds.Data.Count==0) continue;

                Pen pen=new Pen(ds.Color);
                if (ds==HighlightedDataSet) pen=new Pen(Color.White);
                if (UseThickLines) pen.Width=3;
                if (ds==HighlightedDataSet) ++pen.Width;

                DataPoint lastPoint=TransformPoint(ds.Data[0]);
                for (int i=0; i<ds.Data.Count; ++i) //start at 0 so if the only data is 1 point we still draw 1 pixel
                {
                    DataPoint curPoint=TransformPoint(ds.Data[i]);

                    if ((curPoint.X>=ReservedXSpace-1 || lastPoint.X>=ReservedXSpace-1) && (curPoint.X<=Width+1 || lastPoint.X<=Width+1))
                    {
                        float yNudge=0; //so single points always show up
                        if (Math.Abs(curPoint.X-lastPoint.X)<1 && Math.Abs(curPoint.Y-lastPoint.Y)<1) yNudge=-1.0f;

                        //Large numbers kill .NET for some reason.. so lets cap them to something sane.. grr
                        float drawY1=lastPoint.Y;
                        if (drawY1<-100000) drawY1=-100000;
                        if (drawY1>100000) drawY1=100000;
                        float drawY2=curPoint.Y+yNudge;
                        if (drawY2<-100000) drawY2=-100000;
                        if (drawY2>100000) drawY2=100000;

                        //draw the line
                        gfx.DrawLine(pen, lastPoint.X, drawY1, curPoint.X, drawY2);
                    }

                    lastPoint=curPoint;
                }
            }

            //clear reserved area
            gfx.SmoothingMode=SmoothingMode.None;

            gfx.FillRectangle(Brushes.Black, 0, 0, ReservedXSpace, Height);
            gfx.FillRectangle(Brushes.Black, ReservedXSpace, Height-ReservedYSpace+1, Width, Height);

            //draw extras
            if (GraphDrawnEvent!=null) GraphDrawnEvent(gfx);
        }
    }

    //provides a container for a graph, with user controls to scroll and zoom
    public class GraphScroller: Panel
    {
        //ctor
        public GraphScroller(BasicLineGraph containedGraph)
        {
            graph=containedGraph;
            graph.Location=new System.Drawing.Point(40, 0);
            Controls.Add(graph);
            graph.ViewChangedEvent+=SyncScrollersToGraph;
            graph.Cursor=Cursors.SizeAll;

            //horizontal graph sliders
            gsxOffset=new TrackBar();
            gsxOffset.AutoSize=false;
            gsxOffset.Location=new System.Drawing.Point(40, Height-40+2);
            gsxOffset.Size=new System.Drawing.Size(Width-40, 19);
            gsxOffset.Anchor=AnchorStyles.Left|AnchorStyles.Right|AnchorStyles.Bottom;
            gsxOffset.TickStyle=TickStyle.None;
            gsxOffset.Minimum=0;
            gsxOffset.Maximum=10000;
            gsxOffset.SmallChange=1;
            gsxOffset.LargeChange=500;
            Controls.Add(gsxOffset);
            new ToolTip().SetToolTip(gsxOffset, "Translate X");
            gsxOffset.Scroll+=ScrollXOffset;

            gsxScale=new TrackBar();
            gsxScale.AutoSize=false;
            gsxScale.Location=new System.Drawing.Point(40, Height-40+2+20);
            gsxScale.Size=new System.Drawing.Size(Width-40, 19);
            gsxScale.Anchor=AnchorStyles.Left|AnchorStyles.Right|AnchorStyles.Bottom;
            gsxScale.TickStyle=TickStyle.None;
            gsxScale.Minimum=1;
            gsxScale.Maximum=10000;
            gsxScale.SmallChange=1;
            gsxScale.LargeChange=500;
            Controls.Add(gsxScale);
            new ToolTip().SetToolTip(gsxScale, "Scale X");
            gsxScale.Scroll+=ScrollXZoom;

            //vertical graph sliders
            gsyOffset=new TrackBar();
            gsyOffset.Orientation=Orientation.Vertical;
            gsyOffset.AutoSize=false;
            gsyOffset.Location=new System.Drawing.Point(1+20, 0);
            gsyOffset.Size=new System.Drawing.Size(19, Height-40);
            gsyOffset.Anchor=AnchorStyles.Left|AnchorStyles.Bottom|AnchorStyles.Top;
            gsyOffset.TickStyle=TickStyle.None;
            gsyOffset.Minimum=0;
            gsyOffset.Maximum=10000;
            gsyOffset.SmallChange=1;
            gsyOffset.LargeChange=500;
            Controls.Add(gsyOffset);
            new ToolTip().SetToolTip(gsyOffset, "Translate Y");
            gsyOffset.Scroll+=ScrollYOffset;

            gsyScale=new TrackBar();
            gsyScale.Orientation=Orientation.Vertical;
            gsyScale.AutoSize=false;
            gsyScale.Location=new System.Drawing.Point(1, 0);
            gsyScale.Size=new System.Drawing.Size(19, Height-40);
            gsyScale.Anchor=AnchorStyles.Left|AnchorStyles.Bottom|AnchorStyles.Top;
            gsyScale.TickStyle=TickStyle.None;
            gsyScale.Minimum=1;
            gsyScale.Maximum=10000;
            gsyScale.SmallChange=1;
            gsyScale.LargeChange=500;
            Controls.Add(gsyScale);
            new ToolTip().SetToolTip(gsyScale, "Scale Y");
            gsyScale.Scroll+=ScrollYZoom;

            //autofit buttons
            Button butFitX=new Button();
            butFitX.Location=new System.Drawing.Point(2, Height-40+1);
            butFitX.Size=new System.Drawing.Size(36, 19);
            butFitX.Text="Fit X";
            butFitX.Anchor=AnchorStyles.Left|AnchorStyles.Bottom;
            butFitX.Click+=ButClickFitX;
            Controls.Add(butFitX);

            Button butFitY=new Button();
            butFitY.Location=new System.Drawing.Point(2, Height-40+1+20);
            butFitY.Size=new System.Drawing.Size(36, 19);
            butFitY.Text="Fit Y";
            butFitY.Anchor=AnchorStyles.Left|AnchorStyles.Bottom;
            butFitY.Click+=ButClickFitY;
            Controls.Add(butFitY);

            //set up events
            Resize+=OnResize;
            graph.MouseMove+=Graph_MouseMove;
            graph.MouseWheel+=Graph_MouseWheel;

            //setup timers
            zoomTimer.Interval=40; //25FPS ideal
            zoomTimer.Elapsed+=ZoomTick;
            zoomTimer.SynchronizingObject=graph;

            //
            OnResize(null, null);
        }

        //whether to zoom towards the center rather than the bottom of the graph
        public bool YZoomCenter=true;
        public bool XZoomCenter=true;

        // -- internals
        BasicLineGraph graph;

        TrackBar gsxOffset;
        TrackBar gsxScale;
        TrackBar gsyOffset;
        TrackBar gsyScale;

        bool allowScollerSyncXOffset=true;
        bool allowScollerSyncYOffset=true;
        bool allowScollerSyncXZoom=true;
        bool allowScollerSyncYZoom=true;

        System.Timers.Timer zoomTimer=new System.Timers.Timer();
        DateTime zoomAniLastUpdate;
        float zoomAniProgress=0.0f; //0-1
        float zoomAniMagnitude=0.0f;

        //panel resize
        private void OnResize(object sender, EventArgs e)
        {
            //adjust graph size
            if (Width>40)
            {
                graph.Width=Width-40;
            }
            if (Height>40)
            {
                graph.Height=Height-40;
            }
        }

        //fit clickers
        private void ButClickFitX(object sender, EventArgs e)
        {
            graph.FitBoundsToData(true, false);
            graph.RefreshGraph(false);
        }
        private void ButClickFitY(object sender, EventArgs e)
        {
            graph.FitYBoundToXRange(true, true);
            graph.RefreshGraph(false);
        }

        //scrollyness
        private void ScrollXOffset(object sender, EventArgs e)
        {
            allowScollerSyncXOffset=false;
            graph.XOffset=graph.DataMinX + (gsxOffset.Value/10000.0f)*(graph.DataMaxX-graph.DataMinX-graph.XRange);
            graph.RefreshGraph(false);
            allowScollerSyncXOffset=true;
        }
        private void ScrollYOffset(object sender, EventArgs e)
        {
            allowScollerSyncYOffset=false;
            graph.YOffset=graph.DataMinY + (gsyOffset.Value/10000.0f)*(graph.DataMaxY-graph.DataMinY-graph.YRange);
            graph.RefreshGraph(false);
            allowScollerSyncYOffset=true;
        }
        private void ScrollXZoom(object sender, EventArgs e)
        {
            allowScollerSyncXZoom=false;
            float oldXRange=graph.XRange;
            graph.XRange=(gsxScale.Value/10000.0f)*(graph.DataMaxX-graph.DataMinX);
            if (XZoomCenter) graph.XOffset+=(oldXRange-graph.XRange)/2;
            graph.RefreshGraph(false);
            allowScollerSyncXZoom=true;
        }
        private void ScrollYZoom(object sender, EventArgs e)
        {
            allowScollerSyncYZoom=false;
            float oldYRange=graph.YRange;
            graph.YRange=(gsyScale.Value/10000.0f)*(graph.DataMaxY-graph.DataMinY);
            if (YZoomCenter) graph.YOffset+=(oldYRange-graph.YRange)/2;
            graph.RefreshGraph(false);
            allowScollerSyncYZoom=true;
        }

        //sets the scrollers to match the graph's current location and range
        private void SyncScrollersToGraph()
        {
            if (allowScollerSyncXOffset)
            {
                float xLoc=(graph.XOffset-graph.DataMinX)/((graph.DataMaxX-graph.DataMinX)-graph.XRange*0.9999f);
                int xLocVal=(int)(xLoc*10000);
                if (xLocVal<0) xLocVal=0;
                if (xLocVal>10000) xLocVal=10000;
                gsxOffset.Value=xLocVal;
            }

            if (allowScollerSyncYOffset)
            {
                float yLoc=(graph.YOffset-graph.DataMinY)/((graph.DataMaxY-graph.DataMinY)-graph.YRange*0.9999f);
                int yLocVal=(int)(yLoc*10000);
                if (yLocVal<0) yLocVal=0;
                if (yLocVal>10000) yLocVal=10000;
                gsyOffset.Value=yLocVal;
            }

            if (allowScollerSyncXZoom)
            {
                float xZoom=graph.XRange/(graph.DataMaxX-graph.DataMinX);
                int xZoomVal=(int)(xZoom*10000);
                if (xZoomVal<1) xZoomVal=1;
                if (xZoomVal>10000) xZoomVal=10000;
                gsxScale.Value=xZoomVal;
            }

            if (allowScollerSyncYZoom)
            {
                float yZoom=graph.YRange/(graph.DataMaxY-graph.DataMinY);
                int yZoomVal=(int)(yZoom*10000);
                if (yZoomVal<1) yZoomVal=1;
                if (yZoomVal>10000) yZoomVal=10000;
                gsyScale.Value=yZoomVal;
            }
        }

        //graph dragging
        bool isDraggingMove=false, isDraggingZoom=false;
        Point dragLastPos;

        private void Graph_MouseMove(object sender, MouseEventArgs ea)
        {
            Point curDragPos=new Point(ea.X, ea.Y);

            graph.Focus(); //so we can capture wheel events

            if (ea.Button==MouseButtons.None) //end move
            {
                isDraggingMove=false;
                isDraggingZoom=false;
            }

            if (isDraggingMove) //moving
            {
                float xPixels=dragLastPos.X-curDragPos.X;
                float yPixels=-(dragLastPos.Y-curDragPos.Y);

                graph.XOffset+=(xPixels/graph.GraphDataWidth)*graph.XRange;
                graph.YOffset+=(yPixels/graph.GraphDataHeight)*graph.YRange;

                graph.RefreshGraph(false);
            }
            else if (isDraggingZoom) //zooming
            {
                float xPixels=dragLastPos.X-curDragPos.X;
                float yPixels=-(dragLastPos.Y-curDragPos.Y);

                float oldXRange=graph.XRange;
                float oldYRange=graph.YRange;

                graph.XRange+=0.5f*(xPixels/graph.GraphDataWidth)*(graph.DataMaxX-graph.DataMinX);
                graph.YRange+=0.5f*(yPixels/graph.GraphDataHeight)*(graph.DataMaxY-graph.DataMinY);

                if (XZoomCenter) graph.XOffset+=(oldXRange-graph.XRange)/2;
                if (YZoomCenter) graph.YOffset+=(oldYRange-graph.YRange)/2;

                graph.RefreshGraph(false);
            }
            else
            {
                if (ea.Button==MouseButtons.Left) //start move
                {
                    isDraggingMove=true;
                }
                if (ea.Button==MouseButtons.Right) //start zoom
                {
                    isDraggingZoom=true;
                }
            }

            dragLastPos=curDragPos;
        }

        private void Graph_MouseWheel(object sender, MouseEventArgs ea)
        {
            zoomTimer.Stop();
            zoomAniLastUpdate=System.DateTime.Now;

            zoomAniMagnitude+=-0.002f*ea.Delta;

            zoomAniProgress=0.0f;
            zoomTimer.Start();
        }

        //ticks used when animating mousewheel zoom
        private void ZoomTick(object sender, System.Timers.ElapsedEventArgs eea)
        {
            const float ZOOM_TIME=0.25f;

            //get the actual time passed and update progress
            System.DateTime now=System.DateTime.Now;
            float seconds=(float)(now-zoomAniLastUpdate).TotalSeconds;
            zoomAniLastUpdate=now;

            if (seconds>(1-zoomAniProgress)/(1/ZOOM_TIME)) seconds=(1-zoomAniProgress)/(1/ZOOM_TIME);
            zoomAniProgress+=seconds*(1/ZOOM_TIME);

            if (zoomAniProgress>=1.0f)
            {
                zoomAniProgress=1.0f;
                zoomAniMagnitude=0;
                zoomTimer.Stop();
            }

            //update zoom
            float oldXRange=graph.XRange;
            float oldYRange=graph.YRange;

            graph.XRange+=zoomAniMagnitude*seconds*(graph.DataMaxX-graph.DataMinX);
            graph.YRange+=zoomAniMagnitude*seconds*(graph.DataMaxY-graph.DataMinY);

            if (XZoomCenter) graph.XOffset+=(oldXRange-graph.XRange)/2;
            if (YZoomCenter) graph.YOffset+=(oldYRange-graph.YRange)/2;

            graph.RefreshGraph(false);
        }
    }

    //converts colors
    public class ColorConverter
    {
        //color types
        public struct HSV
        {
            public float H, S, V;
        }
        public struct RGB
        {
            public float R, G, B;
        }

        //converters
        public static RGB HSVToRGB(HSV hsv)
        {
            RGB rgb=new RGB();

            int hueChunk=(int)(5.99999f*hsv.H);
            float huePart=6*hsv.H-hueChunk;
            float p=1-hsv.S;
            float q=1-huePart*hsv.S;
            float t=1-(1-huePart)*hsv.S;

            float []arr={1,q,p,p,t,1};
            float r=arr[hueChunk];
            float g=arr[(hueChunk+2)%6];
            float b=arr[(hueChunk+4)%6];

            float max=r;
            if (g>max) max=g;
            if (b>max) max=b;

            float mag=hsv.V/max;

            rgb.R=mag*r;
            rgb.G=mag*g;
            rgb.B=mag*b;
            return rgb;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GraphicsCommon\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GraphicsCommon\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_testgraphicscommon_none_12.4.56.0_none_248cf796767614bb
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=testgraphicscommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.manifest
XP_MANIFEST_PATH=manifests\msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.cat
XP_CATALOG_PATH=manifests\msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.cat
XP_PAYLOAD_PATH=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=testgraphicscommon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\GraphicsCommon\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_testgraphicscommon_none_12.4.56.0_none_248cf796767614bb
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=testgraphicscommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.manifest
XP_MANIFEST_PATH=manifests\msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.cat
XP_CATALOG_PATH=manifests\msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab.cat
XP_PAYLOAD_PATH=msil_testgraphicscommon_no-public-key_12.4.56.0_x-ww_d47a74ab
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=testgraphicscommon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\HealthWebPage\WebForm2.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Health
{
	/// <summary>
	/// Summary description for WebForm2.
	/// </summary>
	public class WebForm2 : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Calendar Calendar1;
		protected System.Web.UI.WebControls.ListBox ListBox1;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\HealthWebPage\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace Health 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\IFNC\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\HealthWebPage\Menu.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Health
{
	/// <summary>
	/// Summary description for Menu.
	/// </summary>
	public class Menu : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.ImageButton ImageButton1;
		protected System.Web.UI.WebControls.ImageButton ImageButton2;
		protected System.Web.UI.WebControls.Panel Panel1;
		protected System.Web.UI.WebControls.Label Label1;
		public Control c1;
		protected System.Web.UI.WebControls.Panel Panel2;
		protected System.Web.UI.WebControls.Label TestGuid;
		protected System.Web.UI.WebControls.Label Date;
		protected System.Web.UI.WebControls.Image Image1;
		protected System.Web.UI.WebControls.Panel Panel3;
		protected System.Web.UI.WebControls.Label Label2;
		public Control c2;

	
		private void Page_Load(object sender, System.EventArgs e)
		{
			c1 = LoadControl("ServerStateCtrl.ascx");
			c2 = LoadControl("HistoryCtrl.ascx");
			((Health.HistoryCtrl)c2).SetServerCtrl(this);
			((Health.ServerStateCtrl)c1).SetServerCtrl(this);
			//((Health.ServerStateCtrl)c1).SetServerCtrl(this);
			Panel1.Controls.Add(c1);
			Panel2.Controls.Add(c2);

			if( this.IsPostBack ==true)
			{
				
				if (Label1.Text == "ServerStateCtrl1")
				{
					Panel1.Visible = true;
					Panel2.Visible = false;
				}
				else
				{
					Panel1.Visible = false;
					Panel2.Visible = true;
				}
			}
			else
			{
				//TestGuid.Text = ((ServerStateCtrl)c1).getlastRuntime();
				Panel1.Visible = true;
				Panel2.Visible = false;
			}
	
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.ImageButton2.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton2_Click);
			this.ImageButton1.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton1_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void ImageButton2_Click(object sender, System.Web.UI.ImageClickEventArgs e)
		{
			ImageButton2.ImageUrl = "home2.jpg";
			ImageButton1.ImageUrl = "history1.jpg";
			Label1.Text = "ServerStateCtrl1";
		//	Panel1.Controls.Clear();
		//	Panel1.Controls.Add(c1);
			Panel1.Visible = true;
			Panel2.Visible = false;
			//TestGuid.Text  = "" ;//((Health.ServerStateCtrl )c1).getlastRuntime();
			

						

		}

		private void ImageButton1_Click(object sender, System.Web.UI.ImageClickEventArgs e)
		{
			ImageButton2.ImageUrl = "home1.jpg";
			ImageButton1.ImageUrl = "history2.jpg";
			Label1.Text = "HistoryCtrl1";
			//Panel1.Controls.Clear();
			//Panel1.Controls.Add(c2);
			Panel1.Visible = false;
			Panel2.Visible = true;
			

		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\HealthWebPage\ServerStateCtrl.ascx.cs ===
namespace Health
{
	using System;
	using System.Data;
	using System.Drawing;
	using System.Web;
	using System.Web.UI.WebControls;
	using System.Web.UI.HtmlControls;
	using System.Data.SqlClient;
	using System.Collections;
	using System.ComponentModel;
	


	class MapTestToName
	{
		class iteam 
		{
			public string m_testname;
			public string m_displayname;
			
			public iteam(string testname , string displayname)
			{
				m_testname =testname;
				m_displayname =displayname;
			}
		};

		ArrayList  internallist;


		public MapTestToName()
		{
			internallist =new ArrayList();
		}

		public void Add(string testname , string displayname)
		{
			internallist.Add(new iteam(testname,displayname));
		}

		public string GetDisplayName(string Testname)
		{
			IEnumerator Enumerator = internallist.GetEnumerator();

			while(Enumerator.MoveNext())
			{
				if(((iteam)Enumerator.Current).m_testname == Testname.Trim())
				{
					return ((iteam)Enumerator.Current).m_displayname;
				}
			}
			return null;
		}

	}
	class Statsrecord
	{
		public string	Testid;
		public DateTime   runtime;
		
		public Statsrecord()
		{
		}

	};


	class HealthDB
	{
		private MapTestToName map;


		public HealthDB()
		{
		}
		public void InitMap()
		{
			map = new MapTestToName();
			// feedback server
			map.Add("VALID_NEG_NICKNAME","Feedback for Bad NickName");
			map.Add("VALID_NEG_GAMEPLAY","Feedback for Bad Game Play");
			map.Add("VALID_NEG_SCREAMING","Feedback for Screaming");
			map.Add("VALID_NEG_HARASSMENT","Feedback for Harassment");
			map.Add("VALID_NEG_LEWDNESS","Feedback for Lewdness");
			map.Add("VALID_POS_ATTITUDE","Feedback for Positive Attitude");
			map.Add("VALID_POS_SESSION","Feedback for Positive Session");
			// message server
			map.Add("VALID_REQUEST_SINGLE_EXISTING","Title ID Lookup");
			map.Add("VALID_SYSTEMMSG_SINGLE_USER","System Message");
			map.Add("VALID_TitleMSG_Mult_USER","Title Message");
			map.Add("VALID_UserMSG_SINGLE_USER","User Message");

			//Stats
			map.Add("FDSetGetAttribute","Set / Get User Stats");
			map.Add("FDEnumByUser","Enum Leader Board");

			//matchmaking
			map.Add("Basic session creation","Create session");
			map.Add("Delete a valid session","Delete session");
			map.Add("Search such that 0 results are returned","Search a session to join");

			//Xkdc /xmac
			map.Add("Test_Xmacs_Devkit","Machine Account creation");
			map.Add("Test_Xmacs_Genealogy","Genealogy");
			map.Add("Test_Xkdc_Logon_Machine","Machine Logon");

			//presence
			map.Add("AcceptMsg","Accept Msg");
			map.Add("AddMsg","Add Msg ");
			map.Add("DeleteMsg","Delete Msg");
			map.Add("NicknameMsg","Nickname Msg");
			map.Add("RejectMsg","Reject Msg");
			map.Add("StateMsg","State Msg");

			//XBos
			map.Add("PANKAJ_AUTOUPDATE_15_XRLS_ALL_RETURNED_AS_UNDER_MAX_16","Auto Update");
			map.Add("PANKAJ_DETAILS_US_FREE_CONTENT_DETAILS_64K_SIZED_BLOB","Details");
			map.Add("PANKAJ_REFERRAL_JP_FEE_ONE_SZXRL_RETURNED","Referral");
			map.Add("PANKAJ_PURCHASE_US_PREMIUM_SUBSCRIPTION","Purchase Premiun Subscription");
			map.Add("PANKAJ_PURCHASE_US_FEE_PREMIUM_OFFER_SMALL","Purchase Premiun Offer");
			map.Add("PANKAJ_ENUMERATE_US_FREE_8K_MAX_ENUM_BLOB","Enumerate");

			//NOTIINH
			map.Add("DeadSGMsg","DeadSG Msg");
			map.Add("DeadXboxMsg","DeadXbox Msg ");
			map.Add("DeleteMatchesMsg","DeleteMatches Msg");
			map.Add("DequeueMsg","Dequeue Msg");
			map.Add("GeneralMsg","General Msg");
			map.Add("HelloMsg","Hello Msg");
			map.Add("ListMsg","List Msg");
			map.Add("UserInfo","User Msg");

			//XUAC
			map.Add("BVTTests.P.Mainline","User creation");
			map.Add("BVTTests.P.SPI","SetPaymentInfo");

			//SG
			map.Add("SG Quick Test","Key Exchange");
			


			
		}


		/*public bool StatusBydate(DateTime SelectedDate)
		{
			bool retval= false;
			DateTime prevday = SelectedDate.AddDays(-1);
			string strprevday = prevday.Year.ToString()+"-"+prevday.Month.ToString()+"-"+prevday.Day.ToString();
			DateTime nextday = SelectedDate.AddDays(1);
			string strnextday = nextday.Year.ToString()+"-"+nextday.Month.ToString()+"-"+nextday.Day.ToString();

			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string mySelectQuery = "SELECT * FROM Stats where TimeStamp > '"+strprevday+" 23:59' and TimeStamp <'"+strnextday+" 0:0' order by TimeStamp desc" ;
			//string mySelectQuery = "SELECT Count(*),SubComponent FROM TestRuns where id='"+latestrunid+"' and Status!=128 group by SubComponent" ;
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommand = new SqlCommand(mySelectQuery,myConnection);
						
			try
			{
				myConnection.Open();
				
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;
				return false;

			}
					
			
			try
			{
				SqlDataReader myReader = myCommand.ExecuteReader();
				//ListBox2.
				
				
				while (myReader.Read())
				{
					retval= true;
					

				}
				

				myReader.Close();
				
				
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				myConnection.Close();
			}

			return retval;

		}
		*/

		public bool StatusBydate(DateTime SelectedDate)
		{
			bool retval= false;
			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string mySelectQuery = "SELECT * FROM TodaysStatus" ;
			//string mySelectQuery = "SELECT Count(*),SubComponent FROM TestRuns where id='"+latestrunid+"' and Status!=128 group by SubComponent" ;
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommand = new SqlCommand(mySelectQuery,myConnection);
						
			try
			{
				myConnection.Open();
				
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;
				return false;

			}
					
			
			try
			{
				SqlDataReader myReader = myCommand.ExecuteReader();
				//ListBox2.
				
				
				while (myReader.Read())
				{
					retval= true;
					

				}
				

				myReader.Close();
				
				
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				myConnection.Close();
			}

			return retval;


		}


		public void updatePassFail(string Testid,Label downservers,Label upserver,Label Unknownsrv)
		{
			//string retval="ERROR" ;
			downservers.Text ="";
			upserver.Text="";

			string[] servers = {"FBCKIIS","MESSIIS","STATIIS","MTCHIIS","XKDCINH","XMACINH","XPNFIIS","XBOS","NOTIINH","XUACSV2","SECUINH"};
			string[] Fail = new String[12];
			string[] Pass = new String[12];
			string[] Unknown = new String[12];
			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string FailSelectQuery = "SELECT Count(*),SubComponent FROM TestRuns where id='"+Testid+"' and SubComponent != 'PRESINH' and Status=4 group by SubComponent" ;
			string PassSelectQuery = "SELECT Count(*),SubComponent FROM TestRuns where id='"+Testid+"' and SubComponent != 'PRESINH' and Status=128 group by SubComponent" ;
			//string mySelectQuery = "SELECT Count(*),SubComponent FROM TestRuns where id='"+latestrunid+"' and Status!=128 group by SubComponent" ;
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommandFail = new SqlCommand(FailSelectQuery,myConnection);
			SqlCommand myCommandPass = new SqlCommand(PassSelectQuery,myConnection);
			//int PassCount=0;
			//int FailCount=0;
			
			try
			{
				myConnection.Open();
				
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;
				return ;

			}
					
			
			try
			{
				SqlDataReader FailReader = myCommandFail.ExecuteReader();
				
				//ListBox2.
				int index=0;
				while (FailReader.Read())
				{
					Fail[index]= FailReader.GetString(1).Trim();
					index++;
					downservers.Text += FailReader.GetString(1).Trim() + " ; ";
					
				}
				FailReader.Close();

				// pass
				SqlDataReader PassReader = myCommandPass.ExecuteReader();
				int indexpas=0;
				while (PassReader.Read())
				{
					int flag =0;

					for(int i=0 ; i< Fail.Length;i++)
					{
						if (Fail[i]==PassReader.GetString(1).Trim())
						{
							flag=1;
							break;
							/*string blank="";
							servers.SetValue((object)blank,i);
							NotFail[index]= PassReader.GetString(1).Trim();
							index++;
							*/
						}
					}
					if(flag==0)
					{
						Pass[indexpas]=PassReader.GetString(1).Trim();
						indexpas++;
						upserver.Text += PassReader.GetString(1).Trim() + " ; ";
					}
					
				}
				PassReader.Close();


						
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				myConnection.Close();
			}

			Unknownsrv.Text ="";
			for(int i=0 ; i< servers.Length;i++)
			{
				/*if (((string)servers.GetValue(i)).Length >1)
				{
					upserver.Text  += (string)servers.GetValue(i)+" ; ";
				}*/
				// check if server passed;
				bool found = false;
				for(int p=0; p < Fail.Length ;p++)
				{
					if(Fail[p]==servers[i])
						found= true;

				}
				for(int f=0; f < Pass.Length ;f++)
				{
					if(Pass[f]==servers[i])
						found= true;
				}

				if(found==false)
				{
					Unknownsrv.Text += (string) servers[i]+" ; ";
				}


				// check if server failed;

			}
			

		}

		public void updatestatus(string servertype,string Testid,ListBox WorkingListBox,ListBox NotWorkingListBox)
		{
			//string retval="ERROR" ;
			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string mySelectQuery = "SELECT DISTINCT * FROM TestRuns where id='"+Testid+"' and SubComponent ='"+servertype+"' " ;
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommand = new SqlCommand(mySelectQuery,myConnection);
			int PassCount=0;
			int FailCount=0;
			
			try
			{
				myConnection.Open();
				
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;
				return ;

			}
					
			
			try
			{
				SqlDataReader myReader = myCommand.ExecuteReader();
				//ListBox2.
				while (myReader.Read())
				{
					int status =myReader.GetInt32(0);
					if(status == 128)
					{
						//String temp = " \n"+myReader.GetString(1)+"\t\tPASSED";
						String temp = map.GetDisplayName(myReader.GetString(1));
						if(temp!=null)
							WorkingListBox.Items.Add(new ListItem(temp));
						//else
						//	ListBox2.Items.Add(new ListItem(myReader.GetString(1)));
						PassCount++;
					}
					else if(status == 4)
					{
						String temp = map.GetDisplayName(myReader.GetString(1));
						if(temp!=null)
							NotWorkingListBox.Items.Add(new ListItem(temp));
						FailCount++;

					}

				}
				

				myReader.Close();
				// 
				
				if(FailCount>0)
				{
					//Serverstatus.Text ="Status: Down";
				}
				else
				{
					//Serverstatus.Text ="Status: Running";
				}
				//passfail.Text = "Test Passed:" + PassCount.ToString();
				//passfail.Text += " Test Failed:" +FailCount.ToString() ;

				
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				
				// always call Close when done reading.
				myConnection.Close();
			}
		}
		public string gettimeofPuid(string puid)
		{
			string retval="ERROR" ;
			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string mySelectQuery = "SELECT * FROM Stats where id= '"+puid+"'";
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommand = new SqlCommand(mySelectQuery,myConnection);
			try
			{
				myConnection.Open();
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;

			}
					
			SqlDataReader myReader = myCommand.ExecuteReader();

			try
			{
				myReader.Read();
				DateTime m_time = myReader.GetDateTime(0);
				retval = m_time.ToString();
				
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				myReader.Close();
				// always call Close when done reading.
				myConnection.Close();
			}
			return retval;
		}

		public Statsrecord getlastRuntime()
		{
			Statsrecord temprec = new Statsrecord();
			
			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string mySelectQuery = "SELECT * FROM Stats ORDER BY [TimeStamp] Desc";
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommand = new SqlCommand(mySelectQuery,myConnection);
			try
			{
				myConnection.Open();
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;

			}
					
			SqlDataReader myReader = myCommand.ExecuteReader();

			try
			{
				myReader.Read();
				Guid temp = myReader.GetGuid(1);
				temprec.Testid  = temp.ToString();
				temprec.runtime  = myReader.GetDateTime(0);
				
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				myReader.Close();
				// always call Close when done reading.
				myConnection.Close();
			}
			return temprec;
		}



	};


	/// <summary>
	///		Summary description for ServerStateCtrl.
	/// </summary>
	public abstract class ServerStateCtrl : System.Web.UI.UserControl
	{
		protected System.Web.UI.WebControls.Label testnet;
		protected System.Web.UI.WebControls.Label Label2;
		protected System.Web.UI.WebControls.Label upserver;
		protected System.Web.UI.WebControls.Label Label3;
		protected System.Web.UI.WebControls.Label downservers;
		protected System.Web.UI.WebControls.Button Button3;
		protected System.Web.UI.WebControls.Label Label4;
		protected System.Web.UI.WebControls.DropDownList DropDownList1;
		protected System.Web.UI.WebControls.Button Button2;
		protected System.Web.UI.WebControls.Label Label5;
		protected System.Web.UI.WebControls.Label Label6;
		protected System.Web.UI.WebControls.ListBox ListBox2;
		protected System.Web.UI.WebControls.ListBox ListBox3;
		protected System.Web.UI.WebControls.Button Button1;
		protected System.Web.UI.WebControls.Button Button4;
		protected System.Web.UI.WebControls.Label Label1;
		Statsrecord m_currentrec;
		HealthDB m_healthdb;
		protected System.Web.UI.WebControls.Label Label7;
		protected System.Web.UI.WebControls.Label Label8;
		protected System.Web.UI.WebControls.Label Label9;
		protected System.Web.UI.WebControls.Label Label10;
		protected System.Web.UI.WebControls.Label unknown;
		protected System.Web.UI.WebControls.Label Unknownsrv;
		
		//public string Selected_date;
		protected Menu m_menu1;

		public void SetServerCtrl(Menu mn)
		{
			m_menu1= mn;
			m_healthdb= new HealthDB();
			
		}
		

		private void Page_Load(object sender, System.EventArgs e)
		{
			DateTime  today = DateTime.Now;
			m_healthdb.InitMap();
			testnet.Text = today.Month.ToString()+" : "+today.Day.ToString()+" : "+today.Year.ToString();
			if(m_healthdb.StatusBydate(today)==true)
			{
				Label10.ForeColor = System.Drawing.Color.Green;
				Label10.Text= "TESTNET is Open For testing";
				m_currentrec = m_healthdb.getlastRuntime();
				Label8.Text = m_currentrec.runtime.Hour.ToString() +" : " +m_currentrec.runtime.Minute.ToString();
				m_healthdb.updatePassFail(m_currentrec.Testid,downservers,upserver,Unknownsrv);
			}
			else
			{
				Label10.ForeColor = System.Drawing.Color.Red;
				Label10.Text= "TESTNET is NOT Open For testing";
				DropDownList1.Enabled = false;
			}
			
		}

	
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		///		Required method for Designer support - do not modify
		///		the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.DropDownList1.SelectedIndexChanged += new System.EventHandler(this.DropDownList1_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		

		private void DropDownList1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			this.Visible = true;
			m_healthdb.updatestatus(DropDownList1.SelectedItem.Value,m_currentrec.Testid,ListBox2,ListBox3);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\IFNC\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_ifnc_none_12.4.56.0_none_b4da5705193711f5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=ifnc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.manifest
XP_MANIFEST_PATH=manifests\msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.cat
XP_CATALOG_PATH=manifests\msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.cat
XP_PAYLOAD_PATH=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=ifnc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\IFNC\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\IFNC\IFNC.cs ===
using System;

namespace IFNC
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			IFNCApp app = new IFNCApp();
			app.Run(args);
			Console.WriteLine("Done.");
		}
	}

	public class IFNCApp
	{
		private const string DEFAULT_CUST_URL = "http://10.20.1.2:13010/xsuppapi/cxsuppapi.asmx";
		private string CustUrl = DEFAULT_CUST_URL;
		CXSuppApi CxCust;
		ulong Puid = 0;

		public void Run(string[] args)
		{
			try
			{
				ProcessArgs(args);
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
				Console.WriteLine("");
				DisplayHelp();
				return;
			}
			CxCust = new CXSuppApi(CustUrl);
			string errorString;
			Console.Write("Calling Cust to force name change... ");
			try
			{
				if (ForcedNameChange(Puid, CxCust, out errorString))
				{
					Console.WriteLine("Succeeded.");
				}
				else
				{
					Console.WriteLine("Failed.");
					Console.WriteLine("");
					Console.WriteLine("Possible error string: " + errorString);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine("Failed.");
				Console.WriteLine("");
				Console.WriteLine(e.ToString());
			}
		}

		public void ProcessArgs(string[] args)
		{
			if (args.Length != 1 && args.Length != 2)
			{
				throw new Exception("Invalid # of parameters used.");
			}

			foreach (string arg in args)
			{
				if (arg.StartsWith("/puid:"))
				{
					Puid = UInt64.Parse(arg.Substring("/puid:".Length));
				}
				else if (arg.StartsWith("/cust:"))
				{
					CustUrl = arg.Substring("/cust:".Length);
				}
				else
				{
					throw new Exception("Invalid argument: " + arg);
				}
			}
		}

		// Borrowed and slightly modified from \private\tools\CommunityMgr\QuickEnforcement\Enforcements.cs
		public bool ForcedNameChange(ulong PUID, CXSuppApi cxcust, out string errorstring)
		{
			//FNC = Enforcement Gamertag complaint 
            
			bool owner, active, lockout, voiceban, nickban, fnc;
			bool result = false;
			errorstring = "";
            
			// check that user still has gamertag, isn't currently marked for FNC 
			cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out errorstring);

			//enforce
			if (!fnc)
			{
				//FNC 'em ..
				fnc = true;
				cxcust.modifyAccount(PUID, lockout, voiceban, nickban, fnc, out errorstring);

				fnc = false;
				//check to confirm user's account is now marked for FNC
				cxcust.getAccount(PUID, out owner, out active, out lockout, out voiceban, out nickban, out fnc, out errorstring);
				if (fnc)
				{
					// then they're in the right state ... ;-)
					result = true;
				}
			} // fnc already?

			return result;

		} // FNC

		public void DisplayHelp()
		{
			Console.WriteLine(@"Immediate Force Name Change

IFNC calls ModifyAccount() on the Cust (XSuppAPI) server.  The result will be to force a name change
on the user's next login; force the user's Forum posts to reflect a new, generated named; and potentially
change the user's gamertag in UODB and possibly leave auth data, depending on account type.

Pamemeters:
/puid:<userPuid>\tRequired: puid to execute IFNC functionality against
/cust:<url>\t\tOptional: url of Cust server.  Defaults to " + DEFAULT_CUST_URL);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\InserPurchases\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\HealthWebPage\HistoryCtrl.ascx.cs ===
namespace Health
{
	using System;
	using System.Data;
	using System.Drawing;
	using System.Web;
	using System.Web.UI.WebControls;
	using System.Web.UI.HtmlControls;
	using System.Data.SqlClient;
	using System.Collections;
	using System.ComponentModel;

	/// <summary>
	///		Summary description for HistoryCtrl.
	/// </summary>
	public abstract class HistoryCtrl : System.Web.UI.UserControl
	{
		protected System.Web.UI.WebControls.Label Label1;
		protected System.Web.UI.WebControls.Calendar Calendar1;
		protected System.Web.UI.WebControls.Label Label3;
		protected System.Web.UI.WebControls.Label Label2;
		protected System.Web.UI.WebControls.Label Label4;
		protected System.Web.UI.WebControls.Label Label5;
		protected System.Web.UI.WebControls.Label Label6;
		protected System.Web.UI.WebControls.Button Button3;
		protected System.Web.UI.WebControls.Label Label7;
		protected System.Web.UI.WebControls.Label upserver;
		protected System.Web.UI.WebControls.Label downservers;
		protected System.Web.UI.WebControls.Button Button1;
		protected System.Web.UI.WebControls.Label Label8;
		protected System.Web.UI.WebControls.Button Button2;
		protected System.Web.UI.WebControls.Label Label9;
		protected System.Web.UI.WebControls.ListBox ListBox2;
		protected System.Web.UI.WebControls.ListBox ListBox3;
		//protected Health.ServerStateCtrl m_ServerCtrl;
		//protected Panel m_p1;
		protected Menu m_menu1;
		HealthDB m_healthdb;
		protected System.Web.UI.WebControls.DropDownList timelist;
		protected System.Web.UI.WebControls.Label latestrunid;
		protected System.Web.UI.WebControls.Label Label10;
		protected System.Web.UI.WebControls.Label Unknown;
		protected System.Web.UI.WebControls.DropDownList ServerList;
		//string latestrunid;

		public void SetServerCtrl(Menu mn)
		{
			m_menu1= mn;
			m_healthdb = new HealthDB();
		}

		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
			if(!IsPostBack)
			{
				Calendar1.SelectedDate = DateTime.Now;
				FillList(Calendar1.SelectedDate);
				m_healthdb.updatePassFail(latestrunid.Text,downservers,upserver,Unknown);
			}
			//Label1 .Text= DateTime.Now.ToString();
			m_healthdb.updatePassFail(latestrunid.Text,downservers,upserver,Unknown);
			m_healthdb.InitMap();
		
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		///		Required method for Designer support - do not modify
		///		the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.timelist.SelectedIndexChanged += new System.EventHandler(this.timelist_SelectedIndexChanged);
			this.ServerList.SelectedIndexChanged += new System.EventHandler(this.ServerList_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		
		protected void FillList(DateTime SelectedDate)
		{
			DateTime prevday = SelectedDate.AddDays(-1);
			string strprevday = prevday.Year.ToString()+"-"+prevday.Month.ToString()+"-"+prevday.Day.ToString();
			DateTime nextday = SelectedDate.AddDays(1);
			string strnextday = nextday.Year.ToString()+"-"+nextday.Month.ToString()+"-"+nextday.Day.ToString();

			string myConnString ="Data Source=pankajndbox;uid=regressionuser;PWD=regressionuser;Initial Catalog=TestNetHealth";
			string mySelectQuery = "SELECT * FROM Stats where TimeStamp > '"+strprevday+" 23:59' and TimeStamp <'"+strnextday+" 0:0' order by TimeStamp desc" ;
			//string mySelectQuery = "SELECT Count(*),SubComponent FROM TestRuns where id='"+latestrunid+"' and Status!=128 group by SubComponent" ;
			SqlConnection myConnection = new SqlConnection(myConnString);
			SqlCommand myCommand = new SqlCommand(mySelectQuery,myConnection);
						
			try
			{
				myConnection.Open();
				
			}
			catch (SqlException exp) 
			{
				SqlErrorCollection myErrors = exp.Errors;
				return ;

			}
					
			
			try
			{
				SqlDataReader myReader = myCommand.ExecuteReader();
				//ListBox2.
				int index=0;
				while (myReader.Read())
				{
                    DateTime runtime = myReader.GetDateTime(0);
					string   stringtime = runtime.Hour.ToString() + ":"+ runtime.Minute.ToString(); 
					string puid = myReader.GetGuid(1).ToString();
					timelist.Items.Add(new ListItem(stringtime,puid));
					if(index==0)
					{
						latestrunid.Text  = puid;
						index++;
					}
					

				}
				

				myReader.Close();
				
				
			} 
			catch (SqlException exp1) 
			{
				SqlErrorCollection myErrors = exp1.Errors;

			}
			finally 
			{
				// always call Close when done reading.
				myConnection.Close();
			}

		}


		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
			
			Label4 .Text = Calendar1.SelectedDate.Month.ToString() +":"+Calendar1.SelectedDate.Day.ToString()+":"+Calendar1.SelectedDate.Year.ToString();
			timelist.Items.Clear();
			FillList(Calendar1.SelectedDate);
			m_healthdb.updatePassFail(latestrunid.Text,downservers,upserver,Unknown);

		}

		private void timelist_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			latestrunid.Text= timelist.SelectedItem.Value;
			m_healthdb.updatePassFail(timelist.SelectedItem.Value,downservers,upserver,Unknown);
		}

		private void ServerList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			m_healthdb.updatePassFail(latestrunid.Text,downservers,upserver,Unknown);
			m_healthdb.updatestatus(ServerList.SelectedItem.Value,latestrunid.Text,ListBox2,ListBox3);
		
		}

				
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\IFNC\CUSTProxyCode.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// Then the constructor was modified by ramhar to tailor it to our environment.
// 

namespace IFNC
{
	using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Net;
    using System.Web;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="CXSuppApiSoap", Namespace="http://xbox.com/xsuppapi/")]
    public class CXSuppApi : System.Web.Services.Protocols.SoapHttpClientProtocol {

        // used to connect to proxies
        // private IWebProxy myProxy;

        /// <remarks/>
        /// 
        public CXSuppApi(string myurl) 
        {
            try
            {
                this.Url = myurl;
            }
            catch (Exception e)
            {
                throw(new Exception("Error in CXSuppAPI Constructor. " + e.Message));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPuidFromXName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 getPuidFromXName(string XName, out System.UInt64 puid, out string errorString) {
            object[] results = this.Invoke("getPuidFromXName", new object[] {
                        XName});
            puid = ((System.UInt64)(results[1]));
            errorString = ((string)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetPuidFromXName(string XName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getPuidFromXName", new object[] {
                        XName}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndgetPuidFromXName(System.IAsyncResult asyncResult, out System.UInt64 puid, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            puid = ((System.UInt64)(results[1]));
            errorString = ((string)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 getAccount(System.UInt64 puid, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out string errorString) {
            object[] results = this.Invoke("getAccount", new object[] {
                        puid});
            isAccountOwner = ((bool)(results[1]));
            isActive = ((bool)(results[2]));
            isLockedOut = ((bool)(results[3]));
            isVoiceBanned = ((bool)(results[4]));
            isNicknameBanned = ((bool)(results[5]));
            mustChangeXName = ((bool)(results[6]));
            errorString = ((string)(results[7]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetAccount(System.UInt64 puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getAccount", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndgetAccount(System.IAsyncResult asyncResult, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            isAccountOwner = ((bool)(results[1]));
            isActive = ((bool)(results[2]));
            isLockedOut = ((bool)(results[3]));
            isVoiceBanned = ((bool)(results[4]));
            isNicknameBanned = ((bool)(results[5]));
            mustChangeXName = ((bool)(results[6]));
            errorString = ((string)(results[7]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/modifyAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 modifyAccount(System.UInt64 puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, out string errorString) {
            object[] results = this.Invoke("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName});
            errorString = ((string)(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginmodifyAccount(System.UInt64 puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("modifyAccount", new object[] {
                        puid,
                        isLockedOut,
                        isVoiceBanned,
                        isNicknameBanned,
                        mustChangeXName}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndmodifyAccount(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/resetPassword", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 resetPassword(System.UInt64 puid, out string errorString) {
            object[] results = this.Invoke("resetPassword", new object[] {
                        puid});
            errorString = ((string)(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginresetPassword(System.UInt64 puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("resetPassword", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndresetPassword(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getRelatedAccounts", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 getRelatedAccounts(System.UInt64 puid, out System.UInt64[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
            object[] results = this.Invoke("getRelatedAccounts", new object[] {
                        puid});
            relatedAccounts = ((System.UInt64[])(results[1]));
            relatedAccountNames = ((string[])(results[2]));
            errorString = ((string)(results[3]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetRelatedAccounts(System.UInt64 puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getRelatedAccounts", new object[] {
                        puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndgetRelatedAccounts(System.IAsyncResult asyncResult, out System.UInt64[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            relatedAccounts = ((System.UInt64[])(results[1]));
            relatedAccountNames = ((string[])(results[2]));
            errorString = ((string)(results[3]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getSubscriptionCodeStatus", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 getSubscriptionCodeStatus(string SubscriptionCode, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out System.UInt64 ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out System.UInt64 ulOfferID, out string szOffer, out string errorString) {
            object[] results = this.Invoke("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode});
            bValidSubscriptionCode = ((bool)(results[1]));
            bUsed = ((bool)(results[2]));
            bUsedMaxTimes = ((bool)(results[3]));
            ulLastUser = ((System.UInt64)(results[4]));
            szLastUser = ((string)(results[5]));
            ftLastUsage = ((System.DateTime)(results[6]));
            ulOfferID = ((System.UInt64)(results[7]));
            szOffer = ((string)(results[8]));
            errorString = ((string)(results[9]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetSubscriptionCodeStatus(string SubscriptionCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getSubscriptionCodeStatus", new object[] {
                        SubscriptionCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndgetSubscriptionCodeStatus(System.IAsyncResult asyncResult, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out System.UInt64 ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out System.UInt64 ulOfferID, out string szOffer, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            bValidSubscriptionCode = ((bool)(results[1]));
            bUsed = ((bool)(results[2]));
            bUsedMaxTimes = ((bool)(results[3]));
            ulLastUser = ((System.UInt64)(results[4]));
            szLastUser = ((string)(results[5]));
            ftLastUsage = ((System.DateTime)(results[6]));
            ulOfferID = ((System.UInt64)(results[7]));
            szOffer = ((string)(results[8]));
            errorString = ((string)(results[9]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getTransactions", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 getTransactions(int maxResults, out System.UInt64[] transactionOwners, out string[] transactionIDs, out System.DateTime[] transactionDates, out int[] transactionTypes, out string errorString) {
            object[] results = this.Invoke("getTransactions", new object[] {
                        maxResults});
            transactionOwners = ((System.UInt64[])(results[1]));
            transactionIDs = ((string[])(results[2]));
            transactionDates = ((System.DateTime[])(results[3]));
            transactionTypes = ((int[])(results[4]));
            errorString = ((string)(results[5]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetTransactions(int maxResults, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getTransactions", new object[] {
                        maxResults}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndgetTransactions(System.IAsyncResult asyncResult, out System.UInt64[] transactionOwners, out string[] transactionIDs, out System.DateTime[] transactionDates, out int[] transactionTypes, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            transactionOwners = ((System.UInt64[])(results[1]));
            transactionIDs = ((string[])(results[2]));
            transactionDates = ((System.DateTime[])(results[3]));
            transactionTypes = ((int[])(results[4]));
            errorString = ((string)(results[5]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/emailsSent", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 emailsSent(System.UInt64[] puid, string[] SubscriptionID, System.DateTime[] ft, int[] phoenixErrors, out string errorString) {
            object[] results = this.Invoke("emailsSent", new object[] {
                        puid,
                        SubscriptionID,
                        ft,
                        phoenixErrors});
            errorString = ((string)(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginemailsSent(System.UInt64[] puid, string[] SubscriptionID, System.DateTime[] ft, int[] phoenixErrors, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("emailsSent", new object[] {
                        puid,
                        SubscriptionID,
                        ft,
                        phoenixErrors}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndemailsSent(System.IAsyncResult asyncResult, out string errorString) {
            object[] results = this.EndInvoke(asyncResult);
            errorString = ((string)(results[1]));
            return ((System.UInt32)(results[0]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\IFNC\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_ifnc_none_12.4.56.0_none_b4da5705193711f5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=ifnc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.manifest
XP_MANIFEST_PATH=manifests\msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.cat
XP_CATALOG_PATH=manifests\msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475.cat
XP_PAYLOAD_PATH=msil_ifnc_no-public-key_12.4.56.0_x-ww_a59f1475
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=ifnc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\integration\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__integration_4_none_12.4.56.0_none_ea2d6f53e2b97790
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_integration_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.manifest
XP_MANIFEST_PATH=manifests\x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.cat
XP_CATALOG_PATH=manifests\x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.cat
XP_PAYLOAD_PATH=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_integration_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\integration\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying scripts...
    -robocopy . $(_NT386TREE)\test\tools\integration *.cmd /XD obj objd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\integration\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__integration_4_none_12.4.56.0_none_ea2d6f53e2b97790
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_integration_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.manifest
XP_MANIFEST_PATH=manifests\x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.cat
XP_CATALOG_PATH=manifests\x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0.cat
XP_PAYLOAD_PATH=x86__integration_4_no-public-key_12.4.56.0_x-ww_5c8c79e0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_integration_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\InserPurchases\main.cs ===
using System;
using System.Xml;
using System.Collections;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using live.common;
      
namespace ImportPurchase
{
    class ImportPurchase
    {
        static string purchaseFilePath = "purchase.txt";
        static string envName = "stressnet";

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] args)
        {
    
            ulong numberOfUsers = 100;
            int totalRowImported = 0;
            ulong basePuid = 0;
            ulong progressinterval = 100;
            ulong curUserCount=0;
            

            string orginalPuid; 
            string machinePuid;
            string offerInstanceId;
            string offerId;
            string  mediaTypeId;
            string dt_purchase;
            string si_hash_bucket;
            string dt_changed_date;
            string storeId;
            bool clean = false;

            DateTime startTime = DateTime.UtcNow;

            purchaseFilePath = Directory.GetCurrentDirectory() + purchaseFilePath;
            string helpMsg = "Usage: importpurchase [-env <environment>] -file <purchase file path> -usercount <number of users> -basepuid <base userpuid> [-clean]";
            if (args[0].Contains("/?") || args[0].Contains("-?"))
            {
                System.Console.WriteLine(helpMsg);
                return -1;
            }
           for(int i = 0; i < args.Length; i++) 
            {              

                if ( (args[i] == "-env") || (args[i] == "/env")) 
                {
                    envName = args[i+1];
                }

                if ((args[i] == "-clean") || (args[i] == "/clean"))
                {
                    clean = true;
                }


                if ( (args[i] == "-usercount") || (args[i] == "/usercount")) 
                {
                    numberOfUsers = ulong.Parse(args[i+1]);
                }

                if ((args[i] == "-basepuid") || (args[i] == "/basepuid"))
                {
                    basePuid = (ulong)SafeConvert.ToUInt64(args[i + 1]);
                }

                if ((args[i] == "-file") || (args[i] == "/file"))
                {
                    purchaseFilePath = args[i + 1];

                    if (!File.Exists(purchaseFilePath))
                    {
                        throw new Exception("This purchase file does not exist: " + purchaseFilePath);
                    }
                }

            }

            
            Console.WriteLine("use " + envName + " as Environment" + " user count " + numberOfUsers + " basePuid: " + basePuid.ToString("X"));
            Console.WriteLine("imported from  " + purchaseFilePath);
            InitializeSTF(envName);

            //read production license data
            StreamReader sr = new StreamReader(purchaseFilePath);

            string insertString = null;
            string prevPuid = null;
            ulong failedInsertCount = 0;
            int userPurchaseCount = 0;
            try
            {
                while (sr.Peek() >= 0)
                {
                    string record = sr.ReadLine();

                    string[] columns = record.Split(new char[] { '\t' });

                    orginalPuid = columns[0];
                    if (!orginalPuid.Equals(prevPuid) && prevPuid != null)
                    {
                        //import previous user
                        Console.WriteLine(string.Format("insert {0} records for user[{1}]: {2}", userPurchaseCount,  curUserCount, basePuid + curUserCount));

                        try
                        {
                            ServerTestFramework.Database.UserCommercedbWS.SimulatePurchaseMultipleOffers(basePuid + curUserCount, insertString, clean);
                            curUserCount++;
                            insertString = null;

                            if (curUserCount >= numberOfUsers) break;

                            if ((curUserCount % progressinterval) == 0)
                            {
                                Console.WriteLine(string.Format("Finish inserting for {0}% users elapsedTime: {1} minutes",
                                    ((float)curUserCount / numberOfUsers) * 100, ((DateTime.UtcNow - startTime)).TotalMinutes));
                            }
                            //curUserCount
                        }
                        catch(Exception e)
                        {
                            Console.WriteLine(e.InnerException.Message);
                            Console.WriteLine(string.Format("Add purchase failed with {0} times, move to next user", failedInsertCount++));                            
                            //discard the insert for that user and move to next
                            insertString = null;
                            prevPuid = null;
                        }
                        userPurchaseCount = 0;
                        //start a new user                        
                    }
                    else
                    {
                        //same user
                        //append ',' to the previous purchase
                        if (insertString != null)
                            insertString += ",";
                    }

                    userPurchaseCount++;
                    machinePuid = columns[1];
                    offerInstanceId = columns[2];
                    offerId = columns[3];
                    mediaTypeId = columns[4];
                    dt_purchase = columns[5].Remove(columns[7].IndexOf('.'));
                    si_hash_bucket = columns[6];
                    dt_changed_date = columns[7].Remove(columns[7].IndexOf('.'));
                    storeId = columns[8];

                    //handle the situation that can not insert more than 1000 values using single insert.
                    if (userPurchaseCount == 999 || userPurchaseCount == 2000 - 2)
                    {                    
                        insertString = insertString.Substring(0, insertString.Length-1) + "\r\n insert into t_user_offer_instance_purchases values ";                                                
                    }

                    insertString += string.Format("({0}, {1}, '{2}', '{3}', {4}, '{5}', {6}, '{7}', {8})",
                                    basePuid + curUserCount, machinePuid, offerInstanceId, offerId, mediaTypeId, dt_purchase, si_hash_bucket, dt_changed_date, storeId);

                    prevPuid = orginalPuid;
                    totalRowImported++;
                }
            }
            finally
            {
                sr.Close();
            }
            //finish last insert
            if(insertString != null)
                ServerTestFramework.Database.UserCommercedbWS.SimulatePurchaseMultipleOffers(basePuid + curUserCount, insertString, clean);       
   
            return 0;
        }


         public static void InitializeSTF(string envName)
        {

            XmlDocument config = new XmlDataDocument();

            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            ServerTestFramework.Global.Initialize(config);

            bool found = false;
            foreach (ServerTestFramework.EnvironmentSetting npdbSetting in ServerTestFramework.Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    ServerTestFramework.Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                throw new Exception("Error - unknown environment '{0}' specified (not in stf.xml?)." + envName);
            }

            ServerTestFramework.Global.ResetEnvironment();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ListUsers\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ListUsers\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ListUsers\Class1.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Threading;
using System.Collections;

namespace ListUsers
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			ArrayList threads=new ArrayList();
			TextReader tr;
			try
			{

				tr=File.OpenText("computerlist.txt");
			}
			catch (FileNotFoundException)
			{
				Console.WriteLine("Can't open computerList.txt - you need to make a file that contains a list of servers to check.");
				Console.WriteLine("a sample computerList.txt has been checked in with the source.");
				return;
			}
			string s;

			DateTime StartTime=DateTime.Now;
			while((s=tr.ReadLine())!=null)
			{
				SearchThread st;
				Thread t;
				st=new SearchThread();
				st.Server=s;
				t=new Thread(new ThreadStart(st.Body));
				t.Start();
				t.Join(250);	// stagger the threads a little
				threads.Add(t);
			}

			tr.Close();

			foreach (Thread t in threads)
				t.Join();
			
			Console.WriteLine(DateTime.Now-StartTime);
		}
	}

	class	SearchThread
	{
		public string	Server;

		public void		Body()
		{
			Process p = new Process();
			p.StartInfo.FileName="query";
			p.StartInfo.Arguments="session /SERVER:"+Server;
			p.StartInfo.RedirectStandardOutput=true;
			p.StartInfo.UseShellExecute=false;
			p.Start();
			p.WaitForExit();

			string output;
			p.StandardOutput.ReadLine();
			while ((output = p.StandardOutput.ReadLine())!=null)
			{
				Console.WriteLine(Server+" | "+output);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ListUsers\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_listusers_none_12.4.56.0_none_4ce601640a7b5dd7
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=listusers
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.manifest
XP_MANIFEST_PATH=manifests\msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.cat
XP_CATALOG_PATH=manifests\msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.cat
XP_PAYLOAD_PATH=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=listusers,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\ListUsers\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_listusers_none_12.4.56.0_none_4ce601640a7b5dd7
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=listusers
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.manifest
XP_MANIFEST_PATH=manifests\msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.cat
XP_CATALOG_PATH=manifests\msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d.cat
XP_PAYLOAD_PATH=msil_listusers_no-public-key_12.4.56.0_x-ww_17ed410d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=listusers,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\NetTail\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\NetTail\NetTail.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Collections;
using System.Text;
using System.Threading;

namespace NetTail
{

	class Defaults
	{
		public static int Port = 31337;
	}

	class Switch
	{
		public string Name;
		public string Value;
	}

	class ChangeRecord
	{
		public ChangeRecord()
		{
			LastChanged = DateTime.Now;
			LastSize = 0;
		}
		public DateTime 	LastChanged;
		public long 		LastSize;
	}

	class Args 
	{
		private int _pos;
		private string[] _args;

		public Args(string[] args)
		{
			_args = args;
			_pos = 0;
		}

		public void Reset()
		{
			_pos = 0;
		}

		public bool ReadSwitch(out Switch sw, bool required)
		{
			sw = null;

			if(_args == null || _pos == _args.Length)
			{
				if(required)
					throw new ArgumentException("Required argument not supplied");
				return false;
			}

			sw = new Switch();

			if(_args[_pos][0] == '/')
			{
				int valueMark = _args[_pos].IndexOf(':');
				if(valueMark > 0)
				{
					sw.Name = _args[_pos].Substring(1,valueMark-1);
					sw.Value = _args[_pos].Substring(valueMark+1);
				}
				else
				{
					sw.Name = _args[_pos].Substring(1);
					sw.Value = "";
				}
			}
			else
			{
				sw.Name = _args[_pos];
			}
			_pos++;

			return true;
		}

	}

	class Client
	{
		private string 	_Remote;
		private ArrayList _Files;
		private ArrayList _Dirs;
		private ArrayList _Exprs;
		private ArrayList _Watchers;
		private UdpClient _Conn;
		private Hashtable _Changes;

		public Client()
		{
			_Files = new ArrayList();
			_Dirs = new ArrayList();
			_Exprs = new ArrayList();
			_Watchers = new ArrayList();
			_Changes = new Hashtable(128);
			_Conn = new UdpClient();
			_Remote = "localhost";
		}

		public void Start(Args args)
		{
			Switch sw;
			while(args.ReadSwitch(out sw, false))
			{
				if(sw.Name == "dir")
				{
					if(sw.Value == null) throw new ArgumentException("/dir: argument expects value");
					_Dirs.Add(sw.Value);
				}
				else if(sw.Name == "file")
				{
					if(sw.Value == null) throw new ArgumentException("/file: argument expects value");
					_Files.Add(sw.Value);
				}
				else if(sw.Name == "expr")
				{
					if(sw.Value == null) throw new ArgumentException("/expr: argument expects value");
					_Exprs.Add(sw.Value);
				}
				else if(sw.Name == "remote")
				{
					if(sw.Value == null) throw new ArgumentException("/remote: argument expects value");
					_Remote = sw.Value;
				}

			}

			if(_Exprs.Count == 0 && _Files.Count == 0 && _Dirs.Count == 0)
			{
				_Exprs.Add("");
			}

			if(_Exprs.Count > 0 && _Dirs.Count == 0)
			{
				_Dirs.Add(".");
			}

			SetupRemote();
			SetupWatches();
			Run();
		}

		void Run()
		{
			Console.WriteLine("NetTail client running... (Control-C to cancel)");
			while(true)
			{
				Thread.Sleep(1000);
			}
		}
		private void CreateWatcher(string path, string expr)
		{
			FileSystemWatcher watcher = new FileSystemWatcher();
			watcher.Path = path;
			watcher.Filter = expr;
			watcher.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.Size;
			watcher.EnableRaisingEvents = true;
			watcher.Changed += new FileSystemEventHandler(this.OnChanged);
        	watcher.Created += new FileSystemEventHandler(this.OnChanged);
        	watcher.Deleted += new FileSystemEventHandler(this.OnChanged);
        	watcher.Renamed += new RenamedEventHandler(this.OnRenamed);
			_Watchers.Add(watcher);

			if(expr == "")
				expr = "*.*"; // makes more sense to user
			Console.WriteLine("NetTail client added watch on: {0}\\{1}", path, expr);
		}

		private void CreateWatcher(string file)
		{
			FileSystemWatcher watcher = new FileSystemWatcher();
			watcher.Filter = file;
			watcher.NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;
			watcher.EnableRaisingEvents = true;
			watcher.Changed += new FileSystemEventHandler(this.OnChanged);
        	watcher.Created += new FileSystemEventHandler(this.OnChanged);
        	watcher.Deleted += new FileSystemEventHandler(this.OnChanged);
        	watcher.Renamed += new RenamedEventHandler(this.OnRenamed);
			_Watchers.Add(watcher);
			Console.WriteLine("NetTail client added watch on: {0}", file);
		}


		private void SetupRemote()
		{
			_Conn.Connect(_Remote, Defaults.Port);
		}

		private void SetupWatches()
		{
			foreach(string file in _Files)
			{
				CreateWatcher(file);
			}
			foreach(string path in _Dirs)
			{
				if(_Exprs.Count == 0)
				{
					CreateWatcher(path, "");
				}
				else
				{
					foreach(string expr in _Exprs)
					{
						CreateWatcher(path, expr);
					}
				}
			}
		}

		private void SendBytes(byte[] data, int count)
		{
			int sent = 0;
			while(sent < count)
			{
				sent = _Conn.Send(data, count);
				Console.WriteLine("Sent {0}/{1} bytes", sent, count);
			}
		}

		private void HandleChange(string FullPath, ChangeRecord rec)
		{

			using ( StreamReader reader = new StreamReader(new FileStream(FullPath, 
                     FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) )
			{
				long delta = reader.BaseStream.Length - rec.LastSize;

				if(delta < reader.BaseStream.Length)
				{
					byte []data = new byte[2048];
					int n, tot = 0;
					reader.BaseStream.Seek(rec.LastSize, SeekOrigin.Begin);
					while(tot < delta)
					{
						n = reader.BaseStream.Read(data, 0, data.Length);
						if(n > 0)
						{
							SendBytes(data, n);
							tot += n;
						}
						else
						{
							Console.WriteLine("FileStream.Read() return: {0}", n);
							break;
						}
					}
				}
				rec.LastChanged = DateTime.Now;
				rec.LastSize = reader.BaseStream.Length;
			}
		}
    	private void OnChanged(object source, FileSystemEventArgs e)
    	{
       		Console.WriteLine("Change --> File: " +  e.FullPath + " " + e.ChangeType);
			switch(e.ChangeType)
			{
				case WatcherChangeTypes.Deleted:
				case WatcherChangeTypes.Renamed:
					_Changes.Remove(e.FullPath);
					break;
				case WatcherChangeTypes.Created:
				case WatcherChangeTypes.Changed:
					ChangeRecord rec = _Changes[e.FullPath] as ChangeRecord;
					if(rec == null)
					{
						Console.WriteLine("Adding new change record for: " + e.FullPath);
						rec = new ChangeRecord();
						_Changes[e.FullPath] = rec;
					}
					HandleChange(e.FullPath, rec);	
					break;
			}	
    	}

    	private void OnRenamed(object source, RenamedEventArgs e)
    	{
        	// Specify what is done when a file is renamed.
        	Console.WriteLine("File: {0} renamed to {1}", e.OldFullPath, e.FullPath);
    	}
	}

	class Server
	{
		public Server()
		{
		}

		public void Start(Args args)
		{
			UdpClient listen;
			ASCIIEncoding encoding;
			IPEndPoint remote;
			byte[] data;
			String decoded;

			encoding = new ASCIIEncoding();
			listen = new UdpClient(Defaults.Port);

			Console.WriteLine("NetTail server started... (Control-C to cancel)");
			while(true)
			{
				remote = null;
				data = listen.Receive(ref remote);
				decoded = encoding.GetString(data);
				Console.Write("[");
				Console.Write(remote.ToString());
				Console.Write("] ");
				Console.Write("[");
				Console.Write(DateTime.Now.ToString());
				Console.Write("] ");
				Console.Write(decoded);
			}
		}
	}

	class MainClass
	{
		[STAThread]
		public static void Main(string []rawArgs)
		{
			// conver raw arguments to reader args class
			Args args = new Args(rawArgs);
			Switch sw;
			args.ReadSwitch(out sw, true);
			object o = null;

			try
			{
				if(sw.Name == "server")
				{
					Server server = new Server();
					o = server;
					server.Start(args);
				}
				else
				{
					args.Reset();
					Client client = new Client();
					o = client ;
					client.Start(args);
				}
			}
			catch(Exception ex)
			{
				Console.WriteLine("Exception in " + o.GetType().Name + ": " + ex.Message);
				Console.WriteLine(ex.StackTrace);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\CommandLine\PCPT.cs ===
using System;
using System.IO;
using System.Text;
using Microsoft.SPG.eAuto.PCPT.Model;
using Microsoft.SPG.eAuto.PCPT.Model.Processes;

namespace Microsoft.SPG.eAuto.PCPT.View.CommandLine
{
    /// <summary>
    /// This class provides a Command Line interface that allows a user to
    /// deploy, start, or stop counters on the machines in a topology
    /// </summary>
    public class PCPT
    {
        #region Enumerations

        /// <summary>
        /// An enumeration of the possible commands that can beused with the
        /// PCPT command.
        /// </summary>
        enum PCPTCommand
        {
            Deploy,
            Start,
            Stop 
        };

        #endregion
		
        #region Member Variables

        private PCPTCommand command;
        private string username;
        private string password;
        private FileInfo configFile;
        private string interval;
        private LogFormat format;
        private DirectoryInfo counterFileDirectory;
        private DirectoryInfo logArchiveDirectory;
        private bool deleteLogs;
        private bool archiveLogs;
        private Topology topology;

        #endregion
		
        #region Constructors

        /// <summary>
        /// Default Constructor.  Private, and cannot be called outside of this
        /// class.
        /// </summary>
        private PCPT ()
        {
            this.deleteLogs = false;
            this.archiveLogs = false;
        }

        /// <summary>
        /// Creates a new PCPT Object, parsing a list of arguments to determine
        /// the different options to be used.
        /// </summary>
        /// <param name="arguments"></param>
        public PCPT (string [] arguments)
            : this ()
        {
            try
            {
                ParseArguments (arguments);
            }
            catch (Exception e)
            {
                UsageError (e.Message);
            }

            try
            {
                this.topology = (this.counterFileDirectory == null)
                    ? new Topology (this.configFile)
                    : new Topology (this.configFile, this.counterFileDirectory);

                switch (this.command)
                {
                    case PCPTCommand.Deploy:
                        Deploy ();
                        break;
                    case PCPTCommand.Start:
                        Start ();
                        break;
                    case PCPTCommand.Stop:
                        Stop ();
                        break;
                }
            }
            catch (Exception exception)
            {
                HandleException (exception);
            }
        }

        #endregion
		
        #region Deploy/Start/Stop Methods

        /// <summary>
        /// Connects to the Machines in the topology (if a username and
        /// password were specified)
        /// </summary>
        private void ConnectMachines ()
        {
            if (this.username != null && this.password != null)
            {
                this.topology.ConnectMachines (this.username, this.password);
            }
        }

        /// <summary>
        /// Deploys the counters to the machines in the topology.
        /// </summary>
        private void Deploy ()
        {
            ConnectMachines ();
            if (this.interval != null)
            {
                this.topology.DeployCounters (this.interval, this.format);
            }
            else
            {
                this.topology.DeployCounters (this.format);
            }
        }

        /// <summary>
        /// Starts the counters on all the machines in the topology.
        /// </summary>
        private void Start ()
        {
            ConnectMachines ();
            if (this.interval != null)
            {
                this.topology.UpdateCounterInterval (this.interval);
            }
            this.topology.StartCounters ();
        }

        /// <summary>
        /// Stops the counters on all the machines in the topology.  After
        /// they have been stopped, the counter logs will either be left in
        /// place, deleted, or archived, depending on what options have been
        /// specified.
        /// </summary>
        private void Stop ()
        {
            ConnectMachines ();
            this.topology.StopCounters ();

            if (this.deleteLogs)
            {
                this.topology.DeleteCounterLogs ();
            }
            else if (this.archiveLogs)
            {
                this.topology.ArchiveCounterLogs (this.logArchiveDirectory);
            }
        }

        #endregion
		
        #region Methods for Parsing the Arguments

        /// <summary>
        /// Parses a list of arguments.  Throws an exception if an invalid
        /// option is specified, or if there is any kind of problem while
        /// parsing the list.
        /// </summary>
        /// <param name="arguments">The list of arguments to parse.</param>
        private void ParseArguments (string [] arguments)
        {
            if (arguments.Length < 1)
            {
                throw new Exception ("Not enough arguments");
            }

            switch (arguments [0].ToLower ())
            {
                case "deploy":
                    this.command = PCPTCommand.Deploy;
                    break;
                case "start":
                    this.command = PCPTCommand.Start;
                    break;
                case "stop":
                    this.command = PCPTCommand.Stop;
                    break;
                default:
                    throw new Exception ("Invalid command specified");
            }

            for (int i = 1; i < arguments.Length; i++)
            {
                ParseArgument (arguments [i]);
            }

            if (this.archiveLogs && this.deleteLogs)
            {
                throw new Exception ("Only one of the archive logs and delete logs options may be specified");
            }

            if (this.password != null && this.username == null)
            {
                throw new Exception ("You can only specify a password if you also specify a username");
            }

            if (this.password == null && this.username != null)
            {
                throw new Exception ("You can only specify a username if you also specify a password");
            }

            if (this.configFile == null)
            {
                throw new Exception ("You must specify a configuration XML file");
            }
            else if (!this.configFile.Exists)
            {
                throw new Exception ("The configuration file you specified does not exist.");
            }
        }

        /// <summary>
        /// Parses a single argument.  Throws an exception if there is any
        /// kind of problem while parsing or if an invalid option is specified.
        /// </summary>
        /// <param name="argument">The argument to be parsed.</param>
        private void ParseArgument (string argument)
        {
            if (!argument.StartsWith ("/"))
            {
                throw new Exception ("Argument did not start with '/'");
            }
            switch (argument [1])
            {
                case 'u':
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("Username option did not include a colon");
                    }
                    this.username = argument.Substring (3);
                    break;
                case 'p':
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("Password option did not include a colon");
                    }
                    this.password = argument.Substring (3);
                    break;
                case 'x':
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("XML Configuration file option did not include a colon");
                    }
                    this.configFile = new FileInfo (argument.Substring (3));
                    break;
                case 'i':
                    if (this.command != PCPTCommand.Deploy && this.command != PCPTCommand.Start)
                    {
                        throw new Exception ("The interval option can only be used with the 'deploy' or 'start' command");
                    }
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("Interval option did not include a colon");
                    }
                    this.interval = argument.Substring (3);
                    if (!this.ValidInterval)
                    {
                        throw new Exception ("The interval specified was not of the form HH:MM:SS");
                    }
                    break;
                case 't':
                    if (this.command != PCPTCommand.Deploy)
                    {
                        throw new Exception ("The counter file directory option can only be used with the 'deploy' command");
                    }
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("Counter file directory option did not include a colon");
                    }
                    this.counterFileDirectory = new DirectoryInfo (argument.Substring (3));
                    break;
                case 'f':
                    if (this.command != PCPTCommand.Deploy)
                    {
                        throw new Exception ("The log format option can only be used with the 'deploy' command");
                    }
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("The log format option did not include a colon");
                    }
                    this.format = TranslateFormat (argument.Substring (3));
                    break;
                case 'd':
                    if (this.command != PCPTCommand.Stop)
                    {
                        throw new Exception ("The delete logs option can only be used with the 'stop' command");
                    }
                    if (argument.Length != 2)
                    {
                        throw new Exception ("No other information may be included in the delete logs option");
                    }
                    this.deleteLogs = true;
                    break;
                case 'a':
                    if (this.command != PCPTCommand.Stop)
                    {
                        throw new Exception ("The archive logs option can only be used with the 'stop' command");
                    }
                    if (argument.Length < 3 || argument [2] != ':')
                    {
                        throw new Exception ("Archive logs option did not include a colon");
                    }
                    this.archiveLogs = true;
                    this.logArchiveDirectory = new DirectoryInfo (argument.Substring (3));
                    break;
            }
        }

        /// <summary>
        /// Gets whether or not the interval that was specified is valid.  A
        /// valid interval is of the form HH:MM:SS.
        /// </summary>
        private bool ValidInterval
        {
            get
            {
                return (this.interval.Length == 8
                    && Char.IsDigit (this.interval [0])
                    && Char.IsDigit (this.interval [1])
                    && this.interval [2] == ':'
                    && Char.IsDigit (this.interval [3])
                    && Char.IsDigit (this.interval [4])
                    && this.interval [5] == ':'
                    && Char.IsDigit (this.interval [6])
                    && Char.IsDigit (this.interval [7]));
            }
        }

        /// <summary>
        /// Translates a log format string into a LogFormat enumeration value,
        /// checking to make sure a valid log format was specified
        /// </summary>
        /// <param name="argument">The log format string</param>
        /// <returns>The corresponding LogFormat enumeration value</returns>
        private static LogFormat TranslateFormat (string argument)
        {
            argument = argument.ToLower ();
            if (argument == "blg")
            {
                return LogFormat.Blg;
            }
            else if (argument == "csv")
            {
                return LogFormat.Csv;
            }
            else
            {
                throw new Exception ("An invalid log format option was specified: " + argument);
            }
        }

        /// <summary>
        /// Tells the user that they have incorrectly invoked the PCPT command.
        /// Also provides them with information about what they did wrong, as
        /// well as the correct way to invoke the PCPT command.
        /// </summary>
        /// <param name="error">The error that occurred.</param>
        private static void UsageError (string error)
        {
            string br = Environment.NewLine;
            StringBuilder sb = new StringBuilder ();

            sb.Append (br);
            sb.Append ("You have used the Performance Counter Pushing Tool (PCPT) incorrectly.");
            sb.Append (br);
            sb.Append ("  (");
            sb.Append (error);
            sb.Append (")");
            sb.Append (br);
            sb.Append ("The correct usage for the PCPT is as follows:");
            sb.Append (br);
            sb.Append (br);

            sb.Append ("pcpt.exe <command> [options]");
            sb.Append (br);
            sb.Append ("  <command> is either 'deploy', 'start', or 'stop'");
            sb.Append (br);
            sb.Append ("  [options] depends on what <command> is");
            sb.Append (br);
            sb.Append (br);

            sb.Append ("Options for any command:");
            sb.Append (br);
            sb.Append ("  /u:<username>    - Specifies the username to use on all computers");
            sb.Append (br);
            sb.Append ("  /p:<password>    - Specifies the password to use on all computers");
            sb.Append (br);
            sb.Append ("  /x:<config-file> - Specifies the XML configuration file for the toplogy");
            sb.Append (br);
            sb.Append (br);

            sb.Append ("Options specific to the 'deploy' command:");
            sb.Append (br);
            sb.Append ("  /i:<interval>    - Specifies the interval at which counters are to be updated");
            sb.Append (br);
            sb.Append ("                     Must be in the form HH:MM:SS");
            sb.Append (br);
            sb.Append (br);
            sb.Append ("  /f:<format>      - Specifies format to use for the log file");
            sb.Append (br);
            sb.Append ("                     Must be in either blg or csv");
            sb.Append (br);
            sb.Append ("  /t:<directory>   - Specifies where to place the generated counter files");
            sb.Append (br);
            sb.Append (br);

            sb.Append ("Options specific to the 'start' command:");
            sb.Append (br);
            sb.Append ("  /i:<interval>    - Specifies the interval at which counters are to be updated");
            sb.Append (br);
            sb.Append ("                     Must be in the form HH:MM:SS");
            sb.Append (br);
            sb.Append (br);

            sb.Append ("Options specific to the 'stop' command:");
            sb.Append (br);
            sb.Append ("  /d               - Delete the log files that were generated");
            sb.Append (br);
            sb.Append ("  /a:<directory>   - Archive the log files in the specified directory");
            sb.Append (br);
            sb.Append (br);

            Console.WriteLine (sb.ToString ());

            Environment.Exit (1);
        }

        #endregion

        #region Helper Methods

        private void HandleException (Exception exception)
        {
            const string message = "There was an error while running PCPT:";

            TextWriter writer = Console.Error;

            writer.WriteLine ();
            writer.WriteLine (message);
            writer.WriteLine (exception.Message);
        }

        #endregion

        /// <summary>
        /// The entry point for the PCPT command.
        /// </summary>
        /// <param name="arguments">The Command Line arguments to the command.</param>
        public static void Main (string [] arguments)
        {
            new PCPT (arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\NameVetting\Form1.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.IO;

namespace WindowsApplication2
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class fMain : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ComboBox cbEntry;
		private System.Windows.Forms.Button bGo;
		private System.Windows.Forms.ListBox lbResults;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox tServer;
		private System.Windows.Forms.Button bFromFile;
		private System.Windows.Forms.OpenFileDialog OFD;
		private System.Windows.Forms.Button bSaveLog;
		private System.Windows.Forms.SaveFileDialog SFD;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public fMain()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			Tester=new TestName();
			Tester.Report=new TestName.ReportFunctionCallback(Report);
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.cbEntry = new System.Windows.Forms.ComboBox();
			this.bGo = new System.Windows.Forms.Button();
			this.lbResults = new System.Windows.Forms.ListBox();
			this.label1 = new System.Windows.Forms.Label();
			this.tServer = new System.Windows.Forms.TextBox();
			this.bFromFile = new System.Windows.Forms.Button();
			this.OFD = new System.Windows.Forms.OpenFileDialog();
			this.bSaveLog = new System.Windows.Forms.Button();
			this.SFD = new System.Windows.Forms.SaveFileDialog();
			this.SuspendLayout();
			// 
			// cbEntry
			// 
			this.cbEntry.Location = new System.Drawing.Point(16, 16);
			this.cbEntry.Name = "cbEntry";
			this.cbEntry.Size = new System.Drawing.Size(280, 21);
			this.cbEntry.TabIndex = 0;
			this.cbEntry.Text = "some name";
			this.cbEntry.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.cbEntry_KeyPress);
			// 
			// bGo
			// 
			this.bGo.Location = new System.Drawing.Point(304, 16);
			this.bGo.Name = "bGo";
			this.bGo.TabIndex = 1;
			this.bGo.Text = "Vet name";
			this.bGo.Click += new System.EventHandler(this.bGo_Click);
			// 
			// lbResults
			// 
			this.lbResults.Items.AddRange(new object[] {
														   "Results:"});
			this.lbResults.Location = new System.Drawing.Point(16, 88);
			this.lbResults.Name = "lbResults";
			this.lbResults.Size = new System.Drawing.Size(360, 160);
			this.lbResults.TabIndex = 2;
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(16, 56);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(152, 16);
			this.label1.TabIndex = 3;
			this.label1.Text = "Server (any XUACS will do):";
			// 
			// tServer
			// 
			this.tServer.Location = new System.Drawing.Point(160, 52);
			this.tServer.Name = "tServer";
			this.tServer.Size = new System.Drawing.Size(136, 20);
			this.tServer.TabIndex = 4;
			this.tServer.Text = "10.10.2.132";
			// 
			// bFromFile
			// 
			this.bFromFile.Location = new System.Drawing.Point(304, 51);
			this.bFromFile.Name = "bFromFile";
			this.bFromFile.TabIndex = 5;
			this.bFromFile.Text = "From file";
			this.bFromFile.Click += new System.EventHandler(this.bFromFile_Click);
			// 
			// OFD
			// 
			this.OFD.DefaultExt = "txt";
			this.OFD.Filter = "Text files (*.txt)|*.txt";
			this.OFD.RestoreDirectory = true;
			this.OFD.ShowReadOnly = true;
			// 
			// bSaveLog
			// 
			this.bSaveLog.Location = new System.Drawing.Point(304, 256);
			this.bSaveLog.Name = "bSaveLog";
			this.bSaveLog.TabIndex = 6;
			this.bSaveLog.Text = "Save Log";
			this.bSaveLog.Click += new System.EventHandler(this.bSaveLog_Click);
			// 
			// SFD
			// 
			this.SFD.DefaultExt = "txt";
			this.SFD.FileName = "doc1";
			this.SFD.Filter = "Text files (*.txt)|*.txt";
			// 
			// fMain
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(392, 285);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.bSaveLog,
																		  this.bFromFile,
																		  this.tServer,
																		  this.label1,
																		  this.lbResults,
																		  this.bGo,
																		  this.cbEntry});
			this.Name = "fMain";
			this.Text = "Name vetting test tool v1";
			this.Closing += new System.ComponentModel.CancelEventHandler(this.fMain_Closing);
			this.ResumeLayout(false);

		}
		#endregion

		TestName		Tester;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new fMain());
		}

		private void Report(string s)
		{
			lbResults.Items.Add(s);
			int TopIndex;
			TopIndex=lbResults.Items.Count-(lbResults.Height/lbResults.ItemHeight);
			if (TopIndex<0)
				TopIndex=0;
			lbResults.TopIndex=TopIndex;
		}

		private void cbEntry_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
		{
			if (e.KeyChar=='\r')
				bGo_Click(this,null);
		}

		private void bGo_Click(object sender, System.EventArgs e)
		{
			Tester.Server=tServer.Text;
			Tester.Go(cbEntry.Text);
			cbEntry.Items.Add(cbEntry.Text);
		}

		private void fMain_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			Tester.Dispose();
			Tester=null;
		}

		private void bFromFile_Click(object sender, System.EventArgs e)
		{
			if (OFD.ShowDialog()!=DialogResult.OK)
				return;
			TextReader	InputFile=File.OpenText(OFD.FileName); 

			while (true)
			{
				string s=InputFile.ReadLine();
				if (s==null)
					break;
				Tester.Server=tServer.Text;
				Tester.Go(s);
			}
		}

		private void bSaveLog_Click(object sender, System.EventArgs e)
		{
			if (SFD.ShowDialog()!=DialogResult.OK)
				return;
			TextWriter	OutputFile=File.CreateText(SFD.FileName); 

			foreach (string s in lbResults.Items)
			{
				OutputFile.WriteLine(s);
			}
			OutputFile.Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\NameVetting\TestName.cs ===
using System;
using XTest.Utilities.Users;
using XTest.Utilities.Diagnostics;
using XTest.Utilities;

namespace WindowsApplication2
{
	/// <summary>
	/// Summary description for TestName.
	/// </summary>
	public class TestName
	{
		protected FakeSG		SG;
		public string Server="192.168.86.231";
		
		public delegate void ReportFunctionCallback(string s);
		public ReportFunctionCallback Report;
		protected void NullReport(string s)
		{
			System.Diagnostics.Debug.WriteLine(s);
		}
			
		public void Dispose()
		{
			SG.End();
		}
		public TestName()
		{
			Report=new ReportFunctionCallback(NullReport);
			SG=new FakeSG();
			SG.Start();
			XRLReserveName.DefaultSG=SG;
			XRLReserveName.DefaultMpuid=0x0009400000000001;
			//
			// TODO: Add constructor logic here
			//
		}
		public void Go(string Name)
		{
			XRLReserveName			Request = new XRLReserveName();
			XRLReserveResponseHead	Head;
			XRLReserveResponseItem	[]Items;
			ulong					Ret;

			Report("Trying name ["+Name+"]");
			Request.GamerName=Name;
			Request.MaxAltNames=10;
			Request.CountryId=103;
			Request.SG=SG;
			Request.BogusAuth=false;
			Request.MachinePuid=0x0009400000000001;
			try
			{
				Ret=Request.Create(Server,out Head, out Items);
				if (Head!=null)
				{
					if (Head.NameCount>0)
						Report("["+Name+"] is taken");
					else
						Report("["+Name+"] is available, but Head is not null");
				}
				else
				{
					if (Ret==0 && Request.XErr==0)
					{
						Report("["+Name+"] is available");
					}
					else
					{
						Report("["+Name+"] seems to be invalid");
						Report("XErr 0x"+Request.XErr.ToString("X"));
						Report("Returned code "+Request.HttpStatus);
					}
				}
			}
			catch(Exception e)
			{
				Report(e.ToString());
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\IntervalControl.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
	/// <summary>
	/// Summary description for IntervalControl.
	/// </summary>
	public class IntervalControl : System.Windows.Forms.UserControl
	{
        private System.Windows.Forms.NumericUpDown secondsBox;
        private System.Windows.Forms.NumericUpDown minutesBox;
        private System.Windows.Forms.NumericUpDown hoursBox;
        private System.Windows.Forms.Label secondsLabel;
        private System.Windows.Forms.Label minutesLabel;
        private System.Windows.Forms.Label hoursLabel;
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public IntervalControl()
		{
			// This call is required by the Windows.Forms Form Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call

		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public string Interval
        {
            get
            {
                StringBuilder sb = new StringBuilder (9);
                if (this.hoursBox.Value < 10)
                {
                    sb.Append ("0");
                }
                sb.Append (this.hoursBox.Value);
                sb.Append (":");
                if (this.minutesBox.Value < 10)
                {
                    sb.Append ("0");
                }
                sb.Append (this.minutesBox.Value);
                sb.Append (":");
                if (this.secondsBox.Value < 10)
                {
                    sb.Append ("0");
                }
                sb.Append (this.secondsBox.Value);
                return sb.ToString ();
            }
        }

        #region Component Designer generated code
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.secondsLabel = new System.Windows.Forms.Label();
            this.minutesLabel = new System.Windows.Forms.Label();
            this.hoursLabel = new System.Windows.Forms.Label();
            this.secondsBox = new System.Windows.Forms.NumericUpDown();
            this.minutesBox = new System.Windows.Forms.NumericUpDown();
            this.hoursBox = new System.Windows.Forms.NumericUpDown();
            ((System.ComponentModel.ISupportInitialize)(this.secondsBox)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.minutesBox)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.hoursBox)).BeginInit();
            this.SuspendLayout();
            // 
            // secondsLabel
            // 
            this.secondsLabel.Location = new System.Drawing.Point(8, 72);
            this.secondsLabel.Name = "secondsLabel";
            this.secondsLabel.Size = new System.Drawing.Size(56, 24);
            this.secondsLabel.TabIndex = 10;
            this.secondsLabel.Text = "&Seconds:";
            this.secondsLabel.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // minutesLabel
            // 
            this.minutesLabel.Location = new System.Drawing.Point(8, 40);
            this.minutesLabel.Name = "minutesLabel";
            this.minutesLabel.Size = new System.Drawing.Size(56, 24);
            this.minutesLabel.TabIndex = 8;
            this.minutesLabel.Text = "&Minutes:";
            this.minutesLabel.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // hoursLabel
            // 
            this.hoursLabel.Location = new System.Drawing.Point(8, 8);
            this.hoursLabel.Name = "hoursLabel";
            this.hoursLabel.Size = new System.Drawing.Size(56, 24);
            this.hoursLabel.TabIndex = 6;
            this.hoursLabel.Text = "&Hours:";
            this.hoursLabel.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // secondsBox
            // 
            this.secondsBox.Location = new System.Drawing.Point(72, 74);
            this.secondsBox.Maximum = new System.Decimal(new int[] {
                                                                       59,
                                                                       0,
                                                                       0,
                                                                       0});
            this.secondsBox.Name = "secondsBox";
            this.secondsBox.Size = new System.Drawing.Size(48, 20);
            this.secondsBox.TabIndex = 11;
            this.secondsBox.Value = new System.Decimal(new int[] {
                                                                     15,
                                                                     0,
                                                                     0,
                                                                     0});
            // 
            // minutesBox
            // 
            this.minutesBox.Location = new System.Drawing.Point(72, 42);
            this.minutesBox.Maximum = new System.Decimal(new int[] {
                                                                       59,
                                                                       0,
                                                                       0,
                                                                       0});
            this.minutesBox.Name = "minutesBox";
            this.minutesBox.Size = new System.Drawing.Size(48, 20);
            this.minutesBox.TabIndex = 9;
            // 
            // hoursBox
            // 
            this.hoursBox.Location = new System.Drawing.Point(72, 10);
            this.hoursBox.Maximum = new System.Decimal(new int[] {
                                                                     99,
                                                                     0,
                                                                     0,
                                                                     0});
            this.hoursBox.Name = "hoursBox";
            this.hoursBox.Size = new System.Drawing.Size(48, 20);
            this.hoursBox.TabIndex = 7;
            // 
            // IntervalControl
            // 
            this.Controls.Add(this.secondsLabel);
            this.Controls.Add(this.minutesLabel);
            this.Controls.Add(this.hoursLabel);
            this.Controls.Add(this.secondsBox);
            this.Controls.Add(this.minutesBox);
            this.Controls.Add(this.hoursBox);
            this.Name = "IntervalControl";
            this.Size = new System.Drawing.Size(128, 104);
            ((System.ComponentModel.ISupportInitialize)(this.secondsBox)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.minutesBox)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.hoursBox)).EndInit();
            this.ResumeLayout(false);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\ErrorsDialog.cs ===
using System;
using System.Collections;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using Microsoft.SPG.eAuto.PCPT.Model;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
	/// <summary>
	/// Summary description for ErrorsDialog.
	/// </summary>
	public class ErrorsDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label headingLabel;
		private System.Windows.Forms.Label descriptionLabel;
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.TextBox messagesBox;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ErrorsDialog (Topology topology)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			topology.Error += new ErrorEventHandler (OnError);
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		public bool IsEmpty
		{
			get
			{
				return (this.messagesBox.Text == "");
			}
		}

		public void Clear ()
		{
			this.messagesBox.Clear ();
		}

		public void OnError (object sender, ErrorEventArgs args)
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append ("On Machine [");
			sb.Append (args.Machine);
			sb.Append ("]:");
			sb.Append (Environment.NewLine);
			sb.Append (args.Message);
			sb.Append (Environment.NewLine);
			this.messagesBox.Text += sb.ToString ();
			this.messagesBox.Select (0, 0);
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.headingLabel = new System.Windows.Forms.Label();
			this.descriptionLabel = new System.Windows.Forms.Label();
			this.okButton = new System.Windows.Forms.Button();
			this.messagesBox = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// headingLabel
			// 
			this.headingLabel.Font = new System.Drawing.Font("Arial Black", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.headingLabel.Location = new System.Drawing.Point(16, 8);
			this.headingLabel.Name = "headingLabel";
			this.headingLabel.Size = new System.Drawing.Size(462, 23);
			this.headingLabel.TabIndex = 0;
			this.headingLabel.Text = "Unexpected Results";
			this.headingLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// descriptionLabel
			// 
			this.descriptionLabel.Location = new System.Drawing.Point(16, 40);
			this.descriptionLabel.Name = "descriptionLabel";
			this.descriptionLabel.Size = new System.Drawing.Size(462, 32);
			this.descriptionLabel.TabIndex = 1;
			this.descriptionLabel.Text = "The following unexpected messages were received from the machine(s) in the topolo" +
				"gy:";
			this.descriptionLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// okButton
			// 
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(210, 296);
			this.okButton.Name = "okButton";
			this.okButton.TabIndex = 3;
			this.okButton.Text = "&OK";
			// 
			// messagesBox
			// 
			this.messagesBox.Cursor = System.Windows.Forms.Cursors.IBeam;
			this.messagesBox.ForeColor = System.Drawing.SystemColors.WindowText;
			this.messagesBox.Location = new System.Drawing.Point(15, 80);
			this.messagesBox.Multiline = true;
			this.messagesBox.Name = "messagesBox";
			this.messagesBox.ReadOnly = true;
			this.messagesBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.messagesBox.Size = new System.Drawing.Size(464, 200);
			this.messagesBox.TabIndex = 2;
			this.messagesBox.Text = "";
			// 
			// ErrorsDialog
			// 
			this.AcceptButton = this.okButton;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(494, 334);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.okButton,
																		  this.messagesBox,
																		  this.descriptionLabel,
																		  this.headingLabel});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "ErrorsDialog";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Unexpected Results";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Installer\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Help\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\CounterCollectionOptionsDialog.cs ===
using System;
using System.Collections;
using System.Windows.Forms;
using System.Text;
using Microsoft.SPG.eAuto.PCPT.Model.Processes;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
	/// <summary>
	/// Summary description for IntervalDialog.
	/// </summary>
	public class CounterCollectionOptionsDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.Label headingLabel;
        private System.Windows.Forms.GroupBox formatBox;
        private System.Windows.Forms.RadioButton blgButton;
        private System.Windows.Forms.RadioButton csvButton;
        private System.Windows.Forms.GroupBox intervalBox;
        private Microsoft.SPG.eAuto.PCPT.View.Form.IntervalControl intervalControl;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public CounterCollectionOptionsDialog()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public string Interval
        {
            get
            {
                return this.intervalControl.Interval;
            }
        }

        public LogFormat LogFormat
        {
            get
            {
                if (this.csvButton.Checked)
                {
                    return LogFormat.Csv;
                }
                else
                {
                    return LogFormat.Blg;
                }
            }
        }

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.headingLabel = new System.Windows.Forms.Label();
            this.formatBox = new System.Windows.Forms.GroupBox();
            this.csvButton = new System.Windows.Forms.RadioButton();
            this.blgButton = new System.Windows.Forms.RadioButton();
            this.intervalBox = new System.Windows.Forms.GroupBox();
            this.intervalControl = new Microsoft.SPG.eAuto.PCPT.View.Form.IntervalControl();
            this.formatBox.SuspendLayout();
            this.intervalBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // okButton
            // 
            this.okButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.okButton.Location = new System.Drawing.Point(145, 324);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(72, 23);
            this.okButton.TabIndex = 4;
            this.okButton.Text = "&OK";
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(65, 324);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(72, 23);
            this.cancelButton.TabIndex = 3;
            this.cancelButton.Text = "&Cancel";
            // 
            // headingLabel
            // 
            this.headingLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.headingLabel.Location = new System.Drawing.Point(16, 16);
            this.headingLabel.Name = "headingLabel";
            this.headingLabel.Size = new System.Drawing.Size(248, 40);
            this.headingLabel.TabIndex = 0;
            this.headingLabel.Text = "Please specify the options to use when creating the new Performance Counter Colle" +
                "ction";
            // 
            // formatBox
            // 
            this.formatBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.formatBox.Controls.Add(this.csvButton);
            this.formatBox.Controls.Add(this.blgButton);
            this.formatBox.Location = new System.Drawing.Point(16, 64);
            this.formatBox.Name = "formatBox";
            this.formatBox.Size = new System.Drawing.Size(240, 96);
            this.formatBox.TabIndex = 1;
            this.formatBox.TabStop = false;
            this.formatBox.Text = "Log File Format";
            // 
            // csvButton
            // 
            this.csvButton.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.csvButton.Location = new System.Drawing.Point(16, 56);
            this.csvButton.Checked = true; 
            this.csvButton.Name = "csvButton";
            this.csvButton.Size = new System.Drawing.Size(208, 24);
            this.csvButton.TabIndex = 1;
            this.csvButton.Text = "&CSV";
            // 
            // blgButton
            // 
            this.blgButton.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            //this.blgButton.Checked = true;
            this.blgButton.Location = new System.Drawing.Point(16, 24);
            this.blgButton.Name = "blgButton";
            this.blgButton.Size = new System.Drawing.Size(208, 24);
            this.blgButton.TabIndex = 0;
            this.blgButton.TabStop = true;
            this.blgButton.Text = "&BLG";
            // 
            // intervalBox
            // 
            this.intervalBox.Controls.Add(this.intervalControl);           
            this.intervalBox.Location = new System.Drawing.Point(16, 176);
            this.intervalBox.Name = "intervalBox";
            this.intervalBox.Size = new System.Drawing.Size(240, 128);
            this.intervalBox.TabIndex = 2;
            this.intervalBox.TabStop = false;
            this.intervalBox.Text = "Sample Interval";
            // 
            // intervalControl
            // 
            this.intervalControl.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.intervalControl.Location = new System.Drawing.Point(16, 16);
            this.intervalControl.Name = "intervalControl";
            this.intervalControl.Size = new System.Drawing.Size(208, 104);
            this.intervalControl.TabIndex = 0;
            // 
            // CounterCollectionOptionsDialog
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(282, 362);
            this.Controls.Add(this.intervalBox);
            this.Controls.Add(this.formatBox);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.headingLabel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "CounterCollectionOptionsDialog";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Counter Collection Options";
            this.formatBox.ResumeLayout(false);
            this.intervalBox.ResumeLayout(false);
            this.ResumeLayout(false);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\IntervalDialog.cs ===
using System;
using System.Collections;
using System.Windows.Forms;
using System.Text;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
    /// <summary>
    /// Summary description for IntervalDialog.
    /// </summary>
    public class IntervalDialog : System.Windows.Forms.Form
    {
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private Microsoft.SPG.eAuto.PCPT.View.Form.IntervalControl intervalControl;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public IntervalDialog()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        public string Interval
        {
            get
            {
                return this.intervalControl.Interval;
            }
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.intervalControl = new Microsoft.SPG.eAuto.PCPT.View.Form.IntervalControl();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(16, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(152, 40);
            this.label1.TabIndex = 0;
            this.label1.Text = "At What Interval (How Often) Would You Like the Counters to Be Updated?";
            // 
            // okButton
            // 
            this.okButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.okButton.Location = new System.Drawing.Point(96, 192);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(72, 23);
            this.okButton.TabIndex = 3;
            this.okButton.Text = "&OK";
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(16, 192);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(72, 23);
            this.cancelButton.TabIndex = 2;
            this.cancelButton.Text = "&Cancel";
            // 
            // intervalControl
            // 
            this.intervalControl.Location = new System.Drawing.Point(24, 72);
            this.intervalControl.Name = "intervalControl";
            this.intervalControl.Size = new System.Drawing.Size(136, 104);
            this.intervalControl.TabIndex = 1;
            // 
            // IntervalDialog
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(184, 230);
            this.Controls.Add(this.intervalControl);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.label1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "IntervalDialog";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Counter Interval";
            this.ResumeLayout(false);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\ProgressDialog.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using Microsoft.SPG.eAuto.PCPT.Model;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
	/// <summary>
	/// Summary description for ProgressDialog.
	/// </summary>
	public class ProgressDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label;
		private System.Windows.Forms.ProgressBar progressBar;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProgressDialog (Topology topology, System.Windows.Forms.Form owner)
		{
			this.Owner = owner;
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			topology.Progress += new ProgressEventHandler (OnProgress);
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		public void OnProgress (object sender, ProgressEventArgs args)
		{
			if (!this.Visible)
			{
				CenterToParent ();
				Show ();
			}

			if (this.label.Text != args.Message)
			{
				this.label.Text = args.Message;
			}
			if (this.progressBar.Minimum != args.MinimumValue)
			{
				this.progressBar.Minimum = args.MinimumValue;
			}
			if (this.progressBar.Maximum != args.MaximumValue)
			{
				this.progressBar.Maximum = args.MaximumValue;
			}
			if (this.progressBar.Value != args.CurrentValue)
			{
				this.progressBar.Value = args.CurrentValue;
			}

			if (args.CurrentValue == args.MaximumValue)
			{
				Hide ();
			}

			Application.DoEvents ();
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label = new System.Windows.Forms.Label();
			this.progressBar = new System.Windows.Forms.ProgressBar();
			this.SuspendLayout();
			// 
			// label
			// 
			this.label.Font = new System.Drawing.Font("Arial", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label.Location = new System.Drawing.Point(12, 8);
			this.label.Name = "label";
			this.label.Size = new System.Drawing.Size(370, 56);
			this.label.TabIndex = 0;
			this.label.Text = "Progress:";
			this.label.TextAlign = System.Drawing.ContentAlignment.BottomLeft;
			this.label.UseMnemonic = false;
			// 
			// progressBar
			// 
			this.progressBar.Location = new System.Drawing.Point(12, 72);
			this.progressBar.Name = "progressBar";
			this.progressBar.Size = new System.Drawing.Size(370, 20);
			this.progressBar.Step = 1;
			this.progressBar.TabIndex = 1;
			// 
			// ProgressDialog
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(394, 102);
			this.ControlBox = false;
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.progressBar,
																		  this.label});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "ProgressDialog";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Progress";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\UserPassDialog.cs ===
using System;
using System.Collections;
using System.Windows.Forms;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
	public class UserPassDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.TextBox usernameBox;
		private System.Windows.Forms.TextBox passwordBox;
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.Button cancelButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public UserPassDialog()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		public string Username
		{
			get
			{
				return this.usernameBox.Text;
			}
		}

		public string Password
		{
			get
			{
				return this.passwordBox.Text;
			}
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.usernameBox = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.passwordBox = new System.Windows.Forms.TextBox();
			this.okButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(16, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(264, 32);
			this.label1.TabIndex = 0;
			this.label1.Text = "Please Enter the Username and Password that you will connect to the computers in " +
				"the topology with:";
			// 
			// usernameBox
			// 
			this.usernameBox.Location = new System.Drawing.Point(104, 72);
			this.usernameBox.Name = "usernameBox";
			this.usernameBox.Size = new System.Drawing.Size(168, 20);
			this.usernameBox.TabIndex = 1;
			this.usernameBox.Text = "";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(16, 72);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(80, 20);
			this.label2.TabIndex = 2;
			this.label2.Text = "&USERNAME:";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(18, 104);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(78, 20);
			this.label3.TabIndex = 4;
			this.label3.Text = "&PASSWORD:";
			this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// passwordBox
			// 
			this.passwordBox.Location = new System.Drawing.Point(104, 104);
			this.passwordBox.Name = "passwordBox";
			this.passwordBox.PasswordChar = '*';
			this.passwordBox.Size = new System.Drawing.Size(168, 20);
			this.passwordBox.TabIndex = 3;
			this.passwordBox.Text = "";
			// 
			// okButton
			// 
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(152, 152);
			this.okButton.Name = "okButton";
			this.okButton.Size = new System.Drawing.Size(120, 23);
			this.okButton.TabIndex = 5;
			this.okButton.Text = "&OK";
			// 
			// cancelButton
			// 
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(16, 152);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.Size = new System.Drawing.Size(120, 23);
			this.cancelButton.TabIndex = 6;
			this.cancelButton.Text = "&Cancel";
			// 
			// UserPassDialog
			// 
			this.AcceptButton = this.okButton;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.cancelButton;
			this.ClientSize = new System.Drawing.Size(292, 196);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.cancelButton,
																		  this.okButton,
																		  this.label3,
																		  this.passwordBox,
																		  this.label2,
																		  this.usernameBox,
																		  this.label1});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "UserPassDialog";
			this.ShowInTaskbar = false;
			this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Login Information";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\FormView\MainForm.cs ===
using System;
using System.Collections;
using System.Windows.Forms;
using System.IO;
using System.Text;
using Microsoft.SPG.eAuto.PCPT.Model;

namespace Microsoft.SPG.eAuto.PCPT.View.Form
{
    /// <summary>
    /// The main form for this application.
    /// </summary>
    public class MainForm : System.Windows.Forms.Form
    {
        private Topology topology;
        private ErrorsDialog errorDialog;
        private ProgressDialog progressDialog;
        private Button ExitButton;
        private Button LoadButton;
        private Button DeployButton;
        private Button StartButton;
        private Button StopButton;
        private StatusBar StatusBar;
        private StatusBarPanel CurrentTopologyPanel;
        private Button UpdateButton;
        private Label HeadingLabel;
        private Button DeleteButton;
        private Button ArchiveButton;

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() 
        {
            Application.Run (new MainForm ());
        }

        public MainForm()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Helper Methods

        private static void ErrorBox (IWin32Window owner, Exception e)
        {
            string caption = "Error";
            MessageBoxButtons buttons = MessageBoxButtons.OK;
            MessageBoxIcon icon = MessageBoxIcon.Error;
            if (e.InnerException == null)
            {
                MessageBox.Show (owner, e.Message, caption, buttons, icon);
            }
            else
            {
                string errors = e.Message;
                errors += Environment.NewLine;
                errors += e.InnerException.Message;
                MessageBox.Show (owner, errors, caption, buttons, icon);
            }
        }

        private void Begin ()
        {
            this.LoadButton.Enabled = false;
            this.DeployButton.Enabled = false;
            this.UpdateButton.Enabled = false;
            this.StartButton.Enabled = false;
            this.StopButton.Enabled = false;
            this.ExitButton.Enabled = false;
            this.ArchiveButton.Enabled = false;
            this.DeleteButton.Enabled = false;

            if (this.errorDialog != null)
                this.errorDialog.Clear ();
        }

        private void End ()
        {
            if (this.progressDialog != null && this.progressDialog.Visible)
            {
                this.progressDialog.Hide ();
            }

            this.LoadButton.Enabled = true;
            bool loaded = (this.topology != null);
            this.DeployButton.Enabled = loaded;
            this.UpdateButton.Enabled = loaded;
            this.StartButton.Enabled = loaded;
            this.StopButton.Enabled = loaded;
            this.ArchiveButton.Enabled = loaded;
            this.DeleteButton.Enabled = loaded;
            this.ExitButton.Enabled = true;
        }

        private void ShowResults (string header, string message)
        {
            if (this.errorDialog == null || this.errorDialog.IsEmpty)
            {
                MessageBox.Show (this, message, header, MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                this.errorDialog.ShowDialog (this);
            }
        }

        private bool NetUse ()
        {
            if (this.topology.IsConnected)
            {
                return true;
            }
            else
            {
                UserPassDialog dialog = new UserPassDialog ();
                if (dialog.ShowDialog (this) == DialogResult.OK)
                {
                    Application.DoEvents ();
                    this.topology.ConnectMachines (dialog.Username, dialog.Password);
                    if (this.errorDialog.IsEmpty)
                    {
                        return true;
                    }
                    else
                    {
                        this.errorDialog.ShowDialog (this);
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
        }

        #endregion
		
        #region Methods for Performing Commands

        private new void Load ()
        {
            Begin ();
            OpenFileDialog open = new OpenFileDialog ();
            open.RestoreDirectory = true;
            open.DefaultExt = "xml";
            open.Filter = "XML Files (*.xml)|*.xml|All Files (*.*)|*.*";
            open.Title = "Open an XML Topology File";
            if (open.ShowDialog (this) == DialogResult.OK)
            {
                try
                {
                    this.topology = new Topology (new FileInfo (open.FileName));
                    this.errorDialog = new ErrorsDialog (this.topology);
                    this.progressDialog = new ProgressDialog (this.topology, this);
                    this.CurrentTopologyPanel.Text = "Current Topology: " + this.topology.ConfigFile.Name;
                }
                catch (Exception e)
                {
                    ErrorBox (this, e);
                }
            }
            End ();
        }

        private void Deploy ()
        {
            Begin ();
            try
            {
                if (NetUse ())
                {
                    CounterCollectionOptionsDialog dialog = new CounterCollectionOptionsDialog ();
                    if (dialog.ShowDialog (this) == DialogResult.OK)
                    {
                        this.topology.DeleteAndDeployCounters (dialog.Interval, dialog.LogFormat);
                        string header = "All Counters Created Successfully";
                        string success = "The counters were created successfully on all "
                            + this.topology.Machines.Count + " machine(s) in the topology.";
                        ShowResults (header, success);
                    }
                }
            }
            catch (Exception exception)
            {
                ErrorBox (this, exception);
            }
            finally
            {
                End ();
            }
        }

        private void UpdateInterval ()
        {
            Begin ();

            try
            {
                if (NetUse ())
                {
                    IntervalDialog dialog = new IntervalDialog ();
                    if (dialog.ShowDialog (this) == DialogResult.OK)
                    {
                        this.topology.UpdateCounterInterval (dialog.Interval);
                        string header = "All Counter Intervals Updated Successfully";
                        string success = "The counter intervals were successfully changed on all "
                            + this.topology.Machines.Count + " machine(s) in the topology.";
                        ShowResults (header, success);
                    }
                }
            }
            catch (Exception exception)
            {
                ErrorBox (this, exception);
            }
            finally
            {
                End ();
            }
        }

        private void Start ()
        {
            Begin ();

            try
            {
                if (NetUse ())
                {
                    this.topology.StartCounters ();
                    string header = "All Counters Started Successfully";
                    string success = "The counters were successfully started on all "
                        + this.topology.Machines.Count + " machine(s) in the topology.";
                    ShowResults (header, success);
                }
            }
            catch (Exception exception)
            {
                ErrorBox (this, exception);
            }
            finally
            {
                End ();
            }
        }

        private void Stop ()
        {
            Begin ();

            try
            {
                if (NetUse ())
                {
                    this.topology.StopCounters ();
                    string header = "All Counters Stopped Successfully";
                    string success = "The counters were stopped successfully on all "
                        + this.topology.Machines.Count + " machine(s) in the topology.";
                    ShowResults (header, success);
                }
            }
            catch (Exception exception)
            {
                ErrorBox (this, exception);
            }
            finally
            {
                End ();
            }
        }

        private void Delete ()
        {
            Begin ();
            try
            {
                if (NetUse ())
                {
                    this.topology.DeleteCounterLogs ();

                    string message = "The counter logs have been deleted from the "
                        + this.topology.Machines.Count + " machine(s) in this topology.";
                    string caption = "All Counters Deleted Successfully";
                    ShowResults (caption, message);
                }
            }
            catch (Exception exception)
            {
                ErrorBox (this, exception);
            }
            finally
            {
                End ();
            }
        }

        private void Archive ()
        {
            Begin ();
            try
            {
                if (NetUse ())
                {
                    SaveFileDialog dialog = new SaveFileDialog ();
                    dialog.Title = "Where would you like to place the Counter Logs?";
                    dialog.FileName = "Filename Will Be Ignored.";
                    dialog.ValidateNames = false;
                    if (dialog.ShowDialog (this) == DialogResult.OK)
                    {
                        DirectoryInfo directory = new DirectoryInfo (dialog.FileName);
                        if (!directory.Exists)
                        {
                            directory = directory.Parent;
                        }
                        Application.DoEvents ();
                        this.topology.ArchiveCounterLogs (directory);

                        string message = "The counter logs from the "
                            + this.topology.Machines.Count
                            + " machine(s) in this topology have been archived.";
                        string caption = "All Counters Archived Successfully";
                        ShowResults (caption, message);
                    }
                }
            }
            catch (Exception exception)
            {
                ErrorBox (this, exception);
            }
            finally
            {
                End ();
            }
        }

        #endregion
		
        #region Button Event Handlers

        private void LoadButton_Click(object sender, System.EventArgs e)
        {
            Load ();
        }

        private void DeployButton_Click(object sender, System.EventArgs e)
        {
            Deploy ();
        }

        private void UpdateButton_Click(object sender, System.EventArgs e)
        {
            UpdateInterval ();
        }

        private void StartButton_Click(object sender, System.EventArgs e)
        {
            Start ();
        }

        private void StopButton_Click(object sender, System.EventArgs e)
        {
            Stop ();
        }

        private void ExitButton_Click(object sender, System.EventArgs e)
        {
            Close ();
        }

        private void DeleteButton_Click(object sender, System.EventArgs e)
        {
            Delete ();
        }

        private void ArchiveButton_Click(object sender, System.EventArgs e)
        {
            Archive ();
        }

        #endregion

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.LoadButton = new System.Windows.Forms.Button();
            this.DeployButton = new System.Windows.Forms.Button();
            this.StartButton = new System.Windows.Forms.Button();
            this.StopButton = new System.Windows.Forms.Button();
            this.HeadingLabel = new System.Windows.Forms.Label();
            this.StatusBar = new System.Windows.Forms.StatusBar();
            this.CurrentTopologyPanel = new System.Windows.Forms.StatusBarPanel();
            this.UpdateButton = new System.Windows.Forms.Button();
            this.ExitButton = new System.Windows.Forms.Button();
            this.DeleteButton = new System.Windows.Forms.Button();
            this.ArchiveButton = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.CurrentTopologyPanel)).BeginInit();
            this.SuspendLayout();
            // 
            // LoadButton
            // 
            this.LoadButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.LoadButton.Location = new System.Drawing.Point(17, 80);
            this.LoadButton.Name = "LoadButton";
            this.LoadButton.Size = new System.Drawing.Size(200, 30);
            this.LoadButton.TabIndex = 1;
            this.LoadButton.Text = "&Load Topology";
            this.LoadButton.Click += new System.EventHandler(this.LoadButton_Click);
            // 
            // DeployButton
            // 
            this.DeployButton.Enabled = false;
            this.DeployButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.DeployButton.Location = new System.Drawing.Point(17, 128);
            this.DeployButton.Name = "DeployButton";
            this.DeployButton.Size = new System.Drawing.Size(200, 30);
            this.DeployButton.TabIndex = 2;
            this.DeployButton.Text = "&Deploy Counters";
            this.DeployButton.Click += new System.EventHandler(this.DeployButton_Click);
            // 
            // StartButton
            // 
            this.StartButton.Enabled = false;
            this.StartButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.StartButton.Location = new System.Drawing.Point(17, 224);
            this.StartButton.Name = "StartButton";
            this.StartButton.Size = new System.Drawing.Size(200, 30);
            this.StartButton.TabIndex = 4;
            this.StartButton.Text = "&Start Counters";
            this.StartButton.Click += new System.EventHandler(this.StartButton_Click);
            // 
            // StopButton
            // 
            this.StopButton.Enabled = false;
            this.StopButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.StopButton.Location = new System.Drawing.Point(17, 272);
            this.StopButton.Name = "StopButton";
            this.StopButton.Size = new System.Drawing.Size(200, 30);
            this.StopButton.TabIndex = 5;
            this.StopButton.Text = "Sto&p Counters";
            this.StopButton.Click += new System.EventHandler(this.StopButton_Click);
            // 
            // HeadingLabel
            // 
            this.HeadingLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 12.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.HeadingLabel.Location = new System.Drawing.Point(17, 16);
            this.HeadingLabel.Name = "HeadingLabel";
            this.HeadingLabel.Size = new System.Drawing.Size(200, 40);
            this.HeadingLabel.TabIndex = 0;
            this.HeadingLabel.Text = "Performance Counter Pushing Tool";
            this.HeadingLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // StatusBar
            // 
            this.StatusBar.Location = new System.Drawing.Point(0, 466);
            this.StatusBar.Name = "StatusBar";
            this.StatusBar.Panels.AddRange(new System.Windows.Forms.StatusBarPanel[] {
                                                                                         this.CurrentTopologyPanel});
            this.StatusBar.ShowPanels = true;
            this.StatusBar.Size = new System.Drawing.Size(234, 22);
            this.StatusBar.SizingGrip = false;
            this.StatusBar.TabIndex = 9;
            // 
            // CurrentTopologyPanel
            // 
            this.CurrentTopologyPanel.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Spring;
            this.CurrentTopologyPanel.Text = "Current Topology: None";
            this.CurrentTopologyPanel.Width = 234;
            // 
            // UpdateButton
            // 
            this.UpdateButton.Enabled = false;
            this.UpdateButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.UpdateButton.Location = new System.Drawing.Point(17, 176);
            this.UpdateButton.Name = "UpdateButton";
            this.UpdateButton.Size = new System.Drawing.Size(200, 30);
            this.UpdateButton.TabIndex = 3;
            this.UpdateButton.Text = "&Update Counter Interval";
            this.UpdateButton.Click += new System.EventHandler(this.UpdateButton_Click);
            // 
            // ExitButton
            // 
            this.ExitButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.ExitButton.Location = new System.Drawing.Point(18, 416);
            this.ExitButton.Name = "ExitButton";
            this.ExitButton.Size = new System.Drawing.Size(200, 30);
            this.ExitButton.TabIndex = 8;
            this.ExitButton.Text = "E&xit PCPT";
            this.ExitButton.Click += new System.EventHandler(this.ExitButton_Click);
            // 
            // DeleteButton
            // 
            this.DeleteButton.Enabled = false;
            this.DeleteButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.DeleteButton.Location = new System.Drawing.Point(18, 320);
            this.DeleteButton.Name = "DeleteButton";
            this.DeleteButton.Size = new System.Drawing.Size(200, 30);
            this.DeleteButton.TabIndex = 6;
            this.DeleteButton.Text = "D&elete Counter Logs";
            this.DeleteButton.Click += new System.EventHandler(this.DeleteButton_Click);
            // 
            // ArchiveButton
            // 
            this.ArchiveButton.Enabled = false;
            this.ArchiveButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.ArchiveButton.Location = new System.Drawing.Point(18, 368);
            this.ArchiveButton.Name = "ArchiveButton";
            this.ArchiveButton.Size = new System.Drawing.Size(200, 30);
            this.ArchiveButton.TabIndex = 7;
            this.ArchiveButton.Text = "&Archive Counter Logs";
            this.ArchiveButton.Click += new System.EventHandler(this.ArchiveButton_Click);
            // 
            // MainForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(234, 488);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this.ArchiveButton,
                                                                          this.DeleteButton,
                                                                          this.ExitButton,
                                                                          this.StatusBar,
                                                                          this.HeadingLabel,
                                                                          this.StopButton,
                                                                          this.StartButton,
                                                                          this.DeployButton,
                                                                          this.LoadButton,
                                                                          this.UpdateButton});
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.Fixed3D;
            this.MaximizeBox = false;
            this.Name = "MainForm";
            this.Text = "PCPT";
            ((System.ComponentModel.ISupportInitialize)(this.CurrentTopologyPanel)).EndInit();
            this.ResumeLayout(false);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\Counter.cs ===
namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// This class represents a single counter object.
	/// </summary>
	public class Counter
	{
		/// <summary>
		/// The private member variable that contains the text of this counter.
		/// </summary>
		private string text;

		/// <summary>
		/// Constructor: Specifies the text of the Counter.
		/// </summary>
		/// <param name="text">The text of this particular counter.</param>
		public Counter (string text)
		{
			this.text = text;
		}

		/// <summary>
		/// Gets the text of this counter.
		/// </summary>
		public string Text
		{
			get
			{
				return this.text;
			}
			set
			{
				this.text = value;
			}
		}

		/// <summary>
		/// Determines if this Counter is equal to another object.
		/// </summary>
		/// <param name="obj">The object to be compared to this one.</param>
		/// <returns>
		/// True if the object represents the same logical counter, False if
		/// not.  Two Counter objects represent the same logical counter if
		/// their texts are the same, excluding case and leading and trailing
		/// whitespace.
		/// </returns>
		public override bool Equals(object obj)
		{
			if (obj is Counter)
			{
				Counter c = obj as Counter;
				return (c.Text.ToUpper ().Trim () == this.Text.ToUpper ().Trim ());
			}
			else
				return false;
		}

		/// <summary>
		/// Determines the hash code for this Counter object.  The hash code
		/// for a Counter object is the same as the hash code for the text
		/// that represents the counter.
		/// </summary>
		/// <returns>The hash code for this Counter object.</returns>
		public override int GetHashCode()
		{
			return this.text.GetHashCode ();
		}

		/// <summary>
		/// Determines the textual representation of this Counter object.
		/// </summary>
		/// <returns>The textual representation of this Counter.</returns>
		public override string ToString()
		{
			return this.text;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\CounterCollection.cs ===
using System;
using System.IO;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// A CounterCollection is a set of Counters that run together.  A
	/// CounterCollection is a named CounterList.
	/// </summary>
	public class CounterCollection : CounterList
	{
		#region Member Variables

		/// <summary>
		/// The name of this CounterCollection.
		/// </summary>
        private string name;

		#endregion

		#region Constructors

		/// <summary>
		/// Constructor: Specifies both a name for this CounterCollection, and
		/// the location of the CounterList file.
		/// </summary>
		/// <param name="name">The name for this CounterCollection.</param>
		/// <param name="file">The location of the CounterList file.</param>
		public CounterCollection (string name, FileInfo file)
			: base (file)
		{
			this.name = name;
		}

		/// <summary>
		/// Constructor: Specifies both a name for this CounterCollection, and
		/// the location of the CounterList file.
		/// </summary>
		/// <param name="name">The name for this CounterCollection.</param>
		/// <param name="path">The path to the CounterList file.</param>
		public CounterCollection (string name, string path)
			: base (path)
		{
			this.name = name;
		}

		/// <summary>
		/// Constructor: Specifies both a name for this CounterCollection, and
		/// the location of the CounterList file.
		/// </summary>
		/// <param name="name">The name for this CounterCollection.</param>
		/// <param name="directory">The directory of the CounterList file.</param>
		/// <param name="path">The name of the CounterListfile.</param>
		public CounterCollection (string name, DirectoryInfo directory, string filename)
			: base (directory, filename)
		{
			this.name = name;
		}

		/// <summary>
		/// Constructor: Specifies a name for this CounterCollection, but does
		/// not specify any information about a CounterList file.
		/// CounterCollections created using this constructor cannot be written
		/// or read from file.
		/// </summary>
		/// <param name="name"></param>
		public CounterCollection (string name)
		{
			this.name = name;
		}

		#endregion
		
		#region Public Properties

		/// <summary>
		/// Gets the name of this CounterCollection.
		/// </summary>
		public string Name
		{
			get
			{
				return this.name;
			}
		}

		#endregion
		
		#region Overridden Methods

		public override bool Equals (object obj)
		{
			if (obj is CounterCollection)
			{
				CounterCollection other = obj as CounterCollection;
				return (other.Name.ToUpper () == this.Name.ToUpper ());
			}
			else
				return false;
		}

		public override int GetHashCode ()
		{
			return this.Name.GetHashCode ();;
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\Component.cs ===
using System.Collections;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// This class represents a Component that can be installed on a machine,
	/// for which performance counters can be set up.
	/// </summary>
	public class Component
	{
		#region Member Variables

		/// <summary>
		/// The name of this Component.
		/// </summary>
		private string name;

		/// <summary>
		/// The default CounterCollection for this Component.
		/// </summary>
		private CounterCollection defaultCollection;

		/// <summary>
		/// Additional CounterCollections for this Component.
		/// </summary>
		private Hashtable additionalCollections;

		#endregion

		#region Constructors

		/// <summary>
		/// Constructor: Specifies a name for this Component.
		/// </summary>
		/// <param name="name">The name for this Component.</param>
		public Component (string name)
		{
			this.name = name;
			this.defaultCollection = new CounterCollection (name);
			this.additionalCollections = new Hashtable ();
		}

		#endregion
		
		#region Properties

		/// <summary>
		/// Gets or Sets the name of this Component.
		/// </summary>
		public string Name
		{
			get
			{
				return this.name;
			}
		}

		/// <summary>
		/// Gets the default CounterCollection for this Component.
		/// </summary>
		public CounterCollection DefaultCollection
		{
			get
			{
				return this.defaultCollection;
			}
		}

		/// <summary>
		/// Gets a list of additional CounterCollections for this Component.
		/// </summary>
		public ICollection AdditionalCollections
		{
			get
			{
				return this.additionalCollections.Values;
			}
		}

		#endregion

		#region Add/Remove Methods

		/// <summary>
		/// Adds an additional CounterCollection to this Component.
		/// </summary>
		/// <param name="collection">The CounterCollection to add.</param>
		public void AddCounterCollection (CounterCollection collection)
		{
			if (!this.additionalCollections.Contains (collection.Name))
			{
				this.additionalCollections.Add (collection.Name, collection);
			}
		}

		/// <summary>
		/// Removes an additional CounterCollection from this Component.  This
		/// method cannot be used to remove the default CounterCollection.
		/// </summary>
		/// <param name="collection">The CounterCollection to remove.</param>
		public void RemoveCounterCollection (CounterCollection collection)
		{
			this.additionalCollections.Remove (collection.Name);
		}

		/// <summary>
		/// Adds a CounterList to the default CounterCollection for this
		/// Component.
		/// </summary>
		/// <param name="list">The CounterList to add.</param>
		public void AddCounterList (CounterList list)
		{
			this.defaultCollection.AddCounterList (list);
		}

		/// <summary>
		/// Removes (excludes) a CounterList from the default CounterCollection
		/// for this Component.
		/// </summary>
		/// <param name="list">The CounterList to remove (exclude).</param>
		public void RemoveCounterList (CounterList list)
		{
			this.defaultCollection.RemoveCounterList (list);
		}

		#endregion

		#region Overridden Methods

		public override bool Equals (object obj)
		{
			if (obj is Component)
			{
				Component other = obj as Component;
				return (other.Name == this.Name);
			}
			else
				return false;
		}

		public override int GetHashCode()
		{
			return this.Name.GetHashCode ();
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("PCPT Model")]
[assembly: AssemblyDescription("The Model for the PCPT applications")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers
// by using the '*' as shown below:


//
// In order to sign your assembly you must specify a key to use. Refer to the
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing.
//
// Notes:
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\ErrorEventArgs.cs ===
using System;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// This class is a wrapper for the set of arguments associated with
	/// Error events.  An Error event indicates that some error occurred while
	/// working with the topology.
	/// </summary>
	public class ErrorEventArgs : EventArgs
	{
		#region Member Variables

		/// <summary>
		/// The name of the machine on which the error occurred.
		/// </summary>
		private string machine;

		/// <summary>The text of the error message.</summary>
		private string message;

		#endregion

		#region Constructors

		/// <summary>Creates a new ErrorEventArgs object.</summary>
		/// <param name="message">
		/// The error message.  The message will be formatted so that there are
		/// no blank lines in it and it ends with the newline character.
		/// </param>
		/// <param name="machine">The machine on which the error occurred.</param>
		public ErrorEventArgs (string message, string machine)
		{
			this.machine = machine;
			this.message = message.Trim ();

			string doubleNewLine = Environment.NewLine + Environment.NewLine;
			while (this.message.IndexOf (doubleNewLine) != -1)
			{
				this.message = this.message.Replace (doubleNewLine, Environment.NewLine);
			}

			if (!this.message.EndsWith (Environment.NewLine))
			{
				this.message += Environment.NewLine;
			}
		}

		#endregion
		
		#region Properties

		/// <summary>
		/// Gets the message associated with this Error event.
		/// </summary>
		public string Message
		{
			get
			{
				return this.message;
			}
		}

		/// <summary>
		/// Gets the name of the machine on which the associated Error event
		/// occurred.
		/// </summary>
		public string Machine
		{
			get
			{
				return this.machine;
			}
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\CounterList.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// This class represents a file that contains several couunters.  This
	/// class supports both reading such a file from disk, and writing such
	/// a file to disk.
	/// </summary>
	public class CounterList
	{
		#region Member Variables

		/// <summary>
		/// A list of the counters in this CounterList.</summary>
		private SortedList counters;

		/// <summary>
		/// The location of this CounterList file on disk.
		/// </summary>
		private FileInfo file;

		/// <summary>
		/// Whether the information in this object is 'dirty' or not (whether
		/// or not it is in synch with the file that is stored on disk).
		/// </summary>
		private bool dirty;

		#endregion

		#region Constructors

		/// <summary>
		/// Default Constructor.
		/// </summary>
		public CounterList ()
		{
			this.counters = new SortedList (CaseInsensitiveComparer.Default);
			this.dirty = false;
		}

		/// <summary>
		/// Constructor: The list of counters will initially be empty.
		/// </summary>
		/// <param name="file">The location of the CounterList file.</param>
		public CounterList (FileInfo file)
			: this ()
		{
			this.file = file;
		}

		/// <summary>
		/// Constructor: The list of counters will initially be empty.
		/// </summary>
		/// <param name="path">The path to the CounterList file.</param>
		public CounterList (string path)
			: this ()
		{
			file = new FileInfo (path);
		}

		/// <summary>
		/// Constructor: The list of counters will initially be empty.
		/// </summary>
		/// <param name="directory">The directory of the CounterList file.</param>
		/// <param name="path">The name of the CounterListfile.</param>
		public CounterList (DirectoryInfo directory, string filename)
			: this ()
		{
			string fullname = directory.FullName;
			if (!fullname.EndsWith ("\\"))
				fullname += "\\";
			fullname += filename;
			file = new FileInfo (fullname);
		}

		#endregion
		
		#region Properties

		/// <summary>
		/// Gets or sets the file associated with this CounterList.  If this
		/// Property is set to, then the CounterList will be marked as dirty.
		/// </summary>
		public FileInfo File
		{
			get
			{
				return this.file;
			}
			set
			{
				this.file = value;
				this.dirty = true;
			}
		}

		/// <summary>
		/// Gets a collection of the counters in this CounterList.
		/// </summary>
		public ICollection Counters
		{
			get
			{
				return this.counters.Values;
			}
		}

		/// <summary>
		/// Gets whether or not this CounterList is 'dirty'.  If the
		/// information is out of synch with what is stored on disk, then
		/// this CounterList is considered'dirty'.  If the information is in
		/// synch, then it is not considered 'dirty'.
		/// </summary>
		public bool Dirty
		{
			get
			{
				return this.dirty;
			}
		}

		/// <summary>
		/// Gets whether or not this CounterList contains any Counters.
		/// </summary>
		public bool Empty
		{
			get
			{
				return (this.counters.Count == 0);
			}
		}

		#endregion
		
		#region Add/Remove Methods

		/// <summary>
		/// Adds a counter to this CounterList.  The file is not written to
		/// disk.  The CounterList will be marked as dirty if any changes
		/// occur.
		/// </summary>
		/// <param name="counter">The counter to add.</param>
		public void AddCounter (Counter counter)
		{
            if (!this.counters.Contains(counter.Text))
			{
                // check whether it contains the general counter
                bool addCounter = true;
                                
                // general counter: e.g. \PhysicalDisk(*)\* for  \PhysicalDisk(*)\% Disk Read Time 
                int ind = counter.Text.IndexOf('(');                 
                if (ind != -1)
                {
                    string counterGeneral = counter.Text.Substring(0, ind) + "(*)\\*";

                    if (this.counters.Contains(counterGeneral))
                    {
                        addCounter = false;
                    }
                }

                // general counter: e.g. \PhysicalDisk\* for  \PhysicalDisk\Available Kbyte
                ind = counter.Text.IndexOf('\\', 1); // find the second '\'
                if (addCounter && ind != -1)
                {
                    string counterGeneral = counter.Text.Substring(0, ind) + "\\*";

                    if (this.counters.Contains(counterGeneral))
                    {
                        addCounter = false;
                    }
                }

                if (addCounter)
                {
                    this.counters.Add(counter.Text, counter);
                    this.dirty = true;
                }
			}
		}

		/// <summary>
		/// Removes a counter from this file.  The file is not written to disk.
		/// The CounterList will be marked as dirty if any changes occur.
		/// </summary>
		/// <param name="counter">The counter to be removed.</param>
		public void RemoveCounter (Counter counter)
		{
			this.counters.Remove (counter.Text);
			this.dirty = true;
		}

		/// <summary>
		/// Adds (unions) a new CounterList to this CounterList.  This
		/// marks the CounterList as being dirty if necessary.
		/// </summary>
		/// <param name="list">The CounterList to add.</param>
		public void AddCounterList (CounterList list)
		{
			foreach (Counter counter in list.Counters)
			{
				AddCounter (counter);
			}
		}

		/// <summary>
		/// Removes a CounterList from this CounterList.  This will
		/// exclude all counters in the list, even if they were also added
		/// from another CounterList as well.  This will mark the
		/// CounterList as dirty if any changes occur.
		/// </summary>
		/// <param name="list">The CounterList to remove.</param>
		public void RemoveCounterList (CounterList list)
		{
			foreach (Counter counter in list.Counters)
			{
				RemoveCounter (counter);
			}
		}

		#endregion
		
		#region Read/Write Methods

		/// <summary>
		/// Clears the current list of counters, and reads a list from the
		/// file referenced by this object.  If the filename specified does
		/// not exist, then this method will do throw an exception.  The
		/// CounterList will be marked as not dirty.  If the file specified
		/// cannot be found or read from, then this method will throw an
		/// Exception.
		/// </summary>
		public void ReadFromFile ()
		{
			if (this.file == null)
			{
				throw new Exception ("No CounterList file was specified from which to read.");
			}
			else if (this.file.Exists)
			{
				this.counters.Clear ();
				using (StreamReader stream = this.file.OpenText ())
				{
					while (stream.Peek () > -1)
					{
						string line = stream.ReadLine ();
						AddCounter (new Counter (line));
					}
					this.dirty = false;
				}
			}
			else
			{
				string message = "The specified Counter File did not exist.";
				message += Environment.NewLine;
				message += this.file.FullName;
				throw new Exception (message);
			}
		}

		/// <summary>
		/// Writes the current list of counters to file.  If the file specified
		/// already exists, then it will be overwritten.  The CounterList will
		/// be marked as not dirty.
		/// </summary>
		public void WriteToFile ()
		{
			if (this.file == null)
			{
				throw new Exception ("No CounterList file was specified to write to.");
			}
			else
			{
				using (StreamWriter stream = this.file.CreateText ())
				{
					foreach (Counter c in this.Counters)
					{
						stream.WriteLine (c.Text);
					}
					stream.Flush ();
					stream.Close ();
					this.dirty = false;
				}
			}
		}

        /// <summary>
        /// Writes the current list of counters to file. The machine name will 
        /// be prepended to the counter name. If the file specified already exists, 
        /// then it will be overwritten.  The CounterList will be marked as not dirty.
        /// </summary>
        public void WriteToFile(string machineName)
        {
            if (this.file == null)
            {
                throw new Exception("No CounterList file was specified to write to.");
            }
            else
            {
                StringBuilder sb = new StringBuilder(75);
                sb.Append ("\\\\");
                sb.Append (machineName);

                using (StreamWriter stream = this.file.CreateText())
                {
                    foreach (Counter c in this.Counters)
                    {
                        stream.WriteLine(sb.ToString () + c.Text);
                    }
                    stream.Flush();
                    stream.Close();
                    this.dirty = false;
                }
            }
        }

		#endregion
		
		#region Static Read Methods

		/// <summary>
		/// Static method for reading a CounterList from disk.  If the
		/// specified file does not exist or cannot be read from, then an
		/// Exception will be thrown.
		/// </summary>
		/// <param name="file">The location of the CounterList file.</param>
		/// <returns>
		/// The CounterList, after the list of counters has been read.
		/// </returns>
		public static CounterList Read (FileInfo file)
		{
			CounterList list = new CounterList (file);
			list.ReadFromFile ();
			return list;
		}

		/// <summary>
		/// Static method for reading a CounterList from disk.  If the
		/// specified file does not exist or cannot be read from, then an
		/// exception will be thrown.
		/// </summary>
		/// <param name="path">The path to the CounterList file.</param>
		/// <returns>
		/// The CounterList, after the list of counters has been read.
		/// </returns>
		public static CounterList Read (string path)
		{
			CounterList list = new CounterList (path);
			list.ReadFromFile ();
			return list;
		}

		/// <summary>
		/// Static method for reading a CounterList from disk.  If the
		/// specified file does not exist or cannot be read from, then an
		/// exception will be thrown.
		/// </summary>
		/// <param name="directory">
		/// The directory where the CounterList file is located.
		/// </param>
		/// <param name="filename">The name of the CounterList file.</param>
		/// <returns>
		/// The CounterList, after the list of counters has been read.
		/// </returns>
		public static CounterList Read (DirectoryInfo directory, string path)
		{
			CounterList list = new CounterList (directory, path);
			list.ReadFromFile ();
			return list;
		}

		#endregion
		
		#region Static Write Methods

		/// <summary>
		/// Static method for writing a CounterList to disk.
		/// </summary>
		/// <param name="file">
		/// The location that the CounterList file should be saved to.  If
		/// there is already a file at this location, it will be overwritten.
		/// </param>
		/// <param name="counters">
		/// An enumeration of the counters to write.
		/// </param>
		/// <returns>
		/// The CounterList, after it has been written to file.
		/// </returns>
		public static CounterList Write (FileInfo file, IEnumerable counters)
		{
			CounterList list = new CounterList (file);
			foreach (Counter c in counters)
			{
				list.AddCounter (c);
			}
			list.WriteToFile ();
			return list;
		}

		/// <summary>
		/// Static method for writing a CounterList to disk.
		/// </summary>
		/// <param name="path">
		/// The path that the CounterList file should be saved to.  If
		/// there is already a file at this location, it will be overwritten.
		/// </param>
		/// <param name="counters">
		/// An enumeration of the counters to write.
		/// </param>
		/// <returns>
		/// The CounterList, after it has been written to file.
		/// </returns>
		public static CounterList Write (string path, IEnumerable counters)
		{
			CounterList list = new CounterList (path);
			foreach (Counter c in counters)
			{
				list.AddCounter (c);
			}
			list.WriteToFile ();
			return list;
		}

		/// <summary>
		/// Static method for writing a CounterList to disk.
		/// </summary>
		/// <param name="directory">
		/// The directory where the CounterList file should be placed.  If
		/// this directory does not exist, it will be created.
		/// </param>
		/// <param name="filename">
		/// The name that the CounterList file should be saved as.  If there is
		/// already a file at this location, it will be overwritten.
		/// </param>
		/// <param name="counters">
		/// An enumeration of the counters to write.
		/// </param>
		/// <returns>
		/// The CounterList, after it has been written to file.
		/// </returns>
		public static CounterList Write (DirectoryInfo directory, string filename, IEnumerable counters)
		{
			CounterList list = new CounterList (directory, filename);
			foreach (Counter c in counters)
			{
				list.AddCounter (c);
			}
			list.WriteToFile ();
			return list;
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\ProgressEventArgs.cs ===
using System;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// This class is a wrapper for the set of arguments associated with
	/// Progress events.  A Progress event indicates that some amount of
	/// progress has been made on some particular action.
	/// </summary>
	public class ProgressEventArgs : EventArgs
	{
		#region Member Variables

		/// <summary>The minimum value for this progress event.</summary>
		private int minimum;

		/// <summary>The maximum value for this progress event.</summary>
		private int maximum;

		/// <summary>The current value of this progress event.</summary>
		private int current;

		/// <summary>
		/// The message associated with this event.  This is typically used to
		/// indicate what action progress has been made on.
		/// </summary>
		private string message;

		#endregion
		
		#region Constructors

		/// <summary>
		/// Default Constructor.  Creates a new ProgressEventArgs object, with
		/// a minimum value of 0, a maximum value of 100, and a starting value
		/// of 0.
		/// </summary>
		public ProgressEventArgs () : this (0, 100, 0) {}

		/// <summary>
		/// Constructor.  Creates a new ProgressEventArgs object, with the
		/// specified minimum and maximum values, and a starting value of 0.
		/// </summary>
		/// <param name="min">The minimum value.</param>
		/// <param name="max">The maximum value.</param>
		public ProgressEventArgs (int min, int max) : this (min, max, 0) {}

		/// <summary>
		/// Constructor.  Creates a new ProgressEventArgs object, with the
		/// specified minimum, maximum, and starting values.
		/// </summary>
		/// <param name="min">The minimum value.</param>
		/// <param name="max">The maximum value.</param>
		/// <param name="start">The starting value.</param>
		public ProgressEventArgs (int min, int max, int start)
		{
			this.minimum = min;
			this.maximum = max;
			this.current = start;
		}

		/// <summary>
		/// Constructor.  Creates a new ProgressEventArgs object, with the
		/// specified minimum, maximum, and starting values, and specifies the
		/// message for this Progress event as well.
		/// </summary>
		/// <param name="min">The minimum value.</param>
		/// <param name="max">The maximum value.</param>
		/// <param name="start">The starting value.</param>
		/// <param name="message">The message for this Progress event.</param>
		public ProgressEventArgs (int min, int max, int start, string message)
			: this (min, max, start)
		{
			this.Message = message;
		}

		#endregion
		
		#region Properties

		/// <summary>
		/// Gets or sets the message associated with this Progress event.
		/// </summary>
		public string Message
		{
			get
			{
				return this.message;
			}
			set
			{
				this.message = value;
			}
		}

		/// <summary>
		/// Gets or sets the current value for this Progress event.
		/// </summary>
		public int CurrentValue
		{
			get
			{
				return this.current;
			}
			set
			{
				this.current = value;
				if (this.current < MinimumValue)
				{
					this.current = MinimumValue;
				}
				else if (this.current > MaximumValue)
				{
					this.current = MaximumValue;
				}
			}
		}

		/// <summary>Gets the minimum value for this Progress event.</summary>
		public int MinimumValue
		{
			get
			{
				return this.minimum;
			}
		}

		/// <summary>Gets the maximum value for this Progress event.</summary>
		public int MaximumValue
		{
			get
			{
				return this.maximum;
			}
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\Machine.cs ===
using System.Collections;
using System.IO;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
	/// <summary>
	/// This class represents a specific machine in the topology.  This
	/// machine will be associated with any number of components, which will
	/// in turn be associated with any number of counter lists.  These counter
	/// lists will be unioned together to come up with a single counter list
	/// for this machine.  The counter list file for this Machine will only
	/// be created when the WriteToFile method is called.
	/// </summary>
	public class Machine
	{
		#region Member Variables

		/// <summary>
		/// The name of this Machine.
		/// </summary>
		private string name;
		
		/// <summary>
		/// The CounterCollections for this Machine.
		/// </summary>
		private SortedList collections;

		/// <summary>
		/// The default CounterCollection for this Machine.
		/// </summary>
		private CounterCollection defaultCollection;

		/// <summary>
		/// The directory where generated CounterList files will be placed.
		/// </summary>
		private DirectoryInfo directory;

		#endregion
		
		#region Constructors

		/// <summary>
		/// Constructor: Creates a new Machine object, with the specified name.
		/// This also specifies a name for the default collection on this
		/// Machine, as well as a directory in which to place the generated
		/// CounterList files.
		/// </summary>
		/// <param name="machineName">The name for this Machine.</param>
		/// <param name="collectionName">
		/// The name for this Machine's default CounterCollection.
		/// </param>
		/// <param name="directory">
		/// The directory in which to place the CounterList files for this
		/// Machine.
		/// </param>
		public Machine (string machineName, string collectionName, DirectoryInfo directory)
		{
			this.collections = new SortedList (CaseInsensitiveComparer.Default);
			this.name = machineName;
			this.directory = directory;
			this.defaultCollection = new CounterCollection (collectionName, directory, machineName + ".txt");
			this.collections.Add (this.defaultCollection.Name, this.defaultCollection);
		}

		#endregion
		
		#region Public Properties

		/// <summary>
		/// Gets the name for this Machine.
		/// </summary>
		public string Name
		{
			get
			{
				return this.name;
			}
		}

		/// <summary>
		/// Gets a list of all the CounterCollections on this Machine.  This
		/// list will include the default CounterCollection.
		/// </summary>
		public ICollection CounterCollections
		{
			get
			{
				return this.collections.Values;
			}
		}

		/// <summary>
		/// Gets the default CounterCollection for this Machine.
		/// </summary>
		public CounterCollection DefaultCollection
		{
			get
			{
				return this.defaultCollection;
			}
		}

		/// <summary>
		/// Gets a value that indicates whether or not this Machine contains
		/// any non-empty counter-collections. In other words, this indicates
		/// if there is anything for the PCPT to do for this Machine.
		/// </summary>
		public bool IsEmpty
		{
			get
			{
				bool empty = this.defaultCollection.Empty;
				if (empty)
				{
					foreach (CounterCollection collection in this.collections.Values)
					{
						if (!collection.Empty)
						{
							empty = false;
							break;
						}
					}
				}

				return empty;
			}
		}

		#endregion
		
		#region Overridden Methods

		public override bool Equals(object obj)
		{
			if (obj is Machine)
			{
				Machine other = obj as Machine;
				return (other.Name.ToUpper () == this.Name.ToUpper ());
			}
			else return false;
		}

		public override int GetHashCode ()
		{
			return this.Name.GetHashCode ();
		}

		#endregion
		
		#region Add/Remove Methods

		/// <summary>
		/// Adds a new Component to this Machine.  The CounterCollections
		/// associated with this Component will now be included on this
		/// Machine.
		/// </summary>
		/// <param name="component">The Component to be added.</param>
		public void AddComponent (Component component)
		{
			this.defaultCollection.AddCounterList (component.DefaultCollection);
			foreach (CounterCollection source in component.AdditionalCollections)
			{
				if (!this.collections.Contains (source.Name))
				{
					string filename = this.Name + "_" + source.Name + ".txt";
					this.collections.Add (source.Name, new CounterCollection (source.Name, this.directory, filename));
				}
				CounterCollection collection = this.collections [source.Name] as CounterCollection;
				collection.AddCounterList (source);
			}
		}

		/// <summary>
		/// Removes (excludes) a Component from this Machine.  The
		/// CounterCollections associated with this Component will no longer be
		/// included on this Machine.
		/// </summary>
		/// <param name="component">The Component to be removed (excluded).</param>
		public void RemoveComponent (Component component)
		{
			this.defaultCollection.RemoveCounterList (component.DefaultCollection);
			foreach (CounterCollection source in component.AdditionalCollections)
			{
				if (this.collections.Contains (source))
				{
					CounterCollection collection = this.collections [source.Name] as CounterCollection;
					collection.RemoveCounterList (source);
					if (collection.Empty && collection != this.defaultCollection)
					{
						this.collections.Remove (collection.Name);
					}
				}
			}
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Processes\AbstractProcess.cs ===
using System;
using System.Diagnostics;

namespace Microsoft.SPG.eAuto.PCPT.Model.Processes
{
	public abstract class AbstractProcess
	{
		protected Process process;

		protected AbstractProcess (string filename)
		{
			this.process = new Process ();
			this.process.StartInfo = new ProcessStartInfo ();
			this.process.StartInfo.RedirectStandardError = true;
			this.process.StartInfo.RedirectStandardInput = true;
			this.process.StartInfo.RedirectStandardOutput = true;
			this.process.StartInfo.UseShellExecute = false;
			this.process.StartInfo.CreateNoWindow = true;
			this.process.StartInfo.FileName = filename;
		}

		protected static bool IsNonEmptyString (string argument)
		{
			return (argument != null && argument != String.Empty);
		}

		/// <summary>
		/// Starts the execution of this process, returning immediately
		/// </summary>
		public virtual void Start ()
		{
			this.process.StartInfo.Arguments = this.Arguments;
			this.process.Start ();
		}

		/// <summary>
		/// Waits for this process to conclude executing, and only returns after it has
		/// finished executing
		/// </summary>
		protected void WaitForExit ()
		{
			this.process.WaitForExit ();
			CheckForErrors ();
		}

		protected abstract void CheckForErrors ();

		/// <summary>
		/// Executes this process synchronously (this method will only return once the
		/// process has finished executing)
		/// </summary>
		public void Execute ()
		{
			Start ();
			WaitForExit ();
		}

		protected abstract string Arguments
		{
			get;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Processes\NetUseProcess.cs ===
using System;
using System.Diagnostics;
using System.Text;

namespace Microsoft.SPG.eAuto.PCPT.Model.Processes
{
	public class NetUseProcess : AbstractProcess
	{
		private string machine;
		private string username;
		private string password;
		private bool disconnect;

		#region Constructors

		/// <summary>
		/// Creates a new NetUseProcess that will connect to the local machine
		/// </summary>
		public NetUseProcess ()
			: base ("net")
		{
			this.disconnect = false;
		}

		/// <summary>
		/// Creates a new NetUseProcess, specifying the machine to connect to
		/// </summary>
		/// <param name="machine">The name of the machine to connect to</param>
		public NetUseProcess (string machine)
			: this ()
		{
			this.Machine = machine;
		}

		/// <summary>
		/// Creates a new NetUseProcess, specifying the machine to connect to, and the
		/// username/password to use when connecting to that machine
		/// </summary>
		/// <param name="machine"></param>
		/// <param name="username"></param>
		/// <param name="password"></param>
		public NetUseProcess (string machine, string username, string password)
			: this (machine)
		{
			this.UserName = username;
			this.Password = password;
		}

		#endregion

		#region Public Properties

		/// <summary>
		/// Gets or Sets the Name of the Machine to pass to the Net Use Command
		/// </summary>
		public string Machine
		{
			get
			{
				return this.machine;
			}
			set
			{
				this.machine = value.Trim (); // Trim all leading and trailing whitespace
			}
		}

		/// <summary>
		/// Gets or Sets Whether the Command Should Disconnect, rather than Connect
		/// </summary>
		public bool IsDisconnect
		{
			get
			{
				return this.disconnect;
			}
			set
			{
				this.disconnect = value;
			}
		}

		/// <summary>
		/// Gets or Sets the UserName to Pass to the Net Use Command
		/// </summary>
		public string UserName
		{
			get
			{
				return this.username;
			}
			set
			{
				this.username = value.Trim (); // Trim leading and trailing whitespace
			}
		}

		/// <summary>
		/// Gets or Sets the Password to Pass to the Net Use Command
		/// </summary>
		public string Password
		{
			get
			{
				return this.password;
			}
			set
			{
				this.password = value.Trim (); // Trim leading and trailing whitespace
			}
		}

		#endregion

		public override void Start ()
		{
			if (!IsNonEmptyString (Machine))
			{
				throw new Exception ("You must specify a Machine Name to connect to.");
			}
			base.Start ();
		}

		protected override void CheckForErrors ()
		{
			string errors = this.process.StandardError.ReadToEnd ();
			if (errors != String.Empty)
			{
				throw new Exception (errors);
			}
		}

		protected override string Arguments
		{
			get
			{
				StringBuilder sb = new StringBuilder (75);
				sb.Append ("use \\\\");
				sb.Append (this.Machine);
				sb.Append ("\\ipc$");

				// Disconnects don't need the username and password options
				if (this.IsDisconnect)
				{
					sb.Append (" /d");
				}
				else if (IsNonEmptyString (this.UserName))
				{
					sb.Append (" /u:");
					sb.Append (this.UserName);
					if (IsNonEmptyString (this.Password))
					{
						sb.Append (" ");
						sb.Append (this.Password);
					}
				}

				return sb.ToString ();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Processes\LogmanProcess.cs ===
using System;
using System.Diagnostics;
using System.Text;

namespace Microsoft.SPG.eAuto.PCPT.Model.Processes
{
    /// <summary>
    /// The different types of Logman commands that can be run by a LogmanProcess
    /// </summary>
    public enum LogmanVerb
    {
        Create,
        Delete,
        Update,
        Start,
        Stop,
    };

    public class LogmanProcess : AbstractProcess
    {
        private string collection;
        private string machine;
        private LogmanVerb verb;
        private bool helpOnly;

        #region Constructors

        /// <summary>
        /// Static Constructor: Prepares the LogmanProcess class for use.
        /// </summary>
        static LogmanProcess ()
        {
            try
            {
                LogmanProcess testProcess = new LogmanProcess (LogmanVerb.Create, "testCollection");
                testProcess.helpOnly = true;
                testProcess.Execute ();
            }
            catch (Exception e)
            {
                if (e.Message.Trim () == "The system cannot find the file specified")
                {
                    const string message = "PCPT cannot operate because the logman executable cannot be found.";
                    throw new ApplicationException (message);
                }
                else
                {
                    const string message = "PCPT cannot operate because the logman executable is not functioning properly.";
                    throw new ApplicationException (message); 
                }
            }
        }

        /// <summary>
        /// Creates a new LogmanProcess, specifying the verb to use
        /// </summary>
        /// <param name="verb">The Logman Verb to use</param>
        public LogmanProcess (LogmanVerb verb)
            : base ("logman")
        {
            this.Verb = verb;
        }

        /// <summary>
        /// Creates a new LogmanProcess, specifying the verb and collection name to use
        /// </summary>
        /// <param name="verb">The Logman Verb to use</param>
        /// <param name="collection">The collection name</param>
        public LogmanProcess (LogmanVerb verb, string collection)
            : this (verb)
        {
            this.Collection = collection;
        }

        /// <summary>
        /// Creates a new LogmanProcess, specifying the verb, collection name, and
        /// machine name to use
        /// </summary>
        /// <param name="verb">The Logman Verb to use</param>
        /// <param name="collection">The collection name to use</param>
        /// <param name="machine">The machine name to use</param>
        public LogmanProcess (LogmanVerb verb, string collection, string machine)
            : this (verb, collection)
        {
            this.Machine = machine;
        }

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets or Sets the Logman Verb to pass to the Logman Command
        /// </summary>
        public LogmanVerb Verb
        {
            get
            {
                return verb;
            }
            set
            {
                verb = value;
            }
        }

        /// <summary>
        /// Gets or Sets the name of the Counter Collection to pass to the Logman
        /// Command
        /// </summary>
        public string Collection
        {
            get
            {
                return collection;
            }
            set
            {
                collection = value.Trim ();
            }
        }

        /// <summary>
        /// Gets or Sets the Machine Name to pass to the Logman Command
        /// </summary>
        public string Machine
        {
            get
            {
                return machine;
            }
            set
            {
                machine = value.Trim ();
            }
        }

        #endregion

        public override void Start ()
        {
            if (!IsNonEmptyString (this.collection))
            {
                throw new ApplicationException ("You must specify a collection name.");
            }
            base.Start ();
        }

        protected override void CheckForErrors ()
        {
            // This message means that everything worked and can be ignored
            const string okMessage = "The command completed successfully.";

            // This message means we tried to get to a collection that doesn't exist and
            //  can be ignored if we were trying to delete the collection:
            string nonExistantCollectionMessage = "Error:" + Environment.NewLine
                + "Collection \"" + this.Collection + "\" does not exist.";

            bool ok = false;
            string errors = this.process.StandardOutput.ReadToEnd ().Trim ();
			
            if (errors == okMessage || this.helpOnly)
            {
                ok = true;
            }
            else if (Verb == LogmanVerb.Delete && errors == nonExistantCollectionMessage)
            {
                ok = true;
            }

            if (!ok)
            {
                throw new ApplicationException (errors);
            }
        }

        protected string VerbText
        {
            get
            {
                switch (Verb)
                {
                    case LogmanVerb.Create:
                        return "create counter ";
                    case LogmanVerb.Update:
                        return "update ";
                    case LogmanVerb.Delete:
                        return "delete ";
                    case LogmanVerb.Start:
                        return "start ";
                    case LogmanVerb.Stop:
                        return "stop ";
                    default:
                        return "stop ";
                }
            }
        }

        protected override string Arguments
        {
            get
            {
                StringBuilder sb = new StringBuilder (75);

                sb.Append (this.VerbText);
                sb.Append ("\"");
                sb.Append (this.Collection);
                sb.Append ("\"");

                if (IsNonEmptyString (this.Machine))
                {
                    sb.Append (" -s ");
                    sb.Append (this.Machine);
                }

                if (this.helpOnly)
                {
                    sb.Append (" -?");
                }

                return sb.ToString ();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfDestroyer\main.cs ===
using System;
using System.Threading;
using System.Net;
using System.Net.Sockets;

namespace PerfDestroyer
{
    class PerfDestroyer
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            // Parameters
            bool cpu=false;
            bool mem=false;
            bool net=false;
            bool disk=false;

            // Parse command line
            foreach (string arg in args)
            {
                string argl=arg.ToLower();
                if (argl=="cpu")
                    cpu=true;
                if (argl=="cpuhigh")
                {
                    cpu=true;
                    CPU_IsHigh=true;
                }
                if (argl=="mem")
                    mem=true;
                if (argl=="net")
                    net=true;
                if (argl=="disk")
                    disk=true;
            }

            if (!(cpu||mem||net||disk))
            {
                Console.WriteLine("Usage: PerfDestroyer [cpu] [cpuhigh] [mem] [net] [disk]");
                return;
            }

            //Start the destruction
            if (cpu) (new Thread(new ThreadStart(DestroyCPU))).Start();
            if (mem) (new Thread(new ThreadStart(DestroyMEM))).Start();
            if (net) (new Thread(new ThreadStart(DestroyNET))).Start();
            if (disk) (new Thread(new ThreadStart(DestroyDISK))).Start();

            //Await oblivion
            while (true)
            {
                Thread.Sleep(60000);
            }
        }

        #region CPU
        public static bool CPU_IsHigh=false;
        static void DestroyCPU()
        {
            Console.WriteLine("Destroying the CPU."+(CPU_IsHigh?".. highly.":"")+"  "+System.Environment.ProcessorCount+" threads.");
            for (int i=0; i<System.Environment.ProcessorCount; ++i)
            {
                Thread t=new Thread(new ThreadStart(DoDestructionOnOneCPU));
                t.Start();

                if (!CPU_IsHigh && i%2==1)
                    t.Priority=ThreadPriority.AboveNormal;
            }

            //Dangerous...
            if (CPU_IsHigh)
                System.Diagnostics.Process.GetCurrentProcess().PriorityClass=System.Diagnostics.ProcessPriorityClass.AboveNormal;
        }

        static void DoDestructionOnOneCPU()
        {
            DateTime last=DateTime.Now;
            while (true)
            {
                if ((DateTime.Now-last).TotalSeconds>1) //yield rarely so we don't lock the whole system
                {
                    last=DateTime.Now;
                    Thread.Sleep(0);
                }
            }
        }
        #endregion //CPU

        #region MEM
        static void DestroyMEM()
        {
            int threads=System.Environment.ProcessorCount/2;
            if (threads==0) threads=1;
            int blocksize=1024/threads/2;
            Console.WriteLine("Destroying the memory with "+(System.Environment.ProcessorCount*2)+"x"+blocksize+"MB blocks from "+threads+" threads.");
            
            for (int i=0; i<threads; ++i)
            {
                (new Thread(new ThreadStart(DoDestructionOnMem))).Start();
            }
        }
        static void DoDestructionOnMem()
        {
            int blocksize=1024/System.Environment.ProcessorCount/2;
            byte []src=new byte[1024*1024*blocksize];
            byte []dest=new byte[1024*1024*blocksize];

            while (true)
            {
                System.Array.Copy(src, dest, blocksize*1024*1024);
            }
        }
        #endregion //MEM

        #region NET
        static void DestroyNET()
        {
            Console.WriteLine("Destroying the network.");

            Thread.CurrentThread.Priority=ThreadPriority.Highest; //so cpu doesn't hog it all

            Socket s=new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, 1);
            IPEndPoint ep=new IPEndPoint(IPAddress.Parse("255.255.255.255"), 22222);
            byte []data=new byte[32*1024];

            int i=0;
            foreach (char c in "PerfDestroyer Flood")
            {
                data[i]=(byte)c;
                ++i;
            }

            while (true)
            {
                s.SendTo(data, ep);
            }
        }
        #endregion //NET

        #region DISK
        static void DestroyDISK()
        {
            Console.WriteLine("disk not implemented yet.");
        }
        #endregion //DISK
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Processes\DeployCounterProcess.cs ===
using System;
using System.Collections.Specialized;
using System.Text;

namespace Microsoft.SPG.eAuto.PCPT.Model.Processes
{
    public enum LogFormat
    {
        Blg,
        Csv,
    };

    public class DeployCounterProcess : LogmanProcess
    {
        private StringCollection counters;
        private string counterFile;
        private string interval;
        private LogFormat format;

        #region Constructors

        public DeployCounterProcess ()
            : base (LogmanVerb.Create)
        {
            this.counters = new StringCollection ();
        }

        public DeployCounterProcess (string collection, StringCollection counters)
            : this ()
        {
            this.Collection = collection;
            this.Counters = counters;
        }

        public DeployCounterProcess (string collection, string counterFile)
            : this ()
        {
            this.Collection = collection;
            this.CounterFile = counterFile;
        }

        public DeployCounterProcess (string collection, StringCollection counters, string machine)
            : this (collection, counters)
        {
            this.Machine = machine;
        }

        public DeployCounterProcess (string collection, string counterFile, string machine)
            : this (collection, counterFile)
        {
            this.Machine = machine;
        }

        public DeployCounterProcess (string collection, StringCollection counters, string machine, string interval)
            : this (collection, counters, machine)
        {
            this.Interval = interval;
        }


        public DeployCounterProcess (string collection, string counterFile, string machine, string interval)
            : this (collection, counterFile, machine)
        {
            this.Interval = interval;
        }

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets or Sets whether or not this DeployCounterProcess will just update the
        /// Counter Collection (rather than creating it)
        /// </summary>
        public bool Updating
        {
            get
            {
                return (this.Verb == LogmanVerb.Update);
            }
            set
            {
                this.Verb = value ? LogmanVerb.Update : LogmanVerb.Create;
            }
        }

        /// <summary>
        /// Gets or Sets the list of Counters to include in the Collection Created/Updated by
        /// this DeployCounterProcess
        /// </summary>
        public StringCollection Counters
        {
            get
            {
                return this.counters;
            }
            set
            {
                this.counters = value;
            }
        }

        /// <summary>
        /// Gets or Sets the name of the Counter File to pass to the Logman Process
        /// </summary>
        public string CounterFile
        {
            get
            {
                return this.counterFile;
            }
            set
            {
                this.counterFile = value.Trim (); // Trim leading and trailing whitespace
            }
        }

        /// <summary>
        /// Gets or Sets the Interval to pass to the Logman Process
        /// </summary>
        public string Interval
        {
            get
            {
                return this.interval;
            }
            set
            {
                this.interval = value.Trim (); // Trim off leading and trailing whitespace
            }
        }

        /// <summary>
        /// Gets or sets the log format to use when deploying counters
        /// </summary>
        public LogFormat Format
        {
            get
            {
                return this.format;
            }
            set
            {
                this.format = value;
            }
        }

        #endregion

        public override void Start ()
        {
            if (!IsNonEmptyString (this.counterFile) && this.counters.Count == 0)
            {
                throw new Exception ("You must specify either a counter file or a list of counters.");
            }
            else if (IsNonEmptyString (this.counterFile) && this.counters.Count != 0)
            {
                throw new Exception ("You may not specify both a list of counters and a counter file.");
            }

            base.Start ();
        }

        protected override string Arguments
        {
            get
            {
                StringBuilder sb = new StringBuilder (125);
                sb.Append (base.Arguments);

                if (this.Counters.Count > 0)
                {
                    sb.Append (" -c");
                    foreach (string s in this.Counters)
                    {
                        sb.Append (" \"");
                        sb.Append (s);
                        sb.Append ("\"");
                    }
                }
                else
                {
                    sb.Append (" -cf ");
                    sb.Append ("\"");
                    sb.Append (this.CounterFile);
                    sb.Append ("\"");
                }
                if (IsNonEmptyString (this.Interval))
                {
                    sb.Append (" -si ");
                    sb.Append (this.Interval);
                }

                switch (this.Format)
                {
                    default:
                    case LogFormat.Blg:
                    {
                        sb.Append(" -f bin");
                        break;
                    }

                    case LogFormat.Csv:
                        {
                            sb.Append(" -f csv");
                            break;
                        }
                }

                return sb.ToString ();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataAccess\AccountCache.cs ===
//using Microsoft.Subscriptions.Test;
using PerfServer.DataStructures;
//using Microsoft.Subscriptions.Test.SSPR.PerfTunnel;
using Microsoft.Win32;
using PerfServer.Tools;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.Remoting;
using System.Xml;
//using Microsoft.Scs.Test.Common;
using Configuration = PerfServer.Tools.Configuration;

namespace PerfServer.DataAccess
{
    /// <summary>
    /// The CacheManager class represents the cache of accounts that is kept in the
    /// PerfAccountCache database.  It can cache accounts that were pre-populated as
    /// well as accounts created through signup scenarios.
    /// </summary>
    public class AccountCache : CacheManager
    {
        private const string AccountInfoXml = "<AcctInfo xmlns=\"urn:schemas-microsoft-com:billing-data\"><PassportInfo><PUIDHigh>{0}</PUIDHigh><PUIDLow>{1}</PUIDLow></PassportInfo></AcctInfo>";

        private double additionalCacheForNewAccounts; // Due to CloseAccount of new Account
        private Puid[] puids;

        /// <summary>
        /// Class constructor: prepares the AccountCache type for use.
        /// </summary>
        static AccountCache()
        {
            //DatabaseReaderUri = Configuration.GetPerfTunnelUri("DatabaseReader.rem");
        }

        /// <summary>
        /// Constructor: Creates a new AccountCache object, using all the default values.
        /// No connection is made to the database.
        /// </summary>
        public AccountCache()
            : base("Accounts")
        {
            this.additionalCacheForNewAccounts = 0.0;
        }

        /// <summary>
        /// Initializes this AccountCache object, reading values from the database
        /// specified in the connectionString parameter
        /// </summary>
        /// <param name="connectionString">The connection string used to open the PerfAccountCache DB</param>
        /// <param name="mapDBList">A list of Map databases used to obtain a list of puids for pre-populated accounts</param>
        /// <returns>Whether or not the CacheManager object initialized successfully</returns>
        public bool Initialize(string connectionString, string mapDBList)
        {
            lock (this)
            {
                if (base.Initialize(connectionString))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }


        /// <summary>
        /// Retrieves the list of prepopulated accounts from the PerfAccountCache database.
        /// This assumes that the list has already been retrieved from the Map databases.
        /// </summary>
        private void FetchPrepopulatedAccounts()
        {
            int count;
            byte[] buffer;
            GetPreExistingItems(out count, out buffer);

            this.puids = new Puid[count];
            MemoryStream stream = new MemoryStream(buffer);
            BinaryReader binaryReader = new BinaryReader(stream);
            for (int i = 0; i < count; ++i)
            {
                this.puids[i] = new Puid(binaryReader.ReadInt32(), binaryReader.ReadInt32());
            }

            binaryReader.Close();
            stream.Close();
        }

        /// <summary>
        /// Gets an Existing Account from the database
        /// </summary>
        /// <returns>The AccountInfo XML for the Account, or null if none were found</returns>
        public XmlElement GetExistingAccount()
        {
            try
            {
                int index = GetPreExistingItem();
                Puid puid = this.puids[index];
                XmlDocument doc = new XmlDocument();
                doc.LoadXml(String.Format(AccountInfoXml, puid.High, puid.Low));
                return doc.DocumentElement;
            }
            catch (Exception)
            {
                // For now, ignore the exception and return null
                return null;
            }
        }

        /// <summary>
        /// Marks that an account was closed, freeing up cache space if applicable
        /// </summary>
        /// <param name="newSignup">Whether or not the closed account was originally
        /// the result of a new signup (rather than being pre-populated)</param>
        public void MarkAccountClosed(bool newSignup)
        {
            if (newSignup)
            {
                // Increase the number of non-pre-existing items
                this.additionalCacheForNewAccounts += (1.0 - this.cachePercentage);
            }
            else
            {
                IncreaseMaxPreExistingItems();
            }
        }

        /// <summary>
        /// Gets whether or not to newly created item
        /// </summary>
        public override bool CacheNewItem
        {
            get
            {
                if (base.CacheNewItem)
                {
                    return true;
                }
                else if (this.additionalCacheForNewAccounts >= 1)
                {
                    // Return true because we closed an account and have some extra space
                    this.additionalCacheForNewAccounts--;
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataAccess\Bucket.cs ===
using System;
using System.Xml;

namespace PerfServer.DataAccess
{
    /// <summary>
    /// Represents a bucket that accounts can be placed into.  A bucket is made up of an
    /// id, a name, and a set of XML that defines the condition that must be met for an
    /// account to be placed in it.
    /// </summary>
    public class Bucket
    {
        private readonly Condition condition;
        private readonly int id;
        private readonly string name;

        /// <summary>
        /// Constructor: Creates a new AccountBucket object
        /// </summary>
        /// <param name="id">The id of the new Account Bucket</param>
        /// <param name="name">The name of the new Account Bucket</param>
        /// <param name="conditionXml">The XML that specifies the condition for the new Account Bucket</param>
        public Bucket(int id, string name, XmlElement conditionXml)
        {
            this.condition = new Condition(conditionXml);
            this.id = id;
            this.name = name;
        }

        /// <summary>
        /// Gets the ID of this Account Bucket
        /// </summary>
        public int ID
        {
            get
            {
                return this.id;
            }
        }

        /// <summary>
        /// Gets the Name of this Account Bucket
        /// </summary>
        public string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Determines whether an account matches the condition for this Account Bucket
        /// </summary>
        /// <param name="xml">The Account Xml for the account to check</param>
        /// <returns>Whether or not the account matches the condition for this Account Bucket</returns>
        public bool Matches(XmlElement xml)
        {
            return this.condition.Evalulate(xml);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfCounterPushingTool\Model\Topology.cs ===
using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Xml;
using Microsoft.SPG.eAuto.PCPT.Model.Processes;

namespace Microsoft.SPG.eAuto.PCPT.Model
{
    public delegate void ProgressEventHandler (object sender, ProgressEventArgs args);
    public delegate void ErrorEventHandler (object sender, ErrorEventArgs args);

    /// <summary>
    /// This class represents a topology of machines, machine types, and
    /// associated counters.
    /// </summary>
    public class Topology
    {
        #region Constants

        /// <summary>
        /// This is the location of the XML file that specifies which counters
        /// are associated with which components.
        /// </summary>
        private const string ComponentsFileName = "ComponentCounters.xml";

        /// <summary>
        /// This is the default log format that will be used if one is not specified.
        /// </summary>
        private const LogFormat DefaultLogFormat = LogFormat.Blg;

        #endregion
		
        #region Events

        /// <summary>
        /// This event is triggered any time progress is made in one of this
        /// class's public business methods.
        /// </summary>
        public event ProgressEventHandler Progress;

        /// <summary>
        /// This event is triggered whenever an error occurs while working with
        /// this topology.  Any errors will get sent to the error handlers, and
        /// the topology will then continue working.
        /// </summary>
        public event ErrorEventHandler Error;

        #endregion
		
        #region Member Variables

        /// <summary>The name of this topology.</summary>
        private string name;

        /// <summary>
        /// All the components available (specified in the Components XML
        /// File).
        /// </summary>
        private Hashtable components;

        /// <summary>
        /// The machines in this Topology (specified in the Topology
        /// Configuration XML File).
        /// </summary>
        private ArrayList machines;

        /// <summary>
        /// The location of the topology configuration file.
        /// </summary>
        private FileInfo configFile;

        /// <summary>
        /// The directory where the CounterList files for each Machine are to
        /// be stored.
        /// </summary>
        private DirectoryInfo counterFileDirectory;

        /// <summary>
        /// Whether or not the machines in this topology have been connected
        /// to yet.
        /// </summary>
        private bool connected;

        /// <summary>
        /// Whether or not the counter files for each machine have been
        /// created.
        /// </summary>
        private bool written;

        #endregion
		
        #region Constructors

        /// <summary>
        /// Private Constructor that initializes variables to default values
        /// </summary>
        private Topology ()
        {
            this.components = new Hashtable ();
            this.machines = new ArrayList ();
            this.connected = false;
            this.written = false;
        }

        /// <summary>Public Constructor for the Topology class.</summary>
        /// <param name="configFileLocation">
        /// The location of the XML configuration file for this topology.
        /// </param>
        /// <param name="counterDirectoryLocation">
        /// The directory in which to place the generated counter files.
        /// </param>
        public Topology (string configFileLocation, string counterDirectoryLocation)
            : this (new FileInfo (configFileLocation), new DirectoryInfo (counterDirectoryLocation))
        {
        }

        /// <summary>Public Constructor for the Topology class.</summary>
        /// <param name="configFile">
        /// The location of the XML configuration file for this topology.
        /// </param>
        /// <param name="counterFileDirectory">
        /// The directory in which to place the generated counter files.
        /// </param>
        public Topology (FileInfo configFile, DirectoryInfo counterFileDirectory)
            : this ()
        {
            // It matters that the counterFileDirectory gets set before the ConfigFile:
            this.counterFileDirectory = counterFileDirectory;
            this.ConfigFile = configFile;
        }

        /// <summary>Public Constructor for the Topology class.</summary>
        /// <remarks>
        /// Since no directory is specified for counter files, they will be
        /// stored relative to the configuration file.  A new directory named
        /// [CONFIG_FILE]_Machine_Files will be created in the same directory
        /// as the configuration file.  The xml file extension will not be
        /// included in the directory name.
        /// </remarks>
        /// <param name="configFileLocation">
        /// The location of the XML configuration file for this topology.
        /// </param>
        public Topology (string configFileLocation)
            : this (new FileInfo (configFileLocation))
        {
        }

        /// <summary>Public Constructor for the Topology class.</summary>
        /// <remarks>
        /// Since no directory is specified for counter files, they will be
        /// stored relative to the configuration file.  A new directory named
        /// [CONFIG_FILE]_Machine_Files will be created in the same directory
        /// as the configuration file.  The xml file extension will not be
        /// included in the directory name.
        /// </remarks>
        /// <param name="configFile">
        /// The location of the XML configuration file for this topology.
        /// </param>
        public Topology (FileInfo configFile)
            : this (configFile, new DirectoryInfo (configFile.FullName.Replace (configFile.Extension, "_Machine_Files")))
        {
        }

        #endregion
		
        #region Public Properties

        /// <summary>
        /// Gets the name of this Topology.
        /// </summary>
        public string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Gets a dictionary of all Components that are in this Topology,
        /// keyed by name.
        /// </summary>
        public IDictionary Components
        {
            get
            {
                return this.components;
            }
        }

        /// <summary>
        /// Gets a collection of all the Machines that are a part of this
        /// Topology, keyed by name.
        /// </summary>
        public ICollection Machines
        {
            get
            {
                return this.machines;
            }
        }

        /// <summary>
        /// Gets or sets the XML Topology Configuration file.
        /// </summary>
        public FileInfo ConfigFile
        {
            get
            {
                return this.configFile;
            }
            set
            {
                if (value.Exists)
                {
                    this.configFile = value;
                    ReadConfigurationFile ();
                }
                else
                {
                    throw new Exception ("The specified topology configuration file does not exist: "
                        + Environment.NewLine + value.FullName);
                }
            }
        }

        /// <summary>
        /// Gets the directory where the generated CounterList files are
        /// located.
        /// </summary>
        public DirectoryInfo CounterFileDirectory
        {
            get
            {
                return this.counterFileDirectory;
            }
        }

        /// <summary>
        /// Gets whether or not the machines in this topology have been
        /// connected to.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                return this.connected;
            }
        }

        /// <summary>
        /// Gets a count of the number of counters in the system.
        /// </summary>
        public int CounterCount
        {
            get
            {
                int count = 0;
                foreach (Machine m in this.machines)
                {
                    count += m.CounterCollections.Count;
                }
                return count;
            }
        }

        #endregion
		
        #region Public Business Methods

        /// <summary>Connects to the machines on the network.</summary>
        /// <remarks>
        /// <para>Uses the net command to 'use' the remote computers.  This
        /// will allow access to the machines, because the connection remains
        /// open.  This must be done before the counters can be
        /// manipulated.</para>
        /// <para>If an error occurs, then it will be reported through the
        /// Error event.</para>
        /// </remarks>
        /// <param name="username">The username to use.</param>
        /// <param name="password">The password to use.</param>
        public void ConnectMachines (string username, string password)
        {
            NetUseProcess process = new NetUseProcess ();
            process.UserName = username;
            process.Password = password;
            this.connected = true;

            foreach (Machine machine in this.machines)
            {
                process.Machine = machine.Name;
                if (!ExecuteProcess (process, machine.Name))
                {
                    this.connected = false;
                }
            }
        }

        /// <summary>Disconnects from the machines on the network.</summary>
        /// <remarks>
        /// <para>Uses the net command to 'unuse' the remote computers.  this
        /// will close any open connection to that computer.</para>
        /// <para>If an error occurs in this method, then it will be reported
        /// through the Error event.</para>
        /// </remarks>
        public void DisconnectMachines ()
        {
            NetUseProcess process = new NetUseProcess ();
            process.IsDisconnect = true;
            this.connected = false;

            foreach (Machine machine in this.machines)
            {
                process.Machine = machine.Name;
                ExecuteProcess (process, machine.Name);
            }
        }

        /// <summary>Deletes the counters from machines in the topology.</summary>
        /// <remarks>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// <para>This method will remove the counters from the machines in
        /// this topology.  Any counter collections that were created by users
        /// (i.e. not the ones that are created by this application) will
        /// be unaffected.</para>
        /// </remarks>
        public void DeleteCounters ()
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount, 0);
            DeleteCounters (args);
            ReportFinished (args);
        }

        /// <summary>Deploys the counters to the machines in the topology.</summary>
        /// <remarks>
        /// <para>The counters must not already exist.  This can be assured by
        /// first calling the DeleteCounters method.</para>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// </remarks>
        public void DeployCounters ()
        {
            DeployCounters (DefaultLogFormat);
        }

        /// <summary>Deploys the counters to the machines in the topology.</summary>
        /// <remarks>
        /// <para>The counters must not already exist.  This can be assured by
        /// first calling the DeleteCounters method.</para>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// </remarks>
        /// <param name="format">The log format to use</param>
        public void DeployCounters (LogFormat format)
        {
            DeployCounters (null, format);
        }

        /// <summary>Deploys the counters to the machines in the topology.</summary>
        /// <remarks>
        /// <para>The counters must not already exist.  This can be assured by
        /// first calling the DeleteCounters method.</para>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// </remarks>
        /// <param name="interval">
        /// The interval at which the counters will be updated
        /// </param>
        public void DeployCounters (string interval)
        {
            DeployCounters (interval, DefaultLogFormat);
        }

        /// <summary>Deploys the counters to the machines in the topology.</summary>
        /// <remarks>
        /// <para>The counters must not already exist.  This can be assured by
        /// first calling the DeleteCounters method.</para>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// </remarks>
        /// <param name="interval">
        /// The interval at which the counters will be updated
        /// </param>
        /// <param name="format">The log format to use</param>
        public void DeployCounters (string interval, LogFormat format)
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount, 0);
            DeployCounters (args, interval, format);
            ReportFinished (args);
        }

        /// <summary>Deletes and Redeploys the Counters from all Machines in
        /// the Topology.</summary>
        /// <remarks>
        /// If there is an error while executing this method, then that error
        /// will be reported through the Error event.
        /// </remarks>
        public void DeleteAndDeployCounters ()
        {
            DeleteAndDeployCounters (DefaultLogFormat);
        }

        /// <summary>Deletes and Redeploys the Counters from all Machines in
        /// the Topology.</summary>
        /// <remarks>
        /// If there is an error while executing this method, then that error
        /// will be reported through the Error event.
        /// </remarks>
        /// <param name="format">The log format to use</param>
        public void DeleteAndDeployCounters (LogFormat format)
        {
            DeleteAndDeployCounters (null, format);
        }

        /// <summary>Deletes and Redeploys the Counters from all Machines in
        /// the Topology.</summary>
        /// <remarks>
        /// If there is an error while executing this method, then that error
        /// will be reported through the Error event.
        /// </remarks>
        /// <param name="interval">
        /// The interval at which the counters will be updated
        /// </param>
        public void DeleteAndDeployCounters (string interval)
        {
            DeleteAndDeployCounters (interval, DefaultLogFormat);
        }

        /// <summary>Deletes and Redeploys the Counters from all Machines in
        /// the Topology.</summary>
        /// <remarks>
        /// If there is an error while executing this method, then that error
        /// will be reported through the Error event.
        /// </remarks>
        /// <param name="interval">
        /// The interval at which the counters will be updated
        /// </param>
        /// <param name="format">The log format to use</param>
        public void DeleteAndDeployCounters (string interval, LogFormat format)
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount * 2, 0);
            DeleteCounters (args);
            DeployCounters (args, interval, format);
            ReportFinished (args);
        }

        /// <summary>
        /// Updates the counter update interval on every machine in the topology.
        /// </summary>
        /// <remarks>
        /// If there is an error while executing this method, then that error
        /// will be reported through the Error event.
        /// </remarks>
        /// <param name="interval">
        /// The new update interval, which is the frequency at which data will
        /// be collected for each of the counters.
        /// </param>
        public void UpdateCounterInterval (string interval)
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount, 0);
            DeployCounterProcess process = CreateDeployCounterProcess ();
            process.Interval = interval;
            process.Updating = true;

            // Make sure the machine files have been written.
            CreateMachineFiles ();

            foreach (Machine machine in this.machines)
            {
                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    args.Message = "Updating the Counter Interval for "
                        + collection.Name + " on " + machine.Name;
                    ReportProgress (args);

                    process.Machine = machine.Name;
                    process.Collection = collection.Name;
                    process.CounterFile = collection.File.FullName;
                    ExecuteProcess (process, machine.Name);
                }
            }
            ReportFinished (args);
        }

        /// <summary>Starts the counters on every machine in the topology.</summary>
        /// <remarks>
        /// <para>This method will not affect counter collections that were
        /// not created by this application.</para>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// </remarks>
        public void StartCounters ()
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount, 0);
            LogmanProcess process = CreateLogmanProcess (LogmanVerb.Start);
            foreach (Machine machine in this.machines)
            {
                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    args.Message = "Starting " + collection.Name + " on " + machine.Name;
                    ReportProgress (args);

                    process.Machine = machine.Name;
                    process.Collection = collection.Name;
                    ExecuteProcess (process, machine.Name);
                }
            }
            ReportFinished (args);
        }

        /// <summary>Stops the counters on every machine in the topology.</summary>
        /// <remarks>
        /// <para>This method will not affect counter collections that were
        /// not created by this application.</para>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// </remarks>
        public void StopCounters ()
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount, 0);
            LogmanProcess process = CreateLogmanProcess (LogmanVerb.Stop);

            foreach (Machine machine in this.machines)
            {
                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    args.Message = "Stopping " + collection.Name + " on " + machine.Name;
                    ReportProgress (args);

                    process.Machine = machine.Name;
                    process.Collection = collection.Name;
                    ExecuteProcess (process, machine.Name);
                }
            }
            ReportFinished (args);
        }

        /// <summary>
        /// Deletes the counter logs from every machine in the topology.
        /// </summary>
        /// <remarks>
        /// If there is an error while executing this method, then that error
        /// will be reported through the Error event.
        /// </remarks>
        public void DeleteCounterLogs ()
        {
            ProgressEventArgs args = new ProgressEventArgs (0, this.CounterCount, 0);

            ArrayList list = new ArrayList ();
            foreach (Machine machine in this.machines)
            {
                DirectoryInfo dir;

                try
                {
                    dir = GetCounterLogDirectory(machine.Name);
                }
                catch (Exception e)
                {
                    if (e.Message.Contains("Could not locate the Performance Logs directory"))
                    {
                        return;                        
                    }

                    throw new ApplicationException(e.Message, e);
                }

                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    args.Message = "Deleting Log Files for "
                        + collection.Name + " from " + machine.Name;
                    ReportProgress(args);

                    FileInfo[] files = dir.GetFiles(collection.Name + "*.*");
                    foreach (FileInfo file in files)
                    {
                        try
                        {
                            file.Delete();
                        }
                        catch (Exception e)
                        {
                            ReportError(e.Message, machine.Name);
                        }
                    }
                }
            }
            ReportFinished (args);
        }

        /// <summary>
        /// Archives the counter logs from every machine in the topology.
        /// </summary>
        /// <remarks>
        /// <para>The logs will be renamed and relocated to the specified
        /// folder.</para>
        /// <para>Errors that occur while executing this method will be reported
        /// through the Error event, so long as this method can continue.  If an
        /// error occurs that will prevent this method from finishing the rest
        /// of its work, then an Exception will be thrown.</para>
        /// </remarks>
        /// <param name="targetFolder">
        /// The folder where the logs are to be stored.  If this folder does
        /// not exist, it will be created.
        /// </param>
        public void ArchiveCounterLogs (string targetFolder)
        {
            ArchiveCounterLogs (new DirectoryInfo (targetFolder));
        }

        /// <summary>
        /// Archives the counter logs from every machine in the topology.
        /// </summary>
        /// <remarks>
        /// <para>The logs will be renamed and relocated to the specified
        /// folder.</para>
        /// <para>Errors that occur while executing this method will be reported
        /// through the Error event, so long as this method can continue.  If an
        /// error occurs that will prevent this method from finishing the rest
        /// of its work, then an Exception will be thrown.</para>
        /// </remarks>
        /// <param name="targetFolder">
        /// The folder where the logs are to be stored.  If this folder does
        /// not exist, it will be created.
        /// </param>
        public void ArchiveCounterLogs (DirectoryInfo target)
        {
            const string messageTemplate = "Archiving {0} Log File(s) for {1} from {2}";

            if (!target.Exists)
            {
                target.Create ();
            }
            string targetName = target.FullName;
            if (!targetName.EndsWith ("\\"))
            {
                targetName += "\\";
            }

            ProgressEventArgs args = new ProgressEventArgs (0, CounterCount, 0);

            foreach (Machine machine in this.machines)
            {
                DirectoryInfo source = GetCounterLogDirectory (machine.Name);

                if (source == null) continue;

                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    FileInfo [] files = source.GetFiles (collection.Name + "*.*");

                    //Sometime the perfmon log file will be placed in \admin so add this if not found in source.
                    //by qijfeng
                    //if (0 == files.Length)
                    //{

                    //    files = source.GetFiles("admin\\"+collection.Name + "*.*");
                    //}

                    args.Message = String.Format (messageTemplate, files.Length, collection.Name, machine.Name);
                    ReportProgress (args);

                    if (collection == machine.DefaultCollection)
                    {
                        MoveLogFiles (machine.Name, files, targetName, machine.Name);
                    }
                    else
                    {
                        string subDirectory = targetName + collection.Name + "\\";
                        if (!Directory.Exists (subDirectory))
                        {
                            Directory.CreateDirectory (subDirectory);
                        }
                        string filename = machine.Name + "_" + collection.Name;
                        MoveLogFiles (machine.Name, files, subDirectory, filename);
                    }
                }
            }
            ReportFinished (args);
        }

        #endregion
		
        #region Private Methods for Reading the XML Configuration File

        /// <summary>
        /// Reads the configuration xml file, loading first the list of
        /// components and then loading the list of machines.
        /// </summary>
        private void ReadConfigurationFile ()
        {
            ReadComponents ();
            ReadMachines ();
        }

        /// <summary>
        /// This private method reads in all the components from the
        /// configuration file.
        /// </summary>
        private void ReadComponents ()
        {
			// Find the location of the PCPTModel.dll file we are currently using so
			// that we can make paths to config files relative to this one.
			Module[] moduleArray;
			moduleArray = Assembly.GetExecutingAssembly().GetModules(false);
            
			// The module at index 0 will be the module containing this class.
			Module myModule = moduleArray[0];
			string DLLPathAndFile = myModule.FullyQualifiedName;
			if (DLLPathAndFile.ToLower().EndsWith("pcptmodel.dll") == false)
			{
				string message = "Error locating PCPTModel.dll file. Expected the DLL file [";
				message += DLLPathAndFile;
				message += "] to be that file";
				throw new Exception (message);
			}

			// get the path for the DLL
			FileInfo DLLFile = new FileInfo(DLLPathAndFile);
            string DLLPath = DLLFile.Directory.FullName;
			Console.WriteLine("DLLPath = [{0}]", DLLPath);
			
            // Load the XML file:
            XmlDocument document = new XmlDocument ();
            string componentsFilePathAndName = DLLPath + @"\" + Topology.ComponentsFileName;
            try
            {				
                document.Load (componentsFilePathAndName);
            }
            catch (Exception e)
            {
                throw new Exception("Could not load the Components XML File: " + componentsFilePathAndName, e);
            }
            XmlElement root = document.DocumentElement;

            // Check the version of the Component XML file against the assembly version:
            Version fileVersion = new Version (root.GetAttribute ("version"));
            Assembly assembly = Assembly.GetAssembly (GetType ());
            Version assemblyVersion = assembly.GetName ().Version;
            if (fileVersion.Major != assemblyVersion.Major || fileVersion.Minor != assemblyVersion.Minor)
            {
                string message = "You do not have the correct ComponentCounters.xml file for this version of the tool.";
                message += Environment.NewLine;
                message += "You need version " + assemblyVersion.ToString (2);
                throw new Exception (message);
            }

            // Make sure the directory specified exists:
			string directoryString = DLLPath + @"\" + root.Attributes ["directory"].Value;
            DirectoryInfo directory = new DirectoryInfo (directoryString);
            if (!directory.Exists)
            {
                string message = "The components directory did not exist.";
                message += Environment.NewLine;
                message += directory.FullName;
                throw new Exception (message);
            }

            // Loop through all the <Component> tags:
            XmlNodeList nodeList = root.SelectNodes ("Component");
            foreach (XmlElement element in nodeList)
            {
                // Create the component:
                string componentName = element.GetAttribute ("name");
                Component component = new Component (componentName);

                // Add the default CounterCollection:
                AddCounterLists (directory, element, component.DefaultCollection);

                // Add the other CounterCollections:
                XmlNodeList children = element.SelectNodes ("AdditionalCollection");
                foreach (XmlElement child in children)
                {
                    string collectionName = child.GetAttribute ("name");
                    CounterCollection collection = new CounterCollection (collectionName);
                    AddCounterLists (directory, child, collection);
                    component.AddCounterCollection (collection);
                }

                // Add the just-created Component to the Hashtable:
                this.components.Add (component.Name, component);
            }
        }

        /// <summary>
        /// Adds the CounterLists from below a particular node to a specified
        /// CounterCollection.
        /// </summary>
        /// <param name="directory">
        /// The directory to look for the CounterList file in.
        /// </param>
        /// <param name="node">
        /// The node that is the parent of the CounterLists to be added.
        /// </param>
        /// <param name="collection">
        /// The CounterCollection that the CounterLists should be added to.
        /// </param>
        private static void AddCounterLists (DirectoryInfo directory, XmlNode node, CounterCollection collection)
        {
            XmlNodeList children = node.SelectNodes ("CounterList");
            foreach (XmlElement child in children)
            {
                string file = child.GetAttribute ("file");
                CounterList list = CounterList.Read (directory, file);
                collection.AddCounterList (list);
            }
        }

        /// <summary>
        /// This private method reads in all the machine information from the
        /// configuration files.
        /// </summary>
        private void ReadMachines ()
        {
            // Load the XML Document:
            XmlDocument document = new XmlDocument ();
            try
            {
                document.Load (this.configFile.FullName);
            }
            catch (Exception e)
            {
                throw new Exception ("Could not load the Topology Configuration XML File: "
                    + Environment.NewLine + this.configFile.FullName, e);
            }
            XmlElement root = document.DocumentElement;
            name = root.GetAttribute ("topologyName");

            // Loop through the <Server> nodes:
            XmlNodeList nodeList = root.SelectNodes ("Server");
            foreach (XmlElement element in nodeList)
            {
                // Create a new Machine object for each <Server> node:
                string machineName = element.GetAttribute ("name");
                Machine machine = new Machine (machineName, this.name, this.counterFileDirectory);

                // Loop through the <PublishedComponentName> nodes:
                XmlNodeList children = element.SelectNodes ("PublishedComponentName");
                foreach (XmlElement child in children)
                {
                    string componentName = child.GetAttribute ("name");
                    if (this.components.Contains (componentName))
                    {
                        machine.AddComponent ((Component) this.components [componentName]);
                    }
                }

                // Add the just-created Machine to the list of Machines:
                //  (but only if the Machine contains at least one counter to collect)
                if (!machine.IsEmpty)
                {
                    this.machines.Add (machine);
                }
            }
        }

        #endregion
		
        #region Private Methods for Reporting Progress or Errors

        /// <summary>
        /// This method reports errors to any listeners that have been
        /// registered with this Topology object.
        /// </summary>
        /// <param name="message">The error message.</param>
        /// <param name="machine">The machine on which the error occurred.</param>
        private void ReportError (string message, string machine)
        {
            if (Error != null)
            {
                ErrorEventArgs args = new ErrorEventArgs (message, machine);
                Error (this, args);
            }
        }

        /// <summary>
        /// This method reports progress to any listeners that have been
        /// registered with this Topology object.
        /// </summary>
        /// <param name="args">
        /// The arguments to send as part of the progress report.
        /// </param>
        private void ReportProgress (ProgressEventArgs args)
        {
            if (Progress != null)
            {
                Progress (this, args);
            }
            args.CurrentValue++;
        }

        /// <summary>
        /// This method reports that progress has completed on a particular
        /// process.  This is reported to any listeners that have been
        /// registered with this Topology object.
        /// </summary>
        /// <param name="args">
        /// The arguments to send as part of the progress report.
        /// </param>
        private void ReportFinished (ProgressEventArgs args)
        {
            args.CurrentValue = args.MaximumValue;
            args.Message = "Finished";
            ReportProgress (args);
        }

        #endregion
		
        #region Private Methods for Moving Log Files Around

        private static DirectoryInfo GetCounterLogDirectory (string machineName)
        {
            const string pathTemplate = "\\\\{0}\\{1}$\\perflogs";

            DirectoryInfo directory = new DirectoryInfo (String.Format (pathTemplate, machineName, 'd'));
            if (!directory.Exists)
            {
                directory = new DirectoryInfo (String.Format (pathTemplate, machineName, 'c'));
                if (!directory.Exists)
                {
					directory = new DirectoryInfo (String.Format (pathTemplate, machineName, 'e'));
					if (!directory.Exists)
					{
                        return null;
                        //throw new Exception ("Could not locate the Performance Logs directory in"
                        //    + @" directory \PerfLogs on drives C:\, D:\, or E:\ on " + machineName);
					}
                }
            }

            return directory;
        }

        /// <summary>
        /// Moves a set of log files to a new directory.
        /// </summary>
        /// <param name="machine">The machine on which the files are
        /// located.</param>
        /// <param name="files">The list of files to be moved.</param>
        /// <param name="target">The target directory.  This string must end
        /// with "\\".</param>
        /// <param name="filename">The base file name to use, without the
        /// extension.  If more than one file is being moved, then numbers
        /// will be appended to this filename.</param>
        private void MoveLogFiles (string machine, FileInfo [] files, string target, string filename)
        {
            if (files.Length == 1)
            {
                string location = target + filename + files[0].Extension;
                MoveFile (files [0], location, machine);
            }
            else
            {
                int i = 1;
                foreach (FileInfo file in files)
                {
                    string location = target + filename + "_" + i + file.Extension;
                    MoveFile (file, location, machine);
                    i++;
                }
            }
        }

        /// <summary>Moves a single file to a new location.</summary>
        /// <param name="file">The file to be moved.</param>
        /// <param name="location">Where to move the file.</param>
        /// <param name="machine">The machine from which it is being moved.</param>
        private void MoveFile (FileInfo file, string location, string machine)
        {
            try
            {
                file.MoveTo (location);
            }
            catch (Exception e)
            {
                ReportError (e.Message, machine);
            }
        }

        #endregion
		
        #region Other Private Methods

        /// <summary>
        /// Creates a process to use when deploying counters, handling
        /// Exceptions nicely.
        /// </summary>
        /// <returns>A process that can be used to deploy counters</returns>
        private static DeployCounterProcess CreateDeployCounterProcess ()
        {
            try
            {
                return new DeployCounterProcess ();            
            }
            catch (TypeInitializationException exception)
            {
                throw ((exception.InnerException != null) ? exception.InnerException : exception);
            }
        }

        /// <summary>
        /// Creates a process to use when running the logman executable,
        /// handling Exceptions nicely.
        /// </summary>
        /// <param name="verb">
        /// The LogmanVerb to use when creating the LogmanProcess
        /// </param>
        /// <returns>
        /// A process that can be used to run the logman executable
        /// </returns>
        private static LogmanProcess CreateLogmanProcess (LogmanVerb verb)
        {
            try
            {
                return new LogmanProcess (verb);
            }
            catch (TypeInitializationException exception)
            {
                throw ((exception.InnerException != null) ? exception.InnerException : exception);
            }
        }

        /// <summary>Creates the output counter files.</summary>
        /// <remarks>
        /// <para>This method will not generate Error events, but will instead
        /// throw an exception if an error occurs, because errors in this
        /// method should stop execution.</para>
        /// <para>Normally, there will be one output file per machine.  However,
        /// in certain cases, more than one output file will be needed.  In
        /// any event, each output file corresponds to one set of counters
        /// that will run on one machine.  There can be multiple sets of
        /// counters on a single machine, and there can be multiple machines
        /// running similar or even identical sets of counters.  For
        /// each set on each machine, there will be one file.</para>
        /// </remarks>
        private void CreateMachineFiles ()
        {
            if (!this.written)
            {
                if (!this.counterFileDirectory.Exists)
                {
                    this.counterFileDirectory.Create ();
                }
                foreach (Machine m in this.machines)
                {
                    foreach (CounterCollection c in m.CounterCollections)
                    {
                        c.WriteToFile (m.Name);
                    }
                }
                this.written = true;
            }
        }

        /// <summary>Deletes the counters from machines in the topology.</summary>
        /// <remarks>
        /// <para>If there is an error while executing this method, then that
        /// error will be reported through the Error event.</para>
        /// <para>This method will remove the counters from the machines in
        /// this topology.  Any counter collections that were created by users
        /// (i.e. not the ones that are created by this application) will
        /// be unaffected.</para>
        /// </remarks>
        /// <param name="args">The arguments to be used for reporting progress.</param>
        private void DeleteCounters (ProgressEventArgs args)
        {
            LogmanProcess process = CreateLogmanProcess (LogmanVerb.Delete);
            foreach (Machine machine in this.machines)
            {
                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    args.Message = "Deleting " + collection.Name + " from " + machine.Name;
                    ReportProgress (args);
	
                    process.Machine = machine.Name;
                    process.Collection = collection.Name;
                    ExecuteProcess (process, machine.Name);
                }
            }
         }

        /// <summary>
        /// Deploys the Counters to the Machines in this Topology.
        /// </summary>
        /// <remarks>
        /// If there is an error while executing this method, then that
        /// error will be reported through the Error event.
        /// </remarks>
        /// <param name="args">The argumenst to be used for reporting Progress.</param>
        /// <param name="interval">The initial interval for the Counters.</param>
        /// <param name="format">The log format to use</param>
        private void DeployCounters (ProgressEventArgs args, string interval, LogFormat format)
        {
            // Make sure we have created CounterList files:
            CreateMachineFiles ();

            // Set up the Process:
            DeployCounterProcess process = CreateDeployCounterProcess ();
            process.Format = format;
            if (interval != null)
            {
                process.Interval = interval;
            }

            foreach (Machine machine in this.machines)
            {
                foreach (CounterCollection collection in machine.CounterCollections)
                {
                    // Report before doing the current item:
                    args.Message = "Deploying " + collection.Name + " to " + machine.Name;
                    ReportProgress (args);

                    process.Machine = machine.Name;
                    process.Collection = collection.Name;
                    process.CounterFile = collection.File.FullName;
                    ExecuteProcess (process, machine.Name);
                }
            }
        }

        /// <summary>
        /// This method is a shortcut way of executing a process.
        /// </summary>
        /// <param name="process">The process to execute.</param>
        /// <param name="machine">The machine associated with the process.</param>
        private bool ExecuteProcess (AbstractProcess process, string machine)
        {
            try
            {
                process.Execute ();
                return true;
            }
            catch (Exception e)
            {
                ReportError (e.Message, machine);
                return false;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataAccess\Condition.cs ===
using System;
using System.Collections;
using System.Xml;

namespace PerfServer.DataAccess
{
    /// <summary>
    /// An XML-Defined condition that an account can be compared against.  Conditions
    /// can be nested.
    /// </summary>
    public class Condition
    {
        private readonly string operation;
        private readonly string xpath;
        private readonly string attribute;
        private readonly string value;
        private readonly ArrayList subConditions;
        private readonly bool count;
        private readonly XmlNamespaceManager nsmgr;

        /// <summary>
        /// Constructor: Creates a new Condition object from an Xml Element
        /// </summary>
        /// <param name="xml">The Xml element that defines the Condition to create</param>
        public Condition(XmlElement xml)
        {
            this.operation = xml.LocalName;
            this.subConditions = new ArrayList();

            if (this.operation == "and" || this.operation == "or" || this.operation == "not")
            {
                foreach (XmlNode child in xml.ChildNodes)
                {
                    if (child.NodeType == XmlNodeType.Element)
                    {
                        this.subConditions.Add(new Condition(child as XmlElement));
                    }
                }
            }

            else
            {
                this.count = (xml.GetAttribute("countFlag") == "1");

                string xpath = xml.GetAttribute("xpath");
                int index = xpath.IndexOf('|');
                if (index >= 0)
                {
                    this.xpath = xpath.Substring(0, index);
                    this.attribute = xpath.Substring(index + 1);
                }
                else
                {
                    this.xpath = xpath;
                    this.attribute = null;
                }

                this.value = xml.GetAttribute("value");
                this.nsmgr = new XmlNamespaceManager(xml.OwnerDocument.NameTable);
                this.nsmgr.AddNamespace("b", xml.NamespaceURI);
            }
        }

        /// <summary>
        /// Evaluates this Condition against an account.
        /// </summary>
        /// <param name="xml">The Account XML of the account to evaluate against</param>
        /// <returns>Whether or not this condition matches the specified Account XML</returns>
        public bool Evalulate(XmlElement xml)
        {
            try
            {
                if (this.operation == "and")
                {
                    return AndSubConditions(xml);
                }
                else if (this.operation == "or")
                {
                    return OrSubConditions(xml);
                }
                else if (this.operation == "not")
                {
                    return NotSubCondition(xml);
                }
                else
                {
                    return EvaluateLeafCondition(xml);
                }
            }
            catch (Exception)
            {
                return false;
            }
        }

        /// <summary>
        /// Evaluates all the sub-conditions of this Condition, ANDing them together.  This
        /// method makes use of short-circuiting
        /// </summary>
        /// <param name="xml">The Account XML to evaluate against</param>
        /// <returns>Whether or not all the sub-conditions of this Condition matched the specified Account XML</returns>
        private bool AndSubConditions(XmlElement xml)
        {
            foreach (Condition condition in this.subConditions)
            {
                if (!condition.Evalulate(xml))
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Evaluates all the sub-conditions of this Condition, ORing them together.  This
        /// method makes use of short-circuiting
        /// </summary>
        /// <param name="xml">The Account XML to evaluate against</param>
        /// <returns>Whether or not any of the sub-conditions of this Condition matched the specified Account XML</returns>
        private bool OrSubConditions(XmlElement xml)
        {
            foreach (Condition condition in this.subConditions)
            {
                if (condition.Evalulate(xml))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Evaluates the sub-condition of this Condition, returning the inverse of that Condition.
        /// </summary>
        /// <param name="xml">The Account XML to evaluate against</param>
        /// <returns>The inverse of whether or not the sub-condition of this Condition matched the specified Account XML</returns>
        private bool NotSubCondition(XmlElement xml)
        {
            Condition condition = this.subConditions[0] as Condition;
            return !condition.Evalulate(xml);
        }

        /// <summary>
        /// Evaluates all this Condition.  This method does no checking for nested Conditions,
        /// and it should only be called for leaf-node Conditions.
        /// </summary>
        /// <param name="xml">The Account XML to evaluate against</param>
        /// <returns>Whether or not any of this Condition matched the specified Account XML</returns>
        private bool EvaluateLeafCondition(XmlElement xml)
        {
            int comparison;

            if (this.count)
            {
                int count = xml.SelectNodes(this.xpath, this.nsmgr).Count;
                comparison = count.CompareTo(Int32.Parse(this.value));
            }
            else
            {
                XmlElement element = xml.SelectSingleNode(this.xpath, this.nsmgr) as XmlElement;
                string value = (this.attribute != null) ? element.GetAttribute(this.attribute) : element.InnerText;
                comparison = value.CompareTo(this.value);
            }

            return ((comparison == 0 && this.operation == "eq")
                || (comparison > 0 && this.operation == "gt")
                || (comparison < 0 && this.operation == "lt"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataStructures\Puid.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace PerfServer.DataStructures
{
    /// <summary>
    /// Represents a Passport User ID, which contains a high and a low value.
    /// Puid objects are immutable, and can never be changed.
    /// </summary>
    [Serializable]
    public struct Puid
    {
        /// <summary>
        /// The empty Puid, with both its high and low value set to 0
        /// </summary>
        public static readonly Puid Empty;

        private static readonly Random random = new Random();

        private readonly int high;
        private readonly int low;

        static Puid()
        {
            Puid.Empty = new Puid(0, 0);
            random = new Random();
        }

        /// <summary>
        /// Creates a new Puid object
        /// </summary>
        /// <param name="high">The high value</param>
        /// <param name="low">The low value</param>
        public Puid(int high, int low)
        {
            this.high = high;
            this.low = low;
        }

        /// <summary>
        /// Creates a new Puid object
        /// </summary>
        /// <param name="puid">The puid to copy</param>
        public Puid(Puid puid)
        {
            this.high = puid.High;
            this.low = puid.Low;
        }

        /// <summary>
        /// Gets the high value for this Puid
        /// </summary>
        public int High
        {
            get
            {
                return this.high;
            }
        }

        /// <summary>
        /// Gets the low value for this Puid
        /// </summary>
        public int Low
        {
            get
            {
                return this.low;
            }
        }

        /// <summary>
        /// Generates a random Puid
        /// </summary>
        /// <returns>A new, randomly generated Puid</returns>
        public static Puid RandomPuid()
        {
            lock (random)
            {
                int high = random.Next(0, Int32.MaxValue);
                int low = random.Next(Int32.MinValue, Int32.MaxValue);
                return new Puid(high, low);
            }
        }

        /// <summary>
        /// Converts this Puid into a long integer.
        /// </summary>
        /// <returns>A long integer version of this Puid</returns>
        public long ToLong()
        {
            return (long)((((Int64)High) << 32) + ((UInt32)Low));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataAccess\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DataAccess")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("DataAccess")]
[assembly: AssemblyCopyright("Copyright  MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("08f66533-75d2-4002-a73f-d6e1080a4c33")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\ConfigurationManager.cs ===
using PerfServer.DataAccess;
using PerfServer.Tools;
using System;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Collections;


namespace PerfServer.Model
{
    /// <summary>
    /// This class manages the Perf Server configuration file, 
    /// </summary>
    public class ConfigurationManager
    {
        #region Fields

        public const string ApiNotCalled = "This API Was Not Called";
        public const string BdkNamespace = "urn:schemas-microsoft-com:billing-data";

        private const string ConfigFileName = "config.xml";
        //private const string PopulationFileName = "popfile.xml";
        //private const string PGWConfigFileName = @"config\PGWPerfServerTestConfig.xml";

        //private static readonly XmlNamespaceManager namespaceManager;
        //private static readonly ProductCatalog productCatalog;
        //private static readonly ProfileSet profileSet;
        //private static readonly string pgwConfigFilePath;
        private static readonly Hashtable featureSet;

        #endregion

        public static void Initialize()
        { 
            // just a way to call static constructor.
        }

        #region Constructors

        /// <summary>
        /// Initializes the ConfigurationManager class
        /// </summary>
        static ConfigurationManager()
        {
            // Only 1 thread can initialize at once.
            lock (typeof(ConfigurationManager))
            {
                // Force initialization of the CityInfo class:
                //CityInfo cityInfo = new CityInfo();
                
                featureSet = new Hashtable();

                string dllLocation = Assembly.GetExecutingAssembly().CodeBase;
                string perfServerFolder = Path.Combine(dllLocation, @"..\..\");
                string configFileLocation = Path.Combine(perfServerFolder, ConfigFileName);
                //string populationFileLocation = Path.Combine(perfServerFolder, PopulationFileName);
                //initialize configuration for PGW
                //pgwConfigFilePath = String.Format(@"{0}{1}{2}",
                //    Path.GetDirectoryName(dllLocation), Path.DirectorySeparatorChar, PGWConfigFileName);

                try
                {
                    XmlDocument configFileDocument = new XmlDocument();
                    configFileDocument.Load(configFileLocation);
                    XmlElement pcfList = configFileDocument.DocumentElement.SelectSingleNode("PCFFiles") as XmlElement;
                    //productCatalog = new ProductCatalog(perfServerFolder, pcfList);

                    // extract features
                    XmlElement featuresList = configFileDocument.DocumentElement.SelectSingleNode("FeatureSet") as XmlElement;
                    if (featuresList != null)
                    {
                        XmlNodeList nodeList = featuresList.SelectNodes("Feature"); ;
                        foreach (XmlElement element in nodeList)
                        {
                            string name = element.GetAttribute("name");
                            string enabled = element.GetAttribute("enabled").ToLower();
                            featureSet[name] = enabled.Equals("true") ? true : false;
                        }
                    }

                    XmlNodeList bucketList = configFileDocument.DocumentElement.SelectNodes("AcctLists/AcctList");
                    foreach (XmlElement element in bucketList)
                    {
                        Database.AddBucket(element);
                    }

                    //XmlDocument populationFileDocument = new XmlDocument();
                    //populationFileDocument.Load(populationFileLocation);
                    //XmlElement profileSetElement = populationFileDocument.DocumentElement.SelectSingleNode("ProfileSet") as XmlElement;
                    //profileSet = new ProfileSet(profileSetElement);

                    //namespaceManager = new XmlNamespaceManager(populationFileDocument.NameTable);
                    //namespaceManager.AddNamespace("b", BdkNamespace);

                    XmlElement scenarioList = configFileDocument.DocumentElement.SelectSingleNode("Scenarios") as XmlElement;
                    Scenario.LoadScenarios(scenarioList);
                }
                catch (Exception exception)
                {
                    string message = "An Exception occurred while initializing the Perf Server Configuration Manager";
                    GlobalLog.HandleException(message, exception);
                    throw new Exception(message, exception);
                }
                finally
                {
                    // After all this gets done happening, force Garbace Collection to give up memory:
                    GC.Collect();
                }
            }
        }

        /// <summary>
        /// Private Constructor guarantees that this class can never be instantiated.
        /// </summary>
        private ConfigurationManager()
        {
        }

        #endregion

        #region Properties

        //internal static XmlNamespaceManager NamespaceManager
        //{
        //    get
        //    {
        //        return namespaceManager;
        //    }
        //}

        internal static Hashtable FeatureSet
        {
            get
            {
                return featureSet;
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Forces the ConfigurationManager to initialize
        /// </summary>
        internal static void ForceInitialize()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataStructures\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DataStructures")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("DataStructures")]
[assembly: AssemblyCopyright("Copyright  MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("edcdd42f-d3cd-417e-9085-598f83c41511")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataAccess\CacheManager.cs ===
//using Microsoft.Subscriptions.Test;
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Xml;
using PerfServer.Tools;
//using Microsoft.Scs.Test.Common;

namespace PerfServer.DataAccess
{
    /// <summary>
    /// The CacheManager class represents the cache of accounts that is kept in the
    /// PerfAccountCache database.  It can cache accounts that were pre-populated as
    /// well as accounts created through signup scenarios.
    /// </summary>
    public abstract class CacheManager
    {
        protected enum Status
        {
            Unknown = 0,
            Uninitialized = 1,
            WorkInProgress = 2,
            Ready = 3,
            NoPreExisting = 4,
        };

        protected string name;
        protected Status status;
        protected double cachePercentage; // The overall percentage of items to cache
        protected int minimumNew; // The minimum number of new items to cache
        protected int totalNew; // Total number of new signups so far
        protected string connectionString;

        /// <summary>
        /// Constructor: Creates a new CacheManager object, associated with
        /// a specific row in the CacheManager table in the database.  No
        /// connection is made to the database.
        /// </summary>
        /// <param name="name">
        /// The name of the item type this object will be caching
        /// (example: Accounts)
        /// </param>
        protected CacheManager(string name)
        {
            this.name = name;
            this.minimumNew = 100;
            this.cachePercentage = 1.0;
        }

        /// <summary>
        /// Initializes this CacheManager object, reading values from the
        /// database specified in the connectionString parameter
        /// </summary>
        /// <param name="connectionString">
        /// The connection string used to open the PerfAccountCache database
        /// </param>
        /// <returns>
        /// Whether or not the CacheManager object initialized successfully
        /// </returns>
        protected bool Initialize(string connectionString)
        {
            // Store the connection string
            this.connectionString = connectionString;

            lock (this)
            {
                SqlConnection connection = null;
                SqlDataReader reader = null;
                try
                {
                    connection = new SqlConnection(this.connectionString);
                    connection.Open();
                    SqlCommand command = connection.CreateCommand();
                    command.CommandText = "GetCacheManagerInfo";
                    command.CommandType = CommandType.StoredProcedure;
                    command.Parameters.AddWithValue("@Name", this.name);
                    reader = command.ExecuteReader();

                    if (reader.Read())
                    {
                        // Load all the member variables from the database:
                        this.status = (Status)reader.GetInt32(0);
                        this.cachePercentage = reader.GetDouble(1);
                        this.minimumNew = reader.GetInt32(2);
                        this.totalNew = reader.GetInt32(3);
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                finally
                {
                    Database.Close(reader, connection);
                }
            }
        }

        /// <summary>
        /// Sets the status (both in the CacheManager object and in the
        /// Database)
        /// </summary>
        /// <param name="status">
        /// The new status
        /// </param>
        /// <param name="connection">
        /// An already opened connection.  It will still be open after this
        /// method returns.
        /// </param>
        /// <param name="transaction">
        /// An optional transaction to use when updating the database.  If this
        /// parameter is null, no transaction will be used.
        /// </param>
        protected void SetStatus(Status status, SqlConnection connection, SqlTransaction transaction)
        {
            SqlCommand command = new SqlCommand();
            command.Connection = connection;
            command.CommandText = "SetCacheManagerStatus";
            command.CommandType = CommandType.StoredProcedure;
            command.Parameters.AddWithValue("@Name", this.name);
            command.Parameters.AddWithValue("@Status", (int)status);

            if (transaction != null)
            {
                command.Transaction = transaction;
            }

            command.ExecuteNonQuery();
            this.status = status;
        }

        /// <summary>
        /// Sets the pre-existing data in the database row that corresponds to
        /// this CacheManager object.
        /// </summary>
        /// <param name="count">
        /// The number of items that are contained in the data
        /// </param>
        /// <param name="data">
        /// The data that represents the pre-existing items that should be
        /// stored in this CacheManager row
        /// </param>
        /// <param name="connection">
        /// An already opened connection.  It will still be open after this
        /// method returns.
        /// </param>
        /// <param name="transaction">
        /// An optional transaction to use when updating the database.  If this
        /// parameter is null, no transaction will be used.
        /// </param>
        protected void SetPreExistingData(int count, byte[] data, SqlConnection connection, SqlTransaction transaction)
        {
            SqlCommand command = new SqlCommand();
            command.Connection = connection;
            command.CommandText = "SetPreExistingData";
            command.CommandType = CommandType.StoredProcedure;
            command.CommandTimeout = 60000;

            command.Parameters.AddWithValue("@Name", this.name);
            command.Parameters.AddWithValue("@Count", count);
            SqlParameter param;
            if (data != null)
            {
                param = command.Parameters.Add("@Data", SqlDbType.Image);
                param.Value = data;
            }
            param = command.Parameters.Add("@Status", SqlDbType.Int);
            param.Direction = ParameterDirection.Output;

            if (transaction != null)
            {
                command.Transaction = transaction;
            }

            command.ExecuteNonQuery();
            this.status = (Status)param.Value;
        }

        /// <summary>
        /// Gets the list of Pre-Existing items from the database
        /// </summary>
        /// <param name="count">
        /// Will contain the number of pre-existing items 
        /// </param>
        /// <param name="data">
        /// Will contain the pre-existing items (in binary form)
        /// </param>
        protected void GetPreExistingItems(out int count, out byte[] data)
        {
            SqlConnection connection = null;
            SqlDataReader reader = null;
            try
            {
                connection = new SqlConnection(this.connectionString);
                connection.Open();

                SqlCommand command = connection.CreateCommand();
                command.CommandText = "GetPreExistingItems";
                command.CommandType = CommandType.StoredProcedure;
                command.CommandTimeout = 60000;
                command.Parameters.AddWithValue("@Name", this.name);

                reader = command.ExecuteReader();
                if (reader.Read())
                {
                    this.status = (Status)reader.GetInt32(0);
                    count = reader.GetInt32(1);
                    data = new byte[count * 8];
                    reader.GetBytes(2, 0, data, 0, count * 8);
                }
                else
                {
                    count = 0;
                    data = new byte[0];
                }
            }
            finally
            {
                Database.Close(reader, connection);
            }
        }

        /// <summary>
        /// Gets a Pre-Existing Item from the database.  If no Pre-Existing
        /// items exist, or if this CacheManager object is not ready to get one
        /// from the database, this method will throw an Exception.
        /// </summary>
        /// <returns>
        /// The index into the array of pre-existing items to use
        /// </returns>
        protected int GetPreExistingItem()
        {
            if (this.status != Status.Ready)
            {
                const string message = "The CacheManager cannot return a Pre-Existing Item due to not being in the Ready state (current state: {0})";
                throw new Exception(String.Format(message, this.status));
            }

            SqlConnection connection = null;
            SqlDataReader reader = null;
            try
            {
                connection = new SqlConnection(this.connectionString);
                connection.Open();

                SqlCommand command = connection.CreateCommand();
                command.CommandText = "GetPreExistingItem";
                command.CommandType = CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@Name", this.name);

                // Lock so that only one thread can be executing this stored procedure at a time
                lock (typeof(CacheManager))
                {
                    CommandBehavior behavior = CommandBehavior.SingleRow | CommandBehavior.SingleResult;
                    reader = command.ExecuteReader(behavior);
                    if (reader.Read())
                    {
                        return reader.GetInt32(0);
                    }
                    else
                    {
                        const string message = "The GetPreExistingItem stored procedure executed correctly, but didn't return any results.";
                        throw new Exception(message);
                    }
                }

            }
            finally
            {
                Database.Close(reader, connection);
            }
        }

        /// <summary>
        /// Increases the number of pre-existing items that can be cached by
        /// this CacheManager object.  This change is made in the database.
        /// </summary>
        protected void IncreaseMaxPreExistingItems()
        {
            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(this.connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "IncreaseMaxPreExistingItems";
                command.CommandType = CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@Name", this.name);
                command.ExecuteNonQuery();
            }
            finally
            {
                Database.Close(connection);
            }
        }

        /// <summary>
        /// Gets whether or not to newly created item
        /// </summary>
        public virtual bool CacheNewItem
        {
            get
            {
                if (this.totalNew < this.minimumNew)
                {
                    this.totalNew++;
                    if (this.totalNew == this.minimumNew)
                    {
                        SetNewItemTotal(this.totalNew);
                    }

                    // Return true because we haven't yet cached the
                    //  minimum number of new items
                    return true;
                }
                else if (GlobalRandom.NextDouble() < this.cachePercentage)
                {
                    // Return true because we are within the cache percentage
                    return true;
                }
                else
                {
                    // Return false - don't cache this item
                    return false;
                }
            }
        }

        /// <summary>
        /// Sets the number of New Items that have been cached
        /// </summary>
        /// <param name="total">
        /// The total number of new items that have been cached
        /// </param>
        private void SetNewItemTotal(int total)
        {
            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(this.connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "SetNewItemTotal";
                command.CommandType = CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@Name", this.name);
                command.Parameters.AddWithValue("@Total", total);

                command.ExecuteNonQuery();
            }
            finally
            {
                Database.Close(connection);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\DataAccess\Database.cs ===
using System;
using System.Text;
using System.Collections;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using Microsoft.Win32;
using System.Threading;
using PerfServer.Tools;

namespace PerfServer.DataAccess
{
    /// <summary>
    /// The Database class encapsulates all methods that access the
    /// PerfAccountCache database.  This is a static class, which means that it
    /// cannot be instantiated, and all of its methods are static.
    /// </summary>
    public sealed class Database
    {
        internal const string ConnectionStringTemplate = "Trusted_Connection=yes;Server={0};Database={1}";

        private static Hashtable buckets;
        private static string connectionString;
        private static AccountCache accountCache;
        private static Random rnd;

        /// <summary>Private Constructor: This class cannot be instantiated</summary>
        private Database() { }

        /// <summary>
        /// Static Constructor: Initializes the Database object
        /// </summary>
        /// <param name="connectionString">The connection string for connecting to the PerfAccountCache database</param>
        static Database()
        {
            rnd = new Random(DateTime.Now.Millisecond);
            // Load the connection string
            connectionString = (Configuration.ConnectionString != null)
                ? Configuration.ConnectionString
                : String.Format(ConnectionStringTemplate, "localhost", "PerfAccountCache");

            // Create the buckets Hashtable:
            buckets = Hashtable.Synchronized(new Hashtable());

            // Read the list of buckets from the database
            LoadAccountBuckets();

            // Initialize the Account Cache:
            Thread thread = new Thread(new ThreadStart(InitializeAccountCache));
            thread.Start();
        }

        /// <summary>Reads the Account Buckets from the database</summary>
        private static void LoadAccountBuckets()
        {
            SqlConnection connection = null;
            SqlDataReader reader = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();

                SqlCommand command = connection.CreateCommand();
                command.CommandText = "GetBuckets";
                command.CommandType = CommandType.StoredProcedure;
                reader = command.ExecuteReader();
                while (reader.Read())
                {
                    int id = reader.GetInt32(0);
                    string name = reader.GetString(1);
                    string schema = reader.GetString(2);
                    XmlDocument doc = new XmlDocument();
                    doc.LoadXml(schema);
                    Bucket bucket = new Bucket(id, name, doc.DocumentElement);
                    buckets[name] = bucket;
                }
            }
            finally
            {
                Close(reader, connection);
            }
        }

        /// <summary>
        /// Initializes the Account Cache
        /// </summary>
        private static void InitializeAccountCache()
        {
            accountCache = new AccountCache();
        }

        /// <summary>
        /// Gets the number of objects in each bucket
        /// </summary>
        /// <returns>
        /// A DataTable displaying the name of each bucket, and the number of
        /// objects in that bucket
        /// </returns>
        public static DataTable GetCountPerBucket()
        {
            SqlConnection connection = null;
            try
            {
                DataTable table = new DataTable("GetCountPerBucket");
                connection = new SqlConnection(connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "GetCountPerBucket";
                command.CommandType = CommandType.StoredProcedure;
                SqlDataAdapter adapter = new SqlDataAdapter(command);
                adapter.Fill(table);
                return table;
            }
            finally
            {
                Close(connection);
            }
        }

        /// <summary>
        /// Clears all the objects in the database
        /// </summary>
        public static void ClearObjects()
        {
            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "ClearObjects";
                command.CommandType = CommandType.StoredProcedure;
                command.ExecuteScalar();
            }
            finally
            {
                Close(connection);
            }
        }

        /// <summary>
        /// Adds a new Bucket to the Database
        /// </summary>
        /// <param name="name">The name of the new Bucket (must be unique)</param>
        /// <param name="definition">The definition element for the new Bucket</param>
        /// <returns>Whether or not the Bucket was added successfully</returns>
        public static void AddBucket(XmlElement definition)
        {
            string name = definition.GetAttribute("name");
            XmlElement condition = (XmlElement)definition.FirstChild;
            AddBucket(name, condition);
        }

        /// <summary>
        /// Adds a new Bucket to the Database
        /// </summary>
        /// <param name="name">The name of the new Bucket (must be unique)</param>
        /// <param name="condition">The XML condition for Items belonging to the new Bucket</param>
        public static void AddBucket(string name, XmlElement condition)
        {
            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "AddBucket";
                command.CommandType = CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@Name", name);
                SqlParameter param = command.Parameters.Add("@Condition", SqlDbType.NText);
                param.Value = condition.OuterXml;
                param = command.Parameters.Add("@ID", SqlDbType.Int);
                param.Direction = ParameterDirection.Output;
                command.ExecuteScalar();

                int id = (int)param.Value;
                Bucket bucket = new Bucket(id, name, condition);

                buckets[name] = bucket;
            }
            finally
            {
                Close(connection);
            }
        }

        /// <summary>
        /// Adds a new object to the database (the object will only be added
        /// if it meets the caching requirements)
        /// </summary>
        /// <param name="objectXml">The xml of the object to add</param>
        public static void AddNewObject(XmlElement objectXml)
        {
            bool addToCache = true;
            if (accountCache != null)
            {
                string source = objectXml.GetAttribute("source");
                if (source != "prepop")
                {
                    // Check to see if we need to cache this new account:
                    addToCache = accountCache.CacheNewItem;
                }
            }

            if (addToCache)
            {
                AddObject(objectXml);
            }
        }

        /// <summary>
        /// Adds an object to the database, regardless of whether or not it
        /// meets the caching requirements
        /// </summary>
        /// <param name="objectXml">The xml of the object to add</param>
        public static void AddObject(XmlElement objectXml)
        {
            string bucketList = GetBucketList(objectXml);
            if (bucketList == String.Empty)
            {
                string message = "Could not add this object to the Perf Account Cache database because it didn't match any buckets. The object XML is: " + objectXml.OuterXml;
                throw new ApplicationException(message);
            }

            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "AddObject";
                command.CommandType = CommandType.StoredProcedure;
                SqlParameter param = command.Parameters.Add("@Info", SqlDbType.Text);
                param.Value = objectXml.OuterXml;
                command.Parameters.AddWithValue("@BucketIdList", bucketList);
                command.ExecuteScalar();
            }
            finally
            {
                Close(connection);
            }
        }

        /// <summary>
        /// Gets a list of the bucket IDs that the specified object should be
        /// added to.
        /// </summary>
        /// <param name="objectXml">The xml info for the object</param>
        /// <returns>
        /// A list of semi-colon-separated bucket IDs that the object should be
        /// added to.
        /// </returns>
        private static string GetBucketList(XmlElement objectXml)
        {
            StringBuilder builder = new StringBuilder();
            foreach (Bucket bucket in buckets.Values)
            {
                if (bucket.Matches(objectXml))
                {
                    builder.Append(bucket.ID);
                    builder.Append(';');
                }
            }

            return builder.ToString();
        }

        /// <summary>
        /// Removes an Object from the Database
        /// </summary>
        /// <param name="objectId">The id for the object to remove</param>
        /// <param name="objectXml">The xml for the object to remove</param>
        public static void RemoveObject(int objectId, XmlElement objectXml)
        {
            string source = objectXml.GetAttribute("source");

            if (accountCache != null)
            {
                accountCache.MarkAccountClosed(source != "prepop");
            }

            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "DeleteObject";
                command.CommandType = CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@ObjectID", objectId);
                command.ExecuteNonQuery();
            }
            finally
            {
                Close(connection);
            }
        }

        /// <summary>
        /// Gets a pre-existing Account from the cache manager portion of the
        /// database.
        /// </summary>
        /// <returns>The account xml for the pre-existing account</returns>
        public static XmlElement GetPreExistingAccount()
        {
            XmlElement accountXml = null;
            if (accountCache != null)
            {
                accountXml = accountCache.GetExistingAccount();
                if (accountXml != null)
                {
                    accountXml.SetAttribute("source", "prepop");
                }
            }
            return accountXml;
        }

        /// <summary>
        /// Gets an object from the database.
        /// </summary>
        /// <param name="eligibleBuckets">The list of eligible Buckets to look in</param>
        /// <param name="objectId">The id of the object that was found (or -1 if no object was found)</param>
        /// <param name="objectInfo">The xml for the object that was found (or null if no object was found)</param>
        /// <returns>Whether or not an object was found</returns>
        public static bool GetObject(string bucketName, out int objectId, out XmlElement objectInfo)
        {
            Bucket bucket = buckets[bucketName] as Bucket;
            if (bucket != null)
            {
                if (GetObjectFromBucket(bucket.ID, out objectId, out objectInfo))
                {
                    return true;
                }
            }

            // If we get here, we have failed to find an account:
            objectId = -1;
            objectInfo = null;
            return false;
        }

        /// <summary>
        /// Gets an object from a particular Bucket
        /// </summary>
        /// <param name="bucketId">The id of the Bucket that the object must be in</param>
        /// <param name="objectId">The id of the object that was found (or -1 if no object was found)</param>
        /// <param name="objectInfo">The xml for the object that was found (or null if no object was found)</param>
        /// <returns>Whether or not an object was found</returns>
        private static bool GetObjectFromBucket(int bucketId, out int objectId, out XmlElement objectInfo)
        {
            SqlConnection connection = null;
            SqlDataReader reader = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();
                SqlCommand command = connection.CreateCommand();
                command.CommandText = "GetObject";
                command.CommandType = CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@BucketID", bucketId);

                CommandBehavior behavior = CommandBehavior.SingleRow | CommandBehavior.SingleResult;
                // Get rid of the lock 
                // since the bug with calling multiple APIs using the same account does not seem to be coming from the stored proc.
                //lock (typeof (Database)) // Only allow one thread to get an account at a time
                //{
                reader = command.ExecuteReader(behavior);
                if (reader != null && reader.Read())
                {
                    objectId = reader.GetInt32(0);
                    string xml = reader.GetString(1);
                    XmlDocument doc = new XmlDocument();
                    doc.LoadXml(xml);
                    objectInfo = doc.DocumentElement;
                    return true;
                }
                else
                {
                    objectId = -1;
                    objectInfo = null;
                    return false;
                }
                //}
            }
            finally
            {
                Close(reader, connection);
            }
        }

        /// <summary>
        /// Closes a Database Reader and Connection safely
        /// </summary>
        /// <param name="reader">The reader to close</param>
        /// <param name="connection">The connection to close</param>
        internal static void Close(SqlDataReader reader, SqlConnection connection)
        {
            if (reader != null)
            {
                reader.Close();
            }
            Close(connection);
        }

        /// <summary>
        /// Closes a Database Connection safely
        /// </summary>
        /// <param name="connection">The connection to close</param>
        internal static void Close(SqlConnection connection)
        {
            if (connection != null)
            {
                connection.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\IPerfServer.cs ===
//using Microsoft.Subscriptions.Test.SSPR.DataStructures;
using PerfServer.Tools;
using PerfServer.DataStructures;

using System;

namespace PerfServer.Model
{
    public interface IPerfServer
    {
        #region Properties

        string Country
        {
            get;
        }

        string Currency
        {
            get;
        }

        bool IsLoaded
        {
            get;
        }

        string Locale
        {
            get;
        }

        Puid Puid
        {
            get;
        }

        /// <summary>
        /// Gets the total latency for all the APIs that have been called on
        /// this IPerfServer instance since the last time it was cleared (or
        /// since it was created)
        /// </summary>
        uint TotalApiLatency
        {
            get;
        }

        bool PartnerChain
        {
            get;
            set;
        }

        string PartnerName
        {
            get;
            set;
        }

        #endregion

        #region Methods

        void Clear();

        void Create();

        void Create(string profileId);

        bool Load(string bucket);

        void Save();

        void SetTracer(Tracer tracer);

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\InvalidScenarioException.cs ===
using System;

namespace PerfServer.Model
{
    /// <summary>
    /// This Exception gets thrown if an invalid Scenario name was specified.
    /// </summary>
    public class InvalidScenarioException : ApplicationException
    {
        #region Constants

        private const string MessageTemplate = "An invalid scenario name ({0}) was specified.";

        #endregion

        #region Variables

        private readonly string scenario;

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new InvalidScenarioException
        /// </summary>
        /// <param name="scenario">The (invalid) name of the scenario that was given</param>
        public InvalidScenarioException(string scenario)
            : base(String.Format(MessageTemplate, scenario))
        {
            this.scenario = scenario;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets the (invalid) name of the Scenario that was specified
        /// </summary>
        public string Scenario
        {
            get
            {
                return this.scenario;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\MissingAccountTypeException.cs ===
using System;

namespace PerfServer.Model
{
    /// <summary>
    /// This Exception gets thrown if a Scenario could not find an Account of the type
    /// it needs to execute.
    /// </summary>
    public class MissingAccountTypeException : ApplicationException
    {
        #region Constants

        private const string MessageTemplate = "There were no accounts of the type(s) [{0}] in the PerfAccountCache database.  The [{1}] Scenario requires these accounts in order to execute.";

        #endregion

        #region Variables

        private readonly string scenario;
        private readonly string accountTypes;

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new MissingAccountTypeException
        /// </summary>
        /// <param name="scenario">The name of the scenario that threw the exception</param>
        /// <param name="accountTypes">The valid account types for the scenario
        /// (the exception is indicating that there are no accounts of these types)</param>
        public MissingAccountTypeException(string scenario, string accountTypes)
            : base(String.Format(MessageTemplate, accountTypes, scenario))
        {
            this.scenario = scenario;
            this.accountTypes = accountTypes;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets the Scenario that threw this MissingAccountTypeException
        /// </summary>
        public string Scenario
        {
            get
            {
                return this.scenario;
            }
        }

        /// <summary>
        /// Gets the valid account types for the scenario that threw this exception.  These
        /// are the account types of which there were no accounts in the system, causing
        /// the exception to be thrown.
        /// </summary>
        public string AccountTypes
        {
            get
            {
                return this.accountTypes;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\PerfCounters.cs ===
using System;
using System.Collections;
using System.Diagnostics;

namespace PerfServer.Model
{
    /// <summary>
    /// Summary description for PerfCounters.
    /// </summary>
    public class PerfCounters
    {
        /// <summary>
        /// This class contains the performance counters for each scenario.
        /// Each ScenarioCounters object will correspond to a single scenario,
        /// and will contain all the performance counters for that scenario.
        /// </summary>
        private class ScenarioCounters
        {
            private string scenarioName;
            private PerformanceCounter latency;
            private PerformanceCounter apiLatency;
            private PerformanceCounter totalSuccess;
            private PerformanceCounter totalFailure;
            private PerformanceCounter successRate;
            private PerformanceCounter failureRate;

            /// <summary>
            /// Constructor: Creates the individual performance counters for
            /// this ScenarioCounters object.
            /// </summary>
            /// <param name="scenarioName">
            /// The name of the scenario, which will also be the counter instance name.
            /// </param>
            public ScenarioCounters(string scenarioName)
            {
                this.scenarioName = scenarioName;

                latency = new PerformanceCounter(PerfCounters.CategoryName, "Latency", this.scenarioName, false);
                apiLatency = new PerformanceCounter(PerfCounters.CategoryName, "API Latency", this.scenarioName, false);
                totalSuccess = new PerformanceCounter(PerfCounters.CategoryName, "Total Success", this.scenarioName, false);
                successRate = new PerformanceCounter(PerfCounters.CategoryName, "Success Rate", this.scenarioName, false);
                totalFailure = new PerformanceCounter(PerfCounters.CategoryName, "Total Failure", this.scenarioName, false);
                failureRate = new PerformanceCounter(PerfCounters.CategoryName, "Failure Rate", this.scenarioName, false);
            }

            /// <summary>
            /// Increases the success related performance counters.
            /// </summary>
            public void IncrementSuccess()
            {
                totalSuccess.Increment();
                successRate.Increment();
            }

            /// <summary>
            /// Increase the failure related performance counters.
            /// </summary>
            public void IncrementFailure()
            {
                totalFailure.Increment();
                failureRate.Increment();
            }

            /// <summary>
            /// Sets the value of the latency performance counter.
            /// </summary>
            /// <param name="latency">The new latency value.</param>
            public void SetLatency(uint latency)
            {
                this.latency.RawValue = latency;
            }

            /// <summary>
            /// Sets the value of the API Latency Performance Counter
            /// </summary>
            /// <param name="latency">The new API Latency value</param>
            public void SetApiLatency(uint apiLatency)
            {
                this.apiLatency.RawValue = apiLatency;
            }
        }

        private const string CategoryName = "Scenario Counters";
        private const string CategoryDescription = "SPG Billing Usage Scenarios Perf Counters.";
        private static Hashtable CounterMap;

        static PerfCounters()
        {
            // Check if the performance category already exists in perfmon
            if (!PerformanceCounterCategory.Exists(CategoryName))
                RegisterCounters();

            CounterMap = Hashtable.Synchronized(new Hashtable());

            // Create and cache counter instances in memory
            CounterMap.Add("_All", new ScenarioCounters("_All"));
            foreach (string scenario in Scenario.ValidScenarioNames)
            {
                CounterMap.Add(scenario, new ScenarioCounters(scenario));
            }
        }

        /// <summary>
        /// Set up Performance Counter Category
        /// Initialize scenario counters for each scenario, then cache these
        /// counters in memory
        /// </summary>
        private static void RegisterCounters()
        {
            // Create the counters and set their properties.
            CounterCreationData[] creationData = new CounterCreationData[]
            {
                new CounterCreationData ("API Latency", "The total latency for all of the APIs that were called during a successfuly scenario execution", PerformanceCounterType.NumberOfItems32),
                new CounterCreationData ("Latency", "The total time between the beginning and end of a successful scenario execution", PerformanceCounterType.NumberOfItems32),
                new CounterCreationData ("Total Success", "Total number of successful scenario executions", PerformanceCounterType.NumberOfItems32),
                new CounterCreationData ("Success Rate", "Number of successful scenario executions per second", PerformanceCounterType.RateOfCountsPerSecond32),
                new CounterCreationData ("Total Failure", "Total number of failed scenario executions", PerformanceCounterType.NumberOfItems32),
                new CounterCreationData ("Failure Rate", "Number of failed scenario executions per second", PerformanceCounterType.RateOfCountsPerSecond32)
            };

            // Add the counters to the collection.
            CounterCreationDataCollection CounterCollection = new CounterCreationDataCollection(creationData);

            // Create the category in perfmon
            PerformanceCounterCategory.Create(CategoryName, CategoryDescription, PerformanceCounterCategoryType.MultiInstance, CounterCollection);
        }

        /// <summary>
        /// remove the counter category from perfmon
        /// clear counter cache in memory
        /// </summary>
        private static void UnregisterCounters()
        {
            PerformanceCounterCategory.Delete(CategoryName);
            CounterMap.Clear();
        }

        /// <summary>
        /// Increments the success-related counters for a particular scenario.
        /// If the specified scenario does not exist as a counter instance,
        /// then no counters will be updated.
        /// </summary>
        /// <param name="scenarioName">
        /// The name of the scenario, which must be defined in the Scenarios
        /// array.
        /// </param>
        public static void IncrementSuccess(string scenarioName)
        {
            ScenarioCounters counter = CounterMap[scenarioName] as ScenarioCounters;
            if (counter != null)
            {
                counter.IncrementSuccess();
                counter = CounterMap["_All"] as ScenarioCounters;
                if (counter != null)
                    counter.IncrementSuccess();
            }
        }

        /// <summary>
        /// Increments the failure-related counters for a particular scenario.
        /// If the specified scenario does not exist as a counter instance,
        /// then no counters will be updated.
        /// </summary>
        /// <param name="scenarioName">
        /// The name of the scenario, which must be defined in the Scenarios
        /// array.
        /// </param>
        public static void IncrementFailure(string scenarioName)
        {
            ScenarioCounters counter = CounterMap[scenarioName] as ScenarioCounters;
            if (counter != null)
            {
                counter.IncrementFailure();
                counter = CounterMap["_All"] as ScenarioCounters;
                if (counter != null)
                    counter.IncrementFailure();
            }
        }

        /// <summary>
        /// Set the latency counter value for a particular scenario.
        /// If the specified scenario does not exist as a counter instance,
        /// then no counters will be updated.
        /// </summary>
        /// <param name="scenarioName">
        /// The name of the scenario, which must be defined in the Scenarios
        /// array.
        /// </param>
        /// <param name="latency">
        /// The new latency value.
        /// </param>
        public static void SetLatency(string scenarioName, uint latency)
        {
            ScenarioCounters counter = CounterMap[scenarioName] as ScenarioCounters;
            if (counter != null)
            {
                counter.SetLatency(latency);
                counter = CounterMap["_All"] as ScenarioCounters;
                if (counter != null)
                {
                    counter.SetLatency(latency);
                }
            }
        }

        /// <summary>
        /// Set the API Latency counter value for a particular scenario.
        /// If the specified scenario does not exist as a counter instance,
        /// then no counters will be updated.
        /// </summary>
        /// <param name="scenarioName">
        /// The name of the scenario on which to update the API Latency Performance Counter
        /// </param>
        /// <param name="latency">
        /// The new API Latency value.
        /// </param>
        public static void SetApiLatency(string scenarioName, uint apiLatency)
        {
            ScenarioCounters counter = CounterMap[scenarioName] as ScenarioCounters;
            if (counter != null)
            {
                counter.SetApiLatency(apiLatency);
                counter = CounterMap["_All"] as ScenarioCounters;
                if (counter != null)
                {
                    counter.SetApiLatency(apiLatency);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\Scenario.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Web;

using System.Xml;
using PerfServer.Tools;

namespace PerfServer.Model
{
    /// <summary>
    /// Represents a single outermost Scenario, comprised of a sequence of APIs that can be
    /// executed together in sequence.  A scenario also has a list of associated AccountTypes.
    /// </summary>
    public class Scenario
    {
        #region ScenarioType Enumeration

        private enum ScenarioType
        {
            UACS,
            StringSrv
        }

        #endregion

        #region Helper Classes

        /// <summary>
        /// Represents a single Execution Step that is a part of a Scenario
        /// </summary>
        private interface ExecutionStep
        {
            /// <summary>
            /// Runs this Execution Step on a specified Account Manager object
            /// </summary>
            /// <param name="instance">The object on which to Run this ExecutionStep</param>
            /// <param name="trace">The Tracer object to use when writing trace messages</param>
            void Execute(IPerfServer instance, Tracer trace);
        }

        /// <summary>
        /// Represents a single API that will be called on an Account Manager
        /// </summary>
        private class API : ExecutionStep
        {
            #region Variables

            private readonly MethodInfo method;
            private readonly string name;
            private readonly object[] parameters;

            #endregion
            #region Constructors

            /// <summary>
            /// Creates a new API object from the specified XML Element
            /// </summary>
            /// <param name="xml">The element to read from</param>
            /// <param name="scenarioType">The type of scenario that this API is in</param>
            internal API(XmlElement xml, ScenarioType scenarioType)
            {
                this.name = xml.GetAttribute("name");

                Type[] paramTypes;
                XmlNodeList nodes = xml.SelectNodes("Parameter");
                if (nodes.Count == 0)
                {
                    this.parameters = null;
                    paramTypes = new Type[0];
                }
                else
                {
                    this.parameters = new object[nodes.Count];
                    paramTypes = new Type[nodes.Count];
                    for (int i = 0; i < nodes.Count; ++i)
                    {
                        XmlElement element = nodes[i] as XmlElement;
                        GetParameter(element, out this.parameters[i], out paramTypes[i]);
                    }
                }

                Type type;
                switch (scenarioType)
                {
                    default:
                    case ScenarioType.UACS:
                        {
                            type = typeof(uacsAcctMgr);
                            break;
                        }
                    case ScenarioType.StringSrv:
                        {
                            type = typeof(StringSrvAcctMgr);
                            break;
                        }

                }
                this.method = type.GetMethod(this.name, paramTypes);
                CheckMethod();
            }

            #endregion
            #region Properties

            /// <summary>
            /// Gets the Name of this API
            /// </summary>
            internal string Name
            {
                get
                {
                    return this.name;
                }
            }

            #endregion
            #region Methods

            /// <summary>
            /// Gets both the value and type of a specified parameter
            /// </summary>
            /// <param name="element">The parameter's XML Element (to read from)</param>
            /// <param name="value">The value of the parameter</param>
            /// <param name="type">The type of the parameter</param>
            private void GetParameter(XmlElement element, out object value, out Type type)
            {
                string typeString = element.GetAttribute("type");
                string valueString = element.InnerText;

                switch (typeString)
                {
                    case "Integer":
                        value = Int32.Parse(valueString);
                        type = typeof(Int32);
                        break;
                    case "Double":
                        value = Double.Parse(valueString);
                        type = typeof(Double);
                        break;
                    case "Boolean":
                        value = Boolean.Parse(valueString);
                        type = typeof(Boolean);
                        break;
                    case "Byte":
                        value = Byte.Parse(valueString);
                        type = typeof(Byte);
                        break;
                    case "String":
                    default:
                        value = valueString;
                        type = typeof(String);
                        break;
                }
            }

            /// <summary>
            /// Checks to make sure that the MethodInfo has been stored correctly by reflection,
            /// throwing an Exception if it has not.
            /// </summary>
            private void CheckMethod()
            {
                if (this.method == null)
                {
                    StringBuilder message = new StringBuilder();
                    message.Append("Could not find the specified API method: ");
                    message.Append(this.name);
                    message.Append(" (");
                    if (this.parameters != null)
                    {
                        for (int i = 0; i < this.parameters.Length; ++i)
                        {
                            message.Append(this.parameters[i].GetType().Name);
                            if (i < this.parameters.Length - 1)
                            {
                                message.Append(", ");
                            }
                        }
                    }
                    message.Append(")");
                    throw new Exception(message.ToString());
                }
            }

            /// <summary>
            /// Executes this API on a specified Account Manager object
            /// </summary>
            /// <param name="instance">The object on which to Execute this API</param>
            /// <param name="trace">The Tracer object to use when writing trace messages</param>
            public void Execute(IPerfServer instance, Tracer trace)
            {
                object output = this.method.Invoke(instance, this.parameters);
                trace.Write(this.name, output);
            }

            #endregion
        }

        /// <summary>
        /// Represents a single Scenario, comprised of a sequence of APIs that can be
        /// executed together in sequence.
        /// </summary>
        private class ScenarioExecutionStep : ExecutionStep
        {
            #region Variables

            private readonly ArrayList steps = new ArrayList();

            #endregion
            #region Properties

            /// <summary>
            /// Gets a list of the names of all the APIs called by this Scenario Execution Step
            /// </summary>
            internal ArrayList ApiNames
            {
                get
                {
                    ArrayList list = new ArrayList();
                    foreach (ExecutionStep step in this.steps)
                    {
                        if (step is API)
                        {
                            list.Add((step as API).Name);
                        }
                        else if (step is ScenarioExecutionStep)
                        {
                            ScenarioExecutionStep scenario = step as ScenarioExecutionStep;
                            foreach (string apiName in scenario.ApiNames)
                            {
                                list.Add(apiName);
                            }
                        }
                    }
                    return ArrayList.ReadOnly(list);
                }
            }

            #endregion
            #region Methods

            /// <summary>
            /// 
            /// </summary>
            /// <param name="step"></param>
            internal void AddExecutionStep(ExecutionStep step)
            {
                this.steps.Add(step);
            }

            /// <summary>
            /// Runs this Scenario Execution Step on a specified Account Manager object
            /// </summary>
            /// <param name="instance">The object on which to run this Scenario Execution Step</param>
            /// <param name="trace">The Tracer object to use when writing trace messages</param>
            public void Execute(IPerfServer instance, Tracer trace)
            {
                foreach (ExecutionStep step in this.steps)
                {
                    step.Execute(instance, trace);
                }
            }

            #endregion
        }

        #endregion

        #region Fields

        private const string NoAccountTypeNeeded = "None";
        private static readonly SortedList scenarios;
        private static Random rnd;

        private readonly string name;
        private readonly string accountTypes;
        private readonly bool chainPartner;
        private readonly string partnerName;
        private readonly ArrayList fillsBuckets;
        private readonly ScenarioExecutionStep outerExecutionStep;
        private readonly ScenarioType scenarioType;

        #endregion

        #region Constructors

        static Scenario()
        {
            scenarios = new SortedList();
            rnd = new Random(DateTime.Now.Millisecond);
        }

        /// <summary>
        /// Creates a new Scenario from the specified XML Element
        /// </summary>
        /// <param name="xml">The XML Element to read from</param>
        public Scenario(XmlElement xml)
        {
            this.name = xml.GetAttribute("name");
            this.accountTypes = xml.GetAttribute("accountTypes");
            this.outerExecutionStep = new ScenarioExecutionStep();
            
            // No more default scenario type.  Going to be so many in xbl that we should force explicit scenario type for all scenarios.
            //this.scenarioType = xml.HasAttribute("scenarioType")
            //    ? (ScenarioType)Enum.Parse(typeof(ScenarioType), xml.GetAttribute("scenarioType"), true)
            //    : ScenarioType.Normal;
            this.scenarioType = (ScenarioType)Enum.Parse(typeof(ScenarioType), xml.GetAttribute("scenarioType"), true);
            this.chainPartner = xml.HasAttribute("chainPartner")
                ? (xml.GetAttribute("chainPartner").ToLower() == "true" ? true : false) : true;
            this.partnerName = xml.HasAttribute("partnerName")
                ? xml.GetAttribute("partnerName") : null;
            this.fillsBuckets = xml.HasAttribute("fillsBuckets")
                ? new ArrayList(xml.GetAttribute("fillsBuckets").Split(',')) : null;

            foreach (XmlNode node in xml.ChildNodes)
            {
                if (node.NodeType == XmlNodeType.Element)
                {
                    XmlElement element = node as XmlElement;

                    // Add the APIs associated with this scenario:
                    if (element.Name == "API")
                    {
                        try
                        {
                            API api = new API(element, this.scenarioType);
                            this.outerExecutionStep.AddExecutionStep(api);
                        }
                        catch (Exception e)
                        {
                            throw new Exception("An error occurred while creating the Scenario Object for the [" + this.name + "] scenario.", e);
                        }
                    }
                    // Add any sub-scenarios associated with this Scenario:
                    else if (element.Name == "Scenario")
                    {
                        // Note that the sub-scenario must have already been declared.
                        string key = element.GetAttribute("name");
                        Scenario scenario = scenarios[key] as Scenario;
                        if (scenario != null)
                        {
                            this.outerExecutionStep.AddExecutionStep(scenario.outerExecutionStep);
                        }
                    }
                }
            }
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets the Name of this Scenario
        /// </summary>
        public string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        /// Gets a list of all Valid Scenario Names, sorted alphabetically.
        /// </summary>
        public static IList ValidScenarioNames
        {
            get
            {
                return scenarios.GetKeyList();
            }
        }

        /// <summary>
        /// Gets a list of the names of all the APIs called by this Scenario
        /// </summary>
        public ArrayList ApiNames
        {
            get
            {
                return this.outerExecutionStep.ApiNames;
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Creates an Account Manager object and executes this Scenario on that object.
        /// </summary>
        public void Execute()
        {
            Execute(String.Empty);
        }

        /// <summary>
        /// Creates an Account Manager object and executes this Scenario on that object.
        /// </summary>
        /// <param name="profileid">The ProfileID to use when executing this Scenario</param>
        public void Execute(string profileid)
        {
            Execute(profileid, Tracer.Default);
        }

        /// <summary>
        /// Creates an Account Manager object and executes this Scenario on that object.
        /// </summary>
        /// <param name="traceContext">The Trace Context to use when writing trace messages</param>
        public void Execute(TraceContext traceContext)
        {
            Execute(String.Empty, traceContext);
        }

        /// <summary>
        /// Creates an Account Manager object and executes this Scenario on that object.
        /// </summary>
        /// <param name="profileid">The ProfileID to use when executing this Scenario</param>
        /// <param name="traceContext">The Trace Context to use when writing trace messages</param>
        public void Execute(string profileid, TraceContext traceContext)
        {
            Execute(profileid, new ContextTracer(traceContext));
        }

        /// <summary>
        /// Creates an Account Manager object and executes this Scenario on that object.
        /// </summary>
        /// <param name="trace">The Tracer to use when writing trace messages</param>
        public void Execute(Tracer trace)
        {
            Execute(String.Empty, trace);
        }

        /// <summary>
        /// Creates an Account Manager object and executes this Scenario on that object.
        /// </summary>
        /// <param name="profileid">The ProfileID to use when executing this Scenario</param>
        /// <param name="trace">The Tracer to use when writing trace messages</param>
        public void Execute(string profileid, Tracer trace)
        {
            uint latency = 0;
            uint apiLatency = 0;
            bool success = false;
            try
            {
                IPerfServer instance;
                switch (this.scenarioType)
                {
                    default:
                    case ScenarioType.UACS:
                        {
                            instance = new uacsAcctMgr();
                            break;
                        }
                    case ScenarioType.StringSrv:
                        {
                            instance = new StringSrvAcctMgr();
                            break;
                        }
                }

                instance.SetTracer(trace);
                if (this.accountTypes == null || this.accountTypes == String.Empty)
                {
                    instance.Create(profileid);
                }
                else // if (this.accountTypes != NoAccountTypeNeeded)
                {
                    Boolean loaded = false;
                    string[] orBuckets = this.accountTypes.Split(new char[1] { ',' });
                    if (orBuckets.Length > 1)  // randomize the list of buckets.
                    {
                        Int32 count = orBuckets.Length;
                        for (int i = 0; i < count; i++)
                        {
                            Int32 rndIndex = rnd.Next(count);
                            string tmp = orBuckets[i];
                            orBuckets[i] = orBuckets[rndIndex];
                            orBuckets[rndIndex] = tmp;
                        }
                    }

                    foreach (string bucket in orBuckets)
                    {
                        if (loaded) continue;
                        if (bucket.Equals(NoAccountTypeNeeded))
                        {
                            loaded = true;
                        }
                        else if (instance.Load(bucket))
                        {
                            loaded = true;
                        }
                    }
                    if (!loaded)
                    {
                        throw new MissingAccountTypeException(this.name, this.accountTypes);
                    }
                }

                DateTime start = DateTime.Now;

                // add a preferred partner and enable chain if given
                instance.PartnerChain = this.chainPartner;
                instance.PartnerName = this.partnerName;

                // execute the APIs
                this.outerExecutionStep.Execute(instance, trace);
                // end execution of APIs

                TimeSpan span = DateTime.Now.Subtract(start);
                latency = (uint)span.TotalMilliseconds;
                apiLatency = instance.TotalApiLatency;

                if (instance.IsLoaded)
                {
                    instance.Save();
                }

                success = true;
            }
            finally
            {
                if (success)
                {
                    PerfCounters.IncrementSuccess(this.name);
                    PerfCounters.SetLatency(this.name, latency);
                    PerfCounters.SetApiLatency(this.name, apiLatency);
                }
                else
                {
                    PerfCounters.IncrementFailure(this.name);
                }
            }
        }

        /// <summary>
        /// Forces the Scenarios to initialize
        /// </summary>
        public static void ForceInitialize()
        {
            ConfigurationManager.ForceInitialize();
        }

        /// <summary>
        /// Loads a set of Scenarios from an XML Element
        /// </summary>
        /// <param name="xml">The XML Element to load from.</param>
        public static void LoadScenarios(XmlElement xml)
        {
            XmlNodeList nodeList = xml.SelectNodes("Scenario");
            foreach (XmlElement element in nodeList)
            {
                Scenario s = new Scenario(element);
                if (scenarios[s.name] == null)
                {
                    scenarios[s.Name] = s;
                }
            }
        }

        /// <summary>
        /// Gets a list of scenarios that will populate the specified bucket
        /// </summary>
        /// <param name="name">The name of the Bucket to be populated</param>
        public static Scenario GetRandomScenarioToFillBucket(string bucketName)
        {
            List<Scenario> bucketFillers = new List<Scenario>();
            foreach (string scenarioName in ValidScenarioNames)
            {
                Scenario scenario = scenarios[scenarioName] as Scenario;
                if (scenario.fillsBuckets != null &&
                    scenario.fillsBuckets.Contains(bucketName))
                {
                    bucketFillers.Add(scenario);
                }
            }

            return (bucketFillers.Count > 0)
                ? bucketFillers[rnd.Next(0, bucketFillers.Count - 1)]
                : null;
        }

        /// <summary>
        /// Gets a reference to a specific Scenario, throwing an InvalidScenarioException
        /// if the specified Scenario doesn't exist
        /// </summary>
        /// <param name="name">The name of the Scenario to look up</param>
        public static Scenario GetScenario(string name)
        {
            Scenario scenario = scenarios[name] as Scenario;
            if (scenario != null)
            {
                return scenario;
            }
            else
            {
                throw new InvalidScenarioException(name);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Model")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("Model")]
[assembly: AssemblyCopyright("Copyright  MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("edf96e8b-0ae7-40c6-9bf7-777215419002")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\uacsAcctMrg.cs ===
using System;
using PerfServer.Tools;
using live.client;
using live.common;
using live.lfm;
using live.server;
using live.protocol;
using System.Xml;
using System.Text;



namespace PerfServer.Model
{
    public class uacsAcctMgr : IPerfServer
    {

        protected Tracer tracer;
        private uint apiLatency;
        private DateTime startTime;
        private bool loaded = false;
        private XblUser user;

        public string CreateLiveAccount(string XblUserTierString, string PassportTypeString)
        {
            PassportType pt;
            XblUserTier xut;

            if (PassportTypeString.ToLower().Equals("real"))
                pt = PassportType.Real;
            else
                pt = PassportType.Fake;

            if (XblUserTierString.ToLower().Equals("silver"))
                xut = XblUserTier.Silver;
            else
                xut = XblUserTier.Gold;
            
            Xbox360 xbox = new Xbox360();
            XblUserSettings settings = new XblUserSettings(xut, pt);

            BeginLatency();
            user = xbox.SignUp.CreateUser(settings);
            EndLatency();
            
            // need to set loaded to true to enable save.
            this.loaded = true;

            return "Success";
        }


        #region IPerfServer Members

        public string Country
        {
            get { throw new System.NotImplementedException(); }
        }

        public string Currency
        {
            get { throw new System.NotImplementedException(); }
        }

        public bool IsLoaded
        {
            get { return this.loaded; }
        }

        public string Locale
        {
            get { throw new System.NotImplementedException(); }
        }

        public PerfServer.DataStructures.Puid Puid
        {
            get { throw new System.NotImplementedException(); }
        }

        public uint TotalApiLatency
        {
            get 
            {
                return this.apiLatency;
            }
        }

        // PARTNER CHAINING stubs        
        private string partnerName;
        private bool partnerChaining;

        public bool PartnerChain { get { return partnerChaining; } set { partnerChaining = value; } }
        public string PartnerName { get { return partnerName; } set { partnerName = value; } }

        public void Clear()
        {
            throw new System.NotImplementedException();
        }

        public void Create()
        {
            throw new System.NotImplementedException();
        }

        public void Create(string profileId)
        {
            throw new System.NotImplementedException();
        }

        public bool Load(string bucket)
        {
            throw new System.NotImplementedException();
        }

        public void Save()
        {
            XmlDocument xml = new XmlDocument();
            StringBuilder sb = new StringBuilder();
            sb.Append("<User>");
            sb.Append("<GamerTag>");
            sb.Append(this.user.Gamertag);
            sb.Append("</GamerTag>");
            sb.Append("<Puid>");
            sb.Append(this.user.Puid.ToString());
            sb.Append("</Puid>");
            sb.Append("<UserType>");
            sb.Append(this.user.Settings.UserType.ToString());
            sb.Append("</UserType>");
            sb.Append("</User>");
            xml.LoadXml(sb.ToString());
            DataAccess.Database.AddObject(xml.DocumentElement);
        }

        public void SetTracer(PerfServer.Tools.Tracer tracer)
        {
            this.tracer = tracer;
        }

        /// <summary>
        /// Begins calculating the latency for an API
        /// </summary>
        private void BeginLatency()
        {
            this.startTime = DateTime.Now;
        }

        /// <summary>
        /// Finishes calculating the latency for an API, adding the calculated latency to the
        /// running total
        /// </summary>
        private void EndLatency()
        {
            TimeSpan span = DateTime.Now.Subtract(this.startTime);
            this.startTime = DateTime.MinValue;

            this.apiLatency += (uint)span.TotalMilliseconds;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Model\StringSvrAcctMgr.cs ===
using System;
using PerfServer.Tools;
using live.client;
using live.common;
using live.lfm;
using live.server;
using live.protocol;
using System.Xml;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.StringServer;
using System.Net;
using System.IO;




namespace PerfServer.Model
{
    public class StringSrvAcctMgr : IPerfServer
    {

        protected Tracer tracer;
        private uint apiLatency;
        private DateTime startTime;
        private bool loaded = false;
        private Npdb npdb;

        public StringSrvAcctMgr()
        {
            npdb = new Npdb("ansxblob");
        }

        public string AddString()
        {
            XRLAdd2String addRequest = new XRLAdd2String();
            XRLAdd2Response addResponse;

            string DataString = "testString";

            addRequest.dwTitleID = 0xFFFE0000;
            addRequest.dwStringID = 0x1110000;
            addRequest.dtExpire = System.DateTime.UtcNow.AddMinutes(20);
            addRequest.szDefaultLocale = "en-US";
            addRequest.cLocaleStrings = 1;
            addRequest.fVetText = false;
            addRequest.rgLocaleStrings = new LocaleString[addRequest.cLocaleStrings];
            addRequest.rgLocaleStrings[0] = new LocaleString();
            addRequest.rgLocaleStrings[0].szLocale = "en-US";
            addRequest.rgLocaleStrings[0].szString = DataString;
            //IPEndPoint stringSvrEndpoint = npdb.GetInterfaceEndpoint("stringsvr");


            if (!addRequest.Execute(out addResponse))
            {
                throw new ApplicationException("AddString call fails.");
            }



            // need to set loaded to true to enable save.
            //this.loaded = true;

            return "Success";
        }

        byte[] myHeader;
        public virtual byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
        {
            StringBuilder sbURL;
            sbURL = new StringBuilder();
            sbURL.Append("POST ");
            sbURL.Append(" HTTP/1.0\r\n");
            sbURL.Append("Relja: true\r\n");  // This header was requested by SLamb to differentiate tools/tests and real clients
            sbURL.Append("Host: " + endPoint.ToString() + "\r\n");
            sbURL.Append("Content-Type: xon/" + ((int)live.common.XOService.StringService).ToString("x") + "\r\n");
            sbURL.Append("User-Agent: " + ((int)live.common.XOService.StringService).ToString("x") + "/0.10.4715\r\n");
            //sbURL.Append(CustomHeader);
            sbURL.Append("Content-Length: " + reqStream.Length + "\r\n\r\n");

            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            myHeader = AE.GetBytes(sbURL.ToString());
            return myHeader;
        }


        #region IPerfServer Members

        public string Country
        {
            get { throw new System.NotImplementedException(); }
        }

        public string Currency
        {
            get { throw new System.NotImplementedException(); }
        }

        public bool IsLoaded
        {
            get { return this.loaded; }
        }

        public string Locale
        {
            get { throw new System.NotImplementedException(); }
        }

        public PerfServer.DataStructures.Puid Puid
        {
            get { throw new System.NotImplementedException(); }
        }

        public uint TotalApiLatency
        {
            get
            {
                return this.apiLatency;
            }
        }

        // PARTNER CHAINING stubs        
        private string partnerName;
        private bool partnerChaining;

        public bool PartnerChain { get { return partnerChaining; } set { partnerChaining = value; } }
        public string PartnerName { get { return partnerName; } set { partnerName = value; } }

        public void Clear()
        {
            throw new System.NotImplementedException();
        }

        public void Create()
        {
            throw new System.NotImplementedException();
        }

        public void Create(string profileId)
        {
            throw new System.NotImplementedException();
        }

        public bool Load(string bucket)
        {
            throw new System.NotImplementedException();
        }

        public void Save()
        {

        }

        public void SetTracer(PerfServer.Tools.Tracer tracer)
        {
            this.tracer = tracer;
        }

        /// <summary>
        /// Begins calculating the latency for an API
        /// </summary>
        private void BeginLatency()
        {
            this.startTime = DateTime.Now;
        }

        /// <summary>
        /// Finishes calculating the latency for an API, adding the calculated latency to the
        /// running total
        /// </summary>
        private void EndLatency()
        {
            TimeSpan span = DateTime.Now.Subtract(this.startTime);
            this.startTime = DateTime.MinValue;

            this.apiLatency += (uint)span.TotalMilliseconds;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\DisplayObject.aspx.cs ===
using PerfServer.DataAccess;
using System;
using System.Xml;

namespace PerfServer
{
    /// <summary>
    /// Summary description for DisplayObject.
    /// </summary>
    public partial class DisplayObject : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            string bucket = Request.QueryString["bucket"];
            if (bucket == null)
            {
                string message = "Error: You must specify a bucket.";
                throw new ApplicationException(message);
            }

            int objectId;
            XmlElement objectInfo;
            if (Database.GetObject(bucket, out objectId, out objectInfo))
            {
                Database.AddObject(objectInfo);
                Response.ContentType = "Text/XML";
                Response.Write(objectInfo.OuterXml);
            }
            else
            {
                string message = "Error: Could not find an object in the specified bucket: " + bucket;
                throw new ApplicationException(message);
            }
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.Load += new System.EventHandler(this.Page_Load);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\AccountBuckets.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using PerfServer.DataAccess;

namespace PerfServer
{
    /// <summary>
    /// Summary description for AccountBuckets.
    /// </summary>
    public partial class AccountBuckets : System.Web.UI.Page
    {

        protected void Page_Load(object sender, EventArgs e)
        {
            if (!this.IsPostBack)
            {
                GetAccountBuckets();
            }
        }

        private void GetAccountBuckets()
        {
            this.BucketGrid.DataSource = Database.GetCountPerBucket();
            this.BucketGrid.DataBind();
        }

        protected void Clear_Click(object sender, System.EventArgs e)
        {
            Database.ClearObjects();
            GetAccountBuckets();
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.Load += new System.EventHandler(this.Page_Load);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\AccountBuckets.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PerfServer {
    
    
    public partial class AccountBuckets {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// BucketGrid control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid BucketGrid;
        
        /// <summary>
        /// Clear control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button Clear;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\DisplayObject.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PerfServer {
    
    
    public partial class DisplayObject {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Global.asax.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.IO;


namespace PerfServer
{
    public class Global : System.Web.HttpApplication
    {

        protected void Application_Start(object sender, EventArgs e)
        {
            Directory.SetCurrentDirectory(Server.MapPath("."));
            //live.common.Config.SetFilename(Server.MapPath("livelib.xml"));            
        }

        protected void Session_Start(object sender, EventArgs e)
        {

        }

        protected void Application_BeginRequest(object sender, EventArgs e)
        {

        }

        protected void Application_AuthenticateRequest(object sender, EventArgs e)
        {

        }

        protected void Application_Error(object sender, EventArgs e)
        {

        }

        protected void Session_End(object sender, EventArgs e)
        {

        }

        protected void Application_End(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\InvalidScenario.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using PerfServer.Model;

namespace PerfServer
{
    public partial class InvalidScenario : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (Request.QueryString["Scenario"] != null)
            {
                ScenarioLabel.Text = Request.QueryString["Scenario"];
            }
            ScenariosGrid.DataSource = Scenario.ValidScenarioNames;
            ScenariosGrid.DataBind();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\InvalidScenario.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PerfServer {
    
    
    public partial class InvalidScenario {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// ScenarioLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label ScenarioLabel;
        
        /// <summary>
        /// ScenariosGrid control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid ScenariosGrid;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Menu.aspx.cs ===
using PerfServer.Model;
//using PerfServer.PopulationFile;
using System;
using System.Collections;
using System.Text;
using System.Web.UI.WebControls;

namespace PerfServer.Webpages
{
    /// <summary>
    /// Summary description for Menu.
    /// </summary>
    public partial class Menu : System.Web.UI.Page
    {


        protected void Page_Load(object sender, EventArgs e)
        {
            if (!this.IsPostBack)
            {
                // Add an item for a random Profile
                //ListItem randomProfile = new ListItem("Random", "0");
                //this.ProfilesDropDown.Items.Add(randomProfile);

                // Add the list of Profiles:
                //foreach (PerfServer.PopulationFile.Profile profile in ConfigurationManager.ProfileSet.Profiles)
                //{
                 //   string itemValue = profile.ID.ToString();
                 //   string itemText = profile.ID.ToString() + ": " + profile.Name;
                 //   ListItem profileItem = new ListItem(itemText, itemValue);
                //    this.ProfilesDropDown.Items.Add(profileItem);
                //}

                //randomProfile.Selected = true;
            }

            //string profileId = this.ProfilesDropDown.SelectedValue;
            ConfigurationManager.Initialize();
            StringBuilder builder = new StringBuilder();
            foreach (string scenario in Scenario.ValidScenarioNames)
            {
                builder.Append("<a href=\"Scenarios.aspx?Scenario=");
                builder.Append(scenario);
                //if (profileId != "0")
                //{
                //    builder.Append("&profileid=");
                //    builder.Append(profileId);
                //}
                builder.Append("\" target=\"main\">");
                builder.Append(scenario);
                builder.Append("</a><br>");
            }
            this.ScenariosList.Text = builder.ToString();
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.Load += new System.EventHandler(this.Page_Load);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Menu.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PerfServer.Webpages {
    
    
    public partial class Menu {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// ProfilesDropDown control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ProfilesDropDown;
        
        /// <summary>
        /// ScenariosList control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Literal ScenariosList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Scenarios.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using PerfServer.Model;
using PerfServer.Tools;

namespace PerfServer
{
    public partial class _Default : System.Web.UI.Page
    {

        #region Constants

        private const string SuccessMessage = "[SCENARIO COMPLETED (SUCCESS)]";

        #endregion

        #region Variables

        private bool redirecting = false;

        #endregion


        protected void Page_Load(object sender, EventArgs e)
        {
            string scenarioName = Request.QueryString["scenario"];
            string profileID = Request.QueryString["profileid"];

            try
            {
                Scenario scenario = Scenario.GetScenario(scenarioName);
                scenario.Execute(profileID, this.Trace);
                Response.Write(SuccessMessage);
            }
            catch (MissingAccountTypeException exception)
            {
                GlobalLog.WriteWarning(exception.Message);
                Redirect("MissingAccountType.aspx?AccountType=" + exception.AccountTypes);
            }
            catch (InvalidScenarioException exception)
            {
                GlobalLog.WriteWarning(exception.Message);
                Redirect("InvalidScenario.aspx?Scenario=" + exception.Scenario);
            }
            catch (Exception exception)
            {
                // Ignore ThreadAbortExceptions: They are thrown by design from
                //  the Response.Redirect Method
                if (!redirecting || !(exception is System.Threading.ThreadAbortException))
                {
                    string message = "An Exception occurred while running the " + scenarioName + " Scenario";
                    GlobalLog.HandleException(message, exception);
                    // Rethrow the exception.  Let the default exception page show
                    //  up.  After all, this is for internal use, and that default page
                    //  is pretty nice for debugging.
                    //Response.Write(message + "/n");
                    //Response.Write(exception.Message + "/n");
                    //Response.Write(exception.StackTrace + "/n");
                    throw new Exception(message, exception);

                }
            }
        }


        #region Methods

        /// <summary>
        /// Redirects this page to another URL.
        /// </summary>
        /// <param name="targetUrl">The URL to redirect to</param>
        private void Redirect(string targetUrl)
        {
            try
            {
                Response.Redirect(targetUrl);
            }
            finally
            {
                // Set the redirecting flag, telling us to ignore ThreadAbortExceptions later
                this.redirecting = true;
            }
        }

        #endregion


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Scenarios.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PerfServer {
    
    
    public partial class _Default {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Welcome.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace PerfServer
{
    public partial class Welcome : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Tools\Configuration.cs ===
using System;
using Microsoft.Win32;

namespace PerfServer.Tools
{
    /// <summary>
    /// This class contains code to dynamically read Perf Server configuration
    /// info from the registry.
    /// </summary>
    public class Configuration
    {
        private const string RegistryPath = "Software\\Microsoft\\XBoxLive\\AcctDB";

        private static string connectionString;

        /// <summary>
        /// Static Constructor: Prepares the Configuration type for use. This
        /// is where the configuration values will be read from the registry.
        /// </summary>
        static Configuration()
        {
            RegistryKey key = Registry.LocalMachine.OpenSubKey(RegistryPath);

            if (key != null)
            {
                connectionString = key.GetValue("ConnectionString") as string;
            }
        }

        /// <summary>
        /// Private constructor: Prevents this class from being instantiated.
        /// </summary>
        private Configuration()
        {
        }

        /// <summary>
        /// Gets the connection string to use when connecting to the
        /// PerfAccountCache database
        /// </summary>
        public static string ConnectionString
        {
            get
            {
                return connectionString;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Welcome.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PerfServer {
    
    
    public partial class Welcome {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Tools\ContextTracer.cs ===
using System;
using System.Web;

namespace PerfServer.Tools
{
    /// <summary>
    /// Writes trace messages to a System.Web.TraceContext object.
    /// </summary>
    public class ContextTracer : Tracer
    {
        private TraceContext context;

        /// <summary>
        /// Creates a new ContextTracer object, that will write to a
        /// System.Web.TraceContext class.
        /// </summary>
        /// <param name="context">The TraceContext object to write to</param>
        public ContextTracer(TraceContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }
            this.context = context;
        }

        /// <summary>
        /// Writes a message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The message to write</param>
        public override void Write(string category, string message)
        {
            this.context.Write(category, message);
        }

        /// <summary>
        /// Writes a message to the appropriate trace location
        /// </summary>
        /// <param name="message">The message to write</param>
        public override void Write(string message)
        {
            this.context.Write(message);
        }

        /// <summary>
        /// Writes a warning message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The message to write</param>
        public override void Warn(string category, string message)
        {
            this.context.Warn(category, message);
        }

        /// <summary>
        /// Writes a warning message to the appropriate trace location
        /// </summary>
        /// <param name="message">The message to write</param>
        public override void Warn(string message)
        {
            this.context.Warn(message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Tools\GlobalLog.cs ===
using System;
using System.Diagnostics;

namespace PerfServer.Tools
{
    /// <summary>
    /// This class contains static methods for loggin output and handling
    /// exceptions.
    /// </summary>
    public class GlobalLog
    {
        private const string ApplicationName = "PerfServer";
        private const string LogName = "Application";
        private const int MaxMessageLength = 8192; // 16 KB is the max event log message size

        /// <summary>
        /// Private Constructor: Prevents this class from being instantiated.
        /// </summary>
        private GlobalLog() { }

        /// <summary>
        /// Static Constructor: Gets the Global Log ready for use.
        /// </summary>
        static GlobalLog()
        {
            // Create the Source, if it does not already exist:
            if (!EventLog.SourceExists(ApplicationName))
            {
                EventLog.CreateEventSource(ApplicationName, LogName);
            }
        }

        private static void WriteToEventLog(string message, EventLogEntryType type)
        {
            if (message.Length > MaxMessageLength)
            {
                // Write the truncated message and append the full message as data:
                string truncated = message.Substring(0, MaxMessageLength - 1);
                byte[] array = new byte[message.Length];
                for (int i = 0; i < array.Length; ++i)
                {
                    try
                    {
                        array[i] = Convert.ToByte(message[i]);
                    }
                    catch (OverflowException)
                    {
                        // If the character can't convert, use a * instead.
                        array[i] = Convert.ToByte('*');
                    }
                }
                EventLog.WriteEntry(ApplicationName, truncated, type, 0, 0, array);
            }
            else
            {
                EventLog.WriteEntry(ApplicationName, message, type);
            }
        }

        /// <summary>
        /// Writes some information to the log.
        /// </summary>
        /// <param name="message">The message to write</param>
        public static void WriteInformation(string message)
        {
            WriteToEventLog(message, EventLogEntryType.Information);
        }

        /// <summary>
        /// Writes a warning to the log.
        /// </summary>
        /// <param name="message">The message to write</param>
        public static void WriteWarning(string message)
        {
            WriteToEventLog(message, EventLogEntryType.Warning);
        }

        /// <summary>
        /// Writes an error to the log.
        /// </summary>
        /// <param name="message">The message to write</param>
        public static void WriteError(string message)
        {
            WriteToEventLog(message, EventLogEntryType.Error);
        }

        /// <summary>
        /// Handles an exception by writing the appropriate error message to the log.
        /// </summary>
        /// <param name="e">The exception to handle</param>
        public static void HandleException(Exception e)
        {
            WriteError(e.Message + Environment.NewLine + e.StackTrace);
        }

        /// <summary>
        /// Handles an exception by writing the appropriate error message to the log.
        /// </summary>
        /// <param name="message">An additonal message to log with the exception</param>
        /// <param name="e">The exception to handle</param>
        public static void HandleException(string message, Exception e)
        {
            WriteError(message + Environment.NewLine + e.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Tools\Tracer.cs ===
using System;
using System.Diagnostics;

namespace PerfServer.Tools
{
    /// <summary>
    /// Writes trace messages to the static System.Diagnostics.Trace class.
    /// Derived classes can write trace messages somewhere else.
    /// </summary>
    public class Tracer
    {
        /// <summary>
        /// The default (and only direct) instance of the Tracer class.
        /// </summary>
        public static readonly Tracer Default;

        /// <summary>
        /// Prepares the Tracer class for use
        /// </summary>
        static Tracer()
        {
            Tracer.Default = new Tracer();
        }

        /// <summary>
        /// Creates a new Tracer object, that will write to the static System.Diagnostics.Trace class.
        /// </summary>
        /// <remarks>
        /// This is protected, so only derived classes can actually be instantiated. Use
        /// Tracer.Default if you want to instantiate this class.
        /// </remarks>
        protected Tracer()
        {
        }

        /// <summary>
        /// Writes a message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The message to write</param>
        public virtual void Write(string category, string message)
        {
            Trace.WriteLine(message, category);
        }

        /// <summary>
        /// Writes a message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The object to write (using its ToString method)</param>
        public void Write(string category, object message)
        {
            Write(category, message.ToString());
        }

        /// <summary>
        /// Writes a message to the appropriate trace location
        /// </summary>
        /// <param name="message">The message to write</param>
        public virtual void Write(string message)
        {
            Trace.WriteLine(message);
        }

        /// <summary>
        /// Writes a message to the appropriate trace location
        /// </summary>
        /// <param name="message">The object to write (using its ToString method)</param>
        public void Write(object message)
        {
            Write(message.ToString());
        }

        /// <summary>
        /// Writes a warning message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The message to write</param>
        public virtual void Warn(string category, string message)
        {
            Trace.Fail(category, message);
        }

        /// <summary>
        /// Writes a warning message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The object to write (using its ToString method)</param>
        public void Warn(string category, object message)
        {
            Warn(category, message.ToString());
        }

        /// <summary>
        /// Writes a warning message to the appropriate trace location
        /// </summary>
        /// <param name="message">The message to write</param>
        public virtual void Warn(string message)
        {
            Trace.Fail(message);
        }

        /// <summary>
        /// Writes a warning message to the appropriate trace location
        /// </summary>
        /// <param name="category">The category for the message</param>
        /// <param name="message">The object to write (using its ToString method)</param>
        public void Warn(object message)
        {
            Warn(message.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Tools\GlobalRandom.cs ===
using System;
using System.Text;

namespace PerfServer.Tools
{
    /// <summary>
    /// A global random-number generator, which will eliminate the possibility that
    /// multiple sequences will get seeded with the same time value.
    /// </summary>
    public class GlobalRandom
    {
        private static readonly Random random;

        /// <summary>
        /// A Private Constructor, to prevent initialization of this class.
        /// </summary>
        private GlobalRandom() { }

        /// <summary>
        /// Static Constructor: Seeds the random number generator with the current time
        /// </summary>
        static GlobalRandom()
        {
            random = new Random();
        }

        /// <summary>
        /// Returns a random number between 0.0 and 1.0.
        /// </summary>
        /// <returns>
        /// A double-precision floating point number greater than or equal to 0.0, and less than 1.0.
        /// </returns>
        public static double NextDouble()
        {
            lock (random)
            {
                return random.NextDouble();
            }
        }

        /// <summary>
        /// Returns a positive random number.
        /// </summary>
        /// <returns>
        /// A number greater than or equal to 0.
        /// </returns>
        public static int Next()
        {
            lock (random)
            {
                return random.Next();
            }
        }

        /// <summary>
        /// Returns a positive random number less than the specified maximum.
        /// </summary>
        /// <param name="maxValue">
        /// The upper bound of the random number to be generated. maxValue must be greater than or equal to zero.
        /// </param>
        /// <returns>
        /// A number greater than or equal to zero, and less than maxValue.
        /// </returns>
        public static int Next(int maxValue)
        {
            lock (random)
            {
                return random.Next(maxValue);
            }
        }

        /// <summary>
        /// Returns a random number within a specified range.
        /// </summary>
        /// <param name="minValue">
        /// The lower bound of the random number returned.
        /// </param>
        /// <param name="maxValue">
        /// The upper bound of the random number returned. maxValue must be greater than or equal to minValue.
        /// </param>
        /// <returns>
        /// A number greater than or equal to minValue and less than maxValue. If minValue equals maxValue, minValue is returned.
        /// </returns>
        public static int Next(int minValue, int maxValue)
        {
            lock (random)
            {
                return random.Next(minValue, maxValue);
            }
        }

        /// <summary>
        /// Returns a positive random number less than the specified maximum.
        /// </summary>
        /// <param name="maxValue">
        /// The upper bound of the random number to be generated. maxValue must be greater than or equal to zero.
        /// </param>
        /// <returns>
        /// A number greater than or equal to zero, and less than maxValue.
        /// </returns>
        /// <remarks>
        /// If MaxValue is greater than Int32.MaxValue, this method will handle
        /// the work of figuring out the random number for you.
        /// </remarks>
        public static uint Next(uint maxValue)
        {
            if (maxValue > (uint)Int32.MaxValue)
            {
                int extra = (int)(maxValue - (uint)Int32.MaxValue);
                uint part1 = (uint)Next(Int32.MaxValue);
                uint part2 = (uint)Next(extra);
                return part1 + part2;
            }
            else
            {
                return (uint)Next((int)maxValue);
            }
        }

        public static string RandomValidPuid()
        {
            char[] netid = new char[16];

            for (int i = 0; i < 16; i++)
            {
                if (i < 2)
                {
                    netid[i] = '0';
                }
                else if (i == 2)
                {
                    netid[i] = Convert.ToChar(Next(1, 7) + (int)'0');
                }
                else
                {
                    int n = Next(0, 16);
                    if (n > 9)
                    {
                        netid[i] = Convert.ToChar((n - 10) + (int)'A');
                    }
                    else
                    {
                        netid[i] = Convert.ToChar(n + (int)'0');
                    }
                }
            }

            StringBuilder sNetID = new StringBuilder("");
            sNetID.Append(netid);
            return sNetID.ToString();
        }


        /// <summary>
        /// Returns a randomly chosen boolean value.
        /// </summary>
        /// <returns>
        /// A randomly chosen boolean value.
        /// </returns>
        public static bool NextBoolean()
        {
            return (GlobalRandom.Next(0, 2) == 1);
        }

        /// <summary>
        /// Fills the elements of a specified array of bytes with random numbers.
        /// </summary>
        /// <param name="buffer">
        /// An array of bytes to contain random numbers.
        /// </param>
        public static void NextBytes(byte[] buffer)
        {
            lock (random)
            {
                random.NextBytes(buffer);
            }
        }

        /// <summary>Creates a random string, containing only alphabetic characters</summary>
        /// <param name="length">The length of the string to create</param>
        /// <returns>The generated string</returns>
        public static string CreateAlphabeticString(int length)
        {
            StringBuilder builder = new StringBuilder(length);
            for (int i = 0; i < length; ++i)
            {
                int choice = GlobalRandom.Next(52);
                char c = (choice < 26)
                    ? (char)((int)'A' + choice)
                    : (char)((int)'a' + choice - 26);
                builder.Append(c);
            }
            return builder.ToString();
        }

        /// <summary>Creates a random string, containing only alphabetic characters</summary>
        /// <param name="minLength">The minimum length of the string to create (inclusive)</param>
        /// <param name="maxLength">The maximum length of the string to create (exclusive)</param>
        /// <returns>The generated string</returns>
        public static string CreateAlphabeticString(uint minLength, uint maxLength)
        {
            int length = Next((int)minLength, (int)maxLength);
            return CreateAlphabeticString(length);
        }

        /// <summary>Creates a random string, containing only numeric digit characters</summary>
        /// <param name="length">The length of the string to create</param>
        /// <returns>The generated string</returns>
        public static string CreateNumericString(int length)
        {
            StringBuilder builder = new StringBuilder(length);
            for (int i = 0; i < length; ++i)
            {
                char c = (char)GlobalRandom.Next((int)'0', (int)'9');
                builder.Append(c);
            }
            return builder.ToString();
        }

        /// <summary>Creates a random IP Address string in IPv4 format</summary>
        /// <returns>The generated string containing IP Address in IPv4 format</returns>
        public static string CreateIPAddress()
        {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < 3; ++i)
            {
                builder.Append(Next(0, 256));
                builder.Append('.');
            }

            builder.Append(Next(0, 256).ToString());

            return builder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\PerfServer\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PerfServer")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("PerfServer")]
[assembly: AssemblyCopyright("Copyright  MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\Main.cs ===
using System;
using System.Windows.Forms;

namespace PerfTsvGrapher
{
    public class Error
    {
        public static void Output(string s)
        {
            MessageBox.Show(s);
        }
    };

    public class MainClass
    {
        private static void ShowHelp()
        {
            Error.Output("Options:\n  -infile:filename (required) -- tsv file from perfmon to use as input\n  -outpath:path  -- location to write all generated html graph files\n  -outname:string  -- filename prefix for the output of this item\n  -start:date  -- first sample date (\"2009 may 12 13:45:00\")\n  -end:date  -- last sample date (\"2009 may 12 13:45:00\")\n  -counter:string  -- name of counter to use. (if omitted, all are used).  use multiple parameters for multiple counters\n  -width:number -- width (in pixels) of the generated graphs. default 800.\n  -height:number -- height (in pixels) of the generated graphs.  default 350.\n\nMust be specified together or not at all:\n  -ymin:number  -- force a specific lower y bound\n  -ymax:number  -- force a specific upper y bound\n");
        }

        //entry point
        [STAThreadAttribute]
        static void Main(string[] args)
        {
            System.DateTime startDate=System.DateTime.MinValue; //start date of graph range
            System.DateTime endDate=System.DateTime.MinValue; //end date of graph range
            string genPath="Output"; //path to dump output files to
            string inputTsvFile=null;
            string outName="default";
            System.Collections.Generic.LinkedList<string> counterList=new System.Collections.Generic.LinkedList<string>();
            System.Nullable<float> minY=null;
            System.Nullable<float> maxY=null;
            int graphWidth=800;
            int graphHeight=350;

            //handle args
            if (args.Length==0)
            {
                ShowHelp();
                return;
            }

            foreach (string arg in args)
            {
                string larg=arg.ToLower();
                if (larg.StartsWith("help") || larg.StartsWith("-help"))
                {
                    ShowHelp();
                    return;
                }
                else if (larg.StartsWith("-start:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        startDate=System.DateTime.Parse(parts[1]);
                    }
                }
                else if (larg.StartsWith("-end:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        endDate=System.DateTime.Parse(parts[1]);
                    }
                }
                else if (larg.StartsWith("-outpath:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        genPath=parts[1];
                    }
                }
                else if (larg.StartsWith("-infile:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        inputTsvFile=parts[1];
                    }
                }
                else if (larg.StartsWith("-outname:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        outName=parts[1];
                    }
                }
                else if (larg.StartsWith("-counter:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        counterList.AddLast(parts[1]);
                    }
                }
                else if (larg.StartsWith("-ymin:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        minY=float.Parse(parts[1]);
                    }
                }
                else if (larg.StartsWith("-ymax:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        maxY=float.Parse(parts[1]);
                    }
                }
                else if (larg.StartsWith("-width:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        graphWidth=int.Parse(parts[1]);
                    }
                }
                else if (larg.StartsWith("-height:"))
                {
                    string []parts=arg.Split(new char[]{':'});
                    if (parts.Length>=2)
                    {
                        graphHeight=int.Parse(parts[1]);
                    }
                }
                else
                {
                    Error.Output("Unhandled parameter: "+arg);
                }
            }

            if (inputTsvFile==null || inputTsvFile.Length==0)
            {
                ShowHelp();
                return;
            }

            //generate
            try
            {
                HtmlGraphGenerator gen=new HtmlGraphGenerator();
                gen.Generate(genPath, outName, inputTsvFile, startDate, endDate, counterList, minY, maxY, graphWidth, graphHeight);
            }
            catch (System.Exception e)
            {
                Error.Output(e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_perftsvgrapher_none_12.4.56.0_none_41ebab1bcfca86c6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=perftsvgrapher
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.manifest
XP_MANIFEST_PATH=manifests\msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.cat
XP_CATALOG_PATH=manifests\msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.cat
XP_PAYLOAD_PATH=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=perftsvgrapher,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfServer\Tools\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Tools")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("Tools")]
[assembly: AssemblyCopyright("Copyright  MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6d7c9ebc-527a-4e28-a20b-e103740263c7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_perftsvgrapher_none_12.4.56.0_none_41ebab1bcfca86c6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=perftsvgrapher
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.manifest
XP_MANIFEST_PATH=manifests\msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.cat
XP_CATALOG_PATH=manifests\msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0.cat
XP_PAYLOAD_PATH=msil_perftsvgrapher_no-public-key_12.4.56.0_x-ww_1d3e28d0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=perftsvgrapher,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PerfTsvGrapher\Generator.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Drawing;

namespace PerfTsvGrapher
{
    public class HtmlGraphGenerator
    {
        //generates html/graphic reports for all components for a specific period of time
        public void Generate(string dropPath, string dropName, string inputFile, System.DateTime startTime, System.DateTime endTime, System.Collections.Generic.LinkedList<string> counterList, System.Nullable<float> minY, System.Nullable<float> maxY, int graphWidth, int graphHeight)
        {
            bool autoStartFind=(startTime==System.DateTime.MinValue);
            bool autoEndFind=(endTime==System.DateTime.MinValue);

            System.IO.Directory.CreateDirectory(dropPath); //verify the output path exists

            System.Collections.Generic.LinkedList<string> failedCounterList=new System.Collections.Generic.LinkedList<string>(); //counters we could not find

            //open input file and get counter list and indices
            System.IO.TextReader streamReader=new System.IO.StreamReader(inputFile);
            string counterListLine=streamReader.ReadLine();
            if (counterListLine==null)
            {
                Error.Output("Empty input file?");
                return;
            }
            string []counterListLineParts=counterListLine.Split(new char[]{'\t'});

            if (counterList.Count==0) //they specified none, so use all counters
            {
                for (int i=1; i<counterListLineParts.Length; ++i)
                {
                    string machine, group, name;
                    SplitCounterString(counterListLineParts[i], out machine, out group, out name);

                    counterList.AddLast(group+"\\"+name);
                }
            }

            if (counterList.Count==0)
            {
                Error.Output("No counters found.");
                return;
            }

            System.Collections.Generic.List<CounterIndexData> counterInfo=new System.Collections.Generic.List<CounterIndexData>();
            foreach (string counter in counterList) //find the tsv index for each counter
            {
                bool found=false;
                for (int i=1; i<counterListLineParts.Length; ++i)
                {
                    string machine, group, name;
                    SplitCounterString(counterListLineParts[i], out machine, out group, out name);

                    string groupAndName=group+"\\"+name;
                    if (counter.ToLower()==groupAndName.ToLower()) //exact group+name match first
                    {
                        found=true;
                        counterInfo.Add(new CounterIndexData(machine, groupAndName, i));
                    }

                    if (counter.ToLower()==name.ToLower()) //match only name
                    {
                        found=true;
                        counterInfo.Add(new CounterIndexData(machine, group.Length>0?groupAndName:name, i));
                    }

                    if (counter.ToLower()==group.ToLower()) //group match
                    {
                        found=true;
                        counterInfo.Add(new CounterIndexData(machine, groupAndName, i));
                    }
                }

                if (!found)
                {
                    failedCounterList.AddLast(counter);
                }
            }

            if (failedCounterList.Count>0) //there are some in their list we could not find
            {
                string errList="";
                foreach (string c in failedCounterList)
                {
                    errList+=c+"\n";
                }

                Error.Output("Could not find some of the requested counters in the tsv file:\n"+errList);
            }

            //write the page head
            string html="<html>\n<head>\n<title>"+dropName+"</title>\n";
            html+="<meta http-equiv=\"cache-control\" content=\"no-cache\">\n</head>\n";
            html+="<body bgcolor=#000000 text=#dddddd link=#aaaaff vlink=#ffaaff alink=#ffccff>\n";

            html+="Generated: "+GetCurrentUserFriedlyTimestamp()+"<br><br>\n";
            html+="Component: "+dropName+"<br>\n";

            //set up the graph
            Bitmap graphBitmap=new Bitmap(graphWidth, graphHeight, System.Drawing.Imaging.PixelFormat.Format24bppRgb);
            GraphicsCommon.DateCountLineGraph graph=new GraphicsCommon.DateCountLineGraph(graphBitmap);
            graph.MinYRangeAmount=3.0f;
            graph.MinXRangeAmount=GraphicsCommon.DateCountLineGraph.HourWidth*2;
            graph.MinimumResolutionIsHour=true;

            foreach (CounterIndexData cid in counterInfo)
            {
                graph.DataSets.Add(cid.GraphData);
            }

            //add data value from the file
            string line;
            for (line=streamReader.ReadLine(); line!=null; line=streamReader.ReadLine())
            {
                string []lineParts=line.Split(new char[]{'\t'});
                string dateString=StripQuotes(lineParts[0]);
                System.DateTime sampleDate=System.DateTime.Parse(dateString);

                if (autoStartFind && (startTime>sampleDate || startTime==System.DateTime.MinValue))
                {
                    startTime=sampleDate;
                }

                if (autoEndFind && (endTime<sampleDate || endTime==System.DateTime.MinValue))
                {
                    endTime=sampleDate;
                }

                foreach (CounterIndexData cid in counterInfo)
                {
                    string valString=StripQuotes(lineParts[cid.TabIndex]).Trim();
                    if (valString.Length>0)
                    {
                        float value=float.Parse(valString);
                        graph.AddDateValue(cid.GraphData, sampleDate, value);

                        cid.TotalSampleValue+=value;
                        ++cid.TotalSamples;
                    }
                }
            }

            //adjust the graph bounds
            graph.RefreshDataBounds();
            float minX=graph.ConvertDateToX(startTime);
            float maxX=graph.ConvertDateToX(endTime);
            graph.EnforceXViewLimit=false;
            graph.XRange=maxX-minX;
            graph.XOffset=minX;
            graph.YOffset=0;

            if (minY==null || maxY==null)
            {
                graph.FitYBoundToXRange(false, true);
            }
            else
            {
                graph.EnforceYViewLimit=false;
                graph.YRange=(float)maxY-(float)minY;
                graph.YOffset=(float)minY;
            }

            //render it and save it to a file
            graph.RecalcIntervals(); //TODO: make this automatic (when used as a bitmap)
            graph.RefreshGraph();
            graphBitmap.Save(dropPath+"\\"+dropName+".png");

            html+="Showing range: "+startTime+" to "+endTime+" (UTC)<br>\n";
            html+="Showing values: "+FormatNumber(graph.YOffset)+" to "+FormatNumber(graph.YOffset+graph.YRange)+"<br><br>\n";
            html+="<table style=\"border: 2px white solid\"><tr><td><img src=\""+dropName+".png\"></td></tr></table><br><br>\n";

            //now add a table for the events
            html+="<table border=1>\n";
            html+="<tr><td>-<b>Machine</b>-</td> <td>-<b>Counter</b>-</td> <td>-<b>Average</b>-</td></tr>\n";
            foreach (GraphicsCommon.BasicLineGraph.DataSet ds in graph.DataSets)
            {
                CounterIndexData cid=(CounterIndexData)ds.Tag;

                html+="<tr>";
                html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+cid.Machine+"</font></td> ";
                html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+cid.Name+"</font></td> ";
                html+="<td><font color=#"+MakeHTMLColor(ds.Color)+">"+FormatNumber((cid.TotalSampleValue/(double)cid.TotalSamples))+"</font></td> ";
                html+="</tr>\n";
            }

            html+="</table>\n";

            //finish page
            html+="</body>\n</html>\n";
            System.IO.File.WriteAllText(dropPath+"\\"+dropName+".html", html);
        }

        //converts a color to an html color string
        string MakeHTMLColor(System.Drawing.Color color)
        {
            return ByteToHex(color.R)+ByteToHex(color.G)+ByteToHex(color.B);
        }

        string ByteToHex(byte b)
        {
            string s="";
            if ((b&0xf) < 0xa)
                s+=b&0xf;
            else
                s+=(char)((b&0xf)-10+(byte)'a');

            b>>=4;

            if ((b&0xf) < 0xa)
                s=(b&0xf)+s;
            else
                s=(char)((b&0xf)-10+(byte)'a')+s;

            return s;
        }

        //for purposes of making a filename from it
        private string SanitizeComponentName(string name)
        {
            name=name.Replace('/',',');
            name=name.Replace('\\',',');
            name=name.Replace('*',',');
            name=name.Replace('?',',');
            name=name.Replace('|',',');
            name=name.Replace('<',',');
            name=name.Replace('>',',');
            return name;
        }

        //returns a string with the current date and time, in both utc and pacific time
        private string GetCurrentUserFriedlyTimestamp()
        {
            DateTime dtNow=System.DateTime.UtcNow;
            string str=dtNow.ToString()+" UTC (";
            //DateTime dtPacific=System.TimeZoneInfo.ConvertTime(dtNow, System.TimeZoneInfo.indSystemTimeZoneById("Pacific Standard Time"));
            str+=dtNow.ToLocalTime().ToString();
            str+=" PST)";
            return str;
        }

        void SplitCounterString(string inCounter, out string outMachine, out string outGroup, out string outName)
        {
            outMachine="";
            outGroup="";
            string counter=StripQuotes(inCounter);

            string []parts=counter.Split(new char[]{'\\'}, System.StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length>=3 && counter.StartsWith("\\\\"))
            {
                outMachine=parts[0];
                outGroup=parts[1];
                outName=parts[2];
            }
            else if (parts.Length>=2)
            {
                outGroup=parts[0];
                outName=parts[1];
            }
            else
            {
                outName=parts[0];
            }
        }

        string FormatNumber(double num)
        {
            string numberFormat;
            if (num==0) numberFormat="{0:N0}";
            else if (Math.Abs(num)<1) numberFormat="{0:N6}";
            else if (Math.Abs(num)<10) numberFormat="{0:N4}";
            else if (Math.Abs(num)<100) numberFormat="{0:N2}";
            else if (Math.Abs(num)<10000) numberFormat="{0:N1}";
            else numberFormat="{0:N0}";

            return string.Format(numberFormat, num);
        }

        string StripQuotes(string s)
        {
            int start=0;
            int len=s.Length;

            if (s[0]=='\"')
            {
                ++start;
                --len;
            }

            if (s[s.Length-1]=='\"')
            {
                --len;
            }

            return s.Substring(start, len);
        }

        private class CounterIndexData
        {
            public string Machine;
            public string Name;
            public int TabIndex;
            public GraphicsCommon.BasicLineGraph.DataSet GraphData=new GraphicsCommon.BasicLineGraph.DataSet();

            public double TotalSampleValue=0;
            public int TotalSamples=0;

            public CounterIndexData(string machine, string name, int ind)
            {
                Machine=machine;
                Name=name;
                TabIndex=ind;
                GraphData.Tag=this;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PQHashPuid\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// PQHashPuid.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PQHashPuid\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PropTitle\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PPAGen\Ppa.cs ===
using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;

namespace PPAGen
{
	/// <summary>
	/// Summary description for Ppa.
	/// </summary>
	public class Ppa
	{
		public const int XONLINE_GAMERTAG_SIZE = 16;

		public Ppa()
		{
		}

		public static byte[] MakeHashableName(string s)
		{
			byte[] tempbytes = new ASCIIEncoding().GetBytes(s.ToUpper());

			byte[] data = new byte[XONLINE_GAMERTAG_SIZE];
			tempbytes.CopyTo(data, 0);

			return data;
		}

		public static string GenerateFakeSerial(string s, uint seq)
		{
			byte[] tempbytes = new UnicodeEncoding(false, false).GetBytes(s);
			byte[] name = new byte[28];
			tempbytes.CopyTo(name, 0);
			name[24] = (byte)(seq);
			name[25] = (byte)(seq >> 8);
			name[26] = (byte)(seq >> 16);
			name[27] = (byte)(seq >> 24);

			SHA1Managed sha = new SHA1Managed();
			byte[] hash = sha.ComputeHash(name);

			StringBuilder fakeserial = new StringBuilder("________||__");
			
			for (int i = 0; i < 12; i++)
				fakeserial[i] = (char)('0' + (hash[i] % 10));
			fakeserial[8] = '8';
			fakeserial[9] = '8';

			return fakeserial.ToString();
		}

		public static void GenPPA(string name, byte[] key, out byte[] sppa1, out byte[] ppa2)
		{
			SHA1 sha = new SHA1CryptoServiceProvider();

			byte[] hashablename = MakeHashableName(name);

			// Compute SPPA1
			HMACSHA1 hmac = new HMACSHA1(key);
			CryptoStream cs = new CryptoStream(Stream.Null, hmac, CryptoStreamMode.Write);
			cs.Write(hashablename, 0, hashablename.Length);
			cs.Close();
			sppa1 = sha.ComputeHash(hmac.Hash);

			// Computer PPA2
			hmac = new HMACSHA1(key);
			cs = new CryptoStream(Stream.Null, hmac, CryptoStreamMode.Write);
			cs.Write(hashablename, 0, hashablename.Length);
			cs.Write(hashablename, 0, hashablename.Length);
			cs.Close();

			byte[] longppa2 = hmac.Hash;
			ppa2 = new byte[8];
			for (int i = 0; i < 8; i++)
				ppa2[i] = longppa2[i];
		}

		private static char hexchar(byte b)
		{
			if (b < 10)
				return (char)('0' + b);
			else
				return (char)('a' + (b - 10));
		}

		private static string tohex(byte[] b)
		{
			string s = "";
			for (int i = 0; i < b.Length; i++)
				s += hexchar((byte)(b[i] >> 4)).ToString() + hexchar((byte)(b[i] & 15)).ToString();
			return s;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PropTitle\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PQHashPuid\PQHashPuid.cpp ===
// PQHashPuid.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

void Usage()
{
    printf( "Gives zero based index of P&N server user puid hashes to.\n" );
    printf( "Usage:\n" );
    printf( "   PQHashPuid <PUID> [<Servers>]\n" );
    printf( "       PUID - decimal int64, can be pasted from Query Analyzer.\n" );
    printf( "       Servers - decimal int, default is 2.\n\n" );
}

int _tmain(int argc, _TCHAR* argv[])
{
    if( (argc < 2) || (argc > 3) )
    {
        Usage();
        return( 1 );
    }

    __int64 qwPuid = _atoi64( argv[1] );
    if( 0 == qwPuid )
    {
        printf( "Input Error: Invalid PUID!\n" );
        Usage();
        return( 1 );
    }

    int iServers = 2;
    if( 3 == argc )
    {
        iServers = atoi( argv[2] );
        if( 0 == iServers)
        {
            printf( "Input Error: Invalid Server Count!\n" );
            Usage();
            return( 1 );
        }
    }

    unsigned long dwLo = (unsigned long)qwPuid & 0xffffffff;
    unsigned long dwHi = (unsigned long)((qwPuid >> 32) & 0xffffffff);
    
    printf( "Hash = %d", ((dwLo + dwHi) % 95219) % iServers );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\pscases\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PropTitle\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_proptitle_none_12.4.56.0_none_47ce0d138dd44a98
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=proptitle
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.manifest
XP_MANIFEST_PATH=manifests\msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.cat
XP_CATALOG_PATH=manifests\msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.cat
XP_PAYLOAD_PATH=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=proptitle,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PropTitle\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;

namespace PropTitle
{
    class PropTitle
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {			
            // Parameters
            uint    title;
            string  platform;
            string  envName;
            uint version;

            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse command line
            if (Environment.GetCommandLineArgs().Length!=5)
            {
                Console.WriteLine("Usage: PropTitle environment titleID version platform");
                Console.WriteLine("  environment: The name of the environment (from stf.xml)");
                Console.WriteLine("  titleID: The title ID in hex (0x is optional)");
                Console.WriteLine("  version: The version to prop it as.");
                Console.WriteLine("  Platform: Platform of the title: XBOX, XENON, or PC");
                return;
            }

            envName=Environment.GetCommandLineArgs()[1];
            title=(uint)Hexer.fromhex(Environment.GetCommandLineArgs()[2]);
            version=uint.Parse(Environment.GetCommandLineArgs()[3]);
            platform=Environment.GetCommandLineArgs()[4];

            AuthContext.ClientTypes clientType;
            if (platform.ToLower()=="xenon") clientType=AuthContext.ClientTypes.Xenon;
            else if (platform.ToLower()=="xbox") clientType=AuthContext.ClientTypes.Xbox;
            else if (platform.ToLower()=="pc") clientType=AuthContext.ClientTypes.Panorama;
            else
            {
                throw new System.Exception("Invalid platform specified.");
            }

            // Initialize the STF
            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found = false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == envName.ToLower())
                {
                    Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                Console.WriteLine("Error - unknown environment '{0}' specified (not in stf.xml?).", envName);
                return;
            }

            Global.ResetEnvironment();

            // Try to prop it
            LiveTitle.PropTitle(title,version,clientType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\pstctransfer\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PPAGen\PpaGen.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Text;
using System.Text.RegularExpressions;

namespace PPAGen
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class PpaGen : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.TextBox textBox2;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label8;
		private System.Windows.Forms.Label label9;
		private System.Windows.Forms.NumericUpDown numericUpDown1;
		private System.Windows.Forms.TextBox textBox3;
		private System.Windows.Forms.TextBox textBox4;
		private System.Windows.Forms.TextBox textBox5;
		private System.Windows.Forms.Label label1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public PpaGen()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			textBox1.Text = "";
			AnyTextChanged();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.textBox2 = new System.Windows.Forms.TextBox();
			this.label4 = new System.Windows.Forms.Label();
			this.label5 = new System.Windows.Forms.Label();
			this.label6 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.label8 = new System.Windows.Forms.Label();
			this.label9 = new System.Windows.Forms.Label();
			this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();
			this.textBox3 = new System.Windows.Forms.TextBox();
			this.textBox4 = new System.Windows.Forms.TextBox();
			this.textBox5 = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();
			this.SuspendLayout();
			// 
			// textBox1
			// 
			this.textBox1.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.textBox1.Location = new System.Drawing.Point(88, 16);
			this.textBox1.MaxLength = 15;
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(112, 20);
			this.textBox1.TabIndex = 0;
			this.textBox1.Text = "MMMMMMMMMMMMMMM";
			this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
			// 
			// textBox2
			// 
			this.textBox2.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.textBox2.Location = new System.Drawing.Point(88, 48);
			this.textBox2.MaxLength = 32;
			this.textBox2.Name = "textBox2";
			this.textBox2.Size = new System.Drawing.Size(232, 20);
			this.textBox2.TabIndex = 2;
			this.textBox2.Text = "00000000000000000000000000000000";
			this.textBox2.TextChanged += new System.EventHandler(this.textBox2_TextChanged);
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(16, 16);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(72, 24);
			this.label4.TabIndex = 5;
			this.label4.Text = "Gamertag / Serial:";
			this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(16, 48);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(32, 24);
			this.label5.TabIndex = 6;
			this.label5.Text = "Key:";
			this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label6
			// 
			this.label6.Location = new System.Drawing.Point(16, 144);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(64, 24);
			this.label6.TabIndex = 7;
			this.label6.Text = "FakeSerial:";
			this.label6.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label7
			// 
			this.label7.Location = new System.Drawing.Point(16, 80);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(48, 24);
			this.label7.TabIndex = 8;
			this.label7.Text = "SPPA1:";
			this.label7.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label8
			// 
			this.label8.Location = new System.Drawing.Point(16, 112);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(40, 24);
			this.label8.TabIndex = 9;
			this.label8.Text = "PPA2:";
			this.label8.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label9
			// 
			this.label9.Location = new System.Drawing.Point(216, 16);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(40, 24);
			this.label9.TabIndex = 10;
			this.label9.Text = "Seq #:";
			this.label9.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// numericUpDown1
			// 
			this.numericUpDown1.Location = new System.Drawing.Point(264, 16);
			this.numericUpDown1.Maximum = new System.Decimal(new int[] {
																		   -1,
																		   0,
																		   0,
																		   0});
			this.numericUpDown1.Minimum = new System.Decimal(new int[] {
																		   1,
																		   0,
																		   0,
																		   0});
			this.numericUpDown1.Name = "numericUpDown1";
			this.numericUpDown1.Size = new System.Drawing.Size(56, 20);
			this.numericUpDown1.TabIndex = 11;
			this.numericUpDown1.Value = new System.Decimal(new int[] {
																		 2,
																		 0,
																		 0,
																		 0});
			this.numericUpDown1.ValueChanged += new System.EventHandler(this.numericUpDown1_ValueChanged);
			// 
			// textBox3
			// 
			this.textBox3.Font = new System.Drawing.Font("Courier New", 8.25F);
			this.textBox3.Location = new System.Drawing.Point(88, 80);
			this.textBox3.Name = "textBox3";
			this.textBox3.ReadOnly = true;
			this.textBox3.Size = new System.Drawing.Size(288, 20);
			this.textBox3.TabIndex = 12;
			this.textBox3.Text = "0000000000000000000000000000000000000000";
			// 
			// textBox4
			// 
			this.textBox4.Font = new System.Drawing.Font("Courier New", 8.25F);
			this.textBox4.Location = new System.Drawing.Point(88, 112);
			this.textBox4.Name = "textBox4";
			this.textBox4.ReadOnly = true;
			this.textBox4.Size = new System.Drawing.Size(120, 20);
			this.textBox4.TabIndex = 13;
			this.textBox4.Text = "0000000000000000";
			// 
			// textBox5
			// 
			this.textBox5.Font = new System.Drawing.Font("Courier New", 8.25F);
			this.textBox5.Location = new System.Drawing.Point(88, 144);
			this.textBox5.Name = "textBox5";
			this.textBox5.ReadOnly = true;
			this.textBox5.Size = new System.Drawing.Size(96, 20);
			this.textBox5.TabIndex = 14;
			this.textBox5.Text = "000000000000";
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(88, 96);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(288, 72);
			this.label1.TabIndex = 15;
			this.label1.Text = "Gamertag / Serial is neither a valid Gamertag nor serial number.";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// PpaGen
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(390, 180);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.textBox5,
																		  this.textBox4,
																		  this.textBox3,
																		  this.numericUpDown1,
																		  this.label8,
																		  this.label7,
																		  this.label6,
																		  this.label5,
																		  this.label4,
																		  this.textBox2,
																		  this.textBox1,
																		  this.label9,
																		  this.label1});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.MaximizeBox = false;
			this.Name = "PpaGen";
			this.Text = "PpaGen";
			this.Load += new System.EventHandler(this.PpaGen_Load);
			((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new PpaGen());
		}

		private byte unhex(char c)
		{
			if (c >= '0' && c <= '9')
				return (byte)(c - '0');
			else if (c >= 'a' && c <= 'z')
				return (byte)(c - 'a' + 10);
			else if (c >= 'A' && c <= 'Z')
				return (byte)(c - 'A' + 10);
			return 0;
		}

		private char hex(byte b)
		{
			if (b < 10)
				return (char)('0' + b);
			else
				return (char)('a' + (b - 10));
		}

		private void AnyTextChanged()
		{
			string gamertag = textBox1.Text;
			string keystring = textBox2.Text;

			bool vis = (IsGamertag(gamertag) || IsSerial(gamertag)) && IsKey(keystring);
			label1.Visible = !vis;
			label7.Visible = vis;
			textBox3.Visible = vis;
			label8.Visible = vis;
			textBox4.Visible = vis;

			numericUpDown1.Visible = vis && IsSerial(gamertag);
			label9.Visible = vis && IsSerial(gamertag);
			label6.Visible = vis && IsSerial(gamertag);
			textBox5.Visible = vis && IsSerial(gamertag);

			if (!IsGamertag(gamertag) && !IsSerial(gamertag))
			{
				label1.Text = "Gamertag / Serial is neither a valid Gamertag nor serial number.";
				return;
			}
			else if (!IsKey(keystring))
			{
				label1.Text = "Key must be 16 bytes in hex.";
				return;
			}

			if (IsSerial(gamertag))
				textBox5.Text = Ppa.GenerateFakeSerial(gamertag, Decimal.ToUInt32(numericUpDown1.Value));

			byte[] key = new byte[16];
			for (int i = 0; i < 16; i++)
			{
				key[i] = (byte)((unhex(keystring[i*2]) << 4) + unhex(keystring[i*2+1]));
			}

			byte[] sppa1;
			byte[] ppa2;
			Ppa.GenPPA(gamertag, key, out sppa1, out ppa2);

			textBox3.Text = "";
			for (int i = 0; i < sppa1.Length; i++)
				textBox3.Text += hex((byte)(sppa1[i] >> 4)).ToString() + hex((byte)(sppa1[i] & 15)).ToString();

			textBox4.Text = "";
			for (int i = 0; i < ppa2.Length; i++)
				textBox4.Text += hex((byte)(ppa2[i] >> 4)).ToString() + hex((byte)(ppa2[i] & 15)).ToString();
		}

		private bool IsKey(string s)
		{
			Regex regex = new Regex(@"^(?:0x)?[a-f0-9]{32}$", RegexOptions.IgnoreCase);
			if (regex.Match(s).Success)
				return true;
			return false;
		}

		private bool IsGamertag(string s)
		{
			Regex regex = new Regex(@"^(?=.{1,15}$)[a-z](?:[a-z0-9]| [a-z0-9])*$", RegexOptions.IgnoreCase);
			if (regex.Match(s).Success)
				return true;
			return false;
		}

		private bool IsSerial(string s)
		{
			Regex regex = new Regex(@"^\d{12}$");
			if (regex.Match(s).Success)
				return true;
			return false;
		}

		private void textBox1_TextChanged(object sender, System.EventArgs e)
		{
			AnyTextChanged();
		}

		private void textBox2_TextChanged(object sender, System.EventArgs e)
		{
			AnyTextChanged();
		}

		private void PpaGen_Load(object sender, System.EventArgs e)
		{
			AnyTextChanged();
		}

		private void numericUpDown1_ValueChanged(object sender, System.EventArgs e)
		{
			AnyTextChanged();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\PropTitle\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_proptitle_none_12.4.56.0_none_47ce0d138dd44a98
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=proptitle
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.manifest
XP_MANIFEST_PATH=manifests\msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.cat
XP_CATALOG_PATH=manifests\msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8.cat
XP_PAYLOAD_PATH=msil_proptitle_no-public-key_12.4.56.0_x-ww_3e94a4d8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=proptitle,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\pstctransfer\Class1.cs ===
using System;
using ProductStudio;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;

namespace PSTCTransfer
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
        static DirectoryClass dc = new DirectoryClass();
        static Datastore dsSrc = null;
        static Datastore dsDst = null;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            if(args.Length != 2)
                return;

            dc.Connect(null, null, null);
            Product p = dc.GetProductByName("Xenon");
            dsSrc = p.Connect(null, null, null);
            p = dc.GetProductByName("Zone Bugs External");
            dsDst = p.Connect(null, null, null);

            Copy(args[0].ToLower(), args[1].ToLower());
        } // Main

        static string GetCurrentUser()
        {
            string u = System.Security.Principal.WindowsIdentity.GetCurrent().Name;
            int idx = u.IndexOf('\\');
            if(idx > -1)
            {
                return u.Substring(idx + 1);
            }
            return u;
        }

        static int GetTestCaseID(int curID)
        {
            ProductStudio.QueryClass q = new QueryClass();
            q.DatastoreItemType = PsDatastoreItemTypeEnum.psDatastoreItemTypeTestCase;
            q.SelectionCriteria = 
@"<Query>
    <Expression Column='Test SubArea' FieldType='16' Operator='equals'>
        <String>" + curID.ToString() + @"</String> 
    </Expression>
</Query>";

            q.CountOnly = false;
            DatastoreItemListClass psDataList = new ProductStudio.DatastoreItemListClass();
            psDataList.Query = q;
            psDataList.Datastore = dsDst;
            psDataList.Execute();
                
            foreach (ProductStudio.DatastoreItem psItem in psDataList.DatastoreItems)
            {
                return Convert.ToInt32(psItem.Fields["ID"].Value);
            }

            return -1;
        }

        static void Copy(string src, string dst)
        {
            Node n = dsDst.get_RootNodeEx(PsCoreTreeTypeEnum.psCoreTreeTypeProduct);
            string tmp = n.Name.ToLower();
            while(tmp != dst)
            {
                bool fMatch = false;
                foreach(Node n2 in n.Nodes)
                {
                    string nm = n2.Name.ToLower();
                    if(dst.StartsWith(tmp + "\\" + nm))
                    {
                        fMatch = true;
                        n = n2;
                        tmp += "\\" + nm;
                        break;
                    }
                }
                if(!fMatch)
                {
                    Console.WriteLine("Could not find a matching node in Zone Bugs External for " + dst);
                    return;
                }
            }

            string user = GetCurrentUser();
            SqlCommand com;

            uint casesNew = 0, casesUpdated = 0, casesMatched = 0;

            using(SqlConnection conn = new SqlConnection("server=" + dsSrc.DomainComputerName + ";database=" + dsSrc.ProductName + "1Issue;Integrated Security=SSPI"))
            {
                conn.Open();
                com = conn.CreateCommand();
                com.CommandType = CommandType.Text;
                com.CommandText = @"
select tc.[id], tc.title, txts.words
                from [test caselatest] as tc
			left join [test caselongtexts] as txts on tc.[id]=txts.[id] and fldname = 'Steps'
                where tc.[Tree Path] = @pathdata
		and (txts.ADdedDAte is null or txts.AddedDate >= (select max(t2.AddedDate) 
					from [test caselongtexts] as t2
					where t2.[id] = tc.[id] and fldname = 'Steps'))
	order by tc.[id], txts.addeddate
";
                SqlParameter p = com.Parameters.Add("@pathdata", SqlDbType.NVarChar);
                p.Value = src;

                DatastoreItem di = null;

                using(SqlDataReader r = com.ExecuteReader())
                {
                    while(r.Read())
                    {
                        int curid = r.GetInt32(0);
                        string newtitle = "", newsteps = "";
                        if(!r.IsDBNull(1))
                            newtitle = r.GetString(1);
                        if(!r.IsDBNull(2))
                            newsteps = r.GetString(2);
                        Console.Write("{0}{2}: {1}", curid, newtitle, (newsteps.Length == 0 ? " **Steps are blank**" : ""));
                        int existingtcid = GetTestCaseID(curid);
                        if(existingtcid != -1)
                        {
                            di = dsDst.GetDatastoreItem(PsDatastoreItemTypeEnum.psDatastoreItemTypeTestCase, existingtcid, null);
                            string title = "", steps = "";
                            if(di.Fields["Title"].Value != null)
                                title = di.Fields["Title"].Value.ToString();
                            if(di.Fields["Steps"].Value != null)
                                steps = di.Fields["Steps"].Value.ToString();
                            if(steps != newsteps || title != newtitle)
                            {
                                di.Edit(PsItemEditActionEnum.psDatastoreItemEditActionEdit, user, PsApplyRulesMask.psApplyRulesDefaults);
                                di.Fields["Title"].Value = newtitle;
                                di.Fields["Steps"].Value = newsteps;
                                di.Save(true);
                                Console.WriteLine(" *** Updated ****");
                                casesUpdated++;
                            }
                            else
                            {
                                Console.WriteLine(" *** Matched ****");
                                casesMatched++;
                            }
                            continue;
                        }

                        di = dsDst.GetDatastoreItem(PsDatastoreItemTypeEnum.psDatastoreItemTypeTestCase, 1, null);
                        DatastoreItem clone = di.Clone(dsDst);
                        foreach(Field f in clone.Fields)
                        {
                            if(!f.IsReadOnly)
                                continue;

                            try
                            {
                                f.Value = null;
                            }
                            catch
                            {
                                try
                                {
                                    f.Value = "";
                                }
                                catch
                                {
                                    string t = "";
                                    foreach(string s in f.ValidValues)
                                    {
                                        t += " " + s;
                                    }
                                    //Debug.WriteLine("Field Values: " + f.Name  + ": " + t);
                                }
                            }
                        }
                        clone.ApplyRules(PsApplyRulesMask.psApplyRulesDefaults);

                        clone.Fields["Title"].Value = newtitle;
                        clone.Fields["Steps"].Value = newsteps;
                        clone.Fields["Test Class"].Value = "Functional";
                        clone.Fields["Test Type"].Value = "Manual";
                        clone.Fields["Frequency"].Value = "Daily";
                        //clone.Fields["Changed by"].Value = user;
                        clone.Fields["Assigned To"].Value = "v-corexf";
                        //clone.Fields["Opened Date"].Value = DateTime.Now;
                        //clone.Fields["Opened By"].Value = user;
                        clone.Fields["Test Priority"].Value = "1";
                        clone.Fields["Owner"].Value = "v-corexf";
                        clone.Fields["Test Subarea"].Value = curid.ToString();

                        clone.Fields["TreeID"].Value = n.ID;

                        foreach(Field f in clone.Fields)
                        {
                            if(f.Validity != PsFieldStatusEnum.psFieldStatusValid)
                                Console.WriteLine("Field: " + f.Name + ": " + f.Validity.ToString());
                        }

                        clone.Save(true);
                        Console.WriteLine(" *** Saved ****");
                        casesNew++;
                    } // while read
                    r.Close();
                } // while datareader
            } // using src db

            Console.WriteLine("Matched: {0}\nUpdated: {1}\nNew: {2}", casesMatched, casesUpdated, casesNew);
        }

        
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RegDBPoster\RegDBPoster.cs ===
using System;
using System.IO;
using System.Data;
using System.Data.SqlClient;

namespace RegDBPoster
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class RegDBPoster
	{
        // Hard-coded values
        static string DBServer = "xonlinetest";
        static string DBLogin = "regression";
        static string DBPassword = "regression";

        // Member variables
        string BuildNumber = "00.00.0000";
        int Iteration = 0;
        string DataFileName = "";

        SqlConnection sqlConnection;

        public RegDBPoster(string buildnum, string datafile, string regdbserver)
        {
            BuildNumber = buildnum;
            DataFileName = datafile;
            Iteration = 0;

            OpenDB(regdbserver, DBLogin, DBPassword);
            PostFile(DataFileName);
        }

        protected void OpenDB(string server, string login, string password)
        {
            string connectionstring = "";
            connectionstring += "data source=" + server;
            connectionstring += ";Initial Catalog=RegDB";
            connectionstring += ";Trusted_Connection=true";
            connectionstring += (login != null) ? ";user id=" + login : "";
            connectionstring += (password != null) ? ";pwd=" + password : "";
            sqlConnection = new SqlConnection(connectionstring);
            try
            {
                sqlConnection.Open();            
                Console.WriteLine("Successfully executed: {0}", connectionstring);
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection failed: " + e);
                throw;
            }
        }

        protected void PostFile(string filename)
        {
            try
            {
                if (sqlConnection.State != ConnectionState.Open)
                    sqlConnection.Open();

                // The using statement will close the file when it goes out of scope
                using (StreamReader sr = new StreamReader(filename))
                {
                    int count = 0;
                    string line;
                    // Read each line until end of file
                    while ((line = sr.ReadLine()) != null)
                    {
                        char[] separators = {',', '\t'};
                        string[] elems = line.Split(separators);
                        if (elems.Length != 5)
                        {
                            Console.WriteLine("Expected 5 fields per row, found %d", elems.Length);
                            Console.WriteLine("Fields: [TestStatus, SubComponent, TestGroup, TestCaseName, ResultDetail]");
                            throw new Exception("Incorrect row length");
                        }
                        PostData(int.Parse(elems[0]), elems[1], elems[2], elems[3], elems[4]);
                        count++;
                    }
                    Console.WriteLine("Successfully posted {0} records from {1}", count, filename);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("PostFile() failed: " + e);
                throw;
            }
            finally
            {
                sqlConnection.Close();
            }
        }

        protected int PostData(int level, string category, string subcategory, string variation, string notes)
        {
            // Auto-correct level var
            if (level == 128)
                level = 1;
            else if (level == 4)
                level = 0;

            SqlCommand sqlCommand = new SqlCommand("dbo.sp_InsertTestResults", sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            sqlCommand.Parameters.Add("@BuildNo", SqlDbType.Char, 10).Value = BuildNumber;
            sqlCommand.Parameters.Add("@IterationNo", SqlDbType.Int).Value = Iteration;
            sqlCommand.Parameters.Add("@SubComponent", SqlDbType.Char, 50).Value = category;
            sqlCommand.Parameters.Add("@TestGroup", SqlDbType.Char, 50).Value = subcategory;
            sqlCommand.Parameters.Add("@TestCaseName", SqlDbType.Char, 50).Value = variation;
            sqlCommand.Parameters.Add("@TestCaseDescription", SqlDbType.Char, 100).Value = "Description";
            sqlCommand.Parameters.Add("@Result", SqlDbType.Int).Value = level;
            sqlCommand.Parameters.Add("@ResultDetail", SqlDbType.NChar, 4000).Value = notes;
            sqlCommand.Parameters.Add("@BugID", SqlDbType.Int).Value = 0;

            sqlCommand.ExecuteNonQuery();

            return (int)retval.Value;   
        }

        static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("  RegDBPoster buildnum datafile [regdbserver]");
            Console.WriteLine("       buildnum:  In the form of 04.00.0056");
            Console.WriteLine("       datafile:  Filename containing comma-separated data to post");
            Console.WriteLine("    regdbserver:  Servername of regression database, default is 'xonlinetest'");
            Console.WriteLine("                  Suggested: 'xonlinetest' from CorpNet, '10.20.2.39' from Testnet");
            Console.WriteLine("");
            Console.WriteLine("Examples:");
            Console.WriteLine("  regdbposter 04.00.0073 results.txt xonlinetest");
            Console.WriteLine("  regdbposter 04.00.0073 results.txt 10.20.2.39");
            Console.WriteLine("");
            Console.WriteLine("Datafile format: 5 fields per record, 1 record per row");
            Console.WriteLine("  Field separators:  comma or tab");
            Console.WriteLine("  Fields: [TestStatus, SubComponent, TestGroup, TestCaseName, ResultDetail]");
        }

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            if (args.Length < 2) 
            {
                Usage();
                return;
            }
            string server = RegDBPoster.DBServer;
            if (args.Length >= 3)
                server = args[2];
            RegDBPoster poster = new RegDBPoster(args[0], args[1], server);
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\pscases\PSStructures.cs ===
using System;
using System.Collections;
using System.Web;

namespace PSCases
{
    public enum PSTestCaseStatus
    {
        Blocked = 0,
        Investigate = 1,
        Active = 2
    };

	/// <summary>
	/// Summary description for PSStructures.
	/// </summary>
	public class PSTestCase : IComparable
	{
        public int id;
        public string title;
        public string path;
        public string frequency;
        public PSTestCaseStatus status;
        public DateTime changed;

        public PSTestResults results = new PSTestResults();

        protected string Product
        {
            get
            {
                return path.Substring(0, path.IndexOf("\\", 1));
            }
        }
        #region IComparable Members

        public int CompareTo(object obj)
        {
            PSTestCase r = (PSTestCase) obj;
            int res = path.CompareTo(r.path);
            if(res != 0) return res;
            res = (results.Count != 0).CompareTo((r.results.Count != 0)); // I only want to sort based on whether there are entries
            if(res != 0) return res;
            if(results.Count > 0)
            {
                PSTestResult left = results.LastResult;
                PSTestResult right = r.results.LastResult;

                res = left.passed.CompareTo(right.passed); // Sort by passed/failed
                if(res != 0) return res;
                if(!left.passed)
                {
                    res = results.ActiveBugCount.CompareTo(r.results.ActiveBugCount);
                    if(res != 0) return res;
                }
                res = left.build.CompareTo(right.build);
                if(res != 0) return res;
            }
            if(res != 0) return res;
            res = status.CompareTo(r.status);
            return id.CompareTo(r.id);
        }

        #endregion

        static public string HTMLHeader(bool ShowBuildNumber, bool ShowBugCount)
        {
            string res = "";
            if(ShowBuildNumber)
                res += "<th>Build</th>";
            if(ShowBugCount)
                res += "<th>Active Bugs</th>";
            res += "<th>ID</th><th>Status</th><th>Title</th>\n";
            return res;
        }

        public string ToHTMLString(bool ShowBuildNumber, bool ShowBugCount)
        {
            string res = "";
            PSTestResult latest = results.LastResult;
            if(ShowBuildNumber)
            {
                if(latest == null)
                    res += "<td>N/A</td>";
                else
                    res += "<td>" + latest.build + "</td>";
            }
            if(ShowBugCount)
                res += "<td>" + results.ActiveBugCount + "</td>";
            res += "<td><a href=\"http://psph/testcase/" + Product + "/" + id + "\">" + id + "</a></td><td>" + status.ToString() + "</td><td>" + title + "</td>\n";
            return res;
        }
    }

    public class PSTestResult
    {
        public int id;
        public bool passed;
        public string build;
        public string assigned;
        public DateTime changed;
        
        public PSTestCase parent;
        public PSBugs bugs = new PSBugs();
    }

    public class PSBug : IComparable
    {
        public int id;
        public string title;
        public string status;
        public string assigned;
        public string path;
        public string release;
		public string issuetype;
        public DateTime changed;

        public static string HTMLHeader()
        {
            return "<th>Bug ID</th><th>Issue Type</th><th>Assigned To</th><th>Status</th><th>Title</th>";
        }

        protected string Product
        {
            get
            {
                return path.Substring(0, path.IndexOf("\\", 1));
            }
        }

        public string ToHTMLString()
        {
            return "<td><a href=\"http://psph/bug/" + Product + "/" + id + "\">" + id + "</a></td><td>" + issuetype + "</td><td>" + assigned + "</td><td>" + status + "</td><td>" + HttpUtility.HtmlEncode(title) + "</td>";
        }

        #region IComparable Members

        public int CompareTo(object obj)
        {
            PSBug l = this, r = (PSBug) obj;
            int res = l.path.CompareTo(r.path);
            if(res != 0) return res;
            res = l.release.CompareTo(r.release);
            if(res != 0) return res;
            res = l.assigned.CompareTo(r.assigned);
            if(res != 0) return res;
            res = l.status.CompareTo(r.status);
            if(res != 0) return res;
            return l.id.CompareTo(r.id);
        }

        #endregion
    }

    public class PSBugs
    {
        Hashtable Bugs = new Hashtable();         // Maps to the bugs by id

        public PSBug ID(int id)
        {
            PSBug p = (PSBug) Bugs[id];
            if(p != null)
                return p;
            p = new PSBug();
            p.id = id;
            Bugs[id] = p;
            return p;
        }

        public bool Exists(int id)
        {
            return Bugs[id] != null;
        }

        public ICollection BugIDs
        {
            get {return Bugs.Keys;}
        }

        public void Add(PSBug b)
        {
            Bugs[b.id] = b;
        }
    }

    public class PSReleaseStatus
    {
        public uint active;
        public uint resolved;
    }

    public class PSBugsAll
    {
        Hashtable bugs = new Hashtable();
        ArrayList all = new ArrayList();
        Hashtable releases = new Hashtable();
        Hashtable aliases = new Hashtable();

        public void GenerateReleaseLists()
        {
            foreach(PSBug bug in all)
            {
                PSReleaseStatus stat = Release(bug.release);
                if(bug.status == "Active")
                    stat.active++;
                else if(bug.status == "Resolved")
                    stat.resolved++;

                stat = Alias(bug.assigned);
                if(bug.status == "Active")
                    stat.active++;
                else if(bug.status == "Resolved")
                    stat.resolved++;
            }
        }

        public PSReleaseStatus Alias(string alias)
        {
            PSReleaseStatus al = (PSReleaseStatus) aliases[alias];
            if(al != null)
                return al;
            al = new PSReleaseStatus();
            aliases[alias] = al;
            return al;
        }

        public PSReleaseStatus Release(string release)
        {
            PSReleaseStatus al = (PSReleaseStatus) releases[release];
            if(al != null)
                return al;
            al = new PSReleaseStatus();
            releases[release] = al;
            return al;
        }

        public ICollection Releases
        {
            get {return releases.Keys;}
        }

        public ICollection Aliases
        {
            get {return aliases.Keys;}
        }

        public PSBugs Path(string path)
        {
            PSBugs al = (PSBugs) bugs[path];
            if(al != null)
                return al;
            al = new PSBugs();
            bugs[path] = al;
            return al;
        }

        public ICollection Paths
        {
            get {return bugs.Keys;}
        }

        public void Add(PSBug bug)
        {
            PSBugs bugs = Path(bug.path);
            if(bugs.Exists(bug.id))
                return;
            bugs.Add(bug);
            all.Add(bug);
        }

        public ICollection SortedList
        {
            get {all.Sort(); return all;}
        }
    }
    public class PSTestResults
    {
        Hashtable TestResults = new Hashtable();    // Maps to the test case results

        public PSTestResult ID(PSTestCase parent, int id)
        {
            PSTestResult p = (PSTestResult) TestResults[id];
            if(p != null)
                return p;
            p = new PSTestResult();
            p.id = id;
            TestResults[id] = p;
            p.parent = parent;
            return p;
        }

        public PSTestResult LastResult
        {
            get
            {
                if(TestResults.Count == 0)
                    return null;

                PSTestResult tr = null, temp;
                foreach(int id in TestResults.Keys)
                {
                    temp = (PSTestResult) TestResults[id];
                    if(tr == null || tr.changed < temp.changed)
                        tr = temp;
                }
                return tr;
            }
        }

        public uint ActiveBugCount
        {
            get
            {
                if(TestResults.Count == 0)
                    return 0;

                uint bugActiveCount = 0;
                PSTestResult temp;
                foreach(int id in TestResults.Keys)
                {
                    temp = (PSTestResult) TestResults[id];
                    foreach(int bugid in temp.bugs.BugIDs)
                    {
                        PSBug b = temp.bugs.ID(bugid);
                        if(b.status == "Active")
                            bugActiveCount++;
                    }
                }
                return bugActiveCount;
            }
        }

        public int Count
        {
            get {return TestResults.Count;}
        }

        public ICollection ResultIDs
        {
            get {return TestResults.Keys;}
        }
    }

    public class PSBuildStatus
    {
        public uint pass = 0;
        public uint fail = 0;
        public uint totalpass = 0;
        public uint totalfail = 0;
    }

    public class PSTestCases
    {
        Hashtable TestCaseIDs = new Hashtable();    // Maps to the real test case
        Hashtable TestCasePaths = new Hashtable();  // Maps to an ArrayList of test cases
        Hashtable TestCaseBuilds = new Hashtable(); // Maps the last build tested to the testcases that were run


        public void GenerateBuildLists()
        {
            foreach(int id in TestCaseIDs.Keys)
            {
                PSTestCase tc = (PSTestCase) TestCaseIDs[id];
                PSTestResult latest = tc.results.LastResult;
                if(latest == null)
                    continue;
                PSBuildStatus stat = Build(latest.build);
                if(latest.passed)
                    stat.pass++;
                else
                    stat.fail++;
                foreach(int trid in tc.results.ResultIDs)
                {
                    PSTestResult r = tc.results.ID(null, trid);
                    stat = Build(r.build);
                    if(r.passed)
                        stat.totalpass++;
                    else
                        stat.totalfail++;
                }
            }
        }

        public PSBuildStatus Build(string build)
        {
            PSBuildStatus al = (PSBuildStatus) TestCaseBuilds[build];
            if(al != null)
                return al;
            al = new PSBuildStatus();
            TestCaseBuilds[build] = al;
            return al;
        }

        public ICollection Builds
        {
            get{return TestCaseBuilds.Keys;}
        }

        public PSTestCase ID(int id)
        {
            PSTestCase p = (PSTestCase) TestCaseIDs[id];
            if(p != null)
                return p;
            p = new PSTestCase();
            p.id = id;
            TestCaseIDs[id] = p;
            return p;
        }

        public ICollection Paths
        {
            get {return TestCasePaths.Keys;}
        }

        public ArrayList Path(string path)
        {
            ArrayList al = (ArrayList) TestCasePaths[path];
            if(al != null)
                return al;
            al = new ArrayList();
            TestCasePaths[path] = al;
            return al;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\pscases\PSCases.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;
using System.Collections;
using System.Web;

namespace PSCases
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class PSCases
	{
        static PSTestCases testCases = new PSTestCases();
        static PSBugsAll bugs = new PSBugsAll();

        static void AddPaths(SqlCommand com, StringBuilder sb, string compareField, string [] paths, int startIndex)
        {
            if(paths == null || paths.Length - startIndex <= 0)
                return;

            // Since each line is preceded by "or" I precede the sequence generation by "0" to make it syntactically correct and simplify my code
            sb.Append("\nand (0 != 0\n");
            for(int i = startIndex; i < paths.Length; ++i)
            {
                string s = "@pathdata" + i.ToString();
                sb.Append("\nor ").Append(compareField).Append(" like ").Append(s);
                SqlParameter p = com.Parameters.Add(s, SqlDbType.NVarChar);
                p.Value = paths[i];
            }
            sb.Append("\n)\n");
        }

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			//
			// TODO: Add code to start application here
			//

            if(args.Length < 2)
            {
                Console.WriteLine("Minimum command line requirements are Product Studio SQL Server and Product Studio Database to query.");
                Console.WriteLine("Each subsequent entry is a path in the product studio database of the form:");
                Console.WriteLine(@"    \Xenon\Software\System Apps\Connectivity Wizard");
                Console.WriteLine("To specify a tree and all of its subtrees you can do:");
                Console.WriteLine(@"    \Xenon\Software\System Apps%");
                return;
            }

            int StartIndex = 2;
            SqlCommand com;
            StringBuilder sb;

            // Check the sql connection
            using(SqlConnection conn = new SqlConnection("server=" + args[0] + ";database=" + args[1] + ";Integrated Security=SSPI"))
            {
                conn.Open();

                // Get all test cases in the given path
                // Get all results for those test cases
                // Get all bugs linked to those results
                // Merge bugs with list of bugs for provided paths

                // For test cases I'm interested in:
                //  ID
                //  Title
                //  Path
                //  Frequency
                //  Status: Active
                //  Changed Date
                #region Retrieve the list of test cases
                com = conn.CreateCommand();
                sb = new StringBuilder();
                com.CommandType = CommandType.Text;
                sb.Append(
                    @"select tc.[id], tc.title, tc.[Tree Path], tc.frequency, tc.[test status], tc.[changed date]
                    from [test caselatest] as tc
                    where 1 = 1");
                AddPaths(com, sb, "tc.[Tree Path]", args, StartIndex);
                com.CommandText = sb.ToString();
                using(SqlDataReader r = com.ExecuteReader())
                {
                    while(r.Read())
                    {
                        PSTestCase p = testCases.ID(r.GetInt32(0));
                        p.title = r.GetString(1);
                        p.path = r.GetString(2);
                        p.frequency = r.GetString(3);
                        p.status = (PSTestCaseStatus) Enum.Parse(typeof(PSTestCaseStatus), r.GetString(4), true);
                        p.changed = r.GetDateTime(5);
                        testCases.Path(p.path).Add(p);
                    }
                }
                #endregion
                
                // For test case results
                //  TestCaseID
                //  ID
                //  Result (pass fail)
                //  Build
                //  Bugs
                //  Assigned to
                //  Changed Date
                #region Retrieve the test case results for the test cases
                com = conn.CreateCommand();
                sb = new StringBuilder();
                com.CommandType = CommandType.Text;
                sb.Append(
                    @"select distinct tc.[id], ra.[id], ra.[Result Value], ra.[App Build], ra.[Assigned To], ra.[changed date]
                    from [test caselatest] as tc
                        inner join [resultlatest] as ra on tc.[id] = ra.testcaseid
                    where 1 = 1");
                AddPaths(com, sb, "tc.[Tree Path]", args, StartIndex);
                com.CommandText = sb.ToString();
                using(SqlDataReader r = com.ExecuteReader())
                {
                    while(r.Read())
                    {
                        PSTestCase p = testCases.ID(r.GetInt32(0));
                        PSTestResult result = p.results.ID(p, r.GetInt32(1));
                        result.passed = r.GetString(2).ToLower().CompareTo("fail") != 0;
                        result.build = r.GetString(3);
                        result.assigned = r.GetString(4);
                        result.changed = r.GetDateTime(5);
                    }
                }
                #endregion

                // For bugs linked to test case results
				//  TestCaseID -- ID of test case
                //  BugLinkID -- ID of bug
                //  TopOwnerID -- ID of test case result
				//  Status: active, resolved (skip closed)
				//  Assigned to
				//  Test case id if relevant
				//  Path
				//  Changed Date
				//  Issue Type
				#region Retrieve the bugs associated with the test case results
                com = conn.CreateCommand();
                sb = new StringBuilder();
                com.CommandType = CommandType.Text;
                sb.Append(
                    @"select distinct tc.[id], ra.[id], bl.[id], bl.title, bl.status, bl.[assigned to], bl.[tree path], bl.[changed date], bl.release, bl.[issue type]
                    from [test caselatest] as tc
                        inner join [resultlatest] as ra on tc.[id] = ra.testcaseid
                        inner join [result\buglinkall] as rbla on rbla.ownerid=ra.[id]
                        inner join [bugslatest] as bl on bl.[id] = rbla.buglinkid
                    where 1 = 1");
                AddPaths(com, sb, "tc.[Tree Path]", args, StartIndex);
                com.CommandText = sb.ToString();
                using(SqlDataReader r = com.ExecuteReader())
                {
                    while(r.Read())
                    {
                        PSTestCase p = testCases.ID(r.GetInt32(0));
                        PSTestResult result = p.results.ID(p, r.GetInt32(1));
                        PSBug b = result.bugs.ID(r.GetInt32(2));
                        b.title = r.GetString(3);
                        b.status = r.GetString(4);
                        b.assigned = r.GetString(5);
                        b.path = r.GetString(6);
                        b.changed = r.GetDateTime(7);
                        b.release = r.GetString(8);
						b.issuetype = r.GetString(9);
                        bugs.Add(b);
                    }
                }
                #endregion

                // For bug lists I'm interested in:
                //  ID
                //  Title
                //  Status: active, resolved (skip closed)
                //  Assigned to
                //  Test case id if relevant
                //  Path
                //  Changed Date
				//  Issue Type
                #region Retrieve the bugs in the specified product paths
                com = conn.CreateCommand();
                sb = new StringBuilder();
                com.CommandType = CommandType.Text;
                sb.Append(
                    @"select distinct bl.[id], bl.title, bl.status, bl.[assigned to], bl.[tree path], bl.[changed date], bl.release, bl.[issue type]
                    from [bugslatest] as bl
                    where 1 = 1");
                AddPaths(com, sb, "bl.[tree path]", args, StartIndex);
                com.CommandText = sb.ToString();
                using(SqlDataReader r = com.ExecuteReader())
                {
                    while(r.Read())
                    {
                        PSBug b = new PSBug();
                        b.id = r.GetInt32(0);
                        b.title = r.GetString(1);
                        b.status = r.GetString(2);
                        b.assigned = r.GetString(3);
                        b.path = r.GetString(4);
                        b.changed = r.GetDateTime(5);
                        b.release = r.GetString(6);
						b.issuetype = r.GetString(7);
                        bugs.Add(b);
                    }
                }
                #endregion

                // The query will be divided into a bunch of groups: 
                //  By path into total number of pass, fail, not run, open bug count, resolved bug count
                //  By build for past 5 builds into pass, fail, not run, open bug count, resolved bug count
                //  Then each test case that is listed as failed and it's open bugs, resolved bug count
                //  Then each test case that has not been run
                //  Then the remaining test cases and the most recent build that they ran for (ordered by build then title)
                //  Then finally the bug list grouped by owner (into active and resolved)

                bugs.GenerateReleaseLists();
                testCases.GenerateBuildLists();

                // Bugs/path
                sb = new StringBuilder();
                #region HTML Header and command line arguments
                sb.Append("<html><head><title>Test Case Status ").Append(DateTime.Now.ToString("g")).Append("</title>\n");
                sb.Append(@"
                            <STYLE TYPE=""text/css""><!--
                                div.path {
	                                padding-left: 10px;
                                    font-size: x-large;
                                }
                                div.release {
	                                padding-left: 20px;
                                    font-size: large;
                                }
                                div.casestatus {
	                                padding-left: 20px;
                                    font-size: large;
                                }
                                div.bugs {
                                    padding-left: 40px;
                                }
                                div.caselist {
                                    padding-left: 40px;
                                }
								td.bugactive {
									background-color: #FFC0C0;
								}
								td.bugresolved {
									background-color: #FFFFC0;
								}
								td.tcfail {
									background-color: #FFC0C0;
								}
								td.tcpass {
									background-color: #C0FFC0;
								}
								th.bugactive {
									background-color: #FFC0C0;
								}
								th.bugresolved {
									background-color: #FFFFC0;
								}
								th.tcfail {
									background-color: #FFC0C0;
								}
								th.tcpass {
									background-color: #C0FFC0;
								}
                            --></STYLE>");
                sb.Append("\n</head><body>\n");

                sb.Append("<h1>Test Case Status ").Append(DateTime.Now.ToString("g")).Append("</h1>\n");

                // List the parameters passed
                sb.Append("<p>Server: ").Append(args[0]).Append("\n");
                sb.Append("<p>Database: ").Append(args[1]).Append("\n");
                sb.Append("<ul>Paths:\n");
                for(int i = 2; i < args.Length; ++i)
                    sb.Append("<li>").Append(HttpUtility.HtmlEncode(args[i])).Append("</li>\n");
                sb.Append("</ul>\n\n");
                #endregion

				SortedList sl = new SortedList();
				foreach(string path in bugs.Paths)
				{
					sl.Add(path, path);
				}

                #region Per path status (active, resolved, cases, pass, fail)
                // List the table for the per path results
                sb.Append("<h2>Summary:</h2>\n");
                sb.Append("<table border=1 align=center>\n");
                sb.Append("\t<tr><th rowspan=3>Path</th><th colspan=6>Bugs</th><th rowspan=2 colspan=7>Test Cases</th></tr>\n");
                sb.Append("\t<tr><th class=\"bugactive\" colspan=5>Active</th><th class=\"bugresolved\" rowspan=2>Resolved</th></tr>");
				sb.Append("\t<tr><th class=\"bugactive\">Total</th><th class=\"bugactive\">Work Item</th><th class=\"bugactive\">Spec Issue</th><th class=\"bugactive\">Code Defect</th><th class=\"bugactive\">Content/Loc</th>\n");
				sb.Append("\t\t<th>Total</th><th class=\"tcpass\" colspan=2>Passed</th><th class=\"tcfail\"  colspan=2>Failed</th><th colspan=2>Run</th></tr>\n");

                foreach(string path in sl.Keys)
                {
                    // Get the bug information per path

                    PSBugs bs = bugs.Path(path);
                    uint active = 0, resolved = 0, closed = 0, cases = 0, pass = 0, fail = 0, work = 0, spec = 0, defect = 0, content = 0;
                    foreach(int id in bs.BugIDs)
                    {
                        PSBug b = bs.ID(id);
                        switch(b.status)
                        {
                            case "Active":
                                active++;
								switch(b.issuetype)
								{
									case "Content":
									case "Localization":
										content++;
										break;
									case "Spec Issue":
										spec++;
										break;
									case "Code Defect":
										defect++;
										break;
									case "Work Item":
										work++;
										break;
								};
								break;
                            case "Resolved":
                                resolved++;
                                break;
                            case "Closed":
                                closed++;
                                break;
                            default:
                                throw new Exception("Unknown bug status: \"" + b.status + "\"");
                        };
                    }

                    // Get the test case information per path
                    ArrayList caseList = testCases.Path(path);
                    foreach(PSTestCase c in caseList)
                    {
                        cases++;
                        PSTestResult r = c.results.LastResult;
                        // Check to see if the latest test result passed or failed
                        if(r == null)
                            continue;

                        if(r.passed)
                            pass++;
                        else
                            fail++;
                    }

                    if((active + resolved + pass + fail) == 0)
                        continue;

					// Path (1 column)
                    sb.Append("\t<tr><td>").Append(HttpUtility.HtmlEncode(path)).Append("</td><td class=\"bugactive\">");
					// bug information (6 columns)
					sb.Append(active).Append("</td><td class=\"bugactive\">");
					sb.Append(work).Append("</td><td class=\"bugactive\">");
					sb.Append(spec).Append("</td><td class=\"bugactive\">");
					sb.Append(defect).Append("</td><td class=\"bugactive\">");
					sb.Append(content).Append("</td><td class=\"bugresolved\">");
					sb.Append(resolved).Append("</td><td>");
					// Test case information (7 columns)
					double ratio = pass;
					ratio /= (cases == 0 ? 1 : cases);
					sb.Append(cases).Append("</td><td class=\"tcpass\">");
					sb.Append(pass).Append("</td><td class=\"tcpass\">");
					sb.Append(ratio.ToString("#0%")).Append("</td><td class=\"tcfail\">");
					ratio = fail;
					ratio /= (cases == 0 ? 1 : cases);
                    sb.Append(fail).Append("</td><td class=\"tcfail\">");
					sb.Append(ratio.ToString("#0%")).Append("</td><td>");
					ratio = (pass + fail);
					ratio /=(cases == 0 ? 1 : cases);
					sb.Append(fail + pass).Append("</td><td>");
					sb.Append(ratio.ToString("#0%")).Append("</td></tr>\n");
                }
                sb.Append("</table>\n");

                #endregion

                #region Per Build status (test case pass and fail)
                sb.Append("<br><table border=0 align=center><td valign=top>\n");

                sb.Append("<table border=1 align=center><tr><th rowspan=2>Build</th><th colspan=2>Test Cases Latest</th><th colspan=2>Test Cases Total</th></tr>\n");
                sb.Append("<tr><th>Pass</th><th>Fail</th><th>Pass</th><th>Fail</th></tr>\n");
                ArrayList buildList = new ArrayList();
                foreach(string build in testCases.Builds)
                {
                    buildList.Add(build);
                }
                buildList.Sort();
                for(int i = buildList.Count - 1; i >= 0; --i)
                {
                    string build = (string) buildList[i];
                    PSBuildStatus stat = testCases.Build(build);
                    if(stat.fail + stat.pass == 0)
                        continue;
                    sb.Append("<tr><td>").Append(build).Append("</td><td>").Append(stat.pass).Append("</td><td>").Append(stat.fail).Append("</td><td>").Append(stat.totalpass).Append("</td><td>").Append(stat.totalfail).Append("</td></tr>");
                }
                sb.Append("</table>\n");
                #endregion

                #region Per Release status (bug active resolved)
                sb.Append("</td><td valign=top>\n");

                sb.Append("<table border=1 align=center><tr><th rowspan=2>Release</th><th colspan=2>Bugs</th></tr>\n");
                sb.Append("<tr><th>Active</th><th>Resolved</th></tr>\n");
                ArrayList releaseList = new ArrayList();
                foreach(string release in bugs.Releases)
                {
                    releaseList.Add(release);
                }
                releaseList.Sort();
                foreach(string release in releaseList)
                {
                    PSReleaseStatus stat = bugs.Release(release);
                    if(stat.active + stat.resolved == 0)
                        continue;
                    sb.Append("<tr><td>").Append(release).Append("</td><td>").Append(stat.active).Append("</td><td>").Append(stat.resolved).Append("</td></tr>");
                }
                sb.Append("</table>\n");

                #endregion

                #region Per Alias status (bug active resolved)
                sb.Append("</td><td valign=top>\n");

                sb.Append("<table border=1 align=center><tr><th rowspan=2>Alias</th><th colspan=2>Bugs</th></tr>\n");
                sb.Append("<tr><th>Active</th><th>Resolved</th></tr>\n");
                ArrayList aliasList = new ArrayList();
                foreach(string alias in bugs.Aliases)
                {
                    aliasList.Add(alias);
                }
                aliasList.Sort();
                foreach(string alias in aliasList)
                {
                    PSReleaseStatus stat = bugs.Alias(alias);
                    if(stat.active + stat.resolved == 0)
                        continue;
                    sb.Append("<tr><td>").Append(alias).Append("</td><td>").Append(stat.active).Append("</td><td>").Append(stat.resolved).Append("</td></tr>");
                }
                sb.Append("</table>\n");

                sb.Append("</td></table>\n");
                #endregion

                #region Per path test case breakdown (not run, failing but should work, failing and not expected to work, passing sorted by build)
                sb.Append("<h2>Test Case Status:</h2>\n");

                foreach(string path in sl.Keys)
                {
                    string curState = "", nextState;
                    ArrayList cases = testCases.Path(path);
                    if(cases.Count == 0)
                        continue;

                    sb.Append("<div class=\"path\">").Append(HttpUtility.HtmlEncode(path)).Append("</div>\n");

                    cases.Sort();
                    bool ShowBuildNumber;
                    bool ShowBugCount;
                    foreach(PSTestCase c in cases)
                    {
                        PSTestResult r = c.results.LastResult;
						if(r == null)                           // 1st Set belong here
						{
							ShowBuildNumber = false;
							ShowBugCount = false;
							nextState = "Not Run";
						}
						else if(r.passed)                       // 3rd Set belong here
						{
							ShowBuildNumber = true;
							ShowBugCount = false;
							nextState = "Passed";
						}
						else                                    // 2nd Set belong here
						{
							ShowBuildNumber = true;
							ShowBugCount = true;
							nextState = "Failed";
						}
                        
                        if(nextState != curState)
                        {
                            if(curState != "")
                                sb.Append("</table></div>\n");
                            sb.Append("<div class=\"casestatus\">").Append(nextState).Append("</div>");
                            sb.Append("<div class=\"caselist\"><table border=1 width=90%>\n");
                            sb.Append("<tr>").Append(PSTestCase.HTMLHeader(ShowBuildNumber, ShowBugCount)).Append("</tr>\n");
                            curState = nextState;
                        }

                        sb.Append("<tr>").Append(c.ToHTMLString(ShowBuildNumber, ShowBugCount)).Append("</tr>\n");
                    }
                    if(curState != "")
                        sb.Append("</table></div>\n");
                }
                #endregion


                #region Bug list by path sorted by path, release, assigned to, status
                sb.Append("<h2>Bug Status:</h2>\n");
                {
                    string path = null;
                    string release = null;
                    bool endTable = false;
                    bool displayPath = true;
                    bool displayRelease = true;
                    foreach(PSBug bug in bugs.SortedList)
                    {  
                        if(bug.status == "Closed")
                            continue;

                        if(path == null || path != bug.path)
                        {
                            if(path != null)
                                endTable = true;
                            displayPath = true;
                            displayRelease = true;
                            path = bug.path;
                            release = bug.release;
                        }
                        if(release != bug.release)
                        {
                            endTable = true;
                            displayRelease = true;
                            release = bug.release;
                        }
                        if(endTable)
                            sb.Append("</table></div>\n");

                        if(displayPath)
                            sb.Append("<div class=\"path\">").Append(HttpUtility.HtmlEncode(bug.path)).Append("</div>\n");

                        if(displayRelease)
                        {
                            sb.Append("<div class=\"release\">").Append(HttpUtility.HtmlEncode(bug.release)).Append("</div>\n");
                            sb.Append("<div class=\"bugs\"><table width=90% border=1>\n");
                            sb.Append("<tr>").Append(PSBug.HTMLHeader()).Append("</tr>\n");
                        }

                        sb.Append("<tr>").Append(bug.ToHTMLString()).Append("</tr>\n");
                        endTable = false;
                        displayPath = false;
                        displayRelease = false;
                    }
                    if(release != null)
                        sb.Append("</table>\n");
                }
                #endregion

                // Also can get list of bugs that are now listed as resolved/closed for test cases with a most recent result of failure should now work
                // Test case has most recent result of failure and all bugs associated with the test case are resolved or closed
                // Test case failure results without bugs associated with them
                // Can also list bugs with most cases broken by that bug

                sb.Append("</body></html>\n");

                Console.WriteLine(sb.ToString());
            }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RunFunctionals\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_getlivebldver_none_12.4.56.0_none_88cb282ed613f1d8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=getlivebldver
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_MANIFEST_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_CATALOG_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_PAYLOAD_PATH=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=getlivebldver,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RemoteService\RemoteService.cpp ===
// RemoteService.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

void Usage()
{
	printf("Usage: RemoteService <machinename> <servicename> start|stop\n");
};

HRESULT ShutdownRemoteService(const char *szService, const char *szMachine)
{
	HRESULT hr = S_OK;
	printf("INFO: Shutting down %s service on %s...\n", szService, szMachine);
	
	// Stop XMS server
	SC_HANDLE sch = ::OpenSCManager(szMachine, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
	if (sch == NULL)
	{
		printf("ERROR: Could not open Service Control Manager on %s, GetLastError() == %lu\n", szMachine, ::GetLastError());
		return E_FAIL;
	}

	SC_HANDLE schService = ::OpenService(sch, szService, SERVICE_STOP | SERVICE_QUERY_STATUS);
	if (!::CloseServiceHandle(sch))
		printf("WARNING: Unable to close service handle to SC Manager.  Potential resource leak\n");

	if (schService == NULL)
	{
		printf("ERROR: Could not open %s service on %s, GetLastError() == %lu\n", szService, szMachine, ::GetLastError());
		return E_FAIL;
	}

	SERVICE_STATUS sstatus;
	if (!::ControlService(schService, SERVICE_CONTROL_STOP, &sstatus))
	{
		if (::GetLastError() != ERROR_SERVICE_NOT_ACTIVE)
		{
			printf("ERROR: Could not stop %s service on %s, GetLastError() == %lu\n", szService, szMachine, ::GetLastError());
			hr = E_FAIL;
		}
		else
		{
			printf("WARNING: Service is already stopped\n");
			hr = S_FALSE;
		}
	}

	// wait 10 seconds at the most for this to start
	time_t tmEnd = time(NULL) + 10;
	// Proceed only after QueryServiceStatus shows that it has started
	do
	{
		if (tmEnd < time(NULL))
		{
			printf("ERROR: Timeout waiting for service to stop on %s\n", szService, szMachine);
			hr = E_FAIL;
			break;
		}

		if (!::QueryServiceStatus(schService, &sstatus))
		{
			printf("ERROR: Unable to query status of %s service on %s, GetLastError() == %lu\n", szService, szMachine, ::GetLastError());
			hr = E_FAIL;
			break;
		}

		if (sstatus.dwCurrentState != SERVICE_STOP_PENDING && sstatus.dwCurrentState != SERVICE_STOPPED)
		{
			printf("ERROR: State of %s service is %lu, but expects SERVICE_STOP_PENDING or SERVICE_STOPPED\n", szService, sstatus.dwCurrentState);
			hr = E_FAIL;
			break;
		}

		::Sleep(100);
	} while (sstatus.dwCurrentState != SERVICE_STOPPED);

	if (!::CloseServiceHandle(schService))
		printf("WARNING: Unable to close service handle to %s.  Potential resource leak\n", szService);

	printf("INFO: Succeeded in shutting down %s service on %s\n", szService, szMachine);

	return hr;
}

HRESULT StartRemoteService(const char *szService, const char *szMachine)
{
	HRESULT hr = S_OK;
	printf("INFO: Starting up %s service on %s...\n", szService, szMachine);

	SC_HANDLE sch = ::OpenSCManager(szMachine, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
	if (sch == NULL)
	{
		printf("ERROR: Could not open Service Control Manager on %s, GetLastError() == %lu\n", szMachine, ::GetLastError());
		return E_FAIL;
	}

	SC_HANDLE schService = ::OpenService(sch, szService, SERVICE_START | SERVICE_QUERY_STATUS);

	if (!::CloseServiceHandle(sch))
		printf("WARNING: Unable to close service handle to SC Manager.  Potential resource leak\n");

	if (schService == NULL)
	{
		printf("ERROR: Could not open %s service on %s, GetLastError() == %lu\n", szService, szMachine, ::GetLastError());
		return E_FAIL;
	}

	if (!::StartService(schService, 0, NULL))
	{
		if (::GetLastError() != ERROR_SERVICE_ALREADY_RUNNING)
		{
			printf("ERROR: Could not start Monitoring Service on %s, GetLastError() == %lu\n", szMachine, ::GetLastError());
			hr = E_FAIL;
		}
		else
		{
			printf("WARNING: Service is already running\n");
			hr = S_FALSE;
		}
	}


	// wait 10 seconds at the most for this to start
	SERVICE_STATUS sstatus;
	time_t tmEnd = time(NULL) + 10;
	// Proceed only after QueryServiceStatus shows that it has started
	do
	{
		if (tmEnd < time(NULL))
		{
			printf("ERROR: Timeout waiting for monitoring service to start on %s\n", szMachine);
			hr = E_FAIL;
			break;
		}

		if (!::QueryServiceStatus(schService, &sstatus))
		{
			printf("ERROR: Unable to query status of monitoring service on %s, GetLastError() == %lu\n", szMachine, ::GetLastError());
			hr = E_FAIL;
			break;
		}

		if (sstatus.dwCurrentState != SERVICE_START_PENDING && sstatus.dwCurrentState != SERVICE_RUNNING)
		{
			printf("ERROR: State of monitoring service is %lu, but expects SERVICE_START_PENDING or SERVICE_RUNNING\n", sstatus.dwCurrentState);
			hr = E_FAIL;
			break;
		}

		::Sleep(100);
	} while (sstatus.dwCurrentState != SERVICE_RUNNING);

	if (!::CloseServiceHandle(schService))
		printf("WARNING: Unable to close service handle.  Potential resource leak\n");

	printf("INFO: Succeeded in starting %s service on %s\n", szService, szMachine);

	return hr;
}

int __cdecl main(int argc,  char** argv)
{
	if (argc != 4)
	{
		Usage();
		return 1;
	}

	const char *szMachine = argv[1];
	const char *szService = argv[2];

	if (!strcmp(argv[3], "start"))
	{
		// Now start the service
		if FAILED(StartRemoteService(szService, szMachine))
		{
			return 1;
		}
	}
	else if (!strcmp(argv[3], "stop"))
	{
		// First stop the service
		if FAILED(ShutdownRemoteService(szService, szMachine))
		{
			return 1;
		}
	}
	else
	{
		Usage();
		return 1;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RunFunctionals\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_getlivebldver_none_12.4.56.0_none_88cb282ed613f1d8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=getlivebldver
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_MANIFEST_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_CATALOG_PATH=manifests\msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae.cat
XP_PAYLOAD_PATH=msil_getlivebldver_no-public-key_12.4.56.0_x-ww_78e6cfae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=getlivebldver,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RemoteService\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_remoteservice_none_12.4.56.0_none_9cffd57639a6c0ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=remoteservice
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.manifest
XP_MANIFEST_PATH=manifests\x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.cat
XP_CATALOG_PATH=manifests\x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.cat
XP_PAYLOAD_PATH=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=remoteservice,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RemoteService\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// RemoteService.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RemoteService\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#ifdef UNICODE
#undef UNICODE
#endif

#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <time.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\RemoteService\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_remoteservice_none_12.4.56.0_none_9cffd57639a6c0ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=remoteservice
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.manifest
XP_MANIFEST_PATH=manifests\x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.cat
XP_CATALOG_PATH=manifests\x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5.cat
XP_PAYLOAD_PATH=x86_remoteservice_no-public-key_12.4.56.0_x-ww_c74030e5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=remoteservice,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiff\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiff\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiff\SchemaDiff.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using Microsoft.Webstore.Test.SchemaDiffAPI;

namespace Microsoft.Webstore.Test.SchemaDiff
{
	/**
	<summary>
	</summary>
	*/

	public class SchemaDiff
	{
		/** 
		<summary>
		</summary>
		*/ 

		[STAThread]
		static void Main(string[] args)
		{
			try
			{
				string strInFileName = string.Empty;
                string strOutFileName = string.Empty;
                string strOutPath = "results";

				if(args.Length == 0 || args[0].Equals("/?"))
				{
					PrintUsage();
					return;
				}
				else
				{
					for(int idx = 0; idx < args.Length - 1; idx++)
					{           
						string arg = args[idx];
						switch(arg.ToLower())
						{
							case "-in":
								if(true == args[idx + 1].StartsWith("-"))
								{
									PrintUsage();
									return;
								}
								strInFileName = args[idx + 1];
								break;
							case "-out":   
								if(true == args[idx + 1].StartsWith("-"))
								{
									PrintUsage();
									return;
								}
                                strOutPath = System.IO.Path.Combine(args[idx + 1], @"\results");
								break;
						}					
					}

                    Microsoft.Webstore.Test.SchemaDiffAPI.Data.OutputFolder = strOutPath;

                    // Empty results folder...
                    try
                    {
                        if (System.IO.Directory.Exists(strOutPath))
                            System.IO.Directory.Delete(strOutPath, true);
                        System.IO.Directory.CreateDirectory(strOutPath);
                    }
                    catch
                    {
                        Console.WriteLine("Could not delete and create output directory {0}", strOutPath);
                        return;
                    }
					if ( strInFileName != string.Empty)
					{
						ConnectionOptions p_connectOpt1 = new ConnectionOptions();
						ConnectionOptions p_connectOpt2 = new ConnectionOptions();
                        SchemaDiffHelper schemadiffHelper = new SchemaDiffHelper();

                        int DBCompares = schemadiffHelper.LoadConfig(strInFileName);
                        Console.WriteLine("Performing {0} database compares...", DBCompares);

                        for (int i = 0; i < DBCompares; i++)
                        {
                            string friendlyName="";
                            if (schemadiffHelper.GetConnectionInfo(i, p_connectOpt1, p_connectOpt2, out friendlyName))
                            {
                                Console.WriteLine("Starting DBCompare '{0}'...", friendlyName);
                                // Setup output file...
                                strOutFileName = System.IO.Path.Combine(strOutPath, friendlyName + ".xml");
                                int ext = 0;
                                while (System.IO.File.Exists(strOutFileName))
                                {
                                    strOutFileName = System.IO.Path.Combine(strOutPath, String.Format("{0}(1}.xml",friendlyName,++ext));
                                }
                                if (ext > 0)
                                {
                                    friendlyName = friendlyName + ext.ToString();
                                    Console.WriteLine("Compare name exists, changing output name to '{0}'...", friendlyName);
                                }
                                // Register the first database
                                Console.WriteLine("Registering database {0} on server {1}",
                                    p_connectOpt1.DatabaseName, p_connectOpt1.ServerName);
                                Database p_database1 = new Database(friendlyName);
                                bool bConnect = p_database1.Register(p_connectOpt1);

                                if (bConnect)
                                {
                                    Console.WriteLine("Successfully registered database");
                                    // Register the second database
                                    Database p_database2 = new Database(friendlyName);
                                    Console.WriteLine("Registering database {0} on server {1}",
                                        p_connectOpt2.DatabaseName, p_connectOpt2.ServerName);
                                    bConnect = p_database2.Register(p_connectOpt2);
                                    if (bConnect)
                                    {
                                        Console.WriteLine("Successfully registered database");
                                        InternalList p_Lst = new InternalList();

                                        // Collect SQL object type information
                                        InternalList p_sqlObjList = schemadiffHelper.GetSqlObjectTypes();

                                        if (p_sqlObjList.Count() == 0)
                                        {
                                            // Compare the two databases
                                            Console.WriteLine("Comparing databases for differences");
                                            p_Lst = p_database1.Compare(p_database2);

                                        }
                                        else
                                        {
                                            // Compare specific objects.
                                            IEnumerator enumSqlObjects = p_sqlObjList.List.GetEnumerator();

                                            while (enumSqlObjects.MoveNext())
                                            {
                                                ISchemaObject iSqlObject = (ISchemaObject)enumSqlObjects.Current;
                                                System.Type type = iSqlObject.GetType();
                                                InternalList p_diffList = schemadiffHelper.CompareSpecificObjectTypes(p_database1, p_database2, type);
                                                p_Lst.AddRange(p_diffList);
                                            }
                                        }

                                        /*if (p_Lst != null)
                                            p_Lst = schemadiffHelper.FilterExcludeList(p_Lst);*/

                                        if (p_Lst != null)
                                        {
                                            Console.WriteLine("{0} differences in SQL objects found", p_Lst.Count());
                                            if (p_Lst.Count() > 0)
                                            {
                                                Console.WriteLine("Logging differences in XML format");
                                                schemadiffHelper.LogToFile(p_Lst, p_database1, p_database2, strOutFileName);
                                            }
                                        }
                                        Console.WriteLine("Finished with DBCompare '{0}'...", friendlyName);
                                    }
                                }
                            }
                        }
					}
					else
					{
						PrintUsage();
					}
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}

            Console.WriteLine("Done.  <Press Enter to finish>");
            Console.ReadLine();
		}

		static void PrintUsage()
		{
            //for formating commandline print out
            string SPACE = "    ";
			
            Console.WriteLine("");
			Console.WriteLine(SPACE + "SchemaDiff Utility 1.5");
            Console.WriteLine("");
            Console.WriteLine(SPACE + SPACE + "SchemaDiff is a utility to compare database schema and data based on a control file.");
            Console.WriteLine("");
            Console.WriteLine(SPACE + "Usage:");
			Console.WriteLine(SPACE + SPACE + "SchemaDiff -in <ConnectionFilePath> [-out <LogPath>]");
			Console.WriteLine("");
            Console.WriteLine(SPACE + SPACE + "where:");
            Console.WriteLine(SPACE + SPACE + SPACE + "<ConnectionFilePath> - Path to the configuration file");
            Console.WriteLine(SPACE + SPACE + SPACE + "<LogPath> - Path to the database differences logs.  Default is 'results'.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiff\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_schemadiff_none_12.4.56.0_none_c1eb269ce38c820f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=schemadiff
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.manifest
XP_MANIFEST_PATH=manifests\msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.cat
XP_CATALOG_PATH=manifests\msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.cat
XP_PAYLOAD_PATH=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=schemadiff,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiff\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_schemadiff_none_12.4.56.0_none_c1eb269ce38c820f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=schemadiff
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.manifest
XP_MANIFEST_PATH=manifests\msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.cat
XP_CATALOG_PATH=manifests\msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9.cat
XP_PAYLOAD_PATH=msil_schemadiff_no-public-key_12.4.56.0_x-ww_dd482da9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=schemadiff,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiff\SchemaDiffUtil.cs ===
/// <remarks>
/// Author : GirijaB 
/// </remarks>
///

using System;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.IO;
using Microsoft.Webstore.Test.SchemaDiffAPI;

namespace Microsoft.Webstore.Test.SchemaDiff
{    

	/// <summary>
	/// This class contains all utility functions used in the application 
	/// </summary>
	public class SchemaDiffHelper
	{
		
        #region variables

        XmlDocument m_xmlConfig = null;
        XmlDocument m_xmlResult = null;
        InternalList m_sqlObjectTypes = new InternalList();

        #endregion variables
        
        #region commonfunctions
		
		/// <summary>
		/// This function logs all the differences between databases in XML format.
		/// </summary>
		/// <param name="lstDifferences">List of difference objects</param>
		/// <param name="objDb1">First database being compared</param>
		/// <param name="objDb2">Second database being compared</param>
		public void LogToFile (InternalList lstDifferences, Database objDb1, 
					Database objDb2, string strOutFileName)
		{
			try
			{
				CreateResultXml(lstDifferences, objDb1, objDb2);
				if ( File.Exists(strOutFileName) )
				{
					File.Delete(strOutFileName);
				}
				m_xmlResult.Save(strOutFileName);
			}
			catch (Exception e)
			{
				//Console.WriteLine(e.ToString());
                throw e;
			}
		}

        /// <summary>
        /// Loads the XML config file and returns the number of DB compares that we are going to perform.
        /// </summary>
        /// <param name="fileConnect">Name of Config XML file</param>
        /// <returns>Number of DBCompares in XML</returns>
        public int LoadConfig(string fileConnect)
        {
            if (null == fileConnect || 0 == fileConnect.Trim().Length)
            {
                throw new Exception("Please provide connection information.");
            }
            // checks if the file exists
            if (!File.Exists(fileConnect))
            {
                throw new Exception(fileConnect + " - File does not exist.");
            }
            m_xmlConfig = new XmlDocument();
            m_xmlConfig.Load(fileConnect);
            XmlNodeList nodeList = m_xmlConfig.DocumentElement.SelectNodes("DBCompares/DBCompare");
            if (nodeList == null)
                return 0;

            return nodeList.Count;

        }
		
		/// <summary>
		/// This method retreives the connection string information from a text file
		/// and sets the connectionoptions object. 
		/// </summary>
		/// <param name="node">DBCompare Node to use</param>
		/// <param name="c1">ConnectionOptions for 1st database</param>
		/// <param name="c2">ConnectionOptions for 2nd database</param>
        /// <param name="friendlyName">Friendly name for the compare</param>
		/// <returns>true/false based on successful connection</returns>
		public bool GetConnectionInfo(int node, ConnectionOptions c1, ConnectionOptions c2, out string friendlyName)
		{
			try
			{
                XmlNodeList nodeList = m_xmlConfig.DocumentElement.SelectNodes("DBCompares/DBCompare");

                XmlNode nodeRoot = nodeList[node];

                friendlyName = nodeRoot.Attributes["name"].Value;

                XmlNode nodeDatabases = nodeRoot.SelectSingleNode("Databases");

                if ( nodeDatabases == null )
                {
                    throw new Exception ("Database information not specified in the config file");                
                }
                else if ( nodeDatabases.ChildNodes.Count != 2 )
                {
                    throw new Exception ("Number of database child elements should be equal to two");
                }

                XmlNode nodeDb = nodeDatabases.FirstChild;
                XmlNode tempNode = nodeDb.SelectSingleNode("ServerName");
                if (tempNode != null)
                    c1.ServerName = tempNode.InnerText;

                tempNode = nodeDb.SelectSingleNode("DatabaseName");
                if (tempNode != null)
                    c1.DatabaseName = tempNode.InnerText;

                nodeDb = nodeDatabases.LastChild;

                tempNode = nodeDb.SelectSingleNode("ServerName");
                if (tempNode != null)
                    c2.ServerName = tempNode.InnerText;

                tempNode = nodeDb.SelectSingleNode("DatabaseName");
                if (tempNode != null)
                    c2.DatabaseName = tempNode.InnerText;

                // Load the control file...
                tempNode = nodeRoot.SelectSingleNode("control");
                if (tempNode != null)
                {
                    ControlXML.Load(tempNode.InnerText);
                }
			}
			catch (Exception e)
			{
				throw e;
			}
			return true;
		}


		/// <summary>
		/// This method creates the result XML content based on the differences list
		/// </summary>
		/// <param name="lstDifferences">List of difference objects</param>
		/// <param name="objDb1">database object</param>
		/// <param name="objDb2">database object</param>
		/// <returns>XMLDocument generated from the difference list</returns>
		void CreateResultXml(InternalList lstDifferences, Database objDb1, Database objDb2)
		{
			m_xmlResult = new XmlDocument();
			XmlDeclaration dec = m_xmlResult.CreateXmlDeclaration("1.0","utf-8",null);
			m_xmlResult.AppendChild(dec);
			
			XmlNode nodeLog =  m_xmlResult.CreateNode(XmlNodeType.Element,"SchemaDiff","");
			m_xmlResult.AppendChild(nodeLog);

			XmlNode nodeDatabases = m_xmlResult.CreateNode(XmlNodeType.Element, "Databases", "");
			AppendDatabaseInfo(nodeDatabases, objDb1);
			AppendDatabaseInfo(nodeDatabases, objDb2);
			nodeLog.AppendChild(nodeDatabases);

			XmlNode nodeDifferences = m_xmlResult.CreateNode(XmlNodeType.Element, "Differences", "");
			IEnumerator enumDifferences = lstDifferences.GetEnumerator();
			while (enumDifferences.MoveNext())
			{
				Difference diff = (Difference)enumDifferences.Current;
				AppendDifferenceInfo(nodeDifferences, diff);
			}
			nodeLog.AppendChild(nodeDifferences);

		}
		
		
		/// <summary>
		/// This method creates the Database node and adds it to the result XML node 
		/// </summary>
		/// <param name="node">XmlNode to which database information is appended</param>
		/// <param name="objDb"></param>
		void AppendDatabaseInfo (XmlNode node, Database objDb)
		{
			XmlNode dBNode = m_xmlResult.CreateNode(XmlNodeType.Element, "Database", "");
			AppendElementWithText ( dBNode, "ServerName", objDb.ConnectOptions.ServerName);
			AppendElementWithText ( dBNode, "DatabaseName", objDb.ConnectOptions.DatabaseName);
			node.AppendChild(dBNode);
		}

		
		/// <summary>
		/// This method creates the difference node and adds it to the result XML node 
		/// </summary>
		/// <param name="node"></param>
		/// <param name="objDiff"></param>
		void AppendDifferenceInfo (XmlNode node, Difference objDiff)
		{
			XmlNode diffNode = m_xmlResult.CreateNode(XmlNodeType.Element, "Difference", "");
			AppendElementWithText ( diffNode, "SQLObjectType", objDiff.ObjectType.ToString());
			AppendElementWithText ( diffNode, "Name", objDiff.SqlObjectName);
			AppendElementWithText ( diffNode, "DifferenceType", objDiff.SqlDifferenceType.ToString());
			if ( objDiff.DiffList != null )
			{
				XmlNode nodeDiffDetails = m_xmlResult.CreateNode(XmlNodeType.Element, "Details", "");
				IEnumerator enumDifferences = objDiff.DiffList.GetEnumerator();
				while (enumDifferences.MoveNext())
				{
					Difference diff = (Difference)enumDifferences.Current;
					AppendDifferenceChildInfo(nodeDiffDetails, diff);
				}
				diffNode.AppendChild(nodeDiffDetails);
			}
			node.AppendChild(diffNode);
		}

		
		/// <summary>
		/// Internal method to add difference details to the result file
		/// </summary>
		/// <param name="node"></param>
		/// <param name="objDiff"></param>
		void AppendDifferenceChildInfo (XmlNode node, Difference objDiff)
		{
			XmlNode diffNode = m_xmlResult.CreateNode(XmlNodeType.Element, "DetailedInfo", "");
			AppendElementWithText ( diffNode, "SQLObjectType", objDiff.ObjectType.ToString());
			AppendElementWithText ( diffNode, "Name", objDiff.SqlObjectName);
			AppendElementWithText ( diffNode, "DifferenceType", objDiff.SqlDifferenceType.ToString());
			node.AppendChild(diffNode);
		}
		

		/// <summary>
		/// This internal method creates a node and adds it to a parent node 
		/// </summary>
		/// <param name="node"></param>
		/// <param name="ElementName"></param>
		/// <param name="TextValue"></param>
		void AppendElementWithText(XmlNode node, string ElementName , string TextValue)
		{
			XmlNode pvnode = m_xmlResult.CreateNode(XmlNodeType.Element,ElementName,"");
			XmlNode text = m_xmlResult.CreateNode(XmlNodeType.Text,TextValue,"");
			text.Value = TextValue;
			pvnode.AppendChild(text);
			node.AppendChild(pvnode);

		}
		

        public InternalList GetSqlObjectTypes()
        {
            if ( m_xmlConfig != null )
            {
                XmlNode nodeRoot = m_xmlConfig.SelectSingleNode("SchemaDiff");
                XmlNode nodeSqlObjects = nodeRoot.SelectSingleNode("SqlObjects");
                if ( nodeSqlObjects != null && nodeSqlObjects.ChildNodes.Count > 0 )
                {
                    XmlNodeList nodeSqlObjectTypes = nodeSqlObjects.ChildNodes;
                    m_sqlObjectTypes = new InternalList();

                    foreach(XmlNode objNode in nodeSqlObjectTypes)
                    {
                        ISchemaObject sqlObjectType = GetSqlObject( objNode.Name );
                        
                        if( sqlObjectType != null )
                        {
                            m_sqlObjectTypes.Add(sqlObjectType);
                        }
                    
                    }
                }
            }
            return m_sqlObjectTypes;
        }

        ISchemaObject GetSqlObject (string name)
        {
            ISchemaObject iSqlObject = null;
            if ( name != null && name != string.Empty )
            {
                switch ( name.ToLower() )
                {
                    case "storedprocedures": 
                        iSqlObject = new StoredProcedure();
                        break;
                    case "trigger":
                        iSqlObject = new Trigger();
                        break;
                    case "views":
                        iSqlObject = new View();
                        break;
                    case "functions":
                        iSqlObject = new UserFunction();
                        break;
                    case "tables":
                        iSqlObject = new Table();
                        break;
                    case "roles":
                        iSqlObject = new Role();
                        break;
                    default:
                        iSqlObject = null;
                        break;
                }       
            }
            return iSqlObject;
        }

        public InternalList CompareSpecificObjectTypes(Database dB1, Database dB2, System.Type type)
        {
            InternalList diffList = new InternalList();
            if ( type != null)
            {
                switch (type.Name)
                {
                    case "Table":
                    {
                        diffList = dB1.CompareTables(dB2);
                        break;
                    }
                    case "View":
                    {
                        diffList = dB1.CompareViews(dB2);
                        break;
                    }
                    case "StoredProcedure":
                    {
                        diffList = dB1.CompareStoredProcedures(dB2);
                        break;
                    }
                    case "UserFunction":
                    {
                        diffList = dB1.CompareFunctions(dB2);
                        break;
                    }
                    case "Trigger":
                    {
                        diffList = dB1.CompareTriggers(dB2);
                        break;
                    }
                    case "Role":
                    {
                        diffList = dB1.CompareRoles(dB2);
                        break;
                    }                
                }            
            }
            return diffList;
        }

        /*public InternalList FilterExcludeList (InternalList diffList)
        {
            if ( m_xmlConfig != null )
            {
                XmlNode nodeRoot = m_xmlConfig.SelectSingleNode("SchemaDiff");
                XmlNodeList nodeExcludeList = nodeRoot.SelectNodes (@"SqlObjects/StoredProcedures/Exclude");

                nodeExcludeList.t
                Console.WriteLine(nodeExcludeList.Count);
            }      
            return diffList;
        }*/

		#endregion commonfunctions
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\ISchemaObject.cs ===
using System;
using System.Collections;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
	/// <summary>
	/// Defines the interface for all Schema objects in the system. Eg. Table, View etc.
	/// </summary>
	public interface ISchemaObject
	{	
		#region functions

		/// <summary>
		/// This method provides the interface for checking if the two schema object are same
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns true or false</returns>
		bool Equals(ISchemaObject p_schemaObj);

		/// <summary>
		/// This method provides the interface for comparing two schema objects for equality bases on their names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>
		int Compare(ISchemaObject p_schemaObj);

		/// <summary>
		/// This method provides the interface for loading the current schema object
		/// </summary>
		void Load ();

		#endregion functions

		#region properties

		/// <summary>
		/// This has a handle to the database object to which the ISchemaObject belongs
		/// </summary>
		Database Database {get; set;}

		/// <summary>
		/// This defines the SQLObjectType of the ISchemaObject i.e. Table, StoredProcedure etc.
		/// </summary>
		SQLObjectType Type {get;}

		/// <summary>
		/// This holds the name of the ISchemaObject as defined in the database
		/// </summary>
		string Name {get; set;}

		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. Some of the ISchemaObject 
		/// like Table, Roles have further properties defined of type ISchemaObject for eg. Indexes, 
		/// Columns etc.
		/// </summary>
		InternalList DifferenceList {get;}


		#endregion properties
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\Data.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Xml;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
    /// <summary>
    /// Class used for comparing data between two tables with identical schema
    /// </summary>
    public static class Data
    {
        /// <summary>
        /// Sets the output folder for the data XMLs to be written
        /// </summary>
        public static string OutputFolder = "";

        private static XmlDocument tokenXML;

        /// <summary>
        /// Compares the data between 2 schema identical tables
        /// </summary>
        /// <param name="tableLeft">Base table to compare</param>
        /// <param name="tableRight">Table to be compared</param>
        /// <param name="indexes">Comma separated list of Index column names</param>
        /// <returns>True if data is identical</returns>
        public static bool CompareTable(Table tableLeft, Table tableRight, string indexes)
        {
            InternalList resultList = new InternalList();
            XmlDocument xmlDiff = new XmlDocument();
            xmlDiff.LoadXml("<table><Differences/></table>");
            string cols = indexes;
            if (indexes == "" || indexes == null)
                indexes = "";
            
            foreach (Column col in tableLeft.Columns)
            {
                if (!indexes.ToUpper().Contains(col.Name.ToUpper()))
                    cols = (string)(cols + "," + col.Name).Trim(',');
            }

            // Special case if there is only 1 col since it breaks tokens and a few other things...
            if (tableLeft.Columns.Count() == 1)
            {
                string sQueryLeft = String.Format("Select {0} from {1}", cols, tableLeft.Name);
                string sQueryRight = String.Format("Select {0} from {1}", cols, tableRight.Name);
                xmlDiff.DocumentElement.SetAttribute("Query", sQueryLeft);
                CompareDataSingle(xmlDiff, tableRight, tableLeft, sQueryLeft, sQueryRight, cols);
            }
            else
            {
                // if there are no indexes, make indexes=cols so that we use every column!
                if (indexes == "")
                    indexes = cols;

                string sQueryLeft = String.Format("Select {0} from {1} ORDER BY {2}", cols, tableLeft.Name, indexes);
                string sQueryRight = String.Format("Select {0} from {1} ORDER BY {2}", cols, tableRight.Name, indexes);
                xmlDiff.DocumentElement.SetAttribute("Query", sQueryLeft);
                CompareData(xmlDiff, tableRight, tableLeft, sQueryLeft, sQueryRight, indexes.Split(',').Length);
            }

            // check for differences and save out if there are
            if (xmlDiff.DocumentElement.SelectNodes("Differences/Difference").Count > 0)
            {
                string outPath = System.IO.Path.Combine(OutputFolder,tableRight.Database.DBCompareInstance);
                if (!System.IO.Directory.Exists(outPath))
                    System.IO.Directory.CreateDirectory(outPath);
                xmlDiff.Save(string.Format(@"{0}\{1}.xml", outPath, tableRight.Name));
                return false;
            }
            return true;
        }
        
        /*private static void LogDifference(XmlDocument xmlDoc, string DiffLocation, string index, string key, string valueLeft, string valueRight)
        {
            XmlElement diff = xmlDoc.CreateElement("Difference");
            xmlDoc.DocumentElement.AppendChild(diff);
            XmlElement parent = xmlDoc.CreateElement("Keys");
            diff.AppendChild(parent);
            XmlElement node;
            string[] keys = key.Split('|');
            string[] indexes = index.Split(',');
            for (int i =0;i<keys.Length;i++)
            {
                node = xmlDoc.CreateElement("Key");
                node.SetAttribute("name", indexes[i]);
                node.SetAttribute("value", keys[i]);
                parent.AppendChild(node);
            }
            diff.SetAttribute("ExistsIn", DiffLocation);
            parent = xmlDoc.CreateElement("Values");
            node = xmlDoc.CreateElement("Left");
            node.InnerText = valueLeft;
            parent.AppendChild(node);
            node = xmlDoc.CreateElement("Right");
            node.InnerText = valueRight;
            parent.AppendChild(node);
            diff.AppendChild(parent);

        }*/

        private static void LogDifference(XmlDocument xmlDoc, string DiffLocation, int colCnt, SqlDataReader valueLeft, SqlDataReader valueRight)
        {
            XmlElement diff = xmlDoc.CreateElement("Difference");
            xmlDoc.DocumentElement.SelectSingleNode("Differences").AppendChild(diff);
            XmlElement parent = xmlDoc.CreateElement("Values");
            diff.AppendChild(parent);
            XmlElement node;
            for (int i = 0; i < colCnt; i++)
            {
                if (valueLeft != null)
                {
                    node = xmlDoc.CreateElement("Value");
                    node.SetAttribute("name", valueLeft.GetName(i));
                    node.SetAttribute("location", "left");
                    if (!valueLeft.IsDBNull(i))
                        node.InnerText = getSQLObjectAsString(valueLeft.GetSqlValue(i));
                    parent.AppendChild(node);
                }
                if (valueRight != null)
                {
                    node = xmlDoc.CreateElement("Value");
                    node.SetAttribute("name", valueRight.GetName(i));
                    node.SetAttribute("location", "right");
                    if (!valueRight.IsDBNull(i))
                        node.InnerText = getSQLObjectAsString(valueRight.GetSqlValue(i));
                    parent.AppendChild(node);
                }
            }
            diff.SetAttribute("ExistsIn", DiffLocation);
        }

        private static void LogDifference(XmlDocument xmlDoc, string DiffLocation, string colName, string valueLeft, string valueRight)
        {
            XmlElement diff = xmlDoc.CreateElement("Difference");
            xmlDoc.DocumentElement.SelectSingleNode("Differences").AppendChild(diff);
            XmlElement parent = xmlDoc.CreateElement("Values");
            diff.AppendChild(parent);
            XmlElement node;
            if (valueLeft != "")
            {
                node = xmlDoc.CreateElement("Value");
                node.SetAttribute("name", colName);
                node.SetAttribute("location", "left");
                node.InnerText = valueLeft;
                parent.AppendChild(node);
            }
            if (valueRight != "")
            {
                node = xmlDoc.CreateElement("Value");
                node.SetAttribute("name", colName);
                node.SetAttribute("location", "right");
                node.InnerText = valueRight;
                parent.AppendChild(node);
            }
            diff.SetAttribute("ExistsIn", DiffLocation);
        }

        /*private static Dictionary<String, String> GetData(Table table, string query, int idxCnt)
        {
            SqlDataReader p_SqlReader = null;
            Dictionary<String, String> resultDict = new Dictionary<string, string>();
            string keys, values;
            try
            {
                table.Database.GetConnection();
                table.Database.SqlDBCommand.CommandText = query;

                table.Database.SqlDBConnection.Open();
                p_SqlReader = table.Database.SqlDBCommand.ExecuteReader();
                while (p_SqlReader.Read())
                {
                    keys = "";
                    values = "";
                    if (!p_SqlReader.IsDBNull(0))
                    {
                        for (int column = 0; column < p_SqlReader.FieldCount; column++)
                        {
                            if (p_SqlReader.IsDBNull(column))
                                continue;
                            object val = p_SqlReader.GetSqlValue(column);
                            if (column < idxCnt)
                            {
                                keys = (string)(keys + "|" + getSQLObjectAsString(val)).Trim('|');
                            }
                            else
                            {
                                if (!(val is SqlDateTime))
                                    values += getSQLObjectAsString(val);
                            }
                        }
                    }
                    if (keys == "" || keys == null)
                        continue;
                    resultDict.Add(keys, values);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Data.GetData() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
            finally
            {
                if (p_SqlReader != null)
                    p_SqlReader.Close();
                if (table.Database.SqlDBConnection != null)
                    table.Database.SqlDBConnection.Close();
            }
            return resultDict;
        }
        */

        private static string getSQLObjectAsString(object value)
        {
            if (value is SqlBinary) return getHexadecimal(((SqlBinary)value).Value);
            if (value is SqlBoolean) return ((SqlBoolean)value).Value.ToString();
            if (value is SqlByte) return ((SqlByte)value).Value.ToString();
            if (value is SqlDateTime) return ((SqlDateTime)value).Value.ToString("yyyy-MM-dd HH:mm:ss.FFFFFFF");
            if (value is SqlDecimal) return ((SqlDecimal)value).Value.ToString();
            if (value is SqlDouble) return ((SqlDouble)value).Value.ToString("X");
            if (value is SqlGuid) return ((SqlGuid)value).Value.ToString();
            if (value is SqlInt16) return ((SqlInt16)value).Value.ToString();
            if (value is SqlInt32) return ((SqlInt32)value).Value.ToString("X");
            if (value is SqlInt64) return ((SqlInt64)value).Value.ToString("X");
            if (value is SqlMoney) return ((SqlMoney)value).Value.ToString();
            if (value is SqlSingle) return ((SqlSingle)value).Value.ToString("X");
            if (value is SqlXml) return ((SqlXml)value).Value.ToString();
            return value.ToString(); 
        }

        private static int CompareSQLObject(object value1, Object value2)
        {
            if (value1 is SqlBinary) return ((SqlBinary)value1).CompareTo(value2);
            if (value1 is SqlBoolean) return ((SqlBoolean)value1).CompareTo(value2);
            if (value1 is SqlByte) return ((SqlByte)value1).CompareTo(value2);
            if (value1 is SqlDateTime) return ((SqlDateTime)value1).CompareTo(value2);
            if (value1 is SqlDecimal) return ((SqlDecimal)value1).CompareTo(value2);
            if (value1 is SqlDouble) return ((SqlDouble)value1).CompareTo(value2);
            if (value1 is SqlGuid) return ((SqlGuid)value1).CompareTo(value2);
            if (value1 is SqlInt16) return ((SqlInt16)value1).CompareTo(value2);
            if (value1 is SqlInt32) return ((SqlInt32)value1).CompareTo(value2);
            if (value1 is SqlInt64) return ((SqlInt64)value1).CompareTo(value2);
            if (value1 is SqlMoney) return ((SqlMoney)value1).CompareTo(value2);
            if (value1 is SqlSingle) return ((SqlSingle)value1).CompareTo(value2);
            //if (value1 is SqlXml) return ((SqlXml)value1).CompareTo(value2);
            return value1.ToString().CompareTo(value2.ToString());
        }

        private static string getHexadecimal(byte[] array)
        {
            StringBuilder Builder;
            Builder = new StringBuilder(array.Length * 2 + 2);
            Builder.Append("0x");
            for (int c = 0; c < array.Length; c++)
                Builder.AppendFormat("{0:X2}", array[c]);
            return Builder.ToString();
        }

        /// <summary>
        /// Gets the fully qualified name of the schemaObject with ServerName and Database Name
        /// </summary>
        /// <param name="schemaObject">Database object</param>
        /// <returns>Full name of object</returns>
        public static string getFullName(ISchemaObject schemaObject)
        {
            return String.Format("{0}.{1}", schemaObject.Database.ConnectOptions.ServerName, schemaObject.Database.DatabaseName);
        }

        private static bool CheckTokenReplacement(XmlDocument xmlDiff, string leftVal, string rightVal)
        {
            return CheckTokenReplacement(xmlDiff, leftVal, rightVal, 0, 0);
        }

        private static bool CheckTokenReplacement(XmlDocument xmlDiff, string leftVal, string rightVal, int ptrLeft, int ptrRight)
        {
            string replacement, token;
            int nextToken=-1;

            // Find location of first #
            int start = leftVal.IndexOf("#XBLOB_", ptrLeft)-ptrLeft;
            int end = leftVal.IndexOf('#', start + ptrLeft  + 1)-ptrLeft;

            if (start < 0 || end < 0)
                return false;

            // find the token...  and then the replacement text
            token = leftVal.Substring(start+ptrLeft, end - start + 1);
            if (ptrLeft + end + 1 >= leftVal.Length)
            {
                replacement = rightVal.Substring(start+ptrRight);
            }
            else
            {
                nextToken = leftVal.IndexOf('#', ptrLeft + end + 1);
                if (nextToken < 0)
                {
                    replacement = rightVal.Substring(start+ptrRight, rightVal.IndexOf(leftVal.Substring(ptrLeft+end + 1),ptrRight) - start);
                }
                else
                {
                    replacement = rightVal.Substring(start + ptrRight, rightVal.IndexOf(leftVal.Substring(ptrLeft + end + 1,nextToken-ptrLeft-end-1), ptrRight) - start);
                }
            }

            // Make sure we have a Token XML...
            if (tokenXML == null)
            {
                tokenXML = new XmlDocument();
                tokenXML.LoadXml("<tokens />");
            }
            // Check to see if we have found this token before... if we have, compare the replacement value... if not, add it
            XmlNode testNode = tokenXML.DocumentElement.SelectSingleNode("token[@name='" + token + "']");
            if (testNode!=null)
            {
                if (testNode.InnerText != replacement)
                {
                    Console.WriteLine("WARNING: Token {0} had changed replacement text of '{1}' from '{2}'!  Logging to data compare files.", token, replacement, testNode.InnerText);
                    return false;
                }
            }
            else
            {
                XmlElement node = tokenXML.CreateElement("token");
                node.SetAttribute("name", token);
                node.InnerText = replacement;
                tokenXML.DocumentElement.AppendChild(node);
                // Save out token XML here so we save only after we add a new node instead of every data check...
                tokenXML.Save(string.Format(@"{0}\token.xml", OutputFolder));
            }

            // Check to see if there are anymore tokens in this before we exit...
            if (nextToken > 0)
            {
                CheckTokenReplacement(xmlDiff, leftVal, rightVal, nextToken, nextToken - ptrLeft + ptrRight);
            }

            return true;            
        }

        private static bool CompareData(XmlDocument xmlDiff, Table rightTable, Table leftTable, string queryLeft, string queryRight, int keyCount)
        {
            SqlDataReader rightReader = null;
            SqlDataReader leftReader = null;
            try
            {
                rightTable.Database.GetConnection();
                leftTable.Database.GetConnection();
                rightTable.Database.SqlDBCommand.CommandText = queryRight;
                leftTable.Database.SqlDBCommand.CommandText = queryLeft;

                rightTable.Database.SqlDBConnection.Open();
                leftTable.Database.SqlDBConnection.Open();
                rightReader = rightTable.Database.SqlDBCommand.ExecuteReader();
                leftReader = leftTable.Database.SqlDBCommand.ExecuteReader();

                bool isLeftMove, isRightMove;

                isLeftMove = leftReader.Read();
                isRightMove = rightReader.Read();
                bool Advance, TokenMatch;
                while (isLeftMove && isRightMove)
                {

                    Advance = true;
                    TokenMatch = false;
                    for (int column = 0; column < rightReader.FieldCount; column++)
                    {
                        if (rightReader.IsDBNull(column))
                            continue;
                        object rightVal = rightReader.GetSqlValue(column);
                        object leftVal = leftReader.GetSqlValue(column);
                        // if we are in an index, check those and advance if the index doesn't match... else general check
                        if (column < keyCount)
                        {
                            //rightKeys = (string)(rightKeys + "|" + getSQLObjectAsString(rightVal)).Trim('|');
                            //Verify token replacements... we are going to add them to the Diff XML in a Replacements node
                            if (leftVal.ToString().Contains("#XBLOB_"))
                            {
                                if (CheckTokenReplacement(xmlDiff, leftVal.ToString(), rightVal.ToString()))
                                    continue;
                            }

                            // Compare values...
                            int rslt = CompareSQLObject(leftVal, rightVal);
                            if (rslt<0)
                            {
                                LogDifference(xmlDiff, getFullName(leftTable), rightReader.FieldCount, leftReader, null);
                                isLeftMove = leftReader.Read();
                                Advance = false;
                                break;
                            }
                            if (rslt>0)
                            {
                                LogDifference(xmlDiff, getFullName(rightTable), rightReader.FieldCount, null, rightReader);
                                isRightMove = rightReader.Read();
                                Advance = false;
                                break;
                            }
                        }
                        else
                        {
                            //if (!(rightVal is SqlDateTime))
                            {
                                //Verify token replacements... we are going to add them to the Diff XML in a Replacements node
                                if (leftVal.ToString().Contains("#XBLOB_"))
                                {
                                    TokenMatch = CheckTokenReplacement(xmlDiff, leftVal.ToString(), rightVal.ToString());
                                }
                                if (!TokenMatch)
                                {
                                    if (!rightVal.Equals(leftVal))
                                    {
                                        LogDifference(xmlDiff, "Both", rightReader.FieldCount, leftReader, rightReader);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (Advance)
                    {
                        isLeftMove = leftReader.Read();
                        isRightMove = rightReader.Read();
                    }
                }
                // loop through any remaining left...
                while (leftReader.Read())
                {
                    LogDifference(xmlDiff, getFullName(leftTable), leftReader.FieldCount, leftReader, null);
                }
                // then right...
                while (rightReader.Read())
                {
                    LogDifference(xmlDiff, getFullName(rightTable), rightReader.FieldCount, null, rightReader);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Data.CompareData() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
            finally
            {
                if (rightReader != null)
                    rightReader.Close();
                if (leftReader != null)
                    leftReader.Close();
                if (rightTable.Database.SqlDBConnection != null)
                    rightTable.Database.SqlDBConnection.Close();
                if (leftTable.Database.SqlDBConnection != null)
                    leftTable.Database.SqlDBConnection.Close();
            }
            return true;
        }

        /// <summary>
        /// Compares the data of two tables when there is just 1 column
        /// </summary>
        /// <param name="xmlDiff">XML Document to write differences</param>
        /// <param name="rightTable">Right table to compare</param>
        /// <param name="leftTable">Original left table</param>
        /// <param name="query">Query string</param>
        /// <param name="col"></param>
        /// <returns></returns>
        private static bool CompareDataSingle(XmlDocument xmlDiff, Table rightTable, Table leftTable, string queryLeft, string queryRight, string col)
        {
            string[] leftValues, rightValues;
            try
            {
                leftValues = GetRowList(leftTable, String.Format("{0} WHERE {1} not in ({2})", queryRight, col, MakeSQLList(GetRowList(rightTable,queryRight))));
                rightValues = GetRowList(rightTable, String.Format("{0} WHERE {1} not in ({2})", queryLeft, col, MakeSQLList(GetRowList(leftTable, queryLeft))));

                int left = 0;
                int right = 0;
                string leftVal, rightVal;
                bool Advance, tokenReplace;
                while (left < leftValues.Length && right < rightValues.Length)
                {
                    Advance = true;
                    tokenReplace = false;
                    leftVal = leftValues[left];
                    rightVal = rightValues[right];
                    //Verify token replacements... we are going to add them to the Diff XML in a Replacements node
                    if (leftVal.ToString().Contains("#XBLOB_"))
                    {
                        tokenReplace = CheckTokenReplacement(xmlDiff, leftVal, rightVal);
                    }

                    if (!tokenReplace)
                    {
                        // Compare values...
                        int rslt = CompareSQLObject(leftVal, rightVal);
                        if (rslt < 0)
                        {
                            LogDifference(xmlDiff, getFullName(leftTable), col, leftVal, null);
                            left++;
                            Advance = false;
                        }
                        if (rslt > 0)
                        {
                            LogDifference(xmlDiff, getFullName(rightTable), col, null, rightVal);
                            right++;
                            Advance = false;
                        }
                    }
                    if (Advance)
                    {
                        left++;
                        right++;
                    }
                }
                // loop through any remaining left...
                while (left < leftValues.Length)
                {
                    LogDifference(xmlDiff, getFullName(leftTable), col, leftValues[left], null);
                    left++;
                }
                // then right...
                while (right < rightValues.Length)
                {
                    LogDifference(xmlDiff, getFullName(rightTable), col, null, rightValues[right]);
                    right++;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Data.CompareData() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }

            return true;
        }

        private static string[] GetRowList(Table table, string query)
        {
            table.Database.GetConnection();
            table.Database.SqlDBCommand.CommandText = query;

            table.Database.SqlDBConnection.Open();
            SqlDataReader dataReader = table.Database.SqlDBCommand.ExecuteReader();

            System.Collections.Specialized.StringCollection rows = new System.Collections.Specialized.StringCollection();
            while (dataReader.Read())
            {
                rows.Add(dataReader.GetValue(0).ToString());
            }
            dataReader.Close();
            table.Database.SqlDBConnection.Close();
            string[] dataArray = new string[rows.Count];
            rows.CopyTo(dataArray, 0);
            return dataArray; // String.Join(",", dataArray);
        }

        private static string MakeSQLList(string[] NameArray)
        {
            string[] modName = new string[NameArray.Length];
            for (int i=0;i<NameArray.Length;i++)
            {
                modName[i] = String.Format("'{0}'",NameArray[i]);
            }
            string rslt = String.Join(",", modName);
            if (rslt == string.Empty)
                rslt = "''";
            return rslt;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\ControlXML.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
    /// <summary>
    /// Controls if DB objects are included in the compare
    /// </summary>
    public static class ControlXML
    {
        private static XmlDocument _xmlDoc;

        /// <summary>
        /// Loads an Control XML from a file
        /// </summary>
        /// <param name="controlXMLPath">Path to XML file</param>
        public static void Load(string controlXMLPath)
        {
            if (!System.IO.File.Exists(controlXMLPath))
            {
                throw new Exception(String.Format("Control File '{0}' does not exist."));
            }
            
            _xmlDoc = new XmlDocument();
            _xmlDoc.Load(controlXMLPath);
        }

        /// <summary>
        /// Loads a Control XML file from a XML String
        /// </summary>
        /// <param name="XMLString">Valid XML string</param>
        public static void LoadXML(string XMLString)
        {
            _xmlDoc = new XmlDocument();
            _xmlDoc.LoadXml(XMLString);
        }

        /// <summary>
        /// Checks an object to see if it should be included in the schema compare
        /// </summary>
        /// <param name="ObjectType">SQL object type (table,storedprocedure,view, etc) </param>
        /// <param name="ObjectName">Name of the object</param>
        /// <returns>True if it should include the object in the schema compare</returns>
        public static bool IncludeSchema(string ObjectType, string ObjectName)
        {
            if (_xmlDoc == null)  // bail out if there is no control XML
                return true;

            XmlNode node = _xmlDoc.SelectSingleNode(String.Format("control/{0}s/{0}[@name='{1}']/schema",ObjectType, ObjectName));
            if (node == null)
            {
                node = _xmlDoc.SelectSingleNode(String.Format("control/{0}s/default/schema",ObjectType));
                if (node == null)
                {
                    return true;  // The default default is include...
                }
            }
            return (node.Attributes["behavior"].Value == "include" || node.Attributes["behavior"].Value != "exclude");
        }

        /// <summary>
        /// Checks a table to see if it should be included in the data compare
        /// </summary>
        /// <param name="ObjectName">Name of the table</param>
        /// <returns>True if it should include the object in the data compare</returns>
        public static bool IncludeData(string ObjectName)
        {
            if (_xmlDoc == null)  // bail out if there is no control XML
                return true;

            XmlNode node = _xmlDoc.SelectSingleNode(String.Format("control/tables/table[@name='{0}']/data", ObjectName));
            if (node == null)
            {
                node = _xmlDoc.SelectSingleNode("control/tables/default/data");
                if (node == null)
                {
                    return true;  // The default default is include...
                }
            }
            return (node.Attributes["behavior"].Value == "include" || node.Attributes["behavior"].Value != "exclude");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\Role.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{

	/// <summary>
	/// This enumeration defines the various action types available for permissions object
	/// </summary>
	public enum ActionType
    {
        /// <summary></summary>
        Insert,
        /// <summary></summary>
        Update,
        /// <summary></summary>
        Delete,
        /// <summary></summary>
        Select,
        /// <summary></summary>
        Execute,
        /// <summary></summary>
        References,
        /// <summary></summary>
        CreateTable,
        /// <summary></summary>
        CreateRule,
        /// <summary></summary>
        CreateDatabase,
        /// <summary></summary>
        CreateFunction,
        /// <summary></summary>
        CreateView,
        /// <summary></summary>
        CreateProcedure,
        /// <summary></summary>
        BackupDatabase,
        /// <summary></summary>
		CreateDefault,
        /// <summary></summary>
        BackupLog,
        /// <summary></summary>
        Undefined
    };

	/// <summary>
	/// This enumeration defines the various levels of protection - Grant, Revoke, Deny
	/// </summary>
	public enum ProtectionType
    {
        /// <summary></summary>
        Grant,
        /// <summary></summary>
        Revoke,
        /// <summary></summary>
        Deny,
        /// <summary></summary>
        None
    };

	/// <summary>
	/// This enumeration defines the various levels of permissions
	/// All = Permission covers all current columns of the object.
	/// New = Permission covers any new columns that might be altered (by using the ALTER statement) on the object in the future.
	/// All+New = Combination of All and New.
	/// </summary>
	public enum PermissionType
    {
        /// <summary></summary>
        All,
        /// <summary></summary>
        New,
        /// <summary></summary>
        AllNew,
        /// <summary></summary>
        None
    };


	/// <summary>
	/// This class represents the Roles SQL Object and implements ISchemaObject interface.
	/// </summary>
	public class Role : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;
		
		private InternalList m_lstDifference;

		// this list contains all the permissions
		// sets for the role
		private InternalList m_lstPermissions;

		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the Role object belongs
		/// </summary>
        public Database Database 
		{
			get 
			{
				return m_database;
			}

            set  
            {
                m_database = value;
            }
		}

		/// <summary>
		/// This is of enumeration type SQLObjectType.Role
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the Role object as defined in the database
		/// </summary>

		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }
        }
		
		/// <summary>
		/// This holds the list of difference objects for Role. The difference list consists of all
		/// the differences between permission objects for this role.
		/// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}
		/// <summary>
		/// This holds a list of all the permissions defined for this Role.
		/// </summary>

		public InternalList Permissions
		{
			get 
			{
				return m_lstPermissions;
			}
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		#endregion properties

        #region constructor
        /// <summary>
        /// 
        /// </summary>
        public Role ()
        {
            this.m_ObjType = SQLObjectType.Role;
            this.m_lstDifference = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
        public Role (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Role;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}
        #endregion

		#region functions
		
		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Role object and have the same name and associated permissions.
		/// </summary>
		/// <param name="p_schemaObj">Role object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
	
		public bool Equals(ISchemaObject p_schemaObj)
		{
			//load the object data
			if ( p_schemaObj == null || p_schemaObj.Type != SQLObjectType.Role
				|| this.Name != p_schemaObj.Name )
				return false;

			this.Load();
			p_schemaObj.Load();
			Role p_tmpObj = (Role)p_schemaObj;
			m_lstDifference = new InternalList();
			m_lstDifference = SchemaDiffUtil.CompareObjects(this.Permissions, p_tmpObj.Permissions);

			if ( m_lstDifference.Count() > 0 ) 
				return false;
			else
				return true;
		}

		/// <summary>
		/// This method compares two schema objects of type Role for equality bases on their names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>

		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}


		/// <summary>
		/// Loads the object including all the permission objects associated
		/// </summary>
		public void Load ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "sp_helprotect null, " + m_strName;
				this.Database.SqlDBConnection.Open();				
				m_lstPermissions = new InternalList();
                p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(1) )
                    {
                        Permission p_objPerm = new Permission(this.Database, p_SqlReader.GetString(1).ToUpper());
                        if ( !p_SqlReader.IsDBNull(2) )
                            p_objPerm.Grantee = p_SqlReader.GetString(2).ToUpper();
                        if ( !p_SqlReader.IsDBNull(4) )
                            p_objPerm.ProtectType = GetProtectionType(p_SqlReader.GetString(4).ToUpper());
                        if ( !p_SqlReader.IsDBNull(5) )
                            p_objPerm.Action = GetActionType(p_SqlReader.GetString(5).ToUpper());
                        if ( !p_SqlReader.IsDBNull(6) )
                            p_objPerm.RolePermission = GetPermissionType(p_SqlReader.GetString(6).ToUpper());
                        m_lstPermissions.Add(p_objPerm);
                    }
                }
			}
            catch (SqlException e)
            {
                //if the role has no permissions, do not throw an exception
                if (!e.Message.Contains("There are no matching rows on which to report."))
                {
                    throw;
                }
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}		
		}


		/// <summary>
		/// This method returns the actiontype enum value based on the string input from SQL
		/// </summary>
		/// <param name="p_strAction">ActionType value returned from SQL</param>
		/// <returns>ActionType Enumeration value</returns>
		internal static ActionType GetActionType (string p_strAction)
		{
			ActionType p_enumActionType = ActionType.Undefined;
			if ( p_strAction != null )
			{
				switch (p_strAction)
				{
					case "EXECUTE":
						p_enumActionType = ActionType.Execute;
						break;
					case "INSERT":
						p_enumActionType = ActionType.Insert;
						break;
					case "UPDATE":
						p_enumActionType = ActionType.Update;
						break;
					case "DELETE":
						p_enumActionType = ActionType.Delete;
						break;
					case "SELECT":
						p_enumActionType = ActionType.Select;
						break;
					case "CREATE TABLE":
						p_enumActionType = ActionType.CreateTable;
						break;
					case "CREATE DATABASE":
						p_enumActionType = ActionType.CreateDatabase;
						break;
					case "CREATE FUNCTION":
						p_enumActionType = ActionType.CreateFunction;
						break;
					case "CREATE RULE":
						p_enumActionType = ActionType.CreateRule;
						break;
					case "CREATE VIEW":
						p_enumActionType = ActionType.CreateView;
						break;
					case "CREATE PROCEDURE":
						p_enumActionType = ActionType.CreateProcedure;
						break;
					case "BACKUP DATABASE":
						p_enumActionType = ActionType.BackupDatabase;
						break;
					case "CREATE DEFAULT":
						p_enumActionType = ActionType.CreateDefault;
						break;
					case "BACKUP LOG":
						p_enumActionType = ActionType.BackupLog;
						break;
					case "REFERENCES":
						p_enumActionType = ActionType.References;
						break;
					default:
						p_enumActionType = ActionType.Undefined;
						break;
				}
			}
			return p_enumActionType;
		}

	
		/// <summary>
		/// This method returns the protection type enum value based on the string input from SQL 
		/// </summary>
        /// <param name="p_strProtect">protection type value from SQL</param>
		/// <returns>ProtectionType enumeration value</returns>
		internal static ProtectionType GetProtectionType (string p_strProtect)
		{
			ProtectionType p_enumProtectType = ProtectionType.None;
			if ( p_strProtect != null )
			{
				switch (p_strProtect)
				{
					case "DENY":
						p_enumProtectType = ProtectionType.Deny;
						break;
					case "GRANT":
						p_enumProtectType = ProtectionType.Grant;
						break;
					case "REVOKE":
						p_enumProtectType = ProtectionType.Revoke;
						break;
					default:
						p_enumProtectType = ProtectionType.None;
						break;
				}
			}
			return p_enumProtectType;
		}


		/// <summary>
		/// This method returns the permission type enum value based on the string input from SQL 
		/// </summary>
		/// <param name="p_strPerm">permission type value from SQL</param>
		/// <returns>permissionType enumeration value</returns>
		internal static PermissionType GetPermissionType (string p_strPerm)
		{
			PermissionType p_enumPermType = PermissionType.None;
			if ( p_strPerm != null )
			{
				switch (p_strPerm)
				{
					case "ALL":
						p_enumPermType = PermissionType.All;
						break;
					case "ALL+NEW":
						p_enumPermType = PermissionType.AllNew;
						break;
					case "NEW":
						p_enumPermType = PermissionType.New;
						break;
					default:
						p_enumPermType = PermissionType.None;
						break;
				}
			}
			return p_enumPermType;
		}
		
		#endregion functions

	}
	
	
	/// <summary>
	/// This class represents the Permission SQL Object and implements ISchemaObject interface.
	/// </summary>
	public class Permission : ISchemaObject
	{
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;

		private InternalList m_lstDifference;

		string m_strGrantee;

		PermissionType m_enumPermissionType;

		ActionType m_enumActionType;

		ProtectionType m_enumProtectType;

		#endregion variables

		#region properties

		/// <summary>
		/// 
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

        /// <summary>
        /// 
        /// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public string Grantee 
		{
			get 
			{
				return m_strGrantee;
			}
			set
			{
				m_strGrantee = value;
			}		
		}

        /// <summary>
        /// 
        /// </summary>
		public PermissionType RolePermission 
		{
			get 
			{
				return m_enumPermissionType;
			}
			set
			{
				m_enumPermissionType = value;
			}		
		}

        /// <summary>
        /// 
        /// </summary>
		public ActionType Action 
		{
			get 
			{
				return m_enumActionType;
			}
			set
			{
				m_enumActionType = value;
			}		
		}

        /// <summary>
        /// 
        /// </summary>
		public ProtectionType ProtectType
		{
			get 
			{
				return m_enumProtectType;
			}
			set
			{
				m_enumProtectType = value;
			}		
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		#endregion properties

		#region constructor

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public Permission (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Permission;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}
		#endregion constructor

		#region functions
	
		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Permission object and have the same name and associated permissions level, 
		/// action etc.
		/// </summary>
		/// <param name="p_objSchema">Role object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals (ISchemaObject p_objSchema)
		{
			if (p_objSchema == null)
				return false;
			else
			{
				Permission p_objPerm = (Permission)p_objSchema;
				if ( this.Name == p_objPerm.Name &&
						this.Grantee == p_objPerm.Grantee &&
						this.Action == p_objPerm.Action &&
						this.RolePermission == p_objPerm.RolePermission )
					return true;
				else
					return false;
			}
		}


		/// <summary>
		/// This method compares two schema objects of type Permission for equality based on their names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}


		/// <summary>
		/// Loads the Permission object. Current implementation is empty.
		/// </summary>
		public void Load(){}

		#endregion functions
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\StoredProcedure.cs ===
using System;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
	/// <summary>
	/// This class represents the StoredProcedure SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>

	public class StoredProcedure : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;
		
		private InternalList m_lstDifference;

		// This is the helptext returned for this stored procedure
		private string m_strText;

//        Dictionary<string, string> m_extendedProperties;

		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the stored procedure belongs
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.StoredProcedure
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the stored procedure object as defined in the database
		/// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }

		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// stored procedures.
		/// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}
		/// <summary>
		/// This holds the sp_helptext information of the stored procedure as defined in the database.
		/// </summary>
		public string Text
		{
			get
			{
				return m_strText;
			}
		}


		#endregion properties

		#region constructor
        /// <summary>
        /// 
        /// </summary>
        public StoredProcedure ()
        {
            this.m_ObjType = SQLObjectType.StoredProcedure;
            this.m_lstDifference = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public StoredProcedure (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.StoredProcedure;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}

		#endregion constructor

		#region functions
/*
        /// <summary>
        /// Loads the Extended Properties of the table
        /// </summary>
        public void LoadExtendedProperties()
        {
            SqlDataReader p_SqlReader = null;
            try
            {
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = String.Format("SELECT name, value FROM fn_listextendedproperty (NULL, 'schema', 'dbo', 'table', '{0}', NULL, NULL);", m_strName);

                this.Database.SqlDBConnection.Open();
                p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
                m_extendedProperties = new Dictionary<string,string>();
                
                while (p_SqlReader.Read())
                {
                    if (!p_SqlReader.IsDBNull(0))
                    {
                        m_extendedProperties.Add(p_SqlReader.GetString(0), p_SqlReader.GetString(1));
                        if (p_SqlReader.GetString(0) == "XBL_DataReplication")
                        {
                            this.m_replicateData = (p_SqlReader.GetString(1) != "0");
                        }
                        if (p_SqlReader.GetString(0) == "XBL_SchemaReplication")
                        {
                            this.m_replicateSchema = (p_SqlReader.GetString(1) != "0");
                        }
                    }
                }
                Console.WriteLine(String.Format("{0} Extended Properties: {1}", m_strName, m_extendedProperties.Count));
                if (!m_extendedProperties.ContainsKey("XBL_DataReplication"))
                {
                    Console.WriteLine(String.Format("{0}: Extended Property XBL_DataReplication missing.", m_strName));
                }
                if (!m_extendedProperties.ContainsKey("XBL_SchemaReplication"))
                {
                    Console.WriteLine(String.Format("{0}: Extended Property XBL_SchemaReplication missing.", m_strName));
                }
            }
            finally
            {
                if (p_SqlReader != null)
                    p_SqlReader.Close();
                if (this.Database.SqlDBConnection != null)
                    this.Database.SqlDBConnection.Close();
            }

        }
*/
		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// StoredProcedure object and have the same name and helptext.
		/// </summary>
		/// <param name="p_schemaObj">StoredProcedure object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>

		public bool Equals(ISchemaObject p_schemaObj)
		{
			//load the object data
			if ( p_schemaObj == null || p_schemaObj.Type != SQLObjectType.StoredProcedure 
				|| this.Name != p_schemaObj.Name )
				return false;

			this.Load();
			p_schemaObj.Load();
			StoredProcedure p_tmpObj = (StoredProcedure)p_schemaObj;
			// does a plain text comparison
            bool test = SchemaDiffUtil.TextDiff(this.Text, p_tmpObj.Text);

            // log to results if failed...
            if (!test)
                SchemaDiffUtil.LogSprocAsXML(this.Name, Data.getFullName(this), this.Text, Data.getFullName(p_tmpObj), p_tmpObj.Text);

            return test;
		}


		/// <summary>
		/// This method compares two schema objects of type StoredProcedure 
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>

		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}

		
		/// <summary>
		/// Loads the help text data for the stored procedure object
		/// </summary>
		public void Load ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "sp_helptext " + m_strName;
				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				StringBuilder p_helpText = new StringBuilder();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0) )
                        p_helpText.Append(p_SqlReader.GetString(0).Trim());
				}

				m_strText = p_helpText.ToString().ToUpper();
			}
            catch (Exception e)
            {
                Console.WriteLine("StoredProcedure Load() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
                    this.Database.SqlDBConnection.Close();
			}
		}

		#endregion functions
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\Trigger.cs ===
using System;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
	/// <summary>
	/// This class represents the Trigger SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	/// 
	public class Trigger : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;
		
		private InternalList m_lstDifference;

		// This is the helptext returned for this trigger
		private string m_strText;

		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the trigger belongs
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.Trigger
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the trigger object as defined in the database
		/// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }
		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// triggers.
		/// </summary>

		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}

		/// <summary>
		/// This holds the sp_helptext information of the trigger as defined in the database.
		/// </summary>
		public string Text
		{
			get
			{
				return m_strText;
			}
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		#endregion properties

		#region constructor
        /// <summary>
        /// 
        /// </summary>
        public Trigger ()
        {
            this.m_ObjType = SQLObjectType.Trigger;
            this.m_lstDifference = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public Trigger (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Trigger;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}
		#endregion constructor

		#region functions

		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Trigger object and have the same name and helptext.
		/// </summary>
		/// <param name="p_schemaObj">Trigger object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals(ISchemaObject p_schemaObj)
		{
			//load the object data
			if ( p_schemaObj == null || p_schemaObj.Type != SQLObjectType.Trigger 
				|| this.Name != p_schemaObj.Name )
				return false;

			this.Load();
			p_schemaObj.Load();
			Trigger p_tmpObj = (Trigger)p_schemaObj;
			// does a plain text comparison
			return SchemaDiffUtil.TextDiff(this.Text, p_tmpObj.Text);
		}

		
		/// <summary>
		/// This method compares two schema objects of type StoredProcedure 
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}

		
		/// <summary>
		/// Loads the help text data for the Trigger object
		/// </summary>
		public void Load ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "sp_helptext " + m_strName;
				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				StringBuilder p_helpText = new StringBuilder();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0) )
                        p_helpText.Append(p_SqlReader.GetString(0).Trim());
				}

				m_strText = p_helpText.ToString().ToUpper();
			}
            catch (Exception e)
            {
                Console.WriteLine("Trigger.Load() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}
		}
		#endregion functions
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\SchemaDiffUtil.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.IO;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{    

	/// <summary>
	/// This enumeration defines the various types of SQL objects being compared.
	/// </summary>
	public enum SQLObjectType
    {
        /// <summary></summary>
        Table,
        /// <summary></summary>
        StoredProcedure,
        /// <summary></summary>
        Function,
        /// <summary></summary>
        View,
        /// <summary></summary>
        Trigger,
        /// <summary></summary>
        Constraint,
        /// <summary></summary>
        Role,
        /// <summary></summary>
        Index,
        /// <summary></summary>
        Permission,
        /// <summary></summary>
        Column,
        /// <summary></summary>
        Undefined
    };

	/// <summary>
	/// This enumeration defines the various types of Difference between SQL objects.
	/// AvailableIn1 - When a SQLObject is present only in the first database.
	/// AvailableIn2 - When a SQLObject is present only in the second database.
	/// Different - When SQLObject is present in both databases but is different.
	/// Same - When SQLObject is same.
	/// </summary>
	public enum DifferenceType
    {
		/// <summary>
		/// The sql object is available only in the first database
		/// </summary>
		AvailableIn1, 
		/// <summary>
		/// The sql object is available only in the second database
		/// </summary>
		AvailableIn2, 
		/// <summary>
		/// The sql object is available in both database but is different
		/// </summary>
		Different, 
		/// <summary>
		/// The sql object is available in both database and is same
		/// </summary>
		Same
    };
	
	/*/// <summary>
	/// This exception encapsulates all exceptions thrown by the application - TBD  
	/// </summary>*/
	/*public class SchemaDiffException : Exception
	{
		public SchemaDiffException (Exception e)
		{

		}
	}*/
	

	/// <summary>
	/// This class contains all utility functions used in the application 
	/// </summary>
	internal class SchemaDiffUtil
	{
		
		#region HelperFunctions

		/// <summary>
		/// This method returns a list of all Objects which are available in the first 
		/// database (p_objDatabase1) and not in second database(p_objDatabase2). 
		/// Currently, it returns objects of all type.																																															 /// </summary>
		/// <param name="p_objDatabase1">First Database</param>
		/// <param name="p_objDatabase2">Second Database</param>
		/// <param name="p_diffType">Difference type either AvailableIn1 or AvailabeIn2</param>
		/// <returns>List of Difference objects</returns>
		internal static InternalList GetMissingObjects (Database p_objDatabase1, Database p_objDatabase2, 
													DifferenceType p_diffType)
		{
			SqlDataReader p_SqlReader = null;
			InternalList arTempList = new InternalList();
			try
			{
				//Open the Sql Connection
				p_objDatabase1.SqlDBCommand.CommandText 
					= "SELECT name, type FROM sysobjects WHERE " 
					+ "name NOT IN (SELECT name FROM "
					+ p_objDatabase2.DatabaseName
					+ "..sysobjects)";

				p_objDatabase1.SqlDBConnection.Open();
				p_SqlReader = p_objDatabase1.SqlDBCommand.ExecuteReader();
				while(p_SqlReader.Read())
				{
					// Create a difference object for every missing SQLObject.
					Difference diff = new Difference();
					diff.SqlObjectName = p_SqlReader.GetString(0);
					diff.SqlDifferenceType = p_diffType;
					// Retreive the SQLObjectType based on the SQL type output string
					diff.ObjectType = GetSQLObjectType(p_SqlReader.GetString(1));
					// add to difference list
					arTempList.Add(diff);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("SchemaDiffUtil.GetMissingObjects() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				// close all connections and readers
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( p_objDatabase1.SqlDBConnection != null ) 
					p_objDatabase1.SqlDBConnection.Close();
			}
			// return difference list
			return arTempList;
		}


		/// <summary>
		/// This is a static function which does a comparison between two lists
		/// containing similar objects
		/// </summary>
		/// <param name="p_lstFirst">First List of type InternalList</param>
		/// <param name="p_lstSecond">Second List of type InternalList</param>
		/// <returns>List of difference objects</returns>
		internal static InternalList CompareObjects (InternalList p_lstFirst, InternalList p_lstSecond)
		{
			// iterate through the list
			// if call compare for each object
			// based on diff type returned create the difference object
			// add to the differences list
			InternalList p_lstDifferences = new InternalList();
			if ( p_lstFirst == null || p_lstSecond == null ) 
				return null;
			

			Difference tmpDiff = null;
			IEnumerator p_EnumFirst = p_lstFirst.GetEnumerator();
			IEnumerator p_EnumSecond = p_lstSecond.GetEnumerator();

			//if ( p_EnumFirst.MoveNext() && p_EnumSecond.MoveNext() )
			{
				ISchemaObject p_objFirst = null;
                ISchemaObject p_objSecond = null;
                if ( p_EnumFirst.MoveNext() )
                    p_objFirst = (ISchemaObject)p_EnumFirst.Current;
                if ( p_EnumSecond.MoveNext() )			
                    p_objSecond = (ISchemaObject)p_EnumSecond.Current;
				
				while ( p_objFirst != null && p_objSecond != null )
				{
					switch ( p_objFirst.Compare(p_objSecond) )
					{
						case -1:
							tmpDiff = new Difference();
							tmpDiff.ObjectType = p_objFirst.Type;
							tmpDiff.SqlObjectName = p_objFirst.Name;
							tmpDiff.SqlDifferenceType = DifferenceType.AvailableIn1;
							p_lstDifferences.Add(tmpDiff);
							if (p_EnumFirst.MoveNext())
								p_objFirst = (ISchemaObject)p_EnumFirst.Current;
							else
								p_objFirst = null;
							break;

						case 1:
							tmpDiff = new Difference();
							tmpDiff.ObjectType = p_objFirst.Type;
							tmpDiff.SqlObjectName = p_objSecond.Name;
							tmpDiff.SqlDifferenceType = DifferenceType.AvailableIn2;
							p_lstDifferences.Add(tmpDiff);
							if ( p_EnumSecond.MoveNext() )
								p_objSecond = (ISchemaObject)p_EnumSecond.Current;
							else
								p_objSecond = null;
							break;
						case 0:
							if ( !p_objFirst.Equals(p_objSecond) )
							{
								tmpDiff = new Difference();
								tmpDiff.ObjectType = p_objFirst.Type;
								tmpDiff.SqlObjectName = p_objFirst.Name;
								tmpDiff.SqlDifferenceType = DifferenceType.Different;
								tmpDiff.DiffList = p_objFirst.DifferenceList;
								p_lstDifferences.Add(tmpDiff);
							}
							if ( p_EnumFirst.MoveNext() )
								p_objFirst = (ISchemaObject)p_EnumFirst.Current;
							else
								p_objFirst = null;
							if ( p_EnumSecond.MoveNext() )
								p_objSecond = (ISchemaObject)p_EnumSecond.Current;
							else
								p_objSecond = null;
							break;					
					}
				}

				while ( p_objFirst != null )
				{
					tmpDiff = new Difference();
					tmpDiff.ObjectType = p_objFirst.Type;
					tmpDiff.SqlObjectName = p_objFirst.Name;
					tmpDiff.SqlDifferenceType = DifferenceType.AvailableIn1;
					if (p_EnumFirst.MoveNext())
						p_objFirst = (ISchemaObject)p_EnumFirst.Current;				
					else
						p_objFirst = null;
					p_lstDifferences.Add(tmpDiff);
				}

				while ( p_objSecond != null )
				{
					tmpDiff = new Difference();
					tmpDiff.ObjectType = p_objSecond.Type;
					tmpDiff.SqlObjectName = p_objSecond.Name;
					tmpDiff.SqlDifferenceType = DifferenceType.AvailableIn2;
					p_lstDifferences.Add(tmpDiff);
					if(p_EnumSecond.MoveNext())
						p_objSecond = (ISchemaObject)p_EnumSecond.Current;
					else
						p_objSecond = null;
				}
			}
			return p_lstDifferences;
		}


		/// <summary>
		/// This method returns SQLObjectType Enumeration value based on sql type string 
		/// </summary>
		/// <param name="p_strObjType">The string representation of SQL Object as 
		/// retrieved from Database</param>
		/// <returns>Enumeration vale of SQLObjectType</returns>
		internal static SQLObjectType GetSQLObjectType (string p_strObjType)
		{
			SQLObjectType p_SqlObjType = SQLObjectType.Undefined;

			switch ( p_strObjType )
			{
				case "P": 
					p_SqlObjType = SQLObjectType.StoredProcedure;
					break;
				case "TR":
					p_SqlObjType = SQLObjectType.Trigger;
					break;
				case "V":
					p_SqlObjType = SQLObjectType.View;
					break;
				case "FN":
					p_SqlObjType = SQLObjectType.Function;
					break;
				case "U":
					p_SqlObjType = SQLObjectType.Table;
					break;
				case "K":
					p_SqlObjType = SQLObjectType.Constraint;
					break;
				case "F":
					p_SqlObjType = SQLObjectType.Constraint;
					break;
				case "C":
					p_SqlObjType = SQLObjectType.Constraint;
					break;
				case "D":
					p_SqlObjType = SQLObjectType.Constraint;
					break;
				default:
					p_SqlObjType = SQLObjectType.Undefined;
					break;
			}

			return p_SqlObjType;
		}

		
		/// <summary>
		/// This method sqltype string value based on SQLObjectType Enumeration type 
		/// </summary>
		/// <param name="p_SqlObjType">Enumeration vale of SQLObjectType</param>
		/// <returns>The string representation of SQL Object as 
		/// retrieved from Database</returns>
		/// 
		internal static string GetSQLType (SQLObjectType p_SqlObjType)
		{
			string p_strCmdType = "";

			switch ( p_SqlObjType )
			{
				case SQLObjectType.StoredProcedure:
					p_strCmdType = "P";
					break;
				case SQLObjectType.Trigger:
					p_strCmdType = "TR";
					break;
				case SQLObjectType.View:
					p_strCmdType = "V";
					break;
				case SQLObjectType.Function:
					p_strCmdType = "FN";
					break;
				case SQLObjectType.Table:
					p_strCmdType = "U";
					break;
				/*case SQLObjectType.Constraint:
					p_strCmdType = "";
					break;
				case SQLObjectType.ForiegnKey:
					p_strCmdType = "F";
					break;
				case SQLObjectType.Check:
					p_strCmdType = "C";
					break;
				case SQLObjectType.Default:
					p_strCmdType = "D";
					break;
				case SQLObjectType.Undefined:
					p_strCmdType = "";
					break;*/
				default:
					p_strCmdType = "";
					break;
			}
			return p_strCmdType;
		}

		
		/// <summary>
		/// This method performs a text comparion for SQL objects of type Storedprocedure,
		/// Triggers, User Functions and Views. This is currently based on simple text 
		/// comparison which can be modified further.
		/// </summary>
		/// <param name="strHelpText1">First string data to be compared</param>
		/// <param name="strHelpText2">Second string data to be compared</param>
		/// <returns></returns>
		internal static bool TextDiff ( string strHelpText1, string strHelpText2)
		{
			string strTempText1 = strHelpText1.Trim().ToLower();

			string strTempText2 = strHelpText2.Trim().ToLower();

            //Console.WriteLine("Length of str1" + strTempText1.Length);
            //Console.WriteLine("Length of str2" + strTempText2.Length);

            //Remove redundent spaces
            string temp1="";
            string temp2="";
            //bool hasBlank = false;
            for (int i = 0; i < strTempText1.Length; i++)
            {
                if (strTempText1[i] == '\n' || strTempText1[i] == '\r' || strTempText1[i] == '\t' || strTempText1[i]==' ')
                    continue;

                //if (strTempText1[i] == ' ')
                //{
                //    if (hasBlank)
                //        continue;
                //    else
                //    {
                //        temp1 += strTempText1[i];
                //        hasBlank = true;
                //    }
                //}
                //else
                //{
                    temp1 += strTempText1[i];
                //    hasBlank = false;
                //}
            }

            //hasBlank = false;

            for (int i = 0; i < strTempText2.Length; i++)
            {
                if (strTempText2[i] == '\n' || strTempText2[i] == '\r' || strTempText2[i] == '\t' ||strTempText2[i]==' ')
                    continue;

                //if (strTempText2[i] == ' ')
                //{
                //    if (hasBlank)
                //        continue;
                //    else
                //    {
                //        temp2 += strTempText2[i];
                //        hasBlank = true;
                //    }
                //}
                //else
                //{
                    temp2 += strTempText2[i];
                    //hasBlank = false;
                //}
            }
            strTempText1 = temp1;
            strTempText2 = temp2;
            //Console.WriteLine("Length of str1 after remove redundent spaces" + strTempText1.Length);
            //Console.WriteLine("Length of str2 after remove redundent spaces" + strTempText2.Length);

            
            if (strTempText1 == strTempText2)
                return true;
            else
            {
                //Console.WriteLine(strTempText1);
                //Console.WriteLine(strTempText2);
                
                for (int i = 0; i < strTempText1.Length; i++)
                {
                    if (i < strTempText2.Length)
                    {
                        if (strTempText1[i] != strTempText2[i])
                        {
                            /*
                            Console.WriteLine("strTempText1[{0}] is {1}", i-1, strTempText1[i-1]);
                            Console.WriteLine("strTempText2[{0}] is {1}", i-1, strTempText2[i-1]);
                            Console.WriteLine("strTempText1[{0}] is {1}", i, strTempText1[i]);
                            Console.WriteLine("strTempText2[{0}] is {1}", i, strTempText2[i]);
                            Console.WriteLine("strTempText1[{0}] is {1}", i + 1, strTempText1[i + 1]);
                            Console.WriteLine("strTempText2[{0}] is {1}", i +1, strTempText2[i + 1]);
                             */
                            //Console.WriteLine(i);
                            //Console.WriteLine("str1 : " + strTempText1.Substring(((i-10)<0?0:i-10), 20));
                            //Console.WriteLine("str2 : " + strTempText2.Substring(((i-10)<0?0:i-10), 20));
                            break;
                        }
                    }
                    else
                    {
                        //Console.Write(strTempText1[i]);
                    }
                }
                 
                return false;
            }
		}

        internal static void LogSprocAsXML(string SprocName, string db1, string value1, string db2, string value2)
        {
            XmlDocument xmlDiff = new XmlDocument();
            xmlDiff.LoadXml("<Differences/>");
            XmlElement temp = xmlDiff.CreateElement("Difference");
            xmlDiff.DocumentElement.AppendChild(temp);
            temp.SetAttribute("SProc", db1);
            temp.InnerText = value1;
            temp = xmlDiff.CreateElement("Difference");
            xmlDiff.DocumentElement.AppendChild(temp);
            temp.SetAttribute("SProc", db2);
            temp.InnerText = value2;
            xmlDiff.Save(string.Format(@"{0}\{1}.xml", "results", SprocName));
            
        }


		#endregion HelperFunctions
		
	}


	/// <summary>
	/// This is an Collection class for this application 
	/// which is used to store object lists 
	/// </summary>

	public class InternalList : IEnumerable
	{
		#region IEnumerable Members

		IEnumerable m_List;
		
		/// <summary>
		/// This is a collection of all the objects belonging to InternalList
		/// </summary>
		public IEnumerable List
		{
			get
			{
				return m_List;
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public InternalList()
		{
			m_List = new ArrayList();
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="c"></param>
		public InternalList (ICollection c)
		{
			m_List = new ArrayList(c);
		}

		/// <summary>
		/// Returns the enumeration for the InternalList class
		/// </summary>
		/// <returns></returns>
		public IEnumerator GetEnumerator()
		{
			return m_List.GetEnumerator();
		}

		/// <summary>
		/// Adds an object to the internal list
		/// </summary>
		/// <param name="pObj">This is the item of type Object to be added to the list</param>
		public void Add (Object pObj)
		{
			ArrayList arrLstTemp = (ArrayList)m_List;
			arrLstTemp.Add(pObj);
		}

		/// <summary>
		/// This method add a collection of type InternalList to the current list
		/// </summary>
		/// <param name="iLst">Collection to be added</param>
		public void AddRange (InternalList iLst)
		{
			ArrayList arrLstTemp = (ArrayList)this.List;
			ArrayList arrLstTempAdd = (ArrayList)iLst.List;
			arrLstTemp.AddRange(arrLstTempAdd);
		}
		
		/// <summary>
		/// Returns the number of items in the list
		/// </summary>
		/// <returns>number of items in the list</returns>
		public int Count ()
		{
			ArrayList arrLstTemp = (ArrayList)m_List;
			return arrLstTemp.Count;
		}

		#endregion
	}

	
	/// <summary>
	/// This class defines the difference object between ISchemaObject Types
	/// </summary>

    public class Difference
	{
		#region variables

		private SQLObjectType m_SqlObjectType;

		private DifferenceType m_DiffType;
		
		private string m_SqlObjectName;

		private InternalList m_lstDifference;

		#endregion variables

		#region properties

		/// <summary>
		/// Defines the name of schema object under comparison 
		/// </summary>
		public string SqlObjectName
		{
			get
			{
				return m_SqlObjectName;
			}
			set
			{
				m_SqlObjectName = value;
			}
		}


		/// <summary>
		/// Defines the type of Schema object being compared eg. table, view etc.
		/// </summary>
		public SQLObjectType ObjectType
		{
			get
			{
				return m_SqlObjectType;
			}
			set
			{
				m_SqlObjectType = value;
			}
		}

		/// <summary>
		/// Defines the type of difference i.e. AvailableIn1, AvailableIn2 or Different 
		/// </summary>
		public DifferenceType	 SqlDifferenceType
		{
			get
			{
				return m_DiffType;
			}
			set
			{
				m_DiffType = value;
			}
		}

		/// <summary>
		/// Holds a list of difference details for some ISchemaObjects
		/// </summary>
		public InternalList DiffList
		{
			get
			{
				return m_lstDifference;
			}
			set
			{
				m_lstDifference = value;
			}
		}
		#endregion properties

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\Database.cs ===
using System;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Specialized;
using System.Collections;
using System.Text;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{    
	/// <summary>
	/// Database encapsulates all the information related to the database being compared.
	/// <remarks>    
	/// </remarks>
	/// </summary>
	public class Database
	{        
		#region variables

		private ConnectionOptions m_ConnOptions;
		private string m_strName;
		private SqlConnection m_SqlConnect;
		private SqlCommand m_SqlCommand;

		// SQL Objects
		private InternalList m_lstTables;
		private InternalList m_lstStoredProcs;
		private InternalList m_lstTriggers;
		private InternalList m_lstViews;
		private InternalList m_lstFunctions;
		private InternalList m_lstRoles;
        //private string m_DBCompareName;
		
		#endregion variables

		#region properties
		// public properties

		/// <summary>
		/// This property holds the name of the database being compared.
		/// </summary>
		public string DatabaseName
		{
			get
			{
				return m_strName;
			}
		}

        /// <summary>
        /// Name of the DBCompare instance.
        /// </summary>
        public string DBCompareInstance
        {
            get
            {
                return m_strName;
            }
        }

		/// <summary>
		/// This property holds the SqlCommand object
		/// </summary>
		public SqlCommand SqlDBCommand
		{
			get
			{
				return m_SqlCommand;
			}
		}

		/// <summary>
		/// This property holds a connection to the database
		/// </summary>
		public SqlConnection SqlDBConnection
		{
			get
			{
				return m_SqlConnect;
			}
		}

		/// <summary>
		/// Returns the connection options for this database i.e. servername, dBName etc.
		/// </summary>
		public ConnectionOptions ConnectOptions
		{
			get
			{
				return m_ConnOptions;
			}
		}

		/// <summary>
		/// This is a collection of all the user tables in the database
		/// </summary>
		public InternalList Tables 
		{
			get
			{
				return m_lstTables;
			}
		}

		/// <summary>
		/// This is a collection of all the stored procedures in the database
		/// </summary>
		public InternalList StoredProcedures 
		{
			get
			{
				return m_lstStoredProcs;
			}
		}

		/// <summary>
		/// This is a collection of all the user defined function in the database
		/// </summary>
		public InternalList Functions 
		{
			get
			{
				return m_lstFunctions;
			}
		}

		/// <summary>
		/// This is a collection of all the triggers defined in the database
		/// </summary>
		public InternalList Triggers 
		{
			get
			{
				return m_lstTriggers;
			}
		}

		/// <summary>
		/// This is a collection of all the views defined in the database
		/// </summary>
		public InternalList Views 
		{
			get
			{
				return m_lstViews;
			}
		}

		/// <summary>
		/// This is a collection of all the roles defined in the database
		/// </summary>
		public InternalList Roles 
		{
			get
			{
				return m_lstRoles;
			}
		}
		#endregion properties

		#region initFunctions

		/// <summary>
		/// Constructor for the Database class object
		/// </summary>
		public Database(string DBCompareName)
		{

		}

		/// <summary>
		/// Register the Database object given the connection parameters
		/// </summary>
		/// <param name="p_ConnOptions">Database connection information</param>
		/// <returns>Success/Failure to connect to the database</returns>
		
		public bool Register(ConnectionOptions p_ConnOptions)
		{
            try
            {
                // Set the connection property object
                m_ConnOptions = p_ConnOptions;
                m_strName = p_ConnOptions.DatabaseName;
			
                // Check for connectivity to the database else throw Exception

                //Define a Sql Connection & Command
                m_SqlConnect = new SqlConnection();
                m_SqlConnect.ConnectionString = "Data Source=" + m_ConnOptions.ServerName 
                    + "; Integrated Security=SSPI;"
                    + "Initial Catalog=" + m_ConnOptions.DatabaseName
                    + "; Pooling=False";

                m_SqlCommand = m_SqlConnect.CreateCommand();
                m_SqlCommand.CommandText = "Select @@SERVERNAME, db_name()";
                //Open the Sql Connection
                m_SqlConnect.Open();
                m_SqlCommand.ExecuteNonQuery();
                //m_SqlConnect.Close();
            }
            catch (SqlException sqlException)
            {
                Console.WriteLine(sqlException.ToString());
                return false;
            }
            finally
            {
                if ( m_SqlConnect != null ) 
                {
                    m_SqlConnect.Close();
                    m_SqlConnect.Dispose();
                }
            }
			return true;
		}

        internal void GetConnection ()
        {
            m_SqlConnect = new SqlConnection();
            m_SqlConnect.ConnectionString = "Data Source=" + this.ConnectOptions.ServerName
                + "; Integrated Security=SSPI;"
                + "Initial Catalog=" + this.ConnectOptions.DatabaseName
                + "; Pooling=False";

            m_SqlCommand = m_SqlConnect.CreateCommand();
        }

        #endregion initFunctions

		#region loadFunctions
		
		/// <summary>
		/// Loads all the table objects available in the database 
		/// </summary>
		public void LoadTables() 
		{
			SqlDataReader p_SqlReader = null;

			m_lstTables = new InternalList();

            try
            {
                GetConnection();
                //Open the Sql Connection
                /*this.SqlDBCommand.CommandText 
                    = "SELECT UPPER(name) FROM sysobjects WHERE Type = '" 
                    + SchemaDiffUtil.GetSQLType (SQLObjectType.Table) 
                    + "' Order by name";*/

                //this.SqlDBCommand.CommandText = "EXEC sp_tables null, null, null, \"'TABLE'\"";
                // <JK 24OCT07> This was returning system tables from replication so updated to the schema view.  Also changed the SQL Reader indexes
                this.SqlDBCommand.CommandText = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND OBJECTPROPERTY(OBJECT_ID(TABLE_NAME), 'IsMSShipped') = 0 AND OBJECTPROPERTY(OBJECT_ID(TABLE_NAME), 'IsSystemTable') = 0 AND OBJECT_ID(TABLE_NAME) NOT IN (Select major_id from sys.extended_properties Where name='microsoft_database_tools_support') ORDER BY TABLE_NAME;";

                this.SqlDBConnection.Open();

                p_SqlReader = this.SqlDBCommand.ExecuteReader();

                while (p_SqlReader.Read())
                {
                    if (!p_SqlReader.IsDBNull(0))
                    {
                        if (ControlXML.IncludeSchema("table", p_SqlReader.GetString(0)))
                        {
                            Table p_tmpTbl = new Table(this, p_SqlReader.GetString(0));
                            m_lstTables.Add(p_tmpTbl);
                        }
                        else
                        {
                            Console.WriteLine("Table {0} excluded from comparison.", p_SqlReader.GetString(0));
                        }
                    }
                }
                // </JK 24OCT07> 
            }
            catch (Exception e)
            {
                Console.WriteLine("LoadTable() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.SqlDBConnection != null ) 
					this.SqlDBConnection.Close();
			}
		}

		/// <summary>
		/// Loads all the stored procedure objects available in the database 
		/// </summary>
		public void LoadStoredProcedures() 
		{
			SqlDataReader p_SqlReader = null;

			m_lstStoredProcs = new InternalList();
			try
			{
				
                GetConnection();
                //Open the Sql Connection
				/*this.SqlDBCommand.CommandText 
					= "SELECT UPPER(name) FROM sysobjects WHERE Category = 0 AND Type = '" 
					+ SchemaDiffUtil.GetSQLType (SQLObjectType.StoredProcedure) 
					+ "' Order by name";*/

                this.SqlDBCommand.CommandText 
                    = "SELECT UPPER(ROUTINE_NAME) FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_NAME like 'p_%' ORDER BY ROUTINE_NAME";

				this.SqlDBConnection.Open();

				p_SqlReader = this.SqlDBCommand.ExecuteReader();

				while(p_SqlReader.Read())
				{
					StoredProcedure p_tmpStoredProc 
						= new StoredProcedure( this, p_SqlReader.GetString(0));

					m_lstStoredProcs.Add(p_tmpStoredProc);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("LoadStoredProcedures() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.SqlDBConnection != null ) 
					this.SqlDBConnection.Close();
			}
		}

		/// <summary>
		/// Loads all the view objects available in the database 
		/// </summary>
		public void LoadViews() 
		{
			SqlDataReader p_SqlReader = null;

			m_lstViews = new InternalList();
			try
			{
                GetConnection();
                //Open the Sql Connection
				/*this.SqlDBCommand.CommandText 
					= "SELECT UPPER(name) FROM sysobjects WHERE Type = '" 
					+ SchemaDiffUtil.GetSQLType (SQLObjectType.View) 
					+ "' Order by name";*/
                // <JK 24OCT07> Limit Views list by non-install views
                this.SqlDBCommand.CommandText = "SELECT UPPER(TABLE_NAME) FROM INFORMATION_SCHEMA.VIEWS WHERE OBJECTPROPERTY(OBJECT_ID(TABLE_NAME), 'IsMsShipped') = 0 ORDER BY TABLE_NAME";
				this.SqlDBConnection.Open();

				p_SqlReader = this.SqlDBCommand.ExecuteReader();

				while(p_SqlReader.Read())
				{
					View p_tmpView 
						= new View( this, p_SqlReader.GetString(0));

					m_lstViews.Add(p_tmpView);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("LoadViews() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.SqlDBConnection != null ) 
					this.SqlDBConnection.Close();
			}
		}

		/// <summary>
		/// Loads all the user defined function objects available in the database 
		/// </summary>
		public void LoadFunctions() 
		{
			SqlDataReader p_SqlReader = null;

			m_lstFunctions = new InternalList();
			try
			{
                GetConnection();
                //Open the Sql Connection
				/*this.SqlDBCommand.CommandText 
					= "SELECT UPPER(name) FROM sysobjects WHERE Type = '" 
					+ SchemaDiffUtil.GetSQLType (SQLObjectType.Function) 
					+ "' ORDER BY name";*/
				this.SqlDBCommand.CommandText
                    = "SELECT UPPER(ROUTINE_NAME) FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'FUNCTION' AND OBJECT_ID(ROUTINE_NAME) NOT IN (Select major_id from sys.extended_properties Where name='microsoft_database_tools_support') ORDER BY ROUTINE_NAME";

				this.SqlDBConnection.Open();

				p_SqlReader = this.SqlDBCommand.ExecuteReader();

				while(p_SqlReader.Read())
				{
					UserFunction p_tmpFunction
						= new UserFunction( this, p_SqlReader.GetString(0));

					m_lstFunctions.Add(p_tmpFunction);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("LoadFunctions() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.SqlDBConnection != null ) 
					this.SqlDBConnection.Close();
			}
		}


		/// <summary>
		/// Loads all the trigger objects available in the database 
		/// </summary>
		public void LoadTriggers() 
		{
			SqlDataReader p_SqlReader = null;

			m_lstTriggers = new InternalList();
			try
			{
                GetConnection();
                //Open the Sql Connection
				this.SqlDBCommand.CommandText 
					= "SELECT UPPER(name) FROM sysobjects WHERE Type = '" 
					+ SchemaDiffUtil.GetSQLType (SQLObjectType.Trigger) 
					+ "' Order by name";

				this.SqlDBConnection.Open();

				p_SqlReader = this.SqlDBCommand.ExecuteReader();

				while(p_SqlReader.Read())
				{
					Trigger p_tmpTrigger
						= new Trigger ( this, p_SqlReader.GetString(0));

					m_lstTriggers.Add(p_tmpTrigger);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("LoadTriggers() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.SqlDBConnection != null ) 
					this.SqlDBConnection.Close();
			}
		}


		/// <summary>
		/// Loads all the role objects available in the database 
		/// </summary>
		public void LoadRoles() 
		{
			SqlDataReader p_SqlReader = null;

			m_lstRoles = new InternalList();
			try
			{
                GetConnection();
                //Open the Sql Connection
				this.SqlDBCommand.CommandText 
					= "SELECT UPPER(name) FROM sysusers WHERE isSQLRole = 1 AND gid <> 0 ORDER BY name";

				this.SqlDBConnection.Open();

				p_SqlReader = this.SqlDBCommand.ExecuteReader();

				while(p_SqlReader.Read())
				{
					Role p_tmpRole
						= new Role( this, p_SqlReader.GetString(0));

					m_lstRoles.Add(p_tmpRole);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("LoadRoles() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.SqlDBConnection != null ) 
					this.SqlDBConnection.Close();
			}
		}


		/// <summary>
		/// Loads all SQL objects available in the database 
		/// </summary>
		public void LoadAll ()
		{
			LoadTables();
			LoadStoredProcedures();
			LoadFunctions();
			LoadViews();
			LoadTriggers();
			LoadRoles();
		}

		#endregion loadFunctions

		#region compareFunctions
		
		/// <summary>
		/// This method does a comparison of SQL objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects</returns>
		public InternalList Compare (Database p_database)
		{
			InternalList p_lstDifferences = new InternalList();
			this.LoadAll();
            p_database.LoadAll();
			InternalList p_lstTemp = CompareTables(p_database);
			p_lstDifferences.AddRange(p_lstTemp);
			
			p_lstTemp = CompareStoredProcedures(p_database);
			p_lstDifferences.AddRange(p_lstTemp);

			p_lstTemp = CompareFunctions(p_database);
			p_lstDifferences.AddRange(p_lstTemp);

			p_lstTemp = CompareViews(p_database);
			p_lstDifferences.AddRange(p_lstTemp);

			p_lstTemp = CompareTriggers(p_database);
			p_lstDifferences.AddRange(p_lstTemp);

			p_lstTemp = CompareRoles(p_database);
			p_lstDifferences.AddRange(p_lstTemp);

			return p_lstDifferences;
		}


		/// <summary>
		/// This method does a comparison of table objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects for tables</returns>
		public InternalList CompareTables (Database p_database)
		{
			if ( this.Tables == null ) this.LoadTables();
            if ( p_database.Tables == null ) p_database.LoadTables();

            if ( this.Tables == null || p_database.Tables == null )
				return null;
			// call a function which does comparison of the two iterators
			InternalList p_lstDifferences = SchemaDiffUtil.CompareObjects (this.Tables, p_database.Tables);
			return p_lstDifferences;
		}

		
		/// <summary>
		/// This method does a comparison of Stored procedure objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects for stored procedures</returns>
		public InternalList CompareStoredProcedures (Database p_database)
		{
            if ( this.StoredProcedures == null ) this.LoadStoredProcedures();
            if ( p_database.StoredProcedures == null ) p_database.LoadStoredProcedures();
			
            if ( this.StoredProcedures == null || p_database.StoredProcedures == null )
				return null;
			// call a function which does comparison of the two iterators
			InternalList p_lstDifferences = SchemaDiffUtil.CompareObjects (this.StoredProcedures, p_database.StoredProcedures);
			return p_lstDifferences;
		}

		/// <summary>
		/// This method does a comparison of function objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects for function</returns>
		public InternalList CompareFunctions (Database p_database)
		{
            if ( this.Functions == null ) this.LoadFunctions();
            if ( p_database.Functions == null ) p_database.LoadFunctions();
            if ( this.Functions == null || p_database.Functions == null )
				return null;
			// call a function which does comparison of the two iterators
			InternalList p_lstDifferences = SchemaDiffUtil.CompareObjects (this.Functions, p_database.Functions);
			return p_lstDifferences;
		}

		/// <summary>
		/// This method does a comparison of views objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects for views</returns>
		public InternalList CompareViews (Database p_database)
		{
            if ( this.Views == null ) this.LoadViews();
            if ( p_database.Views == null ) p_database.LoadViews();
            if ( this.Views == null || p_database.Views == null )
				return null;
			// call a function which does comparison of the two iterators
			InternalList p_lstDifferences = SchemaDiffUtil.CompareObjects (this.Views, p_database.Views);
			return p_lstDifferences;
		}

		/// <summary>
		/// This method does a comparison of triggers objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects for triggers</returns>
		public InternalList CompareTriggers (Database p_database)
		{
            if ( this.Triggers == null ) this.LoadTriggers();
            if ( p_database.Triggers == null ) p_database.LoadTriggers();
            if ( this.Triggers == null || p_database.Triggers == null )
				return null;
			// call a function which does comparison of the two iterators
			InternalList p_lstDifferences = SchemaDiffUtil.CompareObjects (this.Triggers, p_database.Triggers);
			return p_lstDifferences;
		}

		/// <summary>
		/// This method does a comparison of roles objects available in the database 
		/// </summary>
		/// <param name="p_database">This is the database with which the current database is compared</param>
		/// <returns>Returns a list of difference objects for roles</returns>
		public InternalList CompareRoles (Database p_database)
		{
            if ( this.Roles == null ) this.LoadRoles();
            if ( p_database.Roles == null ) p_database.LoadRoles();
            if ( this.Roles == null || p_database.Roles == null )
				return null;
			// call a function which does comparison of the two iterators
			InternalList p_lstDifferences = SchemaDiffUtil.CompareObjects (this.Roles, p_database.Roles);
			return p_lstDifferences;
		}
		#endregion compareFunctions

	}

	/// <summary>
	/// This class defines the connection properties for the database object
	/// </summary>

	public class ConnectionOptions
	{
		#region variables

		private String m_strServerName;
		private String m_strDatabaseName;
		//private String m_strUserName;
		//private String m_strPassword;
		//private bool m_bIntegratedSecurity;
		
		#endregion variables
		
		#region properties

		/// <summary>
		/// This holds the server name
		/// </summary>
		public String ServerName
		{
			get
			{
				return m_strServerName;
			}
			set
			{
				m_strServerName = value;
			}
		}

		/// <summary>
		/// This holds the database name
		/// </summary>
		public String DatabaseName
		{
			get
			{
				return m_strDatabaseName;
			}
			set
			{
				m_strDatabaseName = value;
			}
		}

		/*public String UserName
		{
			get
			{
				return m_strUserName;
			}
			set
			{
				m_strUserName = value;
			}
		}

		public String Password
		{
			get
			{
				return m_strPassword;
			}
			set
			{
				m_strPassword = value;
			}
		}

		public bool IntegratedSecurity
		{
			get
			{
				return m_bIntegratedSecurity;
			}
			set
			{
				m_bIntegratedSecurity = value;
			}
		}*/
		#endregion properties

        /// <summary>
        /// 
        /// </summary>
		public ConnectionOptions()
		{
			//m_bIntegratedSecurity = true;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\UserFunction.cs ===
using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
	/// <summary>
	/// This class represents the UserFunction SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	public class UserFunction : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;
		private InternalList m_lstDifference;

		// This is the helptext returned for this user defined function
		private string m_strText;
		
		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the function belongs
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.Function
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the function object as defined in the database
		/// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }
		
		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// functions.
		/// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}
		
		/// <summary>
		/// This holds the sp_helptext information of the function as defined in the database.
		/// </summary>
		public string Text
		{
			get
			{
				return m_strText;
			}
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		#endregion properties

		#region constructor

        /// <summary>
        /// 
        /// </summary>
        public UserFunction ()
        {
            this.m_ObjType = SQLObjectType.Function;
            this.m_lstDifference = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public UserFunction (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Function;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}
		#endregion constructor

		#region functions
		
		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// UserFunction object and have the same name and helptext.
		/// </summary>
		/// <param name="p_schemaObj">UserFunction object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals(ISchemaObject p_schemaObj)
		{
			//load the object data
			if ( p_schemaObj == null || p_schemaObj.Type != SQLObjectType.Function 
				|| this.Name != p_schemaObj.Name )
				return false;

			this.Load();
			p_schemaObj.Load();
			UserFunction p_tmpObj = (UserFunction)p_schemaObj;
			return SchemaDiffUtil.TextDiff(this.Text, p_tmpObj.Text);
		}

		
		/// <summary>
		/// This method compares two schema objects of type UserFunction
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>

		
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}

		
		/// <summary>
		/// Loads the help text data for the UserFunction object
		/// </summary>
		public void Load ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "sp_helptext " + m_strName;
				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				StringBuilder p_helpText = new StringBuilder();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0) )
                        p_helpText.Append(p_SqlReader.GetString(0).Trim());
				}

				m_strText = p_helpText.ToString().ToUpper();
			}
            catch (Exception e)
            {
                Console.WriteLine("UserFunction.Load() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}
		}

		#endregion function
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_schemadiffapi_none_12.4.56.0_none_39dfb8bd458c3b3d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=schemadiffapi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.manifest
XP_MANIFEST_PATH=manifests\msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.cat
XP_CATALOG_PATH=manifests\msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.cat
XP_PAYLOAD_PATH=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=schemadiffapi,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\View.cs ===
using System;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
	/// <summary>
	/// This class represents the View SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	public class View : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;

		private InternalList m_lstDifference;
		// This is the helptext returned for this view
		private string m_strText;

		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the  view belongs
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }
        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.View
		/// </summary>		
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the view object as defined in the database
		/// </summary>	
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }
        }

		/// <summary>
		/// This holds the sp_helptext information of the view as defined in the database.
		/// </summary>		
		public string Text
		{
			get
			{
				return m_strText;
			}
		}

		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// views.
		/// </summary>	
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		
		#endregion properties

		#region constructor

        /// <summary>
        /// 
        /// </summary>
        public View ()
        {
            this.m_ObjType = SQLObjectType.View;
            this.m_lstDifference = null;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public View (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.View;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}

		
		#endregion constructor

		#region functions

		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// View object and have the same name and helptext.
		/// </summary>
		/// <param name="p_schemaObj">View object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals(ISchemaObject p_schemaObj)
		{
			//load the object data
			if ( p_schemaObj == null || p_schemaObj.Type != SQLObjectType.View
				|| this.Name != p_schemaObj.Name )
				return false;

			this.Load();
			p_schemaObj.Load();
			View p_tmpObj = (View)p_schemaObj;
			return SchemaDiffUtil.TextDiff(this.Text, p_tmpObj.Text);
		}

		
		/// <summary>
		/// Loads the help text data for the View object
		/// </summary>
		public void Load ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "sp_helptext " + m_strName;
				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				StringBuilder p_helpText = new StringBuilder();
				while(p_SqlReader.Read())
				{
					if ( !p_SqlReader.IsDBNull(0) )
                        p_helpText.Append(p_SqlReader.GetString(0).Trim());
				}

				m_strText = p_helpText.ToString().ToUpper();
			}
            catch (Exception e)
            {
                Console.WriteLine("View.Load() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}
		}

		
		/// <summary>
		/// This method compares two schema objects of type View
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}
		#endregion functions
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_schemadiffapi_none_12.4.56.0_none_39dfb8bd458c3b3d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=schemadiffapi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.manifest
XP_MANIFEST_PATH=manifests\msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.cat
XP_CATALOG_PATH=manifests\msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217.cat
XP_PAYLOAD_PATH=msil_schemadiffapi_no-public-key_12.4.56.0_x-ww_ac177217
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=schemadiffapi,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SchemaDiff\SchemaDiffAPI\Table.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;

namespace Microsoft.Webstore.Test.SchemaDiffAPI
{
	/// <summary>
	/// This class represents the Table SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	public class Table : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;

		private Database m_database;

		private string m_strName;

        private string m_keys;

		private InternalList m_lstDifference;

		private InternalList m_lstColumns;

		private InternalList m_lstIndexes;

		private InternalList m_lstConstraints;
//        Dictionary<string, string> m_extendedProperties;

		
		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the table belongs
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.Table
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}
		/// <summary>
		/// This holds the name of the table object as defined in the database
		/// </summary>

		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }

		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. In case of tables this list 
		/// holds all the differences found for Columns, Indexes, Constraints defined for this table.
		/// </summary>
        public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}

		/// <summary>
		/// This holds a list of all the columns defined for this table
		/// </summary>
		public InternalList Columns
		{
			get
			{
				return m_lstColumns;
			}
		}

        public string Keys
        {
            get
            {
                return m_keys;
            }
        }

		/// <summary>
		/// This holds a list of all the constraints defined for this table
		/// </summary>
		public InternalList Constraints
		{
			get
			{
				return m_lstConstraints;
			}
		}	

		/// <summary>
		/// This holds a list of all the indexes defined for this table.
		/// </summary>
		public InternalList Indexes
		{
			get
			{
				return m_lstIndexes;
			}
		}

      

		#endregion properties

		#region constructor
        
        /// <summary>
        /// Default Constructor
        /// </summary>
        public Table ()
        {
            this.m_ObjType = SQLObjectType.Table;
            this.m_lstDifference = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
        public Table (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Table;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}
		
		#endregion constructor

		#region functions

		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Table object and have the same name and same columns, constraints, indexes etc.
		/// </summary>
		/// <param name="p_schemaObj">Table object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals(ISchemaObject p_schemaObj)
		{
			//load the object data
			if ( p_schemaObj == null || p_schemaObj.Type != SQLObjectType.Table
				|| this.Name != p_schemaObj.Name )
				return false;

			this.Load();
			p_schemaObj.Load();
			Table p_tmpObj = (Table)p_schemaObj;
			m_lstDifference = new InternalList();
			m_lstDifference =  SchemaDiffUtil.CompareObjects(this.Columns, p_tmpObj.Columns);
			m_lstDifference.AddRange(SchemaDiffUtil.CompareObjects(this.Constraints, p_tmpObj.Constraints));
			m_lstDifference.AddRange(SchemaDiffUtil.CompareObjects(this.Indexes, p_tmpObj.Indexes));
            // Data compare...
            if (ControlXML.IncludeData(this.Name))
            {
                // if there are differences, don't compare data...
                if (m_lstDifference.Count() > 0)
                {
                    Console.WriteLine("Schema different in {0}, Data not compared.", this.Name);
                    return false;
                }
                if (!Data.CompareTable(this, p_tmpObj, m_keys))
                {
                    Console.WriteLine("Data compare failed for table {0}.", this.Name);
                    return false;
                }
            }

			if (m_lstDifference.Count() > 0) 
				return false;
			else
				return true;
		}

		/// <summary>
		/// This method compares two schema objects of type Table 
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current
		/// object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object 
		/// is greater or +ve if it is lesser</returns>
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}
		
		
		/// <summary>
		/// Loads the various table properties like columns, constraints and indexes
		/// </summary>
		public void Load()
		{
            //LoadExtendedProperties();
            LoadKeys();
			LoadColumns();
			LoadConstraints();
			LoadIndexes();
		}
/*
        /// <summary>
        /// Loads the Extended Properties of the table
        /// </summary>
        public void LoadExtendedProperties()
        {
            SqlDataReader p_SqlReader = null;
            try
            {
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = String.Format("SELECT name, value FROM fn_listextendedproperty (NULL, 'schema', 'dbo', 'table', '{0}', NULL, NULL);", m_strName);

                this.Database.SqlDBConnection.Open();
                p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
                m_extendedProperties = new Dictionary<string,string>();
                
                while (p_SqlReader.Read())
                {
                    if (!p_SqlReader.IsDBNull(0))
                    {
                        m_extendedProperties.Add(p_SqlReader.GetString(0), p_SqlReader.GetString(1));
                        if (p_SqlReader.GetString(0) == "XBL_DataReplication")
                        {
                            this.m_replicateData = (p_SqlReader.GetString(1) != "0");
                        }
                        if (p_SqlReader.GetString(0) == "XBL_SchemaReplication")
                        {
                            this.m_replicateSchema = (p_SqlReader.GetString(1) != "0");
                        }
                    }
                }
                Console.WriteLine(String.Format("{0} Extended Properties: {1}", m_strName, m_extendedProperties.Count));
                if (!m_extendedProperties.ContainsKey("XBL_DataReplication"))
                {
                    Console.WriteLine(String.Format("{0}: Extended Property XBL_DataReplication missing.", m_strName));
                }
                if (!m_extendedProperties.ContainsKey("XBL_SchemaReplication"))
                {
                    Console.WriteLine(String.Format("{0}: Extended Property XBL_SchemaReplication missing.", m_strName));
                }

            }
            finally
            {
                if (p_SqlReader != null)
                    p_SqlReader.Close();
                if (this.Database.SqlDBConnection != null)
                    this.Database.SqlDBConnection.Close();
            }		

        }
*/		
		/// <summary>
		/// Loads the columns associated with the table
		/// </summary>
		public void LoadColumns ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "SELECT UPPER(COLUMN_NAME) " 
					+ "FROM INFORMATION_SCHEMA.COLUMNS "
					+ "WHERE TABLE_NAME = '" + m_strName + "' ORDER BY COLUMN_NAME";

				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				m_lstColumns = new InternalList();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0) )
                    {
                        Column p_objCol = new Column(this.Database, p_SqlReader.GetString(0));
                        p_objCol.TableName = this.Name;
                        m_lstColumns.Add(p_objCol);
                    }
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("Table.LoadColumns() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}				
		}

        /// <summary>
        /// Load the keys
        /// </summary>
        public void LoadKeys()
        {
            SqlDataReader p_SqlReader = null;
            try
            {
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "EXEC sp_pkeys @table_name='" + m_strName + "'";

                this.Database.SqlDBConnection.Open();
                p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
                
                //m_lstColumns = new InternalList();
                while (p_SqlReader.Read())
                {
                    if (!p_SqlReader.IsDBNull(0))
                    {
                        m_keys = (string)(m_keys + "," + p_SqlReader.GetString(3).Trim()).Trim(',');
                        /*
                        Column p_objCol = new Column(this.Database, p_SqlReader.GetString(0));
                        p_objCol.TableName = this.Name;
                        m_lstColumns.Add(p_objCol);
                         */
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Table.LoadKeys() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
            finally
            {
                if (p_SqlReader != null)
                    p_SqlReader.Close();
                if (this.Database.SqlDBConnection != null)
                    this.Database.SqlDBConnection.Close();
            }
        }

		/// <summary>
		/// Loads the constraints associated with the table
		/// </summary>
		public void LoadConstraints ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "SELECT oc.name, i.status, i.colid " 
					+ " FROM sysconstraints i INNER JOIN sysobjects oc ON i.constid = oc.id "
					+ "INNER JOIN sysobjects o ON i.id = o.id AND o.name = '" + m_strName 
					+ "' ORDER BY oc.name";

				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				m_lstConstraints = new InternalList();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0) )
                    {
                        Constraint p_objConst = new Constraint(this.Database, p_SqlReader.GetString(0));
                        if ( !p_SqlReader.IsDBNull(1) )
                        {
                            p_objConst.ConstraintType = Constraint.GetConstraintType(p_SqlReader.GetInt32(1));
                            p_objConst.Level = Constraint.GetConstraintLevel(p_SqlReader.GetInt32(1));
                        }
                        if ( !p_SqlReader.IsDBNull(2) )
                            p_objConst.ColumnId = p_SqlReader.GetInt16(2);
                        //p_objConst.Action = p_SqlReader.GetInt32(3);
                        m_lstConstraints.Add(p_objConst);
                    }
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("Table.LoadConstraints() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}				
		}


		/// <summary>
		/// Loads the indexes associated with the table
		/// </summary>
		public void LoadIndexes ()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "sp_helpindex '" + m_strName + "'";
				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				m_lstIndexes = new InternalList();
				while(p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0))
                    {
                        Index p_objIndex = new Index(this.Database, p_SqlReader.GetString(0));
                        if ( !p_SqlReader.IsDBNull(1) )
                            p_objIndex.IndexKeys = p_SqlReader.GetString(1);
                        p_objIndex.TableName = this.Name;
                        m_lstIndexes.Add(p_objIndex);
                        
                    }
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("Table.LoadIndexes() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}				
		}

		
		#endregion functions

	}
	

	/// <summary>
	/// This class represents the Column SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	public class Column : ISchemaObject
	{
		#region variables

		private SQLObjectType m_ObjType;
		private Database m_database;
		private string m_strName;
		private InternalList m_lstDifference;
		private string m_strSqlType;
		private int m_iLength;
		private bool m_bNullable;
		private string m_strTableName;
		private string m_strDefault;

		#endregion variables

		#region properties
        
         /// <summary>
        /// This has a handle to the database object to which the column belongs
        /// </summary>
        public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.Column
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the column object as defined in the database
		/// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }
		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// columns.
		/// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}

		/// <summary>
		/// This defines the SQL Data type of the column i.e. int, varchar etc.
		/// </summary>
		public string SqlType 
		{
			get 
			{
				return m_strSqlType;
			}
			set
			{
				m_strSqlType = value;
			}		
		}

		/// <summary>
		/// This defines the length of the column
		/// </summary>
		public int Length
		{
			get 
			{
				return m_iLength;
			}
			set
			{
				m_iLength = value;
			}		
		}

		/// <summary>
		/// This defines if the column is Nullable or not
		/// </summary>
		public bool Nullable 
		{
			get 
			{
				return m_bNullable;
			}
			set
			{
				m_bNullable = value;
			}		
		}
		
		/// <summary>
		/// This is the table name to which the column belongs
		/// </summary>
		public string TableName 
		{
			get 
			{
				return m_strTableName;
			}
			set
			{
				m_strTableName = value;
			}		
		}

		/// <summary>
		/// This defines the default value for the column
		/// </summary>
		public string Default 
		{
			get 
			{
				return m_strDefault;
			}
			set
			{
				m_strDefault = value;
			}		
		}

		#endregion properties

		#region constructor
        /// <summary>
        /// Default Constructor
        /// </summary>
        public Column ()
        {
            this.m_ObjType = SQLObjectType.Column;
            this.m_lstDifference = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public Column (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Column;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}

		#endregion constructor

		#region functions

		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Column object and have the same name and properties like datatype, length,
		/// null etc.
		/// </summary>
        /// <param name="p_objSchema">StoredProcedure object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals (ISchemaObject p_objSchema)
		{
			if (p_objSchema == null)
				return false;
			else
			{
				this.Load();
				p_objSchema.Load();
				Column p_objCol = (Column)p_objSchema;
				if ( this.Name == p_objCol.Name &&
					this.SqlType == p_objCol.SqlType &&
					this.Length == p_objCol.Length&&
					this.Nullable == p_objCol.Nullable &&
                    this.Default == p_objCol.Default)
					return true;
				else
					return false;
			}
		}


		/// <summary>
		/// This method compares two schema objects of type Columns 
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>
		
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
			
			int iCmpValue = (this.Name.ToLower()).CompareTo(p_schemaObj.Name.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}


		/// <summary>
		/// Loads the information for column properties Name, SQLDataType, Column Length, Default value and IsNullable.
		/// </summary>
		public void Load()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
                this.Database.GetConnection();
                this.Database.SqlDBCommand.CommandText = "SELECT UPPER(COLUMN_NAME), UPPER(COLUMN_DEFAULT), "
					+ "UPPER(IS_NULLABLE), DATA_TYPE, CHARACTER_MAXIMUM_LENGTH " 
					+ "FROM INFORMATION_SCHEMA.COLUMNS "
					+ "WHERE TABLE_NAME = '" + this.TableName + "' AND COLUMN_NAME = '" + this.Name + "'";

				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				if (p_SqlReader.Read())
				{
                    if (!p_SqlReader.IsDBNull(1))
                    {
                        this.Default = p_SqlReader.GetString(1).TrimStart('(').TrimEnd(')');
                    }
                    if ( !p_SqlReader.IsDBNull(2) )
                        this.Nullable = (p_SqlReader.GetString(2)=="NO"?false:true);
                    if ( !p_SqlReader.IsDBNull(3) )
                        this.SqlType = p_SqlReader.GetString(3);
                    if ( !p_SqlReader.IsDBNull(4) )
                        this.Length = p_SqlReader.GetInt32(4);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("Column.Load() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}					
		}

		#endregion functions

	}


	/// <summary>
    /// This enumeration defines the various types of Constraint Types available.
	/// </summary>
	public enum ConstraintType
    {
        /// <summary></summary>
        PrimaryKey,
        /// <summary></summary>
        UniqueKey, 
        /// <summary></summary>
        ForiegnKey, 
        /// <summary></summary>
        Check,
        /// <summary></summary>
        Default,
        /// <summary></summary>
        Undefined
    }

	
	/// <summary>
	/// This enumeration defines the if the constraint is Table Level or column Level.
	/// </summary>
	public enum ConstraintLevel
    {
        /// <summary></summary>
        Column, 
        /// <summary></summary>
        Table
    }

	
	/// <summary>
	/// This class represents the Constraint SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	public class Constraint : ISchemaObject
	{
		#region variables

		private SQLObjectType m_ObjType;
		private Database m_database;
		private string m_strName;
		private InternalList m_lstDifference;		
		private int m_iColId;
		//private int m_iAction;
		private ConstraintType m_enumConstType;
		private ConstraintLevel m_enumConstLevel;

		#endregion variables

		#region properties
		/// <summary>
		/// This has a handle to the database object to which the constraint belongs
		/// </summary>

		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.Constraint
		/// </summary>
		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the constraint object as defined in the database
		/// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }
		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// constraints.
		/// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}
		
		/// <summary>
		/// This holds the column id on which the constraint is defined
		/// </summary>
		public int ColumnId 
		{
			get 
			{
				return m_iColId;
			}
			set
			{
				m_iColId = value;
			}		
		}

		/*public int Action
		{
			get 
			{
				return m_iAction;
			}
			set
			{
				m_iAction = value;
			}		
		}*/
		
		/// <summary>
		/// This defines the ConstraintType i.e. PK, FK, Unique etc.
		/// </summary>
		public ConstraintType ConstraintType
		{
			get 
			{
				return m_enumConstType;
			}
			set
			{
				m_enumConstType = value;
			}		
		}

		/// <summary>
		/// This defines the constraint level i.e. table or column level
		/// </summary>
		public ConstraintLevel Level 
		{
			get 
			{
				return m_enumConstLevel;
			}
			set
			{
				m_enumConstLevel = value;
			}		
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		#endregion properties

		#region constructor

        /// <summary>
        /// 
        /// </summary>
        public Constraint ()
        {
            this.m_ObjType = SQLObjectType.Constraint;
            this.m_lstDifference = null;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public Constraint (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Constraint;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}

		#endregion constructor

		#region functions

		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Constraint object and have the same name and properties.
		/// </summary>
        /// <param name="p_objSchema">Constraint object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals (ISchemaObject p_objSchema)
		{
			if (p_objSchema == null)
				return false;
			else
			{
				Constraint p_objConst = (Constraint) p_objSchema; 
                // Problem with the last 8 chars in the constraint being random after the last __ ...
                string name1, name2;
                name1 = this.Name;
                name2 = p_objConst.Name;
                if (this.Name.LastIndexOf("__") > 0)
                    name1 = this.Name.Substring(0, this.Name.LastIndexOf("__"));
                if (p_objConst.Name.LastIndexOf("__") > 0)
                    name2 = p_objConst.Name.Substring(0, p_objConst.Name.LastIndexOf("__"));

				if ( name1 == name2 &&
					/*this.ColumnId == p_objConst.ColumnId &&*/
					/*this.Action == p_objConst.Action && */
					this.ConstraintType == p_objConst.ConstraintType && 
                    this.Level == p_objConst.Level)
					return true;
				else
					return false;
			}
		}


		/// <summary>
		/// This method compares two schema objects of type Constraint 
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>

		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;
            // Problem with the last 8 chars in the constraint being random after the last __ ...
            string name1, name2;
            name1 = this.Name;
            name2 = p_schemaObj.Name;
            if (this.Name.LastIndexOf("__") > 0)
                name1 = this.Name.Substring(0, this.Name.LastIndexOf("__"));
            if (p_schemaObj.Name.LastIndexOf("__") > 0)
                name2 = p_schemaObj.Name.Substring(0, p_schemaObj.Name.LastIndexOf("__"));

			int iCmpValue = (name1.ToLower()).CompareTo(name2.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}


		/// <summary>
		/// Loads the help text data for the constraint object
		/// </summary>
        public void Load(){}	
		
		/// <summary>
		/// This method retrieves the constrainttype enumeration value
		/// </summary>
		/// <param name="iStatus">This is the constraint type value as 
		/// represented in SQL</param>
		/// <returns>ConstraintType enumeration value</returns>
		internal static ConstraintType GetConstraintType (int iStatus)
		{
			ConstraintType p_enumTemp = ConstraintType.Undefined;
			if ( (iStatus&1) == 1 )
				p_enumTemp = ConstraintType.PrimaryKey;
			else if ( (iStatus&2) == 2 )
				p_enumTemp = ConstraintType.UniqueKey;
			else if ( (iStatus&3) == 3 )
				p_enumTemp = ConstraintType.ForiegnKey;			
			else if ( (iStatus&4) == 4 )
				p_enumTemp = ConstraintType.Check;			
			else if ( (iStatus&5) == 5 )
				p_enumTemp = ConstraintType.Default;			
			return p_enumTemp;
		}


		/// <summary>
		/// This method retrieves the constraintlevel enumeration value
		/// </summary>
		/// <param name="iStatus">This is the constraint level value as 
		/// represented in SQL</param>
		/// <returns>ConstraintLevel enumeration value</returns>
		internal static ConstraintLevel GetConstraintLevel (int iStatus)
		{
			ConstraintLevel p_enumTemp = ConstraintLevel.Column;
			if ( (iStatus&32) == 32 )
				p_enumTemp = ConstraintLevel.Table;

			return p_enumTemp;
		}
		

		#endregion functions

	}


	/// <summary>
	/// This class represents the Index SQL Object and implements 
	/// ISchemaObject interface.
	/// </summary>
	public class Index : ISchemaObject
	{	
		#region variables

		private SQLObjectType m_ObjType;
		private Database m_database;
		private string m_strTableName;
		private string m_strName;
		private InternalList m_lstDifference;		
		private int m_iUnique;
		private int m_iIdxDepth;
		private int m_iIdxClustered;
		private int m_iIdxFillFactor;
		private int m_iIdxId;
		private int m_iIdxFullTextKey;
		private string m_strIndexKeys;

		#endregion variables

		#region properties

		// Public Properties
		/// <summary>
		/// This has a handle to the database object to which the index belongs
		/// </summary>
		public Database Database 
		{
			get 
			{
				return m_database;
			}
            set  
            {
                m_database = value;
            }

        }

		/// <summary>
		/// This is of enumeration type SQLObjectType.Index
		/// </summary>

		public SQLObjectType Type 
		{
			get 
			{
				return m_ObjType;
			}
		}

		/// <summary>
		/// This holds the name of the index object as defined in the database
		/// </summary>
		public string Name 
		{
			get 
			{
				return m_strName;
			}
            set  
            {
                m_strName = value;
            }

        }

		/// <summary>
		/// This holds the list of difference objects for the ISchemaObject. This is null in the case of 
		/// indexes.
		/// </summary>
		public InternalList DifferenceList
		{
			get 
			{
				return m_lstDifference;
			}
		}

		/// <summary>
		/// This holds the index id as in the database.
		/// </summary>
		public int IndexId
		{
			get 
			{
				return m_iIdxId;
			}
			set
			{
				m_iIdxId = value;
			}		
		}

		/// <summary>
		/// Defines if the index is Unique or not
		/// </summary>
		public int IsUnique
		{
			get 
			{
				return m_iUnique;
			}
			set
			{
				m_iUnique = value;
			}		
		}

		/// <summary>
		/// Defines the Index depth as in the database
		/// </summary>
		public int IndexDepth
		{
			get 
			{
				return m_iIdxDepth;
			}
			set
			{
				m_iIdxDepth = value;
			}		
		}

		/// <summary>
		/// Defines if the index is clustered or non-clustered
		/// </summary>
		public int IsClustered
		{
			get 
			{
				return m_iIdxClustered;
			}
			set
			{
				m_iIdxClustered = value;
			}		
		}

		/// <summary>
		/// Defines the Fill Factor of the index
		/// </summary>
		public int IndexFillFactor
		{
			get 
			{
				return m_iIdxFillFactor;
			}
			set
			{
				m_iIdxFillFactor = value;
			}		
		}

		/// <summary>
		/// Defines if the index is a FullText key
		/// </summary>
		public int IsFullTextKey
		{
			get 
			{
				return m_iIdxFullTextKey;
			}
			set
			{
				m_iIdxFullTextKey = value;
			}		
		}

		/// <summary>
		/// Holds the table to which the index belongs
		/// </summary>
		public string TableName
		{
			get 
			{
				return m_strTableName;
			}
			set
			{
				m_strTableName = value;
			}		
		}

		/// <summary>
		/// Holds the list of columns on which the index is defined
		/// </summary>
		public string IndexKeys
		{
			get 
			{
				return m_strIndexKeys;
			}
			set
			{
				m_strIndexKeys = value;
			}		
		}

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateSchema extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateSchema
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Replicate the schema.  This will only be false if XBL_ReplicateData extended property 
        /// is set to 0.
        /// </summary>
        public bool ReplicateData
        {
            get
            {
                return false;
            }
        }

		#endregion properties

		#region constructor
        /// <summary>
        /// 
        /// </summary>
        public Index ()
        {
            this.m_ObjType = SQLObjectType.Index;
            this.m_lstDifference = null;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="p_db"></param>
        /// <param name="p_strName"></param>
		public Index (Database p_db, string p_strName)
		{
			this.m_database = p_db;
			this.m_ObjType = SQLObjectType.Index;
			this.m_strName = p_strName;
			this.m_lstDifference = null;
		}

		#endregion constructor

		#region functions

		/// <summary>
		/// This method verifies if the two ISchemaObject objects are instances of the
		/// Index object and have the same name and properties.
		/// </summary>
        /// <param name="p_objSchema">Index object with which the current object is being compared</param>
		/// <returns>True/False for equality</returns>
		public bool Equals(ISchemaObject p_objSchema)
		{
			if (p_objSchema == null)
				return false;
			else
			{
                Index p_objIndex = (Index)p_objSchema;

                // Problem with the last 8 chars in the constraint being random after the last __ ...
                string name1, name2;
                name1 = this.Name;
                name2 = p_objIndex.Name;
                if (this.Name.LastIndexOf("__") > 0)
                    name1 = this.Name.Substring(0, this.Name.LastIndexOf("__"));
                if (p_objIndex.Name.LastIndexOf("__") > 0)
                    name2 = p_objIndex.Name.Substring(0, p_objIndex.Name.LastIndexOf("__"));

				if ( name1 == name2 &&
					this.IndexKeys == p_objIndex.IndexKeys &&
					this.IndexId == p_objIndex.IndexId && 
					this.IsFullTextKey == p_objIndex.IsFullTextKey && 
					this.IsUnique == p_objIndex.IsUnique &&
					this.IsClustered == p_objIndex.IsClustered &&
					this.IndexFillFactor == p_objIndex.IndexFillFactor &&
					this.IndexDepth == p_objIndex.IndexDepth)
					return true;
				else
					return false;
			}
		}


		/// <summary>
		/// This method compares two schema objects of type Indexes 
		/// for equality bases on the names. 
		/// </summary>
		/// <param name="p_schemaObj">The schema object with which the current object is being compared</param>
		/// <returns>Returns 0 if they are equal and -ve if the passed in object is greater or +ve if it is lesser</returns>
	
		public int Compare (ISchemaObject p_schemaObj)
		{
			if (p_schemaObj == null)
				return 1;

            // Problem with the last 8 chars in the constraint being random after the last __ ...
            string name1, name2;
            name1 = this.Name;
            name2 = p_schemaObj.Name;
            if (this.Name.LastIndexOf("__") > 0)
                name1 = this.Name.Substring(0, this.Name.LastIndexOf("__"));
            if (p_schemaObj.Name.LastIndexOf("__") > 0)
                name2 = p_schemaObj.Name.Substring(0, p_schemaObj.Name.LastIndexOf("__"));

			int iCmpValue = (name1.ToLower()).CompareTo(name2.ToLower());
			
			if ( iCmpValue < 0 )
			{
				return -1;
			}
			else if ( iCmpValue > 0 )
			{
				return 1;
			}
			else
				return 0;
		}


		/// <summary>
		/// Loads the Index object
		/// </summary>
		public void Load()
		{
			SqlDataReader p_SqlReader = null;
			try
			{
				this.Database.SqlDBCommand.CommandText = "SELECT " + 
					"INDEXPROPERTY(OBJECT_ID('" + this.TableName + "'), '" + this.Name + "', 'IsUnique') IsUnique," +
					"INDEXPROPERTY(OBJECT_ID('" + this.TableName + "'), '" + this.Name + "', 'IndexDepth') IdxDepth," +
					"INDEXPROPERTY(OBJECT_ID('" + this.TableName + "'), '" + this.Name + "', 'IsClustered') IsClustered," +
					"INDEXPROPERTY(OBJECT_ID('" + this.TableName + "'), '" + this.Name + "', 'IndexFillFactor') IdxFillFactor," +
					"INDEXPROPERTY(OBJECT_ID('" + this.TableName + "'), '" + this.Name + "', 'IndexID') IdxId," +
					"INDEXPROPERTY(OBJECT_ID('" + this.TableName + "'), '" + this.Name + "', 'IsFulltextKey') IsFullTextKey";
				this.Database.SqlDBConnection.Open();
				p_SqlReader = this.Database.SqlDBCommand.ExecuteReader();
				if (p_SqlReader.Read())
				{
                    if ( !p_SqlReader.IsDBNull(0) )
                        this.IsUnique = p_SqlReader.GetInt32(0);
                    if ( !p_SqlReader.IsDBNull(1) )
                        this.IndexDepth = p_SqlReader.GetInt32(1);
                    if ( !p_SqlReader.IsDBNull(2) )
                        this.IsClustered = p_SqlReader.GetInt32(2);
                    if ( !p_SqlReader.IsDBNull(3) )
                        this.IndexFillFactor = p_SqlReader.GetInt32(3);
                    if ( !p_SqlReader.IsDBNull(4) )
                        this.IndexId = p_SqlReader.GetInt32(4);
                    if ( !p_SqlReader.IsDBNull(5) )
                        this.IsFullTextKey = p_SqlReader.GetInt32(5);
				}
			}
            catch (Exception e)
            {
                Console.WriteLine("Index.Load() exception: ");
                Console.WriteLine("Source:" + e.Source);
                Console.WriteLine("Message:" + e.Message);
                Console.WriteLine("StackTrace:" + e.StackTrace);
            }
			finally
			{
				if (p_SqlReader != null) 
					p_SqlReader.Close();
				if ( this.Database.SqlDBConnection != null ) 
					this.Database.SqlDBConnection.Close();
			}			
		}

		#endregion functions
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\Class1.cs ===
using System;
using System.Text;
using System.IO;
using System.Threading;

namespace SPSmon
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		/// 
		[STAThread]
		static void Main(string[] args)
		{
			Console.WriteLine("SPSmonitor v1");
			
			ThreadStart myThreadStart = new ThreadStart(Handler);
			Thread myWorkerThread = new Thread(myThreadStart);
			myWorkerThread.Start();
			while (myWorkerThread.IsAlive);

			while (true)
			{
				if (DateTime.Now.Hour<4 || DateTime.Now.Hour>8)
				{
					myThreadStart = new ThreadStart(Handler);
					myWorkerThread = new Thread(myThreadStart);
					myWorkerThread.Start();
				}
				else
					Console.WriteLine(DateTime.Now+" backing off");
				Thread.Sleep(60000);
			}
		}
		static int oldAccountsQueued=0;
		static int oldTotalAccounts=0;

		static void Handler()
		{
			SPSMonitor SP=new SPSMonitor();
			SP.GetState();
			Console.WriteLine(DateTime.Now+" User count "+SP.UserCount+"    Queue size "+SP.BillingQueueSize);
			WriteData("s:\\queued.html","Billing queue",SP.Queued);
			WriteData("s:\\users.html","User list",SP.All);
			WriteStatus("s:\\status.html",SP);
		}
		static void WriteStatus(string FileName, SPSMonitor SP)
		{
			int Status=0; // 0 =undefined 1 = down 2 =up
			TextWriter	TW=File.CreateText(FileName);
			
			TW.WriteLine("<html><body>");
			TW.WriteLine("<font face='Arial'>");
			if (SP.Queued.Length==0 && SP.All.Length!=0)
				Status=2;

			if (SP.Queued.Length!=0 && SP.All.Length!=0)
			{
				TimeSpan dif=SP.Queued[0].Timestamp-SP.All[0].Timestamp;
				if (Math.Abs(dif.TotalSeconds)<15)
					Status=1;
				else 
					Status=2;
				// It's entirely possible that the guy at the top of the billing queue hasn't been entered into the user
				// list yet. Obviously, that means that SPS is down.
				for (int i=0; i<SP.Queued.Length; i++)
				{
					if (SP.Queued[i].Name.CompareTo(SP.All[0].Name)==0)
					{
						Status=1;	
						break;
					}
				}
			}
			TW.WriteLine("<p align='center'><h1>");
			switch(Status)
			{
				case 0:
					TW.WriteLine("Can't determine SPS state");
					break;
				case 1:
					TW.WriteLine("<font color='#800000'>SPS is probably DOWN");
					break;
				case 2:
					TW.WriteLine("<font color='#008000'>SPS is probably UP");
					break;
			}
			TW.WriteLine("</font></h2></p>");
			TW.WriteLine("<p>There are "+SP.UserCount+" total users, "+SP.BillingQueueSize+" are queued.</p>");
			int UserDif=SP.UserCount-oldTotalAccounts;
			int QueueDif=SP.BillingQueueSize-oldAccountsQueued;
			TW.WriteLine("<p>The user count has increased by "+UserDif+" in the last minute, while the billing queue has increased by "+QueueDif+".</p>");
			oldTotalAccounts=SP.UserCount;
			oldAccountsQueued=SP.BillingQueueSize;
			TW.WriteLine("<p>This page last updated at "+DateTime.Now+". It will update again in one minute. Hitting F5 will not force an update ;)</p>");
			TW.WriteLine("</font>");
			TW.WriteLine("</html></body>");
			TW.Flush();
			TW.Close();
		}


		static void	WriteData(string FileName,string Title,UserEntry []Data)
		{
			TextWriter	TW=File.CreateText(FileName);
			
			TW.WriteLine("<html><body>\n");
			TW.WriteLine("<font face='Arial'>");
			TW.WriteLine("<h2>"+Title+"</h2>\n");
			TW.WriteLine("<table border=\"1\">\n");
			TW.WriteLine("<tr><td>Time stamp</td><td>User name</td></tr>\n");
			foreach (UserEntry User in Data)
			{
				string s="<tr><td>"+User.Timestamp+"</td><td>"+User.Name+"</td></tr>\n";
				TW.WriteLine(s);
			}
			TW.WriteLine("</table>\n");
			TW.WriteLine("</font>");
			TW.WriteLine("</html></body>");
			TW.Flush();
			TW.Close();
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_spsmon_none_12.4.56.0_none_f87eeffc9af9f4af
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=spsmon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.manifest
XP_MANIFEST_PATH=manifests\msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.cat
XP_CATALOG_PATH=manifests\msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.cat
XP_PAYLOAD_PATH=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=spsmon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\UserEntry.cs ===
using System;

namespace SPSmon
{
	/// <summary>
	/// Summary description for UserEntry.
	/// </summary>
	public class UserEntry
	{
		public string	Name;
		public ulong	Puid;
		public MiniUODB	Server=null;
		public DateTime	Timestamp;
		public UserEntry()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		public string GetInfo()
		{
			return Name.PadRight(16)+" | "+Puid+" | "+Timestamp.ToString().PadRight(25)+" | "+Server._ServerName;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\MiniUODB.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;

namespace SPSmon
{
	/// <summary>
	/// Summary description for MiniUODB.
	/// </summary>
	public class MiniUODB
	{
		public const int MaxAccounts=10;
		public int	TopAccount=0;
		public int	CurAccounts=0;
		public int	BillingQueueSize=0;
		public int	UserCount=0;
		public UserEntry []Users=new UserEntry[MaxAccounts];
		public string _ServerName;
		SqlConnection	m_SqlConnection=null;
		public bool	PersistentConnection=false;

		SqlConnection	GetConnection()
		{
			if (m_SqlConnection==null)
			{
				m_SqlConnection = new SqlConnection("server="+_ServerName+";database=uodb;user id=sa;password=Suck!h3ad"); 		
				m_SqlConnection.Open();
			}
			return m_SqlConnection;
		}

		void	CloseConnection()
		{
			if (!PersistentConnection)
			{
				m_SqlConnection.Close();
				m_SqlConnection=null;
			}
		}
		public MiniUODB(string Server)
		{
			_ServerName=Server;
		}

		public bool FindUserInUserNames(UserEntry ue)
		{
			bool found=false;
			GetConnection();

			SqlDataReader myDataReader = null;
			string QueryString=
				"select bi_user_puid from t_user_names where vc_nickname = '"+ue.Name+"' and bi_user_puid = "+ue.Puid;

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				while(myDataReader.Read())
				{
					// Always call Read before accessing data.
					if (Convert.ToUInt64(myDataReader.GetInt64(0))==ue.Puid)
						found=true;
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CloseConnection();
			return found;
		}

		// Returns all data in t_users
		public void GetUsers(ArrayList Users)
		{
			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select vc_nickname, bi_user_puid, dt_change_datetime from t_users";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				while(myDataReader.Read())
				{
					UserEntry ue=new UserEntry();
					// Always call Read before accessing data.
					ue.Name=myDataReader.GetString(0);
					ue.Puid=(ulong)myDataReader.GetInt64(1);
					ue.Timestamp=myDataReader.GetDateTime(2).ToLocalTime();
					ue.Server=this;
					Users.Add(ue);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CloseConnection();
		}

		public int GetQueuedAccounts()
		{
			int i=0;

			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select top "+MaxAccounts+" qu.dt_change_datetime,us.vc_nickname from t_users as us inner join t_user_billing_queue as qu "+
				"on us.bi_user_puid=qu.bi_user_puid where us.vc_nickname not like 'RM%' "+
				"order by qu.dt_change_datetime desc";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				for(i=0; i<MaxAccounts && myDataReader.Read(); i++)
				{
					// Always call Read before accessing data.
					Users[i]=new UserEntry();
					Users[i].Timestamp=myDataReader.GetDateTime(0).ToLocalTime();
					Users[i].Name=myDataReader.GetString(1);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CurAccounts=i;
			
			CloseConnection();
			return i;
		}

		public void UpdateCounts()
		{
			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select count(*) from t_user_billing_queue";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				if (myDataReader.Read())
				{
					// Always call Read before accessing data.				
					BillingQueueSize=myDataReader.GetInt32(0);
				}
				myDataReader.Close();

				QueryString="select count(*) from t_users";
				mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);
				myDataReader = mySqlCommand.ExecuteReader();

				if (myDataReader.Read())
				{
					// Always call Read before accessing data.				
					UserCount=myDataReader.GetInt32(0);
				}

			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CloseConnection();
		}
		public int GetAllAcounts()
		{
			int i=0;

			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select top "+MaxAccounts+" dt_change_datetime,vc_nickname from t_users where vc_nickname not like 'RM%' order by dt_change_datetime desc";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				for(i=0; i<MaxAccounts && myDataReader.Read(); i++)
				{
					// Always call Read before accessing data.
					Users[i]=new UserEntry();
					Users[i].Timestamp=myDataReader.GetDateTime(0).ToLocalTime();
					Users[i].Name=myDataReader.GetString(1);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CurAccounts=i;
			
			CloseConnection();
			return i;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\UserTableIntegrity.cs ===
using System;
using System.Collections;

namespace SPSmon
{
	/// <summary>
	/// Summary description for UserTableIntegrity.
	/// </summary>
	public class UserTableIntegrity
	{
		public MiniUODB []UODB;
		public UserTableIntegrity()
		{
			UODB=new MiniUODB[3];
			UODB[0]=new MiniUODB("XONTEUODBSQL002");
			UODB[1]=new MiniUODB("XONTEUODBSQL003");
			UODB[2]=new MiniUODB("XONTEUODBSQL004");
		}

		public void Go()
		{
			int counter=0, total=0;
			ArrayList Users=new ArrayList();

			foreach (MiniUODB db in UODB)
			{
				db.PersistentConnection=false;
				db.GetUsers(Users);
			}
			total=Users.Count;
			Console.WriteLine("Got "+total+" users");
			foreach (UserEntry ue in Users)
			{
				bool found=false;
				Console.Write("Testing "+ue.Name+" ("+counter+" / "+total+")\r");
				counter++;
				foreach (MiniUODB db in UODB)
				{
					found=db.FindUserInUserNames(ue);
					if (found)
						break;
				}
				if (!found)
					Console.WriteLine("Mismatch | "+ue.GetInfo());
			}

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SQLPlayback\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\SPSMonitor.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;

namespace SPSmon
{
	/// <summary>
	/// Summary description for SPSMonitor.
	/// </summary>
	public class SPSMonitor
	{
		const int MaxAccounts=16;
		public UserEntry []Queued=new UserEntry[0];
		public UserEntry []All=new UserEntry[0];
		public MiniUODB []UODB;
		public int BillingQueueSize=0;
		public int UserCount=0;

		public SPSMonitor()
		{
			UODB=new MiniUODB[3];
			UODB[0]=new MiniUODB("XONTEUODBSQL002");
			UODB[1]=new MiniUODB("XONTEUODBSQL003");
			UODB[2]=new MiniUODB("XONTEUODBSQL004");
		}

		int ProcessData(ref UserEntry []Users)
		{
			int CollectedData=0;
			int CurAccounts=0;
			foreach (MiniUODB U in UODB)
			{
				CollectedData+=U.CurAccounts;
				U.TopAccount=0;
			}
			Users=new UserEntry[CollectedData > MaxAccounts ? MaxAccounts : CollectedData];
			while (CurAccounts<MaxAccounts)
			{
				MiniUODB best=null;
				foreach (MiniUODB U in UODB)
				{
					// check if there are accounts to look at
					if (U.TopAccount<U.CurAccounts)
					{
						if (best==null)
							best=U;
						else
						{
							if (U.Users[U.TopAccount].Timestamp>best.Users[best.TopAccount].Timestamp)
							{
								best=U;
							}
						}
					}
				}
				if (best==null)
				{
					// exhausted all
					break;
				}

				Users[CurAccounts]=best.Users[best.TopAccount];
				//Console.WriteLine(Users[CurAccounts].Name+"  "+Users[CurAccounts].Timestamp+"  "+best._ServerName);
				CurAccounts++;
				best.TopAccount++;
			}
			return CurAccounts;
		}
		public void GetState()
		{
			BillingQueueSize=0;
			UserCount=0;
			foreach (MiniUODB U in UODB)
			{
				U.GetQueuedAccounts();
				U.UpdateCounts();
				BillingQueueSize+=U.BillingQueueSize;
				UserCount+=U.UserCount;
			}
			ProcessData(ref Queued);
			foreach (MiniUODB U in UODB)
			{
				U.GetAllAcounts();
			}
			ProcessData(ref All);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SPSmon\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_spsmon_none_12.4.56.0_none_f87eeffc9af9f4af
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=spsmon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.manifest
XP_MANIFEST_PATH=manifests\msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.cat
XP_CATALOG_PATH=manifests\msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79.cat
XP_PAYLOAD_PATH=msil_spsmon_no-public-key_12.4.56.0_x-ww_5eea1e79
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=spsmon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SQLPlayback\SPBExecuter.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Diagnostics;
using System.Collections.Generic;

namespace SQLPlayback
{
	/// <summary>
	/// Class to play back data from a SQL Profiler trace
	/// using a proprietary file format (SPB) as input
	/// The files contain data taked from SQL Profiler trace
    /// 
    /// NOTE:  Logging is disabled right now, it is not thread safe and is a todo item to change
    /// it to be a thread safe logging.  Console logging is only used for timeout errors at this time
	/// </summary>
	public class SPBExecuter
	{
		/// <summary>
		/// The main entry point for the application.
		/// 
		/// DEBUG COMMAND LINE: "EXEC jeffg1 2 . "12/1/2004 9:30AM""
		/// </summary>
		[STAThread]
		static void debugMain(string[] args)
		{
			try
			{
				SPBExecuter executer = new SPBExecuter();
				executer.Initialize(args);
				executer.ProcessData();
				executer.Terminate();
			}
			catch(Exception e)
			{
				Console.WriteLine("ERROR: {0}", e.ToString());
				Console.WriteLine("");
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SPBExecuter()
		{
		}

		public void DisplayUsage()
		{
			Console.WriteLine("\nOPTION: EXEC - Actually executes the playback\n");
			Console.WriteLine("  {0} EXEC <sql server> <threads>",
				AppDomain.CurrentDomain.FriendlyName);
			Console.WriteLine("    <spb file path>  [compression ratio] [start time]\n");
			Console.WriteLine("  EXAMPLE:");
			Console.WriteLine("    {0} EXEC TestServer 10 c:\\playbackfiles\n",
				AppDomain.CurrentDomain.FriendlyName);
			Console.WriteLine("  PARAMS:");
			Console.WriteLine("    <sql server>        = Name of SQL Server to run against");
			Console.WriteLine("    <threads>           = Number of threads to execute");
			Console.WriteLine("    <spb files path>    = Location of SPB file(s) for input");
			Console.WriteLine("    [start Time]        = [OPTIONAL] Time to start, default = NOW\n");
			Console.WriteLine("    [compression ratio] = [OPTIONAL] Time compression ration, default = 1\n");
			Console.WriteLine("                            0 will execute as fast as possible");
			Console.WriteLine("                            .5 will execute at 2x recorded speed");
			Console.WriteLine("                            1 will execute at recorded speed");
			Console.WriteLine("                            2 will execute at 1/2x recorded speed");
			Console.WriteLine("  NOTES:");
			Console.WriteLine("    This option will actually execute the playback on one client.");
			Console.WriteLine("    Each thread expects it's own input file and executes all");
			Console.WriteLine("    queries/SPs synchronously. It expects file names of the form");
			Console.WriteLine("    \\<client name>_Thread##.SPB where ## is the thread number.\n");
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="args"></param>
		public void Initialize(string[] args)
		{
			if (!IsValidInput(args))
			{
				DisplayUsage();
				throw new Exception("Invalid input");
			}

			m_strSQLServer = args[1];
			m_nThreads = Int32.Parse(args[2]);
			m_strInputFilePath = args[3];

			// Figure out the start time
			if (args.Length > 4)
			{
                if (args[4].ToString() == "NOW")
                {
                    m_dtStart = DateTime.Now;
                    m_dtStart = m_dtStart.AddSeconds(10);
                }
                else
                    m_dtStart = DateTime.Parse(args[4]);

                TimeSpan tsWait = m_dtStart - DateTime.Now;
                
				if (tsWait.TotalMilliseconds > 0)
				{
					// Don't let this thing spin doing nothing for too long
					// 7 days is MORE than enough
					if (tsWait.TotalDays > 7)
						throw new Exception("Start time is more than 7 days in the future");

					// Wait until just about the start time
					int nWait = (int)tsWait.TotalMilliseconds;
					if (nWait > 500)
					{
						PrintStatus("Start Time = {0}, waiting for {1} seconds",
							m_dtStart, nWait/1000);
						Thread.Sleep(nWait - 500);
					}
				}
				else
				{
					// User specified a StartTime BEFORE Now
					throw new Exception("Invalid StartTime");
				}
			}
			else
			{
				// If not specified, start right away
				m_dtStart = DateTime.Now;
			}

			// Set the compression ratio
			if (args.Length == 6)
				m_dCompressionRatio = double.Parse(args[5]);
			else
				m_dCompressionRatio = 1;

			// Initialize the error log
			if (m_writerErrorLog == null)
			{
                //KKLINE - need to fix this to be threadsafe
				m_writerErrorLog = new StreamWriter("SQLPlaybackErrors.log", true);
			}
		}

		/// <summary>
		/// Function to do all the work
		/// </summary>
		public void ProcessData()
		{
			// Print out start status
			PrintStatus("Starting {0} threads", m_nThreads);

			// Create and start all the threads
			Thread[] rgThreads = new Thread[m_nThreads];
			for (int i = 0; i < m_nThreads; i++)
			{
				rgThreads[i] = new Thread(new ThreadStart(RunThread));
				rgThreads[i].Name = i.ToString("000");
				rgThreads[i].Start();
			}

			// Print out start status
			PrintStatus("All threads started");

			// Now just wait until we are done (but mostly sleep)
            for (int i = 0; i < m_nThreads; i++)
                rgThreads[i].Join();
            
			// Print out completed status
			PrintStatus("All threads completed");;
		}

		/// <summary>
		/// 
		/// </summary>
		public void Terminate()
		{
			if (m_writerErrorLog != null)
			{
				m_writerErrorLog.Close();
			}
		}

		// *****
		// ** Class internals
		// *****

		// Member variables
		protected string m_strSQLServer;
		protected string m_strMachineName;
		protected string m_strInputFilePath;
		protected int m_nThreads;
		protected DateTime m_dtStart;
		protected double m_dCompressionRatio;
        //KKLINE - added Connection Timeout=10 to try to help simulate live site connection issues
		protected static string m_strConnectionFormat = "Data Source={0};Initial Catalog={1};Integrated Security=SSPI;Connection Timeout=10";
		protected static string m_strFileNameFormat = "\\{0}_Thread{1}.SPB";
		protected TextWriter m_writerErrorLog = null;

		// Helpers

		/// <summary>
		/// Check if command line is valid
		/// </summary>
		/// <param name="args"></param>
		/// <returns></returns>
		protected bool IsValidInput(string[] args)
		{
			if (args.Length < 4 || args.Length > 6)
				return false;

			if (args[0].ToUpper() != "EXEC")
				return false;

			return true;
		}

		/// <summary>
		/// Helper to execute threads
		/// </summary>
		private void RunThread()
		{
			StringBuilder inputfile = new StringBuilder();
			string strLine;
			string[] rgItems;
			SqlConnection con = new SqlConnection();
			int nCurrentLine = 0;

            int nErrors = 0;  //KKLINE
            int nTimeoutErrors = 0;  //KKLINE

			try
			{
				// Open the input file
				inputfile.Append(m_strInputFilePath);
				inputfile.AppendFormat(m_strFileNameFormat,
					Environment.MachineName, Thread.CurrentThread.Name);
				TextReader rdr = new StreamReader(inputfile.ToString());

                List<String> columns = new List<string>();
                // Read the header
                strLine = rdr.ReadLine();
                while (strLine != null && strLine[0] == '#')
                {
                    if (strLine.StartsWith("#Fields"))
                    {
                        String[] colHeaders = strLine.Split('\t');
                        for (int i = 1; i < colHeaders.Length; i++)
                        {
                            columns.Add(colHeaders[i]);
                        }
                    }
                    if (rdr.Peek() == '#')
                        strLine = rdr.ReadLine();
                    else
                        strLine = null;
                }
                if (columns.Count == 0)
                    throw new Exception("File header format not recognized");
                
                int timeCol = columns.IndexOf("Time");
                int databaseCol = columns.IndexOf("Database");
                int queryCol = columns.IndexOf("Query");
                int rowNumCol = columns.IndexOf("RowNumber");
                if (timeCol == -1 || databaseCol == -1 || queryCol == -1 || rowNumCol == -1)
                    throw new Exception("Missing required column");
				// Read the data in the input file
				strLine = rdr.ReadLine();
				while (strLine != null)
				{
					try
					{
						// Split the line into fields
						rgItems = strLine.Split('\t');
                        if (rgItems.Length != columns.Count)
                            throw new Exception("Line has wrong number of columns");

						// Delay until the right start time using the start offset
						WaitThread(Int32.Parse(rgItems[timeCol]));

						// Calculate stats, printing status occassionally
                        // UNDONE: Stats printing every nth line should be configurable
						nCurrentLine++;
						if (nCurrentLine % 10000 == 0)
						{
							DateTime dtQuery = m_dtStart.AddMilliseconds(Int32.Parse(rgItems[timeCol]));
							PrintStatus("{0} lines processed, expected query start time = {1}",
								nCurrentLine.ToString("#,##0"), dtQuery);
						}

						try
						{
							// Fire off the puppy
							ExecuteSql(con, rgItems[databaseCol], rgItems[queryCol]);
						}
						catch (Exception e)
						{
                            //KKLINE
                            if (e.Message.Contains("Timeout"))
                            {
                                PrintStatus("Timeout Error");
                                nTimeoutErrors++;  //KKLINE
                            }
                            
							// Print the status but we gotta keep going
                            LogError("Thread Exception: DeltaTime = {0}, \n\tRow Number = {1}, \n\tQuery = {2}, \n\tException: {3}\n",
                                rgItems[timeCol], rgItems[rowNumCol], rgItems[queryCol], e.ToString());
                            nErrors++;  //KKLINE
                        }
					}
					catch (Exception e)
					{
						// Print the status but we gotta keep going
						PrintStatus("Exception: {0}\n", e.ToString());
					}
					finally
					{
						// Read the next line
						strLine = rdr.ReadLine();
					}
				}
			}
			catch (Exception e)
			{
				PrintStatus("Thread Exception On Startup: {0}\n", e.ToString());
			}

			// Print out complete status
			PrintStatus("Thread is complete");

            //KKLINE
            PrintStatus("Rows Processed: {0}\n Error Rows: {1}\nTimeout Errors: {2}\n", nCurrentLine, nErrors,nTimeoutErrors);

		}

		protected void ExecuteSql(SqlConnection con, string strDatabase,
			string strQuery)
		{
			SqlDataReader dr = null;

			try
			{
				// If this request is using a different db, then change it
                //
                // BUG/UNDONE: It could theoretically get very expensive
                // to keep closing and reopening databases. It would be much
                // better to keep a cache of database connections. We can
                // make the number of cached connections configurable.
                // It should not be huge, it would not be advisable to run
                // a trace against one server with a lot of databases. Better
                // to do multiple traces.

                if (con.Database != strDatabase)
                {
                    // Be a good citizen and close the old db connection
                    if (con.State == ConnectionState.Open)
                    {
                        con.Close();
                    }

                    con.ConnectionString = string.Format(m_strConnectionFormat,
                        m_strSQLServer, strDatabase);
                }

                // KKLINE - Added to produce login/logouts.

                if (con.State == ConnectionState.Open)
                {
                    con.Close();
                    con.ConnectionString = string.Format(m_strConnectionFormat, m_strSQLServer, strDatabase);
                }

				// Open the db if necessary
                if (con.State != ConnectionState.Open)
                {
                    try
                    {
                        con.Open();
                    }
                    catch (Exception e)
                    {
                        PrintStatus("Connection Failure: {0}", e.Message);
                    }

                }

                // KKLINE - End New Code

				// Set up the command
                // UNDONE: We need to cache the command object and not always create a new one
                // UNDONE: Is using a SQL CommandType of Text what we always want to do?
                // This could be based on the SQL Trace event instead to more closely match
                // the actual calling convention.
				SqlCommand cmd = new SqlCommand(strQuery, con);
				cmd.CommandType = CommandType.Text;
				cmd.CommandTimeout = 30;

                // UNDONE: Need to handle exceptions better here. Yes I know they are handled by the caller.
                // What should happen if there is an error executing the sql? Is it better to handle it here?

                // UNDONE: Should we rely on the preprocessing to determine (make guesses) if sql
                // will return data or should we have that here? Making a guess could be configurable.
				// BUG: Removing this if until we can make the guess
                //if (!bReturnsData)
				//{
					// Ignore the RowAffected return value,
					// we don't know what to do with it anyway
					cmd.ExecuteNonQuery();
				//}
				//else
				//{
				//	bool bMoreResults = true;
                //
				//	// Execute the command and get the data back
				//	// Don't need any special command behavior, specify default anyway
				//	dr = cmd.ExecuteReader(CommandBehavior.Default);
                //
				//	while (dr != null && bMoreResults)
				//	{
				//		// Walk through all the records
				//		do
				//		{
				//			// Don't actually do anything with the data
				//		}
				//		while (dr.Read());
                //
				//		// Get the next result set (if any)
				//		bMoreResults = dr.NextResult();
				//	}
				//}
			}
			finally
			{
				// Clean up the reader
				if (dr != null && !dr.IsClosed)
					dr.Close();
			}
		}

		protected void WaitThread(int nStartOffset)
		{
			if (nStartOffset > 0)
			{
				// Calculate the time the thread "should" start
				// NOTE: don't forget to account for compression ratio
				DateTime dtThreadStart = m_dtStart;
				dtThreadStart = dtThreadStart.AddMilliseconds(nStartOffset * m_dCompressionRatio);

				// Calculate at what timespan that should occur
				TimeSpan tsWait = dtThreadStart - DateTime.Now;

				// Wait the right amount of time
				if (tsWait.TotalMilliseconds > 0)
					Thread.Sleep((int)tsWait.TotalMilliseconds);
				else
				{
					// Falling behind, don't wait
				}
			}
		}

		/// <summary>
		/// Helper to log status to the console
		/// </summary>
		/// <param name="format"></param>
		/// <param name="args"></param>
		protected void PrintStatus(string format, params object[] args)
		{
			StringBuilder newformat = new StringBuilder();
			newformat.AppendFormat("[{0}], Thd {1}: ", DateTime.Now.ToString(), Thread.CurrentThread.Name);
			newformat.Append(format);
			Console.WriteLine(newformat.ToString(), args);
		}

		/// <summary>
		/// Helper to log status to an error log output file
		/// </summary>
		/// <param name="format"></param>
		/// <param name="args"></param>
		protected void LogError(string format, params object[] args)
		{
			try
			{
				StringBuilder newformat = new StringBuilder();
				newformat.AppendFormat("[{0}], Thd {1}: ", DateTime.Now.ToString(), Thread.CurrentThread.Name);
				newformat.Append(format);
				//KKLINE - Tried to make thread safe, didn't work, removing error logging temporarily.
                //TextWriter.Synchronized(m_writerErrorLog).WriteLine(newformat.ToString(), args);
                //m_writerErrorLog.WriteLine(newformat.ToString(), args);
			}
			catch(Exception e)
			{
				// Just have to eat exceptions here and hope we can print to
				// give the user notification that something bad has happened
				PrintStatus("Exception trying to write error log: {0}", e.ToString());
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StatsLookup\Form1.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using ServerTestFramework.Database;
using ServerTestFramework;
using ServerTestFramework.LiveService.Stats;
using System.Xml;
using System.IO;


namespace StatsLookup
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class Form1 : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.ListBox listBox1;
		private System.Windows.Forms.TextBox txtPuid;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label Title;
		private System.Windows.Forms.TextBox txtLBID;
		private System.Windows.Forms.TextBox txtTitle;

		
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Form1()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}

				InitializerInfo.UninitializeGlobalResources();
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.button1 = new System.Windows.Forms.Button();
			this.txtPuid = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.listBox1 = new System.Windows.Forms.ListBox();
			this.label2 = new System.Windows.Forms.Label();
			this.Title = new System.Windows.Forms.Label();
			this.txtLBID = new System.Windows.Forms.TextBox();
			this.txtTitle = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(280, 40);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(75, 32);
			this.button1.TabIndex = 0;
			this.button1.Text = "Get Stats";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// txtPuid
			// 
			this.txtPuid.Location = new System.Drawing.Point(96, 80);
			this.txtPuid.Name = "txtPuid";
			this.txtPuid.Size = new System.Drawing.Size(168, 20);
			this.txtPuid.TabIndex = 1;
			this.txtPuid.Text = "";
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(16, 80);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(72, 23);
			this.label1.TabIndex = 2;
			this.label1.Text = "PUID";
			// 
			// listBox1
			// 
			this.listBox1.Location = new System.Drawing.Point(16, 112);
			this.listBox1.Name = "listBox1";
			this.listBox1.Size = new System.Drawing.Size(248, 238);
			this.listBox1.TabIndex = 3;
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(16, 48);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(72, 23);
			this.label2.TabIndex = 4;
			this.label2.Text = "LB ID";
			// 
			// Title
			// 
			this.Title.Location = new System.Drawing.Point(16, 16);
			this.Title.Name = "Title";
			this.Title.Size = new System.Drawing.Size(72, 23);
			this.Title.TabIndex = 5;
			this.Title.Text = "Title";
			// 
			// txtLBID
			// 
			this.txtLBID.Location = new System.Drawing.Point(96, 48);
			this.txtLBID.Name = "txtLBID";
			this.txtLBID.Size = new System.Drawing.Size(168, 20);
			this.txtLBID.TabIndex = 6;
			this.txtLBID.Text = "";
			// 
			// txtTitle
			// 
			this.txtTitle.Location = new System.Drawing.Point(96, 16);
			this.txtTitle.Name = "txtTitle";
			this.txtTitle.Size = new System.Drawing.Size(168, 20);
			this.txtTitle.TabIndex = 7;
			this.txtTitle.Text = "";
			// 
			// Form1
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(376, 358);
			this.Controls.Add(this.txtTitle);
			this.Controls.Add(this.txtLBID);
			this.Controls.Add(this.Title);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.listBox1);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.txtPuid);
			this.Controls.Add(this.button1);
			this.Name = "Form1";
			this.Text = "Form1";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Global.Initialize(Form1.LoadXmlConfig("stf.xml"));

			Application.Run(new Form1());
		}

		public static  XmlDocument LoadXmlConfig(string fileName)
		{
			XmlDocument config = new XmlDocument();
			config.Load(fileName);

			return config;
		}


		private void button1_Click(object sender, System.EventArgs e)
		{
			int title = Int32.Parse(txtTitle.Text);
			int lbid= Int32.Parse(txtLBID.Text);
			long Puid = Int64.Parse(txtPuid.Text);

			object data = StatsWS.GetUserStats(Puid,title,lbid);
			Parsestats(data);

			
		}

		public void Parsestats(object data)
		{
			ArrayList list = new ArrayList();
			byte[]stats = (byte[]) data;

			MemoryStream stream = new MemoryStream(stats);
			BinaryReader reader = new BinaryReader(stream);

			try
			{
				while(true)
				{
					int id = reader.ReadInt16();
					byte Type = reader.ReadByte(); 
					string txt = "ID = "+id.ToString("x");

					switch (Type)
					{
						case(byte)StatParamTypes.Int8:
							txt +=" Type=Int8 Value ="+reader.ReadByte();
							break;
						case(byte)StatParamTypes.Int16:
							txt +=" Type=Int16 Value ="+reader.ReadInt16();
							break;
						case(byte)StatParamTypes.Int32:
							txt +=" Type=Int32 Value ="+reader.ReadInt32();
							break;
						case(byte)StatParamTypes.Int64:
							txt +=" Type=Int64 Value ="+reader.ReadInt64();
							break;
						case(byte)StatParamTypes.Float:
							txt +=" Type=Double Value ="+reader.ReadDouble();
							break;
						case(byte)StatParamTypes.Utf8string:
							short size = reader.ReadInt16();
							byte[] rawBytes = reader.ReadBytes( size );
							string tp= System.Text.UnicodeEncoding.UTF8.GetString(rawBytes );
							txt +=" Type=string  Value ="+tp;
							break;
					}

					
					listBox1.Items.Add(txt);
				}
			}
			catch( System.Exception e)
			{
			}

		
			
			


		}



		
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StorageTestTool\Delete.cs ===
using System;
using ServerTestFramework.Web.Storage;

namespace StorageTestTool
{
	/// <summary>
	/// Summary description for Delete.
	/// </summary>
	public class Delete
	{
		static byte [] webid;
		static string gamertag;
		static uint titleId;
		static string storageFileName;

		public static void ParseArgs(string [] args)
		{
			// parse the remainder of the commandline
			//		StorageTestTool delete [user <passportId> <gamertag>] <titleId> <storageFileName>

			int argIndex = 1;
			try
			{
				// get user info (if any)
				if (args[argIndex].ToLower() == "user")
				{
					if (argIndex + 2 >= args.Length)
						throw new ParseException();
					argIndex++;
					webid = BitConverter.GetBytes(UInt64.Parse(args[argIndex++]));
					gamertag = args[argIndex++];
				}

				// get titleId
				titleId = UInt32.Parse(args[argIndex++],System.Globalization.NumberStyles.HexNumber);

				// get filename
				storageFileName = args[argIndex++];
			}
			catch
			{
				throw new ParseException();
			}

			// make call to DeleteTitle or DeleteUser based on arguments
			if (webid == null && gamertag == null)
				DeleteTitle();
			else
				DeleteUser();
		}

		static void DeleteTitle()
		{
			MainClass.wcstorage.DeleteTitleFile(titleId,storageFileName);

			Console.WriteLine("Deleted file "+storageFileName+" from title "+titleId);
		}

		static void DeleteUser()
		{
			MainClass.wcstorage.DeleteUserFile(titleId,webid,gamertag,storageFileName);

			Console.WriteLine("Deleted file "+storageFileName+" from title "+titleId+" for user "+gamertag);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SQLPlayback\SPBSplitter.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

namespace SQLPlayback
{
	/// <summary>
	/// Class to split up the SQLPlayback file into multiple files so
	/// each synchronous thread has it's own file. The split is made
	/// based on the PUID checksum using a simple hashing function.
	/// </summary>
	public class SPBSplitter
	{
		/// <summary>
		/// The main entry point for the application.
		/// 
		/// DEBUG COMMAND LINE: "SPLIT replay.log . 2 10"
		/// </summary>
		[STAThread]
		static void debugMain(string[] args)
		{
			try
			{
				SPBSplitter splitter = new SPBSplitter();
				splitter.Initialize(args);
				splitter.ProcessData();
				splitter.Terminate();
			}
			catch(Exception e)
			{
				Console.WriteLine("ERROR: {0}", e.ToString());
				Console.WriteLine("");
			}
		}

		/// <summary>
		/// Display the correct command line syntax
		/// </summary>
		public void DisplayUsage()
		{
			Console.WriteLine("\nOPTION: SPLIT - splits SQL Playback file into multiple files\n");
			Console.WriteLine("  {0} SPLIT <input file> <output dir>",
				AppDomain.CurrentDomain.FriendlyName);
			Console.WriteLine("    <client_names> <# threads/client> <group column>\n");
			Console.WriteLine("  EXAMPLE:");
            Console.WriteLine("    {0} SPLIT Nov30_2004.spb ..\\output \"XECLISXXX001,XECLISXXX002\" 25 SPID\n",
				AppDomain.CurrentDomain.FriendlyName);
			Console.WriteLine("  PARAMS:");
			Console.WriteLine("    <input file>       = Input file in SQLPlayback (SBP) format");
			Console.WriteLine("    <output dir>       = Location for output files");
            Console.WriteLine("    <client_names>     = Comma delimited(no spaces) list of client names");
			Console.WriteLine("    <# threads/client> = Number of threads per client\n");
            Console.WriteLine("    <group column>     = Column name to group records by (i.e. SPID or RowNumber)\n");
            Console.WriteLine("  NOTES:");
			Console.WriteLine("    This option will split the input file into multiple files");
			Console.WriteLine("    (one for each thread to be executed) based on a hash");
			Console.WriteLine("    of the group column for each query.");
			Console.WriteLine("    The output file naming convention is ClientXX_ThreadYYY.SPB");
		}

		/// <summary>
		/// Validate input and setup internal data
		/// </summary>
		/// <param name="args"></param>
		public void Initialize(string[] args)
		{
			// Verify the command line is in as expected
			if (!IsValidInput(args))
			{
				DisplayUsage();
				throw new Exception("Invalid input");
			}

			// Setup data
			m_strInputFile = args[1];
			m_strOutputDir = args[2];
            m_strServers = args[3].Split(',');
            for (int i = 0; i < m_strServers.Length; i++)
                m_strServers[i] = m_strServers[i].Trim();
			m_nThreads = System.Int32.Parse(args[4]);
            m_nFiles = m_strServers.Length * m_nThreads;
			m_rgOutputFiles = new StreamWriter[m_nFiles];
            m_strGroupBy = args[5];
            m_columns = new List<String>();

			// Open the input file
			m_rdrInputFile = new StreamReader(new FileStream(m_strInputFile, FileMode.Open,
				FileAccess.Read, FileShare.Read, 32767, false), System.Text.Encoding.Unicode);

            //Read the header
            String strLine = m_rdrInputFile.ReadLine();
            while (strLine != null && strLine[0] == '#')
            {
                if (strLine.StartsWith("#Fields"))
                {
                    String[] colHeaders = strLine.Split('\t');
                    for (int i = 1; i < colHeaders.Length; i++)
                    {
                        m_columns.Add(colHeaders[i]);
                    }
                }
                if (m_rdrInputFile.Peek() == '#')
                    strLine = m_rdrInputFile.ReadLine();
                else
                    strLine = null;
            }
            
            // Create the output files
            for (int i = 0; i < m_strServers.Length; i++)
			{
				for (int j = 0; j < m_nThreads; j++)
				{
					StreamWriter writer =
                        new StreamWriter(new FileStream(String.Format(m_strOutputFileFormat, m_strOutputDir, m_strServers[i], j.ToString("000")), FileMode.OpenOrCreate,
						FileAccess.Write, FileShare.Read, 32767, false), System.Text.Encoding.Unicode);
                    m_rgOutputFiles[i * m_nThreads + j] = writer;
                    //Write header
                    writer.WriteLine("#Software: SQLPlayback");
                    writer.WriteLine("#Version: 2.0");
                    writer.WriteLine("#Date: {0}", DateTime.Now);
                    writer.Write("#Fields:");
                    for (int k = 0; k < m_columns.Count; k++)
                        writer.Write("\t" + m_columns[k]);
                    writer.Write("\n");
				}
			}
		}

		/// <summary>
		/// Make sure everything (like files) are properly cleaned up
		/// </summary>
		public void Terminate()
		{
			// Close the input file
			m_rdrInputFile.Close();

			// Close all the output files
			if (m_rgOutputFiles != null)
			{
				for (int i = 0; i < m_nFiles; i++)
				{
					m_rgOutputFiles[i].Close();
				}
			}
		}

		/// <summary>
		/// Read in every line in the input file and write it out to the
		/// appropriate output file based on the PUID checksum hash (if any)
		/// </summary>
		public void ProcessData()
		{
			string strLine;
			string[] rgLineItems;
			int nHash;
			int nLines = 0;
			int nLinesSkipped = 0;
			Random rand = new System.Random();
            int groupIndex = m_columns.IndexOf(m_strGroupBy);

			// Read in a line at a time until done
			strLine = m_rdrInputFile.ReadLine();
			while (strLine != null)
			{
				// Crack the line (it's tab delimited)
				rgLineItems = strLine.Split('\t');

				// Make sure the line is of the proper format
				if (rgLineItems.Length != m_columns.Count)
				{
					nLinesSkipped++;
					if (nLinesSkipped == 1)
						Console.WriteLine("First skipped line detected at line {0}", nLines.ToString("#,##0"));
				}
				else
				{
                    nHash = rgLineItems[groupIndex].GetHashCode();
                    nHash = Math.Abs(nHash);
                    nHash = nHash % (m_nFiles);
					// Write out to the appropriate file
					m_rgOutputFiles[nHash].WriteLine(strLine);
				}

				// Generate and print out stats periodically
				nLines++;
				if (nLines % 10000 == 0)
					Console.WriteLine("Processed {0} lines, {1} lines skipped",
						nLines.ToString("#,##0"), nLinesSkipped.ToString("#,##0"));

				// Read the next line
				strLine = m_rdrInputFile.ReadLine();
			}

			Console.WriteLine("\nProcessing Complete:\nProcessed {0} lines, {1} lines skipped\n",
				nLines.ToString("#,##0"), nLinesSkipped.ToString("#,##0"));
		}

		// **
		// ** Class Internals
		// **

		// Member variables
		protected string m_strInputFile;
		protected string m_strOutputDir;
        protected string m_strGroupBy;
		protected int m_nThreads;
		protected int m_nFiles;
        protected static string m_strOutputFileFormat = "{0}\\{1}_Thread{2}.SPB";
		protected static string m_strOutputFile = "\\output.spb";
		protected StreamReader m_rdrInputFile;
		protected StreamWriter[] m_rgOutputFiles;
        protected String[] m_strServers;
        protected IList<String> m_columns;

		// Helpers

		/// <summary>
		/// Check that the input is valid
		/// </summary>
		/// <param name="args"></param>
		/// <returns></returns>
		protected bool IsValidInput(string[] args)
		{
			if (args.Length != 6)
				return false;

			if (args[0].ToUpper() != "SPLIT")
				return false;

			return true;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SQLPlayback\SPBCreater.cs ===
using System.Xml;
using System;
using System.Collections;
using System.IO;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace SQLPlayback
{
    /// <summary>
    /// This class will take the output of a SQL Profiler trace file that has
    /// been imported into a SQL table and use it to generate a formatted log file.
    /// This "SPB" log file can then be used in the SQLPlayback tool
    /// 
    /// There are numerous assumptions inherent in this tool and they should be
    /// noted in the code but a few will be called out here.
	/// </summary>
	/// 
    /// Assumptions:
    /// 1) The sql trace file has been imported into a SQL table.
    /// 2) The sql trace included a number of parameters like start time and dbid.
    /// 
    /// Below are the configurable parameters in config file
    /// TraceFilterSelectFormat - query to be performed on the table
    ///  e.g. SELECT * FROM {0} WHERE StartTime IS NOT NULL
    /// 
    
    public class SPBCreater
    {
        /// <summary>
        /// The main entry point for the application.
        /// 
        /// DEBUG COMMAND LINE: "CREATE jeffg1 sqlprofiler sqltrace100k replay.log"
        /// </summary>
        [STAThread]
        static void debugMain(string[] args)
        {
            // Use the class to do all the work
            SPBCreater sc = new SPBCreater();
            sc.Initialize(args);
            sc.ProcessData();
            sc.Terminate();
        }

        // Set some member values
        public SPBCreater()
        {
            m_sqlConnection = null;
            m_sqlCommand = null;
            m_sqlDataReader = null;
            m_writer = null;
            m_strSqlTableName = null;
            m_strDefaultDB = "UserDB";
            m_strDbMap = "";
            m_strConnectionFormat = "Data Source={0};Initial Catalog={1};Integrated Security=SSPI";
            m_strSqlCallFormat = "SELECT{0} * FROM [{1}] WHERE TextData IS NOT NULL AND starttime IS NOT NULL AND databaseid IS NOT NULL ORDER BY StartTime";
            m_nMaxLinesToRead = -1;
            m_nQueryTimeout = 900;
            m_extractColumns = new Dictionary<string, Regex>();
        }

		/// <summary>
		/// Display the proper usage on the command line
		/// </summary>
        public void DisplayUsage()
        {
			Console.WriteLine("\nOPTION: CREATE - creates a SQL Playback file\n");
			Console.WriteLine("  {0} CREATE <sql server> <sql db>\n",
				AppDomain.CurrentDomain.FriendlyName);
			Console.WriteLine("    <sql table> <output file> [max lines]\n");
			Console.WriteLine("  EXAMPLE:");
			Console.WriteLine("    {0} CREATE TestSvr ProfilerData",
				AppDomain.CurrentDomain.FriendlyName);
			Console.WriteLine("     Trace_11_30_04 replay_11_30_04\n");
			Console.WriteLine("  PARAMS:");
			Console.WriteLine("    <sql server>   = Name of SQL Server with Profiler Data");
			Console.WriteLine("    <sql db>       = Name of SQL Database with Profiler Data");
			Console.WriteLine("    <sql table>    = Name of SQL Table containing Profiler Data");
			Console.WriteLine("    <output file>  = Name of SPB formatted file to create");
			Console.WriteLine("    [max lines]    = [OPTIONAL] Maximum number of lines to process");
			Console.WriteLine("  NOTES:");
			Console.WriteLine("    For more options, consider using a config file (app.config)");
		}

        /// <summary>
        /// Initialize the database and the output file
        /// </summary>
        /// <param name="args"></param>
        public void Initialize(string[] args)
        {
			// Verify the command line is in as expected
			if (!IsValidInput(args))
			{
				DisplayUsage();
				throw new Exception("Invalid input");
			}

            m_columns = new List<string>();
            m_columns.Add("Time");
            m_columns.Add("Database");
            m_columns.Add("RowNumber");
            m_columns.Add("SPID");
            // Load app config file
            LoadConfig();
            m_columns.Add("Query");

            // Open the connection to the database
            m_sqlConnection = new SqlConnection();
            
            // Build the connection string
            m_sqlConnection.ConnectionString =  string.Format(m_strConnectionFormat,
                args[1], args[2]);

            Console.WriteLine("Connecting to SQL: {0}", 
                m_sqlConnection.ConnectionString);

            m_sqlConnection.Open();

            // Assign sql table name param(needed)
            m_strSqlTableName = args[3];

            // Get number of lines to read
            int nValue;
            if (args.Length > 5)
            {
                nValue = Int32.Parse(args[5]);
                if (nValue > -1)
                    m_nMaxLinesToRead = nValue;
            }

            // Load DB Mapping file
            m_hashtableDbMap = new Hashtable();
            LoadDBMap();

            // Open the SQLTrace table using a SQLDataReader (one record at a time forward only)
            m_sqlCommand = new SqlCommand();           
            m_sqlCommand.CommandType = CommandType.Text;
            m_sqlCommand.Connection = m_sqlConnection;
            m_sqlCommand.CommandTimeout = m_nQueryTimeout;
			if (m_nMaxLinesToRead < 0)
			{
				m_sqlCommand.CommandText = string.Format(m_strSqlCallFormat,
					"", m_strSqlTableName);
			}
			else
			{
				m_sqlCommand.CommandText = string.Format(m_strSqlCallFormat,
					" TOP " + m_nMaxLinesToRead.ToString(), m_strSqlTableName);
			}

			Console.WriteLine("Executing: {0}", m_sqlCommand.CommandText);
			m_sqlDataReader = m_sqlCommand.ExecuteReader();

            //Lock the columns list so that changed cannot be made in the middle
            m_columns = ((List<String>)m_columns).AsReadOnly();
            
            // Create the output file, default to overwrite
			// BUG: Use Unicode encoding because production data died
			// when using the default UTF8 due to the dreaded
			// mismatched pair exception
			m_writer = new StreamWriter((args[4]+".spb"), false, System.Text.Encoding.Unicode);
            Console.WriteLine("Creating {0}.spb...", args[4]);
            //Write the header (try to mimic IIS log format)
            m_writer.WriteLine("#Software: SQLPlayback");
            m_writer.WriteLine("#Version: 2.0");
            m_writer.WriteLine("#Date: {0}", DateTime.Now);
            m_writer.Write("#Fields:");
            for (int i = 0; i < m_columns.Count; i++)
                m_writer.Write("\t" + m_columns[i]);
            m_writer.Write("\n");
        }

        /// <summary>
        /// This is the meat of the class. Simple iterate through all the 
        /// records in the data reader and output one line in the IPB
        /// file for each record. 
        /// </summary>
        public void ProcessData()
        {
			int nDBID;
			int nRowNumber = 0;
            int nSPID;
			string strDatabase = String.Empty;
			string strQuery = String.Empty;
			DateTime dtCurr;
			DateTime dtStart;
			TimeSpan spanDeltaTime;

			int nRecords = 0;
			int nSkippedRecords = 0;
			int nSeconds = 0;
			int nPerSecond = 0;
			int nMaxPerSecond = 0;

			if (!m_sqlDataReader.Read())
            {
                Console.WriteLine("\nTrace table is empty.");
                return;
            }

			// Optimization: cache the column ordinals
			int nSTOrdinal = m_sqlDataReader.GetOrdinal("StartTime");
			int nTDOrdinal = m_sqlDataReader.GetOrdinal("TextData");
            int nDBNameOrdinal = -1;
            try { m_sqlDataReader.GetOrdinal("DatabaseName"); }
            catch (IndexOutOfRangeException) { }
			int nDBIDOrdinal = m_sqlDataReader.GetOrdinal("DatabaseID");
			int nRNOrdinal = m_sqlDataReader.GetOrdinal("RowNumber");
            int nSPIDOrdinal = m_sqlDataReader.GetOrdinal("SPID");

			// Get the data in the expected format
			dtStart = m_sqlDataReader.GetDateTime(nSTOrdinal);

			do 
            {
				try
				{
					dtCurr = m_sqlDataReader.GetDateTime(nSTOrdinal);
					strQuery = m_sqlDataReader.GetString(nTDOrdinal);
					nDBID = m_sqlDataReader.GetInt32(nDBIDOrdinal);
					nRowNumber = m_sqlDataReader.GetInt32(nRNOrdinal);
                    nSPID = m_sqlDataReader.GetInt32(nSPIDOrdinal);
					// Get the db name from the map
                    if(nDBNameOrdinal!=-1)
                        strDatabase = m_sqlDataReader.GetString(nDBNameOrdinal);
                    if (strDatabase == String.Empty)
                    {
                        if (m_hashtableDbMap.ContainsKey(nDBID.ToString()))
                        {
                            strDatabase = (string)m_hashtableDbMap[nDBID.ToString()];
                        }
                        else
                        {
                            strDatabase = m_strDefaultDB;
                        }
                    }
	                
					// Compute the relative delta time
					spanDeltaTime = dtCurr.Subtract(dtStart);

					// BUG: TextData (the query) sometimes contains newlines
					// and returns which wreaks havoc
                    strQuery = strQuery.Replace('\t', ' ');
                    strQuery = strQuery.Replace('\n', ' ');
					strQuery = strQuery.Replace('\r', ' ');

					// Write the data to the output file
                    StringBuilder builder = new StringBuilder();
                    for (int i = 0; i < m_columns.Count; i++)
                    {
                        if (i != 0)
                            builder.Append('\t');
                        switch(m_columns[i])
                        {
                            case "Time":
                                builder.Append(spanDeltaTime.TotalMilliseconds);
                                break;
                            case "Database":
                                builder.Append(strDatabase);
                                break;
                            case "RowNumber":
                                builder.Append(nRowNumber.ToString());
                                break;
                            case "SPID":
                                builder.Append(nSPID);
                                break;
                            case "Query":
                                builder.Append(strQuery);
                                break;
                            default:
                                if (m_extractColumns.ContainsKey(m_columns[i]))
                                {
                                    Regex regex = m_extractColumns[m_columns[i]];
                                    Match match = regex.Match(strQuery);
                                    if (match.Success)
                                    {
                                        builder.Append(match.Groups[m_columns[i]].Value);
                                    }
                                    else
                                        builder.Append('-');

                                }
                                else
                                    throw new Exception("Invalid arg "+m_columns[i]);
                                break;
                        }
                    }
                    m_writer.WriteLine(builder.ToString());
					/*strLine = string.Format(m_LogEntryFormat, spanDeltaTime.TotalMilliseconds,
						strDatabase, nRowNumber, strPuid, strQuery);
					m_writer.WriteLine(strLine);*/
				    
					// Calculate stats
					if ((int)spanDeltaTime.TotalSeconds == nSeconds)
					{
						nPerSecond++;
					}
					else
					{
						if(nPerSecond > nMaxPerSecond)
						{
							nMaxPerSecond = nPerSecond;
						}

						// Reset the data
						nPerSecond = 1;
						nSeconds = (int)spanDeltaTime.TotalSeconds;
					}
				}
				catch (Exception e)
				{
					// Log the first skipped record
					if (nSkippedRecords == 0)
					{
						Console.WriteLine("Skipped record {0}, no more will be logged\n",
							(nRecords+1).ToString("#,##0"));
						Console.WriteLine("RowNumber = {0}, Query = {1}",
							nRowNumber.ToString("#,##0"), strQuery);
						Console.WriteLine(e.ToString());
					}

					// Calculate stats
					nSkippedRecords++;
				}
				finally
				{
					// Increment the record count
					nRecords++;
				}

				// Ouput the status every so often
				if (nRecords % 10000 == 0)
                {
                    Console.WriteLine("{0} Records processed...", nRecords.ToString("#,##0"));
					Console.WriteLine("\tMax queries in 1 second: {0}", nMaxPerSecond.ToString("#,##0"));
					if (nSkippedRecords > 0)
						Console.WriteLine("\tTotal skipped records: {0}", nSkippedRecords);
				}

            } while (m_sqlDataReader.Read());

            // Output stats
            Console.WriteLine("\n\nSuccessfully processed {0} records.", nRecords.ToString("#,##0"));
			Console.WriteLine("\tMax queries in 1 second: {0}\n", nMaxPerSecond.ToString("#,##0"));
        }

		/// <summary>
        /// Close up any open objects 
        /// </summary>
        public void Terminate()
        {
            // Close up shop and be done
            if (m_writer != null)
                m_writer.Close();

            if (m_sqlDataReader != null && !m_sqlDataReader.IsClosed)
                m_sqlDataReader.Close();

            if (m_sqlConnection != null &&
                m_sqlConnection.State == ConnectionState.Open)
                m_sqlConnection.Close();
        }



		// **
		// ** Class Internals
		// **

		// Member variables
		protected string m_strSqlTableName;
		protected string m_strDbMap;
		protected string m_strSqlCallFormat;
		protected string m_strConnectionFormat;
		protected string m_strDefaultDB;
		protected Hashtable m_hashtableDbMap;
		protected SqlConnection m_sqlConnection;
		protected SqlCommand m_sqlCommand;
		protected SqlDataReader m_sqlDataReader;
		protected TextWriter m_writer;
		protected int m_nQueryTimeout;
		protected int m_nMaxLinesToRead;
        protected IList<String> m_columns;
        protected Dictionary<String, Regex> m_extractColumns;

		// Log Format
		// DeltaTime Database RowNumber PUID ThreadChecksum ReturnsData Query
		protected static string m_LogEntryFormat = "{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}";

		// Split chars for SQL string PUID cracking
		protected static char[] m_SQLDelimiters = {' ', ',', '\t', '\n'};


		// Helpers

		/// <summary>
		/// Validate that the input is what is expected
		/// </summary>
		/// <param name="args"></param>
		/// <returns></returns>
		protected bool IsValidInput(string[] args)
		{
			if (args.Length < 5 || args.Length > 6)
				return false;

			if (args[0].ToUpper() != "CREATE")
				return false;

			return true;
		}

		/// <summary>
		/// Get some values from the app config file
		/// </summary>
		protected void LoadConfig()
		{
			string strTemp;

            strTemp = ConfigurationManager.AppSettings["DBMap"];  
			if (strTemp != null)
				m_strDbMap = strTemp;

			strTemp = ConfigurationManager.AppSettings["DefaultDB"];  
			if (strTemp != null)
				m_strDefaultDB = strTemp;

			strTemp = ConfigurationManager.AppSettings["TraceFilterSelectFormat"];
			if (strTemp != null)
				m_strSqlCallFormat = strTemp;

			strTemp = ConfigurationManager.AppSettings["ConnectionString"];
			if (strTemp != null)
				m_strConnectionFormat = strTemp;

			strTemp = ConfigurationManager.AppSettings["QueryTimeout"];
			if (strTemp != null)
				m_nQueryTimeout = Int32.Parse(strTemp);

            String[] keys=ConfigurationManager.AppSettings.AllKeys;
            for (int i = 0; i < keys.Length; i++)
            {
                if (keys[i].StartsWith("Extract"))
                {
                    string name = keys[i].Substring(7);
                    m_columns.Add(name);
                    String regexText=ConfigurationManager.AppSettings[keys[i]];
                    Regex regex=new Regex(regexText, RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);
                    m_extractColumns.Add(name, regex);
                }
            }

        }

        /// <summary>
        /// Loads the db mapping in a table and use that to map the dbid in SQL Profiler trace
        /// </summary>
        protected void LoadDBMap()
		{
			string []rgFields;
			string []rgItems;
			int nCount;

			rgFields = m_strDbMap.Split(';');

			if ((nCount = rgFields.Length) == 0 || rgFields[0].Length == 0)
				return;

			while (nCount > 0)
			{
				nCount--;
				rgItems = rgFields[nCount].Split('=');
				if (rgItems.Length != 2)
				{
					Console.WriteLine("Invalid DBMap entry in config file[{0}].", m_strDbMap);
					Console.WriteLine("Should be this format: <dbname>=<dbid>;<dbname>=<dbid>");
					return;
				}
				m_hashtableDbMap.Add(rgItems[1].Trim(), rgItems[0].Trim());
			}
		}

		/// <summary>
		/// Internal helper to get the Puid, calculate a checksum,
		/// and determine if the query returns data
		/// </summary>
		/// <param name="strQuery"></param>
		/// <param name="strPuid"></param>
		/// <param name="nChecksum"></param>
		/// <param name="bReturnsData"></param>
		/*protected String GetPUID(string strQuery)
		{
			string[] rgQuery;

			// Set the default values
			strPuid = "-";
			nChecksum = 0;
			bReturnsData = true;

			// Crack the query on spaces then check for PUIDs
			rgQuery = strQuery.Split(m_SQLDelimiters);

			// BUG: Some SQL statements are prepared
			// ie -
			//   declare @P int
			//   set @P1=1
			//   exec sp_prepare @P1 output, N'@P1 int OUTPUT', N' EXEC @P1=wsp_DeletePosTransaction ''{FC1B0144-F9BB-46B1-B3A6-1EB66B4B39FC}'',0,0x0003000081522b3a  ', 1
			//   select @P1
			string strTemp = strQuery.ToUpper();
			if (strTemp.StartsWith("DECLARE"))
			{
				int nStart;
				int nEnd;

				// Specially mark escaped single quotes
				strTemp = strTemp.Replace("''", "~~");

				// With Surfboard release, only wsp_ procs ever are prepared
				nStart = strTemp.IndexOf("WSP_");
				if (nStart > 0)
				{
					// It's prepared, extract substring from wsp_ to final single quote
					nEnd = strTemp.IndexOf("'", nStart);
					strTemp = strQuery.Substring(nStart, nEnd - nStart);

					// Remove escaped single quotes
					strTemp = strTemp.Replace("''", "'");

					// Now reset the query info
					strQuery = "exec " + strTemp.TrimEnd(' ');
					rgQuery = strQuery.Split(m_SQLDelimiters);
				}
			}

			// Loop until we find the puid OR hit the end
			for (int i = 0; i < rgQuery.Length; i++)
			{
				// We're done if we've found what looks like a PUID
				// IE - starts with "0x" and is 2 + 16 chars long
				if (rgQuery[i].StartsWith("0x") && rgQuery[i].Length == 18)
				{
					strPuid = rgQuery[i];

					// Now get the checksum
					nChecksum = GetPuidChecksum(strPuid);
					break;
				}

				// BUG: We're done if we've found "@puid ="
				// Some PUIDs with no A-F octal digits don't
				// have the 0x prefix and aren't 18 digits long
				else if (i < (rgQuery.Length - 2) && rgQuery[i] == "@puid" &&
					rgQuery[i+1] == "=" && !rgQuery[i+2].StartsWith("0x"))
				{
					strPuid = rgQuery[i+2];

					// Now get the checksum
					nChecksum = GetPuidChecksum(strPuid);
					break;
				}
			}
		}*/

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SQLPlayback\Main.cs ===
using System;

namespace SQLPlayback
{
	/// <summary>
	/// Tool created by Jeff Grove - given to KKline from MSN Money team
    /// for use.  
	/// </summary>
	public class PlaybackApp
	{
		/// <summary>
		/// The main entry point for the application. 
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			try
			{
				PlaybackApp app = new PlaybackApp();

				if (!app.IsValidInput(args))
				{
					app.DisplayUsage();
					throw new Exception("Invalid input");
				}

                // UNDONE: All 3 classes could be derived from same base class
                // and wouldn't need a big switch statement here.

				switch (args[0].ToUpper())
				{
					case "CREATE":
                        if (args.Length == 1)
                        {
                            app.m_create.DisplayUsage();
                            break;
                        }
						app.m_create.Initialize(args);
						app.m_create.ProcessData();
						app.m_create.Terminate();
						break;

					case "SPLIT":
                        if (args.Length == 1)
                        {
                            app.m_split.DisplayUsage();
                            break;
                        }
						app.m_split.Initialize(args);
						app.m_split.ProcessData();
						app.m_split.Terminate();
						break;

					case "EXEC":
                        if (args.Length == 1)
                        {
                            app.m_exec.DisplayUsage();
                            break;
                        }
						app.m_exec.Initialize(args);
						app.m_exec.ProcessData();
						app.m_exec.Terminate();
						break;

					default:
						app.DisplayUsage();
						throw new Exception("Invalid input");
				}
			}
			catch(Exception e)
			{
				Console.WriteLine("ERROR: {0}", e.ToString());
				Console.WriteLine("");
			}
		}

		/// <summary>
		/// 
		/// </summary>
		protected PlaybackApp()
		{
			m_create = new SPBCreater();
			m_split = new SPBSplitter();
			m_exec = new SPBExecuter();
		}

		/// <summary>
		/// 
		/// </summary>
		public void DisplayUsage()
		{
			Console.WriteLine("This application is for replaying SQL Profiler traces.");
			Console.WriteLine("It is affectionately referred to as SQLPlayback.");
			Console.WriteLine("This executable performs 3 main functions.");
			Console.WriteLine("  1 - It will generate a file used to drive the playback");
			Console.WriteLine("        ASSUMES: Profiler data stored in accessible SQL DB");
			Console.WriteLine("                 and that this profiler data is a duration");
			Console.WriteLine("                 based profile.");
			Console.WriteLine("  2 - It will split up this output file into multiple files");
			Console.WriteLine("        ASSUMES: MSN Money/Passport specific data");
			Console.WriteLine("                 is part of virtually every query/SP called.");
			Console.WriteLine("                 The split is based on a hash of these PUIDs.");
			Console.WriteLine("  3 - It will execute a multi-threaded replay in real time");
			Console.WriteLine("\nMore information is supplied for each one of these 3 steps:\n");

			SPBCreater creater = new SPBCreater();
			SPBSplitter splitter = new SPBSplitter();
			SPBExecuter executer = new SPBExecuter();
            
			Console.WriteLine("\n------------------------------------\n");
			creater.DisplayUsage();
			Console.WriteLine("\n------------------------------------\n");
			splitter.DisplayUsage();
			Console.WriteLine("\n------------------------------------\n");
			executer.DisplayUsage();
		}

		// **
		// ** Class Internals
		// **

		// Member variables
		protected SPBCreater m_create;
		protected SPBSplitter m_split;
		protected SPBExecuter m_exec;

		// Helper functions
		protected bool IsValidInput(string[] args)
		{
			if (args.Length == 0)
				return false;

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StorageTestTool\Download.cs ===
using System;
using ServerTestFramework.Web.Storage;

namespace StorageTestTool
{
	/// <summary>
	/// Summary description for Download.
	/// </summary>
	public class Download
	{
		static byte [] webid;
		static string gamertag;
		static uint titleId;
		static string storageFileName;
		static string locationToDownload;

		public static void ParseArgs(string [] args)
		{
			// parse the remainder of the commandline
			//		StorageTestTool download [user <passportId> <gamertag>] <titleId> <storageFileName> <locationToDownload>

			int argIndex = 1;
			try
			{
				// get user info (if any)
				if (args[argIndex].ToLower() == "user")
				{
					if (argIndex + 2 >= args.Length)
						throw new ParseException();
					argIndex++;
					webid = BitConverter.GetBytes(UInt64.Parse(args[argIndex++]));
					gamertag = args[argIndex++];
				}

				// get titleId
				titleId = UInt32.Parse(args[argIndex++],System.Globalization.NumberStyles.HexNumber);

				// get filename
				storageFileName = args[argIndex++];

				// get location to Download
				locationToDownload = args[argIndex++];
			}
			catch
			{
				throw new ParseException();
			}

			// make call to DownloadTitle or DownloadUser based on arguments
			if (webid == null && gamertag == null)
				DownloadTitle();
			else
				DownloadUser();
		}

		static void DownloadTitle()
		{
			ReadFileInfo rInfo = MainClass.wcstorage.ReadTitleFile(titleId,storageFileName,DateTime.MinValue);

			// first try to create the file containing the data returned
			try
			{
				System.IO.FileStream fstream = System.IO.File.Create(locationToDownload);
				fstream.Write(rInfo.FileData,0,rInfo.FileData.Length);
				fstream.Close();
			}
			catch
			{
				throw new Exception("Error creating file: "+locationToDownload);
			}

			// then print info about the file
			Console.WriteLine("Wrote file "+locationToDownload);
			Console.WriteLine("\tCreation Date: "+rInfo.CreationDate.ToString());
			Console.WriteLine("\tTitle ID: "+rInfo.TitleID.ToString());
			Console.WriteLine("\tTitle Version: "+rInfo.TitleVersion.ToString());
			Console.WriteLine("\tFile Size: "+rInfo.FileSize.ToString());
			Console.WriteLine("\tContent Type: "+rInfo.FileContentType.GetType());
			Console.WriteLine("\tGamerTag: "+rInfo.GamerTag);
			Console.WriteLine("\tUser's Country ID: "+rInfo.UserCountryID.ToString());
		}

		static void DownloadUser()
		{
			ReadFileInfo rInfo = MainClass.wcstorage.ReadUserFile(titleId,webid,gamertag,storageFileName,DateTime.MinValue);

			// first try to create the file containing the data returned
			try
			{
				System.IO.FileStream fstream = System.IO.File.Create(locationToDownload);
				fstream.Write(rInfo.FileData,0,rInfo.FileData.Length);
				fstream.Close();
			}
			catch
			{
				throw new Exception("Error creating file: "+locationToDownload);
			}

			// then print info about the file
			Console.WriteLine("Wrote file "+locationToDownload);
			Console.WriteLine("\tCreation Date: "+rInfo.CreationDate.ToString());
			Console.WriteLine("\tTitle ID: "+rInfo.TitleID.ToString());
			Console.WriteLine("\tTitle Version: "+rInfo.TitleVersion.ToString());
			Console.WriteLine("\tFile Size: "+rInfo.FileSize.ToString());
			Console.WriteLine("\tContent Type: "+rInfo.FileContentType.ToString());
			Console.WriteLine("\tGamerTag: "+rInfo.GamerTag);
			Console.WriteLine("\tUser's Country ID: "+rInfo.UserCountryID.ToString());
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StorageTestTool\Revoke.cs ===
using System;
using ServerTestFramework.Web.Storage;

namespace StorageTestTool
{
	/// <summary>
	/// Summary description for Revoke.
	/// </summary>
	public class Revoke
	{
		static byte [] webid;
		static string gamertag;
		static uint titleId;
		static string storageFileName;

		public static void ParseArgs(string [] args)
		{
			// parse the remainder of the commandline
			//		StorageTestTool revoke [user <passportId> <gamertag>] <titleId> <storageFileName>

			int argIndex = 1;
			try
			{
				// get user info (if any)
				if (args[argIndex].ToLower() == "user")
				{
					if (argIndex + 2 >= args.Length)
						throw new ParseException();
					argIndex++;
					webid = BitConverter.GetBytes(UInt64.Parse(args[argIndex++]));
					gamertag = args[argIndex++];
				}

				// get titleId
				titleId = UInt32.Parse(args[argIndex++],System.Globalization.NumberStyles.HexNumber);

				// get filename
				storageFileName = args[argIndex++];
			}
			catch
			{
				throw new ParseException();
			}

			// make call to RevokeTitle or RevokeUser based on arguments
			if (webid == null && gamertag == null)
				RevokeTitle();
			else
				RevokeUser();
		}

		static void RevokeTitle()
		{
			MainClass.wcstorage.RevokeTitleFile(titleId,storageFileName);

			Console.WriteLine("Revoked file "+storageFileName+" from title "+titleId);
		}

		static void RevokeUser()
		{
			MainClass.wcstorage.RevokeUserFile(titleId,webid,gamertag,storageFileName);

			Console.WriteLine("Revoked file "+storageFileName+" from title "+titleId+" for user "+gamertag);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StorageTestTool\Enumerate.cs ===
using System;
using ServerTestFramework.Web.Storage;

namespace StorageTestTool
{
	/// <summary>
	/// Summary description for Enumerate.
	/// </summary>
	public class Enumerate
	{
		static uint titleId;
		static string queryString = "%";

		public static void ParseArgs(string [] args)
		{
			// parse the remainder of the commandline
			//		StorageTestTool enum|enumerate <titleId> [<queryString>]

			int argIndex = 1;
			try
			{
				// get titleId
				titleId = UInt32.Parse(args[argIndex++],System.Globalization.NumberStyles.HexNumber);

				// get queryString (if any)
				if (argIndex < args.Length)
				{
					queryString = args[argIndex++];
				}
			}
			catch
			{
				throw new ParseException();
			}

			EnumerateTitle();
		}

		static void EnumerateTitle()
		{
			FileEnumerationInfo[] eInfos = MainClass.wcstorage.EnumerateTitleFiles(titleId,queryString,DateTime.MinValue);

			if (eInfos.Length == 0)
			{
				Console.WriteLine("No files found.");
				return;
			}

			Console.WriteLine("Files returned for title "+titleId+" version "+eInfos[0].TitleVersion+":");
			Console.WriteLine("FileName\tFileSize\tCreationDate\tModifiedDate\tContentType\tGamerTag\tUserCountryId");
			foreach (FileEnumerationInfo eInfo in eInfos)
			{
				Console.WriteLine(eInfo.FileName+"\t"+eInfo.FileSize.ToString()+"\t"+eInfo.CreationDate.ToString()+"\t"+eInfo.ModifiedDate.ToString()+"\t"+eInfo.FileContentType.ToString()+"\t"+eInfo.GamerTag+"\t"+eInfo.UserCountryID.ToString());
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StorageTestTool\Upload.cs ===
using System;
using ServerTestFramework.Web.Storage;

namespace StorageTestTool
{
	/// <summary>
	/// Summary description for Upload.
	/// </summary>
	public class Upload
	{
		static byte [] webid;
		static string gamertag;
		static FileContentTypeEnum contentType = FileContentTypeEnum.Blob;
		static uint titleId;
		static string storageFileName;
		static byte [] data;

		public static void ParseArgs(string [] args)
		{
			// parse the remainder of the commandline
			//		StorageTestTool upload [user <passportId> <gamertag>] [package] <titleId> <storageFileName> <fileToUpload>

			string fileToUpload;
			int argIndex = 1;
			try
			{
				// get user info (if any)
				if (args[argIndex].ToLower() == "user")
				{
					if (argIndex + 2 >= args.Length)
						throw new ParseException();
					argIndex++;
					webid = BitConverter.GetBytes(UInt64.Parse(args[argIndex++]));
					gamertag = args[argIndex++];
				}

				// is this a package?
				if (args[argIndex].ToLower() == "package")
				{
					argIndex++;
					contentType = FileContentTypeEnum.Package;
				}

				// get titleId
				titleId = UInt32.Parse(args[argIndex++],System.Globalization.NumberStyles.HexNumber);

				// get filename
				storageFileName = args[argIndex++];

				// get filename to upload
				fileToUpload = args[argIndex++];
			}
			catch
			{
				throw new ParseException();
			}

			// get data to upload
			System.IO.FileStream fStream = System.IO.File.OpenRead(fileToUpload);
			int fileLen = (int)fStream.Length;
			data = new byte[fileLen];
			int nBytesRead = fStream.Read(data,0,fileLen);
			if (nBytesRead != fileLen)
				throw new Exception("Error reading file: "+fileToUpload);
			fStream.Close();

			// make call to UploadTitle or UploadUser based on arguments
			if (webid == null && gamertag == null)
				UploadTitle();
			else
				UploadUser();
		}

		static void UploadTitle()
		{
			MainClass.wcstorage.WriteTitleFile(titleId,storageFileName,contentType,data,DateTime.MaxValue.AddDays(-1));

			Console.WriteLine("Stored file as: "+storageFileName);
		}

		static void UploadUser()
		{
			MainClass.wcstorage.WriteUserFile(titleId,webid,gamertag,storageFileName,contentType,data,DateTime.MaxValue.AddDays(-1));

			Console.WriteLine("Stored file as: "+storageFileName);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\ErrorBox.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace Microsoft.Live.Test.Common.Forms
{
	public partial class ErrorBox : Form
	{
		/// <summary>
		/// 
		/// </summary>
		/// <param name="e"></param>
		/// <param name="message"></param>
		public ErrorBox(Exception e, string caption, string message)
		{
			InitializeComponent();

			this.Height = 146;
			this.errorIcon.Image = SystemIcons.Error.ToBitmap();
			this.Text = caption;
			this.errorMessage.Text = String.Format("{0}  {1}", message, e.Message);
			this.innerException.Text = e.ToString();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void ok_Click(object sender, EventArgs e)
		{
			this.Close();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void showInnerException_Click(object sender, EventArgs e)
		{
			if (this.Height == 279)
			{
				this.Height = 146;
			}
			else
			{
				this.Height = 279;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\ClientVersionConverter.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    public class ClientVersionConverter: TypeConverter
    {
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
        {
            return TypeDescriptor.GetProperties(typeof(ClientVersion), attributes).Sort(new string[] { "MajorVersion", "MinorVersion", "BuildNumber", "QFENumber" });
        }

        public override bool GetPropertiesSupported(ITypeDescriptorContext context)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StorageTestTool\MainClass.cs ===
using System;
using System.Xml;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService;

namespace StorageTestTool
{
	// define a new exception class ParseException to determine difference between
	// an exception due to command-line parsing and exceptions from trying to hit the widget
	class ParseException : System.Exception
	{
		public ParseException ()
		{
		}

		public ParseException (string errorMessage)
		{
		}
	}

	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class MainClass
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		public static WCStorage wcstorage;

		[STAThread]
		static void Main(string[] args)
		{
			// get config info from xml file
			string IPofWebCacheVIP = null;
			string PartnerName = null;
			string PartnerIP = null;
			string RequestID = null;
			try
			{
				XmlDocument configXML = new XmlDocument();
				configXML.Load("Config.xml");

				// get IP address of Web Cache VIP
				XmlNode configNode = configXML.SelectSingleNode("/config/IPofWebCacheVIP");
				if (configNode == null)
					throw new Exception("Error in XML document");
				IPofWebCacheVIP = configNode.InnerText;

				// get Partner Name
				configNode = configXML.SelectSingleNode("/config/PartnerName");
				if (configNode == null)
					throw new Exception("Error in XML document");
				PartnerName = configNode.InnerText;

				// get Partner IP
				configNode = configXML.SelectSingleNode("/config/PartnerIP");
				if (configNode == null)
					throw new Exception("Error in XML document");
				PartnerIP = configNode.InnerText;

				// get Request ID
				configNode = configXML.SelectSingleNode("/config/RequestID");
				if (configNode == null)
					throw new Exception("Error in XML document");
				RequestID = configNode.InnerText;
			}
			catch (Exception e)
			{
				Console.WriteLine("Error reading Config.xml file: "+e.Message);
				return;
			}

			// create instance of wcstorage
			LiveServer ls = new LiveServer("storWidget",IPofWebCacheVIP);
			wcstorage = new WCStorage(ls,new RequestInfo(PartnerName,PartnerIP,RequestID));

			// determine what type of call this is:
			//     UPLOAD (Title or User)
			//     DOWNLOAD (Title or User)
			//     ENUMERATE (Title only)
			//     DELETE (Title or User)
			//     REVOKE (Title or User)
			// then parse rest of commandline based on the type of call
			try
			{
				if (args.Length == 0)
					throw new ParseException();

				switch (args[0].ToLower())
				{
					case "upload":
						Upload.ParseArgs(args);
						break;
					case "download":
						Download.ParseArgs(args);
						break;
					case "enum":
						goto case "enumerate";
					case "enumerate":
						Enumerate.ParseArgs(args);
						break;
					case "delete":
						Delete.ParseArgs(args);
						break;
					case "revoke":
						Revoke.ParseArgs(args);
						break;
					default:
						throw new ParseException();
				}
			}
			catch (ParseException)
			{
				// on any parse error, print the correct usage and quit
				Console.WriteLine("See the following for proper usage.");
				Console.WriteLine();
				Console.WriteLine("UPLOAD:");
				Console.WriteLine("\tStorageTestTool upload [user <passportId> <gamertag>] [package] <titleId> <storageFileName> <fileToUpload>");
				Console.WriteLine("\t - If the [user...] option is specified, the file will be uploaded to that user's storage; otherwise, global-title storage is assumed.");
				Console.WriteLine("\t - The [package] option indicates that the file is a cab file; otherise, the data is assumed to be a blob.");
				Console.WriteLine("\t - <titleId> is the title's hex Id");
				Console.WriteLine("\t - <storageFileName> provides the name of the file as stored on the server");
				Console.WriteLine("\t - <fileToUpload> designates the path and filename of the data to upload");
				Console.WriteLine();
				Console.WriteLine("DOWNLOAD:");
				Console.WriteLine("\tStorageTestTool download [user <passportId> <gamertag>] <titleId> <storageFileName> <locationToDownload>");
				Console.WriteLine("\t - If the [user...] option is specified, the file will be downloaded from that user's storage; otherwise, global-title storage is assumed.");
				Console.WriteLine("\t - <titleId> is the title's hex Id");
				Console.WriteLine("\t - <storageFileName> provides the name of the file as stored on the server");
				Console.WriteLine("\t - <locationToDownload> designates the path and filename of where to store the downloaded data");
				Console.WriteLine();
				Console.WriteLine("ENUMERATE:");
				Console.WriteLine("\tStorageTestTool enum|enumerate <titleId> [<queryString>]");
				Console.WriteLine("\t - <titleId> is the title's hex Id");
				Console.WriteLine("\t - If <queryString> is specified, only information on files whose names match that query will be returned; otherwise, information on all files for that title are returned.");
				Console.WriteLine();
				Console.WriteLine("DELETE:");
				Console.WriteLine("\tStorageTestTool delete [user <passportId> <gamertag>] <titleId> <storageFileName>");
				Console.WriteLine("\t - If the [user...] option is specified, the file will be deleted from that user's storage; otherwise, global-title storage is assumed.");
				Console.WriteLine("\t - <titleId> is the title's hex Id");
				Console.WriteLine("\t - <storageFileName> provides the name of the file as stored on the server");
				Console.WriteLine();
				Console.WriteLine("REVOKE:");
				Console.WriteLine("\tStorageTestTool revoke [user <passportId> <gamertag>] <titleId> <storageFileName>");
				Console.WriteLine("\t - If the [user...] option is specified, the file will be revoked from that user's storage; otherwise, global-title storage is assumed.");
				Console.WriteLine("\t - <titleId> is the title's hex Id");
				Console.WriteLine("\t - <storageFileName> provides the name of the file as stored on the server");
				Console.WriteLine();
				return;
			}
			catch (Exception e)
			{
				// on any other error, print the error and quit
				Console.WriteLine(e.Message);
				return;
			}

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\ClientVersion.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(ClientVersionConverter))]
    public class ClientVersion
	{
        /// <summary>
        /// 
        /// </summary>
        public ClientVersion(): this(2, 5, 8764, 0)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="major"></param>
        /// <param name="minor"></param>
        /// <param name="build"></param>
        /// <param name="qfe"></param>
        public ClientVersion(byte major, byte minor, ushort build, byte qfe)
        {
            this.MajorVersion = major;
            this.MinorVersion = minor;
            this.BuildNumber = build;
            this.QfeNumber = qfe;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Major Version")]
        [Description("The major version to be reported from the Security Gateway.")]
        public byte MajorVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Minor Version")]
        [Description("The minor version to be reported from the Security Gateway.")]
        public byte MinorVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Build Number")]
        [Description("The build number to be reported from the Security Gateway.")]
        public ushort BuildNumber
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("QFE Number")]
        [Description("The QFE number to be reported from the Security Gateway.")]
        public byte QfeNumber
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("0x{0:X}", StsTest.SamlUtil.GetClientVersion(this.MajorVersion, this.MinorVersion, this.BuildNumber, this.QfeNumber));
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\ErrorBox.Designer.cs ===
namespace Microsoft.Live.Test.Common.Forms
{
	partial class ErrorBox
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.errorMessage = new System.Windows.Forms.Label();
			this.ok = new System.Windows.Forms.Button();
			this.showInnerException = new System.Windows.Forms.Button();
			this.innerException = new System.Windows.Forms.TextBox();
			this.errorIcon = new System.Windows.Forms.PictureBox();
			((System.ComponentModel.ISupportInitialize)(this.errorIcon)).BeginInit();
			this.SuspendLayout();
			// 
			// errorMessage
			// 
			this.errorMessage.Location = new System.Drawing.Point(12, 19);
			this.errorMessage.Name = "errorMessage";
			this.errorMessage.Size = new System.Drawing.Size(458, 44);
			this.errorMessage.TabIndex = 0;
			// 
			// ok
			// 
			this.ok.Location = new System.Drawing.Point(152, 82);
			this.ok.Name = "ok";
			this.ok.Size = new System.Drawing.Size(75, 23);
			this.ok.TabIndex = 1;
			this.ok.Text = "&OK";
			this.ok.UseVisualStyleBackColor = true;
			this.ok.Click += new System.EventHandler(this.ok_Click);
			// 
			// showInnerException
			// 
			this.showInnerException.Location = new System.Drawing.Point(240, 82);
			this.showInnerException.Name = "showInnerException";
			this.showInnerException.Size = new System.Drawing.Size(144, 23);
			this.showInnerException.TabIndex = 2;
			this.showInnerException.Text = "&Show Inner Exception";
			this.showInnerException.UseVisualStyleBackColor = true;
			this.showInnerException.Click += new System.EventHandler(this.showInnerException_Click);
			// 
			// innerException
			// 
			this.innerException.Location = new System.Drawing.Point(12, 122);
			this.innerException.Multiline = true;
			this.innerException.Name = "innerException";
			this.innerException.ReadOnly = true;
			this.innerException.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.innerException.Size = new System.Drawing.Size(505, 120);
			this.innerException.TabIndex = 3;
			// 
			// errorIcon
			// 
			this.errorIcon.Location = new System.Drawing.Point(480, 17);
			this.errorIcon.Name = "errorIcon";
			this.errorIcon.Size = new System.Drawing.Size(35, 34);
			this.errorIcon.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.errorIcon.TabIndex = 4;
			this.errorIcon.TabStop = false;
			// 
			// ErrorBox
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(529, 254);
			this.Controls.Add(this.errorIcon);
			this.Controls.Add(this.innerException);
			this.Controls.Add(this.showInnerException);
			this.Controls.Add(this.ok);
			this.Controls.Add(this.errorMessage);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "ErrorBox";
			this.ShowIcon = false;
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			((System.ComponentModel.ISupportInitialize)(this.errorIcon)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.Label errorMessage;
		private System.Windows.Forms.Button ok;
		private System.Windows.Forms.Button showInnerException;
		private System.Windows.Forms.TextBox innerException;
		private System.Windows.Forms.PictureBox errorIcon;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\MachinePuidConverter.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    public class MachinePuidConverter: TypeConverter
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="value"></param>
        /// <param name="attributes"></param>
        /// <returns></returns>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
        {
            return TypeDescriptor.GetProperties(typeof(MachinePuid), attributes).Sort(new string[] { "Value" });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\MachinePuid.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
	[TypeConverter(typeof(MachinePuidConverter))]
    public class MachinePuid
	{
        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Value")]
        [Description("The decimal value of the machine puid to be reported from the Security Gateway.")]
        public ulong Value
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("0x{0:X}", this.Value);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\TitleID.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
	[TypeConverter(typeof(TitleIDConverter))]
    public class TitleID
	{
        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Value")]
        [Description("The decimal value of the title ID to be reported from the Security Gateway.")]
        public uint Value
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        public string ToString(bool prefix)
        {
            if (prefix)
                return String.Format("0x{0:X}", this.Value);
            return this.Value.ToString("X");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace StsGui
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.ThreadException += new System.Threading.ThreadExceptionEventHandler(Application_ThreadException);
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        static void Application_ThreadException(object sender, System.Threading.ThreadExceptionEventArgs e)
        {
            using (Microsoft.Live.Test.Common.Forms.ErrorBox error = new Microsoft.Live.Test.Common.Forms.ErrorBox(e.Exception, "Unexpected exception occurred", "Unexpected exception while running STS GUI."))
            {
                error.ShowDialog();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\MainForm.Designer.cs ===
namespace StsGui
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.menuStrip = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.environmentToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.noneToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.xblobToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.testNetToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.coreNetToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.bvtNetToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.int2ToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.stressNetToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.stressNet2ToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.urlEncodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.formatTokenToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.viewNPDBSettingsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.sTSHealthcheckToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.statusStrip = new System.Windows.Forms.StatusStrip();
            this.toolStripStatusUrl = new System.Windows.Forms.ToolStripStatusLabel();
            this.leftPanel = new System.Windows.Forms.Panel();
            this.propertySplitter = new System.Windows.Forms.Splitter();
            this.requestGrid = new System.Windows.Forms.PropertyGrid();
            this.splitter1 = new System.Windows.Forms.Splitter();
            this.mainPanel = new System.Windows.Forms.Panel();
            this.responseText = new System.Windows.Forms.TextBox();
            this.splitter2 = new System.Windows.Forms.Splitter();
            this.buttonPanel = new System.Windows.Forms.Panel();
            this.sendPanel = new System.Windows.Forms.Panel();
            this.send = new System.Windows.Forms.Button();
            this.requestSplitter = new System.Windows.Forms.Splitter();
            this.requestText = new System.Windows.Forms.TextBox();
            this.contextMenuStripRequest = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.syncRequestToInputsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuStrip.SuspendLayout();
            this.statusStrip.SuspendLayout();
            this.leftPanel.SuspendLayout();
            this.mainPanel.SuspendLayout();
            this.buttonPanel.SuspendLayout();
            this.sendPanel.SuspendLayout();
            this.contextMenuStripRequest.SuspendLayout();
            this.SuspendLayout();
            // 
            // menuStrip
            // 
            this.menuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.optionsToolStripMenuItem,
            this.helpToolStripMenuItem});
            this.menuStrip.Location = new System.Drawing.Point(0, 0);
            this.menuStrip.Name = "menuStrip";
            this.menuStrip.Size = new System.Drawing.Size(841, 24);
            this.menuStrip.TabIndex = 0;
            this.menuStrip.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem
            // 
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.exitToolStripMenuItem});
            this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(35, 20);
            this.fileToolStripMenuItem.Text = "&File";
            // 
            // exitToolStripMenuItem
            // 
            this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
            this.exitToolStripMenuItem.Size = new System.Drawing.Size(92, 22);
            this.exitToolStripMenuItem.Text = "E&xit";
            this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
            // 
            // optionsToolStripMenuItem
            // 
            this.optionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.environmentToolStripMenuItem,
            this.urlEncodeToolStripMenuItem,
            this.formatTokenToolStripMenuItem,
            this.toolStripSeparator1,
            this.viewNPDBSettingsToolStripMenuItem,
            this.sTSHealthcheckToolStripMenuItem});
            this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
            this.optionsToolStripMenuItem.Size = new System.Drawing.Size(56, 20);
            this.optionsToolStripMenuItem.Text = "&Options";
            // 
            // environmentToolStripMenuItem
            // 
            this.environmentToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.noneToolStripMenuItem,
            this.xblobToolStripMenuItem,
            this.testNetToolStripMenuItem,
            this.coreNetToolStripMenuItem,
            this.bvtNetToolStripMenuItem,
            this.int2ToolStripMenuItem,
            this.stressNetToolStripMenuItem,
            this.stressNet2ToolStripMenuItem});
            this.environmentToolStripMenuItem.Name = "environmentToolStripMenuItem";
            this.environmentToolStripMenuItem.Size = new System.Drawing.Size(179, 22);
            this.environmentToolStripMenuItem.Text = "&Environment";
            // 
            // noneToolStripMenuItem
            // 
            this.noneToolStripMenuItem.Checked = true;
            this.noneToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
            this.noneToolStripMenuItem.Name = "noneToolStripMenuItem";
            this.noneToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.noneToolStripMenuItem.Text = "&None";
            this.noneToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // xblobToolStripMenuItem
            // 
            this.xblobToolStripMenuItem.Name = "xblobToolStripMenuItem";
            this.xblobToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.xblobToolStripMenuItem.Text = "&Xblob";
            this.xblobToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // testNetToolStripMenuItem
            // 
            this.testNetToolStripMenuItem.Name = "testNetToolStripMenuItem";
            this.testNetToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.testNetToolStripMenuItem.Text = "&TestNet";
            this.testNetToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // coreNetToolStripMenuItem
            // 
            this.coreNetToolStripMenuItem.Name = "coreNetToolStripMenuItem";
            this.coreNetToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.coreNetToolStripMenuItem.Text = "&CoreNet";
            this.coreNetToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // bvtNetToolStripMenuItem
            // 
            this.bvtNetToolStripMenuItem.Name = "bvtNetToolStripMenuItem";
            this.bvtNetToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.bvtNetToolStripMenuItem.Text = "&BvtNet";
            this.bvtNetToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // int2ToolStripMenuItem
            // 
            this.int2ToolStripMenuItem.Name = "int2ToolStripMenuItem";
            this.int2ToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.int2ToolStripMenuItem.Text = "&Int2";
            this.int2ToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // stressNetToolStripMenuItem
            // 
            this.stressNetToolStripMenuItem.Name = "stressNetToolStripMenuItem";
            this.stressNetToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.stressNetToolStripMenuItem.Text = "&StressNet";
            this.stressNetToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // stressNet2ToolStripMenuItem
            // 
            this.stressNet2ToolStripMenuItem.Name = "stressNet2ToolStripMenuItem";
            this.stressNet2ToolStripMenuItem.Size = new System.Drawing.Size(127, 22);
            this.stressNet2ToolStripMenuItem.Text = "S&tressNet2";
            this.stressNet2ToolStripMenuItem.Click += new System.EventHandler(this.Environment_Clicked);
            // 
            // urlEncodeToolStripMenuItem
            // 
            this.urlEncodeToolStripMenuItem.Checked = true;
            this.urlEncodeToolStripMenuItem.CheckOnClick = true;
            this.urlEncodeToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
            this.urlEncodeToolStripMenuItem.Name = "urlEncodeToolStripMenuItem";
            this.urlEncodeToolStripMenuItem.Size = new System.Drawing.Size(179, 22);
            this.urlEncodeToolStripMenuItem.Text = "&Url Encode";
            this.urlEncodeToolStripMenuItem.Click += new System.EventHandler(this.urlEncodeToolStripMenuItem_Click);
            // 
            // formatTokenToolStripMenuItem
            // 
            this.formatTokenToolStripMenuItem.Checked = true;
            this.formatTokenToolStripMenuItem.CheckOnClick = true;
            this.formatTokenToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
            this.formatTokenToolStripMenuItem.Name = "formatTokenToolStripMenuItem";
            this.formatTokenToolStripMenuItem.Size = new System.Drawing.Size(179, 22);
            this.formatTokenToolStripMenuItem.Text = "&Format Token";
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(176, 6);
            // 
            // viewNPDBSettingsToolStripMenuItem
            // 
            this.viewNPDBSettingsToolStripMenuItem.Enabled = false;
            this.viewNPDBSettingsToolStripMenuItem.Name = "viewNPDBSettingsToolStripMenuItem";
            this.viewNPDBSettingsToolStripMenuItem.Size = new System.Drawing.Size(179, 22);
            this.viewNPDBSettingsToolStripMenuItem.Text = "&View NPDB Settings...";
            this.viewNPDBSettingsToolStripMenuItem.Click += new System.EventHandler(this.viewNPDBSettingsToolStripMenuItem_Click);
            // 
            // sTSHealthcheckToolStripMenuItem
            // 
            this.sTSHealthcheckToolStripMenuItem.Enabled = false;
            this.sTSHealthcheckToolStripMenuItem.Name = "sTSHealthcheckToolStripMenuItem";
            this.sTSHealthcheckToolStripMenuItem.Size = new System.Drawing.Size(179, 22);
            this.sTSHealthcheckToolStripMenuItem.Text = "STS Healthcheck...";
            this.sTSHealthcheckToolStripMenuItem.Click += new System.EventHandler(this.sTSHealthcheckToolStripMenuItem_Click);
            // 
            // helpToolStripMenuItem
            // 
            this.helpToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.aboutToolStripMenuItem});
            this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
            this.helpToolStripMenuItem.Size = new System.Drawing.Size(40, 20);
            this.helpToolStripMenuItem.Text = "&Help";
            // 
            // aboutToolStripMenuItem
            // 
            this.aboutToolStripMenuItem.Name = "aboutToolStripMenuItem";
            this.aboutToolStripMenuItem.Size = new System.Drawing.Size(157, 22);
            this.aboutToolStripMenuItem.Text = "&About STS GUI...";
            this.aboutToolStripMenuItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);
            // 
            // statusStrip
            // 
            this.statusStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripStatusUrl});
            this.statusStrip.Location = new System.Drawing.Point(0, 485);
            this.statusStrip.Name = "statusStrip";
            this.statusStrip.Size = new System.Drawing.Size(841, 22);
            this.statusStrip.TabIndex = 1;
            this.statusStrip.Text = "statusStrip1";
            // 
            // toolStripStatusUrl
            // 
            this.toolStripStatusUrl.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Text;
            this.toolStripStatusUrl.IsLink = true;
            this.toolStripStatusUrl.Name = "toolStripStatusUrl";
            this.toolStripStatusUrl.Size = new System.Drawing.Size(826, 17);
            this.toolStripStatusUrl.Spring = true;
            this.toolStripStatusUrl.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // leftPanel
            // 
            this.leftPanel.Controls.Add(this.propertySplitter);
            this.leftPanel.Controls.Add(this.requestGrid);
            this.leftPanel.Dock = System.Windows.Forms.DockStyle.Left;
            this.leftPanel.Location = new System.Drawing.Point(0, 24);
            this.leftPanel.Name = "leftPanel";
            this.leftPanel.Size = new System.Drawing.Size(243, 461);
            this.leftPanel.TabIndex = 2;
            // 
            // propertySplitter
            // 
            this.propertySplitter.Dock = System.Windows.Forms.DockStyle.Top;
            this.propertySplitter.Location = new System.Drawing.Point(0, 0);
            this.propertySplitter.Name = "propertySplitter";
            this.propertySplitter.Size = new System.Drawing.Size(243, 3);
            this.propertySplitter.TabIndex = 1;
            this.propertySplitter.TabStop = false;
            // 
            // requestGrid
            // 
            this.requestGrid.Dock = System.Windows.Forms.DockStyle.Fill;
            this.requestGrid.Location = new System.Drawing.Point(0, 0);
            this.requestGrid.Name = "requestGrid";
            this.requestGrid.Size = new System.Drawing.Size(243, 461);
            this.requestGrid.TabIndex = 0;
            this.requestGrid.PropertyValueChanged += new System.Windows.Forms.PropertyValueChangedEventHandler(this.requestGrid_PropertyValueChanged);
            // 
            // splitter1
            // 
            this.splitter1.Location = new System.Drawing.Point(243, 24);
            this.splitter1.Name = "splitter1";
            this.splitter1.Size = new System.Drawing.Size(3, 461);
            this.splitter1.TabIndex = 3;
            this.splitter1.TabStop = false;
            // 
            // mainPanel
            // 
            this.mainPanel.Controls.Add(this.responseText);
            this.mainPanel.Controls.Add(this.splitter2);
            this.mainPanel.Controls.Add(this.buttonPanel);
            this.mainPanel.Controls.Add(this.requestSplitter);
            this.mainPanel.Controls.Add(this.requestText);
            this.mainPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.mainPanel.Location = new System.Drawing.Point(246, 24);
            this.mainPanel.Name = "mainPanel";
            this.mainPanel.Size = new System.Drawing.Size(595, 461);
            this.mainPanel.TabIndex = 4;
            // 
            // responseText
            // 
            this.responseText.AcceptsReturn = true;
            this.responseText.AcceptsTab = true;
            this.responseText.Dock = System.Windows.Forms.DockStyle.Fill;
            this.responseText.Location = new System.Drawing.Point(0, 60);
            this.responseText.Multiline = true;
            this.responseText.Name = "responseText";
            this.responseText.ReadOnly = true;
            this.responseText.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.responseText.Size = new System.Drawing.Size(595, 337);
            this.responseText.TabIndex = 7;
            this.responseText.WordWrap = false;
            this.responseText.KeyDown += new System.Windows.Forms.KeyEventHandler(this.textBox_KeyDown);
            // 
            // splitter2
            // 
            this.splitter2.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.splitter2.Location = new System.Drawing.Point(0, 397);
            this.splitter2.Name = "splitter2";
            this.splitter2.Size = new System.Drawing.Size(595, 3);
            this.splitter2.TabIndex = 6;
            this.splitter2.TabStop = false;
            // 
            // buttonPanel
            // 
            this.buttonPanel.Controls.Add(this.sendPanel);
            this.buttonPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.buttonPanel.Location = new System.Drawing.Point(0, 400);
            this.buttonPanel.Name = "buttonPanel";
            this.buttonPanel.Size = new System.Drawing.Size(595, 61);
            this.buttonPanel.TabIndex = 5;
            // 
            // sendPanel
            // 
            this.sendPanel.Controls.Add(this.send);
            this.sendPanel.Dock = System.Windows.Forms.DockStyle.Right;
            this.sendPanel.Location = new System.Drawing.Point(323, 0);
            this.sendPanel.Name = "sendPanel";
            this.sendPanel.Size = new System.Drawing.Size(272, 61);
            this.sendPanel.TabIndex = 0;
            // 
            // send
            // 
            this.send.Location = new System.Drawing.Point(173, 19);
            this.send.Name = "send";
            this.send.Size = new System.Drawing.Size(74, 23);
            this.send.TabIndex = 7;
            this.send.Text = "&Send";
            this.send.UseVisualStyleBackColor = true;
            this.send.Click += new System.EventHandler(this.send_Click);
            // 
            // requestSplitter
            // 
            this.requestSplitter.Dock = System.Windows.Forms.DockStyle.Top;
            this.requestSplitter.Location = new System.Drawing.Point(0, 57);
            this.requestSplitter.Name = "requestSplitter";
            this.requestSplitter.Size = new System.Drawing.Size(595, 3);
            this.requestSplitter.TabIndex = 1;
            this.requestSplitter.TabStop = false;
            // 
            // requestText
            // 
            this.requestText.ContextMenuStrip = this.contextMenuStripRequest;
            this.requestText.Dock = System.Windows.Forms.DockStyle.Top;
            this.requestText.Location = new System.Drawing.Point(0, 0);
            this.requestText.Multiline = true;
            this.requestText.Name = "requestText";
            this.requestText.Size = new System.Drawing.Size(595, 57);
            this.requestText.TabIndex = 0;
            this.requestText.KeyDown += new System.Windows.Forms.KeyEventHandler(this.textBox_KeyDown);
            // 
            // contextMenuStripRequest
            // 
            this.contextMenuStripRequest.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.syncRequestToInputsToolStripMenuItem});
            this.contextMenuStripRequest.Name = "contextMenuStripRequest";
            this.contextMenuStripRequest.Size = new System.Drawing.Size(183, 26);
            // 
            // syncRequestToInputsToolStripMenuItem
            // 
            this.syncRequestToInputsToolStripMenuItem.Name = "syncRequestToInputsToolStripMenuItem";
            this.syncRequestToInputsToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
            this.syncRequestToInputsToolStripMenuItem.Text = "&Sync request to inputs";
            this.syncRequestToInputsToolStripMenuItem.Click += new System.EventHandler(this.syncRequestToInputsToolStripMenuItem_Click);
            // 
            // MainForm
            // 
            this.AcceptButton = this.send;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(841, 507);
            this.Controls.Add(this.mainPanel);
            this.Controls.Add(this.splitter1);
            this.Controls.Add(this.leftPanel);
            this.Controls.Add(this.statusStrip);
            this.Controls.Add(this.menuStrip);
            this.MainMenuStrip = this.menuStrip;
            this.MaximizeBox = false;
            this.Name = "MainForm";
            this.Text = "STS GUI";
            this.Shown += new System.EventHandler(this.MainForm_Shown);
            this.menuStrip.ResumeLayout(false);
            this.menuStrip.PerformLayout();
            this.statusStrip.ResumeLayout(false);
            this.statusStrip.PerformLayout();
            this.leftPanel.ResumeLayout(false);
            this.mainPanel.ResumeLayout(false);
            this.mainPanel.PerformLayout();
            this.buttonPanel.ResumeLayout(false);
            this.sendPanel.ResumeLayout(false);
            this.contextMenuStripRequest.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.MenuStrip menuStrip;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem optionsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
        private System.Windows.Forms.StatusStrip statusStrip;
        private System.Windows.Forms.Panel leftPanel;
        private System.Windows.Forms.Splitter splitter1;
        private System.Windows.Forms.Panel mainPanel;
        private System.Windows.Forms.Splitter requestSplitter;
        private System.Windows.Forms.TextBox requestText;
        private System.Windows.Forms.Splitter propertySplitter;
        private System.Windows.Forms.PropertyGrid requestGrid;
        private System.Windows.Forms.ToolStripMenuItem environmentToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem urlEncodeToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;
        private System.Windows.Forms.Panel buttonPanel;
        private System.Windows.Forms.Panel sendPanel;
        private System.Windows.Forms.Button send;
        private System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem xblobToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem testNetToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem stressNetToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem formatTokenToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem coreNetToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem bvtNetToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem int2ToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem stressNet2ToolStripMenuItem;
        private System.Windows.Forms.ToolStripStatusLabel toolStripStatusUrl;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private System.Windows.Forms.ToolStripMenuItem viewNPDBSettingsToolStripMenuItem;
        private System.Windows.Forms.TextBox responseText;
        private System.Windows.Forms.Splitter splitter2;
        private System.Windows.Forms.ContextMenuStrip contextMenuStripRequest;
        private System.Windows.Forms.ToolStripMenuItem syncRequestToInputsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem sTSHealthcheckToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem noneToolStripMenuItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\MainForm.cs ===
using System;
using System.Windows.Forms;
using System.Xml;
using System.IO;
using System.Net;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using StsTest;
using Microsoft.Live.Test.Common.Forms;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    public partial class MainForm : Form
    {
        private RequestValues request;
        private static bool initializedFakeSG = false;

        /// <summary>
        /// 
        /// </summary>
        public MainForm()
        {
            InitializeComponent();
            
            //STF common infrastructure needs to be in place for ANYTHING to work
            InitializeGlobal();
        }

        /// <summary>
        /// 
        /// </summary>
        private static void InitializeGlobal()
        {
            FileInfo runningAssembly = new FileInfo(new Uri(System.Reflection.Assembly.GetExecutingAssembly().CodeBase).LocalPath);
            string configFilePath = Path.Combine(runningAssembly.DirectoryName, "stf.xml");

            if (!System.IO.File.Exists(configFilePath))
                throw new ApplicationException(String.Format("Unable to find required config file '{0}'.", configFilePath));

            XmlDocument configXml = new XmlDocument();
            configXml.Load(configFilePath);
            Global.Initialize(configXml);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private EnvironmentSetting GetCurrentEnvironment()
        {
            string currentEnv = null;
            for (int i = 0; i < this.environmentToolStripMenuItem.DropDownItems.Count; i++)
            {
                if ((this.environmentToolStripMenuItem.DropDownItems[i] as ToolStripMenuItem).Checked)
                {
                    currentEnv = this.environmentToolStripMenuItem.DropDownItems[i].Text.Replace("&", "");
                    break;
                }
            }
            if (currentEnv == null)
                throw new ApplicationException("No environment selected!");

            EnvironmentSetting envSetting = Global.EnvironmentList.Find(env => currentEnv.Equals(env.Environment, StringComparison.OrdinalIgnoreCase));
            if (envSetting == null)
                throw new ApplicationException(String.Format("Unable to find a valid configuration for '{0}' environment!", currentEnv));
            return envSetting;
        }

        /// <summary>
        /// 
        /// </summary>
        private void SetCurrentEnvironment()
        {
            //reset the environment and corresponding url
            Global.ResetEnvironment();
            Global.CurrentEnvironment = GetCurrentEnvironment();
            this.toolStripStatusUrl.Text = String.Empty;

            if (!this.noneToolStripMenuItem.Checked)
            {
                GenerateRequestAsync();
                initializedFakeSG = false;

                Thread worker = new Thread(new ThreadStart(InitializeFakeSGServiceAsync));
                worker.Start();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Environment_Clicked(object sender, EventArgs e)
        {
            ToolStripMenuItem item = sender as ToolStripMenuItem;
            string name = item.Text.Replace("&", "");
            if (Global.CurrentEnvironment != null && name.Equals(Global.CurrentEnvironment.Environment, StringComparison.OrdinalIgnoreCase))
                return;

            item.Checked = true;
            for (int i = 0; i < this.environmentToolStripMenuItem.DropDownItems.Count; i++)
            {
                ToolStripMenuItem envItem = this.environmentToolStripMenuItem.DropDownItems[i] as ToolStripMenuItem;
                if (envItem != item)
                    envItem.Checked = false;
            }

            this.viewNPDBSettingsToolStripMenuItem.Enabled = this.sTSHealthcheckToolStripMenuItem.Enabled = !name.Equals("None", StringComparison.OrdinalIgnoreCase);
            SetCurrentEnvironment();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void send_Click(object sender, EventArgs e)
        {
            //clear old output
            this.responseText.Clear();
            Application.DoEvents();
            System.Threading.Thread.Sleep(100);
            
            using(WaitCursor wait = new WaitCursor())
            {
                //generate a fake SG slot
                CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
                slot.machinePuid = request.SG_MachinePuid.Value;
                slot.titleId = request.SG_TitleID.Value;
                slot.titleVersion = request.SG_TitleVersion.Value;

                slot.wMajorVersion = request.SG_ClientVersion.MajorVersion;
                slot.wMinorVersion = request.SG_ClientVersion.MinorVersion;
                slot.wBuildNumber = request.SG_ClientVersion.BuildNumber;
                slot.wQFENumber = request.SG_ClientVersion.QfeNumber;

                slot.userPuid0 = request.SG_Xuid1.Value;
                slot.userFlag0 = CalculateUserFlags(slot.userFlag0, request.SG_Xuid1.Country, request.SG_Xuid1.Tier);
                slot.userPuid1 = request.SG_Xuid2.Value;
                slot.userFlag1 = CalculateUserFlags(slot.userFlag1, request.SG_Xuid2.Country, request.SG_Xuid2.Tier);
                slot.userPuid2 = request.SG_Xuid3.Value;
                slot.userFlag2 = CalculateUserFlags(slot.userFlag2, request.SG_Xuid3.Country, request.SG_Xuid3.Tier);
                slot.userPuid3 = request.SG_Xuid4.Value;
                slot.userFlag3 = CalculateUserFlags(slot.userFlag3, request.SG_Xuid4.Country, request.SG_Xuid4.Tier);

                if (!InitializeFakeSGService())
                    return;

                StsResponse response = null;
                try
                {
                    response = StsXrlRequest.GetSecurityToken(ref slot, this.requestText.Text);
                }
                catch (Exception ex)
                {
                    ShowErrorMessage("Error sending request", "Unexpected error while sending request to the STS server.", ex);
                    this.responseText.Text = ex.ToString();
                    return;
                }

                if (response.Succeeded)
                {
                    if (String.IsNullOrEmpty(response.Token))
                        this.responseText.Text = "No token returned, but HR=0!";
                    else if (this.formatTokenToolStripMenuItem.Checked)
                    {
                        Microsoft.Live.Test.Common.XmlDocumentEx tokenXml = new Microsoft.Live.Test.Common.XmlDocumentEx(response.Token, true);
                        this.responseText.Text = tokenXml.FormatXml(2, ' ', '"');
                    }
                    else
                        this.responseText.Text = response.Token;
                }
                else
                    this.responseText.Text = String.Format("Error returned from STS service; HR=0x{0}, {1}", response.HResult.ToString("X"), StsXrlRequest.MapHResultToString(response.HResult));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private void InitializeFakeSGServiceAsync()
        {
            if (this.InvokeRequired)
            {               
                this.Invoke(new MethodInvoker(InitializeFakeSGServiceAsync));
            }
            else
            {
                InitializeFakeSGService();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private bool InitializeFakeSGService()
        {
            if (!initializedFakeSG)
            {
                WaitCursor cursor = null;

                try
                {
                    cursor = new WaitCursor();
                    if (!GlobalFakeSG.FakeSG.ConnectToService())
                    {
                        cursor.Dispose();
                        cursor = null;
                        ShowErrorMessage("FakeSG Error", "Unable to install, start or connect to FakeSG service.\r\nThis service is required to send requests to the STS service.");
                        return false;
                    }

                    IPEndPoint ip = Global.XEnv.GetVirtualInterface(xonline.common.config.Interface.sts);
                    GlobalFakeSG.FakeSG.SetStateEndpoint(ip.ToString());
                    this.toolStripStatusUrl.Text = String.Format("http://{0}/sts/getsecuritytoken.ashx?", ip.ToString());
                    initializedFakeSG = true;
                }
                finally
                {
                    if (cursor != null)
                        cursor.Dispose();
                }
            }
            return true;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="flags"></param>
        /// <param name="country"></param>
        /// <param name="tier"></param>
        /// <returns></returns>
        private static uint CalculateUserFlags(uint flags, byte country, byte tier)
        {
            flags = StsRequest.SetUserCountryFlag(flags, country);
            flags = StsRequest.SetUserTierFlag(flags, tier);
            return flags;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="s"></param>
        /// <param name="e"></param>
        private void requestGrid_PropertyValueChanged(object s, PropertyValueChangedEventArgs e)
        {
            if (e.ChangedItem.Parent.Label.Equals("Request Parameters", StringComparison.OrdinalIgnoreCase))
                GenerateRequestAsync();
        }

        /// <summary>
        /// 
        /// </summary>
        private void GenerateRequestAsync()
        {
            Thread worker = new Thread(new ThreadStart(GenerateRequest));
            worker.Start();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private void GenerateRequest()
        {
            if (this.requestText.InvokeRequired)
            {
                this.requestText.BeginInvoke(new MethodInvoker(GenerateRequest));
            }
            else
            {
                StsRequest request = new StsRequest(this.request.Audience, this.request.TitleID, this.request.Xuid1, this.request.Xuid2, this.request.Xuid3, this.request.Xuid4);
                this.requestText.Text = request.ToRequestUrl(this.urlEncodeToolStripMenuItem.Checked);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void urlEncodeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            GenerateRequestAsync();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void exitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.Close();
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="caption"></param>
        /// <param name="message"></param>
        private void ShowErrorMessage(string caption, string message)
        {
            MessageBox.Show(this, message, caption, MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="caption"></param>
        /// <param name="message"></param>
        private void ShowErrorMessage(string caption, string message, Exception e)
        {
            ErrorBox error = new ErrorBox(e, caption, message);
            error.ShowDialog(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)
        {
            MessageBox.Show(this, "STS GUI\r\nApp for calling the front door Security Token Service\r\n\r\nAuthor: P.J. Little (peterl)", "About STS GUI...", MessageBoxButtons.OK, MessageBoxIcon.Information); 
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void MainForm_Shown(object sender, EventArgs e)
        {
            //show property grid data
            this.request = new RequestValues();
            this.requestGrid.SelectedObject = this.request;

            if (!this.noneToolStripMenuItem.Checked)
            {
                //generate a default, baseline request
                GenerateRequestAsync();

                //show the real endpoint that we're hitting...
                IPEndPoint ip = Global.XEnv.GetVirtualInterface(xonline.common.config.Interface.sts);
                this.toolStripStatusUrl.Text = String.Format("http://{0}/sts/getsecuritytoken.ashx", ip.ToString());
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void viewNPDBSettingsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            try
            {
                string settings = String.Format("STS NPDB Settings:\r\n\r\n{0}:\t{1}\r\n{2}:\t{3}\r\n{4}:\t\t{5}",
                    xonline.common.config.Setting.sts_token_window_minutes,
                    NpdbSettingsUtil.TimeWindow,
                    xonline.common.config.Setting.sts_token_issuer_name,
                    NpdbSettingsUtil.IssuerName,
                    xonline.common.config.Setting.sts_cert_subject,
                    NpdbSettingsUtil.CertSubject
                    );

                MessageBox.Show(this, settings, "STS NPDB Settings...", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                ShowErrorMessage("NPDB Error", "Error querying STS settings from NPDB.", ex);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void syncRequestToInputsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            GenerateRequestAsync();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void sTSHealthcheckToolStripMenuItem_Click(object sender, EventArgs e)
        {
            try
            {
                //use the internal interface for health checks
                IPEndPoint ip = Global.XEnv.GetVirtualInterface(xonline.common.config.Interface.sts_int);
                string healthCheckUrl = String.Format("http://{0}/sts/health.ashx", ip.ToString());
                Process.Start("iexplore", healthCheckUrl);
            }
            catch (Exception ex)
            {
                ShowErrorMessage("Error launching STS Healthcheck", "Error lauching IE to view STS Healthcheck.", ex);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void textBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Control && e.KeyCode == Keys.A)
            {
                ((TextBox)sender).SelectAll();
                e.Handled = true;                
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\TitleVersion.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
	[TypeConverter(typeof(TitleVersionConverter))]
    public class TitleVersion
	{
        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Value")]
        [Description("The decimal value of the title version to be reported from the Security Gateway.")]
        public uint Value
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("0x{0:X}", this.Value);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\TitleIDConverter.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    public class TitleIDConverter: TypeConverter
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="value"></param>
        /// <param name="attributes"></param>
        /// <returns></returns>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
        {
            return TypeDescriptor.GetProperties(typeof(TitleID), attributes).Sort(new string[] { "Value" });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\RequestValues.cs ===
using System;
using System.ComponentModel;
using StsTest;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    public class RequestValues
    {
        /// <summary>
        /// 
        /// </summary>
        public RequestValues()
        {
            this.SG_MachinePuid = new MachinePuid() { Value=StsRequest.GenerateRandomMachinePuid(xonline.common.service.XOn.XPLT_XBOX360) };
            this.SG_TitleID = new TitleID() { Value=(uint)XboxTitle.Xbox360Dash };
            this.SG_TitleVersion = new TitleVersion() { Value = StsRequest.GenerateRandomUInt32() };
            this.SG_ClientVersion = new ClientVersion(); 
            this.SG_Xuid1 = new Xuid();
            this.SG_Xuid2 = new Xuid();
            this.SG_Xuid3 = new Xuid();
            this.SG_Xuid4 = new Xuid();
            
            this.Audience = "http://liveconnect.xboxlive.com";
            this.TitleID = StsRequest.GetUInt32Value(this.SG_TitleID.Value);
            this.Xuid1 = this.SG_Xuid1.ToString(false);
            this.Xuid2 = this.SG_Xuid2.ToString(false);
            this.Xuid3 = this.SG_Xuid3.ToString(false);
            this.Xuid4 = this.SG_Xuid4.ToString(false);
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("Request Parameters")]
        [Description("The Audience string to be included in the STS request.")]
        public string Audience
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("Request Parameters")]
        [DisplayName("Title ID")]
        [Description("The Title ID string to be included in the STS request.")]
        public string TitleID
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("Request Parameters")]
        [Description("The Xuid1 string to be included in the STS request.")]
        public string Xuid1
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("Request Parameters")]
        [Description("The Xuid2 string to be included in the STS request.")]
        public string Xuid2
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("Request Parameters")]
        [Description("The Xuid3 string to be included in the STS request.")]
        public string Xuid3
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("Request Parameters")]
        [Description("The Xuid4 string to be included in the STS request.")]
        public string Xuid4
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Title ID")]
        [Description("The Title ID to be reported from the Security Gateway.")]
        public TitleID SG_TitleID
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Title Version")]
        [Description("The Title Version to be reported from the Security Gateway.")]
        public TitleVersion SG_TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Xuid1")]
        [Description("The Xuid1 to be reported from the Security Gateway.")]
        public Xuid SG_Xuid1
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Xuid2")]
        [Description("The Xuid2 to be reported from the Security Gateway.")]
        public Xuid SG_Xuid2
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Xuid3")]
        [Description("The Xuid3 to be reported from the Security Gateway.")]
        public Xuid SG_Xuid3
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Xuid4")]
        [Description("The Xuid4 to be reported from the Security Gateway.")]
        public Xuid SG_Xuid4
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Machine Puid")]
        [Description("The Machine Puid to be reported from the Security Gateway.")]
        public MachinePuid SG_MachinePuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [Category("SG Info")]
        [DisplayName("Client Version")]
        [Description("The Client Version to be reported from the Security Gateway.")]
        public ClientVersion SG_ClientVersion
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\TitleVersionConverter.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    public class TitleVersionConverter: TypeConverter
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <param name="value"></param>
        /// <param name="attributes"></param>
        /// <returns></returns>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
        {
            return TypeDescriptor.GetProperties(typeof(TitleVersion), attributes).Sort(new string[] { "Value" });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\Xuid.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
    [TypeConverter(typeof(XuidConverter))]
    public class Xuid
    {
        /// <summary>
        /// 
        /// </summary>
        public Xuid(): this(StsTest.Xuid.GenerateRandomUInt64(), 103, 6)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="value"></param>
        /// <param name="country"></param>
        /// <param name="tier"></param>
        public Xuid(ulong value, byte country, byte tier)
        {
            this.Value = value;
            this.Country = country;
            this.Tier = tier;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Xuid")]
        [Description("The value of the xuid.")]
        public ulong Value
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Country")]
        [Description("The ID that represents the country code of the xuid.")]
        public byte Country
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        [DisplayName("Tier")]
        [Description("The current subscription level of the xuid.")]
        public byte Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        public string ToString(bool prefix)
        {
            if(prefix)
                return String.Format("0x{0:X}", this.Value);
            return this.Value.ToString("X");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\XuidConverter.cs ===
using System;
using System.ComponentModel;

namespace StsGui
{
    public class XuidConverter: TypeConverter
    {
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
        {
            return TypeDescriptor.GetProperties(typeof(Xuid), attributes).Sort(new string[] { "Country", "Tier", "Value" });
        }

        public override bool GetPropertiesSupported(ITypeDescriptorContext context)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\StsGui\WaitCursor.cs ===
using System;
using System.Windows.Forms;

namespace StsGui
{
    /// <summary>
    /// 
    /// </summary>
	public class WaitCursor: IDisposable
	{
        private bool disposed = false;

        /// <summary>
        /// 
        /// </summary>
        public WaitCursor()
        {
            this.Enabled = true;
        }

        /// <summary>
        /// 
        /// </summary>
        public bool Enabled
        {
            get
            {
                return Application.UseWaitCursor;
            }
            set
            {
                if (Application.UseWaitCursor != value)
                {
                    Application.UseWaitCursor = value;
                    Form active = Form.ActiveForm;
                    if (active != null && (active.Handle != null && active.Handle != IntPtr.Zero))
                        SendMessage(active.Handle, 0x20, active.Handle, (IntPtr)1); //send WM_SETCURSOR
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="disposing"></param>
        protected void Dispose(bool disposing)
        {
            if (!this.disposed)
            {
                if (disposing)
                {
                    this.Enabled = false;
                }

                this.disposed = true;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hWnd"></param>
        /// <param name="msg"></param>
        /// <param name="wp"></param>
        /// <param name="lp"></param>
        /// <returns></returns>
        [System.Runtime.InteropServices.DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wp, IntPtr lp);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\GlobalEnum.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace SubscriptionTestTool
{
    public enum UserType : uint
    {
        SilverUser,
        GoldUser,
        ArgoUser
    }

    public enum QueryType : uint
    {
        QueryForNew         = 0x00000001,
        QueryForCurrent     = 0x00000002,
        //QueryForSuspended   = 0x00000004, 
        //QueryForExpired     = 0x00000008,
        //QueryForCancelled   = 0x00000010,
        QueryForConvert     = 0x00000020,
        //QueryForTrials      = 0x00000040
    }

    public enum OfferType : ulong
    {
        // Xenon offers
        // Fixed offers
        XeFree = 0xFFFE07D180000011,
        XeMigration = 0xFFFE07D180000001,
        XeThreeYearCC = 0xFFFE07D18000000D,
        XeTwoYearCC = 0xFFFE07D18000000C,
        XeYearlyCC = 0xFFFE07D18000000A,
        XeThreeMonthCC = 0xFFFE07D180000009,
        XeMonthlyCC = 0xFFFE07D180000008,
        XeOneMonthTrial = 0xFFFE07D180000003,
        XeOneMonthPrepaid = 0xFFFE07D180000018,
        XeThreeMonthPrepaid = 0xFFFE07D180000019,
        XeTwelveMonthPrepaid = 0xFFFE07D18000001A,
        XeThirteenMonthPrepaid = 0xFFFE07D18000001B,
        XeTwentyFourMonthPrepaid = 0xFFFE07D18000001C,
        XeThirtySixMonthPrepaid = 0XFFFE07D18000001D,

        //Game Subscriptions
        GameSubMonthlyCC = 0xFFFF009588000000,
        GameSubQuarterlyCC = 0xFFFF009588000001,
        GameSubYearlyCC = 0xFFFF009588000002,
        GameSub1moPrepaid = 0xFFFF009588000010,
        GameSub3moPrepaid = 0xFFFF009588000011,
        GameSub12moPrepaid = 0xFFFF009588000012,
        GameSubMinPrepaid = OfferType.GameSub1moPrepaid,
        GameSubMaxPrepaid = OfferType.GameSub12moPrepaid,
        GameSubPrepaid = OfferType.GameSub1moPrepaid,

        //Argo Subscriptions
        ArgoSub14DayTrial = 0xFFFE07778800001A,
        ArgoSubMonthlyCC = 0xFFFE077788000000,
        ArgoSubQuarterlyCC = 0xFFFE077788000001,
        ArgoSubYearlyCC = 0xFFFE077788000002,
        ArgoSub1moPrepaid = 0xFFFE077788000010,
        ArgoSub3moPrepaid = 0xFFFE077788000011,
        ArgoSub12moPrepaid = 0xFFFE077788000012,
        ArgoSubMinPrepaid = OfferType.ArgoSub1moPrepaid,
        ArgoSubMaxPrepaid = OfferType.ArgoSub12moPrepaid,
        ArgoSubPrepaid = OfferType.ArgoSub1moPrepaid,
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Form1.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Reflection;
using System.Text;
using System.Windows.Forms;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Runner;

namespace SubscriptionTestTool
{
    public partial class Form1 : Form
    {
        #region privateattributes
                        
        private const int ACCOUNTTYPES = 3;
        private UserType UserAccountType;
        private XeUser.Country UserCountry = XeUser.Country.US;
        private LiveUser OurUser;
        private static string prevGamerTag = null;
        private SubscriptionForm SubForm;
        #endregion

        #region publicattributes
        public static uint[] UserTypes;
        #endregion

        public Form1()
        {
            BuildTypeArrays();
            InitializeComponent();
            ToolTip forButtons = new ToolTip();
            forButtons.SetToolTip(this.subscriptionButton, "Manipulate User's subscriptions");
            forButtons.SetToolTip(this.createUserButton, "Create New Live User");
            forButtons.SetToolTip(this.retrieveButton, "Retrieve existing user");
            forButtons.SetToolTip(this.getSubButton, "Retrieve details of current user's Live subscription");
            forButtons.AutomaticDelay = 1000;
            PopulateBoxes();

            // make the client timeout 130 seconds
            FDTransaction.sReceiveTimeOut = FDTransaction.BillingReceiveTimeout;

            // Use stf.xml. Only use LiveLib.xml for client type
            live.common.Config.SetConfig(new live.common.STFConfig());
        }

        #region private methods

        private void BuildTypeArrays()
        {
            //populate an array for usertype
            FieldInfo[] fInfo = typeof(UserType).GetFields();
            UserType ut = new UserType();
            UserTypes = new uint[ACCOUNTTYPES];
            for (int i = 1; i <= ACCOUNTTYPES; i++)
            {
                UserTypes[i - 1] = (uint)fInfo[i].GetValue(ut);
            }
        }

        private void PopulateBoxes()
        {
            int i;
            int idx;            
            //Populate UserType drop down box
            foreach (UserType ut in UserTypes)
            {
                this.UATComboBox.Items.Add(ut);
            }

            ////default value               
            idx = this.UATComboBox.FindStringExact(UserType.GoldUser.ToString());
            this.UATComboBox.SelectedIndex = idx;

            // Populate the NPDB drop down box
            if (Global.EnvironmentList != null)
            {
                for (i = 0; i < Global.EnvironmentList.Count; i++)
                {
                    this.cbNpdbSetting.Items.Add(Global.EnvironmentList[i].Environment + "," + 
                        Global.EnvironmentList[i].NpdbIp + "," + Global.EnvironmentList[i].NpdbName + "," + 
                        Global.EnvironmentList[i].WebstoreSiteOverride);
                }
            }
            
            // country drop down list
            foreach (string country in Enum.GetNames(typeof(XeUser.Country)))
            {
                this.comboBoxCountry.Items.Add(country);
                this.comboBoxCountry.SelectedItem = XeUser.Country.US.ToString();
            }

            //// Find item in combo box
            //idx = cbNpdbSetting.FindStringExact(npdbsetting);
            //if (idx >= 0)
            //{
            //    cbNpdbSetting.SelectedIndex = idx;             
            //}
            //else
            //{
            //    // Saved item not found in combobox, toss it away and use first item as default
            //    if (cbNpdbSetting.Items.Count > 0)
            //    {
            //        cbNpdbSetting.SelectedIndex = 0;
            //        //Global.DefaultNpdbSetting = new NpdbSetting((string)cbNpdbSetting.Items[0]);
            //    }
            //}            
        }

        private void createUserButton_Click(object sender, EventArgs e)
        {
            if (this.cbNpdbSetting.SelectedItem == null)
            {
                MessageBox.Show("Select the NPDB Environment");
                return;
            }
            string gamerTag;
            OurUser = null;
            this.createUserButton.Enabled = false;
            this.getSubButton.Enabled = false;
            this.retrieveButton.Enabled = false;
            if (this.gamerTagTextBox.Text.CompareTo("<gamertag>") == 0 || this.gamerTagTextBox.Text.CompareTo("") == 0 || this.gamerTagTextBox.Text.CompareTo(prevGamerTag) == 0)
                gamerTag = "";
            else
                gamerTag = this.gamerTagTextBox.Text;

            OurUser = new LiveUser(UserAccountType);            
            OurUser.PassportName = this.passportnameText.Text;                      
            OurUser.PassportPwd = this.passportpwdText.Text;
            OurUser.GamerTag = gamerTag;
            try
            {
                OurUser.CreateUser(UserCountry);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message + "\n" + ex.StackTrace);
                OurUser = null;
                return;
            }
            finally
            {
                this.createUserButton.Enabled = true;
                this.getSubButton.Enabled = true;
                this.retrieveButton.Enabled = true;
            }

            this.userPuidTextBox.Text = OurUser.UserPuid.ToString();
            this.gamerTagTextBox.Text = OurUser.GamerTag;
            this.passportnameText.Clear();
            this.passportpwdText.Clear();
            this.passportnameText.Text = OurUser.PassportName;
            this.passportpwdText.Text = OurUser.PassportPwd;
            prevGamerTag = OurUser.GamerTag;
        }


        private void retrieveButton_Click(object sender, EventArgs e)
        {
            if (this.cbNpdbSetting.SelectedItem == null)
            {
                MessageBox.Show("Select the NPDB Environment");
                return;
            }
            string gamerTag;
            OurUser = null;
            OurUser = new LiveUser();            
            if (this.gamerTagTextBox.Text.CompareTo("<gamertag>") == 0 || this.gamerTagTextBox.Text.CompareTo("") == 0 || this.gamerTagTextBox.Text.CompareTo(prevGamerTag) == 0)
            {
                gamerTag = "";
                MessageBox.Show("Enter a valid gamer tag");
                return;
            }
            else
                gamerTag = this.gamerTagTextBox.Text;

            this.getSubButton.Enabled = false;
            this.retrieveButton.Enabled = false;
            this.createUserButton.Enabled = false;
            try
            {
                OurUser.Retrieve(gamerTag);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message + "\n" + ex.StackTrace);
                OurUser = null;
                return;
            }
            finally
            {
                this.getSubButton.Enabled = true;
                this.retrieveButton.Enabled = true;
                this.createUserButton.Enabled = true;
            }

            this.userPuidTextBox.Text = OurUser.UserPuid.ToString();
            this.passportnameText.Clear();
            this.passportpwdText.Clear();
            prevGamerTag = gamerTag;
            this.UATComboBox.Text = OurUser.AccountType.ToString();
            this.comboBoxCountry.SelectedItem = ((XeUser.Country)OurUser.CountryId).ToString();
        }

        private void getSubButton_Click(object sender, EventArgs e)
        {
            if (this.cbNpdbSetting.SelectedItem == null)
            {
                MessageBox.Show("Select the NPDB Environment");
                return;
            }

            if (OurUser == null)
            {
                MessageBox.Show("A user has to be created or retrieved first.");
                return;
            }

            this.getSubButton.Enabled = false;
            this.retrieveButton.Enabled = false;
            this.createUserButton.Enabled = false;
            this.textBoxSubInfo.Text = string.Empty;

            string outputString;
            string subDetails;
            if (!Subscriptions.XeGetUserSubscriptionDetails(OurUser.UserPuid, out subDetails, out outputString))
            {
                MessageBox.Show(outputString);
            }
            else
            {
                this.textBoxSubInfo.Text = subDetails;
            }

            this.getSubButton.Enabled = true;
            this.retrieveButton.Enabled = true;
            this.createUserButton.Enabled = true;
        }

        private void uatComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {            
            UserAccountType = (UserType) Enum.Parse(typeof(UserType), this.UATComboBox.SelectedItem.ToString(), true);
        }
        
        private void comboBoxCountry_SelectedIndexChanged(object sender, EventArgs e)
        {
            UserCountry = (XeUser.Country)Enum.Parse(typeof(XeUser.Country), this.comboBoxCountry.SelectedItem.ToString(), true);
        }

        private void cbNpdbSetting_SelectedIndexChanged(object sender, EventArgs e)
        {
            string currEnv = (string)cbNpdbSetting.SelectedItem;
            string[] envParas = currEnv.Split(',');
            Global.CurrentEnvironment = new EnvironmentSetting(envParas[0], envParas[1], envParas[2], envParas[3], false);
            if (!ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.ConnectToService())
            {
                Console.WriteLine("Failed to connect to FakeSG Service... achievement setting will likely fail.");
            }
            else
            {
                try
                {
                    ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface("xpnfd_presence").ToString());
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Exception: " + ex.Message);
                    return;
                }
            }      
        }

 
        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void subscriptionButton_Click(object sender, EventArgs e)
        {
            if (OurUser == null)
            {
                MessageBox.Show("A user has to be created or retrieved first.");
                return;
            }
            SubForm = new SubscriptionForm();
            SubForm.SubFormInit(OurUser);
            SubForm.ShowDialog();
            SubForm.Dispose();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\LiveUser.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace SubscriptionTestTool
{
    public class LiveUser
    {
        #region attributes
        private XeUser user;
        private UserInfo uinfo;
        private UserType accountType;
        private ulong userPuid;
        private string gamerTag;
        private byte countryId;
        private ushort languageId;
        private bool bretrieved = false;
        private AddressInfoData addressInfo;
        private string passportName;
        private string passportPwd;
        #endregion

        #region Properties

        public XeUser XeUser
        {
            set { user = value; }
            get { return user; }
        }

        public string GamerTag
        {
            set
            {
                gamerTag = value;
            }
            get
            {
                return gamerTag;
            }
        }

        public ulong UserPuid
        {
            set
            {
                userPuid = value;
            }
            get
            {
                return userPuid;
            }
        }

        public byte CountryId
        {
            set
            {
                countryId = value;
            }
            get
            {
                return countryId;
            }
        }

        public ushort LanguageId
        {
            set
            {
                languageId = value;
            }
            get
            {
                return languageId;
            }
        }

        public AddressInfoData AddressInfoLive
        {
            set
            {
                addressInfo = value;
            }
            get
            {
                return addressInfo;
            }
        }

        public bool bRetrieved
        {
            set
            {
                bretrieved = value;
            }
            get
            {
                return bretrieved;
            }
        }

        public UserType AccountType
        {
            set
            {
                accountType = value;
            }
            get
            {
                return accountType;
            }
        }

        public string PassportName
        {
            set
            {
                passportName = value;
            }
            get
            {
                return passportName;
            }
        }

        public string PassportPwd
        {
            set
            {
                passportPwd = value;
            }
            get
            {
                return passportPwd;
            }
        }
        #endregion 

        public LiveUser()
        {
            //this value needs to set if the user is being retrieved from Live service
            accountType = UserType.GoldUser;
        }

        public LiveUser(UserType ut)
        {
            accountType = ut;
        }

        #region PublicMethods
        public void CreateUser(XeUser.Country country)
        {
            UacsCommon UACS = new UacsCommon();
            user = new XeUser(true, country);
            if (this.GamerTag == "")
            {
                this.GamerTag = "auto" + UACS.Random.GenerateRandomNameString(10);
            }
            if (this.PassportName == "")
            {
                this.PassportName = this.gamerTag + "@xboxtest.com";
            }
            if (this.PassportPwd == "")
            {
                this.PassportPwd = "supersecret";
            }
            user.Gamertag = this.GamerTag;          
            user.Email = XeUser.Country.US.ToString() + "_XboxRenewalTesting@xboxlive.com";
            user.FirstName = user.Gamertag;
            user.PassportMemberName = this.PassportName;
            user.PassportPassword = this.PassportPwd;
            user.LastName = user.Gamertag + "Last";
            //TODO: Have a drop down menu listing all the countries            

            //Add a payment Instrument
            user.PaymentInstrumentType = PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
            user.BillingToken = "";
            user.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
            user.CreditCardInfo.ExpirationDate = new DateTime(2020, 12, 1);

            switch (accountType)
            {
                case UserType.SilverUser:
                    {
                        user.CreateAsGold = false;
                        user.OfferId = 0xFFFE07D180000011;
                        break;
                    }
                case UserType.ArgoUser:
                    {
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        break;
                    }
                case UserType.GoldUser:
                    {
                        user.OfferId = (ulong) OfferType.XeYearlyCC;
                        break;
                    }
            }
            UserPuid = user.Create();
            if (UserPuid == 0)
            {
                throw new Exception("XeUser.Create() failed: " + user.GetDumpString());
            }

            // update passport membername and password
            this.PassportName = user.PassportMemberName;
            this.PassportPwd = user.PassportPassword;

            AddressInfoLive = user.AddressInfo; 
            CountryId = user.CountryId;
            LanguageId = user.LanguageId;
            
        }

        public void Retrieve(string gTag)
        {
            bRetrieved = true;
            GamerTag = gTag;
            UserPuid = UodbWS.GetUserIDFromGamerTag(gTag);
            uinfo = UodbWS.GetUserInfo(UserPuid);
            if (UodbWS.GetUserTier(UserPuid) == 0x03)
                accountType = UserType.SilverUser;
            else
                accountType = UserType.GoldUser;
            CountryId = (byte) uinfo.country;
            LanguageId = (byte) uinfo.language;
            PassportName = "";
            PassportPwd = "";

            // try to re-create the XeUser object
            user = new XeUser(true, gTag, (XeUser.Country)CountryId);
            user.UserPuid = UserPuid;
            user.LanguageId = LanguageId;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Program.cs ===
using System;
using System.Xml;
using System.Collections.Generic;
using System.Windows.Forms;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;

namespace SubscriptionTestTool
{
    static class Program
    {
        public static void InitializeStf()
        {
            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            GlobalFakeSG.FakeSG = new FakeSGClient("FakeSGClient"); //you probably don't need this now... 
        }
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            InitializeStf();
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());

            CoreGlobal.Uninitialize();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Form1.Designer.cs ===
namespace SubscriptionTestTool
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.createUserButton = new System.Windows.Forms.Button();
            this.gamerTagTextBox = new System.Windows.Forms.TextBox();
            this.panel1 = new System.Windows.Forms.Panel();
            this.label5 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.comboBoxCountry = new System.Windows.Forms.ComboBox();
            this.textBoxSubInfo = new System.Windows.Forms.TextBox();
            this.passportPwdLabel = new System.Windows.Forms.Label();
            this.label1 = new System.Windows.Forms.Label();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.passportnameText = new System.Windows.Forms.TextBox();
            this.passportpwdText = new System.Windows.Forms.TextBox();
            this.subscriptionButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.retrieveButton = new System.Windows.Forms.Button();
            this.getSubButton = new System.Windows.Forms.Button();
            this.userPuidTextBox = new System.Windows.Forms.TextBox();
            this.UATComboBox = new System.Windows.Forms.ComboBox();
            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.panel2 = new System.Windows.Forms.Panel();
            this.npdbLabel = new System.Windows.Forms.Label();
            this.cbNpdbSetting = new System.Windows.Forms.ComboBox();
            this.panel1.SuspendLayout();
            this.tableLayoutPanel2.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();
            this.panel2.SuspendLayout();
            this.SuspendLayout();
            // 
            // createUserButton
            // 
            this.createUserButton.Dock = System.Windows.Forms.DockStyle.Fill;
            this.createUserButton.Location = new System.Drawing.Point(3, 3);
            this.createUserButton.Name = "createUserButton";
            this.createUserButton.Size = new System.Drawing.Size(91, 21);
            this.createUserButton.TabIndex = 5;
            this.createUserButton.Text = "CreateUser";
            this.createUserButton.UseVisualStyleBackColor = true;
            this.createUserButton.Click += new System.EventHandler(this.createUserButton_Click);
            // 
            // gamerTagTextBox
            // 
            this.gamerTagTextBox.Location = new System.Drawing.Point(15, 38);
            this.gamerTagTextBox.Name = "gamerTagTextBox";
            this.gamerTagTextBox.Size = new System.Drawing.Size(140, 20);
            this.gamerTagTextBox.TabIndex = 0;
            this.gamerTagTextBox.Text = "<gamertag>";
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.label5);
            this.panel1.Controls.Add(this.label4);
            this.panel1.Controls.Add(this.label3);
            this.panel1.Controls.Add(this.label2);
            this.panel1.Controls.Add(this.comboBoxCountry);
            this.panel1.Controls.Add(this.textBoxSubInfo);
            this.panel1.Controls.Add(this.passportPwdLabel);
            this.panel1.Controls.Add(this.label1);
            this.panel1.Controls.Add(this.tableLayoutPanel2);
            this.panel1.Controls.Add(this.subscriptionButton);
            this.panel1.Controls.Add(this.tableLayoutPanel1);
            this.panel1.Controls.Add(this.userPuidTextBox);
            this.panel1.Controls.Add(this.UATComboBox);
            this.panel1.Controls.Add(this.gamerTagTextBox);
            this.panel1.Controls.Add(this.tableLayoutPanel3);
            this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
            this.panel1.Location = new System.Drawing.Point(0, 0);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(470, 460);
            this.panel1.TabIndex = 1;
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(158, 18);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(50, 13);
            this.label5.TabIndex = 15;
            this.label5.Text = "UserPuid";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(9, 18);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(57, 13);
            this.label4.TabIndex = 14;
            this.label4.Text = "GamerTag";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(329, 18);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(43, 13);
            this.label3.TabIndex = 13;
            this.label3.Text = "Country";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(12, 78);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(53, 13);
            this.label2.TabIndex = 12;
            this.label2.Text = "UserType";
            // 
            // comboBoxCountry
            // 
            this.comboBoxCountry.FormattingEnabled = true;
            this.comboBoxCountry.Location = new System.Drawing.Point(332, 36);
            this.comboBoxCountry.Name = "comboBoxCountry";
            this.comboBoxCountry.Size = new System.Drawing.Size(125, 21);
            this.comboBoxCountry.TabIndex = 11;
            this.comboBoxCountry.SelectedIndexChanged += new System.EventHandler(this.comboBoxCountry_SelectedIndexChanged);
            // 
            // textBoxSubInfo
            // 
            this.textBoxSubInfo.Location = new System.Drawing.Point(12, 208);
            this.textBoxSubInfo.Multiline = true;
            this.textBoxSubInfo.Name = "textBoxSubInfo";
            this.textBoxSubInfo.ReadOnly = true;
            this.textBoxSubInfo.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.textBoxSubInfo.Size = new System.Drawing.Size(445, 249);
            this.textBoxSubInfo.TabIndex = 10;
            this.textBoxSubInfo.WordWrap = false;
            // 
            // passportPwdLabel
            // 
            this.passportPwdLabel.AutoSize = true;
            this.passportPwdLabel.Location = new System.Drawing.Point(211, 123);
            this.passportPwdLabel.Name = "passportPwdLabel";
            this.passportPwdLabel.Size = new System.Drawing.Size(69, 13);
            this.passportPwdLabel.TabIndex = 0;
            this.passportPwdLabel.Text = "PassportPwd";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(12, 123);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(76, 13);
            this.label1.TabIndex = 1;
            this.label1.Text = "PassportName";
            // 
            // tableLayoutPanel2
            // 
            this.tableLayoutPanel2.ColumnCount = 2;
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 65.86207F));
            this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 34.13793F));
            this.tableLayoutPanel2.Controls.Add(this.passportnameText, 0, 0);
            this.tableLayoutPanel2.Controls.Add(this.passportpwdText, 1, 0);
            this.tableLayoutPanel2.Location = new System.Drawing.Point(12, 139);
            this.tableLayoutPanel2.Name = "tableLayoutPanel2";
            this.tableLayoutPanel2.RowCount = 1;
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel2.Size = new System.Drawing.Size(290, 26);
            this.tableLayoutPanel2.TabIndex = 3;
            // 
            // passportnameText
            // 
            this.passportnameText.Location = new System.Drawing.Point(3, 3);
            this.passportnameText.Name = "passportnameText";
            this.passportnameText.Size = new System.Drawing.Size(184, 20);
            this.passportnameText.TabIndex = 3;
            // 
            // passportpwdText
            // 
            this.passportpwdText.Location = new System.Drawing.Point(193, 3);
            this.passportpwdText.Name = "passportpwdText";
            this.passportpwdText.Size = new System.Drawing.Size(94, 20);
            this.passportpwdText.TabIndex = 4;
            // 
            // subscriptionButton
            // 
            this.subscriptionButton.Location = new System.Drawing.Point(376, 175);
            this.subscriptionButton.Name = "subscriptionButton";
            this.subscriptionButton.Size = new System.Drawing.Size(81, 22);
            this.subscriptionButton.TabIndex = 7;
            this.subscriptionButton.Text = "Subscriptions";
            this.subscriptionButton.UseVisualStyleBackColor = true;
            this.subscriptionButton.Click += new System.EventHandler(this.subscriptionButton_Click);
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 3;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 96F));
            this.tableLayoutPanel1.Controls.Add(this.retrieveButton, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.getSubButton, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.createUserButton, 0, 0);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(12, 175);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 1;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(290, 27);
            this.tableLayoutPanel1.TabIndex = 8;
            // 
            // retrieveButton
            // 
            this.retrieveButton.Dock = System.Windows.Forms.DockStyle.Fill;
            this.retrieveButton.Location = new System.Drawing.Point(100, 3);
            this.retrieveButton.Name = "retrieveButton";
            this.retrieveButton.Size = new System.Drawing.Size(91, 21);
            this.retrieveButton.TabIndex = 7;
            this.retrieveButton.Text = "Retrieve User";
            this.retrieveButton.UseVisualStyleBackColor = true;
            this.retrieveButton.Click += new System.EventHandler(this.retrieveButton_Click);
            // 
            // getSubButton
            // 
            this.getSubButton.Dock = System.Windows.Forms.DockStyle.Fill;
            this.getSubButton.Location = new System.Drawing.Point(197, 3);
            this.getSubButton.Name = "getSubButton";
            this.getSubButton.Size = new System.Drawing.Size(90, 21);
            this.getSubButton.TabIndex = 6;
            this.getSubButton.Text = "Retrieve Sub";
            this.getSubButton.UseVisualStyleBackColor = true;
            this.getSubButton.Click += new System.EventHandler(this.getSubButton_Click);
            // 
            // userPuidTextBox
            // 
            this.userPuidTextBox.Location = new System.Drawing.Point(161, 38);
            this.userPuidTextBox.Name = "userPuidTextBox";
            this.userPuidTextBox.Size = new System.Drawing.Size(137, 20);
            this.userPuidTextBox.TabIndex = 1;
            this.userPuidTextBox.Text = "<userpuid>";
            // 
            // UATComboBox
            // 
            this.UATComboBox.AllowDrop = true;
            this.UATComboBox.FormattingEnabled = true;
            this.UATComboBox.Location = new System.Drawing.Point(12, 94);
            this.UATComboBox.Name = "UATComboBox";
            this.UATComboBox.Size = new System.Drawing.Size(121, 21);
            this.UATComboBox.TabIndex = 2;
            this.UATComboBox.SelectedIndexChanged += new System.EventHandler(this.uatComboBox_SelectedIndexChanged);
            // 
            // tableLayoutPanel3
            // 
            this.tableLayoutPanel3.ColumnCount = 2;
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.Location = new System.Drawing.Point(12, 38);
            this.tableLayoutPanel3.Name = "tableLayoutPanel3";
            this.tableLayoutPanel3.RowCount = 1;
            this.tableLayoutPanel3.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel3.Size = new System.Drawing.Size(290, 20);
            this.tableLayoutPanel3.TabIndex = 9;
            // 
            // panel2
            // 
            this.panel2.Controls.Add(this.npdbLabel);
            this.panel2.Controls.Add(this.cbNpdbSetting);
            this.panel2.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.panel2.Location = new System.Drawing.Point(0, 463);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(470, 26);
            this.panel2.TabIndex = 0;
            // 
            // npdbLabel
            // 
            this.npdbLabel.AutoSize = true;
            this.npdbLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.npdbLabel.Location = new System.Drawing.Point(37, 8);
            this.npdbLabel.Name = "npdbLabel";
            this.npdbLabel.Size = new System.Drawing.Size(42, 16);
            this.npdbLabel.TabIndex = 0;
            this.npdbLabel.Text = "Npdb";
            // 
            // cbNpdbSetting
            // 
            this.cbNpdbSetting.FormattingEnabled = true;
            this.cbNpdbSetting.Location = new System.Drawing.Point(85, 3);
            this.cbNpdbSetting.Name = "cbNpdbSetting";
            this.cbNpdbSetting.Size = new System.Drawing.Size(195, 21);
            this.cbNpdbSetting.TabIndex = 8;
            this.cbNpdbSetting.SelectedIndexChanged += new System.EventHandler(this.cbNpdbSetting_SelectedIndexChanged);
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(470, 489);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.panel1);
            this.Name = "Form1";
            this.Text = "SubscriptionTestTool";
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.tableLayoutPanel2.ResumeLayout(false);
            this.tableLayoutPanel2.PerformLayout();
            this.tableLayoutPanel1.ResumeLayout(false);
            this.panel2.ResumeLayout(false);
            this.panel2.PerformLayout();
            this.ResumeLayout(false);

        }    
        #endregion

        private System.Windows.Forms.Button createUserButton;
        private System.Windows.Forms.TextBox gamerTagTextBox;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.ComboBox UATComboBox;
        private System.Windows.Forms.Panel panel2;
        private System.Windows.Forms.ComboBox cbNpdbSetting;
        private System.Windows.Forms.Label npdbLabel;
        private System.Windows.Forms.TextBox userPuidTextBox;
        private System.Windows.Forms.Button getSubButton;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;
        private System.Windows.Forms.Button subscriptionButton;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;
        private System.Windows.Forms.TextBox passportpwdText;
        private System.Windows.Forms.TextBox passportnameText;
        private System.Windows.Forms.Label passportPwdLabel;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button retrieveButton;
        private System.Windows.Forms.TextBox textBoxSubInfo;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.ComboBox comboBoxCountry;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\SubscriptionForm.Designer.cs ===
namespace SubscriptionTestTool
{
    partial class SubscriptionForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.panel3 = new System.Windows.Forms.Panel();
            this.groupBox4 = new System.Windows.Forms.GroupBox();
            this.previewButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.subscriptionsComboBox = new System.Windows.Forms.ComboBox();
            this.enumerateButton = new System.Windows.Forms.Button();
            this.queryTypeListBox = new System.Windows.Forms.ListBox();
            this.titleIdLabel = new System.Windows.Forms.Label();
            this.titleIdTextBox = new System.Windows.Forms.TextBox();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.label3 = new System.Windows.Forms.Label();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.VerifyTokenButton = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.textBoxTokenCode = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.piComboBox = new System.Windows.Forms.ComboBox();
            this.piEnumButton = new System.Windows.Forms.Button();
            this.addPIButton = new System.Windows.Forms.Button();
            this.purchaseButton = new System.Windows.Forms.Button();
            this.label5 = new System.Windows.Forms.Label();
            this.comboBoxPaymentType = new System.Windows.Forms.ComboBox();
            this.label4 = new System.Windows.Forms.Label();
            this.textBoxOfferGuid = new System.Windows.Forms.TextBox();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.disableButton = new System.Windows.Forms.Button();
            this.radioButtonPanel = new System.Windows.Forms.TableLayoutPanel();
            this.radioSuspendButton = new System.Windows.Forms.RadioButton();
            this.radioExpireButton = new System.Windows.Forms.RadioButton();
            this.radioDelayedCancelButton = new System.Windows.Forms.RadioButton();
            this.closeButton = new System.Windows.Forms.Button();
            this.radioCancelButton = new System.Windows.Forms.RadioButton();
            this.panel3.SuspendLayout();
            this.groupBox4.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.radioButtonPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // panel3
            // 
            this.panel3.Controls.Add(this.groupBox4);
            this.panel3.Controls.Add(this.groupBox3);
            this.panel3.Controls.Add(this.groupBox2);
            this.panel3.Controls.Add(this.closeButton);
            this.panel3.Location = new System.Drawing.Point(0, 3);
            this.panel3.Name = "panel3";
            this.panel3.Size = new System.Drawing.Size(546, 568);
            this.panel3.TabIndex = 0;
            // 
            // groupBox4
            // 
            this.groupBox4.Controls.Add(this.previewButton);
            this.groupBox4.Controls.Add(this.label1);
            this.groupBox4.Controls.Add(this.subscriptionsComboBox);
            this.groupBox4.Controls.Add(this.enumerateButton);
            this.groupBox4.Controls.Add(this.queryTypeListBox);
            this.groupBox4.Controls.Add(this.titleIdLabel);
            this.groupBox4.Controls.Add(this.titleIdTextBox);
            this.groupBox4.Location = new System.Drawing.Point(12, 12);
            this.groupBox4.Name = "groupBox4";
            this.groupBox4.Size = new System.Drawing.Size(519, 149);
            this.groupBox4.TabIndex = 25;
            this.groupBox4.TabStop = false;
            this.groupBox4.Text = "Enumerate Subscription";
            // 
            // previewButton
            // 
            this.previewButton.Location = new System.Drawing.Point(10, 116);
            this.previewButton.Name = "previewButton";
            this.previewButton.Size = new System.Drawing.Size(134, 26);
            this.previewButton.TabIndex = 9;
            this.previewButton.Text = "PreviewProductPurchase";
            this.previewButton.UseVisualStyleBackColor = true;
            this.previewButton.Click += new System.EventHandler(this.previewButton_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(7, 68);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(130, 13);
            this.label1.TabIndex = 11;
            this.label1.Text = "Enumerated Subscriptions";
            // 
            // subscriptionsComboBox
            // 
            this.subscriptionsComboBox.FormattingEnabled = true;
            this.subscriptionsComboBox.Location = new System.Drawing.Point(10, 84);
            this.subscriptionsComboBox.Name = "subscriptionsComboBox";
            this.subscriptionsComboBox.Size = new System.Drawing.Size(438, 21);
            this.subscriptionsComboBox.TabIndex = 3;
            // 
            // enumerateButton
            // 
            this.enumerateButton.Location = new System.Drawing.Point(241, 22);
            this.enumerateButton.Name = "enumerateButton";
            this.enumerateButton.Size = new System.Drawing.Size(90, 22);
            this.enumerateButton.TabIndex = 2;
            this.enumerateButton.Text = "SubEnumerate";
            this.enumerateButton.UseVisualStyleBackColor = true;
            this.enumerateButton.Click += new System.EventHandler(this.enumerateButton_Click);
            // 
            // queryTypeListBox
            // 
            this.queryTypeListBox.FormattingEnabled = true;
            this.queryTypeListBox.Location = new System.Drawing.Point(124, 22);
            this.queryTypeListBox.Name = "queryTypeListBox";
            this.queryTypeListBox.SelectionMode = System.Windows.Forms.SelectionMode.MultiSimple;
            this.queryTypeListBox.Size = new System.Drawing.Size(98, 43);
            this.queryTypeListBox.TabIndex = 1;
            // 
            // titleIdLabel
            // 
            this.titleIdLabel.AutoSize = true;
            this.titleIdLabel.Location = new System.Drawing.Point(10, 21);
            this.titleIdLabel.Name = "titleIdLabel";
            this.titleIdLabel.Size = new System.Drawing.Size(38, 13);
            this.titleIdLabel.TabIndex = 12;
            this.titleIdLabel.Text = "TitleID";
            // 
            // titleIdTextBox
            // 
            this.titleIdTextBox.Location = new System.Drawing.Point(10, 37);
            this.titleIdTextBox.Name = "titleIdTextBox";
            this.titleIdTextBox.Size = new System.Drawing.Size(100, 20);
            this.titleIdTextBox.TabIndex = 0;
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.label3);
            this.groupBox3.Controls.Add(this.groupBox1);
            this.groupBox3.Controls.Add(this.purchaseButton);
            this.groupBox3.Controls.Add(this.label5);
            this.groupBox3.Controls.Add(this.comboBoxPaymentType);
            this.groupBox3.Controls.Add(this.label4);
            this.groupBox3.Controls.Add(this.textBoxOfferGuid);
            this.groupBox3.Location = new System.Drawing.Point(12, 167);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(520, 303);
            this.groupBox3.TabIndex = 24;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "Purchase Subscription";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(10, 131);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(199, 13);
            this.label3.TabIndex = 23;
            this.label3.Text = "3. Select a PI or Enter a 5X5 token code";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.VerifyTokenButton);
            this.groupBox1.Controls.Add(this.label2);
            this.groupBox1.Controls.Add(this.textBoxTokenCode);
            this.groupBox1.Controls.Add(this.tableLayoutPanel1);
            this.groupBox1.Location = new System.Drawing.Point(13, 147);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(395, 104);
            this.groupBox1.TabIndex = 22;
            this.groupBox1.TabStop = false;
            // 
            // VerifyTokenButton
            // 
            this.VerifyTokenButton.Location = new System.Drawing.Point(275, 69);
            this.VerifyTokenButton.Name = "VerifyTokenButton";
            this.VerifyTokenButton.Size = new System.Drawing.Size(108, 26);
            this.VerifyTokenButton.TabIndex = 18;
            this.VerifyTokenButton.Text = "VerifyToken";
            this.VerifyTokenButton.UseVisualStyleBackColor = true;
            this.VerifyTokenButton.Click += new System.EventHandler(this.VerifyTokenButton_Click);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(27, 59);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(94, 13);
            this.label2.TabIndex = 17;
            this.label2.Text = "Token Code (5X5)";
            // 
            // textBoxTokenCode
            // 
            this.textBoxTokenCode.Location = new System.Drawing.Point(24, 75);
            this.textBoxTokenCode.Name = "textBoxTokenCode";
            this.textBoxTokenCode.Size = new System.Drawing.Size(237, 20);
            this.textBoxTokenCode.TabIndex = 16;
            this.textBoxTokenCode.WordWrap = false;
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 3;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 72.34637F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 27.65363F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 87F));
            this.tableLayoutPanel1.Controls.Add(this.piComboBox, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.piEnumButton, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.addPIButton, 2, 0);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(21, 20);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 1;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(365, 28);
            this.tableLayoutPanel1.TabIndex = 14;
            // 
            // piComboBox
            // 
            this.piComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.piComboBox.FormattingEnabled = true;
            this.piComboBox.Location = new System.Drawing.Point(3, 3);
            this.piComboBox.Name = "piComboBox";
            this.piComboBox.Size = new System.Drawing.Size(195, 21);
            this.piComboBox.TabIndex = 0;
            // 
            // piEnumButton
            // 
            this.piEnumButton.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.piEnumButton.Location = new System.Drawing.Point(204, 3);
            this.piEnumButton.Name = "piEnumButton";
            this.piEnumButton.Size = new System.Drawing.Size(70, 22);
            this.piEnumButton.TabIndex = 1;
            this.piEnumButton.Text = "PIEnumerate";
            this.piEnumButton.UseVisualStyleBackColor = true;
            this.piEnumButton.Click += new System.EventHandler(this.piEnumButton_Click);
            // 
            // addPIButton
            // 
            this.addPIButton.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.addPIButton.Location = new System.Drawing.Point(280, 3);
            this.addPIButton.Name = "addPIButton";
            this.addPIButton.Size = new System.Drawing.Size(82, 22);
            this.addPIButton.TabIndex = 2;
            this.addPIButton.Text = "AddPI";
            this.addPIButton.UseVisualStyleBackColor = true;
            this.addPIButton.Click += new System.EventHandler(this.addPIButton_Click);
            // 
            // purchaseButton
            // 
            this.purchaseButton.Location = new System.Drawing.Point(8, 264);
            this.purchaseButton.Name = "purchaseButton";
            this.purchaseButton.Size = new System.Drawing.Size(88, 26);
            this.purchaseButton.TabIndex = 4;
            this.purchaseButton.Text = "Purchase";
            this.purchaseButton.UseVisualStyleBackColor = true;
            this.purchaseButton.Click += new System.EventHandler(this.purchaseButton_Click);
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(8, 75);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(454, 13);
            this.label5.TabIndex = 21;
            this.label5.Text = "2. Select a Payment Type (For CC, select a PI or add a PI. For Token, enter a 5X5" +
                " token code)";
            // 
            // comboBoxPaymentType
            // 
            this.comboBoxPaymentType.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.comboBoxPaymentType.FormattingEnabled = true;
            this.comboBoxPaymentType.Location = new System.Drawing.Point(11, 99);
            this.comboBoxPaymentType.Name = "comboBoxPaymentType";
            this.comboBoxPaymentType.Size = new System.Drawing.Size(227, 21);
            this.comboBoxPaymentType.TabIndex = 20;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(10, 23);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(486, 13);
            this.label4.TabIndex = 19;
            this.label4.Text = "1. Enter a Offer Guid (must be in Guid format) or Select one from Enumerated Subs" +
                "criptions List Above";
            // 
            // textBoxOfferGuid
            // 
            this.textBoxOfferGuid.Location = new System.Drawing.Point(13, 45);
            this.textBoxOfferGuid.Name = "textBoxOfferGuid";
            this.textBoxOfferGuid.Size = new System.Drawing.Size(210, 20);
            this.textBoxOfferGuid.TabIndex = 15;
            this.textBoxOfferGuid.WordWrap = false;
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.disableButton);
            this.groupBox2.Controls.Add(this.radioButtonPanel);
            this.groupBox2.Location = new System.Drawing.Point(12, 476);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(520, 55);
            this.groupBox2.TabIndex = 23;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Disable Subscription";
            // 
            // disableButton
            // 
            this.disableButton.Location = new System.Drawing.Point(434, 20);
            this.disableButton.Name = "disableButton";
            this.disableButton.Size = new System.Drawing.Size(80, 26);
            this.disableButton.TabIndex = 8;
            this.disableButton.Text = "Disable";
            this.disableButton.UseVisualStyleBackColor = true;
            this.disableButton.Click += new System.EventHandler(this.disableButton_Click);
            // 
            // radioButtonPanel
            // 
            this.radioButtonPanel.ColumnCount = 4;
            this.radioButtonPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 33.33333F));
            this.radioButtonPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 33.33333F));
            this.radioButtonPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 33.33333F));
            this.radioButtonPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute, 133F));
            this.radioButtonPanel.Controls.Add(this.radioCancelButton, 0, 0);
            this.radioButtonPanel.Controls.Add(this.radioSuspendButton, 0, 0);
            this.radioButtonPanel.Controls.Add(this.radioExpireButton, 1, 0);
            this.radioButtonPanel.Controls.Add(this.radioDelayedCancelButton, 2, 0);
            this.radioButtonPanel.Location = new System.Drawing.Point(37, 20);
            this.radioButtonPanel.Name = "radioButtonPanel";
            this.radioButtonPanel.RowCount = 1;
            this.radioButtonPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.radioButtonPanel.Size = new System.Drawing.Size(391, 26);
            this.radioButtonPanel.TabIndex = 10;
            // 
            // radioSuspendButton
            // 
            this.radioSuspendButton.AutoSize = true;
            this.radioSuspendButton.Location = new System.Drawing.Point(3, 3);
            this.radioSuspendButton.Name = "radioSuspendButton";
            this.radioSuspendButton.Size = new System.Drawing.Size(67, 17);
            this.radioSuspendButton.TabIndex = 5;
            this.radioSuspendButton.TabStop = true;
            this.radioSuspendButton.Text = "Suspend";
            this.radioSuspendButton.UseVisualStyleBackColor = true;
            // 
            // radioExpireButton
            // 
            this.radioExpireButton.AutoSize = true;
            this.radioExpireButton.Location = new System.Drawing.Point(175, 3);
            this.radioExpireButton.Name = "radioExpireButton";
            this.radioExpireButton.Size = new System.Drawing.Size(54, 17);
            this.radioExpireButton.TabIndex = 6;
            this.radioExpireButton.TabStop = true;
            this.radioExpireButton.Text = "Expire";
            this.radioExpireButton.UseVisualStyleBackColor = true;
            // 
            // radioDelayedCancelButton
            // 
            this.radioDelayedCancelButton.AutoSize = true;
            this.radioDelayedCancelButton.Location = new System.Drawing.Point(261, 3);
            this.radioDelayedCancelButton.Name = "radioDelayedCancelButton";
            this.radioDelayedCancelButton.Size = new System.Drawing.Size(100, 17);
            this.radioDelayedCancelButton.TabIndex = 7;
            this.radioDelayedCancelButton.TabStop = true;
            this.radioDelayedCancelButton.Text = "Delayed Cancel";
            this.radioDelayedCancelButton.UseVisualStyleBackColor = true;
            // 
            // closeButton
            // 
            this.closeButton.Location = new System.Drawing.Point(458, 537);
            this.closeButton.Name = "closeButton";
            this.closeButton.Size = new System.Drawing.Size(75, 23);
            this.closeButton.TabIndex = 9;
            this.closeButton.Text = "Close";
            this.closeButton.UseVisualStyleBackColor = true;
            this.closeButton.Click += new System.EventHandler(this.closeButton_Click);
            // 
            // radioCancelButton
            // 
            this.radioCancelButton.AutoSize = true;
            this.radioCancelButton.Location = new System.Drawing.Point(89, 3);
            this.radioCancelButton.Name = "radioCancelButton";
            this.radioCancelButton.Size = new System.Drawing.Size(58, 17);
            this.radioCancelButton.TabIndex = 8;
            this.radioCancelButton.TabStop = true;
            this.radioCancelButton.Text = "Cancel";
            this.radioCancelButton.UseVisualStyleBackColor = true;
            // 
            // SubscriptionForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(545, 569);
            this.Controls.Add(this.panel3);
            this.Name = "SubscriptionForm";
            this.Text = "Subscriptions";
            this.panel3.ResumeLayout(false);
            this.groupBox4.ResumeLayout(false);
            this.groupBox4.PerformLayout();
            this.groupBox3.ResumeLayout(false);
            this.groupBox3.PerformLayout();
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.tableLayoutPanel1.ResumeLayout(false);
            this.groupBox2.ResumeLayout(false);
            this.radioButtonPanel.ResumeLayout(false);
            this.radioButtonPanel.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel panel3;
        private System.Windows.Forms.TableLayoutPanel radioButtonPanel;
        private System.Windows.Forms.RadioButton radioSuspendButton;
        private System.Windows.Forms.RadioButton radioExpireButton;
        private System.Windows.Forms.RadioButton radioDelayedCancelButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.ComboBox subscriptionsComboBox;
        private System.Windows.Forms.Button enumerateButton;
        private System.Windows.Forms.ListBox queryTypeListBox;
        private System.Windows.Forms.Label titleIdLabel;
        private System.Windows.Forms.TextBox titleIdTextBox;
        private System.Windows.Forms.Button disableButton;
        private System.Windows.Forms.Button purchaseButton;
        private System.Windows.Forms.Button closeButton;
        private System.Windows.Forms.Button previewButton;
        private System.Windows.Forms.TextBox textBoxOfferGuid;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox textBoxTokenCode;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.ComboBox piComboBox;
        private System.Windows.Forms.Button piEnumButton;
        private System.Windows.Forms.Button addPIButton;
        private System.Windows.Forms.ComboBox comboBoxPaymentType;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.GroupBox groupBox3;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.GroupBox groupBox4;
        private System.Windows.Forms.Button VerifyTokenButton;
        private System.Windows.Forms.RadioButton radioCancelButton;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Subscriptions.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

using live.client;
using live.common;
using live.common.next;
using live.protocol;
using live.protocol.next;
using live.server;
using live.server.next;

using xonline.common.catalogutil;

namespace SubscriptionTestTool
{
    class Subscriptions
    {
        private LiveUser user;
        private uint QueryFlags = 0;
        private uint TitleId = 0;

        //properties
        public LiveUser User
        {
            set
            {
                user = value;
            }
            get
            {
                return user;
            }
        }
        public XRLXeSubscriptionEnumerate XrlSE;
        public XRLXeSubscriptionEnumerateResponse XrlSER;
        public XRLXeGetPaymentInstruments xrlXGPI = new XRLXeGetPaymentInstruments();
        public XRLXeGetPaymentInstrumentsResponse xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
        public FeedSubscriptionOfferExt[] SubOffers = null;

        public Subscriptions()
        {

        }       

        public void EnumerateSetup(uint queryFlags, uint titleId)
        {            
            QueryFlags = queryFlags;
            TitleId = titleId;
        }
        //Execute Subscription Enumerate call - returns whether the call succeeded or failed.
        public bool Enumerate(out string outputString)
        {
            bool b = false;			// stores result of request call
            uint retryCount = 0;	// allows us to retry several times when a request fails
            uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
            outputString = "";
            System.Random randomBackoff = new Random();
            XrlSE = new XRLXeSubscriptionEnumerate();
            XrlSER = new XRLXeSubscriptionEnumerateResponse();

            XrlSE.UserPuid = User.UserPuid;
            XrlSE.UserTier = (byte)UodbWS.GetUserTier(User.UserPuid);
            XrlSE.CountryID = User.CountryId;
            XrlSE.LanguageID = User.LanguageId;
            XrlSE.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points |
                (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard |
                (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token;
            //XrlSE.GameRating = 0xFFFF;
            XrlSE.OfferType = (uint)ServerTestFramework.LiveService.Billing.OfferingTypeEnum.Subscription |
                (uint)ServerTestFramework.LiveService.Billing.OfferingTypeEnum.Renewal;
            XrlSE.TitleID = TitleId;
            XrlSE.TitleCategories = 0xFFFFFFFF;
            SetQueryFlags();
            XrlSE.GameRating = 255;
            XrlSE.ManualPopulateSlot();

            do
            {
                if (retryCount > 0)
                {
                    // Backoff on failures
                    outputString = "Retry #" + retryCount + " of " + maxRetries;
                    outputString = "Backing off for random 60-90 second interval";
                    System.Threading.Thread.Sleep(60000 + randomBackoff.Next(30000));
                }
                b = XrlSE.Execute(out XrlSER);
                if (!b)
                {                    
                    outputString = XrlSE.GetType().Name;
                    outputString += " XErr:" + ServerTestFramework.Global.XErrToString(XrlSE.XErr) + "  HTTP:" + XrlSE.httpStatus;                   
                    retryCount++;
                }
            }
            while (!b && retryCount <= maxRetries);

            return b;
        }

        /// <summary>
        /// An extension to FeedSubscriptionOffer
        /// Contains basic subscription offer information returned from SubscriptionOfferEnumerate API
        /// </summary>
        public class FeedSubscriptionOfferExt
        {
            public Guid offerId;
            public string OfferName;
            public uint Price;
            public uint FractionPrice;
            public int SubExtendMonths = -1;
            public ulong legacyOfferId;

            private decimal TotalPrice;

            public FeedSubscriptionOfferExt(FeedSubscription sub)
            {
                foreach (XmlElement element in sub.elements)
                {
                    if (element.Name == "live:subscriptionReducedTitle")
                    {
                        OfferName = element.InnerText;
                        break;
                    }
                }

                FeedSubscriptionOffer subOffer = sub.feedSubscriptionOffers.feedSubscriptionOffer[0];
                foreach (XmlElement element in subOffer.elements)
                {
                    if (element.Name == "live:offerId")
                    {
                        offerId = new Guid(element.InnerText);
                    }
                    else if (element.Name == "live:legacyOfferId")
                    {
                        legacyOfferId = (ulong)(long.Parse(element.InnerText));
                    }
                }

                TotalPrice = subOffer.feedSubscriptionOfferInstances.feedSubscriptionOfferInstanceItems[0].price;
                SetFractionPrice(TotalPrice, out Price, out FractionPrice);
            }

            public static void SetFractionPrice(decimal price, out uint wholePrice, out uint fractionPrice)
            {
                string fractionStr = price.ToString();
                string priceStr;
                priceStr = (fractionStr.IndexOf('.') >= 0) ? fractionStr.Substring(0, fractionStr.IndexOf('.')) : "";
                fractionStr = (fractionStr.LastIndexOf('.') >= 0) ? fractionStr.Substring(fractionStr.LastIndexOf('.')).Replace(".", "") : "";

                wholePrice = (priceStr.CompareTo("") == 0) ? 0 : uint.Parse(priceStr);

                char[] charsToTrim = { '0' };
                fractionStr = fractionStr.TrimEnd(charsToTrim);

                if (fractionStr.Length == 1) //19.9
                    fractionPrice = (fractionStr.CompareTo("") == 0) ? 0 : uint.Parse(fractionStr) * 10;
                else   //19.90 or 19.09
                    fractionPrice = (fractionStr.CompareTo("") == 0) ? 0 : uint.Parse(fractionStr);
            }
        }

        public bool SubscriptionOfferEnumerate(out string output)
        {
            output = string.Empty;
            bool bSuccess = false;
            IClient client = new ZuneClient();
            XblUser user = new XblUser(User.UserPuid, User.GamerTag);
            user.Settings.UserPassportInfo.PassportPuid = UodbWS.GetUserPassportUserPuid(User.UserPuid);
            int[] paymentTypes = new int[] { 2,/*token*/ 3/*credit card*/ };
            ulong queryModifiers = SetQueryFlags();
            int titleId = 0; //unchecked( (int)live.common.XOn.XENON_DASH_TITLE_ID );
            SubscriptionOfferEnumerateWebResponse resp = null;
            try
            {
                SubscriptionOfferEnumerate(client, user, null, null, null, null, null, paymentTypes, queryModifiers, titleId, out resp);

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(resp.Response);
                CatalogResultHandler resultHandler = new CatalogResultHandler();
                FeedResult SubOfferEnumResult = (FeedResult)resultHandler.Create(xmlDoc);

                if (SubOfferEnumResult == null)
                {
                    output = "No subscription is returned";
                    SubOffers = new FeedSubscriptionOfferExt[0];
                    return false;
                }

                List<FeedSubscriptionOfferExt> offerList = new List<FeedSubscriptionOfferExt>();
                foreach (FeedEntry entry in SubOfferEnumResult._entries)
                {
                    foreach (FeedSubscription sub in entry.FeedSubscriptions)
                    {
                        FeedSubscriptionOfferExt offer = new FeedSubscriptionOfferExt(sub);
                        offerList.Add(offer);
                    }
                }
                SubOffers = offerList.ToArray();

                bSuccess = true;
            }
            catch (Exception e)
            {
                output = "Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
            }

            return bSuccess;
        }

        private static void SubscriptionOfferEnumerate
            (IClient client
            , XblUser user
            , int[] productTypes
            , Guid[] productIds
            , Guid[] groupIds
            , Guid[] offerIds
            , long[] legacyOfferIds
            , int[] paymentTypes
            , ulong queryModifiers
            , int? titleId
            , out SubscriptionOfferEnumerateWebResponse resp
            )
        {
            live.common.next.SubscriptionOfferEnumerateFilter queryFilter = new live.common.next.SubscriptionOfferEnumerateFilter();
            queryFilter.LegacyOfferIds = (legacyOfferIds != null) ? ListEx.NewList(legacyOfferIds) : null;
            queryFilter.OfferIds = (offerIds != null) ? ListEx.NewList(offerIds) : null;
            queryFilter.PaymentTypes = (paymentTypes != null) ? ListEx.NewList(paymentTypes) : null;
            queryFilter.ProductIds = (productIds != null) ? ListEx.NewList(productIds) : null;
            queryFilter.ProductTypes = (productTypes != null) ? ListEx.NewList(productTypes) : null;
            queryFilter.SubscriptionFamilyIds = (groupIds != null) ? ListEx.NewList(groupIds) : null;
            if (titleId != null)
                queryFilter.TitleId = (int?)titleId;
            else queryFilter.TitleId = null;

            resp = live.server.next.WebBilling.GetSubscriptionOffers(client, user, queryModifiers, queryFilter.ToList(), null);
        }

        public bool EnumeratePI(out string outputString)
        {
            //get payment instrument ID
            bool b = true;
            xrlXGPI = new XRLXeGetPaymentInstruments();
            xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
            outputString = "";

            xrlXGPI.MaxResults = 5;
            xrlXGPI.UserPuid = User.UserPuid;
            b = xrlXGPI.Execute(out xrlXGPIR);
            if (!b)
            {
                outputString = "Failed getting a payment instrument";                
            }
            return b;
        }

        public string AddPI(out string outputString)
        {
            XRLXeAddPaymentInstrument xrlXAPI = new XRLXeAddPaymentInstrument();
            XRLXeAddPaymentInstrumentResponse xrlXAPIR = new XRLXeAddPaymentInstrumentResponse();
            bool b = true;
            string piIdString = "";
            outputString = "";
            xrlXAPI.UserPuid = User.UserPuid;
            if (user.AddressInfoLive != null)
            {
                xrlXAPI.AddressInfo = User.AddressInfoLive;
            }
            else
            {
                if (!EnumeratePI(out outputString) || xrlXGPIR.PaymentInstrumentCount == 0)
                {
                    //Generate AddressInfoData
                    xrlXAPI.AddressInfo.SetDefaultAddress((XeUser.Country)User.CountryId);
                }
                else
                    xrlXAPI.AddressInfo = xrlXGPIR.PaymentInstrumentInfo[0].AddressInfo;
            }
            xrlXAPI.PaymentInstrumentType = (byte)ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
            xrlXAPI.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
            b = xrlXAPI.Execute(out xrlXAPIR);
            if (!b)
            {
                outputString = "Failed adding a payment instrument:" + xrlXAPI.XErr;                
            }
            else{
                piIdString = xrlXAPIR.PaymentInstrumentId;
            }
            return piIdString;
        }

        private FeedSubscriptionOfferExt GetFeedSubOfferExt(Guid offerGuid)
        {
            FeedSubscriptionOfferExt sub = null;
            for (int i = 0; i < SubOffers.Length; i++)
            {
                if (offerGuid == SubOffers[i].offerId)
                {
                    sub = SubOffers[i];
                    break;
                }
            }
            return sub;
        }

        public bool Purchase(string offerGuid, string pi, string token, out string outputString)
        {
            bool b = false;
            string paymentInstId = null;
            outputString = "";
            string outputPIEnum;
            string outputAddPI;

            uint purchaseOfferPaymentType = (uint) ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard;
            if (!string.IsNullOrEmpty(token))   // PaymentType = Token
            {
                purchaseOfferPaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token;
                pi = null;

                // Call XeOfferPurchase for token based subscriptions
                try
                {
                    ulong offerId = CatalogUtil.OfferingGuidToOfferId(new Guid(offerGuid));
                    XbosOffer.OfferPurchase(offerId, User.XeUser, purchaseOfferPaymentType, token, pi);
                    b = true;
                }
                catch (Exception e)
                {
                    outputString = "Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
                }
            }
            else // PaymentType = CreditCard
            {
                // get the payment instrument
                if (string.IsNullOrEmpty(pi))
                {
                    b = EnumeratePI(out outputPIEnum);
                    if (!b)
                    {
                        outputString += outputPIEnum;
                        return b;
                    }
                    //if no payment instrument available
                    if (xrlXGPIR.PaymentInstrumentCount == 0)
                    {
                        paymentInstId = AddPI(out outputAddPI);
                        if (paymentInstId.CompareTo("") == 0)
                        {
                            outputString += outputAddPI;
                            b = false;
                            return b;
                        }
                    }
                    else
                    {
                        paymentInstId = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
                    }
                }
                else
                {
                    paymentInstId = pi;
                }

                try
                {
                    // call PreviewProdcutPurchase first to get subscriptionTimeExtendedInMonths
                    IClient client = new Xbox360Client();
                    int[] mediaTypeIds = new int[] { (int)MediaTypeEnum.LiveSubscription };
                    XOService service = XOService.Billing_Offering;
                    uint storeId = (uint)Store.Xbox360;
                    uint schemaVersion = live.protocol.WireData.MakeSchemaVersion(6, 6);
                    XblUser xblUser = new XblUser(User.UserPuid, User.GamerTag);
                    xblUser.Settings.UserPassportInfo.PassportPuid = UodbWS.GetUserPassportUserPuid(User.UserPuid);
                    ((Xbox360Client)client).UserLoggingOn(xblUser);

                    XePreviewProductPurchaseResponse resp;
                    string temp = PreviewPurchaseMediaOffersXrl(client, xblUser, new Guid[] { new Guid(offerGuid) }, mediaTypeIds,
                        purchaseOfferPaymentType, paymentInstId, storeId, service, token, schemaVersion, out resp);
                    if (!string.IsNullOrEmpty(temp))
                    {
                        throw new Exception("PreviewProductPurchase Failed with " + temp);
                    }

                    //OfferMediaExpected Price
                    uint wholePrice = 0;
                    uint fractionPrice = 0;
                    FeedSubscriptionOfferExt.SetFractionPrice((decimal)resp.offerPrice, out wholePrice, out fractionPrice);

                    ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice[] offers = new ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice[1];
                    offers[0] = new ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice();
                    offers[0].OfferId = new Guid(offerGuid);
                    offers[0].ExpectedPriceWhole = wholePrice;
                    offers[0].ExpectedPriceFractional = fractionPrice;
                    offers[0].MediaTypeId = (int)xonline.common.billing.MediaTypeInfo.LiveSubscription;

                    ServerTestFramework.LiveService.Billing.SubscriptionPurchaseInfo subInfo = new ServerTestFramework.LiveService.Billing.SubscriptionPurchaseInfo();
                    subInfo.subscriptionTimeExtendedInMonths = (uint)resp.previewSubscriptionInfo.timeExtendedinMonths;

                    XbosOffer.XePurchaseMediaOffer(User.UserPuid, (uint)StoreEnum.Xbox, offers,
                        purchaseOfferPaymentType, paymentInstId, token, subInfo, HResult.S_OK, null);

                    b = true;
                }
                catch (Exception e)
                {
                    outputString = "Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
                }
            }
            return b;
        }

        public bool VerifyToken(string code, out string outputString)
        {
            bool bSuccess = false;
            outputString = string.Empty;

            try
            {
                XRLXeVerifyTokenResponse response = XbosOffer.VerifyToken(User.UserPuid, XbosUser.DefaultMachinePuid, code, (uint)StoreEnum.Xbox);
                bool bUodbOffer = (response.OfferCatalogType == (ushort)ServerTestFramework.LiveService.Billing.OfferCatalogTypeEnum.Xbox);
                outputString = string.Format("A Token for {0}\n", bUodbOffer ? "Uodb Offer" : "Catalog Offer");
                if (bUodbOffer)
                {
                    outputString += string.Format("OfferId = {0}\nOfferType = {1}\n", response.XboxOfferInfo.OfferId, response.XboxOfferInfo.OfferTypeId);
                }
                else
                {
                    outputString += string.Format("OfferId = {0}\nMediaId = {1}\nMediaTypeId = {2}\n", response.EmsOfferInfo.OfferId, 
                        response.EmsOfferInfo.MediaId, response.EmsOfferInfo.MediaTypeId);
                }
                bSuccess = true;
            }
            catch (Exception e)
            {
                outputString = "Failed with Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
            }
            return bSuccess;
        }

        public static bool XeGetUserSubscriptionDetails(ulong userPuid, out string subDetails, out string outputString)
        {
            bool bSuccess = false;
            subDetails = string.Empty;
            outputString = string.Empty;
            
            try
            {
                ServerTestFramework.Database.SubscriptionInfo[] subs = UodbWS.GetUserServiceIDs( userPuid );
                foreach ( ServerTestFramework.Database.SubscriptionInfo subInfo in subs )
                {
                    // only active subscriptions
                    if ( subInfo.statusId == 1 )
                    {
                        XRLXeGetUserSubscriptionDetailsResponse response = UacsCommon.GetUserSubscriptionDetails( userPuid, (ulong)subInfo.offerId );
                        subDetails += PrintSubDetails( userPuid, response );
                        subDetails += "\r\n\r\n";
                    }
                }
                bSuccess = true;
            }
            catch (Exception e)
            {
                outputString = "Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
            }
            return bSuccess;
        }

        private static string PrintSubDetails(ulong userPuid, XRLXeGetUserSubscriptionDetailsResponse response)
        {
            StringBuilder output = new StringBuilder(200);
            output.Append(string.Format("User 0x{0:X}'s subscription details:\r\n", userPuid));
            output.Append(string.Format("\tSubscriptionId        : {0}\r\n", response.SubscriptionId));
            output.Append(string.Format("\tDescription           : {0}\r\n", response.Description));
            output.Append(string.Format("\tCurrentOfferStatus    : {0}\r\n", response.CurrentOfferStatus));
            output.Append(string.Format("\tFriendlyName          : {0}\r\n", response.FriendlyName));
            output.Append(string.Format("\tAnniversaryDate       : {0}\r\n", response.AnniversaryDate));
            output.Append(string.Format("\tPurchaseDate          : {0}\r\n", response.PurchaseDate));
            output.Append(string.Format("\tActivationDate        : {0}\r\n", response.ActivationDate));
            output.Append(string.Format("\tEndDate               : {0}\r\n", response.EndDate));
            output.Append(string.Format("\tHasViolations         : {0}\r\n", response.HasViolations));
            output.Append(string.Format("\tRenewalGracePeriod    : {0}\r\n", response.RenewalGracePeriod));
            output.Append(string.Format("\tRenewalOfferStatus    : {0}\r\n", response.RenewalOfferStatus));
            output.Append(string.Format("\tRenewalOfferId        : 0x{0:X}\r\n", response.RenewalOfferId));
            output.Append(string.Format("\tDelayedCancel        : {0}\r\n", response.delayedCancel.ToString()));
            output.Append(string.Format("\t--- Current Subscription Details ---"));
            output.Append(string.Format("\tCurrentOfferDetails.WholePart        : {0}\r\n", response.CurrentOfferDetails.WholePart));
            output.Append(string.Format("\tCurrentOfferDetails.FractionalPart   : {0}\r\n", response.CurrentOfferDetails.FractionalPart));
            output.Append(string.Format("\tCurrentOfferDetails.CurrencyFormat   : {0}\r\n", response.CurrentOfferDetails.CurrencyFormat));
            output.Append(string.Format("\tCurrentOfferDetails.IsoCode          : {0}\r\n", response.CurrentOfferDetails.IsoCode));
            output.Append(string.Format("\tCurrentOfferDetails.FormattedPrice   : {0}\r\n", response.CurrentOfferDetails.FormattedPrice));
            output.Append(string.Format("\tCurrentOfferDetails.OfferingDetails  : {0}\r\n", response.CurrentOfferDetails.OfferingDetails));
            output.Append(string.Format("\t--- Renewal Subscription Details ---"));
            output.Append(string.Format("\tRenewalOfferDetails.WholePart        : {0}\r\n", response.RenewalOfferDetails.WholePart));
            output.Append(string.Format("\tRenewalOfferDetails.FractionalPart   : {0}\r\n", response.RenewalOfferDetails.FractionalPart));
            output.Append(string.Format("\tRenewalOfferDetails.CurrencyFormat   : {0}\r\n", response.RenewalOfferDetails.CurrencyFormat));
            output.Append(string.Format("\tRenewalOfferDetails.IsoCode          : {0}\r\n", response.RenewalOfferDetails.IsoCode));
            output.Append(string.Format("\tRenewalOfferDetails.FormattedPrice   : {0}\r\n", response.RenewalOfferDetails.FormattedPrice));
            output.Append(string.Format("\tRenewalOfferDetails.OfferingDetails  : {0}\r\n", response.RenewalOfferDetails.OfferingDetails));
            output.Append(string.Format("\t--- Payment Instrument ---"));
            output.Append(string.Format("\tPaymentInstrument.PaymentInstrumentId      : {0}\r\n", response.PaymentInstrument.PaymentInstrumentId));
            output.Append(string.Format("\tPaymentInstrument.AddressInfo.Street1      : {0}\r\n", response.PaymentInstrument.AddressInfo.Street1));
            output.Append(string.Format("\tPaymentInstrument.AddressInfo.Street2      : {0}\r\n", response.PaymentInstrument.AddressInfo.Street2));
            output.Append(string.Format("\tPaymentInstrument.AddressInfo.City         : {0}\r\n", response.PaymentInstrument.AddressInfo.City));
            output.Append(string.Format("\tPaymentInstrument.AddressInfo.District     : {0}\r\n", response.PaymentInstrument.AddressInfo.District));
            output.Append(string.Format("\tPaymentInstrument.AddressInfo.State        : {0}\r\n", response.PaymentInstrument.AddressInfo.State));
            output.Append(string.Format("\tPaymentInstrument.AddressInfo.PostalCode   : {0}\r\n", response.PaymentInstrument.AddressInfo.PostalCode));
            output.Append(string.Format("\tPaymentInstrument.PhoneInfo.PhonePrefix    : {0}\r\n", response.PaymentInstrument.PhoneInfo.PhonePrefix));
            output.Append(string.Format("\tPaymentInstrument.PhoneInfo.PhoneNumber    : {0}\r\n", response.PaymentInstrument.PhoneInfo.PhoneNumber));
            output.Append(string.Format("\tPaymentInstrument.PhoneInfo.PhoneExtension : {0}\r\n", response.PaymentInstrument.PhoneInfo.PhoneExtension));
            output.Append(string.Format("\tPaymentInstrument.CreditCardInfo.CardType           : {0}\r\n", response.PaymentInstrument.CreditCardInfo.CardType));
            output.Append(string.Format("\tPaymentInstrument.CreditCardInfo.AccountHolderName  : {0}\r\n", response.PaymentInstrument.CreditCardInfo.AccountHolderName));
            output.Append(string.Format("\tPaymentInstrument.CreditCardInfo.AccountNumber      : {0}\r\n", response.PaymentInstrument.CreditCardInfo.AccountNumber));
            output.Append(string.Format("\tPaymentInstrument.CreditCardInfo.CcvNumber          : {0}\r\n", response.PaymentInstrument.CreditCardInfo.CcvNumber));
            output.Append(string.Format("\tPaymentInstrument.DirectDebitInfo.AccountHolderName : {0}\r\n", response.PaymentInstrument.DirectDebitInfo.AccountHolderName));
            output.Append(string.Format("\tPaymentInstrument.DirectDebitInfo.AccountNumber     : {0}\r\n", response.PaymentInstrument.DirectDebitInfo.AccountNumber));
            output.Append(string.Format("\tPaymentInstrument.DirectDebitInfo.BankCode          : {0}\r\n", response.PaymentInstrument.DirectDebitInfo.BankCode));
            output.Append(string.Format("\tPaymentInstrument.DirectDebitInfo.BranchCode        : {0}\r\n", response.PaymentInstrument.DirectDebitInfo.BranchCode));
            output.Append(string.Format("\tPaymentInstrument.DirectDebitInfo.CheckDigits       : {0}\r\n", response.PaymentInstrument.DirectDebitInfo.CheckDigits));

            return output.ToString();
        }

        public bool ValidateAllRenewOffers(string paymentInstrumentId, Guid[] offers, out string output)
        {
            bool bSuccess = true;
            string temp = string.Empty;
            StringBuilder outputStr = new StringBuilder(200);
            IClient client = new Xbox360Client();
            int[] mediaTypeIds = new int[] { (int)MediaTypeEnum.LiveSubscription };
            XOService service = XOService.Billing_Offering;
            uint storeId = (uint)Store.Xbox360;
            uint schemaVersion = live.protocol.WireData.MakeSchemaVersion(6, 6);
            XePreviewProductPurchaseResponse resp;

            XblUser xblUser = new XblUser(User.UserPuid, User.GamerTag);
            xblUser.Settings.UserPassportInfo.PassportPuid = UodbWS.GetUserPassportUserPuid(User.UserPuid);
            ((Xbox360Client)client).UserLoggingOn(xblUser);

            foreach (Guid offer in offers)
            {
                outputStr.Append(string.Format("\r\nValidate offer {0}:\r\n", offer));
                temp = PreviewPurchaseMediaOffersXrl(client, xblUser, new Guid[] { offer }, mediaTypeIds,
                    (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard, paymentInstrumentId, 
                    storeId, service, string.Empty, schemaVersion, out resp);
                if (!string.IsNullOrEmpty(temp))
                {
                    bSuccess = false;
                    outputStr.Append("\tFailed with " + temp);
                }
                else
                {
                    outputStr.Append("\tPassed.");
                }
            }
            output = outputStr.ToString();
            return bSuccess;
        }

        private string PreviewPurchaseMediaOffersXrl(IClient client, XblUser xblUser, Guid[] offerIds,
            int[] mediaTypeIds, uint paymentType, string paymentInstrumentId,
            uint storeId, XOService service, string billingToken, uint schemaversion, out XePreviewProductPurchaseResponse resp)
        {
            XePreviewProductPurchaseRequest req = new XePreviewProductPurchaseRequest();
            resp = new XePreviewProductPurchaseResponse();
            resp.SchemaVersion = schemaversion;
            req.SchemaVersion = schemaversion;
            req.machinePuid = client.MachinePuid;
            req.userPuid = xblUser.Puid;

            live.protocol.next.OfferProductInfo[] offers = new live.protocol.next.OfferProductInfo[offerIds.Length];
            for (int ii = 0; ii < offerIds.Length; ii++)
            {
                offers[ii] = new live.protocol.next.OfferProductInfo();
                offers[ii].productTypeId = mediaTypeIds[ii];
                offers[ii].offerId = offerIds[ii];
            }

            req.offers = offers;
            req.paymentType = paymentType;
            req.paymentInstrumentID = paymentInstrumentId;
            req.storeId = storeId;
            req.billingToken = billingToken;
            req.billingTokenLength = (string.IsNullOrEmpty(billingToken)) ? (ushort)0 : (ushort)billingToken.Length;

            string output = null;
            uint actualResult = HResult.E_FAIL;
            try
            {
                actualResult = live.server.Billing.SendRequest(client, xblUser, service, req, resp);
            }
            catch (live.common.XrlRequestException ex)
            {
                output = (string.Format("Purchase of offer failed with: {0}, \n Exception: {1} \n {2}", ex.Message, ex.RespData, ex.InnerException));
            }
            catch (live.common.XErrFailedException xerr)
            {
                output = (string.Format("Purchase of offer failed with: {0}, \n Exception: {1} ", xerr.Message, xerr.InnerException));
            }
            catch (Exception ex1)
            {
                output = (string.Format("Purchase of offer failed with: {0}, Exception: {1} ", ex1.Message, ex1.InnerException));
            }

            if (actualResult != HResult.S_OK)
            {
                output += string.Format(" \"The error code is 0x{0:X}\"", actualResult);
            }

            // update the Subscription with timeExtendedinMonths
            if (string.IsNullOrEmpty(output))
            {
                for (int i = 0; i < SubOffers.Length; i++)
                {
                    if (offerIds[0] == SubOffers[i].offerId)
                    {
                        SubOffers[i].SubExtendMonths = resp.previewSubscriptionInfo.timeExtendedinMonths;
                        break;
                    }
                }
            }

            return output;
        }

        public bool DelayedCancel(Guid offerGuid, out string outputString)
        {
            bool b = true;
            outputString = "";
            XRLOfferingCancel xrlCancel = new XRLOfferingCancel();
            xrlCancel.userPuid = User.UserPuid;
            FeedSubscriptionOfferExt sub = GetFeedSubOfferExt(offerGuid);
            xrlCancel.offeringId = sub.legacyOfferId;
            try
            {
                b = xrlCancel.Execute();
            }
            catch (Exception e)
            {
                outputString = "Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
                throw e;
            }
            if (!b)
            {
                outputString += "XErr: " + ServerTestFramework.Global.XErrToString(xrlCancel.XErr) + " HTTP:" + xrlCancel.httpStatus;
            }
            return b;
        }

        public bool Disable(Guid offerGuid, int status, out string outputString)
        {
            bool b = true;
            outputString = "";
            if (status == 5) // DelayedCancel
            {
                return DelayedCancel(offerGuid, out outputString);
            }

            XRLDisableSubscription xrlDS = new XRLDisableSubscription();
            FeedSubscriptionOfferExt sub = GetFeedSubOfferExt( offerGuid );
            ulong offerId = sub.legacyOfferId;
            xrlDS.UserPuid = User.UserPuid;
            xrlDS.ServiceInstanceId = UodbWS.GetUsersAndOffersSubscriptionInstanceId( User.UserPuid, offerId );
            xrlDS.SubscriptionStatusId = status;
            xrlDS.AddViolation = ( status == (int)ServerTestFramework.Database.SubscriptionStatus.Suspended );
            xrlDS.ManualPopulateSlot();
            xrlDS.Slot.machinePuid = 0xfa00000012341234;

            try
            {
                b = xrlDS.Execute();
                //Waiting for SCG to enforce status change
                UodbWS.WaitForCallback( User.UserPuid, offerId );
            }
            catch ( Exception e )
            {
                outputString = "Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException + "\n";
                throw e;
            }
            if ( !b )
            {
                outputString += "XErr: " + ServerTestFramework.Global.XErrToString( xrlDS.XErr ) + " HTTP:" + xrlDS.httpStatus;
            }
            return b;
        }
        
        private ulong SetQueryFlags()
        {
            ulong flag = 0;
            foreach (QueryType qt in SubscriptionForm.QueryTypes)
            {
                switch (qt)
                {
                    case QueryType.QueryForCurrent:
                        {
                            if ((QueryFlags & (uint)QueryType.QueryForCurrent) != 0)
                            {
                                flag = flag | QueryFlags;
                            }
                            break;
                        }
                    case QueryType.QueryForNew:
                        {
                            if ((QueryFlags & (uint)QueryType.QueryForNew) != 0)
                            {
                                flag = flag | QueryFlags;
                            }
                            break;
                        }
                    case QueryType.QueryForConvert:
                        {
                            if ((QueryFlags & (uint)QueryType.QueryForConvert) != 0)
                            {
                                flag = flag | QueryFlags;
                            }
                            break;
                        }
                }
            }
            return flag;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SubscriptionTestTool.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("SubscriptionTestTool.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TcpRelay\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TcpRelay\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tcprelay_none_12.4.56.0_none_e6374c3f4b7e9cc9
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tcprelay
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.manifest
XP_MANIFEST_PATH=manifests\msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.cat
XP_CATALOG_PATH=manifests\msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.cat
XP_PAYLOAD_PATH=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tcprelay,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TcpRelay\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tcprelay_none_12.4.56.0_none_e6374c3f4b7e9cc9
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tcprelay
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.manifest
XP_MANIFEST_PATH=manifests\msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.cat
XP_CATALOG_PATH=manifests\msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3.cat
XP_PAYLOAD_PATH=msil_tcprelay_no-public-key_12.4.56.0_x-ww_91f0ecd3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tcprelay,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TcpRelay\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\SubscriptionForm.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Text.RegularExpressions;
using System.Reflection;
using System.Windows.Forms;

namespace SubscriptionTestTool
{
    public partial class SubscriptionForm : Form
    {
        enum SubStatus
        {
            Suspend = 2,
            Expire = 3,
            Cancel = 4,
            DelayedCancel = 5
        };

        #region private
        private const int QUERYTYPESTOTAL = 3;
        private Subscriptions Subs;
        private uint selectedQuery = 0;        
        #endregion

        #region publicattributes
        public static uint[] QueryTypes;
        #endregion

        #region properties
        public uint SelectedQuery
        {
            set
            {
                selectedQuery = value;
            }
            get
            {
                return selectedQuery;
            }
        }
        #endregion

        private void BuildTypeArrays()
        {
            //populate an array for querytype
            FieldInfo[] fInfo1 = typeof(QueryType).GetFields();
            QueryType qt = new QueryType();
            QueryTypes = new uint[QUERYTYPESTOTAL];
            for (int i = 1; i <= QUERYTYPESTOTAL; i++)
            {
                QueryTypes[i - 1] = (uint)fInfo1[i].GetValue(qt);
            }
        }

        private void PopulateBoxes()
        {
            //populate the QueryListBox
            foreach (QueryType qt in QueryTypes)
            {
                this.queryTypeListBox.Items.Add(qt.ToString());
            }

            // populate the PaymentType ListBox
            this.comboBoxPaymentType.Items.Add("CreditCard");
            this.comboBoxPaymentType.Items.Add("Token");
            this.comboBoxPaymentType.SelectedIndex = 0;

            //Set the default titleid textbox to 0
            this.titleIdTextBox.Text = "0";
        }

        public SubscriptionForm()
        {
        }

        public void SubFormInit(LiveUser user)
        {
            InitializeComponent();
            BuildTypeArrays();
            PopulateBoxes();
            SelectedQuery = 0;
            Subs = new Subscriptions();
            Subs.User = user;
        }

        private void queryTypeListBox_SelectedItems()
        {
            SelectedQuery = 0;
            for (int i = 0; i < this.queryTypeListBox.SelectedItems.Count; i++)
            {
                SelectedQuery |= (uint)Enum.Parse(typeof(QueryType), this.queryTypeListBox.SelectedItems[i].ToString(), true);
            }
        }

        private void enumerateButton_Click(object sender, EventArgs e)
        {
            queryTypeListBox_SelectedItems();

            if (SelectedQuery == 0)
            {
                MessageBox.Show("No query flag is selected.");
                return;
            }

            string outputString;
            if (this.titleIdTextBox.Text == "")
                this.titleIdTextBox.Text = "0";
            try
            {
                Subs.EnumerateSetup(SelectedQuery, uint.Parse(titleIdTextBox.Text, System.Globalization.NumberStyles.HexNumber));
            }
            catch (FormatException fe)
            {
                MessageBox.Show("TitleID format exception (try without 0x)" + "\n" + fe.Message);
            }

            this.enumerateButton.Enabled = false;
            bool returnVal = Subs.SubscriptionOfferEnumerate(out outputString);
            if (!returnVal)
            {
                MessageBox.Show("No Subscription could be enumerated: " + outputString);
            }
            PopulateSubscriptionComboBox();
            this.enumerateButton.Enabled = true;
        }

        private void PopulateSubscriptionComboBox()
        {
            this.subscriptionsComboBox.SelectedText = "";
            this.subscriptionsComboBox.Items.Clear();
            for (int i = 0; i < Subs.SubOffers.Length; i++)
            {
                this.subscriptionsComboBox.Items.Add(Subs.SubOffers[i].offerId + "|" + Subs.SubOffers[i].OfferName);
            }
        }

        private static bool VerifyTokenFormat(string token)
        {
            // The valid token format is ?????-?????-?????-?????-????N format. (Last character must be N).
            // Where ? is 0-9, A-Z without 0,1,2,5,A,E,I,O,U,N,L,S,Z
            return (Regex.IsMatch(token, @"^[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{4}N$"));
        }

        private void VerifyTokenButton_Click(object sender, EventArgs e)
        {
            string tokenCode = this.textBoxTokenCode.Text.Trim();
            if (string.IsNullOrEmpty(tokenCode) || tokenCode.Length > 29)
            {
                MessageBox.Show("The token code is empty or invalid.");
                return;
            }

            this.VerifyTokenButton.Enabled = false;
            string outputString = string.Empty;
            Subs.VerifyToken(tokenCode, out outputString);
            MessageBox.Show(outputString);
            this.VerifyTokenButton.Enabled = true;
        }

        private void purchaseButton_Click(object sender, EventArgs e)
        {
            string outputString = string.Empty;
            string paymentInstrumentId = null;
            string tokenCode = this.textBoxTokenCode.Text.Trim();
            string offerGuid = this.textBoxOfferGuid.Text.Trim();
            string paymentType = this.comboBoxPaymentType.SelectedItem.ToString();

            // get the offer guid
            if (string.IsNullOrEmpty(offerGuid))
            {
                offerGuid = (this.subscriptionsComboBox.SelectedItem == null) ? "" : this.subscriptionsComboBox.SelectedItem.ToString();
                offerGuid = (string.IsNullOrEmpty(offerGuid)) ? "" : offerGuid.Substring(0, offerGuid.IndexOf('|'));
            }
            if (string.IsNullOrEmpty(offerGuid))
            {
                MessageBox.Show("OfferGuid is not provided. Or no subscripiton is selected in Enumerated Subscriptions List.");
                return;
            }

            // make sure token code is supplied for Token payment type
            if (paymentType == "Token")
            {
                if (string.IsNullOrEmpty(tokenCode) || tokenCode.Length > 29)
                {
                    MessageBox.Show("PaymentType is Token. But the token code is empty or invalid.");
                    return;
                }
            }
            // make sure CreditCard payment type has PI ready
            else
            {
                // get the payment instrument id to use
                paymentInstrumentId = (this.piComboBox.SelectedItem == null) ? "" : this.piComboBox.SelectedItem.ToString();
                if (string.IsNullOrEmpty(paymentInstrumentId))
                {
                    MessageBox.Show("PaymentType is CreditCard. But no payment instrument is selected.");
                    return;
                }
                tokenCode = null;
            }

            this.purchaseButton.Enabled = false;
            if (!Subs.Purchase(offerGuid, paymentInstrumentId, tokenCode, out outputString))
                MessageBox.Show("Purchase call failed: " + outputString);
            this.purchaseButton.Enabled = true;
        }

        private void previewButton_Click(object sender, EventArgs e)
        {
            string outputString;

            // get the payment instrument id to use
            string paymentInstrumentId = (this.piComboBox.SelectedItem == null) ? "" : this.piComboBox.SelectedItem.ToString();
            if (string.IsNullOrEmpty(paymentInstrumentId))
            {
                MessageBox.Show("No payment instrument is selected.");
                return;
            }

            List<Guid> offers = new List<Guid>();
            foreach (string offer in this.subscriptionsComboBox.Items)
            {
                string offerGuid = offer.Substring(0, offer.IndexOf('|'));
                offers.Add(new Guid(offerGuid));
            }

            if (offers.Count < 1)
            {
                MessageBox.Show("Either the subscription list is empty or there is no credit card based subscription.");
                return;
            }

            this.previewButton.Enabled = false;

            //call the PreviewProductPurchase functionality in the Subscriptions object
            if (!Subs.ValidateAllRenewOffers(paymentInstrumentId, offers.ToArray(), out outputString))
                MessageBox.Show("PreviewProductPurchase Calls Results: " + outputString);
            else
                MessageBox.Show("All validation passed.");

            this.previewButton.Enabled = true;
        }

        private SubStatus SubscriptionStatusChangeRequest()
        {
            if (radioSuspendButton.Checked)
                return SubStatus.Suspend;
            else if (radioExpireButton.Checked)
                return SubStatus.Expire;
            else if (radioCancelButton.Checked)
                return SubStatus.Cancel;
            else if (radioDelayedCancelButton.Checked)
                return SubStatus.DelayedCancel;
            else
                return SubStatus.Cancel;
        }

        private void disableButton_Click(object sender, EventArgs e)
        {
            string outputString;
            int changeStatus = (int)SubscriptionStatusChangeRequest();

            string offerGuid = (this.subscriptionsComboBox.SelectedItem == null) ? "" : this.subscriptionsComboBox.SelectedItem.ToString();
            offerGuid = offerGuid.Substring( 0, offerGuid.IndexOf( '|' ) );
            if ( string.IsNullOrEmpty( offerGuid ) )
            {
                MessageBox.Show("Query for current first. Then select your current subscripiton.");
                return;
            }

            this.disableButton.Enabled = false;
            try
            {
                if (!Subs.Disable(new Guid(offerGuid), changeStatus, out outputString))
                {
                    MessageBox.Show("Disable call failed: " + outputString);
                }
                else
                {
                    MessageBox.Show("Disable succeeded!");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Disable call failed: " + "\n" + ex.Message);
            }
            this.disableButton.Enabled = true;
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            Subs = null;            
            this.Close();
        }

        private void piEnumButton_Click(object sender, EventArgs e)
        {
            this.piEnumButton.Enabled = false;
            bool returnVal = true;
            string outputString;
            returnVal = Subs.EnumeratePI(out outputString);
            if (!returnVal)
            {
                MessageBox.Show("No PI could be enumerated: " + outputString);
            }
            PopulatePIComboBox();
            this.piEnumButton.Enabled = true;
        }
      
        private void PopulatePIComboBox()
        {
            this.piComboBox.SelectedText = "";
            this.piComboBox.Items.Clear();
            if (Subs.xrlXGPIR != null)
            {
                for (int i = 0; i < Subs.xrlXGPIR.PaymentInstrumentCount; i++)
                {
                    this.piComboBox.Items.Add(Subs.xrlXGPIR.PaymentInstrumentInfo[i].PaymentInstrumentId);
                }
            }            
        }

        private void addPIButton_Click(object sender, EventArgs e)
        {
            this.addPIButton.Enabled = false;
            string outputString;
            string retVal = Subs.AddPI(out outputString);
            if (retVal.CompareTo("") == 0)
            {
                MessageBox.Show("Unable to add PI: " + outputString);
            }
            else
            {
                MessageBox.Show("Payment Instrument id: " + retVal + " added");
            }
            this.addPIButton.Enabled = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TcpRelay\main.cs ===
using System;
using System.Xml;
using System.ComponentModel;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;

namespace TcpRelayTool
{
    class TcpRelayTool
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            // Parameters
            string remoteHost;
            ushort remotePort;
            ushort localListenPort;
            bool verbose=false;

            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Parse command line
            if (Environment.GetCommandLineArgs().Length<4 || Environment.GetCommandLineArgs().Length>5)
            {
                Console.WriteLine("Usage: TcpRelay RemoteHost RemotePort LocalListenPort [option0,option1,etc]");
                Console.WriteLine("  RemoteHost: The target to relay connections to.");
                Console.WriteLine("  RemotePort: The target port to conect on.");
                Console.WriteLine("  LocalListenPort: The local port to listen on.");
                Console.WriteLine("  ");
                Console.WriteLine("  Options: verbose");
                return;
            }

            remoteHost=Environment.GetCommandLineArgs()[1];
            remotePort=ushort.Parse(Environment.GetCommandLineArgs()[2]);
            localListenPort=ushort.Parse(Environment.GetCommandLineArgs()[3]);

            if (Environment.GetCommandLineArgs().Length==5)
            {
                string optionsString=Environment.GetCommandLineArgs()[4].ToLower();
                string []options=optionsString.Split(new char[]{','});

                foreach (string opt in options)
                {
                    if (opt=="verbose") verbose=true;
                }
            }

            //Run the relay
            TcpRelay relay=new TcpRelay(remoteHost, remotePort, localListenPort);

            if (verbose) relay.Verbose=true;

            try
            {
                while (true)
                {
                    System.Threading.Thread.Sleep(1000);
                }
            }
            finally
            {
                relay.Dispose();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SubscriptionTestTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("SubscriptionTestTool")]
//[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fce4e1f9-18b1-4f4d-954b-39df6ffe87ca")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\SubscriptionTestTool\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SubscriptionTestTool.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TiWiz\TestTemplate\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by #TestName#.rc
//

#define IDS_PROJNAME                    100
#define IDR_#TESTNAME#                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TiWiz\TestTemplate\TestInter.h ===
#pragma once
#include "stdafx.h"
#include "resource.h"
#include "testinterlib.h"
#include "ti.h"


class ATL_NO_VTABLE TestInter : public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<TestInter, &CLSID_#TestName#>,
    public IDispatchImpl<ITestInter, &IID_ITestInter, &LIBID_TestInter, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
    TestInter()
    {
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_#TESTNAME#)
    BEGIN_COM_MAP(TestInter)
        COM_INTERFACE_ENTRY(ITestInter)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    HRESULT FinalConstruct()
    {
        return S_OK;
    }

    void FinalRelease()
    {
    }

    STDMETHOD(Initialize)(void) {return til.Initialize();}
    STDMETHOD(StartTest)(BSTR ReportObject, BSTR TestList, BSTR Settings) {return til.StartTest(ReportObject, TestList, Settings);}
    STDMETHOD(Uninitialize)(void) {return til.Uninitialize();}
    STDMETHOD(QueryTests)(BSTR* TestList) {return til.QueryTests(TestList);}
    STDMETHOD(Terminate)(void) {return til.Terminate();}

private:
    TestInterLib til;

};
OBJECT_ENTRY_AUTO(__uuidof(#TestName#), TestInter)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TiWiz\TestTemplate\TestTemplate.cpp ===
#include "stdafx.h"
#include "#testname#.h"


TestInterface *TestImpl::Make()
{
    return new #TestName#();
}

HRESULT #TestName#::TestInitialize()
{
    TiDebug::PrintLine("#TestName#::TestInitialize() entered.");

    return S_OK;
}

HRESULT #TestName#::TestStart(IN IReport *pReport, IN SVector<char*> &vctszTests, IN TiSettings &tis)
{
    TiDebug::PrintLine("#TestName#::TestStart() entered.");

    pReport->Initialize(L"#TestName#");

    SVector<TiKeyValue*> vcttkvServerIps;
    tis.getServerIpList(vcttkvServerIps);
    TiDebug::PrintLine("  Printing server list:");
    for (int j = 0; j < vcttkvServerIps.Count(); j++)
    {
        TiDebug::Print("    %s: %x", vcttkvServerIps[j]->getKey()+7, vcttkvServerIps[j]->toIp());
        if (vcttkvServerIps[j]->toPort())
        {
            TiDebug::Print(", port: %d", vcttkvServerIps[j]->toPort());
        }
        TiDebug::PrintLine();
    }
    TiDebug::PrintLine();

    TiDebug::PrintLine("  Printing all tests and settings:");
    for (int i = 0; i < vctszTests.Count(); i++)
    {
        char *szTestName = vctszTests[i];

        wchar_t wcT[256];
        swprintf(wcT, L"%S (my category)", szTestName);
        pReport->Log(REPORTLOG_INFO, wcT, L"(my subcategory)", L"(my variation)", L"(my notes)");

        TiDebug::Print("  %s -- ", szTestName);
        if (tis[vctszTests[i]])
        {
            for (int j = 0; j < tis[szTestName]->Count(); j++)
            {
                TiDebug::Print("{%s=%s}", (*tis[szTestName])[j]->getKey(), (*tis[szTestName])[j]->toString());
                if (j < tis[szTestName]->Count() - 1)
                {
                    TiDebug::Print(", ");
                }
            }
        }
        TiDebug::PrintLine();

        int nTime = tis.getSetting(szTestName, "time")->toInt();
        TiDebug::PrintLine("    getSetting(%s, time) = %d", szTestName, nTime);
    }
    TiDebug::PrintLine();

    pReport->Log(REPORTLOG_PASS, L"", L"", L"", L"");

    pReport->Uninitialize();

    return S_OK;
}

HRESULT #TestName#::TestUninitialize()
{
    TiDebug::PrintLine("#TestName#::TestUninitialize() entered.");

    return S_OK;
}

HRESULT #TestName#::TestQuery(IN OUT SVector<char*> &vctszTests)
{
    return E_NOTIMPL;
}

HRESULT #TestName#::TestTerminate()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TiWiz\TestTemplate\TestInterEntry.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    TestInterEntry.cpp

Abstract:

    DLL entry points for the library.

Author:

    Josh Poley (jpoley)

Revision History:

Notes:

    All testinter objects support the following interface:
        [propget, id(1)] HRESULT outputLevel([out, retval] ULONG* pVal);
        [propput, id(1)] HRESULT outputLevel([in] ULONG newVal);
        [id(2)] HRESULT Initialize([in] BSTR name);
        [id(3)] HRESULT Log([in] ULONG level, [in] BSTR category, [in] BSTR subcategory, [in] BSTR variation, [in] BSTR notes);
        [id(4)] HRESULT Uninitialize(void);

*****************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "TestInter.h"

// include the class IDs for the objects in this library
#include "testinterlib_i.c"

class CTestInterModule : public CAtlDllModuleT< CTestInterModule >
    {
    public :
        DECLARE_LIBID(LIBID_TestInter)
        DECLARE_REGISTRY_APPID_RESOURCEID(IDR_#TESTNAME#, "{001EEBDD-67F0-462F-8614-5DFF222FD8F6}")
    };
CTestInterModule _Module;


// DLL Entry Point
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
    {
    hInstance;
    return _Module.DllMain(dwReason, lpReserved); 
    }


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
    {
    return _Module.DllCanUnloadNow();
    }


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
    return _Module.DllGetClassObject(rclsid, riid, ppv);
    }


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
    {
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.DllRegisterServer();
    return hr;
    }


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
    {
    HRESULT hr = _Module.DllUnregisterServer();
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TiWiz\TestTemplate\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef STRICT
#define STRICT
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS

#define _ATL_FREE_THREADED

#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>

using namespace ATL;

#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TiWiz\TestTemplate\TestTemplate.h ===
#pragma once
#include "stdafx.h"
#include "ti.h"


class #TestName# : public TestInterface
{
public:

    virtual HRESULT TestInitialize();
    virtual HRESULT TestStart(IN IReport *pReport, IN SVector<char*> &vctszTests, IN TiSettings &tis);
    virtual HRESULT TestUninitialize();
    virtual HRESULT TestQuery(IN OUT SVector<char*> &vctszTests);
    virtual HRESULT TestTerminate();

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TokenImportTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TokenImportTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TokenImportTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tokenimporttest_none_12.4.56.0_none_1111636bb06f513d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tokenimporttest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.manifest
XP_MANIFEST_PATH=manifests\msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.cat
XP_CATALOG_PATH=manifests\msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.cat
XP_PAYLOAD_PATH=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tokenimporttest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TokenImportTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tokenimporttest_none_12.4.56.0_none_1111636bb06f513d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tokenimporttest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.manifest
XP_MANIFEST_PATH=manifests\msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.cat
XP_CATALOG_PATH=manifests\msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693.cat
XP_PAYLOAD_PATH=msil_tokenimporttest_no-public-key_12.4.56.0_x-ww_7db47693
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tokenimporttest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\Class1.cs ===
using System;
using System.Text;
using System.IO;
using System.Threading;

namespace UserIntegrity
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		/// 
		[STAThread]
		static int Main(string[] args)
		{
			Console.WriteLine("UserIntegrity tool v1");
			UserTableIntegrity UTI=new UserTableIntegrity();
			UTI.Go();
			Console.WriteLine("Done! "+UTI.ErrorsFound+" errors found.".PadRight(40));
			return UTI.ErrorsFound;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\TokenImportTest\TokenImportTest.cs ===
using System;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;

namespace TokenImportTest
{
	class TokenImportTest
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			TITests tests = new TITests();
			tests.Run(args);
		}
	}

	public class CommandLineParser
	{
		private string[] validArgs = new string[] {"/?", "/pause", "/importDataOnly", "/app:", "/minSeq:", "/maxSeq:", "/tokenfile:", "/offerid:", "/env:"};
		private string[] args;
		
		public CommandLineParser(string[] args)
		{
			this.args = args;
		}

		public StringDictionary GetArgsDictionary()
		{
			StringDictionary dict = new StringDictionary();

			foreach (string arg in args)
			{
				bool valid = false;
				foreach(string validArg in validArgs)
				{
					if (arg.StartsWith(validArg))
					{
						if (validArg.EndsWith(":"))
						{
							string[] pieces = arg.Split(":".ToCharArray(), 2);
							dict.Add(pieces[0].ToLower(), pieces[1]);
						}
						else
						{
							dict.Add(arg.ToLower(), "");
						}
						valid = true;
						break;
					}
				}
				if (!valid)
				{
					throw new Exception("Invalid argument: " + arg);
				}
			}
			return(dict);
		}
	}

	/// <summary>
	/// TIConfig hosts global test case configuration data retrieved from the command line
	/// </summary>
	public class TIConfig
	{
		public static string TIFileName = "TokenImport.exe";
		public static string TokenFile;
		public static string OfferId;
		public static ulong MinSeq = 0;
		public static ulong MaxSeq = ulong.MaxValue;
        public static string Environment = "";
	}

	public class TITests
	{
		bool pauseOnExit = false;
		bool importDataOnly = false;

		public void Run(string[] args)
		{
			if (ProcessArgs(args))
			{
                InitSTF();
				ExecuteTests();
				Console.WriteLine("Finished");
			}

			if (pauseOnExit)
			{
				Console.WriteLine("Press any key to continue.");
				Console.Read();
			}
			return;
		}

        private void InitSTF()
        {
            // Initialize the STF
            string env = TIConfig.Environment.ToLower();
            XmlDocument config = new XmlDataDocument();
            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException)
            {
                Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
                return;
            }
            CoreGlobal.Initialize(config);

            bool found = false;
            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                if (npdbSetting.Environment.ToLower() == env)
                {
                    Global.CurrentEnvironment = npdbSetting;
                    found = true;
                }
            }
            if (!found)
            {
                Console.WriteLine("Error - unknown environment '{0}' specified (not in stf.xml?).", env);
                return;
            }

            Global.ResetEnvironment();
        }

		private void PrintHelp()
		{
			Console.WriteLine(@"TokenImportTest

/?		This usage information
/pause             Pause on exit ('press any key to continue').  (Def: no pause)
/app:<file>        Optional. File path and name of TokenImport tool.  (Def: .\TokenImport.exe)
/minSeq:<ulong>    Required. Used by import tests to confirm minimum sequence handling works.
/maxSeq:<ulong>    Required. Used by import tests to confirm maximum sequence handling works.
/tokenfile:<file>  Required. Used by most of the import tests.
/offerid:<hex>     Required. Used in conjunction with the token file to test import succeeds.
/env:<environment> Required. Used to switch between test environments or xblobs. For xblob, it should be the name of xblob.
/importDataOnly    Optional. Specifies only import tests using a data file are to be executed. (Def: run all tests)

Example:  TokenImportTest.exe /pause /importDataOnly /tokenfile:01099_Z06-01015_5K_5fee7f4d_XBXTC-00003.txt /offerid:0xfffe07d18000001a /minSeq:01099001196000 /maxSeq:01099001197000 /env:testnet

Note:  After a complete run, it is possible to retest import with different data files. /importDataOnly will
execute only those tests which actually import data from a valid data file.");
		}

		private bool ProcessArgs(string[] args)
		{
			// If anything goes wrong processing the command line, we'll still try to respect /pause
			foreach (string arg in args)
			{
				if (arg == "/pause")
				{
					pauseOnExit = true;
				}
			}

			CommandLineParser clp = new CommandLineParser(args);
			StringDictionary dict = null;
			try
			{
				dict = clp.GetArgsDictionary();
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
				PrintHelp();
				return(false);
			}

			if (dict["/?"] != null)
			{
				PrintHelp();
				return(false);
			}

			if (dict["/importdataonly"] != null)
			{
				importDataOnly = true;
			}

			if (dict["/app"] != null)
			{
				Console.WriteLine("WARNING:  /app currently ignored");
				//TIConfig.TIFileName = dict["/app"];
			}

			if (dict["/tokenfile"] == null)
			{
				Console.WriteLine("Must supply a valid /tokenfile value (see token data file for possible values)");
				return(false);
			}
			TIConfig.TokenFile = dict["/tokenfile"];

			if (dict["/offerid"] == null)
			{
				Console.WriteLine("Must supply a valid /offerid value (see token data file for possible values)");
				return(false);
			}
			TIConfig.OfferId = dict["/offerid"];

			if (dict["/minseq"] == null)
			{
				Console.WriteLine("Must supply a valid /minseq value (see token data file for possible values)");
				return(false);
			}
			TIConfig.MinSeq = ulong.Parse(dict["/minseq"]);

			if (dict["/maxseq"] == null)
			{
				Console.WriteLine("Must supply a valid /maxseq value (see token data file for possible values)");
				return(false);
			}
			TIConfig.MaxSeq = ulong.Parse(dict["/maxseq"]);

            if (dict["/env"] == null)
            {
                Console.WriteLine("Must supply a valid /env value (see stf.xml file for possible values)");
                return (false);
            }
            TIConfig.Environment = dict["/env"];

            return (true);
		}

		private void RunCase(TITestCaseBase TestCase)
		{
			Console.Write("Executing {0}: ", TestCase.GetTestName());
			TIResult result = TestCase.Execute();
			Console.WriteLine(result.ToString());
		}

		public void ExecuteTests()
		{
			// Command Line Test Cases
			RunCase(new P_VerifyImport_Mainline());
			RunCase(new P_VerifyImport_NoPrefix());
			RunCase(new P_VerifyImport_MinSeq());
			RunCase(new P_VerifyImport_MaxSeq());
			RunCase(new P_VerifyImport_MinAndMaxSeq());

			if (!importDataOnly)
			{
				RunCase(new P_VerifyHelp());
				RunCase(new N_VerifyDisableExits());
				RunCase(new N_VerifyEnableExits());
				RunCase(new N_VerifyDeleteExits());
				RunCase(new N_VerifyViewExits());
				RunCase(new N_VerifySummaryExits());
				RunCase(new N_VerifyInvalidArgExits());
				RunCase(new N_VerifyTwoCommandArgsExits());
				RunCase(new N_VerifyImportNoOfferIDExits());
				RunCase(new N_VerifyImportOfferIDWithoutValueExits());
				RunCase(new N_VerifyImportInvalidlyFormattedOfferIDExits());
			}
		}
	}

	public enum TIResult { PASSED, FAILED, NOT_EXECUTED };

	public abstract class TITestCaseBase
	{
		const string HEADER_PATTERN = @"(^\r\nTokenImport run on: \d+/\d+/\d+ \d+:\d+:\d+ \wM\r\n)(.*)";
		protected static Regex headerRegex = new Regex(HEADER_PATTERN, RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.Singleline);

		protected string cmdLine;
		protected string expectedOutput;

		protected TITestCaseBase(string cmdLine, string expectedOutput)
		{
			this.cmdLine = cmdLine;
			this.expectedOutput = expectedOutput;
		}

		public string GetTestName()
		{
			Type myType = this.GetType();
			return(myType.Name);
		}

		protected virtual void Initialize()
		{
			return;
		}

		protected Process StartProcess()
		{
			ProcessStartInfo psi = new ProcessStartInfo();
			psi.FileName = TIConfig.TIFileName;
			psi.Arguments = cmdLine;
			psi.RedirectStandardOutput = true;
			psi.UseShellExecute = false;
                        Console.WriteLine("Executing:" + psi.FileName + " " + psi.Arguments);
			return(Process.Start(psi));
		}

		public virtual TIResult Execute()
		{
			TIResult result = TIResult.NOT_EXECUTED;

			try
			{
				Initialize();
				// Run TokenImport
				Process proc = StartProcess();
				proc.WaitForExit();

				string output = proc.StandardOutput.ReadToEnd();

				if (Verify(output))
				{
					result = TIResult.PASSED;
				}
				else
				{
					result = TIResult.FAILED;
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			return(result);
		}

		protected bool VerifyAndRemoveHeader(ref string output)
		{
			// Consume standard output header ("\r\nTokenImport run on: 9/28/2005 5:41:01 PM\r\n")
			Match m = headerRegex.Match(output);
			Debug.Assert(m.Success, "Header regex failed");
			output = m.Groups[2].ToString();
			return(m.Success);
		}

		protected bool VerifyBodyWithRegex(string output)
		{
			Regex regex = new Regex(expectedOutput);
			Match m = regex.Match(output);
			return(m.Success);
		}

		protected virtual bool Verify(string output)
		{
                    Console.WriteLine("OUTPUT FOLLOWS:");
                    Console.WriteLine(output);
			if (!VerifyAndRemoveHeader(ref output))
			{
				return(false);
			}
			
			bool passed;
			if (expectedOutput.StartsWith("regex:"))
			{
				// Expected output is in the form of a regular expression
				expectedOutput = expectedOutput.Replace("regex:", "");
				passed = VerifyBodyWithRegex(output);
			}
			else
			{
				// Expected output is plain text
				passed = (output == expectedOutput);
			}
			return(passed);
		}
	}

#region TITestCases
	public class P_VerifyImport_Mainline : TITestCaseBase
	{
		static string MATCH_ON = "regex:\r\nToken File: " + TIConfig.TokenFile + "\r\nOffer ID: " + TIConfig.OfferId + @"[\r\n\.\d]+";
		public P_VerifyImport_Mainline() : base("/import /file:" + TIConfig.TokenFile + " /offerid:" + TIConfig.OfferId, MATCH_ON) {}

		protected override void Initialize()
		{
			TokendbWS.DeleteUnactivatedBillingTokens(TIConfig.OfferId);
		}

		protected override bool Verify(string output)
		{
            if (TokendbWS.VerifySequenceRange(TIConfig.OfferId, uint.MinValue, uint.MaxValue))
			{
				if (base.Verify(output))
				{
					return(true);
				}
			}
			return(false);
		}
	}

	public class P_VerifyImport_NoPrefix : TITestCaseBase
	{
		static string MATCH_ON = "regex:\r\nToken File: " + TIConfig.TokenFile + "\r\nOffer ID: " + TIConfig.OfferId + @"[\r\n\.\d]+";
		public P_VerifyImport_NoPrefix() : base("/import /file:" + TIConfig.TokenFile + " /offerid:" + TIConfig.OfferId, MATCH_ON) {}

		protected override void Initialize()
		{
            TokendbWS.DeleteUnactivatedBillingTokens(TIConfig.OfferId);
        }

		protected override bool Verify(string output)
		{
            if (TokendbWS.VerifySequenceRange(TIConfig.OfferId, uint.MinValue, uint.MaxValue))
            {
				if (base.Verify(output))
				{
					return(true);
				}
			}
			return(false);
		}
	}

	public class P_VerifyImport_MinSeq : TITestCaseBase
	{
		static string MATCH_ON = "regex:\r\nToken File: " + TIConfig.TokenFile + "\r\nOffer ID: " + TIConfig.OfferId + @"[\r\n\.\d]+";
		public P_VerifyImport_MinSeq() : base("/import /file:" + TIConfig.TokenFile + " /offerid:" + TIConfig.OfferId + " /minseq:" + TIConfig.MinSeq, MATCH_ON) {}

		protected override void Initialize()
		{
            TokendbWS.DeleteUnactivatedBillingTokens(TIConfig.OfferId);
        }

		protected override bool Verify(string output)
		{
            if (TokendbWS.VerifySequenceRange(TIConfig.OfferId, TIConfig.MinSeq, uint.MaxValue))
			{
                if (TokendbWS.VerifyExclusiveSequenceRange(TIConfig.OfferId, TIConfig.MinSeq, uint.MaxValue))
				{
					if (base.Verify(output))
					{
						return(true);
					}
				}
			}
			return(false);
		}
	}

	public class P_VerifyImport_MaxSeq : TITestCaseBase
	{
		static string MATCH_ON = "regex:\r\nToken File: " + TIConfig.TokenFile + "\r\nOffer ID: " + TIConfig.OfferId + @"[\r\n\.\d]+";
		public P_VerifyImport_MaxSeq() : base("/import /file:" + TIConfig.TokenFile + " /offerid:" + TIConfig.OfferId + " /maxseq:" + TIConfig.MaxSeq, MATCH_ON) {}

		protected override void Initialize()
		{
            TokendbWS.DeleteUnactivatedBillingTokens(TIConfig.OfferId);
        }

		protected override bool Verify(string output)
		{
            if (TokendbWS.VerifySequenceRange(TIConfig.OfferId, uint.MinValue, TIConfig.MaxSeq))
			{
                if (TokendbWS.VerifyExclusiveSequenceRange(TIConfig.OfferId, uint.MinValue, TIConfig.MaxSeq))
				{
					if (base.Verify(output))
					{
						return(true);
					}
				}
			}
			return(false);
		}
	}

	public class P_VerifyImport_MinAndMaxSeq : TITestCaseBase
	{
		static string MATCH_ON = "regex:\r\nToken File: " + TIConfig.TokenFile + "\r\nOffer ID: " + TIConfig.OfferId + @"[\r\n\.\d]+";
		public P_VerifyImport_MinAndMaxSeq() : base("/import /file:" + TIConfig.TokenFile + " /offerid:" + TIConfig.OfferId + " /minseq:" + TIConfig.MinSeq + " /maxseq:" + TIConfig.MaxSeq, MATCH_ON) {}

		protected override void Initialize()
		{
            TokendbWS.DeleteUnactivatedBillingTokens(TIConfig.OfferId);
        }

		protected override bool Verify(string output)
		{
            if (TokendbWS.VerifySequenceRange(TIConfig.OfferId, TIConfig.MinSeq, TIConfig.MaxSeq))
			{
                if (TokendbWS.VerifyExclusiveSequenceRange(TIConfig.OfferId, TIConfig.MinSeq, TIConfig.MaxSeq))
				{
					if (base.Verify(output))
					{
						return(true);
					}
				}
			}
			return(false);
		}
	}

	public class P_VerifyHelp : TITestCaseBase
	{
		const string MATCH_ON = "\r\n\r\nTokenImport <options>\r\n\r\n    -- OPTIONS --\r\n\r\n/import /file /offerid [/minseq] [/maxseq] [/retries]\r\n    Imports key(s)\r\n\r\nParameters:\r\n  /file:<file>            file listing of tokens, each line in the format:\r\n                                   29 character raw token\r\n                                   14 digit sequence number\r\n\r\n  /offerid:<offer id>     offer id to associate with the token(s)\r\n  /minseq:<sequence num>  minimum sequence number (inclusive)\r\n  /maxseq:<sequence num>  maximum sequence number (inclusive)\r\n\r\n@<response file>              file containing any of the above arguments,\r\n                                    one per line\r\n\r\n    -- EXAMPLES --\r\nTokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999\r\n\r\n";
		public P_VerifyHelp() : base("/?", MATCH_ON) {}
	}

	public class N_VerifyDisableExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\n";
		public N_VerifyDisableExits() : base("/disable", MATCH_ON) {}
	}

	public class N_VerifyEnableExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\n";
		public N_VerifyEnableExits() : base("/enable", MATCH_ON) {}
	}

	public class N_VerifyDeleteExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\n";
		public N_VerifyDeleteExits() : base("/delete", MATCH_ON) {}
	}

	public class N_VerifyViewExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\n";
		public N_VerifyViewExits() : base("/view", MATCH_ON) {}
	}

	public class N_VerifySummaryExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\nCount\t\tOfferId\t\t\tUseCount\r\n------------------------------------------------\r\n";
		public N_VerifySummaryExits() : base("/summary", MATCH_ON) {}
	}

	public class N_VerifyInvalidArgExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\nInvalid command line argument: /notReal\r\n\r\nTokenImport <options>\r\n\r\n    -- OPTIONS --\r\n\r\n/import /file /offerid [/minseq] [/maxseq] [/retries]\r\n    Imports key(s)\r\n\r\nParameters:\r\n  /file:<file>            file listing of tokens, each line in the format:\r\n                                   29 character raw token\r\n                                   14 digit sequence number\r\n\r\n  /offerid:<offer id>     offer id to associate with the token(s)\r\n  /minseq:<sequence num>  minimum sequence number (inclusive)\r\n  /maxseq:<sequence num>  maximum sequence number (inclusive)\r\n\r\n@<response file>              file containing any of the above arguments,\r\n                                    one per line\r\n\r\n    -- EXAMPLES --\r\nTokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999\r\n\r\n";
		public N_VerifyInvalidArgExits() : base("/notReal", MATCH_ON) {}
	}

	public class N_VerifyTwoCommandArgsExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\n/import must be specified.\r\n\r\nTokenImport <options>\r\n\r\n    -- OPTIONS --\r\n\r\n/import /file /offerid [/minseq] [/maxseq] [/retries]\r\n    Imports key(s)\r\n\r\nParameters:\r\n  /file:<file>            file listing of tokens, each line in the format:\r\n                                   29 character raw token\r\n                                   14 digit sequence number\r\n\r\n  /offerid:<offer id>     offer id to associate with the token(s)\r\n  /minseq:<sequence num>  minimum sequence number (inclusive)\r\n  /maxseq:<sequence num>  maximum sequence number (inclusive)\r\n\r\n@<response file>              file containing any of the above arguments,\r\n                                    one per line\r\n\r\n    -- EXAMPLES --\r\nTokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999\r\n\r\n";
		public N_VerifyTwoCommandArgsExits() : base("/import /view", MATCH_ON) {}
	}

	public class N_VerifyImportNoOfferIDExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\nMust specify /offerid when updating/adding voucher!\r\n\r\nTokenImport <options>\r\n\r\n    -- OPTIONS --\r\n\r\n/import /file /offerid [/minseq] [/maxseq] [/retries]\r\n    Imports key(s)\r\n\r\nParameters:\r\n  /file:<file>            file listing of tokens, each line in the format:\r\n                                   29 character raw token\r\n                                   14 digit sequence number\r\n\r\n  /offerid:<offer id>     offer id to associate with the token(s)\r\n  /minseq:<sequence num>  minimum sequence number (inclusive)\r\n  /maxseq:<sequence num>  maximum sequence number (inclusive)\r\n\r\n@<response file>              file containing any of the above arguments,\r\n                                    one per line\r\n\r\n    -- EXAMPLES --\r\nTokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999\r\n\r\n";
		public N_VerifyImportNoOfferIDExits() : base("/import", MATCH_ON) {}
	}

	public class N_VerifyImportOfferIDWithoutValueExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\nMust specify /offerid when updating/adding voucher!\r\n\r\nTokenImport <options>\r\n\r\n    -- OPTIONS --\r\n\r\n/import /file /offerid [/minseq] [/maxseq] [/retries]\r\n    Imports key(s)\r\n\r\nParameters:\r\n  /file:<file>            file listing of tokens, each line in the format:\r\n                                   29 character raw token\r\n                                   14 digit sequence number\r\n\r\n  /offerid:<offer id>     offer id to associate with the token(s)\r\n  /minseq:<sequence num>  minimum sequence number (inclusive)\r\n  /maxseq:<sequence num>  maximum sequence number (inclusive)\r\n\r\n@<response file>              file containing any of the above arguments,\r\n                                    one per line\r\n\r\n    -- EXAMPLES --\r\nTokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999\r\n\r\n";
		public N_VerifyImportOfferIDWithoutValueExits() : base("/import /offerid", MATCH_ON) {}
	}

	public class N_VerifyImportInvalidlyFormattedOfferIDExits : TITestCaseBase
	{
		const string MATCH_ON = "\r\nInvalid offer id.\r\n\r\nTokenImport <options>\r\n\r\n    -- OPTIONS --\r\n\r\n/import /file /offerid [/minseq] [/maxseq] [/retries]\r\n    Imports key(s)\r\n\r\nParameters:\r\n  /file:<file>            file listing of tokens, each line in the format:\r\n                                   29 character raw token\r\n                                   14 digit sequence number\r\n\r\n  /offerid:<offer id>     offer id to associate with the token(s)\r\n  /minseq:<sequence num>  minimum sequence number (inclusive)\r\n  /maxseq:<sequence num>  maximum sequence number (inclusive)\r\n\r\n@<response file>              file containing any of the above arguments,\r\n                                    one per line\r\n\r\n    -- EXAMPLES --\r\nTokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999\r\n\r\n";
		public N_VerifyImportInvalidlyFormattedOfferIDExits() : base("/import /offerid:0xdeadbeef", MATCH_ON) {}
	}

#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\UserEntry.cs ===
using System;

namespace UserIntegrity
{
	/// <summary>
	/// Summary description for UserEntry.
	/// </summary>
	public class UserEntry
	{
		public string	Name;
		public ulong	Puid;
		public MiniUODB	Server=null;
		public DateTime	Timestamp;
		public UserEntry()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		public string GetInfo()
		{
			return Name.PadRight(16)+" | "+Puid+" | "+Timestamp.ToString().PadRight(25)+" | "+Server._ServerName;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\MiniUODB.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;

namespace UserIntegrity
{
	/// <summary>
	/// Summary description for MiniUODB.
	/// </summary>
	public class MiniUODB
	{
		public const int MaxAccounts=10;
		public int	TopAccount=0;
		public int	CurAccounts=0;
		public int	BillingQueueSize=0;
		public int	UserCount=0;
		public UserEntry []Users=new UserEntry[MaxAccounts];
		public string _ServerName;
		SqlConnection	m_SqlConnection=null;
		public bool	PersistentConnection=false;

		SqlConnection	GetConnection()
		{
			if (m_SqlConnection==null)
			{
				m_SqlConnection = new SqlConnection("server="+_ServerName+";database=uodb;user id=sa;password=Suck!h3ad"); 		
				m_SqlConnection.Open();
			}
			return m_SqlConnection;
		}

		void	CloseConnection()
		{
			if (!PersistentConnection)
			{
				m_SqlConnection.Close();
				m_SqlConnection=null;
			}
		}
		public MiniUODB(string Server)
		{
			_ServerName=Server;
		}

		public bool FindUserInUserNames(UserEntry ue)
		{
			bool found=false;
			GetConnection();

			SqlDataReader myDataReader = null;
			string QueryString=
				"select bi_user_puid from t_user_names where vc_nickname = '"+ue.Name+"' and bi_user_puid = "+ue.Puid;

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				while(myDataReader.Read())
				{
					// Always call Read before accessing data.
					if (Convert.ToUInt64(myDataReader.GetInt64(0))==ue.Puid)
						found=true;
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CloseConnection();
			return found;
		}

		// Returns all data in t_users
		public void GetUsers(ArrayList Users)
		{
			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select vc_nickname, bi_user_puid, dt_change_datetime from t_users";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				while(myDataReader.Read())
				{
					UserEntry ue=new UserEntry();
					// Always call Read before accessing data.
					ue.Name=myDataReader.GetString(0);
					ue.Puid=(ulong)myDataReader.GetInt64(1);
					ue.Timestamp=myDataReader.GetDateTime(2).ToLocalTime();
					ue.Server=this;
					Users.Add(ue);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CloseConnection();
		}

		public int GetQueuedAccounts()
		{
			int i=0;

			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select top "+MaxAccounts+" qu.dt_change_datetime,us.vc_nickname from t_users as us inner join t_user_billing_queue as qu "+
				"on us.bi_user_puid=qu.bi_user_puid where us.vc_nickname not like 'RM%' "+
				"order by qu.dt_change_datetime desc";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				for(i=0; i<MaxAccounts && myDataReader.Read(); i++)
				{
					// Always call Read before accessing data.
					Users[i]=new UserEntry();
					Users[i].Timestamp=myDataReader.GetDateTime(0).ToLocalTime();
					Users[i].Name=myDataReader.GetString(1);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CurAccounts=i;
			
			CloseConnection();
			return i;
		}

		public void UpdateCounts()
		{
			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select count(*) from t_user_billing_queue";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				if (myDataReader.Read())
				{
					// Always call Read before accessing data.				
					BillingQueueSize=myDataReader.GetInt32(0);
				}
				myDataReader.Close();

				QueryString="select count(*) from t_users";
				mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);
				myDataReader = mySqlCommand.ExecuteReader();

				if (myDataReader.Read())
				{
					// Always call Read before accessing data.				
					UserCount=myDataReader.GetInt32(0);
				}

			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CloseConnection();
		}
		public int GetAllAcounts()
		{
			int i=0;

			GetConnection();
			SqlDataReader myDataReader = null;
			string QueryString=
				"select top "+MaxAccounts+" dt_change_datetime,vc_nickname from t_users where vc_nickname not like 'RM%' order by dt_change_datetime desc";

			SqlCommand mySqlCommand = new SqlCommand(QueryString, m_SqlConnection);

			try
			{
				myDataReader = mySqlCommand.ExecuteReader();

				for(i=0; i<MaxAccounts && myDataReader.Read(); i++)
				{
					// Always call Read before accessing data.
					Users[i]=new UserEntry();
					Users[i].Timestamp=myDataReader.GetDateTime(0).ToLocalTime();
					Users[i].Name=myDataReader.GetString(1);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				if (myDataReader != null)
					myDataReader.Close();
			}

			CurAccounts=i;
			
			CloseConnection();
			return i;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_userintegrity_none_12.4.56.0_none_e889d2da4ce82633
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=userintegrity
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.manifest
XP_MANIFEST_PATH=manifests\msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.cat
XP_CATALOG_PATH=manifests\msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.cat
XP_PAYLOAD_PATH=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=userintegrity,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\UserTableIntegrity.cs ===
using System;
using System.Collections;

namespace UserIntegrity
{
	/// <summary>
	/// Summary description for UserTableIntegrity.
	/// </summary>
	public class UserTableIntegrity
	{
		public int		ErrorsFound=0;
		public MiniUODB []UODB;
		public UserTableIntegrity()
		{
			UODB=new MiniUODB[3];
			UODB[0]=new MiniUODB("XONTEUODBSQL002");
			UODB[1]=new MiniUODB("XONTEUODBSQL003");
			UODB[2]=new MiniUODB("XONTEUODBSQL004");
		}

		public void Go()
		{
			ErrorsFound=0;
			DateTime NextUpdate=DateTime.Now.AddSeconds(1);
			int counter=0, total=0;
			ArrayList Users=new ArrayList();

			foreach (MiniUODB db in UODB)
			{
				db.PersistentConnection=false;
				db.GetUsers(Users);
			}
			total=Users.Count;
			Console.WriteLine("Got "+total+" users");
			foreach (UserEntry ue in Users)
			{
				bool found=false;
				if (DateTime.Now > NextUpdate)
				{
					Console.Write("Testing "+ue.Name.PadRight(16)+" ("+counter+" / "+total+")\r");
					NextUpdate=DateTime.Now.AddSeconds(1);
				}
				counter++;
				foreach (MiniUODB db in UODB)
				{
					found=db.FindUserInUserNames(ue);
					if (found)
						break;
				}
				if (!found)
				{
					Console.WriteLine("Mismatch | "+ue.GetInfo());
					ErrorsFound++;
				}
			}

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserIntegrity\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_userintegrity_none_12.4.56.0_none_e889d2da4ce82633
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=userintegrity
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.manifest
XP_MANIFEST_PATH=manifests\msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.cat
XP_CATALOG_PATH=manifests\msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85.cat
XP_PAYLOAD_PATH=msil_userintegrity_no-public-key_12.4.56.0_x-ww_886f8c85
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=userintegrity,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\MainProfiles.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Data.SqlClient;
using System.Text.RegularExpressions;
using System.IO;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;
namespace UserProfile
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class frmProfiles : System.Windows.Forms.Form
	{
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button btnImport;
        private System.Windows.Forms.Button btnLookup;
        private System.Windows.Forms.Button btnClear;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
        private System.Windows.Forms.ListView lstUsers;
        private System.Windows.Forms.TabControl tabControl1;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.TabPage tabPage2;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox txtValue;
        private System.Windows.Forms.TextBox txtProps;
        private System.Windows.Forms.Button btnSet;
        private System.Windows.Forms.ComboBox cboProps;
        private System.Windows.Forms.ComboBox cboTitles;
        private System.Windows.Forms.Label lblValue;
        private System.Windows.Forms.ListView lstUserProps;
        private System.Windows.Forms.ColumnHeader clmProperty;
        private System.Windows.Forms.ColumnHeader clmType;
        private System.Windows.Forms.ColumnHeader clmValue;
        private System.Windows.Forms.ColumnHeader clmTitle;

        Hashtable userList = new Hashtable();
        private System.Windows.Forms.Label lblUserInfo;
        private System.Windows.Forms.ColumnHeader columnHeader1;
        Hashtable titleList = new Hashtable();

		public frmProfiles()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//

            GetTitles();
            PopulateProperties();

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.label1 = new System.Windows.Forms.Label();
            this.btnImport = new System.Windows.Forms.Button();
            this.btnLookup = new System.Windows.Forms.Button();
            this.btnClear = new System.Windows.Forms.Button();
            this.lstUsers = new System.Windows.Forms.ListView();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.lblValue = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.txtValue = new System.Windows.Forms.TextBox();
            this.txtProps = new System.Windows.Forms.TextBox();
            this.btnSet = new System.Windows.Forms.Button();
            this.cboProps = new System.Windows.Forms.ComboBox();
            this.cboTitles = new System.Windows.Forms.ComboBox();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.lstUserProps = new System.Windows.Forms.ListView();
            this.clmProperty = new System.Windows.Forms.ColumnHeader();
            this.clmType = new System.Windows.Forms.ColumnHeader();
            this.clmTitle = new System.Windows.Forms.ColumnHeader();
            this.clmValue = new System.Windows.Forms.ColumnHeader();
            this.lblUserInfo = new System.Windows.Forms.Label();
            this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(24, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(37, 16);
            this.label1.TabIndex = 1;
            this.label1.Text = "Users:";
            // 
            // btnImport
            // 
            this.btnImport.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.btnImport.Location = new System.Drawing.Point(24, 376);
            this.btnImport.Name = "btnImport";
            this.btnImport.Size = new System.Drawing.Size(56, 24);
            this.btnImport.TabIndex = 2;
            this.btnImport.Text = "Import";
            this.btnImport.Click += new System.EventHandler(this.btnImport_Click);
            // 
            // btnLookup
            // 
            this.btnLookup.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.btnLookup.Location = new System.Drawing.Point(88, 376);
            this.btnLookup.Name = "btnLookup";
            this.btnLookup.Size = new System.Drawing.Size(56, 24);
            this.btnLookup.TabIndex = 3;
            this.btnLookup.Text = "Lookup";
            this.btnLookup.Click += new System.EventHandler(this.btnLookup_Click);
            // 
            // btnClear
            // 
            this.btnClear.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.btnClear.Location = new System.Drawing.Point(152, 376);
            this.btnClear.Name = "btnClear";
            this.btnClear.Size = new System.Drawing.Size(56, 24);
            this.btnClear.TabIndex = 14;
            this.btnClear.Text = "Clear";
            this.btnClear.Click += new System.EventHandler(this.btnClear_Click);
            // 
            // lstUsers
            // 
            this.lstUsers.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left)));
            this.lstUsers.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
                                                                                       this.columnHeader1});
            this.lstUsers.FullRowSelect = true;
            this.lstUsers.HideSelection = false;
            this.lstUsers.Location = new System.Drawing.Point(24, 32);
            this.lstUsers.Name = "lstUsers";
            this.lstUsers.Size = new System.Drawing.Size(184, 290);
            this.lstUsers.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.lstUsers.TabIndex = 15;
            this.lstUsers.View = System.Windows.Forms.View.Details;
            this.lstUsers.SelectedIndexChanged += new System.EventHandler(this.lstUsers_SelectedIndexChanged);
            // 
            // tabControl1
            // 
            this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Location = new System.Drawing.Point(216, 16);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(384, 384);
            this.tabControl1.TabIndex = 25;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.lblValue);
            this.tabPage1.Controls.Add(this.label4);
            this.tabPage1.Controls.Add(this.label3);
            this.tabPage1.Controls.Add(this.label2);
            this.tabPage1.Controls.Add(this.txtValue);
            this.tabPage1.Controls.Add(this.txtProps);
            this.tabPage1.Controls.Add(this.btnSet);
            this.tabPage1.Controls.Add(this.cboProps);
            this.tabPage1.Controls.Add(this.cboTitles);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Size = new System.Drawing.Size(376, 358);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "Edit";
            // 
            // lblValue
            // 
            this.lblValue.AutoSize = true;
            this.lblValue.Location = new System.Drawing.Point(12, 139);
            this.lblValue.Name = "lblValue";
            this.lblValue.Size = new System.Drawing.Size(36, 16);
            this.lblValue.TabIndex = 33;
            this.lblValue.Text = "Value:";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(12, 91);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(167, 16);
            this.label4.TabIndex = 32;
            this.label4.Text = "or Hexadecimal Profile Property:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(12, 51);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(85, 16);
            this.label3.TabIndex = 31;
            this.label3.Text = "Profile Property:";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(12, 3);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(29, 16);
            this.label2.TabIndex = 30;
            this.label2.Text = "Title:";
            // 
            // txtValue
            // 
            this.txtValue.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.txtValue.Location = new System.Drawing.Point(12, 155);
            this.txtValue.Multiline = true;
            this.txtValue.Name = "txtValue";
            this.txtValue.Size = new System.Drawing.Size(352, 160);
            this.txtValue.TabIndex = 28;
            this.txtValue.Text = "";
            this.txtValue.TextChanged += new System.EventHandler(this.txtValue_TextChanged);
            // 
            // txtProps
            // 
            this.txtProps.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.txtProps.Location = new System.Drawing.Point(12, 107);
            this.txtProps.Name = "txtProps";
            this.txtProps.Size = new System.Drawing.Size(352, 20);
            this.txtProps.TabIndex = 27;
            this.txtProps.Text = "";
            this.txtProps.TextChanged += new System.EventHandler(this.txtProps_TextChanged);
            // 
            // btnSet
            // 
            this.btnSet.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnSet.Location = new System.Drawing.Point(304, 328);
            this.btnSet.Name = "btnSet";
            this.btnSet.Size = new System.Drawing.Size(56, 24);
            this.btnSet.TabIndex = 29;
            this.btnSet.Text = "Set!";
            this.btnSet.Click += new System.EventHandler(this.btnSet_Click);
            // 
            // cboProps
            // 
            this.cboProps.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.cboProps.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cboProps.ItemHeight = 13;
            this.cboProps.Location = new System.Drawing.Point(12, 67);
            this.cboProps.Name = "cboProps";
            this.cboProps.Size = new System.Drawing.Size(352, 21);
            this.cboProps.Sorted = true;
            this.cboProps.TabIndex = 26;
            this.cboProps.SelectedIndexChanged += new System.EventHandler(this.cboProps_SelectedIndexChanged);
            // 
            // cboTitles
            // 
            this.cboTitles.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.cboTitles.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cboTitles.ItemHeight = 13;
            this.cboTitles.Location = new System.Drawing.Point(12, 19);
            this.cboTitles.Name = "cboTitles";
            this.cboTitles.Size = new System.Drawing.Size(352, 21);
            this.cboTitles.TabIndex = 25;
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.lstUserProps);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Size = new System.Drawing.Size(376, 358);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "View";
            // 
            // lstUserProps
            // 
            this.lstUserProps.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.lstUserProps.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
                                                                                           this.clmProperty,
                                                                                           this.clmType,
                                                                                           this.clmTitle,
                                                                                           this.clmValue});
            this.lstUserProps.FullRowSelect = true;
            this.lstUserProps.Location = new System.Drawing.Point(0, 0);
            this.lstUserProps.MultiSelect = false;
            this.lstUserProps.Name = "lstUserProps";
            this.lstUserProps.Size = new System.Drawing.Size(377, 358);
            this.lstUserProps.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.lstUserProps.TabIndex = 0;
            this.lstUserProps.View = System.Windows.Forms.View.Details;
            this.lstUserProps.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.lstUserProps_KeyPress);
            this.lstUserProps.DoubleClick += new System.EventHandler(this.lstUserProps_DoubleClick);
            // 
            // clmProperty
            // 
            this.clmProperty.Text = "Property";
            this.clmProperty.Width = 120;
            // 
            // clmType
            // 
            this.clmType.Text = "Type";
            // 
            // clmTitle
            // 
            this.clmTitle.Text = "Title";
            this.clmTitle.Width = 120;
            // 
            // clmValue
            // 
            this.clmValue.Text = "Value";
            // 
            // lblUserInfo
            // 
            this.lblUserInfo.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.lblUserInfo.BackColor = System.Drawing.SystemColors.ActiveCaptionText;
            this.lblUserInfo.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.lblUserInfo.Location = new System.Drawing.Point(24, 336);
            this.lblUserInfo.Name = "lblUserInfo";
            this.lblUserInfo.Size = new System.Drawing.Size(184, 32);
            this.lblUserInfo.TabIndex = 26;
            // 
            // columnHeader1
            // 
            this.columnHeader1.Text = "Gamertags";
            this.columnHeader1.Width = 150;
            // 
            // frmProfiles
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(608, 405);
            this.Controls.Add(this.lblUserInfo);
            this.Controls.Add(this.tabControl1);
            this.Controls.Add(this.lstUsers);
            this.Controls.Add(this.btnClear);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.btnLookup);
            this.Controls.Add(this.btnImport);
            this.MinimumSize = new System.Drawing.Size(480, 376);
            this.Name = "frmProfiles";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "User Profile Settings";
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.tabPage2.ResumeLayout(false);
            this.ResumeLayout(false);

        }
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new frmProfiles());
		}

        /// <summary>
        /// GetTitles retrieves the list of titles from the webdb.  I'm not 100% sure this is the correct place to do so, but it has the strings.
        /// </summary>
        private void GetTitles()
        {
            TitleInfo ti = null, def = null;
            try
            {
                using(SqlConnection c = new SqlConnection(ConfigUtil.WebdbConnectionString))
                {
                    c.Open();
                    SqlCommand com = c.CreateCommand();
                    // Queries for the title id and the display name for the default locale.  This may be wierd though for non-english defaults.
                    // It probably should query based on the local user locale and if not found then go to the default.
                    com.CommandText = 
@"select ti.i_title_id, tni.vc_display_name 
from t_title_info as ti 
	inner join t_title_name_info as tni on tni.i_title_id=ti.i_title_id and tni.vc_locale_id=ti.vc_default_locale
order by tni.vc_display_name";
                    com.CommandType = CommandType.Text;
                    SqlDataReader r = com.ExecuteReader();
                    while(r.Read())
                    {
                        ti = new TitleInfo();
                        ti.ID = r.GetInt32(0);
                        ti.Title = r.GetString(1);
                        cboTitles.Items.Add(ti.ToString());
                        titleList[ti.ID] = ti;
                        if(ti.ID == -129071 /*0xFFFE07D1*/)
                            def = ti;
                    }
                    r.Close();
                }
            }
            catch(System.Exception f)
            {
                MessageBox.Show(this, "An error occurred: " + f.Message + "\n" + f.StackTrace);
            }
            // If i didn't find any titles such as from a fresh build of the service then put in a default.
            if(cboTitles.Items.Count == 0)
            {
                ti = new TitleInfo();
                ti.Title = "Default";
                unchecked {ti.ID = (int) 0xfffe07d1;}     // Xbox 360 dash title id

                cboTitles.Items.Add(ti.ToString());
            
                titleList[ti.ID] = ti;
                def = ti;
            }
            
            // Select the default title from the list
            cboTitles.SelectedIndex = cboTitles.Items.IndexOf(def.ToString());

        }

        /// <summary>
        /// PopulateProperties grabs the list of profile settings a user can have from npdb and adds them to the UI.
        /// </summary>
        private void PopulateProperties()
        {
			using(SqlConnection c = new SqlConnection(ConfigUtil.NpdbConnectionString))
			{
				c.Open();
				Settings.LoadSettings(c);
				foreach(string s in Settings.Names)
				{
					cboProps.Items.Add(s);
				}
				cboProps.SelectedIndex = 0;
			}
        }

        /// <summary>
        /// Imports the list of users from a file.  The file needs to be a flat text file with one gamertag per line.
        /// </summary>
        /// <param name="sender">Ignored</param>
        /// <param name="e">Ignored</param>
        private void btnImport_Click(object sender, System.EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.CheckFileExists = true;
            ofd.CheckPathExists = true;
            ofd.Title = "Select a text file containing gamertags to load";
            ofd.Filter = "Text Files (*.txt)|*.txt|All Files (*.*)|*";
            ofd.FilterIndex = 0;
            // Let the user select the file of names to import.
            if(ofd.ShowDialog(this) != DialogResult.OK)
                return;

            // Read the list of gamertags into a list.
            StreamReader sr = new StreamReader(ofd.FileName, true);
            string gt = "";
            ArrayList gts = new ArrayList();
            try
            {
                while(gt != null)
                {
                    gt = sr.ReadLine();
                    if(gt != null)
                    {
                        gts.Add(gt);
                    }
                }
                // If we have a list, then go to the database to search for the users
                GetUsers(true, (string []) gts.ToArray(typeof(string)));
            }
            catch(System.Exception f)
            {
                MessageBox.Show(this, "Exception occurred: " + f.Message + "\n" + f.StackTrace);
            }
            finally
            {
                // Ensure the file is closed
                sr.Close();
            }
        }

        /// <summary>
        /// A simple function to try converting a puid in string form to a long.  Attempts decimal then hexadecimal conversion.
        /// </summary>
        /// <param name="puidstr">string to convert</param>
        /// <returns>the value or zero on failure (as it is an invalid puid)</returns>
        private long StringToPuid(string puidstr)
        {

            long puid = 0;
            if(puidstr  == null || puidstr.Length == 0)
                return 0;

            try
            {
                puid = System.Convert.ToInt64(puidstr);
                return puid;
            }
            catch
            {
                try
                {
                    puid = System.Convert.ToInt64(puidstr, 16);
                    return puid;
                }
                catch
                {
                    return 0;
                }
            }
        }
        /// <summary>
        /// GetUsers does the call to the database to lookup users by either gamertag or puid
        /// </summary>
        /// <param name="fUsingGamertag">Indicates whether to use the gamertag or puid arguments</param>
        /// <param name="data">Gamertag or puid array to look up if fUsingGamertag</param>
        /// <returns>A boolean indicating whether the gamertag or puid was valid (not whether the query succeeded)</returns>
        private bool GetUsers(bool fUsingGamertag, string [] data)
        {
            // Handy verifcation step to ensure the gamertag is valid.  Note we do support % & _ for wildcard searches in sql
            System.Text.RegularExpressions.Regex r = new System.Text.RegularExpressions.Regex(@"[%_a-zA-Z]( ?[%_a-zA-Z0-9]){0,14}");
            if(data == null)
                return false;

            // Use a progress bar to report to the user the progress.
            ProgressBar pb = new ProgressBar();
            int progress = 0;
            object [] args = new object[1];

            // Use a delegate here to ensure that updates occur on the appropriate thread of the progress bar.
            ProgressBar.UpdateProgressDelegate upd = new ProgressBar.UpdateProgressDelegate(pb.UpdateProgress);

            try
            {
                // Talk to UODB, use webstore
                IVirtualInterfaceInfo vi = Config.GetVirtualInterface(VirtualInterface.uodb, xonline.common.config.Site.main);

                using (WstConnection c = new WstConnection(vi.WebstoreApp))
                {
                    c.Open();

                    // This is the maximum amount of querying we have to do.  Thankfully as we find data it gets faster
                    pb.pbProgress.Maximum = c.SqlPartitions.Count * data.Length;
                    pb.Owner = this;
                    pb.Show();

                    // We search a given partition for each gamertag.  As we find a gamertag we then clear the gamertag (unless it contains wildcards)
                    // to speed up searches on future partitions (since a gamertag should not exist on multiple partitions).
                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        SqlParameter param = null;
                        // I'm not sure if WstFailoverMode.PrimaryOnly is correct.  I probably only need to be able to read.
                        WebstoreDatabase d = c.GetDatabase(i, WstPartitionType.Physical, WstFailoverMode.PrimaryOnly);

                        Microsoft.Webstore.WstClient.WstCommand ws = new WstCommand();
                        ws.Connection = c;

                        ws.Partition = i;
                        ws.PartitionType = WstPartitionType.Physical;

                        // Set up the query based on whether I'm using a gamertag or puid
                        if(fUsingGamertag)
                        {
                            ws.CommandText = "select vc_gamertag, bi_user_puid, si_hash_bucket from t_users where vc_gamertag like @gt";
                            param = ws.Parameters.Add("@gt", SqlDbType.VarChar);
                        }
                        else
                        {
                            ws.CommandText = "select vc_gamertag, bi_user_puid, si_hash_bucket from t_users where bi_user_puid = @puid";
                            param = ws.Parameters.Add("@puid", SqlDbType.BigInt);
                        }
                        ws.CommandType = CommandType.Text;

                        for(int j = 0; j < data.Length; ++j)
                        {
                            if(fUsingGamertag)
                            {
                                // I allow % and _ too to support wildcard searching in sql
                                if(data[j].Length == 0 || !r.IsMatch(data[j]))
                                {
                                    data[j] = "";   // Clear the field for the case that the regular expression does not match
                                    goto Next;
                                }
                                if(userList[data[j].ToLower()] != null) // I've already found this user.
                                {
                                    data[j] = "";
                                    goto Next;
                                }

                                param.Value = data[j];      // Set the parameter
                            }
                            else
                            {
                                // StringToPuid already guards for the empty string.
                                long puid = StringToPuid(data[j]);
                                if(puid == 0)
                                {
                                    data[j] = "";
                                    goto Next;
                                }
                                param.Value = puid;
                            }
                            WstDataReader reader = null;
                            try
                            {
                                reader = ws.ExecuteReader();
                                // I do a while here to support the wildcard scenarios.
                                while(reader.Read())
                                {
                                    UserInfo ui = new UserInfo();
                                    ui.Gamertag = reader.GetString(0);
                                    if(userList[ui.Gamertag.ToLower()] == null) // I have this to ensure that lookups by puid/wildcard don't cause duplication too.
                                    {
                                        ui.Puid = reader.GetInt64(1);
                                        ui.HashBucket = reader.GetInt16(2);
                                        ui.Partition = i;
                                        ui.DBName = d.ServerName;
                                        ui.lvi = new ListViewItem(ui.Gamertag);
                                        userList[ui.Gamertag.ToLower()] = ui;
                                    }
                                    if(data[j].IndexOf('_') == -1 && data[j].IndexOf('%') == -1)
                                    {
                                        data[j] = "";   // Set this to the empty string to make it clear we've already done this one if it doesn't contain a wildcard.
                                    }
                                }
                            }
                            finally
                            {
                                if(reader != null)
                                    reader.Close();
                            }

                            // Update progress bar with status
                        Next:
                            progress++;
                            args[0] = progress;
                            pb.Invoke(upd, args);
                        }
                    }
                }
            }
            catch(System.Exception f)
            {
                MessageBox.Show(this, "An error occurred: " + f.Message + "\n" + f.StackTrace);
                return true;    // I attempted, I shouldn't indicate that the string was invalid
            }
            finally
            {
                args[0] = pb.pbProgress.Maximum;
                pb.Invoke(upd, args);
                // Give the user some time to see that we are done...
                System.Threading.Thread.Sleep(250);
                pb.Hide();
            }

            UpdateUserList();
            return true;
        }

        /// <summary>
        /// This does a single lookup of a user, either by puid or gamertag (including wildcards)
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void btnLookup_Click(object sender, System.EventArgs e)
        {
            Lookup look = new Lookup();

            // Get the gamertag or puid from the user
            if(look.ShowDialog(this) == System.Windows.Forms.DialogResult.Cancel)
                return;

            // Check gamertag first. If it has a value use it
            if(look.txtGamertag.Text != null && look.txtGamertag.Text != "")
            {
                if(!GetUsers(true, new string [] {look.txtGamertag.Text}))
                {
                    System.Windows.Forms.MessageBox.Show(this, "A valid gamertag is 1-15 characters, starts with a letter, contains only letters, numbers, and spaces, does not end in a space and does not contain two consecutive spaces.");
                    return;
                }
            }
            else    // Grabbing a puid
            {
                if(!GetUsers(false, new string [] {look.txtPuid.Text}))
                {
                    System.Windows.Forms.MessageBox.Show(this, "The user puid entered is invalid.  It can be either decimal or hexadecimal.");
                    return;
                }
            }
        }

        /// <summary>
        /// Updates the user list in the UI after doing a query to get the UI back in sync.
        /// </summary>
        private void UpdateUserList()
        {
            ArrayList al = new ArrayList();
            foreach(string k in userList.Keys)
            {
                UserInfo ui = (UserInfo) userList[k];
                if(lstUsers.Items.IndexOf(ui.lvi) == -1)
                    al.Add(ui);
            }

            foreach(UserInfo k in al)
            {
                lstUsers.Items.Add(k.lvi);
            }
        }

        /// <summary>
        /// Clears the list of users
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void btnClear_Click(object sender, System.EventArgs e)
        {
            lstUsers.Items.Clear();
            userList.Clear();
            lstUsers.SelectedItems.Clear();
            lstUserProps.Items.Clear();
            lblUserInfo.Text = "";
        }

        /// <summary>
        /// Sets the current value for the profile setting
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void btnSet_Click(object sender, System.EventArgs e)
        {
            // If no users are selected then we are done.
            if(lstUsers.SelectedIndices.Count == 0)
                return;

            // this is the update string used to setup the query to the db.  I requery the values afterward to double check.
            string updateText = 
                @"if exists(select si_hash_bucket from t_user_settings where bi_user_puid = @puid and si_hash_bucket = @bucket and i_setting_id = @setting and i_title_id = @title)
    update t_user_settings set vb_value=@value, dt_change_datetime=getutcdate() where bi_user_puid = @puid and si_hash_bucket = @bucket and i_setting_id = @setting and i_title_id = @title
else
    insert into t_user_settings (bi_user_puid, i_title_id, i_setting_id, vb_value, si_hash_bucket) values (@puid, @title, @setting, @value, @bucket)

select bi_user_puid, i_title_id, i_setting_id, vb_value from t_user_settings where bi_user_puid = @puid and si_hash_bucket = @bucket and i_setting_id = @setting
";
            // Arguments to pass to the progress update UI
            object [] args = new object[1];
            // Title ID
            string titlename = cboTitles.Items[cboTitles.SelectedIndex].ToString();
            titlename = titlename.Substring(titlename.LastIndexOf("(") + 1, 10);
            int titleid = Convert.ToInt32(titlename, 16);
            int settingval = Convert.ToInt32(txtProps.Text, 16);

            // Set up the progress bar
            ProgressBar pb = new ProgressBar();
            pb.pbProgress.Maximum = lstUsers.SelectedIndices.Count;
            pb.Owner = this;
            pb.Show();

            try
            {
                // You can select multiple users to be modified so we will display the progress bar
                ProgressBar.UpdateProgressDelegate upd = new ProgressBar.UpdateProgressDelegate(pb.UpdateProgress);

                // The general premise of this algorithm is to:
                //  Find the set of partitions that the selected users are on and group those of the same partition together
                //  For each partition that has a set of users go through those users and set the value
                IVirtualInterfaceInfo vi = Config.GetVirtualInterface(VirtualInterface.uodb, xonline.common.config.Site.main);

                using (WstConnection c = new WstConnection(vi.WebstoreApp))
                {
                    c.Open();
               
                    int userProgress = 0;

                    // Typical situation will likely be that only a few users are selected so we only 
                    // hit the partitions related to those users
                    ArrayList [] todo = new ArrayList[c.SqlPartitions.Count];
                    for(int i = 0; i < c.SqlPartitions.Count; i++)
                        todo[i] = null;

                    // Determine which partitions the users are on and put them in the correct array list
                    foreach(int userIdx in lstUsers.SelectedIndices)
                    {
                        string gt = lstUsers.Items[userIdx].SubItems[0].Text;
                        UserInfo ui = (UserInfo) userList[gt.ToLower()];
                        if(todo[ui.Partition] == null)
                            todo[ui.Partition] = new ArrayList();
                        todo[ui.Partition].Add(ui);
                    }


                    for (int i=0; i < c.SqlPartitions.Count; i++)
                    {
                        // Skip this partition if we don't have any relevant users on it.
                        if(todo[i] == null || todo[i].Count == 0)
                            continue;

                        Microsoft.Webstore.WstClient.WstCommand ws = new WstCommand();
                        ws.Connection = c;

                        ws.Partition = i;
                        ws.PartitionType = WstPartitionType.Physical;

                        ws.CommandText = updateText;
                        ws.CommandType = CommandType.Text;
                        // ws.WstCommandType = WstCommandType.ReadThenWrite;
                        SqlParameter puid = new SqlParameter("@puid", SqlDbType.BigInt);
                        SqlParameter bucket = new SqlParameter("@bucket", SqlDbType.SmallInt);
                        SqlParameter setting = new SqlParameter("@setting", SqlDbType.Int);
                        SqlParameter val = new SqlParameter("@value", SqlDbType.VarBinary);
                        SqlParameter title = new SqlParameter("@title", SqlDbType.Int);
                        ws.Parameters.Add(puid);
                        ws.Parameters.Add(bucket);
                        ws.Parameters.Add(setting);
                        ws.Parameters.Add(val);
                        ws.Parameters.Add(title);

                        // title, setting, and value are determined for all users
                        title.Value = titleid;
                        setting.Value = settingval;
                        val.Value = Settings.GetValue(settingval, txtValue.Text);

                        ws.Prepare();
                        foreach(UserInfo ui in todo[i])
                        {
                            // per user information for setting values
                            puid.Value = ui.Puid;
                            bucket.Value = ui.HashBucket;

                            WstDataReader reader = null;
                            try
                            {
                                reader = ws.ExecuteReader();
                                #region Read the results from the data reader as a sanity check of the data
                                // This does a dump to the debug output for a visual inspection.
                                do
                                {
                                    Debug.WriteLine("New Result Set");
                                while(reader.Read())
                                {
                                    for(int j = 0; j < reader.FieldCount; ++j)
                                    {
                                        if(reader.GetValue(j).GetType() == typeof(byte []))
                                        {
                                            Debug.WriteLine(reader.GetName(j) + ": " + Settings.GetValue(settingval, (byte []) reader.GetValue(j)));
                                        }
                                        else
                                        {
                                            Debug.WriteLine(reader.GetName(j) + ": " + reader.GetValue(j).ToString());
                                        }
                                    }
                                }
                                }
                                while(reader.NextResult());
                                #endregion
                            }
                            catch(System.Exception f)
                            {
                                MessageBox.Show(this, "An error occurred: " + f.Message + "\n" + f.StackTrace);
                            }
                            finally
                            {
                                if(reader != null)
                                    reader.Close();
                            }

                            userProgress++;
                            args[0] = userProgress;
                            pb.Invoke(upd, args);
                        }
                    }
                }
            }
            catch(System.Exception f)
            {
                MessageBox.Show(this, "Exception occurred: " + f.Message + "\n" + f.StackTrace);
            }

            // update the user properties information
            RefreshUserProps();

			System.Threading.Thread.Sleep(250);
			pb.Hide();
        }

        /// <summary>
        /// Updates the value if the selected property setting has changed
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void cboProps_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            // If a setting is selected then update the UI to indicate the type of the setting and the value
            if(cboProps.SelectedIndex >= 0)
            {
				Settings settings = new Settings();
				int id = settings[cboProps.Text];
                string s = "0x" + id.ToString("X8");
                if(txtProps.Text != s)
                    txtProps.Text = s;
                lblValue.Text = "Value (" + Settings.PropType(id) + "):";
            }
            else if(cboProps.Focused)
            {
                txtProps.Text = "";
                lblValue.Text = "Value:";
            }
            else
            {
                lblValue.Text = "Value:";
            }
            lblValue.Refresh();
        }
        
        /// <summary>
        /// Keeps track of the current property value selected
        /// </summary>
        int currentPropertyValue = 0;

        /// <summary>
        /// Tracks the ID of the current setting.  If you know the id, you can just put that in to update the list.
        /// Note that this *does* allow setting values in the profile that might have *really* bad side effects.
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void txtProps_TextChanged(object sender, System.EventArgs e)
        {
            try
            {
                currentPropertyValue = Convert.ToInt32(txtProps.Text, 16);
                try
                {
                    // Look up the setting in the property list and if found select it
					Settings settings = new Settings();
					string name = settings[currentPropertyValue];
					if(name == "")
						cboProps.SelectedIndex = -1;
					else
	                    cboProps.SelectedIndex = cboProps.Items.IndexOf(name);
                }
                catch
                {
                    cboProps.SelectedIndex = -1;
                }
                // Always expecting hex
                if(txtProps.Text.Length != 10)
                {
                    currentPropertyValue = 0;
                    btnSet.Enabled = false;
                }
                else
                    btnSet.Enabled = Settings.IsValidValue(currentPropertyValue, txtValue.Text);
            }
            catch
            {
                currentPropertyValue = 0;
                btnSet.Enabled = false;
            }
        }

        /// <summary>
        /// Track when the value specified has changed and only allow setting if the value is a reasonable representation of a value of the appropriate type
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void txtValue_TextChanged(object sender, System.EventArgs e)
        {
            if(currentPropertyValue == 0)
                return;

            if(Settings.IsValidValue(currentPropertyValue, txtValue.Text))
            {
                btnSet.Enabled = true;
                return;
            }
            btnSet.Enabled = false;            
        }

        /// <summary>
        /// Refreshes the properties for the user in the view tab
        /// </summary>
        private void RefreshUserProps()
        {
            // We only show properties for exactly one user.  Otherwise clear the fields.
            if(lstUsers.SelectedIndices.Count != 1)
            {
                lblUserInfo.Text = "";
                lblUserInfo.Update();
                lstUserProps.Items.Clear();
                return;
            }
            // Get the user to query on.
            string gt = lstUsers.Items[lstUsers.SelectedIndices[0]].SubItems[0].Text;
            UserInfo ui = (UserInfo) userList[gt.ToLower()];

            // indicate the user's data in the little box in the lower right indicating puid and partition
            lblUserInfo.Text = "Puid: " + ui.Puid.ToString("X8") + "\nDB: " + ui.DBName;
            lblUserInfo.Update();

            lstUserProps.Items.Clear();

            IVirtualInterfaceInfo vi = Config.GetVirtualInterface(VirtualInterface.uodb, xonline.common.config.Site.main);

            using (WstConnection c = new WstConnection(vi.WebstoreApp))
            {
                c.Open();

                Microsoft.Webstore.WstClient.WstCommand ws = new WstCommand();
                ws.Connection = c;

                ws.Partition = ui.Partition;
                ws.PartitionType = WstPartitionType.Physical;

                // Pull all the settings for this user.  The construct is simple enough to not require using parameters
                ws.CommandText = "select i_setting_id, i_title_id, vb_value from t_user_settings where bi_user_puid = 0x" + ui.Puid.ToString("X16");
                ws.CommandType = CommandType.Text;

                WstDataReader reader = null;
                
                try
                {
                    reader = ws.ExecuteReader();
				    Settings indices = new Settings();
                    int setting, title;
                    string settingstr, titlestr;
                    byte [] val;

                    // Grab all the settings and populate the UI
                    while(reader.Read())
                    {
                        setting = reader.GetInt32(0);
                        title = reader.GetInt32(1);
                        // Null might happen, so guard for it
                        if(reader.IsDBNull(2))
                            val = null;
                        else
                            val = (byte []) reader.GetValue(2);

                        // Get the setting and lookup the name.  If we don't know it just use the hex value
                        settingstr = indices[setting];
                        if(settingstr == "")
                            settingstr = "0x" + setting.ToString("X8");
                        else
                            settingstr += " (0x" + setting.ToString("X8") + ")";

                        // If we don't know the title id, just indicate the hex value
                        if(titleList[title] == null)
                            titlestr = "0x" + title.ToString("X8");
                        else
                            titlestr = ((TitleInfo) titleList[title]).ToString();

                        // Create the entry
                        ListViewItem lvi = new ListViewItem(new string [] {settingstr, Settings.PropType(setting), titlestr, Settings.GetValue(setting, val).ToString()});
                        lstUserProps.Items.Add(lvi);
                    }
                }
                catch(System.Exception f)
                {
                    MessageBox.Show(this, "Exception occurred: " + f.Message + "\n" + f.StackTrace);
                }
                finally
                {
                    reader.Close();
                }
            }
        }

        /// <summary>
        /// Event that occurs when the selected user(s) have changed requiring an update to the UI
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void lstUsers_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            RefreshUserProps();
        }

        /// <summary>
        /// Doubleclicking on a user setting takes you to the set tab prepopulated with the existing values.
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored</param>
        private void lstUserProps_DoubleClick(object sender, EventArgs e)
        {
            // If we don't have exactly one property selected then ignore this
            if(lstUserProps.SelectedIndices.Count != 1)
                return;

            // Get the selected item and it's setting
            ListViewItem lvi = lstUserProps.SelectedItems[0];
            string setting = lvi.SubItems[0].Text;

            // Select title
            int idx = cboTitles.Items.IndexOf(lvi.SubItems[2].Text);
            if(idx == -1)
                idx = 0;
            cboTitles.SelectedIndex = idx;

            // Indicate property
            txtProps.Text = setting.Substring(setting.LastIndexOf("(") + 1, 10);

            // Indicate value
            txtValue.Text = lvi.SubItems[3].Text;

            // Switch the tab control to the set tab
            tabControl1.SelectedIndex = 0;
        }

        /// <summary>
        /// If you hit space or enter on a property it will take you to the set tab as well.
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">the key press information</param>
        private void lstUserProps_KeyPress(object sender, KeyPressEventArgs e)
        {
            if(e.KeyChar == ' ' || e.KeyChar == '\n')
                lstUserProps_DoubleClick(sender, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\Lookup.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace UserProfile
{
	/// <summary>
	/// Summary description for Lookup.
	/// </summary>
	public class Lookup : System.Windows.Forms.Form
	{
        public System.Windows.Forms.TextBox txtGamertag;
        public System.Windows.Forms.TextBox txtPuid;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Button btnLookup;
        private System.Windows.Forms.Button btnCancel;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Lookup()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.txtGamertag = new System.Windows.Forms.TextBox();
            this.txtPuid = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.btnLookup = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // txtGamertag
            // 
            this.txtGamertag.Location = new System.Drawing.Point(80, 16);
            this.txtGamertag.Name = "txtGamertag";
            this.txtGamertag.Size = new System.Drawing.Size(200, 20);
            this.txtGamertag.TabIndex = 0;
            this.txtGamertag.Text = "";
            // 
            // txtPuid
            // 
            this.txtPuid.Location = new System.Drawing.Point(80, 64);
            this.txtPuid.Name = "txtPuid";
            this.txtPuid.Size = new System.Drawing.Size(200, 20);
            this.txtPuid.TabIndex = 1;
            this.txtPuid.Text = "";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(16, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(58, 16);
            this.label1.TabIndex = 2;
            this.label1.Text = "Gamertag:";
            this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(40, 64);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(30, 16);
            this.label2.TabIndex = 3;
            this.label2.Text = "Puid:";
            this.label2.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(138, 42);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(17, 16);
            this.label3.TabIndex = 4;
            this.label3.Text = "Or";
            this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // btnLookup
            // 
            this.btnLookup.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.btnLookup.Location = new System.Drawing.Point(150, 96);
            this.btnLookup.Name = "btnLookup";
            this.btnLookup.Size = new System.Drawing.Size(56, 24);
            this.btnLookup.TabIndex = 5;
            this.btnLookup.Text = "Lookup";
            // 
            // btnCancel
            // 
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Location = new System.Drawing.Point(86, 96);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(56, 24);
            this.btnCancel.TabIndex = 6;
            this.btnCancel.Text = "Cancel";
            // 
            // Lookup
            // 
            this.AcceptButton = this.btnLookup;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this.btnCancel;
            this.ClientSize = new System.Drawing.Size(292, 125);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnLookup);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.txtPuid);
            this.Controls.Add(this.txtGamertag);
            this.Name = "Lookup";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Lookup";
            this.ResumeLayout(false);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_userprofile_none_12.4.56.0_none_a149925bf4e399cb
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=userprofile
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.manifest
XP_MANIFEST_PATH=manifests\msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.cat
XP_CATALOG_PATH=manifests\msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.cat
XP_PAYLOAD_PATH=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=userprofile,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\video_music_migration_tests\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\UserInfo.cs ===
using System;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Windows.Forms;

namespace UserProfile
{
	/// <summary>
	/// The UserInfo class stores the information needed to manipulate a single user including the associated list view item
	/// </summary>
	public class UserInfo
	{
        /// <summary>
        /// The gamertag of the user
        /// </summary>
        public string Gamertag;
        /// <summary>
        /// The puid of the user
        /// </summary>
        public long Puid;
        /// <summary>
        /// The hashbucket of the user (used for creating new setting entries)
        /// </summary>
        public short HashBucket;
        /// <summary>
        /// The webstore database partition the user lives on (so we can go to that partition directly)
        /// </summary>
        public int Partition;
        /// <summary>
        /// The database name where the user lives (handy if you want to look at the db directly)
        /// </summary>
        public string DBName;
        /// <summary>
        /// The list view item associated with the user
        /// </summary>
        public ListViewItem lvi;
	}

    /// <summary>
    /// Tracks the ID and Title association
    /// </summary>
    public class TitleInfo
    {
        /// <summary>
        /// Title name string
        /// </summary>
        public string Title;
        /// <summary>
        /// Title ID
        /// </summary>
        public int ID;

        /// <summary>
        /// Returns the title appended with the title id (in hex)
        /// </summary>
        /// <returns>Title (0x&lt;TitleID&gt;)</returns>
        public new string ToString()
        {
            return Title + " (0x" + ID.ToString("X8") + ")";
        }
    }


    /// <summary>
    /// Stores the association of setting ids to names and vice versa
    /// </summary>
    public class Settings
    {
        /// <summary>
        /// Mapping of setting ids to names
        /// </summary>
		static Hashtable id2name = new Hashtable();
        /// <summary>
        /// Mapping of setting names to ids
        /// </summary>
		static Hashtable name2id = new Hashtable();

        /// <summary>
        /// Populates the id2name and name2id tables from the database
        /// </summary>
        /// <param name="npdb">The database connection to npdb</param>
		static public void LoadSettings(SqlConnection npdb)
		{
			SqlDataReader reader = null;

			string sql = "select i_setting_id, vc_name, vc_location, i_permission_flags from t_stats_user_setting_ids";
			SqlCommand command = new SqlCommand(sql, npdb);
            try
            {
                reader = command.ExecuteReader();
                while(reader.Read())
                {
                    int id = reader.GetInt32(0);
                    string name = reader.GetString(1);
                    id2name[id] = name;
                    name2id[name] = id;
                }
            }
            catch(System.Exception f)
            {
                MessageBox.Show("Exception occurred: " + f.Message + "\n" + f.StackTrace);
            }
            finally
            {
                if(reader != null)
                    reader.Close();
            }
		}

        /// <summary>
        /// The number of settings
        /// </summary>
		public static int SettingCount
		{
			get{return id2name.Count;}
		}

        /// <summary>
        /// The list of setting names
        /// </summary>
		public static ICollection Names
		{
			get{return name2id.Keys;}
		}

        /// <summary>
        /// The list of setting ids
        /// </summary>
		public static ICollection IDs
		{
			get{return id2name.Keys;}
		}

        /// <summary>
        /// Takes a setting id and returns the string name of the property type
        /// </summary>
        /// <param name="prop">setting id</param>
        /// <returns>property type as a string</returns>
		static public string PropType(int prop)
        {
            switch(prop & 0xF0000000)
            {
                case (int) XUSER_DATA_TYPE.CONTEXT:
                    return "Context";
                case (int) XUSER_DATA_TYPE.INT32:
                    return "Int32";
                case (int) XUSER_DATA_TYPE.INT64:
                    return "Int64";
                case (int) XUSER_DATA_TYPE.DOUBLE:
                    return "Double";
                case (int) XUSER_DATA_TYPE.UNICODE:
                    return "Unicode";
                case (int) XUSER_DATA_TYPE.FLOAT:
                    return "Float";
                case (int) XUSER_DATA_TYPE.BINARY:
                    return "Binary";
                case (int) XUSER_DATA_TYPE.DATETIME:
                    return "Date/Time";
            };
            return "Unknown";
        }

        // These are used to perform some basic tests first before trying to do some type casting as a quick check to make sure conversion will work
        // These are generally a little more loose than what the cast would accept since if these don't match then a cast or further more rigorous
        // parsing may not be necessary.
        static Regex matchInt32 = new Regex(@"(^0x[0-9A-Fa-f]{1,8}$)|(^-?\d{1,10}$)", RegexOptions.ExplicitCapture);
        static Regex matchInt64 = new Regex(@"(^0x[0-9A-Fa-f]{1,16}$)|(^-?\d{1,20}$)", RegexOptions.ExplicitCapture);
        static Regex matchDouble = new Regex(@"^-?\d{1,10}(.\d{10})?$", RegexOptions.ExplicitCapture);
        static Regex matchFloat = new Regex(@"^-?\d{1,10}(.\d{10})?$", RegexOptions.ExplicitCapture);
        static Regex matchBinary = new Regex(@"^(0x)?[0-9A-Fa-f]+$", RegexOptions.ExplicitCapture);
        static Regex matchDateTime = new Regex(@"^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(.\d{3})?( [AaPp][Mm])?$", RegexOptions.ExplicitCapture);

        /// <summary>
        /// Returns the default value for a given setting id
        /// </summary>
        /// <param name="type">setting id</param>
        /// <returns>default value for the setting</returns>
        static public object GetDefault(int type)
        {
            switch(type)
            {
                case (int) XUSER_DATA_TYPE.INT32:
                {
                    return (int) 0;
                }
                case (int) XUSER_DATA_TYPE.INT64:
                {
                    return (long) 0;
                }
                case (int) XUSER_DATA_TYPE.FLOAT: // Treat float as the same.  Not ideal
                {
                    return (float) 0;
                }
                case (int) XUSER_DATA_TYPE.DOUBLE:
                {
                    return (double) 0;
                }
            };
            return "";
        }

        /// <summary>
        /// Returns an object containing the system usable value based on the property and the database value
        /// </summary>
        /// <param name="prop">setting id the value is associated with</param>
        /// <param name="val">the value from the database</param>
        /// <returns></returns>
        static public object GetValue(int prop, byte [] val)
        {
            // Get the type and length of the data
            int type = (int) (prop & 0xF0000000);
            int length = prop & 0x0FFF0000;

            // If the value is null, return the default instead
            if(val == null)
                return GetDefault(type);

            // Set up the streams to convert the value from a byte array to a system value
            MemoryStream ms = new MemoryStream();
            BinaryReader br = new BinaryReader(ms);

            ms.Write(val, 0, val.Length);
            ms.Position = 0;

            switch(type)
            {
                case (int) XUSER_DATA_TYPE.UNICODE:
                case (int) XUSER_DATA_TYPE.CONTEXT: // I have no idea what this means.  Just check length and treat as if unicode.
                {
                    // The representation of the unicode is not how the binary reader would read it in so we 
                    // keep reading until the end of the array and add it to a string from a char array
                    StringBuilder sb = new StringBuilder();
                    char [] buf = new char[val.Length / 2];
					for(int i = 0; i < val.Length / 2; ++i)
					{
                        buf[i] = (char) br.ReadInt16();
					}
                    sb.Append(buf);
                    return sb.ToString();

                }
                case (int) XUSER_DATA_TYPE.INT32:
                case (int) XUSER_DATA_TYPE.INT64:
                {
                    // This is to gracefully handle the web settings as it is very minimalist in the number of bytes written.
                    // Namely if it is writing the integer value 1, it will only use 1 byte instead of 4.  I'm assuming that the
                    // below is sufficient and that I don't need to fully flesh out all the possible sizes (like 3)
                    long res = 0;
                    switch(ms.Length)
                    {
                        case 1:
                            res = br.ReadByte();
                            break;
                        case 2:
                            res = br.ReadInt16();
                            break;
                        case 4:
                            res = br.ReadInt32();
                            break;
                        case 8:
                            res = br.ReadInt64();
                            break;
                    };

                    if(type == (int) XUSER_DATA_TYPE.INT32)
                        return (int) res;
                    else
                        return res;
                }
				case (int) XUSER_DATA_TYPE.FLOAT: 
				{
					return br.ReadSingle();
				}
                case (int) XUSER_DATA_TYPE.DOUBLE:
                {
                    return br.ReadDouble();
                }
                case (int) XUSER_DATA_TYPE.BINARY:
                {
                    // Convert the binary value to something you can look at a little more easily
                    string s = "0x";
                    for(int i = 0; i < val.Length; i++)
                    {
                        s += val[i].ToString("X2");
                    }
                    return s;
                }
                case (int) XUSER_DATA_TYPE.DATETIME:
                {
                    long l = br.ReadInt64();
                    DateTime res = DateTime.FromFileTime(l);
                    return res;
                }
            };
            return "";
        }

        /// <summary>
        /// Converts the string value the user enters into the byte array to stuff into the database
        /// </summary>
        /// <param name="prop">setting id for the value to convert</param>
        /// <param name="val">value to convert</param>
        /// <returns>byte array as it should go into the db</returns>
        static public byte [] GetValue(int prop, string val)
        {
            // Get type and length
            int type = (int) (prop & 0xF0000000);
            int length = prop & 0x0FFF0000;

            // If it isn't valid, we don't want to write anything
            if(!IsValidValue(prop, val))
                throw new Exception("The value to set is invalid for this setting.");

            // If the value is the empty string we can just put in null
            if(val == "")
                return null;

            // Set up the streams for the conversion (don't cross them!)
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            switch(type)
            {
                case (int) XUSER_DATA_TYPE.UNICODE:
                case (int) XUSER_DATA_TYPE.CONTEXT: // I have no idea what this means.  Just check length and treat as if unicode.
                {
                    // Write a null terminated string (using BinaryWriter doesn't write null terminated strings)
                    for(int i = 0; i < val.Length; ++i)
                    {
                        bw.Write((short) val[i]);
                    }
                    bw.Write((short) 0);
                    break;
                }
                case (int) XUSER_DATA_TYPE.INT32:
                {
                    // Write values based on how the system would write them (not the web).
                    int res;
                    if(val.StartsWith("0x"))
                        res = Convert.ToInt32(val, 16);
                    else
                        res = Convert.ToInt32(val, 10);
                    bw.Write(res);
                    break;
                }
                case (int) XUSER_DATA_TYPE.INT64:
                {
                    // Write values based on how the system would write them (not the web).
                    long res;
                    if(val.StartsWith("0x"))
                        res = Convert.ToInt64(val, 16);
                    else
                        res = Convert.ToInt64(val, 10);
                    bw.Write(res);
                    break;
                }
                case (int) XUSER_DATA_TYPE.FLOAT:
                {
                    float res = Convert.ToSingle(val);
                    bw.Write(res);
                    break;
                }
                case (int) XUSER_DATA_TYPE.DOUBLE:
                {
                    double res = Convert.ToDouble(val);
                    bw.Write(res);
                    break;
                }
                case (int) XUSER_DATA_TYPE.BINARY:
                {
                    // Get the binary data and write it.
                    for(int i = (val.StartsWith("0x") ? 2 : 0); i < val.Length; i += 2)
                    {
                        bw.Write(Convert.ToByte(val.Substring(i, 2)));
                    }
                    break;
                }
                case (int) XUSER_DATA_TYPE.DATETIME:
                {
                    DateTime res = Convert.ToDateTime(val);
                    bw.Write(res.ToFileTime());
                    break;
                }
            };
            // Read the bytes and return the results
            ms.Position = 0;
            byte [] results = new byte[ms.Length];
            ms.Read(results, 0, (int) ms.Length);
            return results;
        }

        /// <summary>
        /// IsValidValue does some basic checking of the value to ensure that what is being written is "good"
        /// </summary>
        /// <param name="prop">setting id to check for</param>
        /// <param name="val">value to check</param>
        /// <returns>true if "valid", false otherwise</returns>
        static public bool IsValidValue(int prop, string val)
        {
            // Get type and length
            int type = (int) (prop & 0xF0000000);
            int length = prop & 0x0FFF0000;

            // Emptiness is always good
            if(val == "")
                return true;

            switch(type)
            {
                case (int) XUSER_DATA_TYPE.UNICODE:
                case (int) XUSER_DATA_TYPE.CONTEXT: // I have no idea what this means.  Just check length and treat as if unicode.
                    if((val.Length + 2) / 2 > length)       // Check length
                        return false;
                    return true;
                case (int) XUSER_DATA_TYPE.INT32:
                    if(!matchInt32.IsMatch(val))            // Check int32 datatype using regex first
                        return false;
                    try
                    {
                        if(val.StartsWith("0x"))            // Then actually try to convert to verify
                            Convert.ToInt32(val, 16);
                        else
                            Convert.ToInt32(val, 10);
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                case (int) XUSER_DATA_TYPE.INT64:           // Check int64 datatype using regex first
                    if(!matchInt64.IsMatch(val))
                        return false;
                    try
                    {
                        if(val.StartsWith("0x"))            // Then actually try to convert to verify
                            Convert.ToInt64(val, 16);
                        else
                            Convert.ToInt64(val, 10);
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                case (int) XUSER_DATA_TYPE.FLOAT: // Treat float as the same.  Not ideal
                case (int) XUSER_DATA_TYPE.DOUBLE:
                    if(!matchDouble.IsMatch(val))           // Check regex then attempt to convert
                        return false;
                    try
                    {
                        Convert.ToDouble(val);
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                case (int) XUSER_DATA_TYPE.BINARY:          // Check length and regex
                    if(val.Length % 2 == 1 || val.Length / 2 > length)
                        return false;
                    if(!matchBinary.IsMatch(val))
                        return false;
                    return true;
                case (int) XUSER_DATA_TYPE.DATETIME:        // Check datetime regex and then attempt conversion
                    if(!matchDateTime.IsMatch(val))
                        return false;
                    try
                    {
                        Convert.ToDateTime(val);
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
            };
            return false;
        }


        /// <summary>
        /// Enum of the possible setting data types
        /// </summary>
        public enum XUSER_DATA_TYPE
        {
            CONTEXT = 0x00000000,
            INT32 = 0x10000000,
            INT64 = 0x20000000,
            DOUBLE = 0x30000000,
            UNICODE = 0x40000000,
            FLOAT = 0x50000000,
            BINARY = 0x60000000,
            DATETIME = 0x70000000,
        };

        /// <summary>
        /// Enum of the possible profile setting sizes
        /// </summary>
        public enum XPROFILE_SETTING
        {
            SIZEOF_WCHAR = 0x00020000,
            SIZEOF_DWORD = 0x00040000,
            MAX_SIZE = 1000,
            MAX_URL_PATH = 100,
            MAX_GAMER_MOTTO = 22 * SIZEOF_WCHAR,
            MAX_CHARACTER_NAME = 16 * SIZEOF_WCHAR,
            MAX_CITY_NAME = 33 * SIZEOF_WCHAR,
            MAX_COUNTRY_NAME = 33 * SIZEOF_WCHAR,
            MAX_UNIVERSITY_NAME = 33 * SIZEOF_WCHAR,
        }

        /// <summary>
        /// Returns the setting id for a given name
        /// </summary>
		public int this[string name]
		{
			get
			{
				object o = name2id[name];
				return (o == null) ? 0 : (int) o;
			}
			set
			{
			}
		}

        /// <summary>
        /// Returns the setting name for a given id
        /// </summary>
		public string this[int id]
		{
			get
			{
				object o = id2name[id];
				return (o == null) ? "" : (string) o;
			}
			set
			{
			}
		}


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\ProgressBar.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace UserProfile
{
	/// <summary>
	/// Summary description for ProgressBar.
	/// </summary>
	public class ProgressBar : System.Windows.Forms.Form
	{
        public delegate void UpdateProgressDelegate(int progress);

        public System.Windows.Forms.ProgressBar pbProgress;
        private System.Windows.Forms.Label label1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProgressBar()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public void UpdateProgress(int progress)
        {
            pbProgress.Value = progress;
        }

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.pbProgress = new System.Windows.Forms.ProgressBar();
            this.label1 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // pbProgress
            // 
            this.pbProgress.Location = new System.Drawing.Point(64, 16);
            this.pbProgress.Name = "pbProgress";
            this.pbProgress.Size = new System.Drawing.Size(208, 16);
            this.pbProgress.TabIndex = 0;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(8, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(53, 16);
            this.label1.TabIndex = 1;
            this.label1.Text = "Progress:";
            this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // ProgressBar
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(292, 53);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.pbProgress);
            this.Name = "ProgressBar";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "ProgressBar";
            this.ResumeLayout(false);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\UserProfile\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_userprofile_none_12.4.56.0_none_a149925bf4e399cb
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=userprofile
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.manifest
XP_MANIFEST_PATH=manifests\msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.cat
XP_CATALOG_PATH=manifests\msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1.cat
XP_PAYLOAD_PATH=msil_userprofile_no-public-key_12.4.56.0_x-ww_bbdf45c1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=userprofile,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\InstanceNameAndAppPoolIDMapper.cs ===
using System;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Management;
using System.Text.RegularExpressions;
using System.Threading;

namespace InstanceMapper
{
	/// <summary>
	/// Provides a type-safe way to associate an AppPoolID with its corresponding InstanceName
	/// </summary>
	public struct InstanceNameAndAppPoolIDMap
	{
		public string AppPoolID;
		public string Win32InstanceName;
        public string CLRInstanceName;
	}

	/// <summary>
	/// When an specialized exception (i.e. COMException) is logged by an inner function with extra context dependent
	/// details but can't be handled, it is re-thrown wrapped in this LoggedException class so that the main try/catch
	/// block doesn't re-log the exception.
	/// </summary>
	public class LoggedException : System.Exception
	{
		public LoggedException(System.Exception e)
		{
			this.e = e;
		}
		public System.Exception e;
	}

	/// <summary>
	/// Given a list of machine names, maps out the relationship between AppPoolIDs and PerfMon instance names
	/// </summary>
	class InstanceNameAndAppPoolIDMapper
	{
		private const string wmiConnect  = "\\\\{0}\\root\\cimv2";
		ManualResetEvent[] ThreadCompletionEvents;

		private struct TheadData
		{
			public HybridDictionary MachinesDict;
			public string MachineName;
			public ManualResetEvent OnCompletionEvent;

			public TheadData(string MachineName, ref HybridDictionary MachinesDict, ref ManualResetEvent OnCompletionEvent)
			{
				this.MachinesDict = MachinesDict;
				this.MachineName = MachineName;
				this.OnCompletionEvent = OnCompletionEvent;
			}
		}

		private static void LogError(string errMsg)
		{
            Debug.WriteLine(errMsg);
			Console.WriteLine(errMsg);
		}

		/// <summary>
		/// IIS includes the AppPoolID as part of the command line when it launches w3wp.exe.  Given the command line,
		/// this method extracts and returns the AppPoolID
		/// </summary>
		private static string ExtractAppPoolID(string commandLine)
		{
			// We're assuming app pool names consist of alphanumerics and dashes
            Regex r = new Regex("-ap \"(?<name>[^\"]*)\"", RegexOptions.IgnoreCase | RegexOptions.Compiled);
			Match m = r.Match(commandLine);
			if (!m.Success)
			{
                LogError("ExtractAppPoolID failed: commandLine = " + commandLine);
                return("");
			}
			return m.Result("${name}");
		}

		/// <summary>
		/// Stores an IIS AppPoolID for a w3wp.exe process, indexed by that process's PID
		/// </summary>
		private static void GetAppPoolIDsByPID(HybridDictionary processMap, string machineName)
		{
			// The connection credentials - not needed if the logged in account has access
			ConnectionOptions oConnectionOptions = new ConnectionOptions();
			oConnectionOptions.Impersonation = ImpersonationLevel.Impersonate;

			// The scope
			string wmiScope = string.Format(wmiConnect, machineName);
			ManagementScope oScope = new ManagementScope(wmiScope, oConnectionOptions);

			// The query
			string[] SelectProperties = { "Name", "ProcessID", "CommandLine" };
			SelectQuery oQuery = new SelectQuery("Win32_Process", "Name=\"w3wp.exe\"", SelectProperties);

			// Run the query within the scope
			ManagementObjectSearcher oSearcher = new ManagementObjectSearcher(oScope, oQuery);

			try
			{
				foreach(ManagementObject oReturn in oSearcher.Get())
				{
					InstanceNameAndAppPoolIDMap Mapping = new InstanceNameAndAppPoolIDMap();
					Mapping.AppPoolID = ExtractAppPoolID(oReturn["CommandLine"].ToString());
					int PID = int.Parse(oReturn["ProcessId"].ToString());
					processMap.Add(PID, Mapping);
				}
			}
			catch (System.Runtime.InteropServices.COMException COMException)
			{
				string ErrorMsg = string.Format("Exception thrown\nCOM Error:\n{1}", COMException.ToString());
				LogError(ErrorMsg);
				throw(new LoggedException(COMException));
			}
			catch (System.Management.ManagementException WMIException)
			{
				string ErrorMsg = string.Format("Exception thrown\nWMI Error:\n{1}", WMIException.ToString());
				LogError(ErrorMsg);
				throw(new LoggedException(WMIException));
			}
		}

        delegate void AssignmentOp(ref InstanceNameAndAppPoolIDMap Mapping, string InstanceName);

        /// <summary>
        /// Stores a PerfMon instance name for a w3wp.exe process, indexed by that process's PID
        /// </summary>
        private static void GetInstanceNamesByPID(HybridDictionary processMap, string machineName, 
            string categoryName, string counterName, string startsWith, AssignmentOp assignmentOp)
        {
            PerformanceCounterCategory PerfCat = new PerformanceCounterCategory(categoryName, machineName);

            // NOTE: This is an extremely expensive call
            string[] InstanceNames = PerfCat.GetInstanceNames();

            foreach (string InstanceName in InstanceNames)
            {
                if (InstanceName.StartsWith(startsWith))
                {
                    // Win32 perf instance name
                    PerformanceCounter PC = new PerformanceCounter(categoryName, counterName, InstanceName, machineName);
                    int PID = int.Parse(PC.NextValue().ToString());
                    if (processMap.Contains(PID))
                    {
                        InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
                        assignmentOp(ref Mapping, InstanceName);
                        processMap[PID] = Mapping;
                    }
                }
            }
        }

        /// <summary>
		/// Stores a PerfMon instance name for a w3wp.exe process, indexed by that process's PID
		/// </summary>
        private static void GetW3WPInstanceNamesByPID(HybridDictionary processMap, string machineName)
        {
            GetInstanceNamesByPID(processMap, machineName, "Process", "ID Process", "w3wp",
                delegate(ref InstanceNameAndAppPoolIDMap Mapping, string InstanceName)
                {
                    Mapping.Win32InstanceName = InstanceName;
                }
            );
            GetInstanceNamesByPID(processMap, machineName, ".NET CLR Memory", "Process ID", "w3wp",
                delegate(ref InstanceNameAndAppPoolIDMap Mapping, string InstanceName)
                {
                    Mapping.CLRInstanceName = InstanceName;
                }
            );
        }

/*
		/// <summary>
		/// Stores a PerfMon instance name for a w3wp.exe process, indexed by that process's PID
		/// </summary>
		private static void GetInstanceNamesByPID(HybridDictionary processMap, string machineName)
		{
			PerformanceCounterCategory PerfCat = new PerformanceCounterCategory("Process", machineName);

			// NOTE: This is an extremely expensive call
			string[] InstanceNames = PerfCat.GetInstanceNames();

			foreach (string InstanceName in InstanceNames)
			{
				if (InstanceName.StartsWith("w3wp"))
				{
                    // Win32 perf instance name
                    PerformanceCounter PC = new PerformanceCounter("Process", "ID Process", InstanceName, machineName);
					int PID = int.Parse(PC.NextValue().ToString());
					if (processMap.Contains(PID))
					{
						InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
						Mapping.InstanceName = InstanceName;
						processMap[PID] = Mapping;
					}

                    // .NET CLR perf instance name
                    PerformanceCounter PC = new PerformanceCounter(".NET CLR Memory", "Process ID", InstanceName, machineName);
                    int PID = int.Parse(PC.NextValue().ToString());
                    if (processMap.Contains(PID))
                    {
                        InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
                        Mapping.InstanceName = InstanceName;
                        processMap[PID] = Mapping;
                    }
                }
			}
		}
*/
		/// <summary>
		/// Worker thread that owns collecting the data for a single machine and signaling the main thread when it's done
		/// </summary>
		static void GetInstanceNameAndAppPoolIDMapsWorker(object TargetDetails)
		{
			TheadData td = (TheadData)TargetDetails;

			try
			{
				HybridDictionary ProcessDict = new HybridDictionary();
				GetAppPoolIDsByPID(ProcessDict, td.MachineName);
				GetW3WPInstanceNamesByPID(ProcessDict, td.MachineName);
				lock(td.MachinesDict)
				{
					td.MachinesDict.Add(td.MachineName, ProcessDict);
				}
			}
			catch(LoggedException)
			{
				return;
			}
			catch(Exception e)
			{
				LogError(string.Format("Machine Name: {0}\nUnhandled Error:\n{1}\n", td.MachineName, e.ToString()));
				//throw;
			}
			finally
			{
				td.OnCompletionEvent.Set();
			}
		}

		/// <summary>
		/// Launches 1 thread per machine and waits for them to gather the data before returning the complete results
		/// </summary>
		public HybridDictionary GetInstanceNameAndAppPoolIDMaps(string[] machineNames)
		{
			int EventsIndex = 0;
			ThreadCompletionEvents = new ManualResetEvent[machineNames.GetLength(0)];
			HybridDictionary MachinesDict = new HybridDictionary();

			DateTime StartDT = DateTime.Now;
			foreach (string MachineName in machineNames)
			{
				ThreadCompletionEvents[EventsIndex] = new ManualResetEvent(false);
				ThreadPool.QueueUserWorkItem(new WaitCallback(GetInstanceNameAndAppPoolIDMapsWorker), new TheadData(MachineName, ref MachinesDict, ref ThreadCompletionEvents[EventsIndex++]));
				Thread.Sleep(0);
			}
			WaitHandle.WaitAll(ThreadCompletionEvents);
			Console.WriteLine("WMI/PerfMon information gathering elapsed time = " + DateTime.Now.Subtract(StartDT).ToString());

			return(MachinesDict);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\InstanceMapperThread.cs ===
using System;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Text;
using System.Threading;
using InstanceMapper;

namespace w3wplist
{
	/// <summary>
	/// The InstanceMapper class is the bridge between the larger XBLPerfLog appplication and the core InstanceMapper
	/// functionality, allowing InstanceMapper to integrate cleanly with XBLPerfLog
	/// </summary>
	public class InstanceMapperManager
	{
		private string[] machineNames;
		public string[] MachineNames
		{
			get
			{
				if (machineNames == null || machineNames.Length == 0)
				{
					machineNames = new string[] { "localhost" };
				}
				return(machineNames);
			}
			set
			{
				machineNames = value;
			}
		}

		/// <summary>
		/// Helper function for demo'ing and debugging
		/// </summary>
		private static void WriteMappingsToConsole(string MachineName, HybridDictionary processMap)
		{
			Console.WriteLine("Machine Name: {0}", MachineName);
			Console.WriteLine("Mappings Count = " + processMap.Count);
			foreach (int PID in processMap.Keys)
			{
				InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
                StringBuilder sb = new StringBuilder();
                sb.AppendFormat("PID: {0}\t", PID);
                sb.AppendFormat("AppPoolID: {0}\t", Mapping.AppPoolID);
                sb.AppendFormat((Mapping.AppPoolID.Length < 5 ? "\t" : ""));
                sb.AppendFormat((Mapping.AppPoolID.Length < 13 ? "\t" : ""));
                //sb.AppendFormat("\t\t" + (Mapping.AppPoolID.Length < 5 ? "\t" : ""));
                sb.AppendFormat("W32InstanceName: {0}\t", Mapping.Win32InstanceName);
                sb.AppendFormat("CLRInstanceName: {0}", Mapping.CLRInstanceName);
				Console.WriteLine(sb.ToString());
			}
			Console.WriteLine("");
		}

		/// <summary>
		/// Calls the main function for getting instance names and app pool IDs then stores the results in the DB.
		/// Cycles until instructed to shutdown.
		/// </summary>
        public void CreateMapping()
		{
			DateTime StartDT = DateTime.Now;

			// Get the data
			InstanceNameAndAppPoolIDMapper oMapper = new InstanceNameAndAppPoolIDMapper();
			HybridDictionary MachineMaps = oMapper.GetInstanceNameAndAppPoolIDMaps(MachineNames);

			// Spew it out
			foreach (string MachineName in MachineMaps.Keys)
			{
				HybridDictionary ProcessMap = (HybridDictionary)MachineMaps[MachineName];
				WriteMappingsToConsole(MachineName, ProcessMap);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\W3WPList.cs ===
using System;
using System.Threading;

namespace w3wplist
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Class1
	{
		public static void DisplayHelp()
		{
			Console.WriteLine("Use: w3wplist.exe <ServerName>");
			Console.WriteLine("\t<ServerName> defaults to localhost.");
            Console.WriteLine("Ex:  w3wplist.exe XePoolIIS007");
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			InstanceMapperManager mapper = new InstanceMapperManager();

            if (args.Length > 1)
            {
                DisplayHelp();
                return;
            }
            if (args.Length == 1)
			{
                if (args[0] == "/?")
                {
                    DisplayHelp();
                    return;
                }
                mapper.MachineNames = args;
			}
            mapper.CreateMapping();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_w3wplist_none_12.4.56.0_none_3bfc5d85b2ddb42c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=w3wplist
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.manifest
XP_MANIFEST_PATH=manifests\msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.cat
XP_CATALOG_PATH=manifests\msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.cat
XP_PAYLOAD_PATH=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=w3wplist,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\w3wplist\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_w3wplist_none_12.4.56.0_none_3bfc5d85b2ddb42c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=w3wplist
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.manifest
XP_MANIFEST_PATH=manifests\msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.cat
XP_CATALOG_PATH=manifests\msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56.cat
XP_PAYLOAD_PATH=msil_w3wplist_no-public-key_12.4.56.0_x-ww_4ff53e56
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=w3wplist,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\video_music_migration_tests\MusicMigrationTest.cs ===
//When run, automates the testing of video/music migrations.
//
//NOTE:This relies heavily on ServerTestFramework.  Specifically, it relies on
//ServerTestFramework.dll and stf.xml being in the same directory as wherever it is.


using System;
using System.Xml;
using System.Data.SqlClient;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;
using ServerTestFramework.LiveService.FakeSG;

public class MusicMigrationTest {

    public static SqlConnection uodb;

    public const string UODB_SERVER = "XeUserSqlW01";

    //Functions and classes all related to getting info out of the DB
    public static void FillWithReader(out Decimal variable, SqlDataReader reader, int ordinal) {
        variable =(ulong) reader.GetDecimal(ordinal);
    }
    public static void FillWithReader(out ulong variable, SqlDataReader reader, int ordinal) {
        variable =(ulong) reader.GetInt64(ordinal);
    }
    public static void FillWithReader(out string variable, SqlDataReader reader, int ordinal) {
        variable = reader.GetString(ordinal);
    }
    public static void FillWithReader(out Guid variable, SqlDataReader reader, int ordinal) {
        variable = reader.GetGuid(ordinal);
    }
    public static void FillWithReader(out int variable, SqlDataReader reader, int ordinal) {
        variable = reader.GetInt32(ordinal);
    }
    public static void FillWithReader(out short variable, SqlDataReader reader, int ordinal) {
        variable = reader.GetInt16(ordinal);
    }
    public static void FillWithReader(out byte variable, SqlDataReader reader, int ordinal) {
        variable = reader.GetByte(ordinal);
    }
    public static void FillWithReader(out DateTime variable, SqlDataReader reader, int ordinal) {
        variable = reader.GetDateTime(ordinal);
    }

/*****************************************************************************************************************/
/**********************              MUSIC MIGRATION TABLES            *******************************************/
/*****************************************************************************************************************/

    public class DmpPurchaseTransactionsRow {
        public ulong bi_user_puid;
	public ulong bi_machine_puid;
	public Guid uid_tracking_guid;
	public int i_status_id;
	public string vc_confirmation_id;
	public int i_hresult;
	public string vc_error_code;
	public string vc_error_xml;
	public DateTime dt_transaction_start;
	public DateTime dt_transaction_end;
	public string vc_alternate_url;
	public short si_hash_bucket;
	public DateTime dt_change_datetime;
	public int i_purchase_type_id;
	public string vc_ip_address;

        public DmpPurchaseTransactionsRow (SqlDataReader reader) {
            FillWithReader(out bi_user_puid, reader, 0);
            FillWithReader(out bi_machine_puid, reader, 1);
            FillWithReader(out uid_tracking_guid, reader, 2);
            FillWithReader(out i_status_id, reader, 3);
            FillWithReader(out vc_confirmation_id, reader, 4);
            FillWithReader(out i_hresult, reader, 5);
            FillWithReader(out vc_error_code, reader, 6);
            FillWithReader(out vc_error_xml, reader, 7);
            FillWithReader(out dt_transaction_start, reader, 8);
            FillWithReader(out dt_transaction_end, reader, 9);
            FillWithReader(out vc_alternate_url, reader, 10);
            FillWithReader(out si_hash_bucket, reader, 11);
            FillWithReader(out dt_change_datetime, reader, 12);
            FillWithReader(out i_purchase_type_id, reader, 13);
            FillWithReader(out vc_ip_address, reader, 14);
        }

        public DmpPurchaseTransactionsRow (Guid guid) {

            string selectAllRowsType2 = "Select * from t_dmp_purchase_transactions where uid_tracking_guid = '" + guid + "'";
            SqlCommand query = new SqlCommand(selectAllRowsType2, uodb);
            SqlDataReader reader = query.ExecuteReader();

            if (reader.Read())
            {
                FillWithReader(out bi_user_puid, reader, 0);
                FillWithReader(out bi_machine_puid, reader, 1);
                FillWithReader(out uid_tracking_guid, reader, 2);
                FillWithReader(out i_status_id, reader, 3);
                FillWithReader(out vc_confirmation_id, reader, 4);
                FillWithReader(out i_hresult, reader, 5);
                FillWithReader(out vc_error_code, reader, 6);
                FillWithReader(out vc_error_xml, reader, 7);
                FillWithReader(out dt_transaction_start, reader, 8);
                FillWithReader(out dt_transaction_end, reader, 9);
                FillWithReader(out vc_alternate_url, reader, 10);
                FillWithReader(out si_hash_bucket, reader, 11);
                FillWithReader(out dt_change_datetime, reader, 12);
                FillWithReader(out i_purchase_type_id, reader, 13);
                FillWithReader(out vc_ip_address, reader, 14);                
            } else {
                reader.Close();
                throw new Exception("No transaction row for guid " + guid + "!");
            }
            reader.Close();
        }
    }

    public class DmpPurchaseTransactionsTable {
        public Hashtable table;

        public DmpPurchaseTransactionsTable() {
            table = new Hashtable();
        }
        //type = 2 for music, 3 for video
        public void Load(int type) {
            Console.WriteLine("Loading t_dmp_purchase_transactions data from " + UODB_SERVER + "...");

            //get only music purchase(i_purchase_type_id = 2) which have succeeded (i_status_id =2).
            //also ensure we don't get transactions that are too recent(i.e. after the migration occurs)
            string selectAllRowsType2 = "Select * from t_dmp_purchase_transactions where i_purchase_type_id = " + 
                type + " and i_status_id = 2 and dt_change_datetime < '2007-09-15'"; 
            SqlCommand query = new SqlCommand(selectAllRowsType2, uodb);
            SqlDataReader reader = query.ExecuteReader();

            //let's see... plenty of memory on a client box, so I'm not going to bother running in chunks.

            while (reader.Read())
            {
                DmpPurchaseTransactionsRow newRow = new DmpPurchaseTransactionsRow(reader);
                table.Add(newRow.uid_tracking_guid, newRow);
            }
            reader.Close();
            Console.WriteLine("done!\n");
        }
    }

    public class DmpPurchaseTransactionMusicDetailsRow {
     	public Guid uid_tracking_guid;
	public string vc_external_id;
	public string vc_ip_address;
	public string vc_alternate_url;
	public int i_error_code;
	public string vc_error_xml;
	public DateTime dt_transaction_start;
	public DateTime dt_transaction_end;
	public short si_hash_bucket;
	public DateTime dt_change_datetime;

        public DmpPurchaseTransactionMusicDetailsRow(Guid guid) {
            string cmd = "Select * from t_dmp_purchase_transaction_music_details where uid_tracking_guid = '" + guid.ToString() + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();

            while (reader.Read())
            {
                FillWithReader(out uid_tracking_guid, reader, 0);
                FillWithReader(out vc_external_id, reader, 1);
                FillWithReader(out vc_ip_address, reader, 2);
                FillWithReader(out vc_alternate_url, reader, 3);
                FillWithReader(out i_error_code, reader, 4);
                FillWithReader(out vc_error_xml, reader, 5);
                FillWithReader(out dt_transaction_start, reader, 6);
                FillWithReader(out dt_transaction_end, reader, 7);
                FillWithReader(out si_hash_bucket, reader, 8);
                FillWithReader(out dt_change_datetime, reader, 9);
            }
            reader.Close();
        }
    }

/*
    public static string GetMnetIdFromOfferInstId(Guid uid_offer_instance_id) {
        SqlConnection uodb = new SqlConnection("server=" + UODB_SERVER + ";database=uodb;Integrated Security=SSPI");
        uodb.Open();

        string cmd = "Select vc_musicnet_mnetid from t_migration_music_map where uid_offer_instance_id = '" + 
            uid_offer_instance_id.ToString() + "'";
        SqlCommand query = new SqlCommand(cmd, uodb);
        SqlDataReader reader = query.ExecuteReader();

        string mnetid = ""; 
        while (reader.Read())
        {
            FillWithReader(out mnetid, reader, 0);
        }
        reader.Close();
        uodb.Close();
        return mnetid;
    }

    public static Guid GetOffIdFromMnetId(string mnetid) {
        SqlConnection uodb = new SqlConnection("server=" + UODB_SERVER + ";database=uodb;Integrated Security=SSPI");
        uodb.Open();

        string cmd = "Select uid_offer_id from t_migration_music_map where vc_musicnet_mnetid = '" + mnetid + "'";

        SqlCommand query = new SqlCommand(cmd, uodb);
        SqlDataReader reader = query.ExecuteReader();

        Guid offId;
        while (reader.Read())
        {
            FillWithReader(out offId, reader, 0);
        }
        reader.Close();
        uodb.Close();
        return offId;
    }
*/
    public class DmpPurchaseTransactionMusicItemsArray {
        public ArrayList items;

        public DmpPurchaseTransactionMusicItemsArray(Guid guid) {
            items = new ArrayList();
            string cmd = "Select * from t_dmp_purchase_transaction_music_items where uid_tracking_guid = '" + guid.ToString() + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();

            while (reader.Read()) {
                items.Add(new DmpPurchaseTransactionMusicItemsRow(reader));
            }
            reader.Close();
        }

        public DmpPurchaseTransactionMusicItemsRow GetRowWithThisMnetid(string mnetid) {
            for(int i=0; i<items.Count; i++) {
                DmpPurchaseTransactionMusicItemsRow row = (DmpPurchaseTransactionMusicItemsRow) items[i];
                if (row.vc_musicnet_mnetid.Equals(mnetid)) {
                    return row;
                }
            }
            throw new Exception("No matching item for the musicnetid = " + mnetid);
        }
        
    }
    public class DmpPurchaseTransactionMusicItemsRow {
        public Guid uid_tracking_guid;
        public string vc_musicnet_mnetid;
        public int i_musicnet_item_type_id;
        public string vc_artist_name;
        public string vc_item_title;
        public int i_retail_price_in_points;
	public Decimal sm_retail_price;   //smallmoney... is an int?
	public Decimal sm_wholesale_price;   //smallmoney... is an int?  GetDecimal?
        public short si_hash_bucket;
        public DateTime dt_change_datetime;

        public DmpPurchaseTransactionMusicItemsRow(SqlDataReader reader) {
            FillWithReader(out uid_tracking_guid, reader, 0);
            FillWithReader(out vc_musicnet_mnetid, reader, 1);
            FillWithReader(out i_musicnet_item_type_id, reader, 2);
            FillWithReader(out vc_artist_name, reader, 3);
            FillWithReader(out vc_item_title, reader, 4);
            FillWithReader(out i_retail_price_in_points, reader, 5);
            FillWithReader(out sm_retail_price, reader, 6);
            FillWithReader(out sm_wholesale_price, reader, 7);
            FillWithReader(out si_hash_bucket, reader, 8);
            FillWithReader(out dt_change_datetime, reader, 9);
        }

        public bool CanBeMigrated() {

            string cmd = "Select count(*) from t_migration_music_map where vc_musicnet_mnetid = '" + vc_musicnet_mnetid + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            int ans = (int) query.ExecuteScalar();

            if (ans == 0) return false;
            return true;
        }

    }


    public class DmpPurchaseTransactionMediaArray {
        public ArrayList items;

        public DmpPurchaseTransactionMediaArray(Guid guid) {
            items = new ArrayList();

            string cmd = "Select * from t_dmp_purchase_transaction_media where uid_tracking_guid = '" + guid.ToString() + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();
            bool dataFound = false;

            while (reader.Read()) {
                dataFound = true;
                items.Add(new DmpPurchaseTransactionMediaRow(reader));
            }
            reader.Close();

            if (!dataFound) {
                throw new Exception("No data found for t_dmp_purchase_transaction_media where uid_tracking_guid = '" + guid.ToString() + "'");
            }
        }

    }

    public class DmpPurchaseTransactionMediaRow {
        public Guid uid_tracking_guid;
        public Guid uid_offer_instance_id;
        public int i_retail_price_points;
        public Decimal dec_retail_price;
        public string vc_retail_price_currency;
        public Decimal dec_wholesale_price;
        public string vc_wholesale_price_currency;
        public Guid uid_promotion_id;
        public int i_pricing_rule_id;
        public short si_hash_bucket;
        public DateTime dt_change_datetime;
        public int i_store_id;

        public DmpPurchaseTransactionMediaRow (SqlDataReader reader) {
            FillWithReader(out uid_tracking_guid, reader, 0);
            FillWithReader(out uid_offer_instance_id, reader, 1);
            FillWithReader(out i_retail_price_points, reader, 2);
            FillWithReader(out dec_retail_price, reader, 3);
            FillWithReader(out vc_retail_price_currency, reader, 4);
            FillWithReader(out dec_wholesale_price, reader, 5);
            FillWithReader(out vc_wholesale_price_currency, reader, 6);
            if (reader.IsDBNull(7)) {
                uid_promotion_id = Guid.Empty;
            } else {
                FillWithReader(out uid_promotion_id, reader, 7);
            }
            FillWithReader(out i_pricing_rule_id, reader, 8);
            FillWithReader(out si_hash_bucket, reader, 9);
            FillWithReader(out dt_change_datetime, reader, 10);
            FillWithReader(out i_store_id, reader, 11);
        }
    }

    public class UserOfferInstancePurchaseArray {
        public ArrayList items;

        public UserOfferInstancePurchaseArray(DmpPurchaseTransactionMediaArray mediaArray, ulong puid) {
            //run through each of the media purchase transactions and grab the related offer
            //purchase.  This is a parallel array to the DmpPurchaseTransactionMediaArray.
            items = new ArrayList();
            for (int i=0; i<mediaArray.items.Count; i++) {
                Guid offer_instance_id = ((DmpPurchaseTransactionMediaRow) mediaArray.items[i]).uid_offer_instance_id;
                items.Add(new UserOfferInstancePurchasesRow(offer_instance_id, puid));
            }
        }
    }

    public class UserOfferInstancePurchasesRow {
        public ulong bi_user_puid;
        public ulong bi_machine_puid;
        public Guid uid_offer_instance_id;
        public Guid uid_offer_id;
        public int i_offer_media_type_id;
        public DateTime dt_purchased;
        public short si_hash_bucket;
        public DateTime dt_change_datetime;
        public int i_store_id;

        public UserOfferInstancePurchasesRow(Guid offer_instance_id, ulong puid) {

            string cmd = "Select * from t_user_offer_instance_purchases where uid_offer_instance_id = '" + 
                offer_instance_id + "' and bi_user_puid = " + puid;
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();
            


            if (reader.Read())
            {
                FillWithReader(out bi_user_puid, reader, 0);
                FillWithReader(out bi_machine_puid, reader, 1);
                FillWithReader(out uid_offer_instance_id, reader, 2);
                FillWithReader(out uid_offer_id, reader, 3);
                FillWithReader(out i_offer_media_type_id, reader, 4);
                FillWithReader(out dt_purchased, reader, 5);
                FillWithReader(out si_hash_bucket, reader, 6);
                FillWithReader(out dt_change_datetime, reader, 7);
                FillWithReader(out i_store_id, reader, 8);
            } else {
                reader.Close();
                throw new Exception("Error!  No UserOfferInstancePurchasesRow for the offer_instance_id " + offer_instance_id.ToString());
            }
            if (reader.Read()) {
                //now we see two.  Just as bad.
                reader.Close();
                throw new Exception("Error!  Two UserOfferInstancePurchasesRows for the offer_instance_id " + offer_instance_id.ToString());
            }

            reader.Close();
        }
    }


    public class MigrationTransactionPurchaseRow {
        public Guid uid_tracking_guid;
        public Guid uid_new_tracking_guid;
        public int i_migration_type;
        public int i_migration_status;
        public short si_hash_bucket;

        public MigrationTransactionPurchaseRow(Guid guid) {
            string cmd = "Select * from t_migration_transaction_map where uid_tracking_guid = '" + guid.ToString() + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();

            if (reader.Read()) {
                FillWithReader(out uid_tracking_guid, reader, 0);
                FillWithReader(out uid_new_tracking_guid, reader, 1);
                FillWithReader(out i_migration_type, reader, 2);
                FillWithReader(out i_migration_status, reader, 3);
                FillWithReader(out si_hash_bucket, reader, 4);
            } else {
                reader.Close();
                throw new Exception("Error!  No migration transaction map for guid " + guid.ToString() + " when expected!");
            }
            reader.Close();
        }            

    }


    public class MigrationMusicMapRow {
        public string vc_musicnet_mnetid;
        public Guid uid_media_id;
        public int i_media_type_id;
        public Guid uid_offer_id;
        public Guid uid_offer_instance_id;
        public int i_pricing_rule_id;

        public MigrationMusicMapRow(Guid guid) {
            string cmd = "Select * from t_migration_music_map where uid_offer_instance_id = '" + guid + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();

            if (reader.Read()) {
                FillWithReader(out vc_musicnet_mnetid, reader, 0);
                FillWithReader(out uid_media_id, reader, 1);
                FillWithReader(out i_media_type_id, reader, 2);
                FillWithReader(out uid_offer_id, reader, 3);
                FillWithReader(out uid_offer_instance_id, reader, 4);
                FillWithReader(out i_pricing_rule_id, reader, 5);
            } else {
                reader.Close();
                throw new Exception("Error!  No migration map for guid " + guid.ToString() + " when expected!");
            }

            reader.Close();
        }

    }

    public static int GetCountMigrations(int status, int type) {
            string cmd = "Select count(*) from t_migration_transaction_map where i_migration_status = " + 
                status + " and i_migration_type = " + type;
            SqlCommand query = new SqlCommand(cmd, uodb);
            int num = (int) query.ExecuteScalar();

            return num;
    }



/*****************************************************************************************************************/
/**********************              VIDEO MIGRATION TABLES            *******************************************/
/*****************************************************************************************************************/

    public class DmpPurchaseTransactionVideoItemsArray {
        public ArrayList items;

        public DmpPurchaseTransactionVideoItemsArray(Guid guid) {
            items = new ArrayList();
            string cmd = "Select * from t_dmp_purchase_transaction_video_items where uid_tracking_guid = '" + guid.ToString() + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();

            while (reader.Read()) {
                items.Add(new DmpPurchaseTransactionVideoItemsRow(reader));
            }
            reader.Close();
        }        

        public DmpPurchaseTransactionVideoItemsRow GetRowWithThisWmid(Guid guid) {
            for(int i=0; i<items.Count; i++) {
                DmpPurchaseTransactionVideoItemsRow row = (DmpPurchaseTransactionVideoItemsRow) items[i];
                if (row.uid_wmid.Equals(guid)) {
                    return row;
                }
            }
            throw new Exception("No matching item for the Wmid = " + guid.ToString());
        }

    }

    public class DmpPurchaseTransactionVideoItemsRow {
        public Guid uid_tracking_guid;
        public Guid uid_wmid;
        public int i_video_type_id;
        public int i_video_quality_id;
        public byte ti_is_drm_protected;
        public string vc_item_title;
        public int i_retail_price_in_points;
        public Decimal sm_retail_price;
        public Decimal sm_wholesale_price;
        public short si_hash_bucket;
        public DateTime dt_change_datetime;

        public DmpPurchaseTransactionVideoItemsRow(SqlDataReader reader) {
            FillWithReader(out uid_tracking_guid, reader, 0);
            FillWithReader(out uid_wmid, reader, 1);
            FillWithReader(out i_video_type_id, reader, 2);
            FillWithReader(out i_video_quality_id, reader, 3);
            FillWithReader(out ti_is_drm_protected, reader, 4);
            FillWithReader(out vc_item_title, reader, 5);
            FillWithReader(out i_retail_price_in_points, reader, 6);
            FillWithReader(out sm_retail_price, reader, 7);
            FillWithReader(out sm_wholesale_price, reader, 8);
            FillWithReader(out si_hash_bucket, reader, 9);
            FillWithReader(out dt_change_datetime, reader, 10);
        }

        public bool CanBeMigrated() {

            string cmd = "Select count(*) from t_migration_video_map where uid_wmid = '" + uid_wmid + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            int ans = (int) query.ExecuteScalar();

            if (ans == 0) return false;
            return true;
        }

    }

    public class UserMediaInstanceLicenseState {
        public ulong bi_user_puid;
        public Guid uid_media_instance_id;
        public Guid uid_offer_instance_id;
        public int i_state;
        public DateTime dt_state_changed;
        public short si_hash_bucket;
        public DateTime dt_change_datetime;


        public UserMediaInstanceLicenseState(ulong userPuid, Guid mediaId, Guid offerInstanceId) {
            string cmd = "Select * from t_user_media_instance_license_state where bi_user_puid = + " + userPuid + 
                " and uid_media_instance_id = '" + mediaId + "' and uid_offer_instance_id = '" + offerInstanceId + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();

            if (reader.Read()) {
                FillWithReader(out bi_user_puid, reader, 0);
                FillWithReader(out uid_media_instance_id, reader, 1);
                FillWithReader(out uid_offer_instance_id, reader, 2);
                FillWithReader(out i_state, reader, 3);
                FillWithReader(out dt_state_changed, reader, 4);
                FillWithReader(out si_hash_bucket, reader, 5);
                FillWithReader(out dt_change_datetime, reader, 6);
            } else {
                reader.Close();
                throw new Exception ("No user media instance license data found for puid " + 
                                     userPuid + ", mediaId " + mediaId + ", offerInstanceId " + offerInstanceId);
            }
            reader.Close();

        }

    }

    public class UserPpvLicensesArray {
        public ArrayList items;

        public UserPpvLicensesArray () {
            items = new ArrayList();
        }

        public void Load() {
            //grab the whole table into memory
            string cmd = "Select * from t_user_ppv_licenses";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();
            try {
                while (reader.Read()) {
                    items.Add(new UserPpvLicenseRow(reader));
                }
            } catch (SqlException) {
                Console.WriteLine("ERROR in reading PPV licenses table!");
            }
            reader.Close();
            Console.WriteLine("Loaded license table!");
        }
    }

    public class UserPpvLicenseRow {
        public ulong bi_user_puid;
        public ulong bi_machine_puid;
        public Guid uid_wmid;
        public int i_video_type_id;
        public DateTime dt_purchased;
        public DateTime dt_expiration;
        public int i_view_hours;
        public int i_view_count;
        public int i_acknowledged;
        public short si_hash_bucket;
        public DateTime dt_change_datetime;


        public UserPpvLicenseRow(SqlDataReader reader) {
            FillWithReader(out bi_user_puid, reader, 0);
            FillWithReader(out bi_machine_puid, reader, 1);
            FillWithReader(out uid_wmid, reader, 2);
            FillWithReader(out i_video_type_id, reader, 3);
            FillWithReader(out dt_purchased, reader, 4);
            FillWithReader(out dt_expiration, reader, 5);
            FillWithReader(out i_view_hours, reader, 6);
            FillWithReader(out i_view_count, reader, 7);
            FillWithReader(out i_acknowledged, reader, 8);
            FillWithReader(out si_hash_bucket, reader, 9);
            FillWithReader(out dt_change_datetime, reader, 10);
        }
    }

    public class MigrationVideoMapArray {
        public ArrayList items;
        

        public MigrationVideoMapArray(Guid guid) {
            items = new ArrayList();
            string cmd = "Select * from t_migration_video_map where uid_offer_instance_id = '" + guid + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();
            while (reader.Read()) {
                items.Add(new MigrationVideoMapRow(reader));
            }
            reader.Close();
        
        }
    }

    public class MigrationVideoMapRow {
        public Guid uid_wmid;
        public Guid uid_media_id;
        public int i_media_type_id;
        public Guid uid_offer_id;
        public Guid uid_offer_instance_id;
        public int i_pricing_rule_id;

        public MigrationVideoMapRow(SqlDataReader reader) {
                FillWithReader(out uid_wmid, reader, 0);
                FillWithReader(out uid_media_id, reader, 1);
                FillWithReader(out i_media_type_id, reader, 2);
                FillWithReader(out uid_offer_id, reader, 3);
                FillWithReader(out uid_offer_instance_id, reader, 4);
                FillWithReader(out i_pricing_rule_id, reader, 5);
        }

        //shortcut to get this row based only on its PK, wmid
        public MigrationVideoMapRow(Guid wmid) {
            string cmd = "Select * from t_migration_video_map where uid_wmid = '" + wmid + "'";
            SqlCommand query = new SqlCommand(cmd, uodb);
            SqlDataReader reader = query.ExecuteReader();
            if (reader.Read()) {
                FillWithReader(out uid_wmid, reader, 0);
                FillWithReader(out uid_media_id, reader, 1);
                FillWithReader(out i_media_type_id, reader, 2);
                FillWithReader(out uid_offer_id, reader, 3);
                FillWithReader(out uid_offer_instance_id, reader, 4);
                FillWithReader(out i_pricing_rule_id, reader, 5);
            }
            reader.Close();
        }

    }


    public static ulong GetMostRecentMachinePuidForThisOffer(ulong bi_user_puid, Guid uid_offer_instance_id) {
        string cmd = "select top 1 bi_machine_puid from t_dmp_purchase_transactions dmp " +
            " inner join t_dmp_purchase_transaction_media dptm ON " +
            "	dmp.uid_tracking_guid = dptm.uid_tracking_guid " +
            " where dmp.bi_user_puid = " + bi_user_puid +
            " and dptm.uid_offer_instance_id = '" + uid_offer_instance_id + "' " +
            "order by dmp.dt_change_datetime desc";
        SqlCommand query = new SqlCommand(cmd, uodb);
        ulong ans = 0;

        SqlDataReader reader = query.ExecuteReader();
        if (reader.Read()) {
            FillWithReader(out ans, reader, 0);                
        } else {
            throw new Exception ("Couldn't get the machine puid for offer instance id " +
                                 uid_offer_instance_id.ToString() + "!");
        }
        reader.Close();
            
        return ans;
    }

    public static Guid GetGuidThatShouldHoldLicense(ulong bi_user_puid, Guid uid_wmid) {
        string cmd = "select dmp.uid_tracking_guid from t_dmp_purchase_transactions dmp " +
            "inner join t_dmp_purchase_transaction_video_items dptvi on " +
            " 	dmp.uid_tracking_guid = dptvi.uid_tracking_guid " +
            "where " +
            "dmp.bi_user_puid = " + bi_user_puid + 
            " and dmp.i_purchase_type_id = 3 " +
            " and dptvi.uid_wmid = '" + uid_wmid + "' " +
            " order by dptvi.dt_change_datetime desc";
        SqlCommand query = new SqlCommand(cmd, uodb);
        Guid ans = Guid.Empty;
        try {
            SqlDataReader reader = query.ExecuteReader();
            if (reader.Read()) {
                FillWithReader(out ans, reader, 0);                
            } else {
                throw new Exception ("Couldn't get the guid for the user + " + bi_user_puid + " purchasing " + uid_wmid);
            }
            reader.Close();
        } catch (SqlException) {
                throw new Exception ("Timeout when getting the guid for the user + " + bi_user_puid + " purchasing " + uid_wmid + ".  Please check by hand!");
        }
        return ans;
    }

    public static void VerifyDateTimeIsSoon(DateTime date) {
        if (date < new DateTime(2007, 11, 1)) {
            throw new Exception ("Date for a migrated row is too early!  Date is " + date);
        }
    }

/*****************************************************************************************************************/
/**********************                    MAIN BODY                   *******************************************/
/*****************************************************************************************************************/

    public static void InitSTF() {
        XmlDocument config = new XmlDataDocument();
        try
        {
            config.Load("stf.xml");
        }
        catch (System.IO.FileNotFoundException)
        {
            Console.WriteLine("Error: Unable to find config file \"stf.xml\" in the current directory.");
            return;
        }
        Global.Initialize(config);

        // We need fakeSG for achievements stuff to work apparently.
        GlobalFakeSG.FakeSG = new FakeSGClient("FakeSGClient");
        if(!GlobalFakeSG.FakeSG.ConnectToService())
        {
            Console.WriteLine("Failed to connect to FakeSG Service... achievement setting will likely fail.");
        }
        else
        {
            GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());
        }
    }


    public static void VerifyMusicMigration() {
        //let's work in batches of 1000?  Or slurp the whole DB into memory?
        //we need to hit a particular SQL server...  does UODB use webstore?  Will this be out of
        //date?
        //it's partitioned, so direct SQL should be ok.

        DmpPurchaseTransactionsTable dmpPurchaseTable = new DmpPurchaseTransactionsTable();
        dmpPurchaseTable.Load(2);

        //we may not need to load all the tables--  just load the guids, and then run little sql
        //selects for each one...  we'll still need all the rows though.
        Global.RO.Info("Verifying rows...");
        int count =0;
        int migrated = 0;
        foreach (DmpPurchaseTransactionsRow dmpRow in dmpPurchaseTable.table.Values) {
            count++;
            if ((count % 1000) == 0) {
                Console.WriteLine(count + " rows verified...");
            }
            Guid oldGuid = Guid.Empty;
//            try {
                oldGuid = dmpRow.uid_tracking_guid;

                //load all the old info about this transaction
                DmpPurchaseTransactionMusicDetailsRow musicDetailsRow = new DmpPurchaseTransactionMusicDetailsRow(oldGuid);
                DmpPurchaseTransactionMusicItemsArray musicItemsArray = new DmpPurchaseTransactionMusicItemsArray(oldGuid);

                //load the transaction map table...  (we only verify post-migration)
                MigrationTransactionPurchaseRow mtpRow = new MigrationTransactionPurchaseRow(oldGuid);
                //regardless of what should happen, this mtpRow had better have the correct
                //si_hash_bucket in it.
                ValueCheck.Test("si_hash_bucket", mtpRow.si_hash_bucket, dmpRow.si_hash_bucket);

                Guid newGuid = mtpRow.uid_new_tracking_guid;

                //check if this row *can* migrate...  and if it can, is it some, or all?  for now let's
                //assume nothing is done.
                bool canBeMigrated = true;
                for(int i=0; i<musicItemsArray.items.Count; i++) {
                    DmpPurchaseTransactionMusicItemsRow row = (DmpPurchaseTransactionMusicItemsRow) musicItemsArray.items[i];
                    if (!row.CanBeMigrated()) {
                        canBeMigrated = false;
                    }
                }
                if (!canBeMigrated) {
                    bool dataPresent = false;
                    //verify that the row is in error status.
                    ValueCheck.Test("i_migration_status", mtpRow.i_migration_status, -1);
                    try {
                        DmpPurchaseTransactionsRow newDmpRowTest = new DmpPurchaseTransactionsRow(newGuid);
                        dataPresent = true;
                    } catch (Exception) {}
                    try {
                        DmpPurchaseTransactionMediaArray mediaArrayTest = new DmpPurchaseTransactionMediaArray(newGuid);
                        dataPresent = true;
                    } catch (Exception) {}
                    //cannot check userofferinstancepurchasearray--no data from the previous table.
                    if (dataPresent) {
                        throw new Exception("Data found in the tables for a migration that should be in error!");
                    }
                    continue; //skip the verify
                } 

                migrated ++;
                //load all the new info about this transaction
                DmpPurchaseTransactionsRow newDmpRow = new DmpPurchaseTransactionsRow(newGuid);
                DmpPurchaseTransactionMediaArray mediaArray = new DmpPurchaseTransactionMediaArray(newGuid);
                UserOfferInstancePurchaseArray purchaseArray = new UserOfferInstancePurchaseArray(mediaArray, dmpRow.bi_user_puid);
            
                //now that we have the tables, we verify.


                //transaction to transaction should be identical, except for i_purchase_type which
                //should be 5, and the guid.
                ValueCheck.Test("bi_user_puid", dmpRow.bi_user_puid, newDmpRow.bi_user_puid);
                ValueCheck.Test("bi_machine_puid", dmpRow.bi_machine_puid, newDmpRow.bi_machine_puid);
//            ValueCheck.Test("uid_tracking_guid", dmpRow.uid_tracking_guid, newDmpRow.uid_tracking_guid);
                ValueCheck.Test("i_status_id", dmpRow.i_status_id, newDmpRow.i_status_id);
                ValueCheck.Test("vc_confirmation_id", dmpRow.vc_confirmation_id, newDmpRow.vc_confirmation_id);
                ValueCheck.Test("i_hresult", dmpRow.i_hresult, newDmpRow.i_hresult);
                ValueCheck.Test("vc_error_code", dmpRow.vc_error_code, newDmpRow.vc_error_code);
                ValueCheck.Test("vc_error_xml", dmpRow.vc_error_xml, newDmpRow.vc_error_xml);
                ValueCheck.Test("dt_transaction_start", dmpRow.dt_transaction_start, newDmpRow.dt_transaction_start);
                ValueCheck.Test("dt_transaction_end", dmpRow.dt_transaction_end, newDmpRow.dt_transaction_end);
                ValueCheck.Test("vc_alternate_url", dmpRow.vc_alternate_url, newDmpRow.vc_alternate_url);
                ValueCheck.Test("si_hash_bucket", dmpRow.si_hash_bucket, newDmpRow.si_hash_bucket);
//                ValueCheck.Test("dt_change_datetime", dmpRow.dt_change_datetime, newDmpRow.dt_change_datetime);
                VerifyDateTimeIsSoon(newDmpRow.dt_change_datetime);
                ValueCheck.Test("i_purchase_type_id", 5, newDmpRow.i_purchase_type_id); //this should be 5.
                ValueCheck.Test("vc_ip_address", dmpRow.vc_ip_address, newDmpRow.vc_ip_address);

                //We should get a copy of this with the new guid.
                DmpPurchaseTransactionMusicDetailsRow copiedMusicDetailsRow = new DmpPurchaseTransactionMusicDetailsRow(newGuid);
                ValueCheck.Test("uid_tracking_guid", copiedMusicDetailsRow.uid_tracking_guid, newGuid);
                ValueCheck.Test("vc_external_id", new Guid(copiedMusicDetailsRow.vc_external_id), oldGuid);
                ValueCheck.Test("vc_ip_address", copiedMusicDetailsRow.vc_ip_address,  musicDetailsRow.vc_ip_address);
                ValueCheck.Test("vc_alternate_url", copiedMusicDetailsRow.vc_alternate_url, musicDetailsRow.vc_alternate_url);
                ValueCheck.Test("i_error_code", copiedMusicDetailsRow.i_error_code, musicDetailsRow.i_error_code);
                ValueCheck.Test("vc_error_xml", copiedMusicDetailsRow.vc_error_xml, musicDetailsRow.vc_error_xml);
                ValueCheck.Test("dt_transaction_start", copiedMusicDetailsRow.dt_transaction_start, musicDetailsRow.dt_transaction_start);
                ValueCheck.Test("dt_transaction_end", copiedMusicDetailsRow.dt_transaction_end, musicDetailsRow.dt_transaction_end);
                ValueCheck.Test("si_hash_bucket", copiedMusicDetailsRow.si_hash_bucket, musicDetailsRow.si_hash_bucket);
//                ValueCheck.Test("dt_change_datetime", copiedMusicDetailsRow.dt_change_datetime, musicDetailsRow.dt_change_datetime);
                VerifyDateTimeIsSoon(copiedMusicDetailsRow.dt_change_datetime);


                //Verify the music mappings
                //dmp_transaction_media
                for(int i=0; i<mediaArray.items.Count; i++) {
                    DmpPurchaseTransactionMediaRow row = (DmpPurchaseTransactionMediaRow) mediaArray.items[i];
                    MigrationMusicMapRow mapRow = new MigrationMusicMapRow(row.uid_offer_instance_id);

                    DmpPurchaseTransactionMusicItemsRow musicItemsRow = musicItemsArray.GetRowWithThisMnetid(mapRow.vc_musicnet_mnetid);

                    ValueCheck.Test("uid_tracking_guid", row.uid_tracking_guid, newGuid);
//                    ValueCheck.test("uid_offer_instance_id", row.uid_offer_instance_id,   //we'll
//                    check this matches the offer_instance_purchase
                    ValueCheck.Test("i_retail_price_points", row.i_retail_price_points, 
                                    musicItemsRow.i_retail_price_in_points);
                    ValueCheck.Test("dec_retail_price", row.dec_retail_price,
                                    musicItemsRow.sm_retail_price);
                    ValueCheck.Test("vc_retail_price_currency", row.vc_retail_price_currency, "USD");
                    ValueCheck.Test("dec_wholesale_price", row.dec_wholesale_price, 
                                    musicItemsRow.sm_wholesale_price);
                    ValueCheck.Test("vc_wholesale_price_currency", row.vc_wholesale_price_currency, "USD");
//         uid_promotion_id; //always empty
                    ValueCheck.Test("i_pricing_rule_id", row.i_pricing_rule_id,
                                    mapRow.i_pricing_rule_id);
                    ValueCheck.Test("si_hash_bucket", row.si_hash_bucket, 
                                    musicItemsRow.si_hash_bucket);
//                    ValueCheck.Test("dt_change_datetime", row.dt_change_datetime, musicItemsRow.dt_change_datetime);
                    VerifyDateTimeIsSoon(row.dt_change_datetime);

                    ValueCheck.Test("i_store_id", row.i_store_id, 2);

                    //user_offer_instance_purchases
                    UserOfferInstancePurchasesRow purchaseRow = (UserOfferInstancePurchasesRow) purchaseArray.items[i];
                    ValueCheck.Test("bi_user_puid", purchaseRow.bi_user_puid, dmpRow.bi_user_puid);
                    ValueCheck.Test("bi_machine_puid", purchaseRow.bi_machine_puid, dmpRow.bi_machine_puid);
                    ValueCheck.Test("uid_offer_instance_id", purchaseRow.uid_offer_instance_id, row.uid_offer_instance_id);
                    ValueCheck.Test("uid_offer_id", purchaseRow.uid_offer_id, mapRow.uid_offer_id);
                    ValueCheck.Test("i_offer_media_type_id", purchaseRow.i_offer_media_type_id, mapRow.i_media_type_id);
//                    ValueCheck.Test("dt_purchased", purchaseRow.dt_purchased, );
                    ValueCheck.Test("si_hash_bucket", purchaseRow.si_hash_bucket, row.si_hash_bucket);
//                    ValueCheck.Test("dt_change_datetime", purchaseRow.dt_change_datetime, );
                    ValueCheck.Test("i_store_id", purchaseRow.i_store_id, 2);//always 2
                }
/*
            } catch (Exception e) {
                Console.WriteLine(e.Message);
                Console.WriteLine("Error during verification for guid " + oldGuid);
            }
*/
        }
        Console.WriteLine("Verified " + count + " rows.");
        Console.WriteLine("Of these, " + migrated + " were migrated rows.");
        //how many migrations should there have been?
                
        Console.WriteLine("There are " + GetCountMigrations(2, 2) + " success migrations for music in the table.");

    }

    public static void VerifyVideoMigration() {
        //Verify license copies
        Console.WriteLine("Verifying licenses...");

        UserPpvLicensesArray oldLicenses = new UserPpvLicensesArray();
        oldLicenses.Load();

        for(int i=0; i<oldLicenses.items.Count; i++) {
            if (i%1000 == 0) {
                Console.WriteLine("Verified " + i + " licenses...");
            }
            UserPpvLicenseRow oldLicense = (UserPpvLicenseRow) oldLicenses.items[i];
            try {
                //get the appropriate row in the new world.

                //start by using the video map
                MigrationVideoMapRow mapRow = new MigrationVideoMapRow(oldLicense.uid_wmid);

                //now load the new media license row
                if (oldLicense.i_acknowledged == 1) {
                    //we expect it.
                    UserMediaInstanceLicenseState newLicense = new UserMediaInstanceLicenseState(oldLicense.bi_user_puid, 
                                                                                                 mapRow.uid_wmid,
                                                                                                 mapRow.uid_offer_instance_id);
                    //now compare the data in the new row.
                    ValueCheck.Test("bi_user_puid", newLicense.bi_user_puid, oldLicense.bi_user_puid);
                    ValueCheck.Test("uid_media_instance_id", newLicense.uid_media_instance_id, mapRow.uid_wmid);
                    ValueCheck.Test("uid_offer_instance_id", newLicense.uid_offer_instance_id, mapRow.uid_offer_instance_id);
                    ValueCheck.Test("i_state", newLicense.i_state, 1);
                    ValueCheck.Test("dt_state_changed", newLicense.dt_state_changed, oldLicense.dt_change_datetime);
                    ValueCheck.Test("si_hash_bucket", newLicense.si_hash_bucket, oldLicense.si_hash_bucket);
//                    ValueCheck.Test("dt_change_datetime", newLicense.dt_change_datetime, oldLicense.dt_change_datetime);
                    VerifyDateTimeIsSoon(newLicense.dt_change_datetime);
                } else {
                    bool foundWhenShouldNotExist = false;
                    //we *don't* expect it.  throw exception if we find one.
                    try {
                        UserMediaInstanceLicenseState newLicense = new UserMediaInstanceLicenseState(oldLicense.bi_user_puid, 
                                                                                                     mapRow.uid_wmid,
                                                                                                     mapRow.uid_offer_instance_id);
                        //bad, we found it.
                        foundWhenShouldNotExist = true;
                    } catch (Exception) {                        
                        //good, we found nothing.
                    }
                    if (foundWhenShouldNotExist) throw new Exception("Found license in new table when we shouldn't have!");


                }

            } catch (Exception e) {
                Console.WriteLine(e.Message);
                Console.WriteLine("Error when checking license of for bi_user_puid " + oldLicense.bi_user_puid + ", wmid " + 
                                  oldLicense.uid_wmid + ", video_type " + oldLicense.i_video_type_id);
           }

        }

        DmpPurchaseTransactionsTable dmpPurchaseTable = new DmpPurchaseTransactionsTable();
        dmpPurchaseTable.Load(3);

        //we may not need to load all the tables--  just load the guids, and then run little sql
        //selects for each one...  we'll still need all the rows though.
        Global.RO.Info("Verifying rows...");
        int count =0;
        int migrated = 0;
        foreach (DmpPurchaseTransactionsRow dmpRow in dmpPurchaseTable.table.Values) {
            count++;
            if ((count % 1000) == 0) {
                Console.WriteLine(count + " rows verified...");
            }
            Guid oldGuid = Guid.Empty;
//            try {
                oldGuid = dmpRow.uid_tracking_guid;

                //load all the old info about this transaction
                DmpPurchaseTransactionVideoItemsArray videoItemsArray = new DmpPurchaseTransactionVideoItemsArray(oldGuid);

                //load the transaction map table...  (we only verify post-migration)
                MigrationTransactionPurchaseRow mtpRow = new MigrationTransactionPurchaseRow(oldGuid);
                Guid newGuid = mtpRow.uid_new_tracking_guid;

                //regardless of what should happen, this mtpRow had better have the correct
                //si_hash_bucket in it.
                ValueCheck.Test("si_hash_bucket", mtpRow.si_hash_bucket, dmpRow.si_hash_bucket);


                //check if this row *can* migrate...  and if it can, is it some, or all?  for now let's
                //assume nothing is done.
                bool canBeMigrated = true;
                for(int i=0; i<videoItemsArray.items.Count; i++) {
                    DmpPurchaseTransactionVideoItemsRow row = (DmpPurchaseTransactionVideoItemsRow) videoItemsArray.items[i];
                    if (!row.CanBeMigrated()) {
                        canBeMigrated = false;
                    }
                }

                if (!canBeMigrated) {
                    bool dataPresent = false;
                    //verify that the row is in error status.
                    ValueCheck.Test("i_migration_status", mtpRow.i_migration_status, -1);
                    try {
                        DmpPurchaseTransactionsRow newDmpRowTest = new DmpPurchaseTransactionsRow(newGuid);
                        dataPresent = true;
                    } catch (Exception) {}
                    try {
                        DmpPurchaseTransactionMediaArray mediaArrayTest = new DmpPurchaseTransactionMediaArray(newGuid);
                        dataPresent = true;
                    } catch (Exception) {}
                    //cannot check userofferinstancepurchasearray--no data from the previous table.
                    if (dataPresent) {
                        throw new Exception("Data found in the tables for a migration that should be in error!");
                    }
                    continue; //skip the verify
                } 

                migrated ++;

                //load all the new info about this transaction
                DmpPurchaseTransactionsRow newDmpRow = new DmpPurchaseTransactionsRow(newGuid);
                DmpPurchaseTransactionMediaArray mediaArray = new DmpPurchaseTransactionMediaArray(newGuid);
                UserOfferInstancePurchaseArray purchaseArray = new UserOfferInstancePurchaseArray(mediaArray, dmpRow.bi_user_puid);
            
                //now that we have the tables, we verify.

                //transaction to transaction should be identical, except for i_purchase_type which
                //should be 5, and the guid.
                ValueCheck.Test("bi_user_puid", dmpRow.bi_user_puid, newDmpRow.bi_user_puid);
                ValueCheck.Test("bi_machine_puid", dmpRow.bi_machine_puid, newDmpRow.bi_machine_puid);
//            ValueCheck.Test("uid_tracking_guid", dmpRow.uid_tracking_guid, newDmpRow.uid_tracking_guid);
                ValueCheck.Test("i_status_id", dmpRow.i_status_id, newDmpRow.i_status_id);
                ValueCheck.Test("vc_confirmation_id", dmpRow.vc_confirmation_id, newDmpRow.vc_confirmation_id);
                ValueCheck.Test("i_hresult", dmpRow.i_hresult, newDmpRow.i_hresult);
                ValueCheck.Test("vc_error_code", dmpRow.vc_error_code, newDmpRow.vc_error_code);
                ValueCheck.Test("vc_error_xml", dmpRow.vc_error_xml, newDmpRow.vc_error_xml);
                ValueCheck.Test("dt_transaction_start", dmpRow.dt_transaction_start, newDmpRow.dt_transaction_start);
                ValueCheck.Test("dt_transaction_end", dmpRow.dt_transaction_end, newDmpRow.dt_transaction_end);
                ValueCheck.Test("vc_alternate_url", dmpRow.vc_alternate_url, newDmpRow.vc_alternate_url);
                ValueCheck.Test("si_hash_bucket", dmpRow.si_hash_bucket, newDmpRow.si_hash_bucket);
//                ValueCheck.Test("dt_change_datetime", dmpRow.dt_change_datetime, newDmpRow.dt_change_datetime);
                VerifyDateTimeIsSoon(newDmpRow.dt_change_datetime);
                ValueCheck.Test("i_purchase_type_id", 4, newDmpRow.i_purchase_type_id); //this
                                                                                         //should be
                                                                                         //4 for video.
                ValueCheck.Test("vc_ip_address", dmpRow.vc_ip_address, newDmpRow.vc_ip_address);

                //Verify the video mappings
                //for every item in the media array...
                for(int i=0; i<mediaArray.items.Count; i++) {
                    //grab the new data
                    DmpPurchaseTransactionMediaRow row = (DmpPurchaseTransactionMediaRow) mediaArray.items[i];


                    //Check--We should *not* get more than one row.
                    MigrationVideoMapArray mapArray = new MigrationVideoMapArray(row.uid_offer_instance_id);
                    if (mapArray.items.Count > 1) {
                        throw new Exception ("Bug # 114571, more than one wmid is found in the map for the same uid_offer_instance_id, "
                                             + row.uid_offer_instance_id);
                    }
                    
                    
                    DmpPurchaseTransactionVideoItemsRow videoItemsRow = null;
                    MigrationVideoMapRow mapRow = null;
                    mapRow = (MigrationVideoMapRow) mapArray.items[0];
                    videoItemsRow = videoItemsArray.GetRowWithThisWmid(mapRow.uid_wmid);
/*
                    for (int j=0; j<mapArray.items.Count; j++) {
                        try {
                            mapRow = (MigrationVideoMapRow) mapArray.items[j];
                            videoItemsRow = videoItemsArray.GetRowWithThisWmid(mapRow.uid_wmid);
                            break;  //if we find it, we have the right map row and video item row
                        } catch (Exception) {};
                    }
*/
                    if (videoItemsRow == null) {
                        throw new Exception ("Couldn't find a video item that matches the offer instance id in the video migration map!");
                    }
                    //verify vs. the video items row.
                    ValueCheck.Test("uid_tracking_guid", row.uid_tracking_guid, newGuid);
//                    ValueCheck.test("uid_offer_instance_id", row.uid_offer_instance_id,   //we'll
//                    check this matches the offer_instance_purchase
                    ValueCheck.Test("i_retail_price_points", row.i_retail_price_points, 
                                    videoItemsRow.i_retail_price_in_points);
                    ValueCheck.Test("dec_retail_price", row.dec_retail_price,
                                    videoItemsRow.sm_retail_price);
                    ValueCheck.Test("vc_retail_price_currency", row.vc_retail_price_currency, "USD");
                    ValueCheck.Test("dec_wholesale_price", row.dec_wholesale_price, 
                                    videoItemsRow.sm_wholesale_price);
                    ValueCheck.Test("vc_wholesale_price_currency", row.vc_wholesale_price_currency, "USD");
//         uid_promotion_id; //always empty
                    ValueCheck.Test("i_pricing_rule_id", row.i_pricing_rule_id,
                                    mapRow.i_pricing_rule_id);
                    ValueCheck.Test("si_hash_bucket", row.si_hash_bucket, 
                                    videoItemsRow.si_hash_bucket);
//                    ValueCheck.Test("dt_change_datetime", row.dt_change_datetime, videoItemsRow.dt_change_datetime);
                    VerifyDateTimeIsSoon(row.dt_change_datetime);
                    ValueCheck.Test("i_store_id", row.i_store_id, 1);

                    //user_offer_instance_purchases
                    //So...  there's the possibility that there is NO license row for this
                    //purchase.  That's because the user has bought this multiple times.  In which
                    //case there can only be a license for the most recent purchase.  Determine this
                    //first.  
                    if (GetGuidThatShouldHoldLicense(dmpRow.bi_user_puid, mapRow.uid_wmid) == 
                        (dmpRow.uid_tracking_guid)) {
                        UserOfferInstancePurchasesRow purchaseRow = (UserOfferInstancePurchasesRow) purchaseArray.items[i];
                        ValueCheck.Test("bi_user_puid", purchaseRow.bi_user_puid, dmpRow.bi_user_puid);
                        //the machine puid should be the one which is of the latest purchase of this
                        //offer.  run a special query to get not the purchase that matched, but the most
                        //recent purchase for this user.
                        GetMostRecentMachinePuidForThisOffer(dmpRow.bi_user_puid, row.uid_offer_instance_id);

                        ValueCheck.Test("bi_machine_puid", purchaseRow.bi_machine_puid, dmpRow.bi_machine_puid);
                        ValueCheck.Test("uid_offer_instance_id", purchaseRow.uid_offer_instance_id, row.uid_offer_instance_id);
                        ValueCheck.Test("uid_offer_id", purchaseRow.uid_offer_id, mapRow.uid_offer_id);
                        ValueCheck.Test("i_offer_media_type_id", purchaseRow.i_offer_media_type_id, mapRow.i_media_type_id);
//                    ValueCheck.Test("dt_purchased", purchaseRow.dt_purchased, );
                        ValueCheck.Test("si_hash_bucket", purchaseRow.si_hash_bucket, row.si_hash_bucket);
//                    ValueCheck.Test("dt_change_datetime", purchaseRow.dt_change_datetime, );
                        ValueCheck.Test("i_store_id", purchaseRow.i_store_id, 1);//always 2
                    }
                }

/*            } catch (Exception e) {
                Console.WriteLine(e.Message);
                Console.WriteLine("Error during verification for guid " + oldGuid);
            }
*/
        }
        Console.WriteLine("Verified " + count + " rows.");
        Console.WriteLine("Of these, " + migrated + " were migrated rows.");
        //how many migrations should there have been?
        
        Console.WriteLine("There are " + GetCountMigrations(2,3) + " success migrations in the table.");

    }


    public static void Main(string [] args ) {
        bool performMigration = false;

        uodb = new SqlConnection("server=" + UODB_SERVER + ";database=uodb;Integrated Security=SSPI");
        uodb.Open();  //set up a GLOBAL uodb connection that everyone uses.


        Console.WriteLine("Welcome to Music Migration tester!");
        //do args for both migrate and verify, allowing migration to be run multiple times?
        if ((args.Length == 1) && args[0].Equals("-m")) {
            Console.WriteLine("performMigration is enabled.");
            performMigration = true;
        }

        InitSTF();

        if (performMigration) {
            //performMigration
        }
       
        VerifyMusicMigration();
//        VerifyVideoMigration();

        uodb.Close();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\WebStasDBLoader\util.cs ===
using System;

namespace WebStasDBLoader
{
	/// <summary>
	/// Summary description for util.
	/// </summary>
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\WebStasDBLoader\StatsDbLoader.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;
using System.Xml;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using V2Functional;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;

namespace WebStasDBLoader
{


	/// <summary>
	/// this  program add all nessary data into UODB , webDB and Stats for testing Stats Web Cache
	/// </summary>
	/// 
	public class ChangeUserList
	{
		public ArrayList UserList;

		public class ChangeUser
		{
			public ulong m_oldpuid;
			public ulong m_newpuid;
			public ChangeUser(ulong oldpuid, ulong newpuid)
			{
				m_oldpuid=oldpuid;
				m_newpuid=newpuid;
			}
		}
		public ChangeUserList()
		{
			UserList = new ArrayList();
		}

		public ulong GetNewpuidFor(ulong oldPuid,string GamerTag)
		{
			// if present in the list return it or create a new uesr and return it.
			for(int i=0;i<UserList.Count;i++)
			{
				ChangeUser temp=(ChangeUser)UserList[i];
				if(temp.m_oldpuid==oldPuid || temp.m_newpuid==oldPuid)
					return 0;
			}

			ulong newpuid = StatsDBLoader.CreateUser(GamerTag);

			UserList.Add(new ChangeUser(oldPuid,newpuid));
			return newpuid;
		}


	}


	class StatsDBLoader
	{

		
		XboxUser[] testUsers=null;
		public ArrayList titles=null;
		public StatsDBLoader()
		{
			testUsers= new XboxUser[1000];
		
			titles = new ArrayList();
		}
		public void PopulateStatsDB()
		{
			System.Console.WriteLine("Creating Stats data for users");
			for(int i=0;i<titles.Count;i++)
			{
				XTitle titletemp = (XTitle)titles[i];
				for(int j=0;j<titletemp.lblist.Count;j++)
				{
					StatsProxy StatsDb = new StatsProxy(titletemp.id,(uint)((Xleaderbosrd)titletemp.lblist[j]).id);
					if(titletemp.id==77)
                    {
					
						
						StatsDb.Filldata64ATT(testUsers,77,21);
			
					}
					else
					{
						StatsDb.Filldata(testUsers);
					}

					if((j%100)==0)
					{
						System.Console.Write("Creating Stats data ... ");
					}
					
				}
				
				
			}
			
			
			

		}


		public void AddLbAndFieldWithNoNames()
		{
			WebDB dbobj= new WebDB("XonteNpdbSQL001");
			if(dbobj.Connect())
			{
				dbobj.AddTitle("401","en-US");
				dbobj.AddTitleNames("401","No LB and Field Names","en-US");

				dbobj.AddLeaderboard("401","1");
				dbobj.AddFieldsToLb("401","1","one","attr[0xFFFE]","0");
			}
			dbobj.Disconnect();
				

		}

		public void Add100Lb()
		{

			string titleid="406";
			WebDB dbobj= new WebDB("XonteNpdbSQL001");
			if(dbobj.Connect())
			{
				dbobj.AddTitle(titleid,"en-US");
				dbobj.AddTitleNames(titleid,"title with 100 LB","en-US");

				for(int i=1;i<700;i++)
				{
					string lbname= "testLB";
					dbobj.AddLeaderboard(titleid,i.ToString());
					dbobj.AddLbName(titleid,i.ToString(),lbname+i,"en-US");
					for (int k=0;k<4;k++)
					{
						//string formulas ="attr["+(i+k)+"]";
						string formulas ="attr[1]";
						dbobj.AddFieldsToLb(titleid,i.ToString(),k.ToString(),formulas,"0");
						dbobj.AddFieldsNames(titleid,i.ToString(),k.ToString(),"en-US",lbname+k.ToString());
					}
				}


			}
			dbobj.Disconnect();
			

		}
		
		public void LoadWebDbFromXML(string filename)
		{

			System.Console.WriteLine("Creating partners and adding  title info");
			string PartnerID;
			XmlDocument config = new XmlDocument();
			config.Load(filename);
			WebDB dbobj= new WebDB("XonteNpdbSQL001");
			if(dbobj.Connect())
			{
				// add titles in webdb
				XmlNodeList XTitles = config.DocumentElement["Titles"].ChildNodes;
				for(int i=0 ; i< XTitles.Count;i++)
				{
					string titleid = XTitles[i].Attributes["id"].Value;
					XTitle temptitle = new XTitle(titleid);
					System.Console.WriteLine("Added Title "+titleid);
					dbobj.AddTitle(titleid,"en-US");

					XmlNodeList Titleinfo = XTitles[i].ChildNodes;
					for(int j=0;j<Titleinfo.Count;j++)
					{
						if(Titleinfo[j].Name=="Titlename")
						{
							XmlNodeList TitleNames = Titleinfo[j].ChildNodes;
							for(int k=0;k<TitleNames.Count;k++)
							{
								string locale= TitleNames[k].Attributes["Lid"].Value;
								string titlename =TitleNames[k].InnerText;
								System.Console.WriteLine(titlename);
								dbobj.AddTitleNames(titleid,titlename,locale);

							}
						}
						else if(Titleinfo[j].Name=="Leaderboard")
						{
							string LBID = Titleinfo[j].Attributes["lid"].Value;
							temptitle.AddLeaderBoard(new Xleaderbosrd(LBID));
							dbobj.AddLeaderboard(titleid,LBID);

							XmlNodeList LBinfo = Titleinfo[j].ChildNodes;
							for(int l=0; l<LBinfo.Count;l++)
							{
								if(LBinfo[l].Name=="LBName")
								{
									XmlNodeList LBNames = LBinfo[l].ChildNodes;
									for(int k=0;k<LBNames.Count;k++)
									{
										string locale= LBNames[k].Attributes["lblid"].Value;
										string LBname =LBNames[k].InnerText;
										System.Console.WriteLine(LBname);
										dbobj.AddLbName(titleid,LBID,LBname,locale);

									}

								}
								else if(LBinfo[l].Name=="Fields")
								{
									XmlNodeList LBFields = LBinfo[l].ChildNodes;
									for(int p=0;p<LBFields.Count;p++)
									{
										string fid = LBFields[p].Attributes["fid"].Value;
										string formula =LBFields[p].Attributes["formula"].Value;
										string Type ;
										try
										{
											Type= LBFields[p].Attributes["type"].Value;
										}
										catch(Exception exp)
										{
											Type="0";
										}
										dbobj.AddFieldsToLb(titleid,LBID,fid,formula,Type);
										XmlNodeList FNames = LBFields[p].ChildNodes;
										for(int k=0;k<FNames.Count;k++)
										{
											string locale= FNames[k].Attributes["flid"].Value;
											string LBname =FNames[k].InnerText;
											System.Console.WriteLine(LBname);
											dbobj.AddFieldsNames(titleid,LBID,fid,locale,LBname);

										}

									}

								}
							}
							

						}
					}
					titles.Add(temptitle);
				}

				
				// create partners ...
				XmlNodeList Partners = config.DocumentElement["Partners"].ChildNodes;
				for(int i=0 ; i< Partners.Count;i++)
				{
					string Partnername =Partners[i].Attributes["name"].Value;
					string IsToAdd =Partners[i].Attributes["Add"].Value;
					PartnerID=Partners[i].Attributes["pid"].Value;

					if(IsToAdd=="YES")
						dbobj.CreatePartner(Partnername,PartnerID);

					XmlNodeList Partnerinfo = Partners[i].ChildNodes;
					for(int j=0;j<Partnerinfo.Count;j++)
					{
						if(Partnerinfo[j].Name=="AllowTitle")
						{
							XmlNodeList AllowTitle = Partnerinfo[j].ChildNodes;
							for(int k=0;k<AllowTitle.Count;k++)
							{
								string titleid =AllowTitle[k].InnerText;
								dbobj.AddTitleToPartner(titleid,PartnerID);
							}
						}
						else if(Partnerinfo[j].Name=="AllowAPI")
						{
							XmlNodeList AllowAPI = Partnerinfo[j].ChildNodes;
							for(int k=0;k<AllowAPI.Count;k++)
							{
								string APIName =AllowAPI[k].InnerText;
								dbobj.AddAPIToPartner(PartnerID,APIName);
							}
						}
					}

				}
			}

		}
		/*public void InitWebDb()
		{
			titles = new XTitle[2];
			titles[0]= new XTitle(75,"The Sims","ENUS");
			titles[1]= new XTitle(76,"Brute Force","ENUS");

			int pid = 4102003;
			WebDB dbobj= new WebDB("XonteNpdbSQL001");
			if(dbobj.Connect())
			{
				dbobj.CreatePartner("StatsWebTest",pid.ToString());
				for (int i=0; i<titles.Length;i++)
				{
					dbobj.AddTitle(titles[i]);
				}
				
				dbobj.AddTitlesToPartner(titles,pid);
				dbobj.AddServicesToPartner(pid,"stats");

				// create leaderboards.

				Xleaderbosrd lboard = new Xleaderbosrd(21,"Overall","ENUS");
				lboard.addField("Rating","attr[0xFFFE]","ENUS");
				lboard.addField("Big Moments","attr[1]","ENUS");
				lboard.addField("Money Earned","attr[2]","ENUS");
				titles[0].AddLeaderBoard(lboard);

				dbobj.AddLeaderboard(titles[0],lboard);

				Xleaderbosrd lboard1 = new Xleaderbosrd(12,"Overall","ENUS");
				lboard1.addField("Rating","attr[0xFFFE]","ENUS");
				lboard1.addField("No Of Kills","attr[1]","ENUS");
				lboard1.addField("No Of Deaths","attr[2]","ENUS");
				titles[1].AddLeaderBoard(lboard1);
				dbobj.AddLeaderboard(titles[1],lboard1);


			}
			dbobj.Disconnect();

		}
		*/



		public bool	ChangeUserInStatsDB(ulong newpuid,ulong oldUserID)
		{
			SqlConnection sql = null;
			SqlTransaction myTrans;

			
			SqlCommand cmdAtt = null;
			//SqlCommand cmdNName = null;
			//SqlCommand cmdXName = null;
			SqlCommand cmdRating = null;
			sql = new SqlConnection("Data Source="+"10.10.6.150"+";Initial Catalog=xstats;Integrated Security =true");
			sql.Open();
			myTrans= sql.BeginTransaction();
			try 
			{
				// Execute SQL script to delete all leaderboards created by the unitest
				string AttrStr= "UPDATE t_attrib_mgp3 SET bi_user_id="+newpuid+"where bi_user_id="+oldUserID;
//				string nicknameStr= "UPDATE t_nickname SET bi_user_id="+newpuid+"where bi_user_id="+oldUserID;
				//string XnameStr= "UPDATE t_xname SET bi_user_id="+newpuid+"where bi_user_id="+oldUserID;
				string ratingStr= "UPDATE t_rating_mgp SET bi_user_id="+newpuid+"where bi_user_id="+oldUserID;
				
				
				cmdAtt = new SqlCommand(AttrStr,sql,myTrans);
				//cmdNName = new SqlCommand(nicknameStr,sql);
				//cmdXName = new SqlCommand(XnameStr,sql);
				cmdRating = new SqlCommand(ratingStr,sql,myTrans);

				cmdAtt.ExecuteNonQuery();
				//cmdNName.ExecuteNonQuery();
				//cmdXName.ExecuteNonQuery();
				cmdRating.ExecuteNonQuery();

				myTrans.Commit();
			}
			catch(Exception e)
			{
				try
				{
					myTrans.Rollback();
				}
				catch (SqlException ex)
				{
					if (myTrans.Connection != null)
					{
						Console.WriteLine("An exception of type " + ex.GetType() +
							" was encountered while attempting to roll back the transaction.");
					}
				}
    
				Console.WriteLine("An exception of type " + e.GetType() +
					" was encountered while inserting the data.");



			}
			finally
			{
				if(sql != null)
				{
					sql.Close();
					sql = null;
				}
				
			}



			return true;
		}
		public void ChangeUsersForExistingLB()
		{
			ChangeUserList userlist= new ChangeUserList();

			///added code to read XML and  find titleid and LBid
			uint title = 1414594581;
			uint[] LBID= new uint[]{1,2,13,14}; 
			uint recCount=1000;

			// call Stats Init so that data gets updated
			//InitializeStats();
			string gamertagbase = "XPlaceUser";
			int UserIndex=0;

			for(int i=0;i<LBID.Length;i++)
			{
				System.Console.WriteLine("repopulating motorGP");

				// do an enum LB request for the title and change its user to real users.
				XRLWebEnumLB LBRequest = new XRLWebEnumLB(title,LBID[i],1,(byte)0,recCount);
				XRLWebEnumLBResponse response = LBRequest.Execute();
				
				
				try
				{
					UodbWS.Connect(Global.Env.Get("UODB").TextFront);


					ulong newpuid=0;
					for(int k=0; k<response.RepUserLBLen;k++)
					{
						UserIndex++;
						string gamertag = gamertagbase+UserIndex.ToString();
						newpuid= userlist.GetNewpuidFor(response.RepUserLB[k].UserID,gamertag) ;
						if(newpuid!=0)
							ChangeUserInStatsDB(newpuid,response.RepUserLB[k].UserID);
						
						if((k%100)==0)
						{
							System.Console.Write("pupulating data...");
						}
					}
				}
				finally
				{
					//UodbWS.Connect(Global.Env.Get("UODB").TextFront);
					UodbWS.Disconnect();
				}
			}

	

		}

		public void  InitializeStats()
		{
			SqlConnection sql = null;
			
			SqlCommand cmd = null;
			
			try 
			{
				sql = new SqlConnection("Data Source="+"10.10.6.150"+";Initial Catalog=xstats;Integrated Security =true");
				sql.Open();
 
				// Execute SQL script to delete all leaderboards created by the unitest
				cmd = new SqlCommand("p_Stats_Initialize",sql);
				cmd.CommandType = CommandType.StoredProcedure;
				
				cmd.ExecuteNonQuery();
				
			}
			catch(Exception e)
			{
				System.Console.WriteLine(e);
			}
			finally
			{
				if(sql != null)
				{
					sql.Close();
					sql = null;
				}
				
			}


		}

		public static ulong CreateUser(string GamerTag)
		{
			ulong puid;
			Owner ownr=new Owner(GamerTag);
			puid=ownr.Create();
			if (puid==0)
			{
				// get the puid from UODB and Add to list.
				puid=UodbWS.DoesUserExist(GamerTag);
			}
			return puid;
		}

		public void CreateUsersInUODB()
		{
			System.Console.WriteLine("Creating Users");
			string gamertagbase = "WebTestUser";
			try
			{
				UodbWS.Connect(Global.Env.Get("UODB").TextFront);
				for(int i=0; i<testUsers.Length;i++)
				{
					int j= i+1;
					string gamertag = gamertagbase+j.ToString();
					testUsers[i]= new XboxUser(CreateUser(gamertag),gamertag);
					
					if((i%100)==0)
					{
						System.Console.Write("Creating Users ...");
					}
				}
			}
			finally
			{
				//UodbWS.Connect(Global.Env.Get("UODB").TextFront);
				UodbWS.Disconnect();
			}

		}

		public  XmlDocument LoadXmlConfig(string fileName)
		{
			XmlDocument config = new XmlDocument();
			config.Load(fileName);

			try
			{
				Global.Env.Add(config.SelectSingleNode("//stf/servers"));
			}
			catch (Exception)
			{
				System.Console.WriteLine("Section <stf><servers> not found in any specified xml config files.  Verify stf.xml is available or specify an alternative on the command line.");
				
			}


			return config;
		}
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			StatsDBLoader webdata= new StatsDBLoader();

			//stf.xml
			


			
			webdata.CreateUsersInUODB(); 
			webdata.AddLbAndFieldWithNoNames();
			webdata.Add100Lb();
			webdata.LoadWebDbFromXML("config.xml");
			
			webdata.PopulateStatsDB();

			/////webdata.ChangeUsersForExistingLB();


			Global.UninitializeGlobalResources();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\LatencyGraph.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Drawing;
using ZedGraph;

public partial class LatencyGraph : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }


    #region Web Form Designer generated code
    override protected void OnInit(EventArgs e)
    {
        //
        // CODEGEN: This call is required by the ASP.NET Web Form Designer.
        //
        InitializeComponent();
        base.OnInit(e);
    }

    /// <summary>
    /// Required method for Designer support - do not modify
    /// the contents of this method with the code editor.
    /// </summary>
    private void InitializeComponent()
    {
        this.ZedGraphWeb1.RenderGraph += new ZedGraph.ZedGraphWebControlEventHandler(this.OnRenderGraph);
    }
    #endregion

    private void OnRenderGraph(System.Drawing.Graphics g, ZedGraph.MasterPane mPane)
    {
        //mPane[0] = new GraphPane();

        GraphPane pane = mPane[0];

        string builds = (string)Page.Request.Params["builds"];
        string latencies = (string)Page.Request.Params["latency"];
        string target = (string)Page.Request.Params["Target"];
        double LatencyTarget = double.Parse(target);

        string[] buildsArray = builds.Split(',');
        string[] latencyArray = latencies.Split(',');

        Int32 ArraySize = buildsArray.Length;

        double[] xVals = new double[ArraySize];
        double[] yVals = new double[ArraySize];
        double[] yValsTarget = new double[ArraySize];

        Border b = new Border(false, Color.White, 0.0f);
        pane.PaneBorder = b;

        int i = 0;
        foreach (string build in buildsArray)
        {
            xVals[i] = double.Parse(build);
            i++;
        }

        i = 0;

        foreach (string latency in latencyArray)
        {
            yVals[i] = double.Parse(latency);
            yValsTarget[i] = LatencyTarget;
            i++;
        }

        pane.XAxis.IsShowMinorGrid = false;


        pane.Title = "Latency vs. Build";
        pane.YAxis.Title = "Latency";
        pane.XAxis.Title = "Build Number";
        pane.YAxis.MinorTicSize = 0f;
        pane.XAxis.MinorTicSize = 0f;

        pane.AxisFill = new Fill(Color.White, Color.FromArgb(255, 255, 166), 45.0F);

        LineItem line = pane.AddCurve("Latency", xVals, yVals, Color.Black);
        LineItem targetLine = pane.AddCurve("Target", xVals, yValsTarget, Color.Red);

        pane.AxisChange(g);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\Default.aspx.cs ===
#define DEBUG

using System;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class _Default : System.Web.UI.Page
{
    DataTable dtSummary;

    protected void Page_Load(object sender, EventArgs e)
    {
        if (!IsPostBack)
        {
            FillProducts();
            FillReleases();
            FillScenarios();
        }

        FillSummaryGrid();
        SummaryGrid.DataBind();

        if (ddScenarios.Items.Count == 0)
        {
            return;
        }
        else if (ddScenarios.SelectedItem.Text == "ALL")
        {
            TPSGraph.Visible = false;
            LatencyGraph.Visible = false;
        }
        else
        {
            TPSGraph.Visible = true;
            LatencyGraph.Visible = true;

            String urlTPS = "TPSGraph.aspx?Builds=";
            String urlLatency = "LatencyGraph.aspx?Builds=";
            String builds = String.Empty;
            String TPS = String.Empty;
            String TPSTarget = String.Empty;
            String LatencyTarget = String.Empty;
            String Latency = String.Empty;

            foreach (GridViewRow row in SummaryGrid.Rows)
            {
                string build = ExtractBuildNumberFromBuildString(row.Cells[1].Text);

                builds += build + ",";
                TPS += row.Cells[4].Text + ",";
                Latency += row.Cells[6].Text + ",";
                TPSTarget = row.Cells[5].Text;
                LatencyTarget = row.Cells[7].Text;
            }
            builds = builds.TrimEnd(',');
            TPS = TPS.TrimEnd(',');
            Latency = Latency.TrimEnd(',');

            urlTPS += builds + "&TPS=" + TPS;
            urlTPS += "&Target=" + TPSTarget;
            TPSGraph.ImageUrl = urlTPS;

            urlLatency += builds + "&Latency=" + Latency;
            urlLatency += "&Target=" + LatencyTarget;
            LatencyGraph.ImageUrl = urlLatency;
        }
    }

    private string ExtractBuildNumberFromBuildString(string BuildString)
    {
        string[] buildParts = BuildString.Split('.');
        return buildParts[2];
    }

    private void FillProducts()
    {
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("GetProducts", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();
        da.Fill(dt);
        cn.Close();

        this.ddProduct.DataSource = dt;
        this.ddProduct.DataBind();
    }

    private void FillReleases()
    {
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("GetReleases", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        Int32 ProductID = Int32.Parse(ddProduct.SelectedValue);

        SqlParameter p1 = new SqlParameter("@ProductID", SqlDbType.Int);
        p1.Value = ProductID;
        cmd.Parameters.Add(p1);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();
        da.Fill(dt);
        cn.Close();
        ddRelease.DataSource = dt;
        this.ddRelease.DataBind();

        // This is where you may set the default selected release for the given product.
        // 32 == 8.0 CP-Main
        if (this.ddProduct.SelectedItem.Text.Equals("SCG"))
        {
            ddRelease.SelectedValue = "32";
        }
        else
        {
            if (ddRelease.Items.Count > 0)
            {
                ddRelease.SelectedIndex = 0;
            }
        }
    }


    private void FillScenarios()
    {
        if (ddRelease.Items.Count == 0)
        {
            // no releases for this product.  Do not attempt to show scenarios.
            this.ddScenarios.Items.Clear();
            return;
        }
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("GetScenariosFromRelease", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        SqlParameter p1 = new SqlParameter("@ReleaseID", SqlDbType.Int);
        p1.Value = Int32.Parse(ddRelease.SelectedValue);
        cmd.Parameters.Add(p1);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();
        da.Fill(dt);
        cn.Close();

        ddScenarios.DataSource = dt;
        ddScenarios.DataBind();

        ddScenarios.SelectedValue = "0";
    }

    private void FillSummaryGrid()
    {
        this.SummaryGrid.Visible = true;
        if (ddRelease.Items.Count == 0)
        {
            // no releases for the selected prodcut.  Do not attempt to show anything.
            this.SummaryGrid.Visible = false;
            return;
        }
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("GetScenarioSummary", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        SqlParameter p1 = new SqlParameter("@ReleaseID", SqlDbType.Int);
        p1.Value = Int32.Parse(ddRelease.SelectedValue);
        cmd.Parameters.Add(p1);

        SqlParameter p2 = new SqlParameter("@ResultCount", SqlDbType.Int);
        p2.Value = Int32.Parse(ddRowCount.SelectedItem.Text);
        cmd.Parameters.Add(p2);

        SqlParameter p3 = new SqlParameter("@ScenarioFilter", SqlDbType.VarChar, 255);
        p3.Value = ddScenarios.SelectedItem.Text;
        cmd.Parameters.Add(p3);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        dtSummary = new DataTable();
        da.Fill(dtSummary);
        cn.Close();

        SummaryGrid.DataSource = dtSummary;
        SummaryGrid.DataBind();
    }



    protected void ddRelease_SelectedIndexChanged(object sender, EventArgs e)
    {
        FillScenarios();
        FillSummaryGrid();
        SummaryGrid.DataBind();
    }

    protected void ddRowCount_SelectedIndexChanged(object sender, EventArgs e)
    {
        if (ddRelease.Items.Count == 0)
        {
            // don't do anything if no release is avalable.
            return;
        }
        FillSummaryGrid();
        SummaryGrid.DataBind();
    }


    protected void SummaryGrid_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType == DataControlRowType.DataRow)
        {
            double tps, tpsTarget;
            if (double.TryParse(e.Row.Cells[4].Text, out tps) & double.TryParse(e.Row.Cells[5].Text, out tpsTarget))
            {
                if (tps < tpsTarget)
                {
                    e.Row.Cells[4].BackColor = System.Drawing.Color.Red;
                    e.Row.Cells[5].BackColor = System.Drawing.Color.Red;
                }
                else
                {
                    e.Row.Cells[4].BackColor = System.Drawing.Color.LightGreen;
                    e.Row.Cells[5].BackColor = System.Drawing.Color.LightGreen;
                }
            }

            double latency, latencyTarget;
            if (double.TryParse(e.Row.Cells[6].Text, out latency) & double.TryParse(e.Row.Cells[7].Text, out latencyTarget))
            {
                if (latency > latencyTarget)
                {
                    e.Row.Cells[6].BackColor = System.Drawing.Color.Red;
                    e.Row.Cells[7].BackColor = System.Drawing.Color.Red;
                }
                else
                {
                    e.Row.Cells[6].BackColor = System.Drawing.Color.LightGreen;
                    e.Row.Cells[7].BackColor = System.Drawing.Color.LightGreen;
                }
            }
        }
    }

    protected void DeleteSuite_Click(object sender, ImageClickEventArgs e)
    {
        Int32 TestSuiteID = Int32.Parse(((ImageButton)sender).CommandArgument);

        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("DeleteSuite", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        SqlParameter p1 = new SqlParameter("@SuiteID", SqlDbType.Int);
        p1.Value = TestSuiteID;
        cmd.Parameters.Add(p1);

        cmd.ExecuteNonQuery();
        cn.Close();

        FillSummaryGrid();
        SummaryGrid.DataBind();
    }

    protected void ddProduct_SelectedIndexChanged(object sender, EventArgs e)
    {
        FillReleases();
        FillScenarios();
        FillSummaryGrid();
        SummaryGrid.DataBind();
        this.LatencyGraph.Visible = false;
        this.TPSGraph.Visible = false;
    }
    protected void ddScenarios_SelectedIndexChanged(object sender, EventArgs e)
    {
        FillSummaryGrid();
        SummaryGrid.DataBind();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\Admin.aspx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using perfweb;


public partial class Admin : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }
    protected void Menu1_MenuItemClick(object sender, MenuEventArgs e)
    {
        switch (this.Menu1.SelectedItem.Text)
        {
            case "Products":
                this.MultiView1.SetActiveView(this.ProductsView);
                FillProducts();
                this.gvProducts.DataBind();
                break;
            case "Releases":
                this.MultiView1.SetActiveView(this.ReleasesView);
                FillReleases();
                this.gvReleases.DataBind();
                break;
            case "Scenarios":
                this.MultiView1.SetActiveView(this.ScenariosView);
                FillScenarios(String.Empty);
                this.gvScenarios.DataBind();
                break;
            case "APIs":
                this.MultiView1.SetActiveView(this.APIsView);
                FillApis(String.Empty);
                this.gvApis.DataBind();
                break;
            case "Counters":
                this.MultiView1.SetActiveView(this.CountersView);
                FillCounters(String.Empty);
                this.gvCounters.DataBind();
                break;
            case "Tools":
                this.MultiView1.SetActiveView(this.ToolsView);
                FillCopyReleases();
                break;
        }
    }

    private void FillCopyReleases()
    {
        String sql = "select ReleaseId, Product + ' ' + Release AS ReleaseName from products p, releases r where p.ProductId=r.ProductId";
        DataView dv = GetData(sql).DefaultView;
        this.ddFromRelease.DataSource = dv;
        this.ddToRelease.DataSource = dv;
        this.ddFromRelease.DataBind();
        this.ddToRelease.DataBind();
    }

    private void FillCounters(string filter)
    {
        String sql;
        if (String.IsNullOrEmpty(filter))
            sql = "select PerformanceCounterId, CounterPath, DisplayType from performanceCounters order by counterPath";
        else
            sql = "select PerformanceCounterId, CounterPath, DisplayType from performanceCounters where CounterPath like '%" + filter + "%' order by counterPath";

        this.gvCounters.DataSource = GetData(sql).DefaultView;
    }

    private void FillApis(string filter)
    {
        string sql;
        if (String.IsNullOrEmpty(filter))
            sql = "SELECT ApiId, ApiName FROM Apis Order by ApiName";
        else
            sql = "SELECT ApiId, ApiName FROM Apis WHERE ApiName LIKE '%" + filter + "%' ORDER BY ApiName";

        this.gvApis.DataSource = GetData(sql).DefaultView;
    }

    private void FillReleases()
    {
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();


        //SqlCommand cmd = new SqlCommand("SELECT ReleaseId, Release, ReleaseDate, Product " +
        //    "FROM view_Releases " +
        //    "ORDER BY Product, Release", cn);

        SqlCommand cmd = new SqlCommand("SELECT r.ReleaseID, r.Release, r.ReleaseDate, p.Product, r.DropLocation FROM dbo.Releases AS r INNER JOIN dbo.Products AS p ON r.ProductID = p.ProductID ORDER BY Product, Release", cn);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();

        da.Fill(dt);
        this.gvReleases.DataSource = dt.DefaultView;
        cn.Close();
    }



    private void FillProducts()
    {
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM Products ORDER BY Product", cn);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();

        da.Fill(dt);

        this.gvProducts.DataSource = dt.DefaultView;
        cn.Close();
    }

    private void FillScenarios(string filter)
    {
        string sql;
        if (String.IsNullOrEmpty(filter))
            sql = "SELECT * FROM Scenarios ORDER BY ScenarioName";
        else
            sql = "SELECT * FROM Scenarios WHERE ScenarioName like '%" + filter + "%' ORDER BY ScenarioName";

        this.gvScenarios.DataSource = GetData(sql).DefaultView;
    }

    private void FillScenarioCounters(Int32 ScenarioId)
    {
        String sql = "select ctc.CollectId, c.CounterPath " +
            "from collectthesecounters ctc, PerformanceCounters c " +
            "where ctc.PerformanceCounterId=c.PerformanceCounterId " +
            "and ctc.ScenarioId=" + ScenarioId.ToString();

        this.gvScenarioCounters.DataSource = GetData(sql).DefaultView;

    }

    private void FillScenarioApis(Int32 ScenarioId)
    {
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        String sql = "select sa.ScenarioApiKey, ApiName " +
            "from apis a, scenarioapi sa " +
            "where a.apiId=sa.apiId " +
            "and scenarioid=" + ScenarioId;

        SqlCommand cmd = new SqlCommand(sql, cn);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();

        da.Fill(dt);

        this.gvScenarioApis.DataSource = dt.DefaultView;
        cn.Close();
    }
    protected void gvScenarios_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        FillScenarios(this.txtScenarioFilter.Text);
        this.gvScenarios.PageIndex = e.NewPageIndex;
        this.gvScenarios.DataBind();
    }
    protected void gvApis_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        FillApis(this.txtAPIFilter.Text);
        this.gvApis.PageIndex = e.NewPageIndex;
        this.gvApis.DataBind();
    }



    protected void gvScenarios_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblScenariosErrorText.Visible = false;
        switch (e.CommandName)
        {
            case "Select":
                Int32 key = (Int32)this.gvScenarios.DataKeys[Int32.Parse((String)e.CommandArgument)].Value;
                Session.Add("ScenarioId", key);
                this.panelScenarioApis.Visible = true;
                FillScenarioApis(key);
                FillScenarioCounters(key);
                this.lblScenarioApis.Text = "APIs in this Scenario.  ScenarioId: " + key.ToString();
                this.gvScenarioApis.DataBind();
                this.gvScenarioCounters.DataBind();
                break;
            case "Insert":
                String ScenarioName = ((TextBox)this.gvScenarios.FooterRow.FindControl("txtInsertScenario")).Text;
                try
                {
                    Scenario.AddScenario(ScenarioName);
                }
                catch (Exception ex)
                {
                    this.lblScenariosErrorText.Visible = true;
                    this.lblScenariosErrorText.Text = ex.Message;
                }
                FillScenarios(this.txtScenarioFilter.Text);
                this.gvScenarios.DataBind();
                break;
            case "Delete":
                Int32 ScenarioIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Scenario.DeleteScenario(ScenarioIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblScenariosErrorText.Visible = true;
                    this.lblScenariosErrorText.Text = ex.Message;
                }
                FillScenarios(this.txtScenarioFilter.Text);
                this.gvScenarios.DataBind();
                break;
        }
    }


    private DataTable GetData(String sql)
    {
        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand(sql, cn);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();

        da.Fill(dt);
        cn.Close();
        return dt;
    }
    protected void gvCounters_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        FillCounters(this.txtCounterFilter.Text);
        this.gvCounters.PageIndex = e.NewPageIndex;
        this.gvCounters.DataBind();
    }
    protected void gvApis_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblAPIErrorText.Visible = false;
        switch (e.CommandName)
        {
            case "Select":
                Int32 key = (Int32)this.gvApis.DataKeys[Int32.Parse((String)e.CommandArgument)].Value;
                Session.Add("SelectedApiId", key);
                this.panelAPITargets.Visible = true;
                this.lblApiTargets.Text = "Latency and TPS Targets for this API.  ApiId: " + key.ToString();
                FillAPITargets(key);
                this.gvApiTargets.DataBind();
                break;
            case "Insert":
                String APIName = ((TextBox)this.gvApis.FooterRow.FindControl("txtInsertApi")).Text;
                try
                {
                    Api.AddApi(APIName);
                }
                catch (Exception ex)
                {
                    this.lblAPIErrorText.Visible = true;
                    this.lblAPIErrorText.Text = ex.Message;
                }
                FillApis(this.txtAPIFilter.Text);
                this.gvApis.DataBind();
                break;
            case "Delete":
                Int32 ApiIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Api.DeleteApi(ApiIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblAPIErrorText.Visible = true;
                    this.lblAPIErrorText.Text = ex.Message;
                }
                FillApis(this.txtAPIFilter.Text);
                this.gvApis.DataBind();
                break;
        }
    }

    private void FillAPITargets(Int32 APIId)
    {
        string sql = "select t.TargetId, tt.TargetType, r.Release, c.CounterPath, t.Target " +
            "from targets t, targettypes tt, Releases r, PerformanceCounters c " +
            "where t.TargetTypeId=tt.TargetTypeId " +
            "and t.ReleaseId=r.ReleaseId " +
            "and t.PerformanceCounterId=c.PerformanceCounterId " +
            "and ApiId=" + APIId.ToString() +
            " order by Release, CounterPath";

        this.gvApiTargets.DataSource = GetData(sql).DefaultView;
    }

    protected void btnScenarioFilter_Click(object sender, EventArgs e)
    {
        FillScenarios(this.txtScenarioFilter.Text);
        this.panelScenarioApis.Visible = false;
        this.gvScenarios.DataBind();
    }
    protected void btnApplyAPIFilter_Click(object sender, EventArgs e)
    {
        FillApis(this.txtAPIFilter.Text);
        this.panelAPITargets.Visible = false;
        this.gvApis.DataBind();
    }
    protected void btnCounterFilter_Click(object sender, EventArgs e)
    {
        FillCounters(this.txtCounterFilter.Text);
        this.gvCounters.DataBind();
    }
    protected void gvApiTargets_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        Int32 ApiId = (Int32)Session["SelectedApiId"];
        switch (e.CommandName)
        {
            case "EmptyInsert":
                DropDownList ddRelease = this.gvApiTargets.Controls[0].Controls[0].FindControl("ddEmptyInsertApiTargetRelease") as DropDownList;
                DropDownList ddCounter = this.gvApiTargets.Controls[0].Controls[0].FindControl("ddEmptyInsertApiTargetCounterPath") as DropDownList;
                DropDownList ddTargetType = this.gvApiTargets.Controls[0].Controls[0].FindControl("ddEmptyInsertApiTargetTargetType") as DropDownList;
                TextBox txtTarget = this.gvApiTargets.Controls[0].Controls[0].FindControl("txtEmptyInsertApiTarget") as TextBox;
                Target.AddTarget(ApiId, Int32.Parse(ddCounter.SelectedValue), Int32.Parse(ddRelease.SelectedValue), Int32.Parse(ddTargetType.SelectedValue), double.Parse(txtTarget.Text));
                FillAPITargets(ApiId);
                this.gvApiTargets.DataBind();
                break;
            case "Insert":
                DropDownList addddRelease = this.gvApiTargets.FooterRow.FindControl("ddInsertApiTargetRelease") as DropDownList;
                DropDownList addddCounter = this.gvApiTargets.FooterRow.FindControl("ddInsertApiTargetCounterPath") as DropDownList;
                DropDownList addddTargetType = this.gvApiTargets.FooterRow.FindControl("ddInsertApiTargetType") as DropDownList;
                TextBox addtxtTarget = this.gvApiTargets.FooterRow.FindControl("txtAddAPITarget") as TextBox;
                Target.AddTarget(ApiId, Int32.Parse(addddCounter.SelectedValue), Int32.Parse(addddRelease.SelectedValue), Int32.Parse(addddTargetType.SelectedValue), double.Parse(addtxtTarget.Text));
                FillAPITargets(ApiId);
                this.gvApiTargets.DataBind();
                break;
            case "Delete":
                Int32 TargetIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                Target.DeleteTarget(TargetIdToDelete);
                FillAPITargets(ApiId);
                this.gvApiTargets.DataBind();
                break;
        }
    }
    protected void gvScenarioApis_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblScenarioApiErrorText.Visible = false;
        Int32 ScenarioId = (Int32)Session["ScenarioId"];

        switch (e.CommandName)
        {
            case "EmptyInsert":
                DropDownList ddApiId = this.gvScenarioApis.Controls[0].Controls[0].FindControl("ddEmptyInsertScenarioApi") as DropDownList;
                Scenario.AddScenarioApi(ScenarioId, Int32.Parse(ddApiId.SelectedValue));
                FillScenarioApis(ScenarioId);
                this.gvScenarioApis.DataBind();
                break;
            case "Insert":
                DropDownList addddApiId = this.gvScenarioApis.FooterRow.FindControl("ddInsertScenarioApi") as DropDownList;
                Scenario.AddScenarioApi(ScenarioId, Int32.Parse(addddApiId.SelectedValue));
                FillScenarioApis(ScenarioId);
                this.gvScenarioApis.DataBind();
                break;
            case "Delete":
                Int32 ScenarioApiIDToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Scenario.DeleteScenarioApi(ScenarioApiIDToDelete);
                }
                catch (Exception ex)
                {
                    this.lblScenarioApiErrorText.Visible = true;
                    this.lblScenarioApiErrorText.Text = ex.Message;
                }
                FillScenarioApis(ScenarioId);
                this.gvScenarioApis.DataBind();
                break;

        }
    }
    protected void gvScenarioCounters_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblCollectTheseCountersErrorText.Visible = false;
        Int32 ScenarioId = (Int32)Session["ScenarioId"];
        DropDownList ddCounterId;

        switch (e.CommandName)
        {
            case "EmptyInsert":
                ddCounterId = this.gvScenarioCounters.Controls[0].Controls[0].FindControl("ddEmptyInsertScenarioCounter") as DropDownList;
                Scenario.AddScenarioCounter(ScenarioId, Int32.Parse(ddCounterId.SelectedValue));
                FillScenarioCounters(ScenarioId);
                this.gvScenarioCounters.DataBind();
                break;
            case "Insert":
                ddCounterId = this.gvScenarioCounters.FooterRow.FindControl("ddInsertScenarioCounter") as DropDownList;
                Scenario.AddScenarioCounter(ScenarioId, Int32.Parse(ddCounterId.SelectedValue));
                FillScenarioCounters(ScenarioId);
                this.gvScenarioCounters.DataBind();
                break;
            case "Delete":
                Int32 CollectIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    CollectTheseCounters.DeleteCounterCollection(CollectIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblCollectTheseCountersErrorText.Visible = true;
                    this.lblCollectTheseCountersErrorText.Text = ex.Message;
                }
                FillScenarioCounters(ScenarioId);
                this.gvScenarioCounters.DataBind();
                break;
        }
    }

    protected void gvApiTargets_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {
        // fails if this method does not exist.  So just add the blank method.
    }
    protected void gvReleases_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblReleaseErrorText.Visible = false;
        switch (e.CommandName)
        {
            case "Insert":
                String ReleaseName = ((TextBox)this.gvReleases.FooterRow.FindControl("txtInsertRelease")).Text;
                String DropLocation = ((TextBox)this.gvReleases.FooterRow.FindControl("txtInsertDropLocation")).Text;
                String ReleaseDate = ((TextBox)this.gvReleases.FooterRow.FindControl("txtInsertReleaseDate")).Text;
                DateTime dtReleaseDate;
                if (!DateTime.TryParse(ReleaseDate, out dtReleaseDate))
                {
                    this.lblReleaseErrorText.Visible = true;
                    this.lblReleaseErrorText.Text = "Invalid release date entered. Please enter a valid date.";
                    return;
                }
                Int32 ProductID = Int32.Parse(((DropDownList)this.gvReleases.FooterRow.FindControl("ddProducts")).SelectedValue);
                try
                {
                    Release.AddRelease(ReleaseName, dtReleaseDate, ProductID, DropLocation);
                }
                catch (Exception ex)
                {
                    this.lblReleaseErrorText.Visible = true;
                    this.lblReleaseErrorText.Text = ex.Message;
                }
                FillReleases();
                this.gvReleases.DataBind();
                break;
            case "Delete":
                Int32 ReleaseIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Release.DeleteRelease(ReleaseIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblReleaseErrorText.Visible = true;
                    this.lblReleaseErrorText.Text = ex.Message;
                }
                FillReleases();
                this.gvReleases.DataBind();
                break;

        }
    }
    protected void gvProducts_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblProductErrorText.Visible = false;
        switch (e.CommandName)
        {
            case "Insert":
                String ProductName = ((TextBox)this.gvProducts.FooterRow.FindControl("txtInsertProduct")).Text;
                String ProductAbv = ((TextBox)this.gvProducts.FooterRow.FindControl("txtInsertProductAbv")).Text;
                Product.AddProduct(ProductName, ProductAbv);
                FillProducts();
                this.gvProducts.DataBind();
                break;
            case "Delete":
                Int32 ProductIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Product.DeleteProduct(ProductIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblProductErrorText.Visible = true;
                    this.lblProductErrorText.Text = ex.Message;
                }
                FillProducts();
                this.gvProducts.DataBind();
                break;

        }
    }

    protected void gvCounters_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblCountersErrorText.Visible = false;
        switch (e.CommandName)
        {
            case "Insert":
                String CounterPath = ((TextBox)this.gvCounters.FooterRow.FindControl("txtInsertCounter")).Text;
                String DisplayType = ((DropDownList)this.gvCounters.FooterRow.FindControl("ddDisplayType")).SelectedValue;
                try
                {
                    Counter.AddCounter(CounterPath, DisplayType);
                }
                catch (Exception ex)
                {
                    this.lblCountersErrorText.Visible = true;
                    this.lblCountersErrorText.Text = ex.Message;
                }
                FillCounters(this.txtCounterFilter.Text);
                this.gvCounters.DataBind();
                break;
            case "Delete":
                Int32 CounterIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Counter.DeleteCounter(CounterIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblCountersErrorText.Visible = true;
                    this.lblCountersErrorText.Text = ex.Message;
                }
                FillCounters(this.txtCounterFilter.Text);
                this.gvCounters.DataBind();
                break;
        }
    }

    protected void gvProducts_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvReleases_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvScenarios_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvApis_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvScenarioCounters_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvScenarioApis_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }

    protected void gvCounters_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void btnFilterCounterDropdown_Click(object sender, EventArgs e)
    {

    }
    protected void btnCopyTargets_Click(object sender, EventArgs e)
    {
        this.lblCopyTargetsStatusText.Visible = false;
        Int32 FromReleaseId = Int32.Parse(this.ddFromRelease.SelectedValue);
        Int32 ToReleaseId = Int32.Parse(this.ddToRelease.SelectedValue);
        if (FromReleaseId == ToReleaseId)
        {
            this.lblCopyTargetsStatusText.Visible = true;
            this.lblCopyTargetsStatusText.Text = "Selected releases are the same.  No copy performed.";
            this.lblCopyTargetsStatusText.ForeColor = System.Drawing.Color.Red;
        }
        try
        {
            Target.CopyTargets(FromReleaseId, ToReleaseId);
            this.lblCopyTargetsStatusText.Visible = true;
            this.lblCopyTargetsStatusText.Text = "Copy targets finished successfully.";
            this.lblCopyTargetsStatusText.ForeColor = System.Drawing.Color.Green;
        }
        catch (Exception ex)
        {
            this.lblCopyTargetsStatusText.Visible = true;
            this.lblCopyTargetsStatusText.Text = ex.Message;
            this.lblCopyTargetsStatusText.ForeColor = System.Drawing.Color.Red;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\xblPerfWeb.master.cs ===
using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Xml.Linq;

public partial class xblPerfWeb : System.Web.UI.MasterPage
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\WebStasDBLoader\WebDB.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using V2Functional;
using System.ComponentModel;
using ServerTestFramework.LiveService;

namespace WebStasDBLoader
{
	/// <summary>
	/// Summary description for WebDB.
	/// </summary>
	/// 

	
	public class Xleaderbosrd
	{
		public int id=0;
		
		public Xleaderbosrd(int lbid)
		{
			id=lbid;
		}

		public Xleaderbosrd(string lbid)
		{
			id = (int)TypeDescriptor.GetConverter(id).ConvertFromString(lbid);
		}

		
	}

	public class XTitle
	{
		public uint id=0;
		public ArrayList lblist;


		public XTitle(uint titleid)
		{
			id=titleid;
			lblist = new ArrayList();
			
		}

		public XTitle(string titleid)
		{
			lblist = new ArrayList();
			id = (uint)TypeDescriptor.GetConverter(id).ConvertFromString(titleid);
			
			
		}


		public void AddLeaderBoard(Xleaderbosrd LB)
		{
			lblist.Add(LB);
		}
		
	}
	public class WebDB
	{
		string myConnString;
		SqlConnection NPDBCnt= null;
		public WebDB(string Servername)
		{
			myConnString ="Data Source="+ Servername +";Integrated Security =true ;Initial Catalog=webdb";
			
		}

		public bool Connect()
		{
			try
			{
				NPDBCnt = new SqlConnection(myConnString);
				NPDBCnt.Open();
			}
			catch(Exception e)
			{
				Console.WriteLine("NPDB connect failed :-"+e.ToString());
				return false;
			}
			return true;
		}

		public void Disconnect()
		{
			if(NPDBCnt!=null)
			{
				NPDBCnt.Close();
				NPDBCnt=null;
			}
		}

		public void CreatePartner(string Partnername,string pid)
		{
			if(NPDBCnt!=null)
			{ // we have connection to NPDB
				string partnerssql="INSERT INTO [t_partners]([i_partner_id], [i_partner_group_id], [vc_subject_name], [i_cred_type], [vc_description], [dt_Change_datetime])VALUES("+pid+", 2,'"+Partnername+"', 1, 'Stats widget testing', getDate())";
				string pIpssql="INSERT INTO [t_partner_ips]([i_partner_id], [i_ip], [i_mask],[dt_Change_datetime])VALUES("+pid+", 16909060,0,getdate())";
				
				SqlDataReader partnerReader = null;
				SqlDataReader pIpsReader = null;
				SqlCommand partnerCommand = new SqlCommand(partnerssql,NPDBCnt);
				SqlCommand pIpsCommand = new SqlCommand(pIpssql,NPDBCnt);

				try
				{
					partnerReader = partnerCommand.ExecuteReader();

					partnerReader.Close();
					partnerReader=null;
					pIpsReader = pIpsCommand.ExecuteReader();
				}
				catch(Exception e)
				{
					Console.WriteLine(e.ToString());
				}
				finally
				{
					// Always call Close when done reading.
					if (partnerReader != null)
						partnerReader.Close();
					if (pIpsReader != null)
						pIpsReader.Close();
				}



			}
		}


		public void AddTitleToPartner(string titles, string pid)
		{
			if(NPDBCnt!=null)
			{ // we have connection to NPDB

				string sql="INSERT INTO [t_partner_allowed_titles]([i_partner_id], [i_title_id],[i_title_privilege], [dt_Change_datetime])VALUES("+pid+", "+titles+", 7, getdate())";
				SqlDataReader Reader = null;

				SqlCommand Command = new SqlCommand(sql,NPDBCnt);
				try
				{
					Reader = Command.ExecuteReader();

				}
				catch(Exception e)
				{
					Console.WriteLine(e.ToString());
				}
				finally
				{
					// Always call Close when done reading.
					if (Reader != null)
						Reader.Close();
					
				}
			}

		}


		public void AddTitleNames(string titleid ,string tname,string Locale)
		{
			string sqltitlename ="INSERT INTO [webdb].[dbo].[t_title_name_info]([i_title_id], [vc_locale_id], [vc_display_name], [dt_Change_datetime])VALUES("+titleid+", '"+Locale+"', '"+tname+"', getdate())";
			SqlDataReader Reader = null;
			SqlCommand nameCommand = new SqlCommand(sqltitlename,NPDBCnt);

			try
			{
				Reader = nameCommand.ExecuteReader();

			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				// Always call Close when done reading.
				if (Reader != null)
					Reader.Close();
					
			}


		}
		public void AddTitle(string titleid ,string locale)
		{
			if(NPDBCnt!=null)
			{ // we have connection to NPDB
				
				string sqltitleinfo="INSERT INTO [webdb].[dbo].[t_title_info]([i_title_id], [ti_esrb_rating], [i_cluster_id],[vc_default_locale], [dt_Change_datetime])VALUES("+titleid+",2, 1, '"+locale+"', getdate())";
								
				SqlDataReader Reader = null;
				
				SqlCommand infoCommand = new SqlCommand(sqltitleinfo,NPDBCnt);
				
				try
				{
					Reader = infoCommand.ExecuteReader();
				}
				catch(Exception e)
				{
					Console.WriteLine(e.ToString());
				}
				finally
				{
					// Always call Close when done reading.
					if (Reader != null)
						Reader.Close();
					
				}
				
			
			}
		}


		public void AddLbName(string title,string lbid,string name,string locale)
		{
			string ibnamesql="INSERT INTO [webdb].[dbo].[t_leaderboard_name_info]([i_title_id], [i_lb_id], [vc_locale_id], [vc_display_name], [dt_Change_datetime])VALUES("+title+", "+lbid+", '"+locale+"', '"+name+"', getdate())";
			SqlDataReader Reader = null;
			SqlCommand lbnameCommand = new SqlCommand(ibnamesql,NPDBCnt);

			try
			{
				Reader = lbnameCommand.ExecuteReader();

			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				// Always call Close when done reading.
				if (Reader != null)
					Reader.Close();
						
			}

		}
		
		public void AddLeaderboard(string title,string lbid)
		{
			// first create leaderboard

			string lbinfosql;
			if(title=="80")
				lbinfosql ="INSERT INTO [t_leaderboard_info]([i_title_id], [i_lb_id], [ti_reset_type], [i_entries_per_cache_line], [i_expiration_seconds], [dt_Change_datetime])VALUES("+title+", "+lbid+", 0,4,1200,getdate())";
			else
				lbinfosql ="INSERT INTO [t_leaderboard_info]([i_title_id], [i_lb_id], [ti_reset_type], [i_entries_per_cache_line], [i_expiration_seconds], [dt_Change_datetime])VALUES("+title+", "+lbid+", 0,50,1200,getdate())";

			
			SqlDataReader Reader = null;

			SqlCommand lbinfoCommand = new SqlCommand(lbinfosql,NPDBCnt);
			
			try
			{
				Reader = lbinfoCommand.ExecuteReader();
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				// Always call Close when done reading.
				if (Reader != null)
					Reader.Close();
						
			}
			// create leaderboard in stats
			int tmp=0;
			int ititle = (int)TypeDescriptor.GetConverter(tmp).ConvertFromString(title);
			int ilbid = (int)TypeDescriptor.GetConverter(tmp).ConvertFromString(lbid);
			CHelper.CreateV2LB(ititle,ilbid,(byte)0,0,0,0,0);
			ManagementConsole.Execute("10.10.5.84","exec aspnet_wp ReloadDbMap");
			ManagementConsole.Execute("10.10.5.85","exec aspnet_wp ReloadDbMap");
		}

		public void AddFieldsNames(string title,string LBid ,string Fid,string locale,string name)
		{
			string fnamesql="INSERT INTO [t_leaderboard_formatted_attribute_name_info]([i_title_id], [i_lb_id], [vc_name], [vc_locale_id], [vc_display_name], [dt_Change_datetime])VALUES("+title+", "+LBid+", '"+Fid+"', '"+locale+"', '"+name+"', getdate())";
			SqlDataReader tempReader = null;
			SqlCommand nameCommand = new SqlCommand(fnamesql,NPDBCnt);
			try
			{
				tempReader = nameCommand.ExecuteReader();
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				// Always call Close when done reading.
				if (tempReader != null)
					tempReader.Close();
				
			}


		}

		public void AddFieldsToLb(string title,string LBid ,string Fid ,string Formula,string Type)
		{
			// create all the fields in the LB
			string finfosql ="INSERT INTO [t_leaderboard_formatted_attribute_info]([i_title_id], [i_lb_id], [vc_name], [i_type], [vc_formula], [dt_Change_datetime])VALUES("+title+", "+LBid+", '"+Fid+"', "+Type+", '"+Formula+"', getdate())";
			string Rawfinfosql;
			if(Fid != "99")
				Rawfinfosql ="INSERT INTO [webdb].[dbo].[t_leaderboard_raw_attribute_info]([i_title_id], [i_lb_id], [i_raw_attribute_id], [ti_puid_attribute], [dt_Change_datetime])VALUES("+title+", "+LBid+", '"+Fid+"', 0, getdate())";
			else 
				Rawfinfosql ="INSERT INTO [webdb].[dbo].[t_leaderboard_raw_attribute_info]([i_title_id], [i_lb_id], [i_raw_attribute_id], [ti_puid_attribute], [dt_Change_datetime])VALUES("+title+", "+LBid+", '"+Fid+"', 1, getdate())";
				
			SqlDataReader tempReader = null;

			SqlCommand infoCommand = new SqlCommand(finfosql,NPDBCnt);
			SqlCommand RawinfoCommand = new SqlCommand(Rawfinfosql,NPDBCnt);
			
			try
			{
				tempReader = infoCommand.ExecuteReader();
				if (tempReader != null)
					tempReader.Close();
				tempReader=RawinfoCommand.ExecuteReader();
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}
			finally
			{
				// Always call Close when done reading.
				if (tempReader != null)
					tempReader.Close();
				
			}
			
			

		}
		public void AddAPIToPartner(string pid,string ApiName)
		{
			if(NPDBCnt!=null)
			{ // we have connection to NPDB
				string sql="INSERT INTO [webdb].[dbo].[t_partner_allowed_apis]([i_partner_id], [vc_api_name], [dt_Change_datetime])VALUES("+pid+", '"+ApiName+"', getdate())";
				SqlDataReader Reader = null;

				SqlCommand Command = new SqlCommand(sql,NPDBCnt);
				try
				{
					Reader = Command.ExecuteReader();

				}
				catch(Exception e)
				{
					Console.WriteLine(e.ToString());
				}
				finally
				{
					// Always call Close when done reading.
					if (Reader != null)
						Reader.Close();
					
				}
			}
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\TPSGraph.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Drawing;
using ZedGraph;

public partial class TPSGraph : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }

    #region Web Form Designer generated code
    override protected void OnInit(EventArgs e)
    {
        //
        // CODEGEN: This call is required by the ASP.NET Web Form Designer.
        //
        InitializeComponent();
        base.OnInit(e);
    }

    /// <summary>
    /// Required method for Designer support - do not modify
    /// the contents of this method with the code editor.
    /// </summary>
    private void InitializeComponent()
    {
        this.ZedGraphWeb1.RenderGraph += new ZedGraph.ZedGraphWebControlEventHandler(this.OnRenderGraph);

    }
    #endregion


    private void OnRenderGraph(System.Drawing.Graphics g, ZedGraph.MasterPane mPane)
    {
        //mPane[0] = new GraphPane();

        GraphPane pane = mPane[0];

        string builds = (string)Page.Request.Params["builds"];
        string TPSs = (string)Page.Request.Params["TPS"];
        string target = (string)Page.Request.Params["Target"];

        double TPSTarget = double.Parse(target);

        string[] buildsArray = builds.Split(',');
        string[] TPSsArray = TPSs.Split(',');

        Int32 ArraySize = buildsArray.Length;

        double[] xVals = new double[ArraySize];
        double[] yVals = new double[ArraySize];
        double[] yValsTarget = new double[ArraySize];

        Border b = new Border(false, Color.White, 0.0f);
        pane.PaneBorder = b;

        int i = 0;
        foreach (string build in buildsArray)
        {
            xVals[i] = double.Parse(build);
            i++;
        }

        i = 0;

        foreach (string TPS in TPSsArray)
        {
            yVals[i] = double.Parse(TPS);
            yValsTarget[i] = TPSTarget;
            i++;
        }

        pane.XAxis.IsShowMinorGrid = false;


        pane.Title = "TPS vs. Build";
        pane.YAxis.Title = "TPS";
        pane.XAxis.Title = "Build Number";
        pane.YAxis.MinorTicSize = 0f;
        pane.XAxis.MinorTicSize = 0f;
        

        pane.AxisFill = new Fill(Color.White, Color.FromArgb(255, 255, 166), 45.0F);

        LineItem line = pane.AddCurve("TPS", xVals, yVals, Color.Black);
        LineItem targetLine = pane.AddCurve("TPS Target", xVals, yValsTarget, Color.Red);

        pane.AxisChange(g);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\TestSuiteDetails.aspx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class TestSuiteDetails : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        Int32 TestSuiteID = Int32.Parse(Request.QueryString["TestSuiteID"]);

        SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
        cn.Open();

        SqlCommand cmd = new SqlCommand("GetTestSuiteDetails", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        SqlParameter p1 = new SqlParameter("@TestSuiteID", SqlDbType.Int);
        p1.Value = TestSuiteID;
        cmd.Parameters.Add(p1);

        DataTable dt = new DataTable();
        SqlDataAdapter da = new SqlDataAdapter(cmd);
        da.Fill(dt);

        TestSuiteDetailsGrid.DataSource = dt;
        TestSuiteDetailsGrid.DataBind();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XlastDataFixups\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\App_Code\Bed.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;


namespace perfweb
{
    public class Bed
    {
        private int bedID;
        private string bedName;

        public Bed(int bedID, string bedName)
        {
            this.bedID = bedID;
            this.bedName = bedName;
        }

        public int BedID
        {
            get
            {
                return this.bedID;
            }
            set
            {
                this.bedID = value;
            }
        }

        public string BedName
        {
            get
            {
                return this.bedName;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XlastDataFixups\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XlastDataFixups\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xlastdatafixups_none_12.4.56.0_none_ebf2668bf028862a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlastdatafixups
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.manifest
XP_MANIFEST_PATH=manifests\msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.cat
XP_CATALOG_PATH=manifests\msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.cat
XP_PAYLOAD_PATH=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlastdatafixups,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XlastDataFixups\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xlastdatafixups_none_12.4.56.0_none_ebf2668bf028862a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlastdatafixups
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.manifest
XP_MANIFEST_PATH=manifests\msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.cat
XP_CATALOG_PATH=manifests\msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe.cat
XP_PAYLOAD_PATH=msil_xlastdatafixups_no-public-key_12.4.56.0_x-ww_54026dbe
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlastdatafixups,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XlastDataFixups\Program.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Xml;

namespace XlastDataFixups
{
    class Program
    {
        private static BooleanSwitch ShowDebugSpew = new BooleanSwitch("ShowDebugSpew", "Show debug spew");
        private XmlNamespaceManager g_nsManager;

        public void DebugSpew(string format, params object[] arg)
        {
            if (ShowDebugSpew.Enabled)
            {
                Console.WriteLine(format, arg);
            }
        }

        public void InfoSpew(string format, params object[] arg)
        {
            Console.Error.WriteLine(format, arg);
        }

        public void WarningSpew(string format, params object[] arg)
        {
            Console.Error.WriteLine("WARNING: " + format, arg);
        }

        public void ErrorSpew(string format, params object[] arg)
        {
            Console.Error.WriteLine("ERROR: " + format, arg);
        }

        public string ProcessArguments(string[] args)
        {
            if (args.Length != 1)
            {
                ErrorSpew("1 argument is required and it must be an XLAST file path");
                return null;
            }
            string xlastFileName = args[0];
            DebugSpew("xlastFileName = " + xlastFileName);
            if (!File.Exists(xlastFileName))
            {
                DebugSpew("Unable to file XLAST file name: " + xlastFileName);
            }
            return xlastFileName;
        }

        public void SetCurrentWorkingDirectory(string xlastFileName)
        {
            DebugSpew("CWD = " + Directory.GetCurrentDirectory());
            string xlastDirPath = Path.GetDirectoryName(xlastFileName);
            DebugSpew("xlastDirPath = " + xlastDirPath);
            Directory.SetCurrentDirectory(xlastDirPath);
            DebugSpew("CWD = " + Directory.GetCurrentDirectory());
        }

        public XmlDocument LoadXlast(string xlastFileName)
        {
            XmlDocument doc = new XmlDocument();
            doc.Load(xlastFileName);
            return doc;
        }

        public List<string> ExtractAllPaths(XmlDocument xlastDoc)
        {
            List<string> paths = new List<string>();
            XmlNodeList pathNodeList = xlastDoc.GetElementsByTagName("Path");
            DebugSpew("pathNodeList.Count = " + pathNodeList.Count);
            foreach (XmlNode pathNode in pathNodeList)
            {
                paths.Add(pathNode.InnerText);
            }
            return paths;
        }

        public int GetXlastSpacersNeededCount(XmlDocument xlastDoc)
        {
            List<string> paths = ExtractAllPaths(xlastDoc);
            int maxRelativeBacktrackDepth = 0;
            foreach (string path in paths)
            {
                string tempPath = path;
                int relativeBacktrackDepth = 0;
                DebugSpew("path == " + tempPath);
                while (tempPath.StartsWith("..\\"))
                {
                    relativeBacktrackDepth++;
                    tempPath = tempPath.Remove(0, 3);
                }
                if (maxRelativeBacktrackDepth < relativeBacktrackDepth)
                {
                    maxRelativeBacktrackDepth = relativeBacktrackDepth;
                }
            }
            return maxRelativeBacktrackDepth;
        }

        public string CreateSpacers(int spacersCount)
        {
            string createSpacerAt = @".";
            for (int i = 1; i <= spacersCount; i++)
            {
                createSpacerAt += @"\spacer" + i;
                Directory.CreateDirectory(createSpacerAt);
            }
            return Path.GetFullPath(createSpacerAt);
        }

        public string MoveXlastProject(string xlastFullPath, string targetFolder)
        {
            DebugSpew("xlastFullPath = " + xlastFullPath);
            string xlastFileName = Path.GetFileName(xlastFullPath);
            DebugSpew("targetFolder = " + targetFolder);
            try
            {
                File.Move(xlastFileName, targetFolder + @"\" + xlastFileName);
            }
            catch (System.IO.IOException)
            {
                // File already exists; ignoring
            }
            return Path.GetFullPath(targetFolder + @"\" + xlastFileName);
        }

        public void GetAttributeValue(XmlNode xmlNode, string attribName, out string attribValue, string defaultValue)
        {
            attribValue = defaultValue;
            XmlAttribute xmlAttrib = xmlNode.Attributes[attribName];
            if (xmlAttrib != null)
            {
                attribValue = xmlAttrib.Value;
            }
        }

        public XmlNode GetGameConfigProjectChildNode(XmlDocument xlastDoc, string nodeName)
        {
            XmlNode node = xlastDoc.SelectSingleNode("/x:XboxLiveSubmissionProject/x:GameConfigProject/x:" + nodeName, g_nsManager);
            return node;
        }

        private List<XmlNode> GetImages(XmlDocument xlastDoc, string imageTypeNodeName)
        {
            XmlNode imagesNode = GetGameConfigProjectChildNode(xlastDoc, "Images");
            DebugSpew("GetImages: imagesNode == null == " + (imagesNode == null ? "true" : "false"));

            XmlNode imageTypeNode = GetGameConfigProjectChildNode(xlastDoc, imageTypeNodeName);
            DebugSpew("GetImages: imageTypeNode == null == " + (imageTypeNode == null ? "true" : "false"));

            List<XmlNode> results = new List<XmlNode>();
            foreach (XmlNode child in imageTypeNode.ChildNodes)
            {
                string imageId;
                GetAttributeValue(child, "imageId", out imageId, null);
                if (imageId != null)
                {
                    DebugSpew("GetImages: imageId == " + imageId);

                    XmlNode imageNode = imagesNode.SelectSingleNode("x:Image[@id='" + imageId + "']", g_nsManager);
                    DebugSpew("GetImages: imageNode == null == " + (imageNode == null ? "true" : "false"));
                    results.Add(imageNode);
                }
            }
            return results;
        }

        private List<XmlNode> GetAvatarImages1(XmlDocument xlastDoc, string imageTypeNodeName)
        {
            XmlNode imagesNode = GetGameConfigProjectChildNode(xlastDoc, "Images");
            List<XmlNode> results = new List<XmlNode>();
            
                DebugSpew("GetImages: imagesNode == null == " + (imagesNode == null ? "true" : "false"));

                XmlNode imageTypeNode = GetGameConfigProjectChildNode(xlastDoc, imageTypeNodeName);
                DebugSpew("GetImages: imageTypeNode == null == " + (imageTypeNode == null ? "true" : "false"));

                if (imageTypeNode != null)
                {
                    foreach (XmlNode child in imageTypeNode.ChildNodes)
                    {
                        string imageId1;
                        string imageId2;
                        GetAttributeValue(child, "imageId1", out imageId1, null);
                        GetAttributeValue(child, "imageId2", out imageId2, null);

                        if (Convert.ToInt32(imageId1) != 0)
                        {
                            DebugSpew("GetImages: imageId == " + imageId1);

                            XmlNode imageNode = imagesNode.SelectSingleNode("x:Image[@id='" + imageId1 + "']", g_nsManager);
                            DebugSpew("GetImages: imageNode == null == " + (imageNode == null ? "true" : "false"));
                            results.Add(imageNode);
                        }
                        if (Convert.ToInt32(imageId2) != 0)
                        {
                            DebugSpew("GetImages: imageId == " + imageId2);

                            XmlNode imageNode = imagesNode.SelectSingleNode("x:Image[@id='" + imageId2 + "']", g_nsManager);
                            DebugSpew("GetImages: imageNode == null == " + (imageNode == null ? "true" : "false"));
                            results.Add(imageNode);
                        }
                    }
                }
            return results;
        }

        public List<XmlNode> GetAchievementImages(XmlDocument xlastDoc)
        {
            return GetImages(xlastDoc, "Achievements");
        }

        public List<XmlNode> GetRatingsImages(XmlDocument xlastDoc)
        {
            return GetImages(xlastDoc, "ProductInformation");
        }
        public List<XmlNode> GetAvatarImages(XmlDocument xlastDoc)
        {
            return GetAvatarImages1(xlastDoc, "AvatarItems");
        }
        private List<XmlNode> GetGamerPictureImages(XmlDocument xlastDoc, string sizePostFix)
        {
            XmlNode imagesNode = GetGameConfigProjectChildNode(xlastDoc, "Images");
            DebugSpew("GetGamerPictureImages: imagesNode == null == " + (imagesNode == null ? "true" : "false"));
            XmlNode gamerPicsNode = GetGameConfigProjectChildNode(xlastDoc, "GamerPictures");
            DebugSpew("GetGamerPictureImages: gamerPicsNode == null == " + (gamerPicsNode == null ? "true" : "false"));

            List<XmlNode> results = new List<XmlNode>();
            foreach (XmlNode child in gamerPicsNode.ChildNodes)
            {
                string friendlyName;
                GetAttributeValue(child, "friendlyName", out friendlyName, null);
                if (friendlyName == null)
                {
                    throw new Exception("Unable to find friendly name");
                }
                DebugSpew("GetGamerPictureImages: friendlyName == " + friendlyName);
                XmlNode smallImageNode = imagesNode.SelectSingleNode("x:Image[@friendlyName='" + friendlyName + sizePostFix + "']", g_nsManager);
                DebugSpew("GetGamerPictureImages: smallImageNode == null == " + (smallImageNode == null ? "true" : "false"));
                results.Add(smallImageNode);
            }
            return results;
        }

        public List<XmlNode> GetSmallGamerPictureImages(XmlDocument xlastDoc)
        {
            return GetGamerPictureImages(xlastDoc, "_SMALL");
        }

        public List<XmlNode> GetLargeGamerPictureImages(XmlDocument xlastDoc)
        {
            return GetGamerPictureImages(xlastDoc, "_LARGE");
        }

        public XmlNode GetGameImage(XmlDocument xlastDoc)
        {
            XmlNode gameImageNode = xlastDoc.SelectSingleNode("//x:Image[@friendlyName='X_IMAGEID_GAME']", g_nsManager);
            DebugSpew("GetGameImage: gameImageNode == null == " + (gameImageNode == null ? "true" : "false"));
            return gameImageNode;
        }

        public XmlNode GetGameMarketplaceImage(XmlDocument xlastDoc)
        {
            XmlNode gameImageNode = xlastDoc.SelectSingleNode("//x:Image[@friendlyName='X_IMAGEID_GAME_MARKETPLACE']", g_nsManager);
            DebugSpew("GetGameMarketplaceImage: gameImageNode == null == " + (gameImageNode == null ? "true" : "false"));
            return gameImageNode;
        }

        public XmlNode GetGameBoxArtImage(XmlDocument xlastDoc)
        {
            XmlNode gameImageNode = xlastDoc.SelectSingleNode("//x:Image[@friendlyName='X_IMAGEID_GAME_BOXART']", g_nsManager);
            DebugSpew("GetGameBoxArtImage: gameImageNode == null == " + (gameImageNode == null ? "true" : "false"));
            return gameImageNode;
        }

        public XmlNode GetGameBackground(XmlDocument xlastDoc)
        {
            XmlNode gameImageNode = xlastDoc.SelectSingleNode("//x:Image[@friendlyName='X_IMAGEID_GAME_BKGND']", g_nsManager);
            DebugSpew("GetGameBackground: gameImageNode == null == " + (gameImageNode == null ? "true" : "false"));
            return gameImageNode;
        }

        private void CopyImage(XmlNode imageNode, string sourceImagePath)
        {
            string id, friendlyName;
            GetAttributeValue(imageNode, "id", out id, "not found");
            GetAttributeValue(imageNode, "friendlyName", out friendlyName, "not found");
            DebugSpew("CopyImage: friendlyName = " + friendlyName);

            if (!imageNode.HasChildNodes)
            {
                ErrorSpew("CopyImage: Found Image node [id: " + id + ", friendlyName: " + friendlyName +
                    "] has no child nodes. A child Path node is required.  Skipping.");
                return;
            }
            string path = null;
            foreach (XmlNode childNode in imageNode.ChildNodes)
            {
                if (childNode.Name == "Path")
                {
                    path = childNode.InnerText;
                    break;
                }
            }
            if (path == null || path == "")
            {
                WarningSpew("CopyImage: Found Image node [id: " + id + ", friendlyName: " + friendlyName +
                    "] has no child Path node. A child Path node is required.  Skipping.");
                return;
            }

            DebugSpew("source = " + sourceImagePath);
            string dest = Path.GetFullPath(path);
            DebugSpew("dest = " + dest);
            Directory.CreateDirectory(Path.GetDirectoryName(dest));
            File.Copy(sourceImagePath, dest, true);
        }

        private void CopyImages(List<XmlNode> imageNodes, string sourceImagePath)
        {
            foreach (XmlNode imageNode in imageNodes)
            {
                CopyImage(imageNode, sourceImagePath);
            }
        }

        public void CreateImages(XmlDocument xlastDoc)
        {
            // Get default image paths
            string appBasePath = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
            DebugSpew("appBasePath = " + appBasePath);

            List<XmlNode> achImages = GetAchievementImages(xlastDoc);
            CopyImages(achImages, appBasePath + @"\DefaultAchievement.png");

            List<XmlNode> ratingsImages = GetRatingsImages(xlastDoc);
            CopyImages(ratingsImages, appBasePath + @"\DefaultGamerPicLarge.png");

            List<XmlNode> avatarImages = GetAvatarImages(xlastDoc);
            CopyImages(avatarImages, appBasePath + @"\DefaultGamerPicLarge.png");

            List<XmlNode> smallGamerPics = GetSmallGamerPictureImages(xlastDoc);
            CopyImages(smallGamerPics, appBasePath + @"\DefaultGamerPicSmall.png");

            List<XmlNode> largeGamerPics = GetLargeGamerPictureImages(xlastDoc);
            CopyImages(largeGamerPics, appBasePath + @"\DefaultGamerPicLarge.png");

            XmlNode titleImage = GetGameImage(xlastDoc);
            CopyImage(titleImage, appBasePath + @"\DefaultTitle.png");

            XmlNode bannerImage = GetGameMarketplaceImage(xlastDoc);
            if (bannerImage != null)
            {
                CopyImage(bannerImage, appBasePath + @"\DefaultBanner.png");
            }

            XmlNode boxArtImage = GetGameBoxArtImage(xlastDoc);
            if (boxArtImage != null)
            {
                CopyImage(boxArtImage, appBasePath + @"\DefaultBanner.png");
            }

            XmlNode backgroundImage = GetGameBackground(xlastDoc);
            if (backgroundImage != null)
            {
                CopyImage(backgroundImage, appBasePath + @"\DefaultBanner.png");
            }
        }

        public void Run(string[] args)
        {
            string xlastFileArg = ProcessArguments(args);

            if (xlastFileArg == null)
            {
                return;
            }

            string xlastFullPath = Path.GetFullPath(xlastFileArg);
            SetCurrentWorkingDirectory(xlastFullPath);

            XmlDocument xlastDoc;
            try
            {
                xlastDoc = LoadXlast(xlastFullPath);
            }
            catch (System.IO.FileNotFoundException)
            {
                ErrorSpew("Could not find XLAST project file at: " + xlastFullPath);
                return;
            }
            g_nsManager = new XmlNamespaceManager(xlastDoc.NameTable);
            g_nsManager.AddNamespace("x", "http://www.xboxlive.com/xlast");

            int spacersCount = GetXlastSpacersNeededCount(xlastDoc);
            DebugSpew("spacersCount = " + spacersCount);
            string targetFolder = CreateSpacers(spacersCount);

            xlastFullPath = MoveXlastProject(xlastFullPath, targetFolder);
            SetCurrentWorkingDirectory(xlastFullPath);

            CreateImages(xlastDoc);
        }

        static void Main(string[] args)
        {
            new Program().Run(args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\App_Code\DatabasePage.cs ===
using System;
using System.Data.SqlClient;
using System.Web.UI;

/// <summary>
/// Summary description for DatabasePage
/// </summary>
/// 
namespace perfweb
{
    public class DatabasePage : Page
    {
        protected SqlConnection connection;

        public DatabasePage()
        {
            // Create the connection up front, but don't open it yet:
            this.connection = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            this.Load += new EventHandler(DatabasePage_Load);
            this.Unload += new EventHandler(DatabasePage_Unload);
        }

        private void DatabasePage_Load(object sender, EventArgs arguments)
        {
            // Open the connection every time the page loads:
            this.connection.Open();
        }

        private void DatabasePage_Unload(object sender, EventArgs arguments)
        {
            // Close the connection every time the page unloads:
            this.connection.Close();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XPQDiag\getweblist.cpp ===
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <stdlib.h>

#define QMSG_HELLO 0
#define QMSG_WEB_LIST 12
#define QMSG_WEB_LIST_REPLY 101
#define PMSG_HELLO 1000
#define PMSG_WEB_ALIVE 1027
#define PMSG_WEB_ALIVE_REPLY 1104
#define CURRENT_XQPROTOCOL_VER 0x00010000
#define MAX_HELLO_DESCRIPTION_LEN   80
#define MAX_PRES_INH 8
#define MAX_NOTI_INH 4
#define QCONN_HELLO_DESC "XPNFD(FAKE)"
#define QCONN_HELLO_DESC_LEN sizeof(QCONN_HELLO_DESC)
#define RECV_TIMEOUT_SECONDS 5

#pragma pack(push, 1)
typedef struct _SGADDR {
    IN_ADDR         inaSg;              // IP address of the SG for the client
    DWORD           dwSpiSg;            // Pseudo-random identifier assigned by the SG
    ULONGLONG       qwXboxID;           // Unique identifier of client machine account
    BYTE            abReserved[4];      // Reserved (must be zero)
} SGADDR;

struct BASE_MSG_HEADER
{
    DWORD dwMsgType;
    DWORD dwMsgLen;
    DWORD dwSeqNum;
    SGADDR sgaddr;

    // BYTE rgbMsgData[ dwMsgLen ];
};


struct Q_HELLO_MSG : public BASE_MSG_HEADER
{
    DWORD dwProtocolVersion;    // Hi word | lo word
    // char szDescription[];    // NULL-terminated ASCII string
};

struct Q_WEB_LIST_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// The asynchronous reply to a Q_WEB_LIST
//
struct Q_WEB_LIST_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD  wNumItems;

    // PQ_WEB_FRIEND rgFriends[ wNumItems ];
};

struct P_WEB_ALIVE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

struct P_WEB_ALIVE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    ULONGLONG qwUserID;
};

//
// Web Friends basic structure
//
struct PQ_WEB_FRIEND
{
    ULONGLONG qwUserID;
    DWORD dwState;
    DWORD dwTitleID;
    WORD cbTitleStuff;
    // byte rgbTitleStuff[];            // Binary
};
#pragma pack(pop)

const SGADDR sgaddrIgnore = { 0, 0, 0, 0, 0, 0, 0};

template<class _Type>
class Buffer
{
private:
	DWORD m_dwAvail;
	DWORD m_dwCount;
	_Type *m_prgData;

	void Init()
	{
		m_dwAvail = m_dwCount = 0;
		m_prgData = 0;
	}

public:
	Buffer()
	{
		Init();
	}
	explicit Buffer(DWORD dwReserve) {
		Init();
		Reserve(dwReserve);
	}
	~Buffer()
	{
		Release();	
	}
	void Release()
	{
		if(m_prgData)
		{
			delete[] m_prgData;
			m_prgData = 0;
			m_dwCount = m_dwAvail = 0;
		}
	}
	HRESULT Append(_Type *prgData, DWORD dwCount)
	{
		HRESULT hr;

		// Make sure we have enough space reserved for the append
		if(FAILED(hr = Reserve(m_dwCount + dwCount)))
		{
			return hr;
		}

		_Type *pDst = m_prgData + m_dwCount;
		_Type *pSrc = prgData;
		_Type *pEnd = prgData + dwCount;
		
		while(pSrc < pEnd)
		{
			*pDst++ = *pSrc++;
			m_dwCount++;
		}

		return S_OK;
	}
	void Clear()
	{
		m_dwCount = 0;
	}
	HRESULT Reserve(DWORD dwReserve)
	{
		if(dwReserve == 0)
		{
			return E_INVALIDARG;
		}
		
		if(dwReserve > m_dwAvail)
		{
			_Type *prgNewData = new _Type[dwReserve];

			if(!prgNewData)
			{
				return E_OUTOFMEMORY;
			}

			if(m_prgData)
			{
				if(m_dwCount > 0)
				{
					CopyMemory(prgNewData, m_prgData, m_dwCount * sizeof(_Type));
				}
				delete[] m_prgData;
			}
			m_prgData = prgNewData;
			m_dwAvail = dwReserve;
		}

		return S_OK;
	}
	DWORD GetCount() const
	{ 
		return m_dwCount;
	}
	DWORD GetCountBytes() const
	{
		return m_dwCount * sizeof(_Type);
	}
	DWORD GetAvail() const
	{
		return m_dwAvail;
	}
	DWORD GetAvailBytes() const
	{
		return m_dwAvail * sizeof(_Type);
	}
	_Type *GetData() const
	{
		return m_prgData;
	}
};


static DWORD g_dwSeqNum;
static DWORD g_dwNumPresInh;
static DWORD g_dwNumNotiInh;
static struct sockaddr_in g_sAddrNoti[MAX_NOTI_INH];
static struct sockaddr_in g_sAddrPres[MAX_PRES_INH];
static SOCKET g_sConnNoti[MAX_NOTI_INH];
static SOCKET g_sConnPres[MAX_PRES_INH];
static Buffer<BYTE> g_bufInput;
static Buffer<BYTE> g_bufOutput;

inline DWORD HIDWORD(const DWORDLONG &dwl)
{
	return (DWORD) (dwl >> 32);
}

inline DWORD LODWORD(const DWORDLONG &dwl)
{
	return (DWORD) (dwl & 0xffffffff);
}

DWORD NextSeqNum()
{
	return g_dwSeqNum++;	
}

DWORD MapPuidToPres(ULONGLONG qwUserID)
{
	return ((LODWORD(qwUserID) + HIDWORD(qwUserID)) % 95219) % g_dwNumPresInh;
}

DWORD MapPuidToNoti(ULONGLONG qwUserID)
{
	return ((LODWORD(qwUserID) + HIDWORD(qwUserID)) % 95219) % g_dwNumNotiInh;
}

HRESULT SendBuffer(SOCKET sConn, Buffer<BYTE> &bufOut)
{
	HRESULT hr = S_OK;
	int iSent, iTot, iCountBytes;

	iTot = 0;
	iCountBytes = bufOut.GetCountBytes();

	while(S_OK == hr && iTot < iCountBytes)
	{
		iSent = send(	sConn, 
				(const char*)(bufOut.GetData() + iTot),
				iCountBytes - iTot, 
				0);

		if(iSent < 0)
		{
			hr = HRESULT_FROM_WIN32(WSAGetLastError());
		}
		else 
		{
			iTot += iSent;
		}
	}

	printf("SendBuffer(): sent %d bytes\n", iTot);

	return hr;
}

HRESULT RecvBuffer(SOCKET sConn, Buffer<BYTE> &bufIn)
{
	HRESULT hr = S_OK;
	int iRecv, iTot;
#define TMP_BUFFER_SZ 1024
	BYTE rgTmpBuffer[TMP_BUFFER_SZ];
	fd_set rset, eset;
	struct timeval timeout;

	iTot = 0;

	while(S_OK == hr)
	{
		// See if we have some data available for reading
		FD_ZERO(&rset); FD_ZERO(&eset);
		FD_SET(sConn, &rset); FD_SET(sConn, &eset);
		timeout.tv_sec = RECV_TIMEOUT_SECONDS;
		timeout.tv_usec = 0;

		iRecv = select(1, &rset, NULL, &eset, &timeout);

		if(iRecv < 0 || FD_ISSET(sConn, &eset))
		{
			hr = HRESULT_FROM_WIN32(WSAGetLastError());
			break;
		}
		else if(iRecv == 0)
		{
			//hr = HRESULT_FROM_WIN32(WSAETIMEDOUT);
			// indicates end of data
			break;
		}


		if(!FD_ISSET(sConn, &rset))
		{
			printf("select(): socket not marked in the output read set, failing");
			hr = E_INVALIDARG;
			break;
		} 

		// Read some data off the connection
		iRecv = recv(	sConn,
				(char*)rgTmpBuffer,
				TMP_BUFFER_SZ,
				0);

		if(iRecv < 0)
		{
			hr = HRESULT_FROM_WIN32(WSAGetLastError());
			break;
		} 
		else if(iRecv == 0)
		{
			printf("recv(): connection closed on remote end\n");
			hr = HRESULT_FROM_WIN32(WSAENOTCONN);
			break;
		}


		// Append to our input buffer
		hr = bufIn.Append(rgTmpBuffer, (DWORD)iRecv);
		iTot += iRecv;
	}

	printf("RecvBuffer(): recv'd %d bytes\n", iTot);

	return hr;
}

/////////////////////////////////////////////////
//  Winsock UP
//  Helper function to bring up winsock layer
//
//
HRESULT WinsockUP()
{

	// Set version requested
	WORD wVersionRequested = MAKEWORD( 2, 2 );

	// WSAStartup
	WSADATA wsaData; // Version of winsock the system supports
	int err = WSAStartup( wVersionRequested, &wsaData );
	if( err != 0 )
	{
		return HRESULT_FROM_WIN32(WSAGetLastError()); // Unable to start winsock
	}

	// Check version
	if( LOBYTE(wsaData.wVersion) != 2 ||
			HIBYTE(wsaData.wVersion) != 2 )
	{
		WSACleanup();
		return HRESULT_FROM_WIN32(WSAGetLastError()); // Wrong version of winsock 
	}

	// Success
	return S_OK;
}

/////////////////////////////////////////////////
//  Winsock DOWN
//
//  Helper function to bring down winsock layer
//
HRESULT WinsockDOWN()
{

	// WSACleanup
	int err=WSACleanup();
	if( err != 0 )
	{
		return HRESULT_FROM_WIN32(WSAGetLastError()); // Unable to bring down winsock
	}

	// Success
	return S_OK;
}

void DumpHex(BYTE *prgData, DWORD cbData)
{
	DWORD dwBytes = 0;

	// Emit the hex data bytes in 16 byte chunks
	printf("0000 0000: ");
	while(dwBytes < cbData)
	{
		printf("%02X ", *prgData);
		if((dwBytes & 3) == 3)
		{
			printf("  ");
		}

		prgData++;
		dwBytes++;

		if((dwBytes-1 & 15) == 15)
		{
			printf("\n");
			printf("%04X %04X: ", dwBytes >> 16, dwBytes & 0xffff);
		}
	}
	
	if((dwBytes-1 & 15) != 15)
	{
		printf("\n");
	}
}

ULONGLONG ParsePuid(const char *pszPuid)
{
	ULONGLONG qwPuid = 0;

	if(!pszPuid || !*pszPuid)
	{
		goto lbDone;
	}

	// Grab the user puid
	if(pszPuid[0] == '0' && tolower(pszPuid[1]) == 'x')
	{
		// Parse hex
		WORD wTmp;
		const char *pszHex = &(pszPuid[2]);
		while(*pszHex)
		{
			if(isdigit(*pszHex))
			{
				wTmp = *pszHex - '0';
			}
			else if(isalpha(*pszHex))
			{
				wTmp = tolower(*pszHex) - 'a';
			}
			else
			{
				printf("error: invalid character in puid string: %c\n", *pszHex);
				qwPuid = 0;
				break;
			}

			qwPuid <<= 4;
			qwPuid |= wTmp;
			pszHex++;
		}
	}
	else
	{
		// Convert decimal
		WORD wTmp;
		const char *pszDec = pszPuid;
		while(*pszDec)
		{
			if(isdigit(*pszDec))
			{
				wTmp = *pszDec - '0';
			}
			else
			{
				printf("error: invalid character in puid string: %c\n", *pszDec);
				exit(1);
			}

			qwPuid *= 10;
			qwPuid += wTmp;
			pszDec++;
		}
	}

lbDone:
	return qwPuid;
}

BOOL ParseTokens(char **ppCursor, DWORD nLength, char *pKeyStart, DWORD nKeySize, char *pValueStart, DWORD nValueSize)
{
	char *pCur = *ppCursor;
	const char *pEnd = pCur + nLength;
	char *pKeyEnd = pKeyStart + nKeySize;	
	char *pValueEnd = pValueStart + nKeySize;	

	// Allows convient loop behavior
	if(pCur == pEnd || !*pCur)
		return FALSE;

	*pKeyStart = *pValueStart = '\0';

	char *pKey = pKeyStart;
	while(pCur < pEnd && pKey < pKeyEnd)
	{
		if(*pCur == '=')
		{
			pCur++;
			break;
		}
		*pKey++ = *pCur++;
	}
	*pKey = '\0';

	char *pValue = pValueStart;
	while(pCur < pEnd && pValue < pValueEnd)
	{
		if(*pCur == '\r' || *pCur == '\n')
		{
			pCur++;
			break;
		}
		*pValue++ = *pCur++;
	}
	*pValue = '\0';

	*ppCursor = pCur;

	return TRUE;
}

HRESULT ConnectToServers()
{
	HRESULT hr;
	char szLine[128];
	char szKey[32];
	char szValue[32];
	char *pCursor;
	int iResult;
	struct sockaddr_in *pAddr;
	SOCKET *psConn;
	Buffer<BYTE> bufOutput;
	WORD wMsgType;

	hr = S_OK;

	FILE *pFile = fopen("serverlist.txt", "ro");
	if(!pFile)
	{
		printf("could not open serverlist.txt\n");
		hr = E_FAIL;
		goto lbDone;
	}

	while(fgets(szLine, sizeof(szLine), pFile))
	{
		pCursor = szLine;
		if(!ParseTokens(&pCursor, strlen(szLine), szKey, 32, szValue, 32))
		{
			printf("line did not contain a valid key=value pair\n");
			hr = E_FAIL;
			break;
		}

		// Check token key type
		if(!strcmp(szKey, "pres"))
		{
			if(g_dwNumPresInh == MAX_PRES_INH)
			{
				printf("exceeded max pres inh records\n");
				hr = E_FAIL;
				break;
			}
			pAddr = &g_sAddrPres[g_dwNumPresInh];
			psConn = &g_sConnPres[g_dwNumPresInh];
			g_dwNumPresInh++;
			wMsgType = PMSG_HELLO;
		}
		else if(!strcmp(szKey, "noti"))
		{
			if(g_dwNumNotiInh == MAX_NOTI_INH)
			{
				printf("exceeded max noti inh records\n");
				hr = E_FAIL;
				break;
			}
			pAddr = &g_sAddrNoti[g_dwNumNotiInh];
			psConn = &g_sConnNoti[g_dwNumNotiInh];
			g_dwNumNotiInh++;
			wMsgType = QMSG_HELLO;
		}
		else
		{
			printf("unrecognized token: %s\n", szKey);
			hr = E_FAIL;
			break;
		}

		// Setup the address structure
		pAddr->sin_family = AF_INET;

		// Parse the port
		char *pszMarker = strchr(szValue, ':');
		if(!pszMarker)
		{
			printf("error: no port specified in <host-ip>:<port> setting\n");
			exit(1);
		}

		*pszMarker = '\0';	

		// Get address and port
		pAddr->sin_addr.S_un.S_addr = inet_addr(szValue);
		pAddr->sin_port = htons((WORD)strtol(pszMarker+1, '\0', 10));

		//  Connect to server
		*psConn = socket(AF_INET, SOCK_STREAM, 0);
		if(*psConn == INVALID_SOCKET)
		{
			printf("socket() failed to create: 0x%08x", HRESULT_FROM_WIN32(WSAGetLastError()));
			hr = E_FAIL;
			break;
		}

		printf("[ connecting to host: %s:%s ... ]\n", szValue, pszMarker+1);
		iResult = connect(*psConn, (struct sockaddr*)pAddr, sizeof(struct sockaddr_in));
		if(iResult < 0)
		{
			hr = HRESULT_FROM_WIN32(WSAGetLastError());
			printf("connect() failed: 0x%08x", hr);
			break;
		}

		printf("[ sending HELLO... ]\n");

		//
		// Send hello
		Q_HELLO_MSG msgHello;
		msgHello.dwMsgType = wMsgType;
    	msgHello.dwMsgLen = sizeof(Q_HELLO_MSG) - sizeof(BASE_MSG_HEADER) + QCONN_HELLO_DESC_LEN;
    	msgHello.dwSeqNum = NextSeqNum();
    	msgHello.sgaddr = sgaddrIgnore;
		msgHello.dwProtocolVersion = CURRENT_XQPROTOCOL_VER;
	
		bufOutput.Append((BYTE*)&msgHello, sizeof(Q_HELLO_MSG));
		bufOutput.Append((BYTE*)QCONN_HELLO_DESC, QCONN_HELLO_DESC_LEN);

		SendBuffer(*psConn, bufOutput);
		bufOutput.Clear();
	}

	fclose(pFile);
lbDone:
	return hr;
}

void DisconnectServers()
{
	DWORD i;

	for(i = 0; i < g_dwNumPresInh; ++i)
	{
		if(g_sConnPres[i] != INVALID_SOCKET)
		{
			//  Disconnect from server
			printf("[ disconnecting from pres inh: %s:%d ... ]\n", 
				inet_ntoa(g_sAddrPres[i].sin_addr),
				ntohs(g_sAddrPres[i].sin_port));

			closesocket(g_sConnPres[i]);
			g_sConnPres[i] = INVALID_SOCKET;
		}
	}
	for(i = 0; i < g_dwNumNotiInh; ++i)
	{
		if(g_sConnNoti[i] != INVALID_SOCKET)
		{
			//  Disconnect from server
			printf("[ disconnecting from noti inh: %s:%d ... ]\n", 
				inet_ntoa(g_sAddrNoti[i].sin_addr),
				ntohs(g_sAddrNoti[i].sin_port));

			closesocket(g_sConnNoti[i]);
			g_sConnNoti[i] = INVALID_SOCKET;
		}
	}
}

HRESULT DumpWebAlive(ULONGLONG qwUserPuid, Buffer<BYTE> &bufInput, Buffer<BYTE> &bufOutput)
{
	P_WEB_ALIVE_MSG msgWebAlive;
	P_WEB_ALIVE_REPLY_MSG *pReply;
	HRESULT hr = S_OK;
	SOCKET sConn = INVALID_SOCKET;

	printf("[ sending WEB_ALIVE_REQ to server index: %d, puid: %I64d... ]\n",
			MapPuidToPres(qwUserPuid), qwUserPuid);

	msgWebAlive.dwMsgType = PMSG_WEB_ALIVE;
	msgWebAlive.dwMsgLen  = sizeof(P_WEB_ALIVE_MSG) - sizeof(BASE_MSG_HEADER);
	msgWebAlive.dwSeqNum = NextSeqNum();
	msgWebAlive.sgaddr = sgaddrIgnore;
    msgWebAlive.qwUserID = qwUserPuid;
	bufOutput.Append((BYTE*)&msgWebAlive, sizeof(P_WEB_ALIVE_MSG));
	
	sConn = g_sConnPres[MapPuidToPres(qwUserPuid)];
	SendBuffer(sConn, bufOutput);
	bufOutput.Clear();

	printf("[ reading WEB_ALIVE_REPLY... ]\n");

	//
	// Read the web alive response
	if(FAILED(hr = RecvBuffer(sConn, bufInput)))
	{
		printf("could not read the web list reply: HR 0x%08x\n", hr);
		goto lbDone;
	}

	// 
	// Ensure we read enough buffer to parse the messages
	if(bufInput.GetCountBytes() < sizeof(P_WEB_ALIVE_REPLY_MSG))
	{
		hr = E_FAIL;
		printf("response buffer was only: %d bytes.. not enough to parse Q_WEB_ALIVE_REPLY_MSG: %d\n",
			bufInput.GetCountBytes(), sizeof(P_WEB_ALIVE_REPLY_MSG));
		goto lbDone;
	}
	
	// 
	// Parse and print web alive message
	pReply = (P_WEB_ALIVE_REPLY_MSG*)bufInput.GetData();

	hr = pReply->hr;

	printf("----- P_WEB_ALIVE_REPLY_MSG -----\n");
	printf("HR: 0x%08x\n", pReply->hr);
	printf("qwUserID: %I64d\n", pReply->qwUserID);

	bufInput.Clear();

lbDone:
	return hr;
}

HRESULT DumpWebList(ULONGLONG qwUserPuid, Buffer<BYTE> &bufInput, Buffer<BYTE> &bufOutput)
{
	Q_WEB_LIST_REPLY_MSG *pReply;
	Q_WEB_LIST_MSG msgWebList;
	PQ_WEB_FRIEND *pWebFriend;
	PQ_WEB_FRIEND *pWebFriendEnd;
	HRESULT hr = S_OK;
	SOCKET sConn = INVALID_SOCKET;
	
	printf("[ sending WEB_LIST_REQ to server index: %d, puid: %I64d... ]\n", 
			MapPuidToNoti(qwUserPuid), qwUserPuid);

	// 
	//  Send web list request
	msgWebList.dwMsgType = QMSG_WEB_LIST;
    msgWebList.dwMsgLen = sizeof(Q_WEB_LIST_MSG) - sizeof(BASE_MSG_HEADER);
    msgWebList.dwSeqNum = NextSeqNum();
    msgWebList.sgaddr = sgaddrIgnore;
    msgWebList.qwUserID = qwUserPuid;

	bufOutput.Append((BYTE*)&msgWebList, sizeof(Q_WEB_LIST_MSG));

	sConn = g_sConnNoti[MapPuidToNoti(qwUserPuid)];
	SendBuffer(sConn, bufOutput);
  	bufOutput.Clear();

	printf("[ reading WEB_LIST_REPLY... ]\n");

	//
	// Read the web list response
	if(FAILED(hr = RecvBuffer(sConn, bufInput)))
	{
		printf("could not read the web list reply: HR 0x%08x\n", hr);
		goto lbDone;
	}

	// 
	// Ensure we read enough buffer to parse the messages
	if(bufInput.GetCountBytes() < sizeof(Q_WEB_LIST_REPLY_MSG))
	{
		hr = E_FAIL;
		printf("response buffer was only: %d bytes.. not enough to parse Q_WEB_LIST_REPLY_MSG: %d\n",
			bufInput.GetCountBytes(), sizeof(Q_WEB_LIST_REPLY_MSG));
		goto lbDone;
	}
	
	// 
	// Parse and print web list message
	pReply = (Q_WEB_LIST_REPLY_MSG*)bufInput.GetData();
	
	hr = pReply->hr;

	printf("----- Q_WEB_LIST_REPLY_MSG -----\n");
	printf("HR: 0x%08x\n", pReply->hr);
	printf("wNumItems: %d\n", pReply->wNumItems);

	pWebFriend = (PQ_WEB_FRIEND*)(bufInput.GetData() + sizeof(Q_WEB_LIST_REPLY_MSG));
	pWebFriendEnd = (PQ_WEB_FRIEND*)(bufInput.GetData() + sizeof(BASE_MSG_HEADER) + pReply->dwMsgLen);

	while(pWebFriend < pWebFriendEnd)
	{
		printf("--- qwUserId: %I64d, dwState: 0x%08x, dwTitleID: 0x%08x, cbTitleStuff: %d\n", 
			pWebFriend->qwUserID, 
			pWebFriend->dwState, 
			pWebFriend->dwTitleID, 
			pWebFriend->cbTitleStuff);
		
		DumpHex(((BYTE*)pWebFriend) + sizeof(PQ_WEB_FRIEND), pWebFriend->cbTitleStuff);
		pWebFriend = (PQ_WEB_FRIEND*)(((BYTE*)pWebFriend) + sizeof(PQ_WEB_FRIEND) + pWebFriend->cbTitleStuff);
	}

	bufInput.Clear();

lbDone:
	return hr;
}

int __cdecl main(int argc, char **argv)
{
	ULONGLONG qwUserPuid; 
	HRESULT hr;
	DWORD i;
	char *pszMarker;
	bool bParsed;
	char szInput[256] = {0,};

	// Clear sockets
	for(i = 0; i < g_dwNumPresInh; ++i)
	{
		g_sConnPres[i] = INVALID_SOCKET;
	}
	for(i = 0; i < g_dwNumNotiInh; ++i)
	{
		g_sConnNoti[i] = INVALID_SOCKET;
	}

	qwUserPuid = 0;
	
	// Check args
	if(argc > 1 && (argv[1][0] == '/' || argv[1][0] == '?'))
	{
		printf("usage: %s [action] [user-puid]\n", argv[0]);
		printf("	action: webalive, weblist, webfd\n");
		printf("	user-puid: Hex bytes starting with 0x or decimal number\n");
		printf("\n");
		printf("config-file:\n");
		printf("    'serverlist.txt' is required to specify all servers in the cluster\n");
		printf("	Format: pres|noti=HOSTIP:PORT<newline>\n");
		printf("    Each line corresponds to one noti or pres server entry\n");

		exit(1);
	}
	
#if 0 // test dump hex routine, none of my users had title data (yet?)
	DWORD dwEBP;
	_asm { mov dword ptr [dwEBP], ebp }
	DumpHex((BYTE*)&main, dwEBP - (DWORD)&dwEBP);
#endif

	if(FAILED(WinsockUP()))
	{
		printf("fatal: Winsock failed to startup");
		exit(1);
	}

	if(FAILED(hr = ConnectToServers()))
	{
		printf("ConnectToServers() failed, HR: 0x%08x\n", hr);
		goto lbCleanup;
	}

	// allow user to input command dynamically or from command line
	if(argc > 2)
	{
		_snprintf(szInput, sizeof(szInput)-1, "%s %s", argv[1], argv[2]);
	}

	do
	{
		qwUserPuid = 0;
		bParsed = false;
		if(szInput[0])
		{
			// remove any type of newline at the end
			pszMarker = szInput;
			while(*pszMarker)
			{
				switch(*pszMarker)
				{
				case '\t':
				case '\r':
				case '\n':
					*pszMarker = '\0';
					break;
				default:
					pszMarker++;
					break;
				}
			}

			pszMarker = strchr(szInput, ' ');
			if(pszMarker)
			{
				qwUserPuid = ParsePuid(pszMarker+1);
			}
			if(!strncmp("webalive", szInput, 8))
			{
				if(FAILED(hr = DumpWebAlive(qwUserPuid, g_bufInput, g_bufOutput)))
				{
					printf("DumpWebAlive() failed: HR: 0x%08x\n", hr);
				}
				bParsed = true;
			}
			else if(!strncmp("weblist", szInput, 7))
			{
				if(FAILED(hr = DumpWebList(qwUserPuid, g_bufInput, g_bufOutput)))
				{
					printf("DumpWebList() failed, HR: 0x%08x\n", hr);
				}
				bParsed = true;
			}
			else if(!strncmp("webfd", szInput, 5))
			{
				if(FAILED(hr = DumpWebAlive(qwUserPuid, g_bufInput, g_bufOutput)))
				{
					printf("DumpWebAlive() failed: HR: 0x%08x\n", hr);
				}
				
				if(hr == S_OK)
				{
					printf("Emulating 1 second sleep due to S_OK HRESULT (non-cached web alive)\n");
					Sleep(1000);
				}

				if(FAILED(hr = DumpWebList(qwUserPuid, g_bufInput, g_bufOutput)))
				{
					printf("DumpWebList() failed, HR: 0x%08x\n", hr);
				}

				bParsed = true;
			}
			else if(!strncmp("exit", szInput, 4))
			{
				break;
			}

			if(!bParsed)				
			{
				printf("Commands: webalive <puid>, weblist <puid>, webfd <puid>, exit\n");
			}
		}

		
	} while(argc == 1 && printf("cmd> ") && fgets(szInput, sizeof(szInput), stdin));

lbCleanup:

	DisconnectServers();
	
	WinsockDOWN();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XlastDataFixups\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XlastDataFixups")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("XlastDataFixups")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("48e2b5a4-47a6-482d-8a17-dc433bd88b35")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\xblPerfWeb\App_Code\Database.cs ===
using System;
using System.Data.SqlClient;
using System.Collections;
using System.Data;

namespace perfweb
{
    public class Target
    {
        // static only.
        private Target() { }

        public static void AddTarget(Int32 ApiId, Int32 CounterId, Int32 ReleaseId, Int32 CounterType, double Target)
        {
            string sql = String.Format("INSERT INTO Targets(TargetTypeId, ApiId, ReleaseId, PerformanceCounterId, Target) " +
                "VALUES({0},{1},{2},{3},{4})", CounterType, ApiId, ReleaseId, CounterId, Target);
            ExecuteSql(sql);
        }

        public static void DeleteTarget(Int32 ApiTargetId)
        {
            string sql = String.Format("DELETE FROM Targets WHERE TargetId={0}", ApiTargetId);
            ExecuteSql(sql);
        }

        public static void CopyTargets(Int32 FromReleaseId, Int32 ToReleaseId)
        {
            SqlCommand cmd = new SqlCommand();
            cmd.CommandText = "CopyReleaseTargets";
            cmd.CommandType = CommandType.StoredProcedure;

            SqlParameter p1 = new SqlParameter("@FromReleaseId", SqlDbType.Int);
            p1.Value = FromReleaseId;
            cmd.Parameters.Add(p1);

            SqlParameter p2 = new SqlParameter("@ToReleaseId", SqlDbType.Int);
            p2.Value = ToReleaseId;
            cmd.Parameters.Add(p2);

            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            cmd.Connection = cn;
            cmd.ExecuteNonQuery();
            cn.Close();
        }


        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }

    }

    public class Api
    {
        private Api() { }

        public static void AddApi(String ApiName)
        {
            string sql = String.Format("INSERT INTO Apis (ApiName) VALUES ('{0}')", ApiName);
            ExecuteSql(sql);
        }

        public static void DeleteApi(Int32 ApiId)
        {
            string sql = String.Format("DELETE FROM Apis WHERE ApiId={0}", ApiId);
            ExecuteSql(sql);
        }

        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }
    }

    public class Scenario
    {
        private Scenario() { }

        public static void AddScenarioApi(Int32 ScenarioId, Int32 ApiId)
        {
            string sql = String.Format("INSERT INTO ScenarioApi (ScenarioId, ApiId) VALUES ({0},{1})", ScenarioId, ApiId);
            ExecuteSql(sql);
        }

        public static void DeleteScenarioApi(Int32 ScenarioApiKey)
        {
            string sql = String.Format("DELETE FROM ScenarioApi WHERE ScenarioAPIKey={0}", ScenarioApiKey.ToString());
            ExecuteSql(sql);
        }

        public static void AddScenarioCounter(Int32 Scenarioid, Int32 CounterId)
        {
            // machine type 21 is xblob.
            string sql = String.Format("INSERT INTO CollectTheseCounters (ScenarioId, MachineTypeid, PerformanceCounterId, CounterTypeId) VALUES ({0}, 21, {1}, 3)", Scenarioid, CounterId);
            ExecuteSql(sql);
        }

        public static void AddScenario(string ScenarioName)
        {
            string sql = String.Format("INSERT INTO Scenarios (ScenarioName, IsOneOffTest) VALUES ('{0}', 0)", ScenarioName);
            ExecuteSql(sql);
        }

        public static void DeleteScenario(Int32 ScenarioId)
        {
            string sql = String.Format("DELETE FROM Scenarios WHERE ScenarioID={0}", ScenarioId);
            ExecuteSql(sql);
        }

        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }
    }

    public class Counter
    {
        private Counter() { }

        public static void AddCounter(String CounterPath, String DisplayType)
        {
            string sql = String.Format("INSERT INTO PerformanceCounters (CounterPath, DefaultScale, IsCommon, DisplayType) VALUES ('{0}', 0,0,'{1}')", CounterPath, DisplayType);
            ExecuteSql(sql);
        }

        public static void DeleteCounter(Int32 PerformanceCounterId)
        {
            string sql = String.Format("DELETE FROM PerformanceCounters WHERE PerformanceCounterID={0}", PerformanceCounterId.ToString());
            ExecuteSql(sql);
        }

        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }
    }

    public class CollectTheseCounters
    {
        private CollectTheseCounters() { }

        public static void DeleteCounterCollection(Int32 CollectId)
        {
            string sql = String.Format("DELETE FROM CollectTheseCounters WHERE CollectId={0}", CollectId.ToString());
            ExecuteSql(sql);
        }

        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }
    }

    public class Release
    {
        private Release() { }

        public static void AddRelease(String ReleaseName, DateTime ReleaseDate, Int32 ProductId, String DropLocation)
        {
            string sql = String.Format("INSERT INTO Releases (Release, ReleaseDate, ProductId, DropLocation) VALUES ('{0}','{1}',{2},'{3}')", ReleaseName, ReleaseDate.ToString(), ProductId.ToString(), DropLocation);
            ExecuteSql(sql);
        }

        public static void DeleteRelease(Int32 ReleaseId)
        {
            string sql = String.Format("DELETE FROM Releases WHERE ReleaseId={0}", ReleaseId.ToString());
            ExecuteSql(sql);
        }

        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }
    }

    public class Product
    {
        private Product() { }

        public static void AddProduct(String ProductName, String ProductAbbreviated)
        {
            string sql = String.Format("INSERT INTO Products (Product, ProductAbbreviated, SortOrder) VALUES ('{0}','{1}',1)", ProductName, ProductAbbreviated);
            ExecuteSql(sql);
        }

        public static void DeleteProduct(Int32 ProductId)
        {
            string sql = String.Format("DELETE FROM Products WHERE ProductID={0}", ProductId.ToString());
            ExecuteSql(sql);
        }

        private static void ExecuteSql(string sql)
        {
            SqlConnection cn = new SqlConnection("server=josephfo;database=PerformanceSummaries;User ID=PerfUser;Password=PerfUser;");
            cn.Open();
            SqlCommand cmd = new SqlCommand(sql, cn);
            cmd.ExecuteNonQuery();
            cn.Close();
        }


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\MainForm.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using xonline.common.service;

namespace XRLDecoder
{
    public partial class MainForm : Form
    {
        private XrlList Xrls;


        public MainForm()
        {
            InitializeComponent();
            Xrls = new XrlList(textInput.Text);
            RefreshDataDrid();
        }

        private void RefreshDataDrid()
        {
            dgvXRLCalls.Rows.Clear();
            foreach (XrlWrapper xrl in Xrls)
            {
               // DataGridViewRow row = dgvXRLCalls.RowTemplate.Clone() as DataGridViewRow;
               // row.Cells["colDate"].Value = xrl.Date;
               // row.Cells["colXrl"].Value = xrl.URI;
               // row.Cells["colRequest"].Value = xrl.Request;
                dgvXRLCalls.Rows.Add(new object[] { xrl.Date, xrl.URI, WireInfoAttribute.VersionToString(xrl.Schema) });
            }
        }

        private void dgvXRLCalls_RowHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (Xrls[e.RowIndex].Request != null)
            {
                textRequest.Lines = Xrls[e.RowIndex].Request.ToString().Split('\n');
            }
            else
            {
                textRequest.Text = Xrls[e.RowIndex].RequestError;
            }
        }

        private void textInput_TextChanged(object sender, EventArgs e)
        {
            Xrls.Clear();
            Xrls.ReadString(textInput.Text);
            RefreshDataDrid();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\Program.cs ===
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace XRLDecoder
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\XrlList.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace XRLDecoder
{
    class XrlList : IEnumerable<XrlWrapper>
    {
        private List<XrlWrapper> _lis;


        public XrlWrapper this[int index]
        {
            get { return _lis[index]; }
            set {  }
        }

        public int Count 
        {
            get { return _lis.Count; }
        }

        public XrlList(StreamReader input)
        {
            _lis = new List<XrlWrapper>();
            ReadStream(input);
        }

        public XrlList(string input)
        {
            _lis = new List<XrlWrapper>();
            ReadString(input);
        }

        public void Clear()
        {
            _lis.Clear();
        }

        public void ReadString(string input)
        {
            MemoryStream stream = new MemoryStream(Encoding.UTF8.GetBytes(input));
            ReadStream(new StreamReader(stream));
        }

        public void ReadStream(StreamReader input)
        {
            while (!input.EndOfStream)
            {
                if (input.Peek() == (int)'>')
                {
                    _lis.Add(new XrlWrapper(input));
                }
                else
                {
                    input.ReadLine();
                }
            }
        }


        #region IEnumerable<XrlWrapper> Members

        public IEnumerator<XrlWrapper> GetEnumerator()
        {
            return _lis.GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return (System.Collections.IEnumerator)_lis.GetEnumerator();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\MainForm.Designer.cs ===
namespace XRLDecoder
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tpDecoder = new System.Windows.Forms.TabPage();
            this.splitContainer1 = new System.Windows.Forms.SplitContainer();
            this.splitContainer2 = new System.Windows.Forms.SplitContainer();
            this.textRequest = new System.Windows.Forms.TextBox();
            this.textResponse = new System.Windows.Forms.TextBox();
            this.dgvXRLCalls = new System.Windows.Forms.DataGridView();
            this.colDate = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colXrl = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.tpInput = new System.Windows.Forms.TabPage();
            this.textInput = new System.Windows.Forms.TextBox();
            this.Schema = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.tabControl1.SuspendLayout();
            this.tpDecoder.SuspendLayout();
            this.splitContainer1.Panel1.SuspendLayout();
            this.splitContainer1.Panel2.SuspendLayout();
            this.splitContainer1.SuspendLayout();
            this.splitContainer2.Panel1.SuspendLayout();
            this.splitContainer2.Panel2.SuspendLayout();
            this.splitContainer2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dgvXRLCalls)).BeginInit();
            this.tpInput.SuspendLayout();
            this.SuspendLayout();
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tpDecoder);
            this.tabControl1.Controls.Add(this.tpInput);
            this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabControl1.Location = new System.Drawing.Point(0, 0);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(689, 512);
            this.tabControl1.TabIndex = 0;
            // 
            // tpDecoder
            // 
            this.tpDecoder.Controls.Add(this.splitContainer1);
            this.tpDecoder.Location = new System.Drawing.Point(4, 22);
            this.tpDecoder.Name = "tpDecoder";
            this.tpDecoder.Padding = new System.Windows.Forms.Padding(6);
            this.tpDecoder.Size = new System.Drawing.Size(681, 486);
            this.tpDecoder.TabIndex = 0;
            this.tpDecoder.Text = "Decoder";
            this.tpDecoder.UseVisualStyleBackColor = true;
            // 
            // splitContainer1
            // 
            this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitContainer1.Location = new System.Drawing.Point(6, 6);
            this.splitContainer1.Name = "splitContainer1";
            this.splitContainer1.Orientation = System.Windows.Forms.Orientation.Horizontal;
            // 
            // splitContainer1.Panel1
            // 
            this.splitContainer1.Panel1.Controls.Add(this.splitContainer2);
            // 
            // splitContainer1.Panel2
            // 
            this.splitContainer1.Panel2.Controls.Add(this.dgvXRLCalls);
            this.splitContainer1.Size = new System.Drawing.Size(669, 474);
            this.splitContainer1.SplitterDistance = 311;
            this.splitContainer1.TabIndex = 1;
            // 
            // splitContainer2
            // 
            this.splitContainer2.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitContainer2.Location = new System.Drawing.Point(0, 0);
            this.splitContainer2.Name = "splitContainer2";
            // 
            // splitContainer2.Panel1
            // 
            this.splitContainer2.Panel1.Controls.Add(this.textRequest);
            // 
            // splitContainer2.Panel2
            // 
            this.splitContainer2.Panel2.Controls.Add(this.textResponse);
            this.splitContainer2.Size = new System.Drawing.Size(669, 311);
            this.splitContainer2.SplitterDistance = 331;
            this.splitContainer2.TabIndex = 0;
            // 
            // textRequest
            // 
            this.textRequest.Dock = System.Windows.Forms.DockStyle.Fill;
            this.textRequest.Location = new System.Drawing.Point(0, 0);
            this.textRequest.Multiline = true;
            this.textRequest.Name = "textRequest";
            this.textRequest.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.textRequest.Size = new System.Drawing.Size(331, 311);
            this.textRequest.TabIndex = 0;
            // 
            // textResponse
            // 
            this.textResponse.Dock = System.Windows.Forms.DockStyle.Fill;
            this.textResponse.Location = new System.Drawing.Point(0, 0);
            this.textResponse.Multiline = true;
            this.textResponse.Name = "textResponse";
            this.textResponse.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.textResponse.Size = new System.Drawing.Size(334, 311);
            this.textResponse.TabIndex = 0;
            // 
            // dgvXRLCalls
            // 
            this.dgvXRLCalls.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dgvXRLCalls.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.colDate,
            this.colXrl,
            this.Schema});
            this.dgvXRLCalls.Dock = System.Windows.Forms.DockStyle.Fill;
            this.dgvXRLCalls.Location = new System.Drawing.Point(0, 0);
            this.dgvXRLCalls.Name = "dgvXRLCalls";
            this.dgvXRLCalls.Size = new System.Drawing.Size(669, 159);
            this.dgvXRLCalls.TabIndex = 0;
            this.dgvXRLCalls.RowHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.dgvXRLCalls_RowHeaderMouseClick);
            // 
            // colDate
            // 
            this.colDate.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
            this.colDate.HeaderText = "Date";
            this.colDate.MaxInputLength = 32;
            this.colDate.Name = "colDate";
            this.colDate.ReadOnly = true;
            this.colDate.Resizable = System.Windows.Forms.DataGridViewTriState.False;
            this.colDate.Width = 55;
            // 
            // colXrl
            // 
            this.colXrl.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
            this.colXrl.HeaderText = "Xrl";
            this.colXrl.MaxInputLength = 128;
            this.colXrl.Name = "colXrl";
            this.colXrl.ReadOnly = true;
            this.colXrl.Width = 44;
            // 
            // tpInput
            // 
            this.tpInput.Controls.Add(this.textInput);
            this.tpInput.Location = new System.Drawing.Point(4, 22);
            this.tpInput.Name = "tpInput";
            this.tpInput.Padding = new System.Windows.Forms.Padding(3);
            this.tpInput.Size = new System.Drawing.Size(681, 486);
            this.tpInput.TabIndex = 1;
            this.tpInput.Text = "Input";
            this.tpInput.UseVisualStyleBackColor = true;
            // 
            // textInput
            // 
            this.textInput.Dock = System.Windows.Forms.DockStyle.Fill;
            this.textInput.Location = new System.Drawing.Point(3, 3);
            this.textInput.Multiline = true;
            this.textInput.Name = "textInput";
            this.textInput.Size = new System.Drawing.Size(675, 480);
            this.textInput.TabIndex = 0;
            this.textInput.TextChanged += new System.EventHandler(this.textInput_TextChanged);
            // 
            // Schema
            // 
            this.Schema.HeaderText = "Schema";
            this.Schema.Name = "Schema";
            this.Schema.ReadOnly = true;
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(689, 512);
            this.Controls.Add(this.tabControl1);
            this.Name = "MainForm";
            this.Text = "XRL Decoder";
            this.tabControl1.ResumeLayout(false);
            this.tpDecoder.ResumeLayout(false);
            this.splitContainer1.Panel1.ResumeLayout(false);
            this.splitContainer1.Panel2.ResumeLayout(false);
            this.splitContainer1.ResumeLayout(false);
            this.splitContainer2.Panel1.ResumeLayout(false);
            this.splitContainer2.Panel1.PerformLayout();
            this.splitContainer2.Panel2.ResumeLayout(false);
            this.splitContainer2.Panel2.PerformLayout();
            this.splitContainer2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.dgvXRLCalls)).EndInit();
            this.tpInput.ResumeLayout(false);
            this.tpInput.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TabControl tabControl1;
        private System.Windows.Forms.TabPage tpDecoder;
        private System.Windows.Forms.TabPage tpInput;
        private System.Windows.Forms.TextBox textInput;
        private System.Windows.Forms.SplitContainer splitContainer1;
        private System.Windows.Forms.DataGridView dgvXRLCalls;
        private System.Windows.Forms.DataGridViewTextBoxColumn colDate;
        private System.Windows.Forms.DataGridViewTextBoxColumn colXrl;
        private System.Windows.Forms.SplitContainer splitContainer2;
        private System.Windows.Forms.TextBox textRequest;
        private System.Windows.Forms.TextBox textResponse;
        private System.Windows.Forms.DataGridViewTextBoxColumn Schema;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XRLDecoder")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("XRLDecoder")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("69ef1dac-9954-48ea-935e-c9000ff0d8d5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\log.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation
// log.cpp

// Error logging for server side
#include "stdafx.h"
//#include "msg.h"
#include "log.h"
#include "Reg.h"
#include "Regkeys.h"
#include "stringutl.h"
//#include "lmcons.h."
#include "psapi.h"

const int LOGMSG_BUFFER_SIZE = 4096;

WORD g_wLogCategory = 0;

static HANDLE g_hEventSource = INVALID_HANDLE_VALUE;
static BOOL g_fLogToConsole = FALSE;
static CRITICAL_SECTION g_csLog;

LLR g_llr;
XCF g_xcf;

static WORD rgTypeLtp[] = {EVENTLOG_ERROR_TYPE, EVENTLOG_WARNING_TYPE, EVENTLOG_INFORMATION_TYPE};
WCHAR *g_rgszLtp[] = {L"Error", L"Warning", L"Info"};

static SYSTEMTIME s_stLogLast;


// Given the inconvenience of storing a longlong to the registry, this is stored as a dword for now,
// but if we run out of bits, we may need to reconsider.
DWORD g_dwTraceGroups = 0;

HANDLE GetEventHandle(void) 
{
    return g_hEventSource;
}

BOOL GetLogToConsole(void) 
{
    return g_fLogToConsole;
}

void MyOutputDebugString(WCHAR *wsz, ...)
    {
#ifdef DEBUG
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE] = {0};
    va_list ap;

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg, sizeof(wszMsg)/sizeof(wszMsg[0])-1, wsz, ap);
    va_end(ap);

    // At this point cch is the length minus the null terminator
    if( cch >= 1 )
    {
        if( g_fLogToConsole )
        {
            // Oacr warning 6053 says not to trust _vsnprintf because it doesn't always null-terminate
            // wszMsg. However, we are (now) following the best-practice outlined at
            // http://msdn.microsoft.com/en-us/library/1kt27hek(VS.80).aspx, so we are fine.
            // TobiasB
#pragma warning ( push )
#pragma warning ( disable : 6053 )
            _putws(wszMsg);
#pragma warning ( pop )
        }

        // Add a newline if there isn't one there already
        // @devnote: we want 2 cch than cch(wszMsg[0]), so that we can add the \n over
        // the terminator and add a new terminator
        if( wszMsg[cch-1] != '\n' && 
            cch < sizeof(wszMsg)/sizeof(wszMsg[0]) - 2) 
        {
            wszMsg[cch] = '\n';
            wszMsg[cch+1] = 0;
        }

        // Ensure null termination
        if (cch<0)
            wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

        OutputDebugStringW(wszMsg);
    }
    else
    {
        if( cch < 0 )
            OutputDebugStringW(L"MyOutputDebugString buffer too small\n");
    }

#endif    
    }

int MyExceptionFilter(EXCEPTION_POINTERS *pExcept, WCHAR *wszFunctionName)
    {
    void *pAdr;
    DWORD dwId;
    
    dwId = GetCurrentThreadId();

    pAdr = NULL;
    if (pExcept)
        {
        pAdr = pExcept->ExceptionRecord->ExceptionAddress;
        LogError(L"Exception in '%s', %X , at address 0x%X, thread 0x%x\n", wszFunctionName, pExcept->ExceptionRecord->ExceptionCode, pAdr, dwId);
        }
    else
        LogError(L"Exception occured in '%s', thread 0x%x", wszFunctionName, dwId);

    if (!TryEnterCriticalSection(&g_csLog))
        {
        InterlockedIncrement(&g_llr.cCSBlock);
        EnterCriticalSection(&g_csLog);
        }

    MoveMemory(&g_xcf.rgSxv[1], &g_xcf.rgSxv[0], sizeof(SXV)*(cSxvSaved-1));
    g_xcf.cExcept++;
    g_xcf.rgSxv[0].pAdr = pAdr;
    MyWstrcpyn(g_xcf.rgSxv[0].sz, wszFunctionName, cchExceptionSavedMax);
    GetSystemTime(&g_xcf.rgSxv[0].st);

    LeaveCriticalSection(&g_csLog);
    
    return EXCEPTION_EXECUTE_HANDLER;
    }

void ExceptionXcf(XCF *pxcf)
{
    if (!TryEnterCriticalSection(&g_csLog))
        {
        InterlockedIncrement(&g_llr.cCSBlock);
        EnterCriticalSection(&g_csLog);
        }
    *pxcf = g_xcf;
    LeaveCriticalSection(&g_csLog);
}

void MyDebugBreak()
    {
#ifdef DEBUG
    DebugBreak();
#endif

#ifdef NOTYET
    __try 
        {
        wTemp = *(int *)0;
        }
    __except (UnhandledExceptionFilter(GetExceptionInformation())) 
        {
        DebugBreak();
        }
#endif
    }

// This function makes an entry into the application event log
void LogEvent(int ltp, const WCHAR *lpwsz, DWORD dwMsgId, ULONG ulDataSize, BYTE *pData)
{
    int cSkipLastHour, cch;
    BOOL fSkip;
    const WCHAR *rgwszBuf[1];
    LNF *plnf;
    SYSTEMTIME st;
    WCHAR wszSkip[1024];

    if (ltp<0 || ltp>=ltpMax)
        ltp = ltpError;

    // Check the event source has been registered and if
    // not then register it now
    if (g_hEventSource == INVALID_HANDLE_VALUE || g_hEventSource == NULL)
        {
#ifdef DEBUG
        //MyDebugBreak();
        OutputDebugString(L"LogEvent: No event source\n");
        OutputDebugString(lpwsz);
#endif
        return;
        }

    if (ulDataSize > 0 && pData == NULL)
    {
        ulDataSize = 0;
        OutputDebugString(L"Null pData in LogEvent\n");
        OutputDebugString(lpwsz);
    }

    if (!TryEnterCriticalSection(&g_csLog))
        {
        InterlockedIncrement(&g_llr.cCSBlock);
        EnterCriticalSection(&g_csLog);
        }

    // If we've had g_llr.cReportMax events of this type this hour, skip
    // logging it
    cSkipLastHour = 0;
    GetSystemTime(&st);
    if (st.wDay!=s_stLogLast.wDay || st.wHour!=s_stLogLast.wHour)
        {
        int ltpT;
        LNF *plnfT;

        for (ltpT=0; ltpT<ltpMax; ltpT++)
            {
            plnfT = &g_llr.rglnf[ltpT];

            cSkipLastHour += plnfT->cSkipThisHour;
            plnfT->cSkipThisHour = 0;
            plnfT->cThisHour = 0;
            }
        }

    plnf = &g_llr.rglnf[ltp];

    plnf->cThisHour++;
    plnf->cTotal++;

    fSkip = plnf->cThisHour >= g_llr.cReportMax;
    if (fSkip)
        plnf->cSkipThisHour++;

    MoveMemory(&plnf->rgSlv[1], &plnf->rgSlv[0], sizeof(SLV)*(cSlvSaved-1));

    plnf->rgSlv[0].st = st;
    s_stLogLast = st;

    cch = min(cchLogSavedMax-1, wcslen(lpwsz));
    MyWstrcpyn(plnf->rgSlv[0].sz, lpwsz, cch+1);

    // Call ReportEvent while inside the critical section.
    // This is supposed to decrease the likelihood of losing events 
    // when the event log is cleared.

    if (plnf->cThisHour==g_llr.cReportMax)
        {
        MywSnPrintf(wszSkip, sizeof(wszSkip)/sizeof(wszSkip[0]), L"More than %d %s events, silent until next hour", g_llr.cReportMax, g_rgszLtp[ltp]);
        rgwszBuf[0] = wszSkip;
        ReportEventW(g_hEventSource,
                          rgTypeLtp[ltp],
                          g_wLogCategory,
                          dwMsgId,    // EVMSG_GENERAL prepends "Message: "
                          NULL, // sid
                          1,
                          ulDataSize,
                          rgwszBuf,
                          pData);
        }
    else if (cSkipLastHour)
        {
        MywSnPrintf(wszSkip, sizeof(wszSkip)/sizeof(wszSkip[0]), L"Resume logging, skipped %d events last hour", cSkipLastHour);
        rgwszBuf[0] = wszSkip;
        ReportEventW(g_hEventSource,
                          rgTypeLtp[ltp],
                          g_wLogCategory,
                          dwMsgId,    // EVMSG_GENERAL prepends "Message: "
                          NULL, // sid
                          1,
                          ulDataSize,
                          rgwszBuf,
                          pData);
        }

    if (!fSkip)
        {
        rgwszBuf[0] = lpwsz;
        ReportEventW(g_hEventSource,
                          rgTypeLtp[ltp],
                          g_wLogCategory,
                          dwMsgId,    // EVMSG_GENERAL prepends "Message: "
                          NULL, // sid
                          1,
                          ulDataSize,
                          rgwszBuf,
                          pData);
        }


    if( g_fLogToConsole )
    {
        _putws(lpwsz);
    }
    LeaveCriticalSection(&g_csLog);

#ifdef DEBUG
    OutputDebugString(lpwsz);
    OutputDebugString(L"\n");
    // MyDebugBreak();
#endif

    // also log error to file?
}

int AddLogHeader(WCHAR *wszTarget, int cchMax)
{
    return MywSnPrintf(wszTarget, cchMax, L"TID[0x%06x]: ", GetCurrentThreadId());
}

void TraceInfo(DWORD dwGroup, WCHAR *wsz, ...)
{
    // Only do the debug print if this bit is set in the TraceGroups global.
    if (g_dwTraceGroups & (1 << dwGroup))
    {
        int cch;
        WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
        va_list ap;
        
        va_start(ap, wsz);
        cch = _vsnwprintf(wszMsg, NUMELEM(wszMsg)-1, wsz, ap);
        va_end(ap);
        OutputDebugString(wszMsg);
    }
}

// Special case of LogInfoID, with id = EVMSG_GENERAL
void LogInfo(WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpInfo, wszMsg, 1, 0, NULL);
    }

void LogInfoID(DWORD dwId, const WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpInfo, wszMsg, dwId, 0, NULL);
    }
    
void LogInfoIDBinary(DWORD dwId, BYTE *pData, ULONG ulDataSize, const WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpInfo, wszMsg, dwId, ulDataSize, pData);
    }
    

// Special case of LogWarningID, with id = EVMSG_GENERAL
void LogWarning(WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpWarn, wszMsg, 1, 0, NULL);
    }
    
void LogWarningID(DWORD dwId, const WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpWarn, wszMsg, dwId, 0, NULL);
    }
    
void LogWarningIDBinary(DWORD dwId, BYTE *pData, ULONG ulDataSize, const WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpWarn, wszMsg, dwId, ulDataSize, pData);
    }
    

// Special case of LogErrorID, with id = EVMSG_GENERAL
void LogError(WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpError, wszMsg, 1, 0, NULL);
    }

void LogErrorID(DWORD dwId, const WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpError, wszMsg, dwId, 0, NULL);
    }
    
void LogErrorIDBinary(DWORD dwId, BYTE *pData, ULONG ulDataSize, const WCHAR *wsz, ...)
    {
    int cch;
    WCHAR wszMsg[LOGMSG_BUFFER_SIZE];
    va_list ap;

    cch = AddLogHeader(wszMsg, NUMELEM(wszMsg));

    va_start(ap, wsz);
    cch = _vsnwprintf(wszMsg+cch, NUMELEM(wszMsg)-cch-1, wsz, ap);
    va_end(ap);

    if (cch<0)
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;

    LogEvent(ltpError, wszMsg, dwId, ulDataSize, pData);
    }
    
void LogInit(const WCHAR *wsz, const WCHAR *wszRegKey, const BOOL fConsole)
    {
    InitializeCriticalSection(&g_csLog);

    g_fLogToConsole = fConsole;
    
#ifdef DEBUG
    // It is sometimes useful for debugging to see who the current user is.
    int iErr = 0;
    WCHAR wszName[UNLEN + 1];
    DWORD dwSize = UNLEN + 1;
    GetUserName(wszName, &dwSize);
#endif

    // Beginning with Win2K, the user at this point is not necessarily 
    // an account with sufficient access rights to register an event handle.
    // If this code is being called from the UPS client, the client might be running 
    // in the IIS process or out of it. If it is running in-process, the 
    // user is apparently IUSR_... If it is running out-of-process, the user
    // is apparently IWAM_... Neither account, by default, has access rights 
    // to register an event handle. 

    // Without this call, the call to RegisterEventSource fails and 
    // we can't report any events. This solves the problem when we 
    // are running in-process. When running out-of-process, it is also
    // necessary to make the IWAM_... account not be a member of Guests.
    // We don't need to test the return value from RevertToSelf() because 
    // there isn't anything we would do differently if it succeeds or fails.
    BOOL fSuccess = RevertToSelf();
    
#ifdef DEBUG    
    iErr = GetLastError();
#endif
    
    g_hEventSource = RegisterEventSource(NULL,  // local machine
                                               wsz); // source name
#ifdef DEBUG    
    iErr = GetLastError();
#endif

    g_llr.cReportMax = 50;
    FGetRegistryDword(HKEY_LOCAL_MACHINE,
                      wszRegKey,
                      CLogReg::m_pwszLogReportMax,
                      (DWORD *)&g_llr.cReportMax);
    }

void LogClose(void)
    {
    if (g_hEventSource != INVALID_HANDLE_VALUE && g_hEventSource != NULL)
    {
        DeregisterEventSource(g_hEventSource);
        g_hEventSource = INVALID_HANDLE_VALUE;
    }
    DeleteCriticalSection(&g_csLog);
    }

void LogLlr(LLR *pllr)
{
    if (!TryEnterCriticalSection(&g_csLog))
        {
        InterlockedIncrement(&g_llr.cCSBlock);
        EnterCriticalSection(&g_csLog);
        }

    *pllr = g_llr;
    LeaveCriticalSection(&g_csLog);
}

BOOL FAppendString(WCHAR *wszAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = wcslen(wszAppend);
    if (cch==0)
        return TRUE;

    if (*pcch + cch >= cchMax)
        return FALSE;

    wcscpy(wsz+*pcch, wszAppend);
    *pcch += cch;
    return TRUE;
}

BOOL FFormatDateTime(SYSTEMTIME *pst, WCHAR *wsz, int cchMax)
{
    int cch;
    WCHAR wszTime[257];
    WCHAR wszDate[257];
    SYSTEMTIME st;

    if (pst->wYear==0)
        {
        cch = 0;
        return FAppendString(L"???", wsz, &cch, cchMax);
        }

    SystemTimeToTzSpecificLocalTime(NULL, pst, &st);

    cch = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, L"MMM dd',' yyyyy ", wszDate, 256);
    wszDate[cch] = 0;

    cch = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, L"hh:mm:ss tt", wszTime, 256);
    wszTime[cch] = 0;

    cch = MywSnPrintf(wsz, cchMax, L"%s %s",  wszTime, wszDate);
    if (cch<0)
        return FALSE;

    return TRUE;
}


BOOL FAppendTime(WCHAR *wszAppend, SYSTEMTIME *pst, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;
    WCHAR wszDateTime[257];
    WCHAR wszTemp[257];

    if (!FFormatDateTime(pst, wszDateTime, 256))
        return FALSE;

    cch = MywSnPrintf(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), L"%s %s PST ", wszAppend, wszDateTime);
    if (cch<0)
        return FALSE;

    cch = wcslen(wszTemp);
    if (*pcch + cch >= cchMax)
        return FALSE;

    wcscpy(wsz+*pcch, wszTemp);
    *pcch += cch;
    return TRUE;
}


BOOL FAppendInt(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s %d", wszAppend, wAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendHexInt(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s 0x%x", wszAppend, wAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendIntBr(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s 0x%x<BR>", wszAppend, wAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendIntDec(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s %d ", wszAppend, wAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendIntDecBr(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s %d<BR>", wszAppend, wAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendInt64DecBr(WCHAR *wszAppend, __int64 wAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s %I64d<BR>", wszAppend, wAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendDouble(WCHAR *wszAppend, double dAppend, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;
    double dT;
    WCHAR *wszFormat;

    dT = dAppend;
    if (dT<0.0)
        dT = -dT;

    if ((double)(int)dT == dT)
        wszFormat = L"%s %.0f";
    else if (dT<0.001)
        wszFormat = L"%s %.6f";
    else if (dT<1.0)
        wszFormat = L"%s %.4f";
    else if (dT<100)
        wszFormat = L"%s %.2f";
    else
        wszFormat = L"%s %.0f";

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, wszFormat, wszAppend, dAppend);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendDoublePercent(WCHAR *wszAppend, double dAppend, double dTotal, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    if (!FAppendDouble(wszAppend, dAppend, wsz, pcch, cchMax))
        return FALSE;

    if (dTotal==0.0)
        dTotal = 1.0;

    cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L" (%.1f)", dAppend/dTotal*100.0);
    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

BOOL FAppendDeltaFileTime(WCHAR *wszAppend, FILETIME *pft, WCHAR *wsz, int *pcch, int cchMax)
{
    double dT;
    __int64 i64T;

    i64T = *(__int64 *)pft;

    dT = (double) i64T / 10000000.0;

    return FAppendDouble(wszAppend, dT, wsz, pcch, cchMax);
}

void MyFileTimeToSystemTime(FILETIME *pft, SYSTEMTIME *pst)
{
    if (pft->dwLowDateTime==0 && pft->dwHighDateTime==0)
        FillMemory(pst, sizeof(SYSTEMTIME), 0);
    else
        FileTimeToSystemTime(pft, pst);
}

BOOL FAppendFileTime(WCHAR *wszAppend, FILETIME *pft, WCHAR *wsz, int *pcch, int cchMax)
{
    SYSTEMTIME stT;

    MyFileTimeToSystemTime(pft, &stT);

    return FAppendTime(wszAppend, &stT, wsz, pcch, cchMax);
}

BOOL FAppend2FileTimes(FILETIME *pft1, FILETIME *pft2, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;
    SYSTEMTIME st1, st2;
    WCHAR wszDateTime1[257];
    WCHAR wszDateTime2[257];
    WCHAR wszTemp[257];

    MyFileTimeToSystemTime(pft1, &st1);
    MyFileTimeToSystemTime(pft2, &st2);

    if (!FFormatDateTime(&st1, wszDateTime1, 256))
        return FALSE;

    if (!FFormatDateTime(&st2, wszDateTime2, 256))
        return FALSE;

    cch = MywSnPrintf(wszTemp, sizeof(wszTemp)/sizeof(wszTemp[0]), L"<TD>%s PST</TD><TD>%s PST</TD>", wszDateTime1, wszDateTime2);
    if (cch<0)
        return FALSE;

    cch = wcslen(wszTemp);
    if (*pcch + cch >= cchMax)
        return FALSE;

    wcscpy(wsz+*pcch, wszTemp);
    *pcch += cch;
    return TRUE;
}

BOOL FAppendLock(int cLock, WCHAR *wszLock, WCHAR *wsz, int *pcch, int cchMax)
{
    int cch;

    if (!cLock)
        return TRUE;

    if (cLock != 1)
        cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s (%d) ", wszLock, cLock);
    else
        cch = MywSnPrintf(wsz+*pcch, cchMax - *pcch, L"%s ", wszLock);

    if (cch<0)
        {
        wsz[*pcch] = 0;
        return FALSE;
        }

    *pcch += cch;
    return TRUE;
}

void ExtractSQLServerNameFromConnectionString(const WCHAR *wszIn, WCHAR *wszSSName, int cchOutBufLen)
{
    if (wszSSName && cchOutBufLen > 0)
        wszSSName[0] = 0;

    WCHAR *pCopy = wszSSName;
    const WCHAR *pwszTag = L"Data Source=";
        
    WCHAR const *p = wcsstr(wszIn, pwszTag);
    if (p)
    {
        p += wcslen(pwszTag);
        
        while (*p && *p != L';')
            *pCopy++ = *p++;
        *pCopy = 0;
    }
}

// Replace any password in wszIn with '???'. wszIn is a SQL connection string. Like
// RemovePasswordFromConnectionString, except it removes the password in place.
void ScrubPassword(WCHAR *wszIn, DWORD dwLen)
{
    WCHAR *pwszScan = NULL;
    WCHAR *pwszMax = wszIn + dwLen;
    
    if ((pwszScan = wcsstr(wszIn, L"Password=")) != NULL)
    {
        pwszScan += wcslen(L"Password=");
        while ((*pwszScan != L' ' && *pwszScan != L';' && *pwszScan != L']' && *pwszScan != L')') && pwszScan < pwszMax)
        {
            *pwszScan = L'?';
            pwszScan++;
        }
    }
}

// Replace any password in wszIn with '???'. wszIn is a SQL connection string.
void RemovePasswordFromConnectionString(const WCHAR *wszIn, WCHAR *wszOut, int cchOutBufLen)
{
    int iOffset = 0;
    WCHAR const *p = wcsstr(wszIn, L"Password=");
    if (p)
    {
        // Make p point to the character just after the = sign
        p+=9;

        iOffset = ((int)(p-wszIn));
        if (iOffset + 4 < cchOutBufLen)
        {
            // Copy from the beginning up until p into the output buffer
            memcpy(wszOut, wszIn, iOffset*sizeof(WCHAR));
            MyWstrcpyn(wszOut + iOffset, L"???", 4);
            WCHAR *pOut = wszOut + iOffset + 3;

            while (*p && *p != ';')
                p++;

            if (*p == ';')
            {
                iOffset = ((int)(p-wszIn));
                int iLenP = (int)wcslen(p);
                if (iOffset + iLenP < cchOutBufLen)
                {
                    MyWstrcpyn(pOut, p, iLenP + 1);
                }
            }
        }
    }
    else
        MyWstrcpyn(wszOut, wszIn, cchOutBufLen);
}


// Andy Pennell (VC++ Dev Lead) had this to say:
// All VC debuggers 6.0 and later understand this event. Its only documentation is in the various public PPTs 
// that we have done to broadcast the fact. It works on all Win32 flavours (haven't yet verified it on Win64 
// come to think of it). If you are not under a debugger at the time the call is made, the thread name is lost. 
// If two calls are made on the same thread, the last one wins.
void NameThread(WCHAR *wszName, DWORD dwThreadId /*=(DWORD)-1*/)
{
    char szName[1024];
    WideCharToMultiByte(CP_ACP, 0, wszName, -1, szName, NUMELEM(szName), NULL, NULL);
    NameThread(szName, dwThreadId);
}

void NameThread(char *szName, DWORD dwThreadId /*=(DWORD)-1*/)
{
    struct
    {
        DWORD  dwType;      // Must be 0x00001000
        LPCSTR szName;      // ANSI string pointer to name.
        DWORD  dwThreadId;  // Thread Id, or -1 for current thread.  Only -1 seems to work.
        DWORD  dwFlags;     // Reserved, must be zero.
    } ThreadName = { 0x00001000, szName, dwThreadId, 0 };
                                    
    // Raise a magic VC exception.  It needs to be handled when not running under VC.
    __try
    {
        RaiseException(0x406D1388, 0, 4, (ULONG_PTR*)&ThreadName);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

void SetLogCategory(WORD wCat)
{
    g_wLogCategory = wCat;
}

#define MAX_PATH                    260
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\reg.cpp ===
//-----------------------------------------------------------------------------
// File:			reg.cpp
//
// Copyright:		Copyright (c) 1999-2001 Microsoft Corporation
//
// Comments: 		Utility routines for reading/writing the registry.
//
// Author:			waltke and briants
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "reg.h"

BOOL FGetRegistryWsz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, WCHAR *szBuf, DWORD cbBuf)
{
	HKEY 	hkey;
	DWORD	dwType;
	BOOL	fRet = FALSE;
	
	szBuf[0] = 0;
	
	if (RegOpenKeyEx(hkeyRoot, wszKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
		{
		if (RegQueryValueEx(hkey, wszVal, NULL, &dwType, (LPBYTE)szBuf, &cbBuf) == ERROR_SUCCESS)
			fRet = (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ);
			
		RegCloseKey(hkey);
		}
		
	return(fRet);
}

BOOL FGetRegistryDword(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, DWORD *pdwRet)
{
	HKEY 	hkey;
	DWORD	dwType, dwT, cbRet;
	BOOL	fRet = FALSE;
	
	cbRet = sizeof(DWORD);
	
	if (RegOpenKeyEx(hkeyRoot, wszKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
		{
		if (RegQueryValueEx(hkey, wszVal, NULL, &dwType, (BYTE *)&dwT, &cbRet) == ERROR_SUCCESS)
			{
			if (dwType == REG_DWORD)
				{
				*pdwRet = dwT;
				fRet = TRUE;
				}
			}
			
		RegCloseKey(hkey);
		}
		
	return(fRet);
}

BOOL FSetRegistry(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, DWORD dwType, BYTE* pBytes, DWORD cbBytes, LPDWORD pdwDisp)
{
	HKEY 	hkey;
	BOOL	fRet = FALSE;

    if( RegCreateKeyEx(	hkeyRoot, wszKey, 0, L"", REG_OPTION_NON_VOLATILE, 
    			KEY_WRITE | KEY_ALL_ACCESS, NULL, &hkey, pdwDisp) == ERROR_SUCCESS )
	{
		LONG lRet = RegSetValueEx(hkey, wszVal, 0, dwType, (BYTE*)pBytes, cbBytes);
	    if(lRet  == ERROR_SUCCESS )
		{
			fRet = TRUE;
		}
			
		RegCloseKey(hkey);
	}
		
	return(fRet);
}

BOOL FSetRegistryDword(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, DWORD dwVal, LPDWORD pdwDisp)
{
	DWORD dwValue = dwVal;
	return FSetRegistry(hkeyRoot, wszKey, wszVal, REG_DWORD, (BYTE*)&dwValue, sizeof(DWORD), pdwDisp);
}

BOOL FSetRegistryExpandSz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, const WCHAR* pwszVal, DWORD cchVal, LPDWORD pdwDisp)
{
	return FSetRegistry(hkeyRoot, wszKey, wszVal, REG_EXPAND_SZ, (BYTE*)pwszVal, (cchVal * sizeof(WCHAR)), pdwDisp);
}

BOOL FSetRegistrySz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, const WCHAR* pwszVal, DWORD cchVal, LPDWORD pdwDisp)
{
	return FSetRegistry(hkeyRoot, wszKey, wszVal, REG_SZ, (BYTE*)pwszVal, (cchVal * sizeof(WCHAR)), pdwDisp);
}

BOOL FSetRegistryMultiSz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, const WCHAR* pwszVal, DWORD cchVal, LPDWORD pdwDisp)
{
	return FSetRegistry(hkeyRoot, wszKey, wszVal, REG_MULTI_SZ, (BYTE*)pwszVal, (cchVal * sizeof(WCHAR)), pdwDisp);
}

//-------------------------------------------------------------------------------
// Recursively delete pKeyName and everything beneath it
//-------------------------------------------------------------------------------
DWORD RegDeleteKeyNT(HKEY hStartKey, WCHAR *pwszKeyName)
{
   DWORD   dwRtn, dwSubKeyLength;
   WCHAR   wszSubKey[256];
   HKEY    hKey;
 
   // do not allow NULL or empty key name
	if (pwszKeyName && *pwszKeyName)
	{
		if( (dwRtn=RegOpenKeyEx(hStartKey, pwszKeyName,
			 0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
		{
			while (dwRtn == ERROR_SUCCESS)
			{
				dwSubKeyLength = 256;
				dwRtn=RegEnumKeyEx(
						   hKey,
						   0,       // always index zero
						   wszSubKey,
						   &dwSubKeyLength,
						   NULL,
						   NULL,
						   NULL,
						   NULL
						 );

				if(dwRtn == ERROR_NO_MORE_ITEMS)
				{
					dwRtn = RegDeleteKey(hStartKey, pwszKeyName);
					break;
				}
				else if(dwRtn == ERROR_SUCCESS)
				{
					// Try to delete this key
					dwRtn = RegDeleteKey(hKey, wszSubKey);

					// If this key has subkeys, the delete failed with ERROR_ACCESS_DENIED.
					// In that case, call this function recursively to delete the child keys
					// first.
					if (dwRtn == ERROR_ACCESS_DENIED)
					{
						WCHAR wszNewKey[512];
						lstrcpyn(wszNewKey, pwszKeyName, NUMELEM(wszNewKey));
						StrCatMaxLen(wszNewKey, L"\\", NUMELEM(wszNewKey));
						StrCatMaxLen(wszNewKey, wszSubKey, NUMELEM(wszNewKey));
						dwRtn = RegDeleteKeyNT(hStartKey, wszNewKey);		// recursive call!

						// Try to delete the original key again.
						if (dwRtn == ERROR_SUCCESS)
						{
							dwRtn = RegDeleteKey(hKey, wszSubKey);

							// If ERROR_FILE_NOT_FOUND, it means the key was already deleted
							if (dwRtn == ERROR_FILE_NOT_FOUND)
								dwRtn = ERROR_SUCCESS;
						}
					}
				}
			}
			RegCloseKey(hKey);
			// Do not save return code because error
			// has already occurred
		}
	}
	else
		dwRtn = ERROR_BADKEY;

	return dwRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\regkeys.cpp ===
//-----------------------------------------------------------------------------
// File:			RegKeys.cpp
//
// Copyright:		Copyright (c) 1999-2001 Microsoft Corporation
//
// Contents: 		Implementation of CDsReg and CClientReg
//
// Comments: 		Reg keys used by various test modules
//
//-----------------------------------------------------------------------------

// Note: please use the following format to document each reg key.  It is important to follow the field format exactly so that parser will be able  to recognize it.

// Some notes on the documentation fields and how they are used:
// Key:  		Name of Registry Key
// Type: 		Registry Key Type, e.g. REG_DWORD
// Created Ver: The version the reg key was created.  E.g. 1.1, 1.5, 2.0
// Created By:  Alias of the developer who created the registry key
// Attribute:  	The fields are defined as :
//	 		 	Required: 	Is this setting required for the application to work? 
// 			  	Internal:		Is this setting only for internal use, i.e. it should not be exposed to partners
// 			   	Configurable:	Can this setting be changed?
// 			    Write-Only:	Is this a write-only value?
//				Delete the entries that are not applicable.
// Default:  	What is the default setting for the reg key? 
// Unit:  		What is the unit the reg key setting represents? N/A if not applicable
// Valid Value:	Specify the what the valid values are for this key as completely as possible.  Min/Max, True/False, etc.
// Scope:  	   	What applications does this key apply to?  Delete the entries that are not applicable.
// Description:	Describe the registry key and any additional comments
// 
//+==========================================================================================
//  Key         - "ConnectionsCache"
//  Type        - REG_DWORD ???
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Configurable>,
//  Default     - CONNECTIONS_TO_CACHE = 0 ???
//  Unit        - Unit_???? <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ???
//  Scope       - 
//  Description - Specifies something
//+==========================================================================================

#include "stdafx.h"
#include "regkeys.h"

#define EVENT_LOG_ROOT 
#define EVENT_MSG_FILE_KEY L"EventMessageFile"
#define TYPE_SUPPORTED_KEY L"TypesSupported"
#define CATEGORY_MSGFILE_KEY L"CategoryMessageFile"
#define CATEGORY_COUNT_KEY L"CategoryCount"

//+==========================================================================================
//		CLogReg				CLogReg				CLogReg
//+==========================================================================================

//+==========================================================================================
//  Key         - "ReportMax"
//  Type        - REG_DWORD
//  Created Ver - 1.0
//  Created By  - ????
//  Attribute   - <Configurable>
//  Default     - 50
//  Unit        - <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ???
//  Scope       - 
//  Description - The maximum number of event log entries of each type (error, warning, info)
//                that will be written to the log each hour. If this entry is not present,
//                no more than 50 events of each type per hour will be written. The log will
//                also note that the limit was reached and will report on the total number of
//                skipped events.
//+==========================================================================================
WCHAR *CLogReg::m_pwszLogReportMax = L"ReportMax";

//+==========================================================================================
//		CNtServiceReg				CNtServiceReg				CNtServiceReg
//
// ****: All registry entries are read at process start only.
//+==========================================================================================

//==================================
// named values under m_pwszEventLog
//==================================

//+==========================================================================================
//  Key         - "EventMessageFile"
//  Type        - REG_EXPAND_SZ
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Fixed>
//  Default     - Def_???? <N/A>
//  Unit        - Unit_???? <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ???
//  Scope       - <Spammer>
//  Description - specifies the location for the error messages. This value is established 
//                during service installation
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszEventMessageFile = EVENT_MSG_FILE_KEY;

//+==========================================================================================
//  Key         - "TypesSupported"
//  Type        - REG_DWORD
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Fixed>
//  Default     - 0x07
//  Unit        - <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ??? -- was <N/A>
//  Scope       - <Spammer>
//  Description - specifies the types of error messages. This value is established 
//                during service installation
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszTypesSupported = TYPE_SUPPORTED_KEY;

//+==========================================================================================
//  Key         - "CategoryMessageFile"
//  Type        - REG_EXPAND_SZ
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Fixed>
//  Default     - Def_???? <N/A>
//  Unit        - Unit_???? <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ???
//  Scope       - <Spammer>
//  Description - specifies the location for the error message categories. This value is established 
//                during service installation. 
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszEventCategoryMessageFile = CATEGORY_MSGFILE_KEY;

//+==========================================================================================
//  Key         - "CategoryCount"
//  Type        - REG_DWORD
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Fixed>
//  Default     - Def_???? <N/A>
//  Unit        - Unit_???? <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ???
//  Scope       - <Spammer>
//  Description - specifies the number of defined categories. This value is established 
//                during service installation
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszEventCategoryCount = CATEGORY_COUNT_KEY;

//+==========================================================================================
//  Key         - "Parameters\StartMode"
//  Type        - REG_DWORD
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Configurable>,
//  
// Default     - define SERVICE_DEMAND_START           0x00000003
//  Unit        - <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ??? -- was specifies the startup mode for the service. Possible values include (from winnt.h):
//                 #define SERVICE_BOOT_START             0x00000000
//                 #define SERVICE_SYSTEM_START           0x00000001
//                 #define SERVICE_AUTO_START             0x00000002
//                 #define SERVICE_DEMAND_START           0x00000003
//                 #define SERVICE_DISABLED               0x00000004
//  Scope       - <Spammer>
//  Description - Comments ????
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszStartMode = L"StartMode";

//+==========================================================================================
//  Key         - "Parameters\WaitHint"
//  Type        - REG_DWORD
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Configurable>,
//  Default     - const int DEFAULT_WAIT_HINT = 15000;
//  Unit        - milliseconds
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ??? -- was <= DEFAULT_WAIT_HINT
//  Scope       - <Spammer>
//  Description - specifies the wait hint for the service. Thus spake MSDN:
//                Specifies an estimate of the amount of time, in milliseconds, that the 
//                service expects a pending start, stop, pause, or continue operation to take 
//                before the service makes its next call to the SetServiceStatus function with 
//                either an incremented dwCheckPoint value or a change in dwCurrentState. If 
//                the amount of time specified by dwWaitHint passes, and dwCheckPoint has not 
//                been incremented, or dwCurrentState has not changed, the service control 
//                manager or service control program can assume that an error has occurred. 
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszWaitHint = L"WaitHint";

//+==========================================================================================
//  Key         - "Parameters\SleepInterval"
//  Type        - REG_DWORD
//  Created Ver - 1.1, 1.5, 2.0 ???
//  Created By  - ????
//  Attribute   - <Required>, <Configurable>, <Internal>, <Write Only>  ---- was :<Configurable>,
//  Default     - Def_???? <N/A>       
// bugbug - seems not used.
//  Unit        - Unit_???? <N/A>
//  Valid Value - Min/Max, TRUE/FALSE, <N/A> ???
//  Scope       - <Spammer>
//  Description - specifies the sleep interval for the service. If this reg key isn't present
//                5000 milliseconds is the default. It wouldn't ordinarily be necessary to change 
//                this value.
//+==========================================================================================
WCHAR *CNtServiceReg::m_pwszSleep = L"SleepInterval";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.832
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace XRLDecoder.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "8.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\XrlWrapper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.service;
using System.IO;
using System.Reflection;

namespace XRLDecoder
{
    public class XrlWrapper
    {
        private const string DateStart = "Debugger (not debuggee) time: ";
        private const string URIStart = "pszPath";
        private const string SchemaHeader = "X-Schema-Ver: ";
        private WireData _response;
        private WireData _request;
        private DateTime _date;
        private string _uri;
        private static Dictionary<string, Type> _requestObjsTypes;
        private uint _schema;
        private string _requestError = "***NULL***";

        public string RequestError
        {
            get { return _requestError; }
            set { _requestError = value; }
        }


        public uint Schema
        {
            get { return _schema; }
            set { _schema = value; }
        }


        public string URI
        {
            get { return _uri; }
            set { _uri = value; }
        }


        public DateTime Date
        {
            get { return _date; }
            set { _date = value; }
        }

        public WireData Request
        {
            get { return _request; }
            set { _request = value; }
        }


        public WireData Response
        {
            get { return _response; }
            set { _response = value; }
        }


        private static void Init()
        {
            if (_requestObjsTypes == null)
            {
                _requestObjsTypes = new Dictionary<string, Type>();
                foreach (Type type in Assembly.GetExecutingAssembly().GetTypes())
                {
                    if (type.IsSubclassOf(typeof(WireData)))
                    {
                        PropertyInfo prop = type.GetProperty("Xrl");
                        string uri = string.Empty;
                        if (prop != null)
                        {
                            object o = type.GetConstructor(Type.EmptyTypes).Invoke(null);
                            uri = (string)prop.GetValue(o, null);
                        }
                        else
                        {
                            MethodInfo meth = type.GetMethod("GetXRL");
                            if (meth != null)
                            {
                                object o = type.GetConstructor(Type.EmptyTypes).Invoke(null);
                                uri = (string)meth.Invoke(o, null);

                            }

                        }
                        if (!_requestObjsTypes.ContainsKey(uri))
                        {
                            _requestObjsTypes.Add(uri, type);
                        }

                    }
                }
            }
        }

        public XrlWrapper(StreamReader input)
        {
            Init();
            string line;
            List<byte> requestBytes = new List<byte>();
            while (!input.EndOfStream)
            {
                line = input.ReadLine().Trim();
                if (line == ">>>>>>>>>")
                {
                    continue;
                }
                else if (line == "<<<<<<<<<")
                {
                    break;
                }
                else if (line.Contains(SchemaHeader))
                {
                    string schemastr = line.Substring(line.IndexOf(SchemaHeader)+SchemaHeader.Length);
                    String[] split = schemastr.Split('.');

                    _schema = UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);

                }
                else if (line.StartsWith(DateStart))
                {
                    string datestr = line.Substring(DateStart.Length).Replace("(GMT", "UTC").Replace(")", "");
                    string[] comstr = datestr.Split(' ');
                    // Tue Nov 27 12:31:48.025 2007 (GMT-8)
                    datestr = comstr[1] + " " + comstr[2] + " " + comstr[4] + " " + comstr[3];// +" " + comstr[5];
                    _date = DateTime.Parse(datestr);
                }
                else if (line.StartsWith(URIStart))
                {
                    _uri = line.Substring(line.IndexOf('"')).Trim('"');
                }
                else
                {
                    ParseBytes(line, requestBytes);
                }
            }

            Type type;
            if (_requestObjsTypes.TryGetValue(_uri, out type))
            {
                try
                {
                    _request = type.GetConstructor(Type.EmptyTypes).Invoke(null) as WireData;
                    SetSchema(_request, _schema);
                    _request.ReadBytes(requestBytes.ToArray());
                }
                catch (Exception e)
                {
                    _request = null;
                    _requestError = e.Message;
                }
            }
        }

        private void SetSchema(WireData wireObj, uint schema) 
        {
            wireObj.SchemaVersion = schema;
            foreach (FieldInfo fi in wireObj.GetType().GetFields())
            {
                if (fi.FieldType.IsSubclassOf(typeof(WireData)) )
                {
                    SetSchema((WireData)fi.GetValue(wireObj), schema);
                }
            }
        }

        private void ParseBytes(string line, List<byte> bytes)
        {
            string byteString = line.Substring(line.IndexOf(' ')).Replace(" ", "");
            while (byteString.Contains("\""))
            {
                int index1 = byteString.IndexOf("\"");
                int index2 = byteString.IndexOf("\"", index1 + 1);
                byteString = byteString.Remove(index1, index2 - index1 + 1);
            }
            for (int i = 0; i < byteString.Length; i += 2)
            {
                bytes.Add(byte.Parse(byteString.Substring(i, 2), System.Globalization.NumberStyles.HexNumber));
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\SCommon.cpp ===
//------------------------------------------------------------------------------
// Microsoft User Profile Store
//
// File:        SCommon.cpp
//
// Copyright:    Copyright (c) 1999-2001 Microsoft Corporation
//
// Contents:    Functions definitions for SCommon for getting random numbers and 
//                miscelaneous utility functions.
//
// History:        08/29/2001    johnblac    created
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "SCommon.h"
#include "Log.h"
#include <objbase.h>
#include <crtdbg.h>
#include <winnt.h>
#include <Wincrypt.h>

// Local globals
HCRYPTPROV g_hProv = 0;        // CryptoObject for random numbers

//*****************************************************************************
//
//  GetRandomNumber generates a number between 0 and lMax returned in the 
//  pointer
//
HRESULT GetRandomNumber
(
    // [in] maximum value
    const ULONG lMax,
    // [out] pointer to random value generated
    ULONG* plRandomValue
)
{
    HRESULT hr = S_OK;

    if (plRandomValue == NULL)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    if (lMax == 0)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    if (lMax == 1)
    {
        *plRandomValue = lMax;
    }
    else
    {
        *plRandomValue = (rand() % lMax); // +1;
    }

    hr = S_OK;

Cleanup:

    return hr;

Error:
    ASSERT(SUCCEEDED(hr));
    goto Cleanup;
}


/*****************************************************************************/
BOOL GenerateRandomBytes(LPBYTE pbDestination, int cchBufLen)
{
    BOOL fSuccess = FALSE;

    Assert(pbDestination != NULL);
    if (pbDestination != NULL)
    {

        // Get handle to the default provider if we haven't already.
        if (g_hProv == 0)
        {
            if(!CryptAcquireContext(&g_hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
            {
                int iErr = GetLastError();
                
                // Do we have a keyset here?
                if (iErr == NTE_BAD_KEYSET)
                {
                    if(!CryptAcquireContext(&g_hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
                        return FALSE;
                }
            }
        }

        if (g_hProv)
            fSuccess = CryptGenRandom(g_hProv, cchBufLen, pbDestination);

    }

    return(fSuccess);
}


WCHAR* FindOneOf
//-----------------------------------------------------------------------------
//
// FindOneOf
//
// Modified version of ATL code that looks for an instance of string p1 in string p2 using only\
// WCHARs.
//
( 
    WCHAR* p1, 
    WCHAR* p2
)
{
    while (p1 != NULL && *p1 != NULL)
    {
        WCHAR* p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


void FreeCryptoContext(void)
{
    if(g_hProv)
         CryptReleaseContext(g_hProv, 0);

}

// BUGBUG -- maybe extract this out into a shared module for date conversions?
// One-based array of days in year at month start
static int rgMonthDays[13] =
    {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
    WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
    // Validate year and month (ignore day of week and milliseconds)
    if (wYear > 9999 || wMonth < 1 || wMonth > 12)
        return FALSE;

    //  Check for leap year and set the number of days in the month
    BOOL bLeapYear = ((wYear & 3) == 0) &&
        ((wYear % 100) != 0 || (wYear % 400) == 0);

    int nDaysInMonth =
        rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
        ((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

    // Finish validating the date
    if (wDay < 1 || wDay > nDaysInMonth ||
        wHour > 23 || wMinute > 59 ||
        wSecond > 59)
    {
        return FALSE;
    }

    // Cache the date in days and time in fractional days
    long nDate;
    double dblTime;

    //It is a valid date; make Jan 1, 1AD be 1
    nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
        rgMonthDays[wMonth-1] + wDay;

    //  If leap year and it's before March, subtract 1:
    if (wMonth <= 2 && bLeapYear)
        --nDate;

    //  Offset so that 12/30/1899 is 0
    nDate -= 693959L;

    dblTime = (((long)wHour * 3600L) +  // hrs in seconds
        ((long)wMinute * 60L) +  // mins in seconds
        ((long)wSecond)) / 86400.;

    dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

    return TRUE;
}


HRESULT NewGUID
//-----------------------------------------------------------------------------
//
// NewGuid
//
// Creates a new GUID
//
(
    WCHAR *pwszGUID
    // [in/out] - pointer to a buffer for the new GUID to be returned to
)
{
    int hr;
    GUID guidT;
    WCHAR *pwchFrom, *pwchTo;
    WCHAR wchT[256];

    hr = CoCreateGuid(&guidT);
    if (hr)
        return hr;

    if (!StringFromGUID2(guidT, wchT, (sizeof(wchT)/sizeof(WCHAR))-1))
        return E_FAIL;

    pwchFrom = pwchTo = wchT;
    for (; *pwchFrom; pwchFrom++)
    {
        WCHAR wch;

        wch = *pwchFrom;
        if (wch != L'-' && wch != L'{' && wch != L'}')
            *pwchTo++ = wch;
    }
    *pwchTo = 0;
    
    MyWstrcpyn(pwszGUID, wchT, (k_nGUIDSize+1));
    pwszGUID[k_nGUIDSize] = L'\0';

    return S_OK;
}


HRESULT NewPPID
//-----------------------------------------------------------------------------
//
// NewPPID
//
// Creates a new PPID
//
(
    WCHAR *pwszPPID
    // [in/out] - pointer to a buffer for the new PPID to be returned to
)
{
    int hr;
    GUID guidT;
    WCHAR *pwchFrom, *pwchTo;
    WCHAR wchT[256];

    hr = CoCreateGuid(&guidT);
    if (hr)
    {
        return hr;
    }

    if (!StringFromGUID2(guidT, wchT, (sizeof(wchT)/sizeof(WCHAR))-1))
    {
        return E_FAIL;
    }

    pwchFrom = pwchTo = wchT;
    for (; *pwchFrom; pwchFrom++)
    {
        WCHAR wch;

        wch = *pwchFrom;
        if (wch != L'-' && wch != L'{' && wch != L'}')
        {
            *pwchTo++ = wch;
        }
    }
    *pwchTo = 0;

    MyWstrcpyn(pwszPPID, wchT, (k_uiPPIDSize+1));
    pwszPPID[k_uiPPIDSize] = L'\0';

    return S_OK;
}


void SPostMessage(DWORD dwMsgType, DWORD dwMessageID, BOOL bOutputToScreen, const WCHAR *pwszFmt, ...)
{
    int     cch;
    WCHAR   wszMsg[k_uiMaxBuff] = {0};
    va_list ap;

    // format output string.
    va_start(ap, pwszFmt);
    cch = _vsnwprintf(wszMsg, sizeof(wszMsg)/sizeof(wszMsg[0])-1, pwszFmt, ap);
    va_end(ap);

    // _vsnwprintf will not add ending '\0' if the buffer is too small.
    if (cch<0)
    {
        wszMsg[sizeof(wszMsg)/sizeof(wszMsg[0])-1] = 0;
    }

    // Only print to the screen if the call requests it, and pwsz is not NULL.
    if(bOutputToScreen && wszMsg)
    {
        // Oacr warning 6053 says not to trust _vsnprintf because it doesn't always null-terminate
        // wszMsg. However, we are (now) following the best-practice outlined at
        // http://msdn.microsoft.com/en-us/library/1kt27hek(VS.80).aspx, so we are fine.
        // TobiasB
#pragma warning ( push )
#pragma warning ( disable : 6053 )
        wprintf(wszMsg);
#pragma warning ( pop )
    }

    // Only log the event if there is a non NULL message ID
    if(dwMessageID && wszMsg && dwMsgType)
    {
        // Check the Message Type for Error or Info
        if(dwMsgType == ERROR_EVENT)
        {
            LogErrorID(dwMessageID, wszMsg);
        }
        else if(dwMsgType == INFO_EVENT)
        {
            LogInfoID(dwMessageID, wszMsg);
        }    
    }
    // LogInfoID and LogErrorID also go to the debug window,
    // so we only call MyOutputDebugString if we're not calling
    // one of the above and we have a valid wszMsg
    else if (wszMsg)
    {
        MyOutputDebugString(wszMsg);
    }
}


BOOL CompareVariant
//-----------------------------------------------------------------------------
//
// CompareVariant
//
// Compare two variants.  Does not attempt to free memory
//
(
    VARIANT *pVariantOrg,    // Pointer to the variant returned by UPS
    VARIANT *pVariantCpy,    // Pointer to expectedVariatn
    BOOL    fCaseSensitive
)
{
    //Handle NULL cases...
    if(pVariantOrg==NULL || pVariantCpy==NULL)
    {
        if(pVariantOrg == pVariantCpy)
        {
            return TRUE;
        }
        return FALSE;
    }

    if (V_VT(pVariantOrg) != V_VT(pVariantCpy))
    {
        return FALSE;
    }
    
    // Return FALSE if vt is ORed with VT_RESERVED
    if (V_VT(pVariantOrg) & VT_RESERVED)
    {
        return FALSE;
    }

    // Return TRUE is the vt is VT_EMPTY or VT_NULL
    if (V_VT(pVariantOrg)==VT_EMPTY || V_VT(pVariantOrg)==VT_NULL)
    {
        return TRUE;
    }

        
    // Check if the variant is a safearray, no need to verify the corresponding DBTYPE.
    // do not free memory
    if (V_VT(pVariantOrg) & VT_ARRAY)
    {
        return CompareSafeArray(V_ARRAY(pVariantOrg), V_ARRAY(pVariantCpy));
    }

    switch(V_VT(pVariantOrg))
    {    
        case VT_UI1:
            return V_UI1(pVariantOrg) == V_UI1(pVariantCpy);

        case VT_I1:
            return V_I1(pVariantOrg) == V_I1(pVariantCpy);
        
        case VT_I2:
            return V_I2(pVariantOrg) == V_I2(pVariantCpy);

        case VT_I4:
            return V_I4(pVariantOrg) == V_I4(pVariantCpy);

        case VT_UI2:
            return V_UI2(pVariantOrg) == V_UI2(pVariantCpy);

        case VT_UI4:
            return V_UI4(pVariantOrg) == V_UI4(pVariantCpy);

        case VT_R4:
            return V_R4(pVariantOrg) == V_R4(pVariantCpy);

        case VT_DATE:    
            return     V_DATE(pVariantCpy) == V_DATE(pVariantOrg);

        case VT_R8:
             return V_R8(pVariantCpy) == V_R8(pVariantOrg);

        case VT_BOOL:
            return V_BOOL(pVariantOrg) == V_BOOL(pVariantCpy);

        case VT_ERROR:
            return V_ERROR(pVariantOrg) == V_ERROR(pVariantCpy);

        case VT_CY:
            return memcmp(&V_CY(pVariantOrg), &V_CY(pVariantCpy),sizeof(CY))==0;

        case VT_BSTR:
            if(fCaseSensitive)
            {
                if( wcslen(V_BSTR(pVariantOrg)) == wcslen(V_BSTR(pVariantCpy)))
                {
                    return wcscmp(V_BSTR(pVariantOrg), V_BSTR(pVariantCpy))==0;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                if( wcslen(V_BSTR(pVariantOrg)) == wcslen(V_BSTR(pVariantCpy)))
                {
                    return _wcsicmp(V_BSTR(pVariantOrg), V_BSTR(pVariantCpy))==0;
                }
                else
                {
                    return FALSE;
                }                
            }

        default: 
            Assert(!L"Unhandled Type!");
            return FALSE;
    }
}


BOOL CompareSafeArray
//-----------------------------------------------------------------------------
//
// CompareSafeArray
//
// Compare two safearrays
//
(
    SAFEARRAY *    psaSrc,
    SAFEARRAY *    psaDst
)
{
    // special flags that should never exist on a copied SafeArray
    const unsigned short usStaticArrayFlags = FADF_AUTO | FADF_STATIC | FADF_EMBEDDED | FADF_FIXEDSIZE;
    ULONG    cIter;

    // Can only deal with one-dimensional array.
    Assert(psaSrc->cDims == 1 && psaDst->cDims == 1);
    Assert(psaSrc->cbElements == sizeof(VARIANT));

    if( psaSrc->cbElements != psaDst->cbElements )
    {
        return FALSE;
    }

    if((psaSrc->fFeatures & (~usStaticArrayFlags)) != (psaDst->fFeatures & (~usStaticArrayFlags)) )
    {
        return FALSE;
    }

    // Copied array should have none of these bits set
    if(0 != (psaDst->fFeatures & (FADF_AUTO | FADF_STATIC | FADF_EMBEDDED | FADF_FIXEDSIZE)))
    {
        return FALSE;
    }

    if(psaSrc->rgsabound[0].cElements != psaDst->rgsabound[0].cElements)
    {
        return FALSE;
    }

    if(psaSrc->rgsabound[0].lLbound != psaDst->rgsabound[0].lLbound)
    {
        return FALSE;
    }
    
    for( cIter = 0; cIter < psaDst->rgsabound[0].cElements; cIter++ )
    {
        VARIANT *    pVariantSrc = (VARIANT *)((BYTE *)psaSrc->pvData + (cIter * psaSrc->cbElements));
        VARIANT *    pVariantDst = (VARIANT *)((BYTE *)psaDst->pvData + (cIter * psaDst->cbElements));

        if( !CompareVariant(pVariantSrc, pVariantDst, true) )
        {
            return FALSE;        
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\tools\XRLDecoder\XRLDecoder\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.832
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace XRLDecoder.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("XRLDecoder.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\stdafx.h ===
// Copyright (c) 2000-2001 Microsoft Corporation
#ifndef UPST_STDAFX_INCLUDED
#define UPST_STDAFX_INCLUDED

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <atldbcli.h>
#include <process.h>    
#include <mswsock.h>
#include <winsock.h>
#include <Lmcons.h>		// UNLEN-> size of the Username buffer

#include "stringutl.h"
#include "Constants.h"

//
// Some helpful Macros
//
#define NUMELEM(p1) (sizeof(p1) / sizeof(*p1))
#define E(exp) { hr = exp; if (FAILED(hr)) { goto Error; } }
#define ErrorTrace(hr) \
    _RPTF2( \
        _CRT_WARN, \
        "Spammer Error -- thread id: %d, hr: 0x%lx\n", \
        GetCurrentThreadId(), \
        hr)

#ifdef _DEBUG
#define ASSERT(x) if(!x){DebugBreak();}
#else
#define ASSERT(x) 1
#endif 

#define Assert(exp) _ASSERTE(exp)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_tldbroutines_none_12.4.56.0_none_8c11d56eb3219dc7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tldbroutines
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.manifest
XP_MANIFEST_PATH=manifests\x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.cat
XP_CATALOG_PATH=manifests\x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.cat
XP_PAYLOAD_PATH=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tldbroutines,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\TLDBroutines.cpp ===
//-----------------------------------------------------------------------------
// XBox Online
//
// File:			TLDBroutines.cpp
//
// Copyright:		Copyright (c) 2000-2001 Microsoft Corporation
//
// Comments: 	Routines for accessing the Tactics databases
//
// History:		9/17/2001	JohnBlac	Created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "TLDBroutines.h"

CTLDBRoutines::CTLDBRoutines()
{
}

CTLDBRoutines::~CTLDBRoutines()
{
}

CTestData::CTestData()
{
	m_nTestCase = -1;	// User defined

	m_nConfig = -1;		// 1 -Lab Machine Config
						// 2 - Personal Machine Config

	m_nMethod = -1;		// 1	Manual
						// 2	Nonlab Automated
						// 3	Lab-Ready
						// 4	Manual (Plan to Automate)
						// 5	Lab-Pending
						// 6	Lab-Review
						// 7	Under Development
						// 8	Needs Repair
	
	m_nMilestone = -1;	// 9		Beta
						// 10	M2
						// 11	M3
						// 12	RC1
						// 13	Release

	m_nStatus = -1;		// 1	Pass
						// 2	Fail
						// 3	Blocked
						// 4	Not Applicable
						// 5	Fail (Unanalyzed)

	m_nType = -1;		// 20	Accessibility
						// 21	Admin Customizations
						// 39	API/SDK
						// 11	Basic Func
						// 41	Basic Functionality
						// 15	BCT
						// 1		Boundary
						// 16	BVT
						// 2		Class
						// 43	Compat
						// 38	Context-Menu
						// 36	Dialup
						// 22	Drag / Drop
						// 5		Error Handling
						// 23	Euro Symbol
						// 18	Functionality
						// 44	GP-SIE Functionality
						// 24	Help / UE
						// 10	Integration
						// 6		International
						// 7		Interoperability
						// 17	Localization
						// 25	MSAA
						// 37	Offline
						// 19	Outsource
						// 9		Performance
						// 28	Point of Entry (ways to invoke)
						// 14	QFE
						// 29	Ratings
						// 40	Regression
						// 3		Resource Fail
						// 30	Roaming / User Profiles
						// 31	Security
						// 32	Setup
						// 12	Smoke
						// 13	Special
						// 4		Stress
						// 42	Template
						// 33	Usability / Discoverability
						// 8		User Interface
						// 34	User Scenarios
						// 35	Y2K
						
	m_nCreatedBy = -1;		// int representing your user name
	m_nModifiedBy = -1;		// int representing your user name

	memset(m_szBuild, NULL, sizeof(m_szBuild));
	memset(m_szPassNum, NULL, sizeof(m_szPassNum));
	memset(m_szComments, NULL, sizeof(m_szComments));
	
	MySnPrintf(m_szLogTable, k_ui32Buffer, "LogTbl_TestPass");	// [DEFAULT]
	
	m_nImage = 1;		// None [DEFAULT]
	m_nLocale = 1033;		// English - US [DEFAULT]
	m_nOSLoc = 1;		// English [DEFAULT]
	m_nProdLoc = 1;		// English [DEFAULT]
	m_nLanguage = 1252;	// Western [DEFAULT]
	m_nOperSys = 21;		// Win2K Advanced Server [DEFAULT]
	m_nPlatform = 15;		// Win2K [DEFAULT]
	m_nVersion = 18;		// XONLINE 1.0 [DEFAULT]
}

CTestData::~CTestData()
{

}

//=============================================================================
//CTLDBroutines::Init
//
//Initialize the DataSource and Session objects for upst_sys and all the 
//physical partitions;
//=============================================================================
HRESULT CTLDBRoutines::Init()
{
	HRESULT	hr = S_OK;

	//Initialize the DataSource and Session object for upst_sys database
	if( FAILED(hr = m_DataSource.OpenFromInitializationString(g_wszConnectString)))
	{
		wprintf(L"TLCDbRoutine: OpenFromInitializationString %s failed with hr = 0x%x", g_wszConnectString, hr);
		goto Error;
	}

	// Get the session
	if( FAILED(hr = m_SysSess.Open(m_DataSource)) )
	{
		wprintf(L"TLCDbRoutine: Sess.Open failed with hr = 0x%x", hr);
		goto Error;		
	}

Error:	
	return hr;
}


//=============================================================================
// CTLDBroutines::AddTestCase
//
// The TestData structure that is passed to this funciton is verified for valid content and then submitted to the Tactics 
// database.
//
//=============================================================================
HRESULT CTLDBRoutines::AddTestResult
(
	// [in] TestInfo data should be filled out for the query to submit this data
	CTestData *pTestData,
	// [in] This method will look up the user name and assign the modified by tags accordingly so the user
	//       doesn't have to know his or her ID
	WCHAR *pwszUserName
)
{
	USES_CONVERSION;
	HRESULT					hr;
	CCommandStoredProc		CmdAddTestInfo;
	CCommandUserID			CmdGetUserID;

	// Buffer for the SQL query
	WCHAR wszQuery[k_uiSQLQueryLength];
	char szErrorMsg[k_ui32Buffer];

	// Get User ID.  If no UserName is supplied, then the member variables for the CTestData class
	// are used instead
	if(pwszUserName && *pwszUserName != L'\0')
	{
		// Create the query
		MywSnPrintf( wszQuery, k_uiSQLQueryLength, g_wszGetUserID, pwszUserName);
		// Execute the command
		hr = CmdGetUserID.Open( m_SysSess, wszQuery );
		if ( FAILED(hr) )
		{
			wprintf(L"Failed to get UserID for the user %s\n", pwszUserName); 
			goto Cleanup;
		}
		// Fetch the row.  It should only be one.
		if((hr = CmdGetUserID.MoveNext()) == S_OK)
		{
			// I set both the created and modified by tags here.  This will only 
			// affect the log entries for a test, not the original test itself.
			pTestData->m_nCreatedBy = CmdGetUserID.nUserID;
			pTestData->m_nModifiedBy = CmdGetUserID.nUserID;
		}
		else
		{
			wprintf(L"User %s does not exist in the Tactics database.\n", pwszUserName);
			goto Cleanup;
		}
	}

	// Verify validity of data
	hr = VerifyTestData(pTestData, szErrorMsg);
	if(FAILED(hr))
	{
		printf("Input data invalid: Error was in %s\n", szErrorMsg);
		hr =  E_INVALIDARG;
		goto Cleanup;
	}

	//
	// *********** TEST INFO ***********
	//
	// Create the stored procedure query based on the inputs in pTestData
	MywSnPrintf( wszQuery, k_uiSQLQueryLength, 
			g_wszAddLogToTest,
			A2W(pTestData->m_szLogTable),
			pTestData->m_nTestCase,
			pTestData->m_nConfig,
			pTestData->m_nLanguage,
			pTestData->m_nMethod,
			pTestData->m_nMilestone,
			pTestData->m_nOperSys,
			pTestData->m_nPlatform,
			pTestData->m_nStatus,
			pTestData->m_nType,
			pTestData->m_nVersion,
			pTestData->m_nCreatedBy,
			pTestData->m_nModifiedBy,
			A2W(pTestData->m_szBuild),
			A2W(pTestData->m_szPassNum),
			pTestData->m_nImage,
			A2W(pTestData->m_szComments),
			pTestData->m_nLocale,
			pTestData->m_nOSLoc,
			pTestData->m_nProdLoc
	);

	// Execute the query
	hr = CmdAddTestInfo.Open( m_SysSess, wszQuery );
	if ( FAILED(hr) )
	{
		wprintf(L"Failed to submit the test data for test case %d", pTestData->m_nTestCase); 
		goto Cleanup;
	}
		
Cleanup:
	// Close the command
	CmdAddTestInfo.Close();
	CmdGetUserID.Close();
	
	return hr;
}


//=============================================================================
// CTLDBroutines::GetTestData
//
// The TestData structure that is passed to this funciton receives the info associated with the testID that is filled out in
// the structure.
//
//=============================================================================
HRESULT CTLDBRoutines::GetTestData
(
	// [in\out] TestRow data should have just the test ID filled out.  The rest will be filled out by the function
	TestRow *pTestInfo
)
{
	USES_CONVERSION;
	HRESULT					hr;
	CCommandGetDataProc	CmdGetTestData;

	// Buffer for the SQL query
	WCHAR wszQuery[k_uiSQLQueryLength];
	ZeroMemory(wszQuery, k_uiSQLQueryLength);
	ZeroMemory(wszQuery, k_ui32Buffer);

	//
	// *********** TEST INFO ***********
	//
	// Create the stored procedure query based on the inputs in pTestData
	MywSnPrintf( wszQuery, k_uiSQLQueryLength, 
			g_wszGetTestCase,
			pTestInfo->nTestCase);

	// Execute the query
	hr = CmdGetTestData.Open( m_SysSess, wszQuery );
	if ( FAILED(hr) )
	{
		wprintf(L"Failed to fetch the test data for test case %d", pTestInfo->nTestCase); 
		goto Cleanup;
	}
	// Fetch the row.  It should only be one.
	if((hr = CmdGetTestData.MoveNext()) == S_OK)
	{
		memcpy(pTestInfo->szTitle, &CmdGetTestData.szTitle, k_ui255Buffer);
		memcpy(pTestInfo->szDescription, &CmdGetTestData.szDescription, k_ui128Buffer);
		memcpy(pTestInfo->szURL, &CmdGetTestData.szURL, k_ui255Buffer);
		memcpy(pTestInfo->szChangeHistory, &CmdGetTestData.szChangeHistory, k_ui2000Buffer);
	}
	else
	{
		wprintf(L"Test case %d does not exist in the Tactics database.\n", pTestInfo->nTestCase);
		goto Cleanup;
	}
	
Cleanup:
	// Close the command
	CmdGetTestData.Close();
	
	return hr;
}

//=============================================================================
// CTLDBroutines::VerifyTestData
//
// This function checks the submitted test data for valid numerical content and also checks the build string for proper 
// formatting
//
//=============================================================================
HRESULT CTLDBRoutines::VerifyTestData
(
	// [in] TestInfo data should be filled out for the query to submit this data
	CTestData *pTestData,
	// [out] Copies an error message of length k_ui32Buffer or less.
	char* pszErrorMsg
)
{
	Mystrcpyn(pszErrorMsg, "OK", k_ui32Buffer);

	// Test Cases should be positive
	if(pTestData->m_nTestCase < 1)
	{
		Mystrcpyn(pszErrorMsg, "m_nTestCase", k_ui32Buffer);	
		goto Error;
	}

	// Restricts configuration values to those in the database
	if(pTestData->m_nConfig < k_nConfigMin || pTestData->m_nConfig > k_nConfigMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nConfig", k_ui32Buffer);	
		goto Error;
	}

	// Restricts language values to those in the database
	if(pTestData->m_nLanguage < k_nLanguageMin || pTestData->m_nLanguage > k_nLanguageMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nLanguage", k_ui32Buffer);	
		goto Error;
	}

	// Restricts method values to those in the database
	if(pTestData->m_nMethod < k_nMethodMin || pTestData->m_nMethod > k_nMethodMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nMethod", k_ui32Buffer);	
		goto Error;
	}	

	// Restricts milestone values to those in the database
	if(pTestData->m_nMilestone < k_nMileStoneMin || pTestData->m_nMilestone > k_nMileStoneMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nMilestone", k_ui32Buffer);	
		goto Error;
	}

	// Restricts operating system values to those in the database
	if(pTestData->m_nOperSys < k_nOperSysMin || pTestData->m_nOperSys > k_nOperSysMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nOperSys", k_ui32Buffer);	
		goto Error;
	}	

	// Restricts platform values to those in the database
	if(pTestData->m_nPlatform < k_nPlatformMin || pTestData->m_nPlatform > k_nPlatformMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nPlatform", k_ui32Buffer);	
		goto Error;
	}

	// Restricts status values to those in the database
	if(pTestData->m_nStatus < k_nStatusMin || pTestData->m_nStatus > k_nStatusMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nStatus", k_ui32Buffer);	
		goto Error;
	}	

	// Restricts type values to those in the database
	if(pTestData->m_nType < k_nTypeMin || 
	   pTestData->m_nType > k_nTypeMax || 
	   pTestData->m_nType == 26 || 
	   pTestData->m_nType == 27)
	{
		Mystrcpyn(pszErrorMsg, "m_nType", k_ui32Buffer);	
		goto Error;
	}	
	
	// Restricts version values to those in the database
	if(pTestData->m_nVersion < k_nVersionMin || pTestData->m_nVersion > k_nVersionMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nVersion", k_ui32Buffer);	
		goto Error;
	}

	// Tester IDs are always positive
	if(pTestData->m_nCreatedBy < 1)
	{
		Mystrcpyn(pszErrorMsg, "m_nCreatedBy", k_ui32Buffer);	
		goto Error;
	}

	// Tester IDs are always positive
	if(pTestData->m_nModifiedBy < 1)
	{
		Mystrcpyn(pszErrorMsg, "m_nModifiedBy", k_ui32Buffer);	
		goto Error;
	}

	// Restricts Image values to those in the database
	if(pTestData->m_nImage < k_nImageMin || pTestData->m_nImage > k_nImageMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nImage", k_ui32Buffer);
		goto Error;
	}

	// Restricts locale values to those in the database
	if(pTestData->m_nLocale < k_nLocalMin || pTestData->m_nLocale > k_nLocalMax )
	{
		Mystrcpyn(pszErrorMsg, "m_nLocale", k_ui32Buffer);
		goto Error;
	}

	// Restricts OS Location values to those in the database
	if(pTestData->m_nOSLoc < k_nLocMin || pTestData->m_nOSLoc > k_nLocMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nOSLoc", k_ui32Buffer);
		goto Error;
	}

	// Restricts Product Location values to those in the database
	if(pTestData->m_nProdLoc < k_nLocMin || pTestData->m_nProdLoc > k_nLocMax)
	{
		Mystrcpyn(pszErrorMsg, "m_nProdLoc", k_ui32Buffer);
		goto Error;
	}

	// The Log table should always be this value.
	if(strcmp(pTestData->m_szLogTable, "LogTbl_TestPass"))
	{
		Mystrcpyn(pszErrorMsg, "m_szLogTable", k_ui32Buffer);
		goto Error;
	}

	// Build versions should always be xxxx.xxxxxx
	if(strlen(pTestData->m_szBuild) != 11)
	{
		Mystrcpyn(pszErrorMsg, "m_szBuild is wrong length", k_ui32Buffer);
		goto Error;
	}
	// The 5th character should always be .
	if(pTestData->m_szBuild[4] != '.')
	{
		Mystrcpyn(pszErrorMsg, "m_szBuild is wrong format", k_ui32Buffer);
		goto Error;
	}

	// The pass number should have something in it
	if(pTestData->m_szPassNum == '\0')
	{
		Mystrcpyn(pszErrorMsg, "m_szPassNum is empty", k_ui32Buffer);
		goto Error;
	}
	
	// m_szComments is optional, so we don't care.
	
	return S_OK;
Error:
	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_tldbroutines_none_12.4.56.0_none_8c11d56eb3219dc7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tldbroutines
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.manifest
XP_MANIFEST_PATH=manifests\x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.cat
XP_CATALOG_PATH=manifests\x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b.cat
XP_PAYLOAD_PATH=x86_tldbroutines_no-public-key_12.4.56.0_x-ww_3318657b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tldbroutines,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\util\stringutl.cpp ===
//-----------------------------------------------------------------------------
// File:			stringutl.cpp
//
// Copyright:		Copyright (c) 1999-2001 Microsoft Corporation
//
// Comments: 		Shared string utilities for xonline
//
// Author:			johnk in Investor, adapted for XBox Online by johnblac
//
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "stringutl.h"

// lstrcpyn for wide characters. It writes into a buffer of size cchMax
// and guarantees the copied string to be null-terminated.
void MyWstrcpyn(WCHAR *wszTarget, const WCHAR *wszSource, int cchMax)
{
	if (cchMax > 0)
	{
		wcsncpy(wszTarget, wszSource, cchMax-1);
		wszTarget[cchMax-1] = 0;
	}
}

// strncpy, but with lstrcpyn semantics, namely
// cchMax includes the zero, and the zero is always
// written.
char *MyStrNCpy(char *szDest, const char *szSrc, int cchMax)
{
	int cch;
	const char *pch;

	if (cchMax <= 0)
		return szDest;

	pch = szSrc;
	for (cch=0; ; cch++)
		{
		if (cch == cchMax-1)
			break;
		if (!*pch++)
			break;
		}

	MoveMemory(szDest, szSrc, cch);
	szDest[cch] = 0;

	return szDest;
}

// lstrcpyn but without the locale overhead. It writes into a buffer of size cchMax
// and guarantees the copied string to be null-terminated.
void Mystrcpyn(char *szTarget, const char *szSource, int cchMax)
{
	strncpy(szTarget, szSource, cchMax-1);
	szTarget[cchMax-1] = 0;
}

// _snprintf, but guarantees zero is written
// cchBuf includes space for zero
int MywSnPrintf(WCHAR *wszBuf, int cchBuf, const WCHAR *wszFormat, ...)
{
	int cch;
	va_list ap;

	if (cchBuf<=0)
		return -1;

	va_start(ap, wszFormat);
	cch = _vsnwprintf(wszBuf, cchBuf-1, wszFormat, ap);
	va_end(ap);

	if (cch<0 || cch == cchBuf-1) // if the buffer was too short or we exactly filled it up, except for the zero...
		wszBuf[cchBuf-1] = 0;

	return cch;
}

// _snprintf, but guarantees zero is written
// cchBuf includes space for zero
int MySnPrintf(char *szBuf, int cchBuf, char *szFormat, ...)
{
	int cch;
	va_list ap;

	if (cchBuf<=0)
		return -1;

	va_start(ap, szFormat);
	cch = _vsnprintf(szBuf, cchBuf-1, szFormat, ap);
	va_end(ap);

	if (cch<0 || cch == cchBuf-1) // if the buffer was too short or we exactly filled it up, except for the zero...
		szBuf[cchBuf-1] = 0;

	return cch;
}


BOOL StrCatMaxLen(WCHAR *wszTarget, const WCHAR *wszAppend, int cchMax)
{
	if ((int)(wcslen(wszTarget) + wcslen(wszAppend)) < cchMax)
	{
		wcscat(wszTarget, wszAppend);
		return TRUE;
	}
	else
	{
		// Trying to write past the end of a buffer.
		return FALSE;
	}
}

// Convert a null-terminated sz into a wsz, guaranteeing null termination of the wsz
WCHAR *SZ_TO_WSZ(char *sz, WCHAR *wsz, int cchWszBufLen)
{
	MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cchWszBufLen);
	wsz[cchWszBufLen] = 0;
	return wsz;
}

// Convert a null-terminated wsz into an sz, guaranteeing null termination of the sz
char *WSZ_TO_SZ(WCHAR *wsz, char *sz, int cchSzBufLen)
{
	WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cchSzBufLen, NULL, NULL);
	sz[cchSzBufLen] = 0;
	return sz;
}

// Strips the cStrip TCHAR from szIn, copying output to szOut. If szOut is null, 
// the output is copied directly back to szIn.
void StripChar(WCHAR *wszIn, WCHAR *wszOut, WCHAR cStrip)
{
	WCHAR *p = wszIn;
	WCHAR *q;
	
	if (wszOut)
		q = wszOut;
	else
		q = wszIn;

	while (*p)
	{
		if (*p != cStrip)
			*q++ = *p;
		p++;
	}
	*q = 0;
}

int Between(int iValue, int iLow, int iHigh)
{
	int iReturn = max(iValue, iLow);
	iReturn = min(iReturn, iHigh);
	return iReturn;
}

//-----------------------------------------------------------------------------
// QuoteEscape
//
// Scan wszIn doubling up any single quotes that aren't already doubled
//-----------------------------------------------------------------------------
void QuoteEscape(WCHAR *wszIn, WCHAR *wszOut, int cchMaxLen)
{
	WCHAR *p = wszIn;
	WCHAR *q = wszOut;
	WCHAR *qMax = wszOut + cchMaxLen - 1;	// the last byte we can write to

	if (!p || !q)
		return;
		
	while (*p)
	{
		if (*p == L'\'')
		{
			if (*(p+1) != L'\'')	// safe at end of string because of the null
			{
				// Found an undoubled single quote
				if (q < qMax-2)
				{
					*q++ = *p++;			// copy the quote
					*q++ = L'\'';			// add another one
				}
			}
			else
			{
				if (q < qMax - 2)
				{
					// Found an already doubled single quote. Copy them both.
					*q++ = *p++;
					*q++ = *p++;
				}
			}
		}
		else
		{
			if (q < qMax - 1)
				*q++ = *p++;		// copy some non-quote character
		}
	}
	
	if (q <= qMax)
		*q = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\makefile.inc ===
!include $(INETROOT)\build\makefile.inc


!include $(BASEDIR)\private\test\common\wshelper\makefile.dep
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\CertPW.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace VerifyPartner
{
	/// <summary>
	/// Summary description for CertPW.
	/// </summary>
	public class CertPW : System.Windows.Forms.Form
	{
		public System.Windows.Forms.TextBox PW;
		private System.Windows.Forms.Label label1;
		public System.Windows.Forms.Label FileName;
		private System.Windows.Forms.Button OK;
		private System.Windows.Forms.Button Cancel;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public CertPW()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.PW = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.FileName = new System.Windows.Forms.Label();
			this.OK = new System.Windows.Forms.Button();
			this.Cancel = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// PW
			// 
			this.PW.Location = new System.Drawing.Point(96, 48);
			this.PW.Name = "PW";
			this.PW.PasswordChar = '*';
			this.PW.Size = new System.Drawing.Size(160, 20);
			this.PW.TabIndex = 0;
			this.PW.Text = "";
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(40, 48);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(57, 16);
			this.label1.TabIndex = 1;
			this.label1.Text = "Password:";
			// 
			// FileName
			// 
			this.FileName.AutoSize = true;
			this.FileName.Location = new System.Drawing.Point(16, 16);
			this.FileName.Name = "FileName";
			this.FileName.Size = new System.Drawing.Size(151, 16);
			this.FileName.TabIndex = 2;
			this.FileName.Text = "Please enter a password for: ";
			// 
			// OK
			// 
			this.OK.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.OK.Location = new System.Drawing.Point(296, 16);
			this.OK.Name = "OK";
			this.OK.Size = new System.Drawing.Size(72, 24);
			this.OK.TabIndex = 3;
			this.OK.Text = "OK";
			this.OK.Click += new System.EventHandler(this.OK_Click);
			// 
			// Cancel
			// 
			this.Cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.Cancel.Location = new System.Drawing.Point(296, 48);
			this.Cancel.Name = "Cancel";
			this.Cancel.Size = new System.Drawing.Size(72, 24);
			this.Cancel.TabIndex = 4;
			this.Cancel.Text = "Cancel";
			this.Cancel.Click += new System.EventHandler(this.Cancel_Click);
			// 
			// CertPW
			// 
			this.AcceptButton = this.OK;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.Cancel;
			this.ClientSize = new System.Drawing.Size(384, 87);
			this.ControlBox = false;
			this.Controls.Add(this.Cancel);
			this.Controls.Add(this.OK);
			this.Controls.Add(this.FileName);
			this.Controls.Add(this.PW);
			this.Controls.Add(this.label1);
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "CertPW";
			this.ShowInTaskbar = false;
			this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Please enter a password";
			this.Load += new System.EventHandler(this.CertPW_Load);
			this.ResumeLayout(false);

		}
		#endregion

		private void CertPW_Load(object sender, System.EventArgs e)
		{
		
		}

		private void OK_Click(object sender, System.EventArgs e)
		{
			this.DialogResult = DialogResult.OK;
			this.Close();
		}

		private void Cancel_Click(object sender, System.EventArgs e)
		{
			this.DialogResult = DialogResult.Cancel;
			this.Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\Progress.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace VerifyPartner
{
	/// <summary>
	/// Summary description for Progress.
	/// </summary>
	public class Progress : System.Windows.Forms.Form
	{
		public System.Windows.Forms.ProgressBar pbar;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Progress()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.pbar = new System.Windows.Forms.ProgressBar();
			this.SuspendLayout();
			// 
			// pbar
			// 
			this.pbar.Location = new System.Drawing.Point(16, 16);
			this.pbar.Name = "pbar";
			this.pbar.Size = new System.Drawing.Size(240, 16);
			this.pbar.TabIndex = 0;
			// 
			// Progress
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(272, 47);
			this.ControlBox = false;
			this.Controls.Add(this.pbar);
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "Progress";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Progress";
			this.ResumeLayout(false);

		}
		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\PartnerVerifier.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using CAPICOM;
using WSHelper;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.IO;
using System.Text;
using System.Diagnostics;

namespace VerifyPartner
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	/// 
	public class PVForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button LoadCert;
		private System.Windows.Forms.Button RunTests;

		private CAPICOM.Store certStore = null;
		private CAPICOM.ICertificate2 cert = null;
		private bool fDeleteLoadedCert = true;
		private System.Windows.Forms.ComboBox HostEnvs;
		private System.Windows.Forms.Label label7;
		private System.Drawing.Point pt = new Point(0, 0);
		private Progress prog = new Progress();
		private System.Windows.Forms.Button SelectCert;
		private System.Windows.Forms.TabPage tabAllowedAPIs;
		private System.Windows.Forms.ListBox AllowedAPIs;
		private System.Windows.Forms.TabPage tabAllowedTitles;
		private System.Windows.Forms.TabPage tabDeniedAPIs;
		private System.Windows.Forms.TabPage tabFailedAPIs;
		private System.Windows.Forms.ListBox DeniedAPIs;
		private System.Windows.Forms.ListBox FailedAPIs;
		private System.Windows.Forms.TabControl tabControl;

		string [] HostVersion = new string [] {"All", "All", "All", "All", "All", "All"};
		string [] HostNames = new string [] {"192.168.86.51", "131.107.60.22", "websvc.part.xboxlive.com", "websvc.xboxlive.com", "websvc.gsrv.xboxlive.com", "131.107.58.35"};
		string [] HostStrings = new string [] {"TestNet (Tsunami SP1)", "CertNet (Tsunami SP1)", "PartnerNet (Tsunami SP1)", "Production (Tsunami SP1)", "GameServerNet (Tsunami SP1)", "PreProduction (Tsunami SP1)"};
		private System.Windows.Forms.Button Report;
		private System.Windows.Forms.ListView AllowedTitles;
		private System.Windows.Forms.ColumnHeader TitleID;
		private System.Windows.Forms.ColumnHeader Permissions;
		private System.Windows.Forms.ColumnHeader TitleName;

		private PassState ps = new PassState();
		private System.Windows.Forms.TextBox txtTitleID;
		private System.Windows.Forms.Label label1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		
		public PVForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			foreach(string s in HostStrings)
				HostEnvs.Items.Add(s);
			HostEnvs.SelectedIndex = 2;
			ResetTabs();
			Report.Enabled = false;
			RunTests.Enabled = false;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			if(cert != null && fDeleteLoadedCert)
			{
				certStore.Remove(cert);
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.LoadCert = new System.Windows.Forms.Button();
			this.RunTests = new System.Windows.Forms.Button();
			this.HostEnvs = new System.Windows.Forms.ComboBox();
			this.label7 = new System.Windows.Forms.Label();
			this.SelectCert = new System.Windows.Forms.Button();
			this.tabControl = new System.Windows.Forms.TabControl();
			this.tabAllowedAPIs = new System.Windows.Forms.TabPage();
			this.AllowedAPIs = new System.Windows.Forms.ListBox();
			this.tabAllowedTitles = new System.Windows.Forms.TabPage();
			this.AllowedTitles = new System.Windows.Forms.ListView();
			this.TitleID = new System.Windows.Forms.ColumnHeader();
			this.Permissions = new System.Windows.Forms.ColumnHeader();
			this.TitleName = new System.Windows.Forms.ColumnHeader();
			this.tabDeniedAPIs = new System.Windows.Forms.TabPage();
			this.DeniedAPIs = new System.Windows.Forms.ListBox();
			this.tabFailedAPIs = new System.Windows.Forms.TabPage();
			this.FailedAPIs = new System.Windows.Forms.ListBox();
			this.Report = new System.Windows.Forms.Button();
			this.txtTitleID = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.tabControl.SuspendLayout();
			this.tabAllowedAPIs.SuspendLayout();
			this.tabAllowedTitles.SuspendLayout();
			this.tabDeniedAPIs.SuspendLayout();
			this.tabFailedAPIs.SuspendLayout();
			this.SuspendLayout();
			// 
			// LoadCert
			// 
			this.LoadCert.Location = new System.Drawing.Point(159, 360);
			this.LoadCert.Name = "LoadCert";
			this.LoadCert.Size = new System.Drawing.Size(68, 24);
			this.LoadCert.TabIndex = 7;
			this.LoadCert.Text = "Load Cert";
			this.LoadCert.Click += new System.EventHandler(this.LoadCert_Click);
			// 
			// RunTests
			// 
			this.RunTests.Location = new System.Drawing.Point(239, 360);
			this.RunTests.Name = "RunTests";
			this.RunTests.Size = new System.Drawing.Size(68, 24);
			this.RunTests.TabIndex = 8;
			this.RunTests.Text = "Run Tests";
			this.RunTests.Click += new System.EventHandler(this.RunTests_Click);
			// 
			// HostEnvs
			// 
			this.HostEnvs.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.HostEnvs.Location = new System.Drawing.Point(88, 24);
			this.HostEnvs.Name = "HostEnvs";
			this.HostEnvs.Size = new System.Drawing.Size(248, 21);
			this.HostEnvs.TabIndex = 1;
			// 
			// label7
			// 
			this.label7.Location = new System.Drawing.Point(8, 24);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(80, 16);
			this.label7.TabIndex = 22;
			this.label7.Text = "Environments:";
			this.label7.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// SelectCert
			// 
			this.SelectCert.Location = new System.Drawing.Point(79, 360);
			this.SelectCert.Name = "SelectCert";
			this.SelectCert.Size = new System.Drawing.Size(68, 24);
			this.SelectCert.TabIndex = 23;
			this.SelectCert.Text = "Select Cert";
			this.SelectCert.Click += new System.EventHandler(this.SelectCert_Click);
			// 
			// tabControl
			// 
			this.tabControl.Controls.Add(this.tabAllowedAPIs);
			this.tabControl.Controls.Add(this.tabAllowedTitles);
			this.tabControl.Controls.Add(this.tabDeniedAPIs);
			this.tabControl.Controls.Add(this.tabFailedAPIs);
			this.tabControl.Location = new System.Drawing.Point(16, 56);
			this.tabControl.Name = "tabControl";
			this.tabControl.SelectedIndex = 0;
			this.tabControl.Size = new System.Drawing.Size(432, 288);
			this.tabControl.TabIndex = 26;
			// 
			// tabAllowedAPIs
			// 
			this.tabAllowedAPIs.Controls.Add(this.AllowedAPIs);
			this.tabAllowedAPIs.Location = new System.Drawing.Point(4, 22);
			this.tabAllowedAPIs.Name = "tabAllowedAPIs";
			this.tabAllowedAPIs.Size = new System.Drawing.Size(424, 262);
			this.tabAllowedAPIs.TabIndex = 0;
			this.tabAllowedAPIs.Text = "Allowed APIs";
			// 
			// AllowedAPIs
			// 
			this.AllowedAPIs.HorizontalScrollbar = true;
			this.AllowedAPIs.Location = new System.Drawing.Point(0, 0);
			this.AllowedAPIs.Name = "AllowedAPIs";
			this.AllowedAPIs.Size = new System.Drawing.Size(424, 264);
			this.AllowedAPIs.Sorted = true;
			this.AllowedAPIs.TabIndex = 11;
			// 
			// tabAllowedTitles
			// 
			this.tabAllowedTitles.Controls.Add(this.AllowedTitles);
			this.tabAllowedTitles.Location = new System.Drawing.Point(4, 22);
			this.tabAllowedTitles.Name = "tabAllowedTitles";
			this.tabAllowedTitles.Size = new System.Drawing.Size(424, 262);
			this.tabAllowedTitles.TabIndex = 1;
			this.tabAllowedTitles.Text = "Allowed Titles";
			// 
			// AllowedTitles
			// 
			this.AllowedTitles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																							this.TitleID,
																							this.Permissions,
																							this.TitleName});
			this.AllowedTitles.FullRowSelect = true;
			this.AllowedTitles.Location = new System.Drawing.Point(0, 0);
			this.AllowedTitles.Name = "AllowedTitles";
			this.AllowedTitles.Size = new System.Drawing.Size(424, 264);
			this.AllowedTitles.Sorting = System.Windows.Forms.SortOrder.Ascending;
			this.AllowedTitles.TabIndex = 0;
			this.AllowedTitles.View = System.Windows.Forms.View.Details;
			// 
			// TitleID
			// 
			this.TitleID.Text = "TitleID";
			this.TitleID.Width = 80;
			// 
			// Permissions
			// 
			this.Permissions.Text = "Permissions";
			this.Permissions.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.Permissions.Width = 80;
			// 
			// TitleName
			// 
			this.TitleName.Text = "TitleName";
			this.TitleName.Width = 240;
			// 
			// tabDeniedAPIs
			// 
			this.tabDeniedAPIs.Controls.Add(this.DeniedAPIs);
			this.tabDeniedAPIs.Location = new System.Drawing.Point(4, 22);
			this.tabDeniedAPIs.Name = "tabDeniedAPIs";
			this.tabDeniedAPIs.Size = new System.Drawing.Size(424, 262);
			this.tabDeniedAPIs.TabIndex = 2;
			this.tabDeniedAPIs.Text = "Denied APIs";
			// 
			// DeniedAPIs
			// 
			this.DeniedAPIs.HorizontalScrollbar = true;
			this.DeniedAPIs.Location = new System.Drawing.Point(0, 0);
			this.DeniedAPIs.Name = "DeniedAPIs";
			this.DeniedAPIs.Size = new System.Drawing.Size(424, 264);
			this.DeniedAPIs.Sorted = true;
			this.DeniedAPIs.TabIndex = 12;
			// 
			// tabFailedAPIs
			// 
			this.tabFailedAPIs.Controls.Add(this.FailedAPIs);
			this.tabFailedAPIs.Location = new System.Drawing.Point(4, 22);
			this.tabFailedAPIs.Name = "tabFailedAPIs";
			this.tabFailedAPIs.Size = new System.Drawing.Size(424, 262);
			this.tabFailedAPIs.TabIndex = 3;
			this.tabFailedAPIs.Text = "Failed APIs";
			// 
			// FailedAPIs
			// 
			this.FailedAPIs.HorizontalScrollbar = true;
			this.FailedAPIs.Location = new System.Drawing.Point(0, 0);
			this.FailedAPIs.Name = "FailedAPIs";
			this.FailedAPIs.Size = new System.Drawing.Size(424, 264);
			this.FailedAPIs.Sorted = true;
			this.FailedAPIs.TabIndex = 26;
			// 
			// Report
			// 
			this.Report.Location = new System.Drawing.Point(319, 360);
			this.Report.Name = "Report";
			this.Report.Size = new System.Drawing.Size(68, 24);
			this.Report.TabIndex = 27;
			this.Report.Text = "Report";
			this.Report.Click += new System.EventHandler(this.Report_Click);
			// 
			// txtTitleID
			// 
			this.txtTitleID.Location = new System.Drawing.Point(384, 24);
			this.txtTitleID.Name = "txtTitleID";
			this.txtTitleID.Size = new System.Drawing.Size(64, 20);
			this.txtTitleID.TabIndex = 28;
			this.txtTitleID.Text = "0";
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(344, 24);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(40, 16);
			this.label1.TabIndex = 29;
			this.label1.Text = "TitleID:";
			this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// PVForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(466, 399);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.txtTitleID);
			this.Controls.Add(this.Report);
			this.Controls.Add(this.tabControl);
			this.Controls.Add(this.SelectCert);
			this.Controls.Add(this.label7);
			this.Controls.Add(this.HostEnvs);
			this.Controls.Add(this.RunTests);
			this.Controls.Add(this.LoadCert);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.Name = "PVForm";
			this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "Partner Verification Tool";
			this.tabControl.ResumeLayout(false);
			this.tabAllowedAPIs.ResumeLayout(false);
			this.tabAllowedTitles.ResumeLayout(false);
			this.tabDeniedAPIs.ResumeLayout(false);
			this.tabFailedAPIs.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new PVForm());
		}

		void ResetTabs()
		{
			AllowedAPIs.Items.Clear();
			DeniedAPIs.Items.Clear();
			AllowedTitles.Items.Clear();
			FailedAPIs.Items.Clear();
			tabAllowedAPIs.Text = "Allowed APIs (0)";
			tabAllowedTitles.Text = "Allowed Titles (0)";
			tabDeniedAPIs.Text = "Denied APIs (0)";
			tabFailedAPIs.Text = "Failed APIs (0)";
		}

		public static bool SameCertificate(ICertificate2 lhs, ICertificate2 rhs)
		{
			return lhs.PrivateKey.ProviderName == rhs.PrivateKey.ProviderName && lhs.SerialNumber == rhs.SerialNumber && 
				lhs.Thumbprint == rhs.Thumbprint && lhs.ValidFromDate == rhs.ValidFromDate && 
				lhs.ValidToDate == rhs.ValidToDate && lhs.Version == rhs.Version &&
				lhs.IssuerName == rhs.IssuerName && lhs.SubjectName == rhs.SubjectName;
		}

		private void LoadCertificate()
		{
			string password = null;
			bool fAdded = false;
			int count = 0;
			System.Windows.Forms.OpenFileDialog ofd = new OpenFileDialog();
			ofd.DefaultExt = "pfx";
			ofd.Filter = "Certificate Files (*.pfx)|*.pfx";
			ofd.Title = "Select a Certificate File";
			if(ofd.ShowDialog(this) != DialogResult.OK)
				return;

			RunTests.Enabled = false;
			ResetTabs();
			while(true)
			{
				if(cert != null && fDeleteLoadedCert)
				{
					certStore.Remove(cert);
				}
				cert = null;

				try
				{
					count++;
					this.Text =  "Partner Verification Tool";

					fDeleteLoadedCert = true;
					cert = new CAPICOM.CertificateClass();
					cert.Load(ofd.FileName, password, CAPICOM_KEY_STORAGE_FLAG.CAPICOM_KEY_STORAGE_EXPORTABLE, 
									CAPICOM_KEY_LOCATION.CAPICOM_CURRENT_USER_KEY);

					if(certStore == null)
					{
						certStore = new CAPICOM.StoreClass();
						certStore.Open(CAPICOM_STORE_LOCATION.CAPICOM_CURRENT_USER_STORE, "My", CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_READ_WRITE | CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_EXISTING_ONLY);
					}
					CAPICOM.Certificates certs = (CAPICOM.Certificates) certStore.Certificates;
					if(certs != null)
					{
						foreach(CAPICOM.ICertificate2 c in certs)
						{
							if(SameCertificate(c, cert))
							{
								fDeleteLoadedCert = false;
								break;
							}
						}
					}

					certStore.Add(cert);
					fAdded = true;
					this.Text =  "Partner Verification Tool - " + Helpers.CertificateCN(cert.SubjectName);
					Report.Enabled = false;
					RunTests.Enabled = true;
					return;
				}
				catch(System.Exception f)
				{
					if(!fAdded)
						cert = null;
					else if(fDeleteLoadedCert)
					{
						certStore.Remove(cert);
						cert = null;
					}
					fAdded = false;
					if(count > 3)
					{
						MessageBox.Show(this, "Failed to load the certificate.");
						return;
					}
					if(f.GetType() == typeof(System.Runtime.InteropServices.COMException))
					{
						System.Runtime.InteropServices.COMException com = (System.Runtime.InteropServices.COMException) f;
						if( (uint) com.ErrorCode == (uint) 0x80070056)
						{
							CertPW cpw = new CertPW();
							int idx = ofd.FileName.LastIndexOf(@"\");
							idx = (idx > -1) ? idx + 1 : 0;
							string fn = ofd.FileName.Substring(idx, ofd.FileName.Length - idx);
							if(count > 1)
								cpw.Text = "Please enter a password - Attempt " + count.ToString() + " of 3";
							cpw.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
							if( pt.X == 0 && pt.Y == 0 )
							{
								pt = new Point(this.Location.X + 100, this.Location.Y + 150);
							}
							cpw.Location = pt;
							cpw.FileName.Text = "Please enter a password for " + fn;
							cpw.ShowDialog(this);
							pt = cpw.Location;
							if(cpw.DialogResult == DialogResult.OK)
							{
								password = cpw.PW.Text;
								continue;
							}
							else
								return;
						}
					}
					MessageBox.Show(this, "The certificate file failed to load:\n\n" + f.Message);
					return;
				}
			}
		}

		private void LoadCert_Click(object sender, System.EventArgs e)
		{
			LoadCertificate();
		}

		private void RunTests_Click(object sender, System.EventArgs e)
		{
			System.Net.ServicePointManager.MaxServicePointIdleTime = 1000;
			WSUserInfo u = new WSUserInfo();
			StreamWriter sw = null;
			try
			{
				string s = Helpers.CertificateCN(cert.SubjectName) + ".log";
				sw = new StreamWriter(new FileStream(s, System.IO.FileMode.Create));
			}
			catch
			{
				sw = null;
			}
			WSEnvironment env = new WSEnvironment();
			env.Version = "1.0";
			env.fKeepAlive = false;
			env.fPipelined = false;
			if(cert == null)
			{
				MessageBox.Show(this, "A certificate file must be loaded before running the tests.");
				return;
			}
			string b64cert = cert.Export(CAPICOM_ENCODING_TYPE.CAPICOM_ENCODE_BASE64);
			env.Cert = new X509Certificate(Convert.FromBase64String(b64cert));

			env.Timeout = 1200;
			System.Random r = new Random();
			u.Puid = new byte[8];
			r.NextBytes(u.Puid);
			u.PuidFriendly = "";
			foreach(byte b in u.Puid)
			{
				u.PuidFriendly += b.ToString("X");
			}

			env.Description = "Partner Verification Tool";
			env.Host = HostNames[HostEnvs.SelectedIndex];
			env.UpdateAPISet(HostVersion[HostEnvs.SelectedIndex]);
			ps.TargetEnv = HostStrings[HostEnvs.SelectedIndex];
			ps.CertCN = Helpers.CertificateCN(env.Cert);

			if(u.GamerTag == null)
			{
				u.GamerTag = "VerifyPartner";
				u.PhonePrefix = "111";
				u.PhoneNumber = "1111111";
				u.PhoneExtension = "";
				u.CardNumber = "12345678901234";
				u.CardHolder = "Partner Verification Tool";
				u.PostalCode = "98052";
			}
			ps.Clear();
			ValidatePartner(env, u, sw);
			Report.Enabled = true;
		}

		enum FailureSignificance
		{
			FailureMeansHasPermissions,
			FailureMeansNoPermissions,
			FailureIsFailure
		};

		struct FailureMapping
		{
			public string FailureString;
			public FailureSignificance Significance;
			public string AdditionalInfo;

			public bool InfoProvided
			{
				get { return AdditionalInfo.Length > 0; }
			}
			public FailureMapping(string f, FailureSignificance s)
			{
				FailureString = f;
				Significance = s;
				AdditionalInfo = "";
			}
			public FailureMapping(string f, FailureSignificance s, string i)
			{
				FailureString = f;
				Significance = s;
				AdditionalInfo = " " + i;
			}
		};

		FailureMapping [] FailureMap = new FailureMapping [] 
			{
				new FailureMapping("leaderboard doesn't match type required by this webmethod", FailureSignificance.FailureMeansHasPermissions),
				new FailureMapping("error: 80156109:", FailureSignificance.FailureMeansHasPermissions),		// Result returned from Query for missing datasets on query
				new FailureMapping("0x8015c004: file not found", FailureSignificance.FailureMeansHasPermissions),	// Result returned from storage for a file in storage that isn't found
				new FailureMapping("timeout", FailureSignificance.FailureIsFailure, "(Timeout)"),
				new FailureMapping("time-out", FailureSignificance.FailureIsFailure, "(Timeout)"),
				new FailureMapping("the remote server returned an error: (403) forbidden.", FailureSignificance.FailureMeansNoPermissions, "(403 forbidden--check certificate, api permissions, and ips allowed)"),
				new FailureMapping("the request failed with http status 403: access forbidden.", FailureSignificance.FailureMeansNoPermissions, "(403 forbidden--certificate may be expired or not in the server's certificate trust list)"),
				new FailureMapping("could not establish secure channel for ssl/tls", FailureSignificance.FailureIsFailure, "(secure channel negotiation failure--check client and server certificates for correct installation, expiry, etc)"),
				new FailureMapping("the underlying connection was closed", FailureSignificance.FailureMeansNoPermissions, "(IP Blocked?)"),
				new FailureMapping("invalid ip", FailureSignificance.FailureMeansNoPermissions),
				new FailureMapping("access forbidden", FailureSignificance.FailureMeansNoPermissions),
				new FailureMapping("access denied", FailureSignificance.FailureMeansNoPermissions),
				new FailureMapping("partner not found", FailureSignificance.FailureMeansNoPermissions),
				new FailureMapping("not allowed", FailureSignificance.FailureMeansNoPermissions),
				new FailureMapping("is not linked in our system", FailureSignificance.FailureMeansHasPermissions),
				new FailureMapping("does not exist in our system", FailureSignificance.FailureMeansHasPermissions),
			};

		/// <summary>
		/// Determines whether an exception thrown indicates whether we have permissions for the api (or don't know).
		/// </summary>
		/// <param name="api">Name of the API to display</param>
		/// <param name="e">The exception to test against</param>
		/// <returns></returns>
		private bool ProcessFailure(string api, System.Exception e)
		{
			return ProcessFailure(api, e, true);
		}

		/// <summary>
		/// Determines whether an exception thrown indicates whether we have permissions for the api (or don't know).
		/// </summary>
		/// <param name="api">Name of the API to display</param>
		/// <param name="e">The exception to test against</param>
		/// <param name="deeprecurse">Whether this is just a scan of the current exception or to thoroughly check inner exceptions to</param>
		/// <returns></returns>
		private bool ProcessFailure(string api, System.Exception e, bool deeprecurse)
		{
			/* Ok, this may seem a bit wonky, but first I check the inner exception to one level only since I usually
			   wrap the real exception with one of my own.  But I don't want to recurse yet because there are some tests
			   that throw their own top-level exceptions that I would like to check next.  Only after failing both of those
			   do I want to consider recursing deeply.
			*/
			string msg;
			// Check the inner exception to exactly one level
			if(e.InnerException != null && deeprecurse == true)
			{
				if(ProcessFailure(api, e.InnerException, false))
					return true;
			}
			// Check the outer exception
			msg = e.Message.ToLower();
			// If it is a web exception, then there are headers and body that I can grab and check against.
			if(e.GetType() == typeof(System.Net.WebException))
			{
				System.Net.WebException we = (System.Net.WebException) e;
				// string response = "";
				if(we.Response != null && we.Response.Headers != null)
				{
					// X-Err comes from an internal server from an XRL request.  If we got that far, we have permissions.
					if(we.Response.Headers["X-Err"] != null)
					{
						AddGood(api);
						return true;
					}
					// response += we.Response.Headers.ToString();
				}
				/*
				 * This code exists for debugging purposes.
				if(we.Response != null)
				{
					System.IO.Stream s = we.Response.GetResponseStream();
					if(s != null && s.CanRead)
					{
						System.IO.StreamReader r = new System.IO.StreamReader(s);
						string resp = r.ReadToEnd();
						response += resp;
					}
				}
				response += Helpers.ExceptionInfo(e, false);
				*/
				//MessageBox.Show(response);
			}

			// Check against the failure mapping.
			foreach(FailureMapping fm in FailureMap)
			{
				if(msg.IndexOf(fm.FailureString) > -1)
				{
					switch(fm.Significance)
					{
						case FailureSignificance.FailureIsFailure:
							AddFailed(api + fm.AdditionalInfo, e, fm.InfoProvided);
							return true;
						case FailureSignificance.FailureMeansHasPermissions:
							AddGood(api);
							return true;
						case FailureSignificance.FailureMeansNoPermissions:
							AddBad(api + fm.AdditionalInfo, e, fm.InfoProvided);
							return true;
					};
				}
			}

			// If there are no inner exceptions, we can only assume failure.
			if(e.InnerException == null)
			{
				AddFailed(api, e, false);
				return true;
			}

			// There is an inner exception.  If we are to recurse then do so.
			if(deeprecurse)
				return ProcessFailure(api, e.InnerException);

			// Nothing left to do, we didn't process this failure so return false;
			return false;
		}

		void AddGood(string txt)
		{
			APIState a = new APIState();
			a.result = APIResult.Good;
			a.name = txt;
			a.exception = null;
			ps.APIStates.Add(a);
			AllowedAPIs.Items.Add(txt);
			AllowedAPIs.Update();
			tabAllowedAPIs.Text = "Allowed APIs (" + AllowedAPIs.Items.Count.ToString() + ")";
			tabAllowedAPIs.Update();
		}

		void AddBad(string txt, System.Exception e, bool dontaddmessage)
		{
			APIState a = new APIState();
			a.result = APIResult.Bad;
			a.name = txt;
			a.exception = e;
			ps.APIStates.Add(a);
			if(e == null || dontaddmessage)
			{
				DeniedAPIs.Items.Add(txt);
			}
			else
			{
				DeniedAPIs.Items.Add(txt + " (" + e.Message + ")");
			}
			DeniedAPIs.Update();
			tabDeniedAPIs.Text = "Denied APIs (" + DeniedAPIs.Items.Count.ToString() + ")";
			tabDeniedAPIs.Update();
		}

		void AddFailed(string txt, System.Exception e, bool dontaddmessage)
		{
			APIState a = new APIState();
			a.result = APIResult.Failed;
			a.name = txt;
			a.exception = e;
			ps.APIStates.Add(a);
			if(e == null || dontaddmessage)
			{
				FailedAPIs.Items.Add(txt);
			}
			else
			{
				FailedAPIs.Items.Add(txt + " (" + e.Message + ")");
			}
			FailedAPIs.Update();
			tabFailedAPIs.Text = "Failed APIs (" + FailedAPIs.Items.Count.ToString() + ")";
			tabFailedAPIs.Update();
		}

		void AddTitle(uint TitleID, GeneralInfo.TitlePrivilege Permissions, string TitleName)
		{
			TitleState t = new TitleState();
			t.titleID = TitleID;
			t.permissions = Permissions;
			t.titleName = TitleName;
            ps.TitleStates.Add(t);

			string id = "0x" + TitleID.ToString("X8");
			ListViewItem lvi = new ListViewItem(new string [] {id, Permissions.ToString(), TitleName});
			AllowedTitles.Items.Add(lvi);
			AllowedTitles.Update();
			tabAllowedTitles.Text = "Allowed Titles (" + AllowedTitles.Items.Count.ToString() + ")";
			tabAllowedTitles.Update();
		}

		void ValidatePartner(WSEnvironment env, WSUserInfo u, StreamWriter sw)
		{
			uint titleid = 0;
			try
			{
				titleid = Convert.ToUInt32(txtTitleID.Text, 16);
			}
			catch
			{
			}
			Tests t = new Tests(env, u, sw, new AddTitleString(AddTitle), titleid);
			ResetTabs();

			prog.Owner = this;
			prog.StartPosition = FormStartPosition.Manual;
			if(pt.X == 0 && pt.Y == 0)
			{
				pt = new Point(this.Location.X + 100, this.Location.Y + 150);
			}
			prog.Location = pt;
			prog.pbar.Maximum = t.ValidationRoutines.Length;
			prog.pbar.Minimum = 0;
			prog.pbar.Value = 0;
			prog.Text = "Progress - Working...";

			prog.Show();

			string result;

			foreach(ValidationRoutine vr in t.ValidationRoutines)
			{
				try
				{
					t.ResetTime();
					result = vr.Test();
					if(result == null)
                        AddGood(vr.Name);
					else
						AddBad(result, null, false);
				}
				catch(System.Exception exc)
				{
					ProcessFailure(vr.Name, exc);
				}
				prog.pbar.Value++;
			}

			foreach(APIInfo a in env.SupportedAPIs.Keys)
			{
				uint successful, failed, completions; 
				TimeSpan successtime, failedtime, completiontime;

				if(0 == t.CallData.GetCallStats(a, out successful, out successtime, out failed, out failedtime, out completions, out completiontime))
				{
					AddFailed(a.ToString() + " (not tested)", null, true);
				}
			}

			if(sw != null)
				sw.Close();

			prog.Text = "Progress - Done!";
			Thread.Sleep(750);
			if(AllowedAPIs.Items.Count > 0)
				tabControl.SelectedIndex = 0;
			else if(AllowedTitles.Items.Count > 0)
				tabControl.SelectedIndex = 1;
			else if(DeniedAPIs.Items.Count > 0)
				tabControl.SelectedIndex = 2;
			else if(FailedAPIs.Items.Count > 0)
				tabControl.SelectedIndex = 3;
			prog.Hide();
		}

		private void SelectCert_Click(object sender, System.EventArgs e)
		{
			VerifyPartner.SelectCert sc;
			if(cert != null && fDeleteLoadedCert)
				sc = new VerifyPartner.SelectCert(cert);
			else
				sc = new VerifyPartner.SelectCert();
			
			
			sc.ShowDialog(this);
			if(sc.cert != null)
			{
				if(cert != null && fDeleteLoadedCert)
				{
					certStore.Remove(cert);
					cert = null;
				}
				cert = sc.cert;
				fDeleteLoadedCert = false;
				Text =  "Partner Verification Tool - " + Helpers.CertificateCN(sc.cert.SubjectName);
				Report.Enabled = false;
				RunTests.Enabled = true;
			}
		}

		private void Report_Click(object sender, System.EventArgs e)
		{
			StringBuilder sb = new StringBuilder();
			uint bad = 0, failed = 0;
			// HTML Header goodies
			sb.Append("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" >\n");
			sb.Append("<HTML>\n<HEAD>\n");
			sb.Append("<title>Xbox Live Web Services Partner Verification Tool Report</title>\n");
			sb.Append("</HEAD>\n<BODY>\n");
			sb.Append("<h4 align=center>Xbox Live Web Services Partner Verification Tool Report</h3>\n");
			sb.Append("<h6 align=center>for</h6>\n");
			sb.Append("<h3 align=center>Partner: ").Append(ps.CertCN).Append(" against ").Append(ps.TargetEnv).Append("</h4>\n");

			// Now for the list of permitted APIs and titles
			sb.Append("<br><TABLE ALIGN=CENTER BORDER=0><TR><TD VALIGN=TOP>\n");

			try
			{
				APIState first = (APIState) ps.APIStates[0];
				ps.APIStates.Sort(first);
			}
			catch(System.Exception exc)
			{
				System.Diagnostics.Debug.WriteLine(Helpers.ExceptionInfo(exc, false));
			}
			try
			{
				TitleState first = (TitleState) ps.TitleStates[0];
				ps.TitleStates.Sort(first);
			}
			catch(System.Exception exc)
			{
				System.Diagnostics.Debug.WriteLine(Helpers.ExceptionInfo(exc, false));
			}

			// Allowed APIs
			sb.Append("<TABLE WIDTH=100% BORDER=1><TR><TH>Allowed APIs</TH></TR>\n");
			foreach(APIState a in ps.APIStates)
			{
				if(a.result == APIResult.Good)
				{
					sb.Append("<TR><TD>").Append(a.name).Append("</TD></TR>\n");
				}
				else if(a.result == APIResult.Bad)
				{
					bad++;
				}
				else if(a.result == APIResult.Failed)
				{
					failed++;
				}
			}
			sb.Append("</TABLE>\n");

			// Between allowed apis and titles
			sb.Append("</TD><TD VALIGN=TOP>\n");

			// Allowed Titles
			sb.Append("<TABLE WIDTH=100% BORDER=1><TR><TH>Title ID</TH><TH>Permissions</TH><TH>Title Name</TH></TR>\n");
			foreach(TitleState t in ps.TitleStates)
			{
				sb.Append("<TR><TD>0x").Append(t.titleID.ToString("X8")).Append("</TD><TD ALIGN=CENTER>").Append(t.permissions.ToString()).Append("</TD><TD>").Append(t.titleName).Append("</TD></TR>\n");
			}
			sb.Append("</TABLE>\n");

			// End of successful apis and titles.

			// Begin of failed apis and titles
			uint idx = 0;
			if(bad > 0 || failed > 0)
			{
				sb.Append("<TR><TD COLSPAN=2><HR></TD></TR>\n");
				sb.Append("<TR><TD VALIGN=TOP");
				if(bad == 0 || failed == 0)
					sb.Append(" COLSPAN=2");
				sb.Append(">");

				// Begin of forbidden apis
				if(bad > 0)
				{
					sb.Append("<TABLE WIDTH=100% BORDER=1><TR><TH>Disallowed APIs</TH></TR>\n");
					foreach(APIState a in ps.APIStates)
					{
						if(a.result == APIResult.Bad)
						{
							if(a.exception != null)
							{
								sb.Append("<TR><TD><A HREF=\"#").Append(idx.ToString()).Append("\">").Append(a.name).Append("</A></TD></TR>\n");
								++idx;
							}
							else
							{
								sb.Append("<TR><TD>").Append(a.name).Append("</A></TD></TR>\n");
							}
						}
					}
					sb.Append("</TABLE>\n");
				}

				if(bad > 0 && failed > 0)
				{
					sb.Append("</TD><TD VALIGN=TOP>\n");
				}

				// Begin of forbidden apis
				if(failed > 0)
				{
					sb.Append("<TABLE WIDTH=100% BORDER=1><TR><TH>Failed APIs (permissions unknown)</TH></TR>\n");
					foreach(APIState a in ps.APIStates)
					{
						if(a.result == APIResult.Failed)
						{
							if(a.exception != null)
							{
								sb.Append("<TR><TD><A HREF=\"#").Append(idx.ToString()).Append("\">").Append(a.name).Append("</A></TD></TR>\n");
								++idx;
							}
							else
							{
								sb.Append("<TR><TD>").Append(a.name).Append("</A></TD></TR>\n");
							}
						}
					}
					sb.Append("</TABLE>\n");
				}
			}
			sb.Append("</TD></TR></TABLE>\n");

			if(bad > 0 || failed > 0)
			{
				idx = 0;
				foreach(APIState a in ps.APIStates)
				{
					if(a.result == APIResult.Bad && a.exception != null)
					{
						sb.Append("<hr><h5><A NAME=\"#").Append(idx.ToString()).Append("\">").Append(a.name).Append("</A></h5>\n");
						sb.Append("<pre>").Append(Helpers.ExceptionInfo(a.exception, false).Replace("\r\n", "\n")).Append("</pre>\n");
						++idx;
					}
				}
				foreach(APIState a in ps.APIStates)
				{
					if(a.result == APIResult.Failed && a.exception != null)
					{
						sb.Append("<hr><h5><A NAME=\"#").Append(idx.ToString()).Append("\">").Append(a.name).Append("</A></h5>\n");
						sb.Append("<pre>").Append(Helpers.ExceptionInfo(a.exception, false).Replace("\r\n", "\n")).Append("</pre>\n");
						++idx;
					}
				}
			} // bad > 0 || failed > 0

			sb.Append("</BODY></HTML>\n");


			try
			{
				string nm = System.Environment.GetEnvironmentVariable("TEMP") + "\\VerfyPartnerReport_" + DateTime.Now.Ticks.ToString("X8") + ".html";
				TextWriter tw = File.CreateText(nm);
				tw.Write(sb.ToString());
				tw.Close();
	
				Process p = new Process();
				p.StartInfo.FileName = nm;
				p.StartInfo.UseShellExecute = true;
				p.Start();
			}
			catch(System.Exception exc)
			{
				MessageBox.Show(this, "Failed to create the report:\n" + Helpers.ExceptionInfo(exc, false));
			}
		}

	}

	public enum APIResult
	{
		Good,
		Bad,
		Failed
	};

	public class APIState : IComparer
	{
		public APIResult result;
		public string name;
		public System.Exception exception;
		#region IComparer Members

		int IComparer.Compare(object x, object y)
		{
			// TODO:  Add APIState.Compare implementation
			return ((APIState) x).name.CompareTo(((APIState) y).name);
		}

		#endregion
	}

	public class TitleState : IComparer
	{
		public GeneralInfo.TitlePrivilege permissions;
		public uint titleID;
		public string titleName;
		#region IComparer Members

		int IComparer.Compare(object x, object y)
		{
			// TODO:  Add TitleState.Compare implementation
			TitleState tx = (TitleState) x;
			TitleState ty = (TitleState) y;

			if(tx.titleID < ty.titleID)
				return -1;
			if(tx.titleID > ty.titleID)
				return 1;
			return 0;
		}

		#endregion
	}

	public class PassState
	{
		public string CertCN = "";
		public string TargetEnv = "";
		public ArrayList APIStates = new ArrayList();
		public ArrayList TitleStates = new ArrayList();

		public void Clear()
		{
			APIStates.Clear();
			TitleStates.Clear();
		}
	};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_verifypartner_none_12.4.56.0_none_8136af301da81208
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=verifypartner
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.manifest
XP_MANIFEST_PATH=manifests\msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.cat
XP_CATALOG_PATH=manifests\msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.cat
XP_PAYLOAD_PATH=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=verifypartner,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\SelectCert.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using CAPICOM;
using WSHelper;
using System.Security.Cryptography.X509Certificates;

namespace VerifyPartner
{
	/// <summary>
	/// Summary description for SelectCert.
	/// </summary>
	public class SelectCert : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ListView lstCerts;
		private System.Windows.Forms.Button btnSelect;
		private System.Windows.Forms.Button btnCancel;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		CAPICOM.Store certStore = new CAPICOM.StoreClass();
		CAPICOM.Certificates certs = null;
		public ICertificate2 cert = null;
		protected ICertificate2 skipcert = null;

		public SelectCert(ICertificate2 cert)
		{
			skipcert = cert;
			Initialize();
		}

		public SelectCert()
		{
			Initialize();
		}

		public void Initialize()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//

			lstCerts.Columns.Add("Issuer", 200, HorizontalAlignment.Left);
			lstCerts.Columns.Add("Subject Name", 200, HorizontalAlignment.Left);
			certStore.Open(CAPICOM_STORE_LOCATION.CAPICOM_CURRENT_USER_STORE, "My", CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_READ_WRITE | CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_EXISTING_ONLY);
			GetCertificates();
			btnSelect.Enabled = false;
		}

		protected void GetCertificates()
		{
			certs = (CAPICOM.Certificates) certStore.Certificates;
			if(certs != null)
			{
				foreach(CAPICOM.ICertificate2 c in certs)
				{
					try
					{
						if(c.PrivateKey != null && (skipcert == null || !VerifyPartner.PVForm.SameCertificate(c, skipcert)))
						{
							ListViewItem lvi = new ListViewItem();
							lvi.Text = Helpers.CertificateCN(c.IssuerName);
							lvi.SubItems.Add(Helpers.CertificateCN(c.SubjectName));
							lstCerts.Items.Add(lvi);
						}
					}
					catch
					{
					}
				}
			}
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.lstCerts = new System.Windows.Forms.ListView();
			this.btnSelect = new System.Windows.Forms.Button();
			this.btnCancel = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// lstCerts
			// 
			this.lstCerts.FullRowSelect = true;
			this.lstCerts.Location = new System.Drawing.Point(16, 16);
			this.lstCerts.MultiSelect = false;
			this.lstCerts.Name = "lstCerts";
			this.lstCerts.Size = new System.Drawing.Size(440, 112);
			this.lstCerts.TabIndex = 0;
			this.lstCerts.View = System.Windows.Forms.View.Details;
			this.lstCerts.SelectedIndexChanged += new System.EventHandler(this.lstCerts_SelectedIndexChanged);
			// 
			// btnSelect
			// 
			this.btnSelect.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnSelect.Location = new System.Drawing.Point(252, 136);
			this.btnSelect.Name = "btnSelect";
			this.btnSelect.Size = new System.Drawing.Size(72, 24);
			this.btnSelect.TabIndex = 1;
			this.btnSelect.Text = "Select";
			this.btnSelect.Click += new System.EventHandler(this.btnSelect_Click);
			// 
			// btnCancel
			// 
			this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnCancel.Location = new System.Drawing.Point(148, 136);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Size = new System.Drawing.Size(72, 24);
			this.btnCancel.TabIndex = 2;
			this.btnCancel.Text = "Cancel";
			// 
			// SelectCert
			// 
			this.AcceptButton = this.btnSelect;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.btnCancel;
			this.ClientSize = new System.Drawing.Size(472, 167);
			this.Controls.Add(this.btnCancel);
			this.Controls.Add(this.btnSelect);
			this.Controls.Add(this.lstCerts);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.Name = "SelectCert";
			this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "SelectCert";
			this.ResumeLayout(false);

		}
		#endregion

		private void btnSelect_Click(object sender, System.EventArgs e)
		{
			if(lstCerts.SelectedIndices.Count > 0)
			{
				// The next line mysteriously doesn't work.  Performing a loop as a work around.
				// CAPICOM.ICertificate2 c = (CAPICOM.ICertificate2) certs[lstCerts.SelectedIndices[0]];
				int i = 0;
				try
				{
					foreach(CAPICOM.ICertificate2 c in certs)
					{
						try
						{
							if(i == lstCerts.SelectedIndices[0] && c.PrivateKey != null && (skipcert == null || !VerifyPartner.PVForm.SameCertificate(c, skipcert)))
							{
								cert = c;
								return;
							}
							++i;
						}
						catch
						{
						}
					}
				}
				catch(System.Exception f)
				{
					MessageBox.Show(this, "The specified certificate failed to load:\n\n" + f.Message);
				}
				return;
			}
		}

		private void lstCerts_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			btnSelect.Enabled = true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WCUtilWrapper\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_verifypartner_none_12.4.56.0_none_8136af301da81208
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=verifypartner
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.manifest
XP_MANIFEST_PATH=manifests\msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.cat
XP_CATALOG_PATH=manifests\msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272.cat
XP_PAYLOAD_PATH=msil_verifypartner_no-public-key_12.4.56.0_x-ww_0bdf0272
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=verifypartner,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WCUtilWrapper\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wcutilwrapper_none_12.4.56.0_none_1e428661c4d211f0
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wcutilwrapper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.manifest
XP_MANIFEST_PATH=manifests\msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.cat
XP_CATALOG_PATH=manifests\msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.cat
XP_PAYLOAD_PATH=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wcutilwrapper,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WCUtilWrapper\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WCUtilWrapper\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wcutilwrapper_none_12.4.56.0_none_1e428661c4d211f0
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wcutilwrapper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.manifest
XP_MANIFEST_PATH=manifests\msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.cat
XP_CATALOG_PATH=manifests\msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28.cat
XP_PAYLOAD_PATH=msil_wcutilwrapper_no-public-key_12.4.56.0_x-ww_2ffefb28
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wcutilwrapper,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WCUtilWrapper\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WCUtilWrapper\WCUtilWrapper.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Caching;
using System.Web.Services;


using xonline.common.protocol;
using xonline.server.webcache.common;
using xonline.server.mgmt.soap;
using xonline.common.mgmt;
using xonline.common.service;



[assembly: XomAreaDefinition(XomAreaName.wcgeneraltrace)]
[assembly: XomAreaDefinition(XomAreaName.wcgenerallog)]

namespace XBOX.WebService
{
	[WebService(Namespace="http://websvc.xboxlive.com/Test/WCUtilDll/")]
	public class WCUtilWrapper : System.Web.Services.WebService
	{
		Utilities utils;
		
		public WCUtilWrapper()
		{
			utils = Utilities.Instance;
                
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

        #region Component Designer generated code
        
		//Required by the Web Services Designer 
		private IContainer components = null;
                
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);        
		}
        
        #endregion

		// Checks the API
		[WebMethod]
		public void CheckAPI( string APIName )
		{
			utils.CheckAPI(APIName);
		}

		// Checks the API and Title
		[WebMethod]
		public void CheckAPIAndTitle( string APIName, uint TitleID, TitlePrivilege privilegeRequired )
		{
			utils.CheckAPIAndTitle(APIName, TitleID, privilegeRequired);
		}

		// LookupPartner(string subjectName) is private, so we're not testing it here
		// It is used in side CheckAPI and CheckAPIAndTitle

		// GetRequestID/GetClientIPPort/GetSubjectName are used for logging 
		// only in the User account widget.  They are static functions as 
		// well, so I am omitting them.

		// Returns the Xbox user PUID of a gamer (
		[WebMethod]
		public ulong LookupPUID(string gamerTag)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupXuidByGamertag(gamerTag);
		}

		// Looks up the PUID 100 times similar to the Stats widget
		[WebMethod]
		public ulong LookupPUIDx100(string gamerTag)
		{
			ulong puid = 0;
			CheckAPI("GeneralInfo.GetTitleList");
			for(uint i=0; i < 100; i++)
			{
				puid = utils.LookupXuidByGamertag(gamerTag);
			}
			return puid;
		}

		// Looks up a Batch of PUIDs
		[WebMethod]
		public ulong[] LookupPUIDBatch(string[] gamerTags)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupXuidsByGamertags(gamerTags);
		}

		// Returns the gamer tag of a Xbox user PUID
		[WebMethod]
		public string LookupGamerTag(ulong PUID)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupGamerTag(PUID);
		}

		// Looks up the gamer tag 100 times similar to the Stats widget
		[WebMethod]
		public string LookupGamerTagx100(ulong PUID)
		{
			string gt = "";
			CheckAPI("GeneralInfo.GetTitleList");
			for(uint i=0; i < 100; i++)
			{
				gt = utils.LookupGamerTag(PUID);
			}
			return gt;
		}

		// Looks up a Batch of Gamer Tags
		[WebMethod]
		public string[] LookupGamerTagBatch(ulong[] PUIDs)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupGamerTags(PUIDs);
		}

		// Returns the PUID for a given team
		[WebMethod]
		public ulong LookupTeamPUID(uint titleId, string teamName)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupTeamPUID(titleId, teamName);
		}

		// Returns the PUIDs for a given team
		[WebMethod]
		public ulong[] LookupTeamPUIDs(uint titleId, string [] teamNames)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupTeamPUIDs(titleId, teamNames);
		}

		// Looks up the Team PUID 100 times similar to the Stats Widget
		[WebMethod]
		public ulong LookupTeamPUIDx100(uint titleId, string teamName)
		{
			ulong puid = 0;
			CheckAPI("GeneralInfo.GetTitleList");
			for(uint i = 0; i < 100; i++)
			{
				puid = utils.LookupTeamPUID(titleId, teamName);
			}
			return puid;
		}

		// Returns the team name for a given Team Puid and title
		[WebMethod]
		public string LookupTeamName(uint titleId, ulong puidTeam)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupTeamName(titleId, puidTeam);
		}

		// Returns the team name for a given Team Puid and title
		[WebMethod]
		public string[] LookupTeamNames(uint titleId, ulong [] puidTeams)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupTeamNames(titleId, puidTeams);
		}

		// Looks up the team name 100 times similar to the Stats widget
		[WebMethod]
		public string LookupTeamNamex100(uint titleId, ulong puidTeam)
		{
			string team = "foo";
			CheckAPI("GeneralInfo.GetTitleList");
			for(uint i = 0; i < 100; i++)
			{
				team = utils.LookupTeamName(titleId, puidTeam);
			}
			return team;
		}

		// AddWebMapping is a static void function that is used when
		// data is loaded from the SQL server.  It is not used by any 
		// method a widget will use except on WebCache start up.
		// It creates the PUID to Owner mapping when reading each
		// PUID from the DB.

		// Returns and array of PUID/Owner for a given WebID
		[WebMethod]
		public PUIDAndOwner[] LookupWebIDArray(byte[] webID)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupWebID(webID);
		}

		// Returns PUID and Owner of a specific webID/GamerTag
		[WebMethod]
		public PUIDAndOwner LookupWebID(byte[] webID, string GamerTag)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.LookupWebID(webID, GamerTag);
		}

		// Returns PUID and Owner of a specific webID/GamerTag
		[WebMethod]
		public PUIDAndOwner LookupWebIDx100(byte[] webID, string GamerTag)
		{
			PUIDAndOwner PaO = new PUIDAndOwner();
			CheckAPI("GeneralInfo.GetTitleList");
			for(uint i = 0; i < 100; i++)
			{
				PaO = utils.LookupWebID(webID, GamerTag);
			}
			return PaO;
		}

		// Returns array of partner-filtered title info structs
		// Definition of TitlePrivilegeInfo comes from Utilities.cs
		[WebMethod]
		public TitlePrivilegeInfo[] GetPartnerSpecificTitleInfo()
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.GetPartnerSpecificTitleInfo();
		}

		// Inserts an item into the cache
		[WebMethod]
		public void CacheInsert(CacheType type, byte[] key, byte[] value, uint expireInSeconds)
		{
			CheckAPI("GeneralInfo.GetTitleList");
			utils.CacheInsert( type, key, value, expireInSeconds, new CacheItemRemovedCallback(Callback));
		}

		// Inserts an item into the cache and returns 1 if it succeeded
		[WebMethod]
		public bool ArbitraryCacheInsert(CacheType type, byte[] key, uint uiSizeInBytes, uint expireInSeconds)
		{
			Random RandObj = new Random();

			// Allocate the data to be added here
			byte[] rgbValue = new byte[uiSizeInBytes];
			byte[] rgbLookup = new byte[uiSizeInBytes];
			// Set it to some random value
			RandObj.NextBytes(rgbValue);

			CheckAPI("GeneralInfo.GetTitleList");
			utils.CacheInsert( type, key, rgbValue, expireInSeconds, new CacheItemRemovedCallback(Callback));
			rgbLookup = utils.CacheLookup( type, key );

			// Verify that the retrieved item is correct
			for(uint i=0; i < uiSizeInBytes; i++)
			{
				if(rgbLookup[i] != rgbValue[i])
					return false;
			}
			return true;
		}

		// Inserts an item into the cache and returns 1 if it succeeded
		[WebMethod]
		public void QuickCacheInsert(CacheType type, uint uiSizeInBytes, uint expireInSeconds)
		{
			Random RandObj = new Random();

			// Allocate the data to be added here
			byte[] rgbKey = new byte[8];
			byte[] rgbValue = new byte[uiSizeInBytes];
			// Set it to some random value
			RandObj.NextBytes(rgbKey);
			RandObj.NextBytes(rgbValue);

			CheckAPI("GeneralInfo.GetTitleList");
			utils.CacheInsert( type, rgbKey, rgbValue, expireInSeconds, new CacheItemRemovedCallback(Callback));
		}

		// Inserts an item into the cache and returns 1 if it succeeded
		[WebMethod]
		public void QuickCacheInsertX(CacheType type, uint uiSizeInBytes, uint expireInSeconds, uint numToInsert)
		{
			Random RandObj = new Random();

			// Allocate the data to be added here
			byte[] rgbKey = new byte[8];
			byte[] rgbValue = new byte[uiSizeInBytes];
			// Set it to some random value
			RandObj.NextBytes(rgbKey);
			RandObj.NextBytes(rgbValue);

			CheckAPI("GeneralInfo.GetTitleList");
			for(uint i = 0; i < numToInsert; i++)
			{
				utils.CacheInsert( type, rgbKey, rgbValue, expireInSeconds, new CacheItemRemovedCallback(Callback));
				RandObj.NextBytes(rgbKey);
			}
		}

		public void Callback(string key, object value, CacheItemRemovedReason reason)
		{
		}

		// Returns the contents of the cache in a byte array based on the 
		// key and cache type
		[WebMethod]
		public byte[] CacheLookup( CacheType type, byte[] key )
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.CacheLookup( type, key );
		}

		// Returns the contents of the cache in a byte array based on the 
		// key and cache type
		[WebMethod]
		public byte[] FrontDoorRequest( String Url, ulong RequestingUserPUID, uint titleID, uint serviceId1, uint serviceId2, byte[] postData  )
		{
			CheckAPI("GeneralInfo.GetTitleList");
			return utils.FrontDoorRequest( Url, RequestingUserPUID, titleID, serviceId1, serviceId2, postData );
		}

		// Reload the data from the UODB/NPDB
		[WebMethod]
		public void ReloadTitlesAndPartners()
		{
			string [] args = null;

			// These methods don't even use their arguments, so 
			// I'm setting them to null
			CheckAPI("GeneralInfo.GetTitleList");
			utils.ProcessReloadPartners(args);
			utils.ProcessReloadTitles(args);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\GeneralInfo.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="GeneralInfoSoap", Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class GeneralInfo : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public GeneralInfo(String url) {
        if (url != null)
        {
            this.Url = url;
        }
        else
        {
            this.Url = "https://192.168.86.51/generalinfo/generalinfo.asmx";
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/GeneralInfo/GetTitleList", RequestNamespace="http://websvc.xboxlive.com/GeneralInfo/", ResponseNamespace="http://websvc.xboxlive.com/GeneralInfo/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public TitlePrivilegeInfo[] GetTitleList(out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetTitleList", new object[0]);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((TitlePrivilegeInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTitleList(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTitleList", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public TitlePrivilegeInfo[] EndGetTitleList(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((TitlePrivilegeInfo[])(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class TitlePrivilegeInfo {
    
    /// <remarks/>
    public System.UInt32 TitleID;
    
    /// <remarks/>
    public TitlePrivilege Privileges;
    
    /// <remarks/>
    public ESRBRating Rating;
    
    /// <remarks/>
    public string DefaultLocale;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LocalizedDisplayName[] LocalizedName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum TitlePrivilege {
    
    /// <remarks/>
    None,
    
    /// <remarks/>
    ReadOnly,
    
    /// <remarks/>
    ReadWrite,
    
    /// <remarks/>
    FullControl,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum ESRBRating {
    
    /// <remarks/>
    ALL,
    
    /// <remarks/>
    ADULT,
    
    /// <remarks/>
    MATURE,
    
    /// <remarks/>
    TEEN,
    
    /// <remarks/>
    EVERYONE,
    
    /// <remarks/>
    KIDS_TO_ADULTS,
    
    /// <remarks/>
    EARLY_CHILDHOOD,
    
    /// <remarks/>
    UNSPECIFIED,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class LocalizedDisplayName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string DisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebCacheReflector\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace Reflector 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebCacheReflector\WebCacheReflector.asmx.cs ===
using System;
using System.Windows.Forms;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.Text;
using System.Threading;

namespace Reflector
{
	/// <summary>
	/// Summary description for Service1.
	/// </summary>
	public class WebCacheReflector : System.Web.Services.WebService
	{
		public WebCacheReflector()
		{
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

		#region Component Designer generated code
		
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
		
		#endregion

        [WebMethod]
        public byte[] WallysWCReflector(int iPayLoad ) {
            string s = "This is a test of the emergency response system.";
            this.Context.Response.AddHeader("Subject-Name","wallyho");
            this.Context.Response.AddHeader("Client-IP-Port","192.168.86.88:8888");
            this.Context.Response.AddHeader("RequestId","8888888888888888");
            return Encoding.ASCII.GetBytes(s);
        }
        [WebMethod]
        public byte[] WallysWCReflectorBytes( uint uiPayLoad ) {
            byte[] b = new byte[uiPayLoad];     
            for (uint i =0; i < uiPayLoad; i++){
                b[i] = (byte)('A' + (i % 65));  
            }
            return b;
        }

        [WebMethod]
        public byte[] WallysWCReflectorBytesTimeout (uint uiPayLoad, int iTimeout ) {
            byte[] b = new byte[uiPayLoad];     
            for (uint i =0; i < uiPayLoad; i++){
                b[i] = (byte)('A' + (i % 65));  
            }
            Thread.Sleep(iTimeout);
            this.Context.Response.AddHeader("Subject-Name","wallyho");
            this.Context.Response.AddHeader("Client-IP-Port","192.168.86.88:8888");
            this.Context.Response.AddHeader("RequestId","8888888888888888");
            return b;
        }

        [WebMethod]
        public string WallysWCReflectorString( ) {
            // Echo back the headers in the request.
            string [] p = this.Context.Request.Headers.AllKeys;
            string s = "SERVER :: " +  SystemInformation.ComputerName + "\n";
            foreach (string x in p){
                s = s + x + ": ";
                foreach (string y in this.Context.Request.Headers.GetValues(x)){
                    s = s + y + "";
                }
                s = s + "\n";
            }
            //this.Context.Response.AddHeader("Cache-Control","private, max-age=0");
            return s;
        }

        [WebMethod]
        public byte[] WallysWCReflectorBytesBreakConnection(uint uiPayLoad, int iTimeToBreak ) {
            byte[] b = new byte[uiPayLoad];     
            for (uint i =0; i < uiPayLoad; i++){
                b[i] = (byte)('A' + (i % 65));  
            }
            Thread.Sleep(iTimeToBreak);
            // Break Connection? how?
            this.Dispose();
            this.Context.Response.AddHeader("Subject-Name","wallyho");
            this.Context.Response.AddHeader("Client-IP-Port","192.168.86.88:8888");
            this.Context.Response.AddHeader("RequestId","8888888888888888");
            return b;
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\WebCacheReflector.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="WebCacheReflectorSoap", Namespace="http://tempuri.org/")]
public class WebCacheReflector : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public WebCacheReflector() {
        this.Url = "http://192.168.86.81/websg/webcachereflector.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflector", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] WallysWCReflector(int iPayLoad) {
        object[] results = this.Invoke("WallysWCReflector", new object[] {
                    iPayLoad});
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflector(int iPayLoad, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflector", new object[] {
                    iPayLoad}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.Byte[] EndWallysWCReflector(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflectorBytes", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] WallysWCReflectorBytes(System.UInt32 uiPayLoad) {
        object[] results = this.Invoke("WallysWCReflectorBytes", new object[] {
                    uiPayLoad});
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflectorBytes(System.UInt32 uiPayLoad, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflectorBytes", new object[] {
                    uiPayLoad}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.Byte[] EndWallysWCReflectorBytes(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflectorBytesTimeout", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] WallysWCReflectorBytesTimeout(System.UInt32 uiPayLoad, int iTimeout) {
        object[] results = this.Invoke("WallysWCReflectorBytesTimeout", new object[] {
                    uiPayLoad,
                    iTimeout});
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflectorBytesTimeout(System.UInt32 uiPayLoad, int iTimeout, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflectorBytesTimeout", new object[] {
                    uiPayLoad,
                    iTimeout}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.Byte[] EndWallysWCReflectorBytesTimeout(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflectorString", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string WallysWCReflectorString() {
        object[] results = this.Invoke("WallysWCReflectorString", new object[0]);
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflectorString(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflectorString", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public string EndWallysWCReflectorString(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\CDatafile.cs ===
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Net;
using System.Diagnostics;

namespace WebSgEngine {

    public struct TESTCASE {
        public string szTestName;
        public uint   Request_uiPacketSize;
        public int    Request_iTimeOutMilliseconds;
        public int    Request_iClientTimeOutMilliseconds;
        public string Request_szAPItoCall;
        public string Request_szURL;
        public string Request_szCertificate;
        public uint   Request_uiStartPacketSizeRange;
        public uint   Request_uiEndPacketSizeRange;
        public uint   Request_uiSkipSizeRange;

        public string Request_SubjectName;
        public string Request_SOAPAction;
        public string Request_ClientIPPort;
        public string Request_RequestId;

        public uint   Response_uiPayloadSize;
        // Program Control codes
        public uint    uiNumberOfTests;
        public bool   bStress;
        public string HTTP_Method;
        public string szWhichRequestType;
        // Stress Weighting system
        public int    iWeightingPercentage;
    }

    public class CDatafile {


        const string TESTCASE_CASE_BEGIN         = "[CASE %d BEGIN]\n";
        const string TESTCASE_CASE_END           = "[CASE %d END]\n";
        uint uiGiveMeNumberOfCases = 0;
        string g_szDriverFilename;

        public uint GiveMeNumberOfCases(){
            return uiGiveMeNumberOfCases;
        }
        
        public TESTCASE []LoadTestCasesToRun( string szDriverFilename ){
            return LoadTestCasesToRun( szDriverFilename, 0 );
        }

        public TESTCASE []LoadTestCasesToRun( string szDriverFilename, uint uiPacketSize ){

            //bool b = false;
            bool bLoopBreak = false;
            string szLineParserBuffer;
            Regex r = new Regex(" +"); 
            string[] szStrings;
            StreamReader srReadConfig = null ;
            g_szDriverFilename = szDriverFilename;
            TESTCASE [] ptc = null;
           
            try {
                srReadConfig = new StreamReader( g_szDriverFilename , false );
                // Get number of test in the test.
                bLoopBreak = false;
               
                while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                    //Console.WriteLine("{0}", szLineParserBuffer);
                    if (true == bLoopBreak)
                        break;
                    if ( -1 != szLineParserBuffer.IndexOf("[TESTS_TO_RUN_START]" )){
                        while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                            if ( -1 != szLineParserBuffer.IndexOf("[TESTS_TO_RUN_END]")){
                                // if end is found stop.
                                bLoopBreak = true;
                                break;
                            }else
                                //ignore blank lines count only full lines.       
                                if ( "" == szLineParserBuffer.ToString()){
                                continue;
                            }else{
                                //szStrings = r.Split(szLineParserBuffer);
                                //szTestNames[uiGiveMeNumberOfCases] = szString[0];
                                uiGiveMeNumberOfCases += 1;
                               // Console.WriteLine("Count {0}", uiGiveMeNumberOfCases);
                            }
                        }                    
                    }                    
                }
                srReadConfig.Close();
                if (uiGiveMeNumberOfCases == 0)
                    goto c0;
                //
                // Create number of test cases to run.
                //
                ptc = new TESTCASE[uiGiveMeNumberOfCases];
                
                // Now load the names of the test into the array.
                uint uiCaseNumber = 0;
                string [] szTestNamesArray= new string[uiGiveMeNumberOfCases];
                int [] iTestNameWeightingPercentage= new int[uiGiveMeNumberOfCases];
                
                bLoopBreak = false;
                srReadConfig = new StreamReader(g_szDriverFilename, false );
                while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                    if (true == bLoopBreak)
                        break;
                    if ( -1 != szLineParserBuffer.IndexOf("[TESTS_TO_RUN_START]" )){
                        while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                            if ( -1 != szLineParserBuffer.IndexOf("[TESTS_TO_RUN_END]")){
                                // if end is found stop.
                                bLoopBreak = true;
                                break;
                            }else
                                //ignore blank lines count only full lines.       
                                if ( "" == szLineParserBuffer.ToString()){
                                continue;
                            }else{
                                szStrings = r.Split(szLineParserBuffer);
                                szTestNamesArray[uiCaseNumber] = szStrings[0];
                                if (1 != szStrings.Length){
                                    iTestNameWeightingPercentage[ uiCaseNumber] =  Convert.ToInt32(szStrings[1],10);
                                }
                                //Console.WriteLine("Count {0} {1}", uiCaseNumber, szTestNamesArray[uiCaseNumber] );
                                //Console.WriteLine("Count {0} {1}", uiCaseNumber, iTestNameWeightingPercentage[uiCaseNumber]  );
                                uiCaseNumber += 1;
                            }
                        }
                    }                    
                }
                // Load and run Cases.
                for (uint i = 0; i < uiGiveMeNumberOfCases; i++){
                    ptc[i] = LoadSingleCaseTestData( szTestNamesArray[i], iTestNameWeightingPercentage[i] );
                    ptc[i].uiNumberOfTests = uiGiveMeNumberOfCases;
                    
                    //Override the packet size in the driver file.
                    if (0 != uiPacketSize)
                        ptc[i].Request_uiPacketSize = uiPacketSize;
                    else 
                        ptc[i].Request_uiPacketSize = 0;
                }
            }catch (Exception e) { 
                Console.Write("CDataFile.LoadTestCasesToRun{0}\n",e.Message.ToString());
                ptc = null;
            }
            c0:
                //if (b == false){
                //    Console.WriteLine("Could not find Entry in Driver file\n");
               // }
            srReadConfig.Close();
            return ptc;
        }


        public TESTCASE LoadSingleCaseTestData( string szTestName, int iWeightingPercentage ) {
            /*++
             Copyright (c) 2001-2002, Microsoft.

                Author:  Wally W. Ho (wallyho)
                Date:    12/21/2001

                Routine Description:
                    This will read a test cast enclosed by 
                    [CASE %d BEGIN] and [CASE %d END] 
                    Add to the structure a formed POST request and formatted POST body input
                Arguments:
                    A structure to store the data retrieved.
                Return Value:
                  BOOL indicating success or failure (TRUE/ FALSE)
            --*/
            bool b = false;
            string szLineParserBuffer;
            Regex r = new Regex(" +"); 
            string[] szStrings;
            StreamReader srReadConfig = null ;
            TESTCASE ptc = new TESTCASE();
            
            try {
                //Walk down the Sample File to the Case Specified.
                srReadConfig = new StreamReader(g_szDriverFilename, false );
                // Create the [CASE %d BEGIN] search criteria
                string szCaseSearchBegin = TESTCASE_CASE_BEGIN;

                // Walk down to the Test Name we are looking for.

                while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                    //Console.WriteLine("->>{0}", szLineParserBuffer);
                    if ( -1 != szLineParserBuffer.IndexOf("TEST_NAME" )){
                        // Now check if this is the right test.
                        // Direct comparison.
                        szStrings = r.Split(szLineParserBuffer);
                        //foreach (string szString in szStrings)
                        //    Console.WriteLine("Yes {0}",szString);
                        szCaseSearchBegin = szStrings[1];
                        if ( true == szCaseSearchBegin.Equals( szTestName) ) {
                            // Found the case.. lets read from it till the end.
                            ptc.szTestName = szTestName;
                            ptc.iWeightingPercentage = iWeightingPercentage;
                            break;
                        } 
                        //loop around till end 
                    }
                }
                if (szLineParserBuffer == null){
                    goto c0;
                }

                // Read out the data.
                while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                    if ( -1 != szLineParserBuffer.IndexOf(" END]")){
                        // if end is found stop.
                        break;
                    }
                    if ( -1 != szLineParserBuffer.IndexOf( "WEBSG_REQUEST" )){
                        szStrings = r.Split(szLineParserBuffer);
                        if ( true == szStrings[1].Equals("uiPacketSize") ) {
                            ptc.Request_uiPacketSize = Convert.ToUInt32(szStrings[2],10);
                        } else
                            if ( true == szStrings[1].Equals("iTimeOutMilliseconds") ) {
                            ptc.Request_iTimeOutMilliseconds = Convert.ToInt32(szStrings[2],10);
                        } else
                            if ( true == szStrings[1].Equals("iClientTimeOutMilliseconds") ) {
                            ptc.Request_iClientTimeOutMilliseconds = Convert.ToInt32(szStrings[2],10);
                        } else
                            if ( true == szStrings[1].Equals("szAPItoCall") ) {
                            ptc.Request_szAPItoCall = szStrings[2];
                        } else
                            if ( true == szStrings[1].Equals("szURL") ) {
                            ptc.Request_szURL = szStrings[2];
                        } else
                            if ( true == szStrings[1].Equals("uiStartPacketSizeRange") ) {
                            ptc.Request_uiStartPacketSizeRange = Convert.ToUInt32(szStrings[2],10);
                        } else
                            if ( true == szStrings[1].Equals("uiSkipSizeRange") ) {
                            ptc.Request_uiSkipSizeRange = Convert.ToUInt32(szStrings[2],10);
                        } else
                            if ( true == szStrings[1].Equals("uiEndPacketSizeRange") ) {
                            ptc.Request_uiEndPacketSizeRange = Convert.ToUInt32(szStrings[2],10);
                        } else
                            if ( true == szStrings[1].Equals("szCertificate") ) {
                            ptc.Request_szCertificate = szStrings[2];
                        }else {
                            //Console.WriteLine("->{0}\n",szLineParserBuffer.ToString() );
                        }
                    }else
                        if ( -1 != szLineParserBuffer.IndexOf( "WEBSG_RESPONSE" )){
                        szStrings = r.Split(szLineParserBuffer);
                        if ( true == szStrings[1].Equals("uiReturnedPayloadSize") ) {
                            ptc.Response_uiPayloadSize = Convert.ToUInt32(szStrings[2],10);
                            // Header responses.
                        } else
                            if ( true == szStrings[1].Equals("Request_SubjectName") ) {
                            ptc.Request_SubjectName = szStrings[2];
                        } else
                            if ( true == szStrings[1].Equals("Request_SOAPAction") ) {
                            ptc.Request_SOAPAction = szStrings[2];
                        } else
                            if ( true == szStrings[1].Equals("Request_ClientIPPort") ) {
                            ptc.Request_ClientIPPort = szStrings[2];
                        } else
                            if ( true == szStrings[1].Equals("Request_RequestId") ) {
                            ptc.Request_RequestId = szStrings[2];
                        } else {
                            //Console.WriteLine("->{0}\n",szLineParserBuffer.ToString() );
                        }
                    }else
                        if ( -1 != szLineParserBuffer.IndexOf( "WEBSGENGINE_CONTROL" )){
                        szStrings = r.Split(szLineParserBuffer);
                        if ( true == szStrings[1].Equals("szWhichRequestType") ) {
                            ptc.szWhichRequestType = szStrings[2];
                        } else {
                            //Console.WriteLine("->{0}\n",szLineParserBuffer.ToString() );
                        }
                    }
                }
                b = true;
            }
            catch (Exception e) { 
                Console.Write("Exception:{0}\n",e.Message.ToString());
                //b = false;
                //ptc = 0;
                //goto c0;
            }
            // Catch if its find nothing
            if (b == false){
                Console.WriteLine("Could not find Entry in Driver file\n");
                srReadConfig.Close();
            }
            c0:
            srReadConfig.Close();
            return ptc;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\VerifyPartner\Tests.cs ===
using System;
using System.Collections;
using System.Reflection;
using System.IO;

using WSHelper;

using Alerts;
using GeneralInfo;
using UserAccount;
using Stats;
using Presence;
using Signature;
using Messaging;
using Query;
using Teams;
using Storage;

namespace VerifyPartner
{
	/// <summary>
	/// Summary description for Tests.
	/// </summary>
	/// 

	public delegate void AddTitleString(uint TitleID, TitlePrivilege Permissions, string TitleName);

	public abstract class ValidationRoutine
	{
		protected string n;
		public string Name
		{
			get {return n;}
		}

		protected Tests p;
		public Tests Parent
		{
			get {return p;}
		}

		protected APIInfo [] a = new APIInfo[0];
		public APIInfo [] RequiredAPIs
		{
			get {return a;}
		}

		public ValidationRoutine(Tests myParent)
		{
			p = myParent;
		}

		public abstract string Test();
	}

	public class Tests
	{
		ValidationRoutine [] vr;
		System.Random rand = new System.Random();
		uint tid = 0xFFFFFFFF, lbtid = 0xFFFFFFFF, lbid = 0xFFFFFFFF;
		uint tidbackup = 0;
		TitlePrivilege tidPrivs = TitlePrivilege.None;

		public CallStatistics CallData
		{
			get {return w;}
		}

		XSigCreateSignatureRequest [] sigReq = new XSigCreateSignatureRequest[1];
		XSigCreateSignatureResponse [] sigRes = new XSigCreateSignatureResponse[1];
		string linked;
		TitleInfoList tl = null;
		WSEnvironment e;
		WSWrap w;
		WSUserInfo u;
		StreamWriter l;
		AddTitleString ats;

		public void ResetTime()
		{
			w.dtStartTime = DateTime.Now;
		}

		#region Constructor
		public Tests(WSEnvironment Environment, WSUserInfo UserInfo, StreamWriter Log, AddTitleString addTitleStringDelegate, uint backupTitleID)
		{
			//
			// TODO: Add constructor logic here
			//

			tidbackup = backupTitleID;

			e = Environment;
			u = UserInfo;
			l = Log;
			linked = u.GamerTag;
			ats = addTitleStringDelegate;

			w = WSWrap.GetWrapper(e, System.DateTime.Now);


			sigReq[0] = new XSigCreateSignatureRequest();
			sigReq[0]._digest = new byte[20];
			rand.NextBytes(sigReq[0]._digest);
			sigRes[0] = new XSigCreateSignatureResponse();
			sigRes[0]._hresult = 0;
			sigRes[0]._signature = null;

			Type [] constructorParamTypes = new Type[] {typeof(Tests)};
			object [] constructorParamList = new object[] {this};
			Type [] nested = this.GetType().GetNestedTypes(BindingFlags.NonPublic|BindingFlags.Instance);
			ArrayList al = new ArrayList();
			foreach(Type t in nested)
			{
				if(t.BaseType == typeof(ValidationRoutine))
				{
					ValidationRoutine v = (ValidationRoutine) t.GetConstructor(constructorParamTypes).Invoke(constructorParamList);
					bool skip = false;
					foreach(APIInfo a in v.RequiredAPIs)
					{
						if(!e.APISupported(a))
						{
							skip = true;
							break;
						}
					}
					if(!skip)
					{
						al.Add(v);
					}
				}
			}

			vr = (ValidationRoutine []) al.ToArray(typeof(ValidationRoutine));
		}
		#endregion

		#region Accessors
		public ValidationRoutine [] ValidationRoutines
		{
			get {return vr;}
		}
		#endregion

		#region GeneralInfo.GetTitleList
		class GeneralInfo_GetTitleList : ValidationRoutine
		{
			public GeneralInfo_GetTitleList(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.GeneralInfo_GetTitleList};
				n = "GeneralInfo.GetTitleList";
			}

			public override string Test()
			{
				try
				{
					p.tl = p.w.GetTitleList();
				}
				catch
				{
					if(p.tidbackup != 0 && p.tidbackup != 0xffffffff)
					{
						p.tidPrivs = TitlePrivilege.FullControl;
						p.tid = p.tidbackup;
					}
					throw;
				}

				foreach(TitlePrivilegeInfo tpi in p.tl.info)
				{
					if(tpi.Privileges != TitlePrivilege.None)
					{
						p.ats(tpi.TitleID, tpi.Privileges, Helpers.GetLocalizedName(tpi.DefaultLocale, tpi.LocalizedName, "0x" + tpi.TitleID.ToString("X8")));
					}
					switch(tpi.Privileges)
					{
						case TitlePrivilege.FullControl:
							if(p.tidPrivs != TitlePrivilege.FullControl)
							{
								p.tidPrivs = TitlePrivilege.FullControl;
								p.tid = tpi.TitleID;
							}
							break;
						case TitlePrivilege.ReadOnly:
							if(p.tidPrivs == TitlePrivilege.None)
							{
								p.tidPrivs = TitlePrivilege.ReadOnly;
								p.tid = tpi.TitleID;
							}
							break;
						case TitlePrivilege.ReadWrite:
							if(p.tidPrivs != TitlePrivilege.FullControl)
							{
								p.tidPrivs = TitlePrivilege.ReadWrite;
								p.tid = tpi.TitleID;
							}
							break;
					};
				}
				return null;
			}
		}
		#endregion

		#region UserAccount.LinkUser
		class UserAccount_LinkUser : ValidationRoutine
		{
			public UserAccount_LinkUser(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.UserAccount_LinkUser};
				n = "UserAccount.LinkUser";
			}

			public override string Test()
			{
				p.w.LinkUser(p.u.Puid, p.u.GamerTag, true, p.u.PhonePrefix, p.u.PhoneNumber, p.u.PhoneExtension, p.u.PostalCode, p.u.CardHolder, p.u.CardNumber); 
				return null;
			}
		}
		#endregion

		#region UserAccount.LinkedGamerTags
		class UserAccount_LinkedGamerTags : ValidationRoutine
		{
			public UserAccount_LinkedGamerTags(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.UserAccount_LinkedGamerTags};
				n = "UserAccount.LinkedGamerTags";
			}

			public override string Test()
			{
				LinkedAccount[] li = p.w.LinkedGamerTags(p.u.Puid); 
				if(li != null && li.Length > 0)
				{
					p.linked = li[0].GamerTag;
				}
				else
				{
					p.linked = p.u.GamerTag;
				}
				return null;
			}
		}
		#endregion

		#region GeneralInfo.LinkedGamerTags
		class GeneralInfo_LinkedGamerTags : ValidationRoutine
		{
			public GeneralInfo_LinkedGamerTags(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.GeneralInfo_LinkedGamerTags};
				n = "GeneralInfo.LinkedGamerTags";
			}

			public override string Test()
			{
				LinkedAccount[] li = p.w.GILinkedGamerTags(p.u.Puid);
				if(li != null && li.Length > 0)
				{
					p.linked = li[0].GamerTag;
				}
				else
				{
					p.linked = p.u.GamerTag;
				}
				return null;
			}
		}
		#endregion

		#region UserAccount.GetUserSettings
		class UserAccount_GetUserSettings : ValidationRoutine
		{
			public UserAccount_GetUserSettings(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.UserAccount_GetUserSettings};
				n = "UserAccount.GetUserSettings";
			}

			public override string Test()
			{
				p.w.GetUserSettings(p.u.Puid, p.linked); 
				return null;
			}
		}
		#endregion

		#region UserAccount.SetInfoSharing
		class UserAccount_SetInfoSharing : ValidationRoutine
		{
			public UserAccount_SetInfoSharing(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.UserAccount_SetInfoSharing};
				n = "UserAccount.SetInfoSharing";
			}

			public override string Test()
			{
				p.w.SetInfoSharing(p.u.Puid, p.linked, false, false); 
				return null;
			}
		}
		#endregion

		#region UserAccount.GetAccountStatus
		class UserAccount_GetAccountStatus : ValidationRoutine
		{
			public UserAccount_GetAccountStatus(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.UserAccount_GetAccountStatus};
				n = "UserAccount.GetAccountStatus";
			}

			public override string Test()
			{
				p.w.GetAccountStatus(p.u.Puid, p.linked); 
				return null;
			}
		}
		#endregion

		#region Alerts.SubscriberExists
		class Alerts_SubscriberExists : ValidationRoutine
		{
			public Alerts_SubscriberExists(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Alerts_SubscriberExists};
				n = "Alerts.SubscriberExists";
			}

			public override string Test()
			{
				p.w.SubscriberExists(p.u.Puid); 
				return null;
			}
		}
		#endregion

		#region Alerts.Subscribe
		class Alerts_Subscribe : ValidationRoutine
		{
			public Alerts_Subscribe(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Alerts_Subscribe};
				n = "Alerts.Subscribe";
			}

			public override string Test()
			{
				AddSubscriptions a = new AddSubscriptions();
				a.contentSubscriptions = new AlertSubscription[1];
				a.contentSubscriptions[0] = new AlertSubscription();
				a.contentSubscriptions[0].locale = "en-US";
				a.contentSubscriptions[0].type = 128;
				a.liveSubscriptions = new AlertSubscription[0];
				p.w.Subscribe(true, p.u.Puid, p.linked, a); 
				return null;
			}
		}
		#endregion

		#region Alerts.EnumerateSubscriptions
		class Alerts_EnumerateSubscriptions : ValidationRoutine
		{
			public Alerts_EnumerateSubscriptions(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Alerts_EnumerateSubscriptions};
				n = "Alerts.EnumerateSubscriptions";
			}

			public override string Test()
			{
				p.w.EnumerateSubscriptions(p.u.Puid, p.linked); 
				return null;
			}
		}
		#endregion

		#region Alerts.ScheduleContentAlert
		class Alerts_ScheduleContentAlert : ValidationRoutine
		{
			public Alerts_ScheduleContentAlert(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Alerts_ScheduleContentAlert};
				n = "Alerts.ScheduleContentAlert";
			}

			public override string Test()
			{
				p.w.ScheduleContentAlert(p.u.Puid, 128, "en-US", "Xbox Live Partner Verification Tool", DateTime.Now.AddYears(-10)); 
				return null;
			}
		}
		#endregion

		#region Alerts.Unsubscribe
		class Alerts_Unsubscribe : ValidationRoutine
		{
			public Alerts_Unsubscribe(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Alerts_Unsubscribe};
				n = "Alerts.Unsubscribe";
			}

			public override string Test()
			{
				ExistingSubscriptions a = new ExistingSubscriptions();
				a.contentSubscriptions = new ContentSubscription[1];
				a.contentSubscriptions[0] = new ContentSubscription();
				a.contentSubscriptions[0].locale = "en-US";
				a.contentSubscriptions[0].subscriptionID = 0;
				a.contentSubscriptions[0].type = 128;
				a.liveSubscriptions = new LiveSubscription[0];
				p.w.Unsubscribe(true, true, p.u.Puid, p.linked, a); 
				return null;
			}
		}
		#endregion

		#region Presence.GetFriends
		class Presence_GetFriends : ValidationRoutine
		{
			public Presence_GetFriends(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Presence_GetFriends};
				n = "Presence.GetFriends";
			}

			public override string Test()
			{
				p.w.GetFriends(p.u.Puid, p.linked); 
				return null;
			}
		}
		#endregion

		#region Stats.GetLBList
		class Stats_GetLBList : ValidationRoutine
		{
			public Stats_GetLBList(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetLBList};
				n = "Stats.GetLBList";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetLBList (no title privileges)";

				StatsLBList lbs;
				if(p.tl == null || p.tl.info == null)
				{
					lbs = p.w.GetLBList(p.tid);
					if(lbs.info.Length > 0)
					{
						p.lbtid = p.tid;
						p.lbid = lbs.info[0].LBID;
					}
				}
				else
				{
					foreach(TitlePrivilegeInfo tpi in p.tl.info)
					{
						if(tpi.Privileges != TitlePrivilege.None)
						{
							lbs = p.w.GetLBList(tpi.TitleID);
							if(lbs.info.Length > 0)
							{
								p.lbtid = tpi.TitleID;
								p.lbid = lbs.info[0].LBID;
								break;
							}
						}
					}
				}
				return null;
			}
		}
		#endregion

		#region Stats.GetLBListByType
		class Stats_GetLBListByType : ValidationRoutine
		{
			public Stats_GetLBListByType(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetLBListByType};
				n = "Stats.GetLBListByType";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetLBListByType (no title privileges)";

				p.w.GetLBListByType(p.tid, Stats.LBType.RegularTeam);
				return null;
			}
		}
		#endregion;

		#region Stats.EnumerateLB
		class Stats_EnumerateLB : ValidationRoutine
		{
			public Stats_EnumerateLB(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_EnumerateLB};
				n = "Stats.EnumerateLB";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.EnumerateLB (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.EnumerateLB (no titles you have privileges to have leaderboards)";

				p.w.EnumerateLB(p.lbtid, p.lbid, 1, 10);
				return null;
			}
		}
		#endregion;

		#region Stats.EnumerateLBRaw
		class Stats_EnumerateLBRaw : ValidationRoutine
		{
			public Stats_EnumerateLBRaw(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_EnumerateLBRaw};
				n = "Stats.EnumerateLBRaw";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.EnumerateLBRaw (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.EnumerateLBRaw (no titles you have privileges to have leaderboards)";

				p.w.EnumerateLBRaw(p.lbtid, p.lbid, 1, 10);
				return null;
			}
		}
		#endregion;

		#region Stats.GetLBNearGamerTag
		class Stats_GetLBNearGamerTag : ValidationRoutine
		{
			public Stats_GetLBNearGamerTag(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetLBNearGamerTag};
				n = "Stats.GetLBNearGamerTag";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetLBNearGamerTag (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.GetLBNearGamerTag (no titles you have privileges to have leaderboards)";

				p.w.GetLBNearGamerTag(p.lbtid, p.lbid, p.linked, 5, 5);
				return null;
			}
		}
		#endregion;

		#region Stats.GetLBDetailsForGamerTags
		class Stats_GetLBDetailsForGamerTags : ValidationRoutine
		{
			public Stats_GetLBDetailsForGamerTags(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetLBDetailsForGamerTags};
				n = "Stats.GetLBDetailsForGamerTags";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetLBDetailsForGamerTags (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.GetLBDetailsForGamerTags (no titles you have privileges to have leaderboards)";

				string[] gtarray = new string[1];
				gtarray[0] = p.linked;
				p.w.GetLBDetailsForGamerTags(p.lbtid, p.lbid, gtarray);
				return null;
			}
		}
		#endregion;

		#region Stats.GetLBForGamerTags
		class Stats_GetLBForGamerTags : ValidationRoutine
		{
			public Stats_GetLBForGamerTags(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetLBForGamerTags};
				n = "Stats.GetLBForGamerTags";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetLBForGamerTags (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.GetLBForGamerTags (no titles you have privileges to have leaderboards)";

				string[] gtarray = new string[1];
				gtarray[0] = p.linked;
				p.w.GetLBForGamerTags(p.lbtid, p.lbid, gtarray);
				return null;
			}
		}
		#endregion;

		#region Stats.EnumerateTeamLB
		class Stats_EnumerateTeamLB : ValidationRoutine
		{
			public Stats_EnumerateTeamLB(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_EnumerateTeamLB};
				n = "Stats.EnumerateTeamLB";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.EnumerateTeamLB (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.EnumerateTeamLB (no titles you have privileges to have leaderboards)";

				p.w.EnumerateTeamLB(p.lbtid, p.lbid, 1, 10);
				return null;
			}
		}
		#endregion;

		#region Stats.GetTeamLBForTeamNames
		class Stats_GetTeamLBForTeamNames : ValidationRoutine
		{
			public Stats_GetTeamLBForTeamNames(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetTeamLBForTeamNames};
				n = "Stats.GetTeamLBForTeamNames";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetTeamLBForTeamNames (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.GetTeamLBForTeamNames (no titles you have privileges to have leaderboards)";


				string[] gtarray = new string[1];
				gtarray[0] = p.linked;
				p.w.GetTeamLBForTeamNames(p.lbtid, p.lbid, gtarray);
				return null;
			}
		}
		#endregion;

		#region Stats.GetTeamLBNearTeamName
		class Stats_GetTeamLBNearTeamName : ValidationRoutine
		{
			public Stats_GetTeamLBNearTeamName(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetTeamLBNearTeamName};
				n = "Stats.GetTeamLBNearTeamName";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetTeamLBNearTeamName (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.GetTeamLBNearTeamName (no titles you have privileges to have leaderboards)";

				p.w.GetTeamLBNearTeamName(p.lbtid, p.lbid, p.linked, 5, 5);
				return null;
			}
		}
		#endregion;

		#region Stats.GetTeamLBDetailsForTeamNames
		class Stats_GetTeamLBDetailsForTeamNames : ValidationRoutine
		{
			public Stats_GetTeamLBDetailsForTeamNames(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Stats_GetTeamLBDetailsForTeamNames};
				n = "Stats.GetTeamLBDetailsForTeamNames";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Stats.GetTeamLBDetailsForTeamNames (no title privileges)";

				if(p.lbtid == 0xFFFFFFFF)
					return "Stats.GetTeamLBDetailsForTeamNames (no titles you have privileges to have leaderboards)";


				string[] gtarray = new string[1];
				gtarray[0] = p.linked;
				p.w.GetTeamLBDetailsForTeamNames(p.lbtid, p.lbid, gtarray);
				return null;
			}
		}
		#endregion;

        //#region Stats.GetUnitsForGamerTag
        //class Stats_GetUnitsForGamerTag : ValidationRoutine
        //{
        //    public Stats_GetUnitsForGamerTag(Tests t) : base(t)
        //    {
        //        a = new APIInfo [] {APIInfo.Stats_GetUnitsForGamerTag};
        //        n = "Stats.GetUnitsForGamerTag";
        //    }

        //    public override string Test()
        //    {
        //        if(p.tidPrivs == TitlePrivilege.None)
        //            return "Stats.GetUnitsForGamerTag (no title privileges)";

        //        if(p.lbtid == 0xFFFFFFFF)
        //            return "Stats.GetUnitsForGamerTag (no titles you have privileges to have leaderboards)";

        //        p.w.GetUnitsForGamerTag(p.lbtid, p.lbid, Stats.UnitSortOrder.Activity, p.linked, 10);
        //        return null;
        //    }
        //}
        //#endregion;

        //#region Stats.GetUnitForGamerTags
        //class Stats_GetUnitForGamerTags : ValidationRoutine
        //{
        //    public Stats_GetUnitForGamerTags(Tests t) : base(t)
        //    {
        //        a = new APIInfo [] {APIInfo.Stats_GetUnitForGamerTags};
        //        n = "Stats.GetUnitForGamerTags";
        //    }

        //    public override string Test()
        //    {
        //        if(p.tidPrivs == TitlePrivilege.None)
        //            return "Stats.GetUnitForGamerTags (no title privileges)";

        //        if(p.lbtid == 0xFFFFFFFF)
        //            return "Stats.GetUnitForGamerTags (no titles you have privileges to have leaderboards)";

        //        string[] gtarray = new string[2];
        //        gtarray[0] = p.linked;
        //        gtarray[1] = p.linked + "2";
        //        p.w.GetUnitForGamerTags(p.lbtid, p.lbid, gtarray);
        //        return null;
        //    }
        //}
        //#endregion;

        //#region Stats.GetUnitsForTeamName
        //class Stats_GetUnitsForTeamName : ValidationRoutine
        //{
        //    public Stats_GetUnitsForTeamName(Tests t) : base(t)
        //    {
        //        a = new APIInfo [] {APIInfo.Stats_GetUnitsForTeamName};
        //        n = "Stats.GetUnitsForTeamName";
        //    }

        //    public override string Test()
        //    {
        //        if(p.tidPrivs == TitlePrivilege.None)
        //            return "Stats.GetUnitsForTeamName (no title privileges)";

        //        if(p.lbtid == 0xFFFFFFFF)
        //            return "Stats.GetUnitsForTeamName (no titles you have privileges to have leaderboards)";

        //        p.w.GetUnitsForTeamName(p.lbtid, p.lbid, Stats.UnitSortOrder.Activity, p.linked, 10);
        //        return null;
        //    }
        //}
        //#endregion;

        //#region Stats.GetUnitForTeamNames
        //class Stats_GetUnitForTeamNames : ValidationRoutine
        //{
        //    public Stats_GetUnitForTeamNames(Tests t) : base(t)
        //    {
        //        a = new APIInfo [] {APIInfo.Stats_GetUnitForTeamNames};
        //        n = "Stats.GetUnitForTeamNames";
        //    }

        //    public override string Test()
        //    {
        //        if(p.tidPrivs == TitlePrivilege.None)
        //            return "Stats.GetUnitForTeamNames (no title privileges)";

        //        if(p.lbtid == 0xFFFFFFFF)
        //            return "Stats.GetUnitForTeamNames (no titles you have privileges to have leaderboards)";

        //        string[] gtarray = new string[2];
        //        gtarray[0] = p.linked;
        //        gtarray[1] = p.linked + "2";
        //        p.w.GetUnitForTeamNames(p.lbtid, p.lbid, gtarray);
        //        return null;
        //    }
        //}
        //#endregion;

		#region Signature.CreateSignature
		class Signature_CreateSignature : ValidationRoutine
		{
			public Signature_CreateSignature(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Signature_CreateSignature};
				n = "Signature.CreateSignature";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Signature.CreateSignature (no title privileges)";

				p.sigRes = p.w.CreateSignature(p.tid, "XLVerify", p.sigReq);
				return null;
			}
		}
		#endregion;

		#region Signature.VerifySignature
		class Signature_VerifySignature : ValidationRoutine
		{
			public Signature_VerifySignature(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Signature_VerifySignature};
				n = "Signature.VerifySignature";
			}

			public override string Test()
			{
				XSigVerifySignatureRequest [] req = new XSigVerifySignatureRequest[1];
				req[0] = new XSigVerifySignatureRequest();
				req[0]._digest = p.sigReq[0]._digest;
				req[0]._signature = p.sigRes[0]._signature;
				uint [] results = p.w.VerifySignature(req);
				return null;
			}
		}
		#endregion;

        //#region UserAccount.UnlinkGamerTag
        //class UserAccount_UnlinkGamerTag : ValidationRoutine
        //{
        //    public UserAccount_UnlinkGamerTag(Tests t) : base(t)
        //    {
        //        a = new APIInfo [] {APIInfo.UserAccount_UnlinkGamerTag};
        //        n = "UserAccount.UnlinkGamerTag";
        //    }

        //    public override string Test()
        //    {
        //        p.w.UnlinkGamerTag(p.u.Puid, p.linked); 
        //        return null;
        //    }
        //}
        //#endregion

		#region Messaging.EnumMessages
		class Messaging_EnumMessages : ValidationRoutine
		{
			public Messaging_EnumMessages(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_EnumMessages};
				n = "Messaging.EnumMessages";
			}

			public override string Test()
			{

				WCMessageSummary [] summ;
				p.w.EnumMessages(p.u.Puid, p.linked, out summ); 
				return null;
			}
		}
		#endregion

		#region Messaging.GetMessageDetails
		class Messaging_GetMessageDetails : ValidationRoutine
		{
			public Messaging_GetMessageDetails(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_GetMessageDetails};
				n = "Messaging.GetMessageDetails";
			}

			public override string Test()
			{

				WCMessageSummary summ;
				WCMessageDetails details;
				p.w.GetMessageDetails(p.u.Puid, p.linked, 1, 0, 0, out summ, out details); 
				return null;
			}
		}
		#endregion

		#region Messaging.SendMessage
		class Messaging_SendMessage : ValidationRoutine
		{
			public Messaging_SendMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_SendMessage};
				n = "Messaging.SendMessage";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Messaging.SendMessage (no title privileges)";
				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp[1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 201;
				details.StringProp[0].Value = "Xbox Live Partner Verification Tool";
				WCRecipientResult [] recips;
				string[] gtarray = new string[1];
				gtarray[0] = p.linked;
				p.w.SendMessage(p.u.Puid, p.linked, 0, 0, p.tid, 10, WCMessageType.TitleCustom, gtarray, details, new WCMessageAttachment[0], out recips); 
				return null;
			}
		}
		#endregion

		#region Messaging.DeleteMessage
		class Messaging_DeleteMessage : ValidationRoutine
		{
			public Messaging_DeleteMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_DeleteMessage};
				n = "Messaging.DeleteMessage";
			}

			public override string Test()
			{
				p.w.DeleteMessage(p.u.Puid, p.linked, 1, 0); 
				return null;
			}
		}
		#endregion

		#region Messaging.EnumUserTitles
		class Messaging_EnumUserTitles : ValidationRoutine
		{
			public Messaging_EnumUserTitles(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_EnumUserTitles};
				n = "Messaging.EnumUserTitles";
			}

			public override string Test()
			{
				WCUserTitle [] titles;
				p.w.EnumUserTitles(p.u.Puid, p.linked, out titles); 
				return null;
			}
		}
		#endregion

		#region Messaging.RevokeMessage
		class Messaging_RevokeMessage : ValidationRoutine
		{
			public Messaging_RevokeMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_RevokeMessage};
				n = "Messaging.RevokeMessage";
			}

			public override string Test()
			{
				WCRecipientResult [] recips = new WCRecipientResult[1];
				recips[0] = new WCRecipientResult();
				recips[0].MessageID = 1;
				recips[0].User = p.linked;
				p.w.RevokeMessage(p.u.Puid, p.linked, recips); 
				return null;
			}
		}
		#endregion

		#region Messaging.DeleteUserTitle
		class Messaging_DeleteUserTitle : ValidationRoutine
		{
			public Messaging_DeleteUserTitle(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_DeleteUserTitle};
				n = "Messaging.DeleteUserTitle";
			}

			public override string Test()
			{
				p.w.DeleteUserTitle(p.u.Puid, p.linked, p.tid); 
				return null;
			}
		}
		#endregion

		#region Messaging.SetMessageFlags
		class Messaging_SetMessageFlags : ValidationRoutine
		{
			public Messaging_SetMessageFlags(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_SetMessageFlags};
				n = "Messaging.SetMessageFlags";
			}

			public override string Test()
			{
				p.w.SetMessageFlags(p.u.Puid, p.linked, 1, 0, 0); 
				return null;
			}
		}
		#endregion

		#region Messaging.EnumTitleWideMessages
		class Messaging_EnumTitleWideMessages : ValidationRoutine
		{
			public Messaging_EnumTitleWideMessages(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_EnumTitleWideMessages};
				n = "Messaging.EnumTitleWideMessages";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Messaging.EnumTitleWideMessages (no title privileges)";
				WCTitleWideMessageSummary [] summary;
				p.w.EnumTitleWideMessages(p.tid, out summary); 
				return null;
			}
		}
		#endregion

		#region Messaging.GetTitleWideMessageDetails
		class Messaging_GetTitleWideMessageDetails : ValidationRoutine
		{
			public Messaging_GetTitleWideMessageDetails(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_GetTitleWideMessageDetails};
				n = "Messaging.GetTitleWideMessageDetails";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Messaging.GetTitleWideMessageDetails (no title privileges)";
				WCTitleWideMessageSummary summary;
				WCMessageDetails details;
				p.w.GetTitleWideMessageDetails(p.tid, 1, out summary, out details); 
				return null;
			}
		}
		#endregion

		#region Messaging.DeleteTitleWideMessage
		class Messaging_DeleteTitleWideMessage : ValidationRoutine
		{
			public Messaging_DeleteTitleWideMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_DeleteTitleWideMessage};
				n = "Messaging.DeleteTitleWideMessage";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Messaging.DeleteTitleWideMessage (no title privileges)";
				p.w.DeleteTitleWideMessage(p.tid, 1, 0); 
				return null;
			}
		}
		#endregion

		#region Messaging.SendTitleWideMessage
		class Messaging_SendTitleWideMessage : ValidationRoutine
		{
			public Messaging_SendTitleWideMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_SendTitleWideMessage};
				n = "Messaging.SendTitleWideMessage";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Messaging.SendTitleWideMessage (no title privileges)";
				ushort delay;
				uint messageid;
				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp[1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 201;
				details.StringProp[0].Value = "Xbox Live Partner Verification Tool";
				WCLocalizedString [] langstring = new WCLocalizedString[1];
				langstring[0] = new WCLocalizedString();
				langstring[0].DefaultLocale = "en-US";
				langstring[0].PropID = 250;
				langstring[0].LangString = new WCLanguageString[1];
				langstring[0].LangString[0] = new WCLanguageString();
				langstring[0].LangString[0].Locale = "en-US";
				langstring[0].LangString[0].String = "Xbox Live Partner Verification Tool String";
				p.w.SendTitleWideMessage("XLVerify", 0, DateTime.Now.AddDays(1), 0, 0, p.tid, 10, WCMessageType.TitleCustom, "Xbox Live Partner Verification Tool", details, langstring, new WCMessageAttachment[0], out delay, out messageid); 
				return null;
			}
		}
		#endregion

		#region Messaging.SendTitleUserMessage
		class Messaging_SendTitleUserMessage : ValidationRoutine
		{
			public Messaging_SendTitleUserMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_SendTitleUserMessage};
				n = "Messaging.SendTitleUserMessage";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Messaging.SendTitleUserMessage (no title privileges)";
				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp[1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 201;
				details.StringProp[0].Value = "Xbox Live Partner Verification Tool";
				WCRecipientResult [] recips;
				string[] gtarray = new string[1];
				gtarray[0] = p.linked;
				p.w.SendTitleUserMessage("XLVerify", 0, 0, p.tid, 10, WCMessageType.TitleCustom, gtarray, details, new WCMessageAttachment[0], out recips);
				return null;
			}
		}
		#endregion

		#region Messaging.RevokeTitleUserMessage
		class Messaging_RevokeTitleUserMessage : ValidationRoutine
		{
			public Messaging_RevokeTitleUserMessage(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_RevokeTitleUserMessage};
				n = "Messaging.RevokeTitleUserMessage";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Messaging.RevokeTitleUserMessage (no title privileges)";
				WCMessageDetails details = new WCMessageDetails();
				WCRecipientResult [] recips = new WCRecipientResult[1];
				recips[0] = new WCRecipientResult();
				recips[0].MessageID = 1;
				recips[0].User = p.linked;
				p.w.RevokeTitleUserMessage(recips);
				return null;
			}
		}
		#endregion

		#region Messaging.GetMessageString
		class Messaging_GetMessageString : ValidationRoutine
		{
			public Messaging_GetMessageString(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Messaging_GetMessageString};
				n = "Messaging.GetMessageString";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Messaging.GetMessageString (no title privileges)";
				p.w.GetMessageString(p.tid, 1, "en-US");
				return null;
			}
		}
		#endregion

		#region Query.GetXQSConfig
		class Query_GetXQSConfig : ValidationRoutine
		{
			public Query_GetXQSConfig(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_GetXQSConfig};
				n = "Query.GetXQSConfig";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.GetXQSConfig (no title privileges)";
				p.w.GetXQSConfig(p.tid, p.u.Puid, 0);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionCreate
		class Query_CompetitionCreate : ValidationRoutine
		{
			public Query_CompetitionCreate(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionCreate};
				n = "Query.CompetitionCreate";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.CompetitionCreate (no title privileges)";

				p.w.CompetitionCreate(p.tid, p.u.Puid, p.linked, "XLVerify", 1, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionCreateSingleElimination
		class Query_CompetitionCreateSingleElimination : ValidationRoutine
		{
			public Query_CompetitionCreateSingleElimination(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionCreateSingleElimination};
				n = "Query.CompetitionCreateSingleElimination";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.CompetitionCreateSingleElimination (no title privileges)";

				p.w.CompetitionCreateSingleElimination(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 4, 4, 4, DateTime.Now, DateTime.Now.AddDays(1), DateTime.Now.AddHours(6), DateTime.Now.AddHours(8), DateTime.Now.AddHours(9), 10, 0, 5, false, 0, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionManageEntrant
		class Query_CompetitionManageEntrant : ValidationRoutine
		{
			public Query_CompetitionManageEntrant(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionManageEntrant};
				n = "Query.CompetitionManageEntrant";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.CompetitionManageEntrant (no title privileges)";

				p.w.CompetitionManageEntrant(p.tid, p.u.Puid, p.linked, 0, "XLVerify", 1, 10, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionCancel
		class Query_CompetitionCancel : ValidationRoutine
		{
			public Query_CompetitionCancel(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionCancel};
				n = "Query.CompetitionCancel";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.CompetitionCancel (no title privileges)";

				p.w.CompetitionCancel(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 10);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionSearch
		class Query_CompetitionSearch : ValidationRoutine
		{
			public Query_CompetitionSearch(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionSearch};
				n = "Query.CompetitionSearch";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.CompetitionSearch (no title privileges)";

				p.w.CompetitionSearch(p.tid, 1, 1, 4, 20, new QueryAttributeSpec[0], new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionTopology
		class Query_CompetitionTopology : ValidationRoutine
		{
			public Query_CompetitionTopology(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionTopology};
				n = "Query.CompetitionTopology";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.CompetitionTopology (no title privileges)";

				p.w.CompetitionTopology(p.tid, 1, 10, 4, 20, 4, 6, new QueryAttributeSpec[0]);
				return null;
			}
		}
		#endregion

		#region Query.CompetitionTopologySingleElimination
		class Query_CompetitionTopologySingleElimination : ValidationRoutine
		{
			public Query_CompetitionTopologySingleElimination(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_CompetitionTopologySingleElimination};
				n = "Query.CompetitionTopologySingleElimination";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.CompetitionTopologySingleElimination (no title privileges)";

				p.w.CompetitionTopologySingleElimination(p.tid, 1, 10, 4, 20, 4, 6, new QueryAttributeSpec[0]);
				return null;
			}
		}
		#endregion

		#region Query.Add
		class Query_Add : ValidationRoutine
		{
			public Query_Add(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_Add};
				n = "Query.Add";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.Add (no title privileges)";

				p.w.Add(p.tid, p.u.Puid, p.linked, "XLVerify", 1, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.Update
		class Query_Update : ValidationRoutine
		{
			public Query_Update(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_Update};
				n = "Query.Update";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.Update (no title privileges)";

				p.w.Update(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 4, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.UpdateId
		class Query_UpdateId : ValidationRoutine
		{
			public Query_UpdateId(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_UpdateId};
				n = "Query.UpdateId";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.UpdateId (no title privileges)";

				p.w.UpdateId(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 4, 10, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.Remove
		class Query_Remove : ValidationRoutine
		{
			public Query_Remove(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_Remove};
				n = "Query.Remove";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.Remove (no title privileges)";

				p.w.Remove(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 10, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.RemoveId
		class Query_RemoveId : ValidationRoutine
		{
			public Query_RemoveId(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_RemoveId};
				n = "Query.RemoveId";
			}

			public override string Test()
			{
				if(p.tidPrivs != TitlePrivilege.ReadWrite && p.tidPrivs != TitlePrivilege.FullControl)
					return "Query.RemoveId (no title privileges)";

				p.w.RemoveId(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 4);
				return null;
			}
		}
		#endregion

		#region Query.Search
		class Query_Search : ValidationRoutine
		{
			public Query_Search(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_Search};
				n = "Query.Search";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.Search (no title privileges)";

				p.w.Search(p.tid, 1, 10, 4, 10, new QueryAttributeSpec[0], new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.Select
		class Query_Select : ValidationRoutine
		{
			public Query_Select(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_Select};
				n = "Query.Select";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.Select (no title privileges)";

				p.w.Select(p.tid, p.u.Puid, p.linked, "XLVerify", 1, 4, 0, new QueryAttribute[0]);
				return null;
			}
		}
		#endregion

		#region Query.FindFromIds
		class Query_FindFromIds : ValidationRoutine
		{
			public Query_FindFromIds(Tests t) : base(t)
			{
				a = new APIInfo [] {APIInfo.Query_FindFromIds};
				n = "Query.FindFromIds";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Query.FindFromIds (no title privileges)";

				p.w.FindFromIds(p.tid, 1, 10, new QueryAttributeSpec[0], new ulong[0]);
				return null;
			}
		}
		#endregion

		#region LSP.GetSiteInfo
		class LSP_GetSiteInfo : ValidationRoutine
		{
			public LSP_GetSiteInfo(Tests t) : base(t)
			{
				n = "LiveProxy.GetSiteInfo";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.GetSiteInfo (no title privileges)";

				p.w.GetSiteInfo(p.tid);
				return null;
			}
		}
		#endregion

		#region LSP.LookupGamerTags
		class LSP_LookupGamerTags : ValidationRoutine
		{
			public LSP_LookupGamerTags(Tests t) : base(t)
			{
				n = "LiveProxy.LookupGamerTags";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.LookupGamerTags (no title privileges)";

				string [] gtarray = new string [] {p.linked};
				p.w.LookupGamerTags(gtarray);
				return null;
			}
		}
		#endregion

		#region LSP.LookupPuids
		class LSP_LookupPuids : ValidationRoutine
		{
			public LSP_LookupPuids(Tests t) : base(t)
			{
				n = "LiveProxy.LookupPuids";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.LookupPuids (no title privileges)";

				ulong u, v;
				v = 2048;
				v *= 1024 * 1024;
				int i = p.rand.Next();
				u = ((i < 0) ? (((ulong) -i) + v) : (ulong) i);
				u <<= 32;
				i = p.rand.Next();
				u += ((i < 0) ? (((ulong) -i) + v) : (ulong) i);
				ulong [] gtarray = new ulong [] {u};
				p.w.LookupPuids(gtarray);
				return null;
			}
		}
		#endregion

		#region LSP.GetSitePuids
		class LSP_GetSitePuids : ValidationRoutine
		{
			public LSP_GetSitePuids(Tests t) : base(t)
			{
				n = "LiveProxy.GetSitePuids";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.GetSitePuids (no title privileges)";

				ulong MachinePuid, UserPuid;
				p.w.GetSitePuids(out MachinePuid, out UserPuid);
				return null;
			}
		}
		#endregion

		#region LSP.MatchHost
		class LSP_MatchHost : ValidationRoutine
		{
			public LSP_MatchHost(Tests t) : base(t)
			{
				n = "LiveProxy.MatchHost";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.MatchHost (no title privileges)";

				p.w.MatchHost(p.tid);
				return null;
			}
		}
		#endregion

		#region LSP.MatchHostDelete
		class LSP_MatchHostDelete : ValidationRoutine
		{
			public LSP_MatchHostDelete(Tests t) : base(t)
			{
				n = "LiveProxy.MatchHostDelete";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.MatchHostDelete (no title privileges)";

				p.w.MatchHostDelete(p.tid);
				return null;
			}
		}
		#endregion

		#region LSP.QueryAdd
		class LSP_QueryAdd : ValidationRoutine
		{
			public LSP_QueryAdd(Tests t) : base(t)
			{
				n = "LiveProxy.QueryAdd";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.QueryAdd (no title privileges)";

				p.w.QueryAdd(p.tid);
				return null;
			}
		}
		#endregion

		#region LSP.QueryRemove
		class LSP_QueryRemove : ValidationRoutine
		{
			public LSP_QueryRemove(Tests t) : base(t)
			{
				n = "LiveProxy.QueryRemove";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "LiveProxy.QueryRemove (no title privileges)";

				p.w.QueryRemove(p.tid);
				return null;
			}
		}
		#endregion

		#region Storage.GetTitleQuota
		class Storage_GetTitleQuota : ValidationRoutine
		{
			public Storage_GetTitleQuota(Tests t) : base(t)
			{
				n = "Storage.GetTitleQuota";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.GetTitleQuota (no title privileges)";

				p.w.GetTitleQuota(p.tid);
				return null;
			}
		}
		#endregion

		#region Storage.EnumerateTitleFiles
		class Storage_EnumerateTitleFiles : ValidationRoutine
		{
			public Storage_EnumerateTitleFiles(Tests t) : base(t)
			{
				n = "Storage.EnumerateTitleFiles";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.EnumerateTitleFiles (no title privileges)";

				p.w.EnumerateTitleFiles(p.tid, "*", DateTime.MinValue);
				return null;
			}
		}
		#endregion

		#region Storage.WriteTitleFile
		class Storage_WriteTitleFile : ValidationRoutine
		{
			static byte [] b = new byte[] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF};
			public Storage_WriteTitleFile(Tests t) : base(t)
			{
				n = "Storage.WriteTitleFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.WriteTitleFile (no title privileges)";

				p.w.WriteTitleFile(p.tid, "VerifyPartner.txt", FileContentTypeEnum.Blob, b, DateTime.UtcNow.AddDays(1));
				return null;
			}
		}
		#endregion

		#region Storage.ReadTitleFile
		class Storage_ReadTitleFile : ValidationRoutine
		{
			public Storage_ReadTitleFile(Tests t) : base(t)
			{
				n = "Storage.ReadTitleFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.ReadTitleFile (no title privileges)";

				p.w.ReadTitleFile(p.tid, "VerifyPartner.txt", DateTime.MinValue);
				return null;
			}
		}
		#endregion

		#region Storage.RevokeTitleFile
		class Storage_RevokeTitleFile : ValidationRoutine
		{
			public Storage_RevokeTitleFile(Tests t) : base(t)
			{
				n = "Storage.RevokeTitleFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.RevokeTitleFile (no title privileges)";

				p.w.RevokeTitleFile(p.tid, "VerifyPartner.txt");
				return null;
			}
		}
		#endregion

		#region Storage.DeleteTitleFile
		class Storage_DeleteTitleFile : ValidationRoutine
		{
			public Storage_DeleteTitleFile(Tests t) : base(t)
			{
				n = "Storage.DeleteTitleFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.DeleteTitleFile (no title privileges)";

				p.w.DeleteTitleFile(p.tid, "VerifyPartner.txt");
				return null;
			}
		}
		#endregion

		#region Storage.WriteUserFile
		class Storage_WriteUserFile : ValidationRoutine
		{
			static byte [] b = new byte[] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF};
			public Storage_WriteUserFile(Tests t) : base(t)
			{
				n = "Storage.WriteUserFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.WriteUserFile (no title privileges)";

				p.w.WriteUserFile(p.tid, p.u.Puid, p.linked, "VerifyPartner.txt", FileContentTypeEnum.Blob, b, DateTime.UtcNow.AddDays(1));
				return null;
			}
		}
		#endregion

		#region Storage.ReadUserFile
		class Storage_ReadUserFile : ValidationRoutine
		{
			public Storage_ReadUserFile(Tests t) : base(t)
			{
				n = "Storage.ReadUserFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.ReadUserFile (no title privileges)";

				p.w.ReadUserFile(p.tid, p.u.Puid, p.linked, "VerifyPartner.txt", DateTime.MinValue);
				return null;
			}
		}
		#endregion

		#region Storage.RevokeUserFile
		class Storage_RevokeUserFile : ValidationRoutine
		{
			public Storage_RevokeUserFile(Tests t) : base(t)
			{
				n = "Storage.RevokeUserFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.RevokeUserFile (no title privileges)";

				p.w.RevokeUserFile(p.tid, p.u.Puid, p.linked, "VerifyPartner.txt");
				return null;
			}
		}
		#endregion

		#region Storage.DeleteUserFile
		class Storage_DeleteUserFile : ValidationRoutine
		{
			public Storage_DeleteUserFile(Tests t) : base(t)
			{
				n = "Storage.DeleteUserFile";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Storage.DeleteUserFile (no title privileges)";

				p.w.DeleteUserFile(p.tid, p.u.Puid, p.linked, "VerifyPartner.txt");
				return null;
			}
		}
		#endregion

		#region Teams.CreateTeam
		class Teams_CreateTeam : ValidationRoutine
		{
			public Teams_CreateTeam(Tests t) : base(t)
			{
				n = "Teams.CreateTeam";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.CreateTeam (no title privileges)";

				p.w.CreateTeam(p.tid, p.u.Puid, p.linked, "VerifyPartner", 4, "Team for verifying permissions", "Break IT!", "http://www.xbox.com", new byte[0], new byte[0]);
				return null;
			}
		}
		#endregion

		#region Teams.DeleteTeam
		class Teams_DeleteTeam : ValidationRoutine
		{
			public Teams_DeleteTeam(Tests t) : base(t)
			{
				n = "Teams.DeleteTeam";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.DeleteTeam (no title privileges)";

				p.w.DeleteTeam(p.tid, p.u.Puid, p.linked, "VerifyPartner");
				return null;
			}
		}
		#endregion

		#region Teams.ManageTeam
		class Teams_ManageTeam : ValidationRoutine
		{
			public Teams_ManageTeam(Tests t) : base(t)
			{
				n = "Teams.ManageTeam";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.ManageTeam (no title privileges)";

				p.w.ManageTeam(p.tid, p.u.Puid, p.linked, "VerifyPartner", "VerifyPartner2", "Still testing partner permissions", "Break IT2!", "http://www.microsoft.com", new byte[0]);
				return null;
			}
		}
		#endregion

		#region Teams.GetTeamInfo
		class Teams_GetTeamInfo : ValidationRoutine
		{
			public Teams_GetTeamInfo(Tests t) : base(t)
			{
				n = "Teams.GetTeamInfo";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.GetTeamInfo (no title privileges)";

				p.w.GetTeamInfo(p.tid, p.u.Puid, p.linked, "VerifyPartner");
				return null;
			}
		}
		#endregion

		#region Teams.GetTeamMembers
		class Teams_GetTeamMembers : ValidationRoutine
		{
			public Teams_GetTeamMembers(Tests t) : base(t)
			{
				n = "Teams.GetTeamMembers";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.GetTeamMembers (no title privileges)";

				p.w.GetTeamMembers(p.tid, p.u.Puid, p.linked, "VerifyPartner");
				return null;
			}
		}
		#endregion

		#region Teams.RecruitTeamMember
		class Teams_RecruitTeamMember : ValidationRoutine
		{
			public Teams_RecruitTeamMember(Tests t) : base(t)
			{
				n = "Teams.RecruitTeamMember";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.RecruitTeamMember (no title privileges)";

				p.w.RecruitTeamMember(p.tid, p.u.Puid, p.linked, "VerifyPartner", p.linked + "2", 1, new byte[0]);
				return null;
			}
		}
		#endregion

		#region Teams.ManageTeamMember
		class Teams_ManageTeamMember : ValidationRoutine
		{
			public Teams_ManageTeamMember(Tests t) : base(t)
			{
				n = "Teams.ManageTeamMember";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.ManageTeamMember (no title privileges)";

				p.w.ManageTeamMember(p.tid, p.u.Puid, p.linked, "VerifyPartner", p.linked + "2", 2, new byte[0]);
				return null;
			}
		}
		#endregion

		#region Teams.JoinTeam
		class Teams_JoinTeam : ValidationRoutine
		{
			public Teams_JoinTeam(Tests t) : base(t)
			{
				n = "Teams.JoinTeam";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.JoinTeam (no title privileges)";

				p.w.JoinTeam(p.tid, p.u.Puid, p.linked, "VerifyPartner", 1);
				return null;
			}
		}
		#endregion

		#region Teams.RemoveTeamMember
		class Teams_RemoveTeamMember : ValidationRoutine
		{
			public Teams_RemoveTeamMember(Tests t) : base(t)
			{
				n = "Teams.RemoveTeamMember";
			}

			public override string Test()
			{
				if(p.tidPrivs == TitlePrivilege.None)
					return "Teams.RemoveTeamMember (no title privileges)";

				p.w.RemoveTeamMember(p.tid, p.u.Puid, p.linked, "VerifyPartner", p.linked + "2");
				return null;
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\SpiderNetwork.cs ===
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Net;
using System.Diagnostics;
using System.Net.Sockets;
using System.Threading;

namespace WebSgEngine {

    public struct SPIDER_PROTOCOL {
	
        public string szSpiderName;
        public string szSpiderServerIp;
        public string szIP;
        public int    iPort;
    }

    public class Spider {
        const string TESTCASE_CASE_BEGIN         = "[CASE %d BEGIN]\n";
        const string TESTCASE_CASE_END           = "[CASE %d END]\n";
        //string g_szDriverFilename = "SpiderNetwork.ini";

 
        public static SPIDER_PROTOCOL [] LoadServers( string szDriverFilename ){
            /*++
             Copyright (c) 2001-2003, Microsoft.

                Author:  Wally W. Ho (wallyho)
                Date:    05/22/2003
                Routine Description:
                Arguments:
                Return Value:
                  BOOL indicating success or failure (TRUE/ FALSE)
            --*/
            
            bool b = false;
            string szLineParserBuffer;
            Regex r = new Regex(" +"); 
            string[] szStrings;
            StreamReader srReadConfig = null;
            SPIDER_PROTOCOL [] pspArray = new SPIDER_PROTOCOL[50];
            uint i = 0;
            try {
                //Walk down the Sample File to the Case Specified.
                srReadConfig = new StreamReader(szDriverFilename, false );
                // Read out the data.
                while (( szLineParserBuffer = srReadConfig.ReadLine()) != null){
                    szStrings = r.Split(szLineParserBuffer);
                    SPIDER_PROTOCOL psp = new SPIDER_PROTOCOL();
                    if ( -1 != szLineParserBuffer.IndexOf( "SERVER" )){
                        pspArray[i].szSpiderServerIp = szStrings[1];
                        pspArray[i].iPort = Convert.ToInt32(szStrings[2],10);
                        i++;
                    }
                }
                b = true;
            }
            catch (Exception e) { 
                Console.Write("Exception:{0}\n",e.Message.ToString());
            }
            // Catch if its find nothing
            if (b == false){
                Console.WriteLine("Could not find Entry in Driver file\n");
            }
            srReadConfig.Close();
            return pspArray;
        }
 
        public void SpiderServer( ) {
            
            SPIDER_PROTOCOL spider = new SPIDER_PROTOCOL();
            
            NetworkStream stream;
            StreamWriter w;
            StreamReader r;
            string szLineParserBuffer;
           
            try {
                Console.WriteLine("Server Started") ;			
                TcpListener tcpl = new TcpListener(IPAddress.Any, 8888); // listen on port 8888
                tcpl.Start();
                Console.WriteLine("Waiting for clients to connect");
                Console.WriteLine("Press Ctrl+c to Quit...");
                int iProcessId = 0;
                while(true){
                    // Accept will block until someone connects
                    Socket socketForClient = tcpl.AcceptSocket();			
                    if (socketForClient.Connected) {
                        Console.WriteLine("Client connected");
                        stream = new NetworkStream(socketForClient);
                        w = new StreamWriter(stream);
                        r = new StreamReader(stream);
                                
                        szLineParserBuffer = r.ReadLine();
                        Console.WriteLine("Read:" + szLineParserBuffer);
                        socketForClient.Close();        	
                        Regex regexString = new Regex(" +"); 
                        //szCommand=szCommand.ToUpper()+ "!";
                        string [] szCommands = regexString.Split(szLineParserBuffer);
                        switch (szCommands[0]){
                            case "stress" :
                                //w.WriteLine("OK");
                                //Console.WriteLine("Wrote:"+ "OK");
                                //w.Flush();   
                                // use this to start the threads engine.
                                
                                // Kill previous process for new command.
                                Console.WriteLine("REMOTE: Killing {0}", iProcessId);
                                if (0 != iProcessId){
                                    Process x = Process.GetProcessById(iProcessId);            
                                    x.Kill();
                                    iProcessId = 0;
                                }
                                int index = 0;
                                string szArguments = " /substress /threads " + szCommands[1] + 
                                    " " + "/driverfile " + szCommands[2] +
                                    " " + "/packetsize " + szCommands[3];

                                Console.WriteLine("Reloading the Stress program {0}. DATED [{1}]\n ",index++, CommandProcessor.GetTimeDate());
                                System.Threading.Thread.Sleep(4000);
                                //Console.WriteLine("Wrote:{0}", szArguments );
                                Process p = Process.Start("WebSgEngine.exe",szArguments );
                                iProcessId = p.Id;
                                Console.WriteLine("CONSOLE: Process Id {0}",iProcessId);
                                break;
                            case "kill":
                                Console.WriteLine("REMOTE: Killing {0}", iProcessId);
                                if (0 != iProcessId){
                                    Process x = Process.GetProcessById(iProcessId);            
                                    x.Kill();
                                    iProcessId = 0;
                                }
                                break;
                            case "normal":
                                break;          
                            default:
                                break;
                        }
                        r.Close();
                        w.Close();
                    }
                }
                //tcpl.Stop();
            }catch (SocketException socketError) {
                if (socketError.ErrorCode == 10048) {
                    Console.WriteLine("Connection to this port failed.  There is another server is listening on this port.");
                }
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\WebSgMain.cs ===
using System;
using System.Web;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;
using System.Globalization;
using System.Net;
using System.Text;
using System.IO ;



namespace WebSgEngine
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	
    class WebSgMain 
	{
        [STAThread]
		static void Main(string[] args) {
            try{
                //call argument processor.
                CommandProcessor.ArgumentsProcessor( args );
            }
            catch (WebException WebExcp) {
                Console.Write("{0}\n",WebExcp.Message.ToString());
                Console.Write("{0}\n",WebExcp.Response.GetResponseStream()); 
                for( int i = 0; i < 30; i++)
                    Console.Write("Web Exception:{0}{1}\n",i,WebExcp.Response.Headers.Get(i));
            }
            catch (Exception e) { 
                Console.Write("Exception:{0}\n",e.Message.ToString());
            }
        }
        public static void Usage (){
            Console.WriteLine("Usage:");
            Console.WriteLine("     : /Normal   - starts normal test functions.");
            Console.WriteLine("     : /Stress   - starts stress functions.");
            Console.WriteLine("     : /driverfile <testcasefile> - the name of the file with test cases.");
            Console.WriteLine("     : /threads <#> - number of threads to use");
            Console.WriteLine("     : /packetsize <size>  - specifies the packet size to return from the webcache reflector.");
            Console.WriteLine("     : /spiderweb - to put code into listening mode for stressing.");
            Console.WriteLine("     : /spiderman  <threads> - spider manager sends start commands to all clients.");
        }
        public static  void Wally (){
            int iProcessId;
            string szArguments = "/C WebSgEngine.exe /normal";
            Process p = Process.Start("cmd",szArguments );
            iProcessId = p.Id;
            Console.WriteLine("killing {0}", iProcessId);
            Process x = Process.GetProcessById(iProcessId);            
            x.Kill();
        }
    }

   
    
    class CommandProcessor {
        public static bool ArgumentsProcessor( string[] args ) {
            /*++
             Copyright (c) 2001-2003, Microsoft.
                Author:  Wally W. Ho (wallyho)
                Date:    02/28/2003
                Routine Description:
                    Parse up the command line aruguments and react accordingly. 
                    Full command line parser.
                Arguments:
                   Typical arguments to main.
                Return Value:
                  TRUE or FALSE
            --*/
            bool b = true;
            uint PacketSize = 1400;
            int NumberOfThreads = 10;
            bool bKillRemoteProcess = false;
            string szDriverFilename = null;
            //Environment.GetCommandLineArgs
            Console.WriteLine("[{0}]\n ", GetTimeDate());
            
            if (0 == args.Length){ WebSgMain.Usage(); goto c0; }
            
            // Findout if stress is wanted. If so we start new process in case this jams.
            // Do the search right at the beginning as we do not want to fill in any variables
            // if we start the new process.
            
            string szCommand;
            string szArgString = "";
            // Create and argument string.
            foreach ( string sz in args ) 
                szArgString += sz.ToString() + " ";

            foreach ( string szCommandLineUnits in args ) {
                if ((szCommandLineUnits[0] == '-') || (szCommandLineUnits[0] == '/')) {
                    szCommand = szCommandLineUnits.Remove(0,1);
                    szCommand = szCommand.ToLower();
                    if ( true == szCommand.Equals("stress")){
                        // use this to start the threads engine.
                        int index = 0;
                        while (true) {
                            string szArguments = "/C WebSgEngine.exe ";
                            string szCommandSubstitute = szArgString.Replace("/stress","/substress");
                            Console.WriteLine("Reloading the Stress program {0}. DATED [{1}]\n ",index++, GetTimeDate());
                            System.Threading.Thread.Sleep(4000);
                            Process p;
                            p = Process.Start("cmd",szArguments + szCommandSubstitute);
                            p.WaitForExit();
                        }
                    }else if (true == szCommand.Equals("spiderweb")){
                        Spider s = new Spider();
                        s.SpiderServer();
                    }

                }
            }
            // Minor argments settings: Settings of Data variables.
            for( int i = 0; i < args.Length; i++ ){
                string szCommandLineUnits = args[i];
                
                if ((szCommandLineUnits[0] == '-') || (szCommandLineUnits[0] == '/')) {
                    szCommand = szCommandLineUnits.Remove(0,1);
                    szCommand = szCommand.ToLower();
                    
                    if ( true == szCommand.Equals("threads")){
                        szCommandLineUnits = args[i + 1];
                        NumberOfThreads = Convert.ToUInt16(szCommandLineUnits,10);
                    } else
                        if ( true == szCommand.Equals("driverfile")){
                        szCommandLineUnits = args[i + 1];
                        szDriverFilename = szCommandLineUnits;
                    } else
                        if ( true == szCommand.Equals("kill")){
                        bKillRemoteProcess = true;
                    } else
                        if ( true == szCommand.Equals("packetsize")){
                        szCommandLineUnits = args[i + 1];
                        PacketSize = Convert.ToUInt32(szCommandLineUnits,10);
                    } else
                        if ( true == szCommand.Equals("output")){
                        szCommandLineUnits = args[i + 1];
                        //CTestSupport::SetOutputFileName( szCommandLineUnits);
                    } else
                        if ( true == szCommand.Equals("loop")){
                        //CFunctionalTest:: SetNormalLoop(_ttoi( m_szArgv[i+1]));
                    } else
                        if ( true == szCommand.Equals("stresspause")){
                        szCommandLineUnits = args[i + 1];
                        //CStressTest::SetStressPause( Convert.ToUInt16(szCommandLineUnits,10));
                    }
                }
            }
            // Major processing of path to take. Calling the functions 
            // that require data variables to be set already.
            foreach ( string szCommandLineUnits in args ) {
                if ((szCommandLineUnits[0] == '-') || (szCommandLineUnits[0] == '/')) {
                    szCommand = szCommandLineUnits.Remove(0,1);
                    szCommand = szCommand.ToLower();
                    if ( true == szCommand.Equals("substress")){
                        WebSgStressPerformance wss = new WebSgStressPerformance();
                        wss.iNumberThreads = NumberOfThreads; 
                        wss.uiPacketSize = PacketSize; 
                        wss.Stress(szDriverFilename);
                    } else
                        if ( true == szCommand.Equals("normal")){
                        WebSgFunctionals wsf = new WebSgFunctionals();
                        b = wsf.Functionals(szDriverFilename);

                    /*} else
                        if ( true == szCommand.Equals("wally")){
                        Wally();*/
                    } else
                        if ( true == szCommand.Equals("spiderman")){

                        SPIDER_PROTOCOL [] p = Spider.LoadServers("websgengine.ini");
                        foreach (SPIDER_PROTOCOL sp in p){
                            if (null != sp.szSpiderServerIp) {
                         
                                try{
                                    Console.WriteLine("Remoting {0}: [GO!]", sp.szSpiderServerIp );
                                    TcpClient tcpClient = new TcpClient(sp.szSpiderServerIp, sp.iPort);
                                    NetworkStream stream = tcpClient.GetStream();
                                    StreamWriter w = new StreamWriter(stream);
                                    StreamReader r = new StreamReader(stream);
                                    //w.WriteLine("YES");
                                    if (bKillRemoteProcess == true){
                                        w.WriteLine("kill");
                                    }else{
                                        w.WriteLine("stress "+ NumberOfThreads + " " + szDriverFilename + " " + PacketSize );
                                    }

                                    //Console.WriteLine("stress");
                                    //string readline = r.ReadLine();
                                    Console.WriteLine("{0}: [OK]", sp.szSpiderServerIp );
                                    //r.Close();
                                    w.Close();
                                    stream.Close();
                                    tcpClient.Close();
                                }
                                catch (Exception e) { 
                                    Console.Write("Exception:{0}\n",e.Message.ToString());
                                }
                            }
                        }
                    } else
                        if ( true == szCommand.Equals("date")){
                        //ServerWally.date(); 
                    }
                }
            }
            c0:
                return b;
        }

        public static string GetTimeDate( ) {
            string szTodaysDate;
            string szAMPM;
            DateTime x = DateTime.Now;
            // 12 pm is noon.
            if ( x.Hour >= 12 && x.Hour < 24 )
                szAMPM = "PM";
            else 
                szAMPM = "AM";
            int wHour = (x.Hour % 12);
            if (wHour == 0)
                wHour = 12;
            szTodaysDate = x.Month + "/" + x.Day + "/" + x.Year + " " + 
                wHour + ":" + x.Minute + " " + szAMPM;
            return szTodaysDate;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WEBSITES\CSWebSGSite\WebCacheReflector.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="WebCacheReflectorSoap", Namespace="http://tempuri.org/")]
public class WebCacheReflector : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public WebCacheReflector() {
        this.Url = "http://192.168.86.81/websg/webcachereflector.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflector", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] WallysWCReflector(int iPayLoad) {
        object[] results = this.Invoke("WallysWCReflector", new object[] {
                    iPayLoad});
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflector(int iPayLoad, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflector", new object[] {
                    iPayLoad}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.Byte[] EndWallysWCReflector(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflectorBytes", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] WallysWCReflectorBytes(System.UInt32 uiPayLoad) {
        object[] results = this.Invoke("WallysWCReflectorBytes", new object[] {
                    uiPayLoad});
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflectorBytes(System.UInt32 uiPayLoad, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflectorBytes", new object[] {
                    uiPayLoad}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.Byte[] EndWallysWCReflectorBytes(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflectorBytesTimeout", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public System.Byte[] WallysWCReflectorBytesTimeout(System.UInt32 uiPayLoad, int iTimeout) {
        object[] results = this.Invoke("WallysWCReflectorBytesTimeout", new object[] {
                    uiPayLoad,
                    iTimeout});
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflectorBytesTimeout(System.UInt32 uiPayLoad, int iTimeout, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflectorBytesTimeout", new object[] {
                    uiPayLoad,
                    iTimeout}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.Byte[] EndWallysWCReflectorBytesTimeout(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.Byte[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WallysWCReflectorString", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string WallysWCReflectorString() {
        object[] results = this.Invoke("WallysWCReflectorString", new object[0]);
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginWallysWCReflectorString(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("WallysWCReflectorString", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public string EndWallysWCReflectorString(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\Stress.cs ===
using System;
using System.Web;
using System.Security;
using System.Net;
using System.IO;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Net.Sockets;
using System.Threading;
using System.Globalization;
using System.Web.Services.Protocols;


namespace WebSgEngine
{

    class WebSgStressWorker {

        public TESTCASE[] testCases;
        public int iThreadindex;
        public WebSgStressWorker(){}


        public void SetWebSgStressWorkerIndex(int i){
           iThreadindex = i;
        }
        
        public void WorkerThreadFunction(){
            string szIndicatorElements= "|/-\\";
            
            while (true){    
                try {
                    foreach (TESTCASE testcase in testCases){
                        for ( int i = 0; i < testcase.iWeightingPercentage; i++){
                            // Console.WriteLine("name:{0} Weighting:{1}",testcase.szTestName, 
                            // testcase.iWeightingPercentage );
                            Console.Write("Processing [{0}]:{1}  \r",
                                szIndicatorElements.Substring(iThreadindex %4,1), 
                                iThreadindex);
                            WebSgFunctionals.MakeRequest(testcase);
                        }
                    }
                }            
                catch (WebException WebExcp) {
                    Console.Write("WebExcp:{0}\n",WebExcp.Message.ToString());
                    Console.Write("WebExcp:{0}\n",WebExcp.Response.GetResponseStream());
                    for( int i = 0; i < 30; i++)
                        Console.Write("WebExcp:{0}{1}\n",i,WebExcp.Response.Headers.Get(i));
                    Thread.Sleep(5000);
                }
                catch (Exception e) { 
                    Console.Write("Exception:{0}\n", e.Message.ToString());
                    Thread.Sleep(5000);
                }
            }
        }
    }

    class WebSgStressPerformance: CDatafile {
        public int iNumberThreads = 0;
        public uint uiPacketSize  = 0;
        
        public void Stress( string szDriverFilename ) {

            int i = 0;
            TESTCASE[] testCases;
            ServicePointManager.DefaultConnectionLimit = 22;
            string szDefaultStressDriverFilename = "webSGEngineStress.txt";
            if (null == szDriverFilename) 
                szDriverFilename = szDefaultStressDriverFilename;
            // Loading Test Cases.

            testCases = LoadTestCasesToRun( szDriverFilename, uiPacketSize  );
            for (i = 0; i < testCases[0].uiNumberOfTests; i++)
                testCases[i].bStress = true;
            
            ThreadStart[] worker = new ThreadStart[iNumberThreads];

            for (i = 0; i < iNumberThreads; i++){
                WebSgStressWorker xs = new WebSgStressWorker();
                xs.testCases = testCases;
                xs.SetWebSgStressWorkerIndex(i);
                worker[i] = new ThreadStart(xs.WorkerThreadFunction);
                if ( 0 == uiPacketSize ) { // means use driverfile
                    Console.Write("Spawning Worker Threads Now! [{0}]  PacketSize [<Specified in DriverFile>]  \r", i + 1, uiPacketSize );
                }else
                    Console.Write("Spawning Worker Threads Now! [{0}]  PacketSize [{1}]  \r", i + 1, uiPacketSize );
                Thread.Sleep(100);
            }

            // Start all of them at once.
            Console.Write("\n");
            for (i = 0; i < iNumberThreads; i++){
                Thread Producer = new Thread(worker[i]);
                Producer.Start();
            }
            while (true) {
                /*
                Console.Write("Processing [|]\r");
                Thread.Sleep(100);
                Console.Write("Processing [/]\r");
                Thread.Sleep(100);
                Console.Write("Processing [-]\r");
                Thread.Sleep(100);
                Console.Write("Processing [\\]\r");
                */
                Thread.Sleep(10000);
            }
        }



        bool MakeWebRequest(Uri URL, string Method) {
            //try catch block to catch any errors
            try {
                //Create a new request
                HttpWebRequest HttpWRequest = (HttpWebRequest)WebRequest.Create(URL);
                // set the HttpWebRequest objects cookie container
                // if you have any cookies that you want to go with the request you can add them 
                // to the cookiecontainer. If you had made a previous request that returned any cookies
                // that needed to be sent on subsequent request this will make sure that they are sent. 
                
                //HttpWRequest.CookieContainer = CookieJar;
               /* 
                // check to see if the user added user name and password for Basic authentication.
                // you can also use digest and Kerbeors authentication
                if (txtUser.Text.Length > 1) { // we will add the user and password for basic auth.
                    NetworkCredential myCred = new NetworkCredential(txtUser.Text.ToString(), txtPassword.Text.ToString());
                      CredentialCache MyCrendentialCache = new CredentialCache();
                    MyCrendentialCache.Add(URL, "Basic", myCred);
                    HttpWRequest.Credentials = MyCrendentialCache;
                }
                else { //Set the default Credentials. This will allow NTLM or Kerbeors authentication with out prompting the user
                    // the default credentials are usually the Windows credentials (user name, password, and domain) of the user running the application
                    HttpWRequest.Credentials = CredentialCache.DefaultCredentials;
                }
                // set the name of the user agent. This is the client name that is passed to IIS
                HttpWRequest.UserAgent = "CSharp HTTP Sample";
                // set the connection keep-alive
                HttpWRequest.KeepAlive = true; //this is the default
                //we don't want caching to take place so we need
                // to set the pragma header to say we don't want caching
                HttpWRequest.Headers.Set("Pragma", "no-cache");
                //set the request timeout to 5 min.
                HttpWRequest.Timeout = 300000;
                // set the request method
                HttpWRequest.Method = Method;
                // See what the Method is a POST 
                if ("POST" == Method) {
                    // add the content type so we can handle form data
                    HttpWRequest.ContentType = "application/x-www-form-urlencoded";
                    if (txtPostData.Text.Length < 1) { // we don't have any data to post
                        MessageBox.Show("Please enter the data to post");
                        return false;
                    }
                    // we need to store the data into a byte array
                    byte[] PostData = System.Text.Encoding.ASCII.GetBytes(txtPostData.Text.ToString());
                    HttpWRequest.ContentLength = PostData.Length;
                    Stream tempStream = HttpWRequest.GetRequestStream();
                    // write the data to be posted to the Request Stream
                    tempStream.Write(PostData,0,PostData.Length);
                    tempStream.Close();
                }
                
                if ("PUT" == Method) { //we want to put a file
                    if (txtFileName.Text.Length < 1) {
                        MessageBox.Show("Please enter a file to put");
                        return false;
                    }
                    //open the file to put
                    FileStream readIn = new FileStream(txtFileName.Text, FileMode.Open, FileAccess.Read);
                    readIn.Seek(0, SeekOrigin.Begin); // move to the start of the file
                    byte[] fileData = new byte[readIn.Length];
                    readIn.Read(fileData,0, (int)readIn.Length); // read the file data
                    HttpWRequest.ContentLength = readIn.Length;
                    Stream tempStream = HttpWRequest.GetRequestStream();
                    // place the file data in the Request Stream to send to the server
                    // for ease of use we just read the whole file into on large byte array to send.
                    tempStream.Write(fileData,0,(int)readIn.Length);
                    tempStream.Close();
                    readIn.Close();
                }
                */
                HttpWebResponse HttpWResponse = null;
                //check to see if we have previously created a response object
                if(null != HttpWResponse) {
                    HttpWResponse.Close(); // close any previous connection
                    HttpWResponse = null; // clear the object. 
                }
                //get the response. This is where we make the connection to the server
                HttpWResponse = (HttpWebResponse)HttpWRequest.GetResponse();
                // Fill out the data on the Response Header Tab
                // check for headers. We don't have the CRLF vs non CRLF headers
                // we get a headers collection. However the following code
                // will output all the Headers in the collection.
                // note they next line of code may be oblolete check when we release. 
                
                /*
                txtReturnHeaders.Text = HttpWResponse.Headers.ToString();
                //Get the content Type 
                txtContentType.Text = HttpWResponse.ContentType.ToString();
                //Get the Content Length 
                txtContentLen.Text = HttpWResponse.ContentLength.ToString();
                //Get the Request Method
                txtRespMethod.Text = HttpWResponse.Method.ToString();
                // Get the Status code
                int iStatCode =  (int)HttpWResponse.StatusCode;
                txtStatusCode.Text = iStatCode.ToString();
                // Get last modified
                txtLastMod.Text = HttpWResponse.LastModified.ToLongDateString();
                // Get HTTP version
                txtVersion.Text = HttpWResponse.ProtocolVersion.ToString();
                // Get the status text
                txtText.Text = HttpWResponse.StatusCode.ToString();
                // Get what the server is
                txtServer.Text = HttpWResponse.Server.ToString();
                // Get the Content Encoding if any
                txtEncoding.Text = HttpWResponse.ContentEncoding.ToString();
                // write the request info to the controls on the
                // Request Header tab
                // Get the request headers
                txtReqHeaders.Text = HttpWRequest.Headers.ToString();
                // Get the request method
                txtReqMethod.Text = HttpWRequest.Method.ToString();
                // Get the user agent name
                txtUserAgent.Text = HttpWRequest.UserAgent.ToString();
                // Get any request cookies
                txtReqCookies.Text = HttpWRequest.CookieContainer.GetCookieHeader(URL).ToString();
                */
                return true;
            }
            catch (WebException WebExcp) {
                Console.WriteLine("{0}", WebExcp.Message.ToString());
                //ICertificatePolicy CertPolicy = ServicePointManager.CertificatePolicy;
                return false;
            }
            catch (Exception e) { // get any other error
                Console.WriteLine("{0}", e.Message.ToString());
                return false;
            }
        }
    }
    
    /*
    class ServerWally {
        public static void date() {
            DateTime now;
            String strDateLine;
            Encoding ASCII = Encoding.ASCII;
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
            try {
                TcpListener tcpl = new TcpListener(13); // listen on port 13

                tcpl.Start();
                
                Console.WriteLine("Waiting for clients to connect");
                Console.WriteLine("Press Ctrl+c to Quit...");
                while (true) {
                    // Accept will block until someone connects
                    Socket s = tcpl.AcceptSocket();

                    // Get the current date and time then concatenate it
                    // into a string
                    now = DateTime.Now;
                    strDateLine = now.ToShortDateString() + " " + now.ToLongTimeString();
                    // Convert the string to a Byte Array and send it
                    Byte[] byteDateLine = ASCII.GetBytes(strDateLine.ToCharArray());
                    s.Send(byteDateLine, byteDateLine.Length, 0);
                    s.Close();
                    Console.WriteLine("Sent {0}", strDateLine);
                }
            }
            catch (SocketException socketError) {
                if (socketError.ErrorCode == 10048) {
                    Console.WriteLine("Connection to this port failed.  There is another server is listening on this port.");
                }
            }
        }
    }*/

}

/*
 *namespace MyWebService
 {
 	using System ;
using System.Web.Services ;

public class MyStringReverse: WebService
{
        		[WebMethod(Description="Reverse String")]
        		public  String ReverseString ( String InString )
        		{
                		// Check null String
                		if ( InString == null )  return null ;
                        
                		Int32 intSize = InString.Length ;
                	char[] arrayInString = InString.ToCharArray() ;
            	    	char[] arrayOutString = new char[intSize] ;
                
                        for (Int32 i = 0 ; i < intSize ; ++i) 
                        		arrayOutString[i] = arrayInString[intSize-i-1] ;
                        
                	return new String(arrayOutString) ;        
        		}
 	}
}
*/





/*
// SimplePool.cs
// Simple thread pool example
using System;
using System.Collections;
using System.Threading;


// Useful way to store info that can be passed as a state on a work item
public class SomeState {
    public int Cookie;
    public SomeState(int iCookie) {
        Cookie = iCookie;
    }
}

public class Alpha {
    public Hashtable HashCount;
    public ManualResetEvent eventX;
    public static int iCount = 0;
    public static int iMaxCount = 0;
    public Alpha(int MaxCount) {
        HashCount = new Hashtable(MaxCount);
        iMaxCount = MaxCount;
    }

    // Beta is the method that will be called when the work item is
    // serviced on the thread pool.
    // That means this method will be called when the thread pool has
    // an available thread for the work item.
    public void Beta(Object state) {
        // Write out the hashcode and cookie for the current thread
        Console.WriteLine(" {0} {1} :", Thread.CurrentThread.GetHashCode(),
            ((SomeState)state).Cookie);
        // The lock keyword allows thread-safe modification
        // of variables accessible across multiple threads.
        Console.WriteLine(
            "HashCount.Count=={0}, Thread.CurrentThread.GetHashCode()=={1}",
            HashCount.Count, 
            Thread.CurrentThread.GetHashCode());
        lock (HashCount) {
            if (!HashCount.ContainsKey(Thread.CurrentThread.GetHashCode()))
                HashCount.Add (Thread.CurrentThread.GetHashCode(), 0);
            HashCount[Thread.CurrentThread.GetHashCode()] = 
                ((int)HashCount[Thread.CurrentThread.GetHashCode()])+1;
        }

        // Do some busy work.
        // Note: Depending on the speed of your machine, if you 
        // increase this number, the dispersement of the thread
        // loads should be wider.
        int iX  = 2000;
        Thread.Sleep(iX);
        // The Interlocked.Increment method allows thread-safe modification
        // of variables accessible across multiple threads.
        Interlocked.Increment(ref iCount);
        if (iCount == iMaxCount) {
            Console.WriteLine();
            Console.WriteLine("Setting eventX ");
            eventX.Set();
        }
    }
}

public class SimplePool {
    public static int Main(string[] args) {
        Console.WriteLine("Thread Pool Sample:");
        bool W2K = false;
        int MaxCount = 10;  // Allow a total of 10 threads in the pool
        // Mark the event as unsignaled.
        ManualResetEvent eventX = new ManualResetEvent(false);
        Console.WriteLine("Queuing {0} items to Thread Pool", MaxCount);
        Alpha oAlpha = new Alpha(MaxCount);  // Create the work items.
        // Make sure the work items have a reference to the signaling event.
        oAlpha.eventX = eventX;
        Console.WriteLine("Queue to Thread Pool 0");
        try {
            // Queue the work items, which has the added effect of checking
            // which OS is running.
            ThreadPool.QueueUserWorkItem(new WaitCallback(oAlpha.Beta),
                new SomeState(0));
            W2K = true;
        }
        catch (NotSupportedException) {
            Console.WriteLine("These API's may fail when called on a non-Windows 2000 system.");
            W2K = false;
        }
        if (W2K) {  // If running on an OS which supports the ThreadPool methods.
            for (int iItem=1;iItem < MaxCount;iItem++) {
                // Queue the work items:
                Console.WriteLine("Queue to Thread Pool {0}", iItem);
                ThreadPool.QueueUserWorkItem(new WaitCallback(oAlpha.Beta),new SomeState(iItem));
            }
            Console.WriteLine("Waiting for Thread Pool to drain");
            // The call to exventX.WaitOne sets the event to wait until
            // eventX.Set() occurs.
            // (See oAlpha.Beta).
            // Wait until event is fired, meaning eventX.Set() was called:
            eventX.WaitOne(Timeout.Infinite,true);
            // The WaitOne won't return until the event has been signaled.
            Console.WriteLine("Thread Pool has been drained (Event fired)");
            Console.WriteLine();
            Console.WriteLine("Load across threads");
            foreach(object o in oAlpha.HashCount.Keys)
                Console.WriteLine("{0} {1}", o, oAlpha.HashCount[o]);
        }
        return 0;
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\Functionals.cs ===
using System;
using System.Web;
using System.Security;
using System.Net;
using System.IO;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Net.Sockets;
using System.Threading;
using System.Globalization;
using System.Web.Services.Protocols;

using System.Text.RegularExpressions;

namespace WebSgEngine
{
    class WebSgFunctionals : CDatafile {
        

        public  bool Functionals(){
             return Functionals( null);
        }
      

        public  bool Functionals( string szDriverFilename){
            bool b = true;
            TESTCASE [] testCases;
            string szDefaultDriverFilename = "webSGEngineDriver.txt";
          
            if (null == szDriverFilename) 
                szDriverFilename = szDefaultDriverFilename;
            testCases = LoadTestCasesToRun( szDriverFilename );
            foreach (TESTCASE testcase in testCases){
                
                switch (testcase.szWhichRequestType){
                    case "RawWebRequest":
                        MakeRawWebRequest( testcase );
                        break;
                    default:
                        MakeRequest( testcase );
                        break;
                }
            }
            return b;
        }
        
        public static bool MakeRequest ( TESTCASE ptc ){

            bool b = true;
            byte [] bReturn;
            if (false == ptc.bStress)
                Console.Write("[STARTING] {0}.\n",ptc.szTestName); 
            try {
                if (-1 != ptc.Request_szURL.IndexOf("generalinfo")){
                    GeneralInfo gi = new GeneralInfo(ptc.Request_szURL);
                    X509Certificate x509 = X509Certificate.CreateFromCertFile( ptc.Request_szCertificate );
                    gi.ClientCertificates.Add(x509);
                    // At this point you just make queries to thse functions on the back end.
                    uint uiValidSeconds = 1;
                    TitlePrivilegeInfo [] p =  gi.GetTitleList( out uiValidSeconds ); 
                    foreach( TitlePrivilegeInfo x in p) {
                        if (false == ptc.bStress){
                            Console.Write("Name {0} Rating {1} \n",x.LocalizedName, x.Rating);
                            Console.Write("Seconds {0} TitleID {1}\n",uiValidSeconds, x.TitleID );
                        }
                    }
                }else
                    if (-1 != ptc.Request_szURL.IndexOf("stats")){
                    Stats stats = new Stats();
                    stats.Url = ptc.Request_szURL;
                    X509Certificate x509 = X509Certificate.CreateFromCertFile( ptc.Request_szCertificate );
                    stats.ClientCertificates.Add(x509);
                    // At this point you just make queries to thse functions on the back end.
                    Console.Write("STATS::This is a stat test.\n" );

                    Console.Write("Calling GetLBList(275).\n" );
                    LBInfo [] x = stats.GetLBList(275);
                    foreach( LBInfo y in x) {
                        Console.Write("==> {0}.\n", y.LBID );
                        foreach( LocalizedName w in y.LocalizedLBName) {
                            Console.Write("Name==> {0}.\n", w.Name );
                        }
                    }             
                }else{
                    WebCacheReflector wcr = new WebCacheReflector();
                    wcr.Url = ptc.Request_szURL;
                    if (0 != ptc.Request_iClientTimeOutMilliseconds){
                        wcr.Timeout = ptc.Request_iClientTimeOutMilliseconds;
                        Console.WriteLine("Request_iClientTimeOutMilliseconds {0}.", wcr.Timeout );
                    }
                    X509Certificate x509 = X509Certificate.CreateFromCertFile( ptc.Request_szCertificate );
                    wcr.ClientCertificates.Add(x509);
                    // At this point you just make queries to these functions on the back end.
                    switch (ptc.Request_szAPItoCall){
                        case "WallysWCReflectorString":
                            bool bSubject = false;
                            bool bSoapAction = false;
                            bool bClientIPPort = false;
                            bool bRequestId  = false;
                            Regex r = new Regex("\n+"); 
                            string[] szStrings;
                            string szReturn = wcr.WallysWCReflectorString();
                            szStrings = r.Split(szReturn);
                            for ( int x = 0; x < szStrings.Length; x++ ){
                                //Console.WriteLine( "szStrings{0}:  {1}", x, szStrings[x]);
                                if ( -1 != szStrings[x].IndexOf("SERVER")){
                                    Console.Write( "{0}\n", szStrings[x]);
                                }else if ( -1 != szStrings[x].IndexOf("SOAPAction:")){
                                    
                                    Console.Write( "{0}\n", szStrings[x] );
                                    if( -1 != szStrings[x].IndexOf(ptc.Request_SOAPAction)) 
                                        bSoapAction = true;
                                }else if ( -1 != szStrings[x].IndexOf("Subject-Name:")){
                                    Console.Write( "{0}\n", szStrings[x] );
                                    if( -1 != szStrings[x].IndexOf(ptc.Request_SubjectName) )
                                        bSubject = true;
                                }else
                                    if ( -1 != szStrings[x].IndexOf("Client-IP-Port:")){
                                    Console.Write( "{0}\n", szStrings[x]);
                                    if( -1 != szStrings[x].IndexOf(ptc.Request_ClientIPPort))
                                        bClientIPPort = true;
                                }else
                                    if ( -1 != szStrings[x].IndexOf("RequestId:")){
                                    Console.Write( "{0}\n", szStrings[x] );
                                    if( -1 != szStrings[x].IndexOf(ptc.Request_RequestId))
                                          bRequestId = true;
                                }
                                //string s = Encoding.ASCII.GetString(p,0,p.Length);
                            }
                            // Check 
                            Console.Write("{0}: Subject-Name sent to cache.\n", bSubject? "PASSED": "FAILED" ); 
                            Console.Write("{0}: SOAPAction sent to cache.\n", bSoapAction? "PASSED": "FAILED" ); 
                            Console.Write("{0}: Client-IP-Port sent to cache.\n", bClientIPPort? "PASSED": "FAILED" ); 
                            Console.Write("{0}: RequestId sent to cache.\n", bRequestId? "PASSED": "FAILED" ); 
                            break;
                        case "WallysWCReflectorBytes":
                            bReturn =  wcr.WallysWCReflectorBytes(ptc.Request_uiPacketSize);
                            if (bReturn.Length != ptc.Request_uiPacketSize ){
                                Console.Write( "FAILED: uiPacketSize, Expect: {0} Retrieved: {0}.\n", 
                                    ptc.Request_uiPacketSize,
                                    bReturn.Length );
                            }else{
                                if (false == ptc.bStress)
                                    Console.Write("PASSED: returned {0} bytes.\n",bReturn.Length); 
                            }
                            break;
                        case "WallysWCReflectorBytesRANGE":
                            for (uint uiPayload = ptc.Request_uiStartPacketSizeRange; 
                                uiPayload < ptc.Request_uiEndPacketSizeRange; 
                                uiPayload+= ptc.Request_uiSkipSizeRange ){
                                bReturn =  wcr.WallysWCReflectorBytes(uiPayload);
                                Console.Write("Returned {0} bytes \r",bReturn.Length); 
                                if (bReturn.Length != uiPayload ){
                                    Console.Write( "FAILED: uiPayload, Expect: {0} Retrieved: {0}.\n", 
                                        uiPayload, bReturn.Length );
                                }else{
                                    Console.Write("PASSED: returned {0} bytes.\r",bReturn.Length); 
                                }
                            }
                            break;

                        case "WallysWCReflectorBytesTimeout":
                            
                            if (false == ptc.bStress)
                                Console.Write("Request_iTimeOutMilliseconds {0}.\n",ptc.Request_iTimeOutMilliseconds ); 
                            bReturn =  wcr.WallysWCReflectorBytesTimeout(ptc.Request_uiPacketSize,ptc.Request_iTimeOutMilliseconds );
                           
                            if (bReturn.Length != ptc.Request_uiPacketSize ){
                                Console.WriteLine( "FAILED: uiPacketSize, Expect: {0} Retrieved: {0}.", 
                                    ptc.Request_uiPacketSize,
                                    bReturn.Length
                                    );
                            }else{
                                if (false == ptc.bStress)
                                    Console.WriteLine("PASSED: returned {0} bytes.",bReturn.Length); 
                            }
                            break;
                        case "WallysWCReflectorCertificateIssuer":
                            bSubject = false;
                            r = new Regex(" +"); 
                            string szIssuerName = x509.GetIssuerName();
                            string [] s = r.Split(szIssuerName);
                            //foreach ( string xx in s){
                            //    Console.Write("CN Issuer is:{0}\n", xx );
                            //}
                            Console.Write("CN Issuer is:{0}\n", s[6] );
                            r = new Regex("\n+"); 
                            szReturn = wcr.WallysWCReflectorString();
                            szStrings = r.Split(szReturn);
                            for( int x = 0; x < szStrings.Length; x++ ){
                                if( -1 != szStrings[x].IndexOf("Subject-Name:")){
                                   Console.Write( "{0}\n", szStrings[x] );
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
            }catch (WebException WebExcp) {
                Console.WriteLine("WebException:{0}",WebExcp.Message.ToString());
                Console.WriteLine("WebException:{0}",WebExcp.Response.GetResponseStream());
                b =  false;
            }
            catch (Exception e) { 
                Console.Write("{0}\n",e.Message.ToString());
                b = false;
            }
            // Add a space between the printed items.
            if (false == ptc.bStress)
                Console.Write("[ENDING  ] {0}.\n\n",ptc.szTestName); 
            return b;
        }
        bool MakeRawWebRequest(TESTCASE ptc ) {
            bool b = false;
            ptc.HTTP_Method = "POST";
            try {
                
                //Create a new request
                HttpWebRequest HttpWRequest = (HttpWebRequest)WebRequest.Create(ptc.Request_szURL);
                X509Certificate x509 = X509Certificate.CreateFromCertFile( ptc.Request_szCertificate );
                HttpWRequest.ClientCertificates.Add(x509);
                // set the name of the user agent. This is the client name that is passed to IIS
                HttpWRequest.UserAgent = 
                "Mozilla/4.0 (compatible;MSIE 6.0;MS Web Services Client Protocol 1.1.4322.573)";
                
                //HttpWRequest. KeepAlive = true; //this is the default
                // set the connection keep-alive
                HttpWRequest.KeepAlive = true; //this is the default
                //we don't want caching to take place so we need
                // to set the pragma header to say we don't want caching
                HttpWRequest.Headers.Set("Pragma", "no-cache");
                //set the request timeout to 5 min.
                HttpWRequest.Timeout = 300000;
                // set the request method
                HttpWRequest.Method = ptc.HTTP_Method;
                // See what the Method is a POST 
                HttpWRequest.ContentType = "text/xml;charset=utf-8";


                string PostText2 = 
                    //"HTTP/1.1" +
                    "SOAPAction:\r\n\"http://tempuri.org/WallysWCReflectorString\"\r\n" +
                    "\r\n\r\n\r\n<?xml\r\nversion=\"1.0\"\r\nencoding=\"utf-8\"?>" +
                    "<soap:Envelope.xmlns:soap=http://schemas.xmlsoap.org/soap/envelope/" +
                    "\r\nxmlns:xsi=http://www.w3.org/2001/XMLSchemainstance" +
                    "\r\nxmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">" +
                    "<soap:Body>" +
                    "<WallysWCReflectorString.xmlns=\"http://tempuri.org/\">" +
                    "</WallysWCReflectorString> " +
                    "</soap:Body>" +
                    "</soap:Envelope>";

                HttpWRequest.ContentLength = PostText2.Length;
                
                if ("POST" == ptc.HTTP_Method) {
                    
                    HttpWRequest.Headers.Add("Subject-Name:t2client2");
                    HttpWRequest.Headers.Add("Client-IP-Port","157.56.13.196:8888");
                    HttpWRequest.Headers.Add("RequestId","690f1170b8352911");
                   
                    // add the content type so we can handle form data
                    //HttpWRequest.ContentType = "application/x-www-form-urlencoded";

                    // we need to store the data into a byte array
                    //byte[] PostData = System.Text.Encoding.ASCII.GetBytes(PostText.ToString());
                    byte[] PostData = System.Text.Encoding.ASCII.GetBytes(PostText2.ToString());
                    HttpWRequest.ContentLength = PostData.Length;
                    Stream UploadStream = HttpWRequest.GetRequestStream();
                    //Write the data to be posted to the Request Stream
                    UploadStream.Write(PostData,0,PostData.Length);
                    UploadStream.Close();
                }
                HttpWebResponse HttpWResponse = null;
                //check to see if we have previously created a response object
                if(null != HttpWResponse) {
                    HttpWResponse.Close(); // close any previous connection
                    HttpWResponse = null; // clear the object. 
                }
             
                //HttpWRequest.
                    WebResponse x = null;
                
                //get the response. This is where we make the connection to the server
                x = HttpWRequest.GetResponse();
                HttpWResponse = (HttpWebResponse)x; 
                // Fill out the data on the Response Header Tab
                // check for headers. We don't have the CRLF vs non CRLF headers
                // we get a headers collection. However the following code
            
                // place the file data in the Request Stream to send to the server
                // for ease of use we just read the whole file into on large byte array to send.
                Stream ResponseStream = x.GetResponseStream();
                Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                
                StreamReader sr = new StreamReader( ResponseStream, encode );
                byte [] fileData = new byte[9000];
                char [] szFileData = new char[9000];
                int iReadCount = sr.Read( szFileData,0, (int)HttpWResponse.ContentLength);
                sr.Close();

                Console.Write("szFileData DATA DUMP:\n" );
                foreach (char ss in szFileData){
                    Console.Write("{0}",ss);
                }
                Console.Write("szFileData Size {0} \n",szFileData.Length );
                Console.Write("Headers {0} \n",x.Headers );
                Console.Write("Server {0} \n",HttpWResponse.Server.ToString());
                
                //Console.Write("Server {0} \n",HttpWResponse.GetResponseStream());
                /*
                Console.Write("Headers {0} \n",HttpWResponse.Headers.ToString());
                //Get the content Type 
                Console.Write("ContentType {0} \n", HttpWResponse.ContentType.ToString());
                //Get the Content Length 
                Console.Write("ContentType {0} \n", HttpWResponse.ContentLength.ToString());
                //Get the Request Method
                Console.Write("ContentType {0} \n",HttpWResponse.Method.ToString());
                // Get the Status code
                //Console.Write("StatusCode {0} \n",(int)HttpWResponse.StatusCode.ToString());
                // Get last modified
                Console.Write("LastModified {0} \n",HttpWResponse.LastModified.ToLongDateString());
                // Get HTTP version
                Console.Write("ProtocolVersion {0} \n",HttpWResponse.ProtocolVersion.ToString());
                // Get the status text
                Console.Write("StatusCode {0} \n",HttpWResponse.StatusCode.ToString());
                // Get what the server is
                Console.Write("Server {0} \n",HttpWResponse.Server.ToString());
                // Get the Content Encoding if any
                Console.Write("ContentEncoding {0} \n", HttpWResponse.ContentEncoding.ToString());
                // write the request info to the controls on the
                // Request Header tab
                // Get the request headers
                Console.Write("Headers {0} \n", HttpWRequest.Headers.ToString());
                // Get the request method
                Console.Write("Method {0} \n", HttpWRequest.Method.ToString());
                // Get the user agent name
                Console.Write("UserAgent {0} \n",HttpWRequest.UserAgent.ToString());
                */
                return true;
            }
            catch (WebException WebExcp) {
                Console.Write("WebException:{0}\n",WebExcp.Message.ToString());
                Console.Write("GetResponseStream:\n{0}\n",WebExcp.Response.GetResponseStream());
                b =  false;
            }
            catch (Exception e) { 
                Console.Write("Exception: {0}\n",e.Message.ToString());
                b = false;
            }
            return b;
        }
    }

/*
    string PostText = 
    "./websg/webcachereflector.asmx" + 
    ".HTTP/1.1." + 
    ".Host:.192.168.86.51." +
    ".User-Agent:" +
    ".Mozilla/4.0.(compatible;" +
    ".MSIE.6.0;" +
    ".MS.Web.Services.Client.Protocol.1.1.4322.573)." +
    ".Content-Length:.350." +
    ".Content-Type:.text/xml;.charset=utf-8." +
    ".SOAPAction:.\"http://tempuri.org/WallysWCReflectorBytes\"." +
    ".Expect:.100-continue." +
    //".Subject-Name:.t2client2." +
    //".Client-IP-Port:.157.56.12.229:4226." +
    //".RequestId:.58B6400495402E62." +
    ".Connection:.Keep-Alive..." +
    ".<?xml.version=\"1.0\".encoding=\"utf-8\"?>" +
    "<soap:Envelope.xmlns:soap=http://schemas.xmlsoap.org/soap/envelope/" +
    ".xmlns:xsi=http://www.w3.org/2001/XMLSchemainstance" +
    ".xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">" +
    "<soap:Body>" +
    "<WallysWCReflectorBytes.xmlns=\"http://tempuri.org/\">" +
    "</WallysWCReflectorBytes> " +
    "</soap:Body>" +
    "</soap:Envelope>";
    */


}

/*
 *namespace MyWebService
 {
 	using System ;
using System.Web.Services ;

public class MyStringReverse: WebService
{
        		[WebMethod(Description="Reverse String")]
        		public  String ReverseString ( String InString )
        		{
                		// Check null String
                		if ( InString == null )  return null ;
                        
                		Int32 intSize = InString.Length ;
                	char[] arrayInString = InString.ToCharArray() ;
            	    	char[] arrayOutString = new char[intSize] ;
                
                        for (Int32 i = 0 ; i < intSize ; ++i) 
                        		arrayOutString[i] = arrayInString[intSize-i-1] ;
                        
                	return new String(arrayOutString) ;        
        		}
 	}
}
*/

                /*
                if ("PUT" == ptc.HTTP_Method) { //we want to put a file
                    if (txtFileName.Text.Length < 1) {
                        MessageBox.Show("Please enter a file to put");
                        return false;
                    }
                    //open the file to put
                    FileStream readIn = new FileStream(txtFileName.Text, FileMode.Open, FileAccess.Read);
                    readIn.Seek(0, SeekOrigin.Begin); // move to the start of the file
                    byte[] fileData = new byte[readIn.Length];
                    readIn.Read(fileData,0, (int)readIn.Length); // read the file data
                    HttpWRequest.ContentLength = readIn.Length;
                    Stream tempStream = HttpWRequest.GetRequestStream();
                    // place the file data in the Request Stream to send to the server
                    // for ease of use we just read the whole file into on large byte array to send.
                    tempStream.Write(fileData,0,(int)readIn.Length);
                    tempStream.Close();
                    readIn.Close();
                }
                */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WEBSITES\CSWebSGSite\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace CSWebSGSite 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WebSgEngine\Stats.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="StatsSoap", Namespace="http://websvc.xboxlive.com/Stats/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBEntry[]))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBAttribute[]))]
public class Stats : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public Stats() {
        this.Url = "http://10.11.2.116/stats/stats.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBList", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBInfo[] GetLBList(System.UInt32 TitleID) {
        object[] results = this.Invoke("GetLBList", new object[] {
                    TitleID});
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBList(System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBList", new object[] {
                    TitleID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBInfo[] EndGetLBList(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults EnumerateLB(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLB(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndEnumerateLB(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBNearGamerTag", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetLBNearGamerTag(System.UInt32 TitleID, System.UInt32 LBID, string GamerTag, System.UInt32 NumAbove, System.UInt32 NumBelow, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBNearGamerTag(System.UInt32 TitleID, System.UInt32 LBID, string GamerTag, System.UInt32 NumAbove, System.UInt32 NumBelow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetLBNearGamerTag(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public LBResults GetLBForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBResults EndGetLBForGamerTags(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBDetailsForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetLBDetailsForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBDetailsForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetLBDetailsForGamerTags(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLBRaw", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public RawLBResults EnumerateLBRaw(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((RawLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLBRaw(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public RawLBResults EndEnumerateLBRaw(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((RawLBResults)(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBInfo {
    
    /// <remarks/>
    public System.UInt32 LBID;
    
    /// <remarks/>
    public int ResetType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LocalizedName[] LocalizedLBName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBAttributeInfo[] AttributeInfo;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LocalizedName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string Name;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBAttribute {
    
    /// <remarks/>
    public System.UInt32 ID;
    
    /// <remarks/>
    public object V;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBAttribute[] A;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBEntryAttribute {
    
    /// <remarks/>
    public string ID;
    
    /// <remarks/>
    public string V;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class DetailedLBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntryAttribute[] F;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class DetailedLBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public DetailedLBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBAttributeInfo {
    
    /// <remarks/>
    public string ID;
    
    /// <remarks/>
    public AttributeUnit Unit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LocalizedName[] LocalizedAttrName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum AttributeUnit {
    
    /// <remarks/>
    Integer,
    
    /// <remarks/>
    Float,
    
    /// <remarks/>
    Percent,
    
    /// <remarks/>
    GamerTag,
    
    /// <remarks/>
    TimeStamp,
    
    /// <remarks/>
    MilliSeconds,
    
    /// <remarks/>
    TenMilliSeconds,
    
    /// <remarks/>
    HundredMilliSeconds,
    
    /// <remarks/>
    Seconds,
    
    /// <remarks/>
    Minutes,
    
    /// <remarks/>
    Hours,
    
    /// <remarks/>
    Days,
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\WebSgTestEngine\WEBSITES\CSWebSGSite\Service1.asmx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.Security.Cryptography.X509Certificates;
using System.Web.Services.Protocols;

using System.Security;
using System.Net;
using System.IO;
using System.Text;
using System.Net.Sockets;
using System.Threading;
using System.Globalization;

namespace CSWebSGSite
{
	/// <summary>
	/// Summary description for Service1.
	/// </summary>
	public class Service1 : System.Web.Services.WebService
	{
		public Service1()
		{
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

		#region Component Designer generated code
		
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{

        }

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
		
		#endregion

		// WEB SERVICE EXAMPLE
		// The HelloWorld() example service returns the string Hello World
        [WebMethod]
        public string MakeRequest( ){
            bool b = true;
      
            string szURL = "https://192.168.86.51/websg/WebCacheReflector.asmx";
            string szCertificate =  "c:\\Inetpub\\tonychen.cer";
            try {
                WebCacheReflector wcr = new WebCacheReflector();
                wcr.Url = szURL;
                X509Certificate x509 = X509Certificate.CreateFromCertFile( szCertificate );
                wcr.ClientCertificates.Add(x509);
                // At this point you just make queries to these functions on the back end.
                string szString = wcr.WallysWCReflectorString();
                return  "Regular " + szString ;
            }
            catch (WebException WebExcp) {
                Console.Write("{0}\n",WebExcp.Message.ToString());
                //Console.Write("{0}\n",WebExcp.Response.GetResponseStream());
                //WebExcp.Response.Headers.GetValues(
                return "WebException " + WebExcp.Message.ToString();
            }
            catch (Exception e) { 
                Console.Write("{0}\n",e.Message.ToString());
                return "WebException " + e.Message.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\CounterInfo.cs ===
using System;

namespace PerfGraphTool
{
	public class CounterInfo
	{
		public string machineName;
		public string objectName;
		public string displayName;
		public string counterName;
		public int counterID;
		public int isViewing;
		public int isChanged;
		public float scale;
		public int color;
		public const int notViewing = 0;
		public const int Viewing = 1;
		public const int Filtered = 2;			
		
		
		//public int 

		public CounterInfo(string MachineName, string ObjectName, string DisplayName, string CounterName, int CounterID, int IsViewing, float Scale)
		{
			this.machineName = MachineName;
			this.objectName = ObjectName;
			this.displayName = DisplayName;
			this.counterName = CounterName;
			this.counterID = CounterID;
			this.isViewing = IsViewing;
			this.isChanged = 0;
			this.scale = Scale;
			this.color = 0xCFCFCF;
		}

		public CounterInfo()
		{
			this.machineName = String.Empty;
			this.objectName = String.Empty;
			this.displayName = String.Empty;
			this.counterName = String.Empty;
			this.counterID = 0;
			this.isViewing = 0;
			this.isChanged = 0;
			this.scale = 1;
			this.color = 0xCFCFCF;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\chart.ashx.cs ===
using System;
using System.Web.SessionState;
using System.IO;
using System.Web;

namespace PerfGraphTool
{
	public class ChartHandler : IHttpHandler, IReadOnlySessionState
	{
        public bool IsReusable 
        { 
            get { return true; } 
        } 
    
        public void ProcessRequest (HttpContext ctx) 
        {
            string chartID = ctx.Request.QueryString[0];
            Array arr = (Array) ctx.Session [chartID];

            ctx.ClearError ();
            ctx.Response.Expires = 0;
            ctx.Response.Buffer = true;
            ctx.Response.Clear ();

            MemoryStream memStream = new MemoryStream ((byte[])arr);
            memStream.WriteTo (ctx.Response.OutputStream);
            memStream.Close ();

            ctx.Response.ContentType = "image/png";
            ctx.Response.StatusCode = 200;
            ctx.Response.End ();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\Addcounter.aspx.cs ===
using System;
using System.Text;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace PerfGraphTool
{
	/// <summary>
	/// Summary description for Addcounter.
	/// </summary>
	public class Addcounter : System.Web.UI.Page
	{
		
		protected System.Web.UI.WebControls.PlaceHolder CounterDataUnselectedPH;
		protected System.Web.UI.WebControls.PlaceHolder CounterDataSelectedPH;
		protected System.Web.UI.WebControls.PlaceHolder CControl;
		protected System.Web.UI.HtmlControls.HtmlForm Form1;
		protected System.Web.UI.WebControls.Label numFilteredCounters;
		protected System.Web.UI.WebControls.Literal numRows_literal;
		protected CounterSelect counterSelectHandler1;

		#region PerfLogToolVars
		protected System.Data.SqlClient.SqlConnection sqlConnection1;
		protected System.Web.UI.WebControls.DropDownList CategoryList1;
		protected System.Web.UI.WebControls.DropDownList ComponentList1;
		protected System.Web.UI.WebControls.DropDownList MachineList1;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectCategoriesAll;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectComponents;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectComponentsAll;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesAll;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesCat;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesComp;
		protected System.Web.UI.WebControls.CustomValidator CustomValidator1;
		protected System.Web.UI.WebControls.CustomValidator CustomValidator2;
		protected System.Web.UI.WebControls.CustomValidator CustomValidator3;
		protected System.Web.UI.WebControls.Label GraphNameLabel;
		protected System.Web.UI.WebControls.Panel GraphPanel;
		protected System.Web.UI.WebControls.Panel MenuPanel;
		protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesBoth;

		#endregion

		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
			if (Session["numRecordsDisplayed"] == null)
			{
				Session["numRecordsDisplayed"] = "10";
			}
			counterSelectHandler1.displayedRows = int.Parse((string)Session["numRecordsDisplayed"]);
			CControl.Controls.Add(counterSelectHandler1);
			

			if (!Page.IsPostBack)
			{
				RefreshCategoryList();
				RefreshComponentList();
				RefreshMachineList();
				//PopulateCounterTable();
			}
			GraphNameLabel.Text = (string)Session["graphname"];
			Session["SelectedMachine"] = MachineList1.SelectedIndex;
		}
	
		override protected void OnPreRender(EventArgs e)
		{
			PopulateCounterTable();
			base.OnPreRender(e);
		}
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
			this.counterSelectHandler1 = new CounterSelect();
			this.counterSelectHandler1.CounterInfoChanged += new System.EventHandler(this.EH_RedirectPage);
			
			// XBLPerfLogTool Init Code
			this.sqlConnection1 = new System.Data.SqlClient.SqlConnection();
			this.sqlcmdSelectCategoriesAll = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectComponents = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectComponentsAll = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesAll = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesBoth = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesCat = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesComp = new System.Data.SqlClient.SqlCommand();
			// 
			// sqlConnection1
			// 
			this.sqlConnection1.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source="+SQLserver.value+";persist security i" +
				"nfo=False;initial catalog=PerfDB";
			// sqlcmdSelectCategoriesAll
			// 
			this.sqlcmdSelectCategoriesAll.CommandText = "SELECT CategoryID, CategoryName FROM Category ORDER BY CategoryName";
			this.sqlcmdSelectCategoriesAll.Connection = this.sqlConnection1;
			// 
			// sqlcmdSelectComponents
			// 
			this.sqlcmdSelectComponents.CommandText = @"SELECT DISTINCT Component.ComponentID AS ComponentID, Component.ComponentName AS ComponentName FROM Component INNER JOIN CompCatMach ON Component.ComponentID = CompCatMach.ComponentID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Component.ComponentName";
			this.sqlcmdSelectComponents.Connection = this.sqlConnection1;
			this.sqlcmdSelectComponents.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
			// 
			// sqlcmdSelectComponentsAll
			// 
			this.sqlcmdSelectComponentsAll.CommandText = "SELECT ComponentID, ComponentName FROM Component";
			this.sqlcmdSelectComponentsAll.Connection = this.sqlConnection1;
			// 
			// sqlcmdSelectMachinesAll
			// 
			this.sqlcmdSelectMachinesAll.CommandText = "SELECT MachineID, MachineName FROM Machines ORDER BY MachineName";
			this.sqlcmdSelectMachinesAll.Connection = this.sqlConnection1;
			// 
			// sqlcmdSelectMachinesBoth
			// 
			this.sqlcmdSelectMachinesBoth.CommandText = @"SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineName FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.MachineID WHERE (CompCatMach.CategoryID = @catid) AND (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
			this.sqlcmdSelectMachinesBoth.Connection = this.sqlConnection1;
			this.sqlcmdSelectMachinesBoth.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
			this.sqlcmdSelectMachinesBoth.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
			// 
			// sqlcmdSelectMachinesCat
			// 
			this.sqlcmdSelectMachinesCat.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
				"ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
				"hineID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Machines.MachineName";
			this.sqlcmdSelectMachinesCat.Connection = this.sqlConnection1;
			this.sqlcmdSelectMachinesCat.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
			// 
			// sqlcmdSelectMachinesComp
			// 
			this.sqlcmdSelectMachinesComp.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
				"ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
				"hineID WHERE (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
			this.sqlcmdSelectMachinesComp.Connection = this.sqlConnection1;
			this.sqlcmdSelectMachinesComp.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.CategoryList1.SelectedIndexChanged += new System.EventHandler(this.CategoryList1_SelectedIndexChanged);
			this.ComponentList1.SelectedIndexChanged += new System.EventHandler(this.ComponentList1_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		public void PopulateCounterTable()
		{
			StringBuilder CounterTableDataSelected = new StringBuilder();
			StringBuilder CounterTableDataUnselected = new StringBuilder();
			ArrayList cinfolist = (ArrayList)Session ["cinfolist"];
			int i = 0;
			int j = 0;
			string selectedCategory = CategoryList1.SelectedItem.Text;
			string cname;
			ArrayList FilteredCounters;
			if (MachineList1.SelectedItem.Value == "-1")
			{
				FilteredCounters =  sp_GetAggCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue));
			}
			else
			{
				FilteredCounters = sp_GetRealCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue), MachineList1.SelectedIndex);
			}
			
			// clear the filtered flag
			if(cinfolist != null)
			{
				foreach (CounterInfo cinfo in cinfolist)
				{
					if ((cinfo != null) && (cinfo.isViewing == CounterInfo.Filtered))
					{
						cinfo.isViewing = CounterInfo.notViewing;
					}
				}
			}
			
			// set the filtered counters
			if(FilteredCounters != null)
			{
				foreach (int fc_counterID in FilteredCounters)
				{
					if(cinfolist != null)
					{
						foreach (CounterInfo cinfo in cinfolist)
						{
							if ((cinfo != null) && 
								(cinfo.counterID == fc_counterID && cinfo.isViewing == CounterInfo.notViewing))
							{
								cinfo.isViewing = CounterInfo.Filtered;
								break;
							}
						}
					}
				}
			}

			// write out counter info to webpage
			if(cinfolist != null)
			{
				foreach (CounterInfo cinfo in cinfolist)
				{
					if(cinfo != null)
					{
						cname = cinfo.objectName;
						if (cinfo.isViewing == CounterInfo.Viewing)
						{
							CounterTableDataSelected.Append(@"tableDataSelected[" + i.ToString() + "]=new dataArray('"+ cinfo.machineName.Replace("\\\\", "") + " ','" 
								+ cinfo.objectName + "','" + cinfo.displayName + "','" + cinfo.counterName + "'" + ",'" + cinfo.counterID.ToString() + "','"+ cinfo.scale.ToString() + "');\n" );
							i++;
						}
						else if (cinfo.isViewing == CounterInfo.Filtered)
						{
							CounterTableDataUnselected.Append(@"tableDataUnselected[" + j.ToString() + "]=new dataArray('"+ cinfo.machineName.Replace("\\\\", "") + " ','" 
								+ cinfo.objectName + "','" + cinfo.displayName + "','" + cinfo.counterName + "'" + ",'" + cinfo.counterID.ToString() + "','"+ cinfo.scale.ToString() + "');\n" );
							j++;
						}
					}
				}
			}
			numFilteredCounters.Text = j.ToString();	//filtered counters
			// -- Write Data to Page
			LiteralControl lc = new LiteralControl(CounterTableDataSelected.ToString() );
			CounterDataSelectedPH.Controls.Add(lc);
			lc = new LiteralControl(CounterTableDataUnselected.ToString() );
			CounterDataUnselectedPH.Controls.Add(lc);

		}

		private void EH_RedirectPage(object sender, System.EventArgs e)
		{
			Response.Redirect(@".\default.aspx");
		}

		#region XBLPerfLogToolCode
		//Ripped straight out of XBLPerfLogTool:PerfLogToolBase.cs
		

		private void RefreshCategoryList()
		{
			BindDrop(CategoryList1, sqlcmdSelectCategoriesAll, "CategoryName", "CategoryID");
			CategoryList1.Items.Insert(0, new ListItem("(All)","0"));
			if (Session["SelectedCategory"] != null)
			{
				CategoryList1.SelectedItem.Selected = false;
				CategoryList1.Items[(int)Session["SelectedCategory"]].Selected = true;
			}	
			else
			{
				Session["SelectedCategory"] = 0;
			}
		}

		private void RefreshComponentList()
		{
			if (CategoryList1.SelectedIndex == 0)
				BindDrop(ComponentList1, sqlcmdSelectComponentsAll, "ComponentName", "ComponentID");
			else
			{
				sqlcmdSelectComponents.Parameters["@catid"].Value = CategoryList1.SelectedValue;
				BindDrop(ComponentList1, sqlcmdSelectComponents, "ComponentName", "ComponentID");
			}
			ComponentList1.Items.Insert(0, new ListItem("(All)","0"));
			if (Session["SelectedComponent"] != null)
			{
				ComponentList1.SelectedItem.Selected = false;
				//ComponentList1.Items[(int)Session["SelectedComponent"]].Selected = true;
				ComponentList1.Items[0].Selected = true;
			}
			else
			{
				Session["SelectedComponent"] = 0;
			}
		}

		private void RefreshMachineList()
		{
			// for MachineList1 binddrop: 
			// MachineList1.SelectedItem.Value is the machineID in the perfdb.Machines table. 
			// MachineList1.SelectedItem.Text is the machineName in the machines table.

			// no categories selected?
			if (CategoryList1.SelectedIndex == 0)
			{
				if (ComponentList1.SelectedIndex == 0)
				{
					BindDrop(MachineList1, sqlcmdSelectMachinesAll, "MachineName", "MachineID");
				}
					// All categories, 1 component
				else
				{
					sqlcmdSelectMachinesComp.Parameters["@compid"].Value = ComponentList1.SelectedValue;
					BindDrop(MachineList1, sqlcmdSelectMachinesComp, "MachineName", "MachineID");
				}                                                                                                         
			}
			else
			{
				if (ComponentList1.SelectedIndex == 0)
				{
					sqlcmdSelectMachinesCat.Parameters["@catid"].Value = CategoryList1.SelectedValue;
					BindDrop(MachineList1, sqlcmdSelectMachinesCat, "MachineName", "MachineID");
				}
					// 1 category, 1 component
				else
				{
					sqlcmdSelectMachinesBoth.Parameters["@compid"].Value = ComponentList1.SelectedValue;
					sqlcmdSelectMachinesBoth.Parameters["@catid"].Value = CategoryList1.SelectedValue;
					BindDrop(MachineList1, sqlcmdSelectMachinesBoth, "MachineName", "MachineID");
				}                                                                                                         
			}
			//machineID that got from perfdb.machines table starts from 1 through N
			MachineList1.Items.Insert(0, new ListItem("(All normal)","0"));
			MachineList1.Items.Insert(1, new ListItem("(All aggregate)","-1"));
			if (Session["SelectedMachine"] != null)
			{
				MachineList1.SelectedItem.Selected = false;
			//	MachineList1.Items[(int)Session["SelectedMachine"]].Selected = true;
				MachineList1.Items[0].Selected = true;
			}
			else
			{
				Session["SelectedMachine"] = 0;
			}
		}

		
		protected void BindDrop(DropDownList control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
		{
			sqlConnection1.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			control.DataSource = dReader;
			control.DataTextField = dataTextField;
			control.DataValueField = dataValueField;
			control.DataBind();
			dReader.Close();
			sqlConnection1.Close();
		}

		private void CategoryList1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			RefreshComponentList();
			RefreshMachineList();
			Session["SelectedCategory"] = CategoryList1.SelectedIndex;
		}

		private void ComponentList1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			RefreshMachineList();
			Session["SelectedComponent"] = ComponentList1.SelectedIndex;
		}

		public ArrayList sp_GetRealCounterInfo(
			int CategoryID,
			int ComponentID,
			int MachineIndex)
		{
			SqlCommand sqlCommand = new SqlCommand("sp_GetRealCounterInfo", sqlConnection1);
			sqlCommand.CommandType = CommandType.StoredProcedure;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			if (CategoryID > 0) 
				sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
			if (ComponentID > 0)
				sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
			if (MachineIndex > 0)
				sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineList1.SelectedItem.Text;
			//else "All normal" is selected as "Machines"
			sqlConnection1.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			
			// Columns in the returned data reader
			const int COUNTERID = 0;
			//const int MACHINENAME = 1;
			//const int OBJECTNAME = 2;
			//const int COUNTERNAME = 3;
			//const int INSTANCENAME = 4;
			//const int DISPLAYNAME = 5;

			ArrayList list = new ArrayList(16);
			while (dReader.Read())
			{
				list.Add(dReader.GetInt32(COUNTERID));
			}
			dReader.Close();
			sqlConnection1.Close();

			return list;
		}

		public ArrayList sp_GetAggCounterInfo(
			int CategoryID,
			int ComponentID)
		{
			SqlCommand sqlCommand = new SqlCommand("sp_GetAggCounterInfo", sqlConnection1);
			sqlCommand.CommandType = CommandType.StoredProcedure;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			// if All is selected for Category and Component, then null will be 
			// passed to sp_GetAggCounterInfo stored procedure
			if (CategoryID > 0) 
				sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
			if (ComponentID > 0)
				sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
			sqlConnection1.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			
			// Columns in the returned data reader
			const int COUNTERID = 0;
			//const int OBJECTNAME = 1;
			//const int COUNTERNAME = 2;
			//const int TYPE = 3;
			//	const int DISPLAYNAME = 4;

			ArrayList list = new ArrayList(16);
			while (dReader.Read())
			{
				list.Add(dReader.GetInt32(COUNTERID));
			}
			dReader.Close();
			sqlConnection1.Close();
			
			return list;
		}            

	#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\csv.ashx.cs ===
using System;
using System.Web.SessionState;
using System.IO;
using System.Web;
using System.Data.SqlClient;
using System.Collections;

namespace PerfGraphTool
{
	public class CsvHandler : IHttpHandler, IReadOnlySessionState
	{
	
		protected System.Data.SqlClient.SqlConnection cn;
        
	    
		public bool IsReusable 
		{ 
			get { return true; } 
		} 
    
		public void ProcessRequest (HttpContext ctx) 
		{
           
			SqlCommand PopulateCsvFile;
			
			int MaxRecordIndex = 0;
			int MinRecordIndex = 0;
			int firstWrite = 0;
			
			string [] CsvInfo;
			SqlDataReader dReader;
			
			InitializeSQL();
			CsvInfo = SetupCsvStructure (ref MaxRecordIndex,ref MinRecordIndex, ctx);
			if (ctx.Session["cinfolist"] != null)
			{
				ArrayList cinfolist = (ArrayList)ctx.Session ["cinfolist"];
		     
				//ctx.ClearError ();
				//ctx.Response.Expires = 0;
				//ctx.Response.Buffer = true;
				//ctx.Response.Clear ();

								
		    
					foreach (CounterInfo cinfo in cinfolist)
					{
						if (cinfo.isViewing == 1)
						{
							PopulateCsvFile = new SqlCommand("Select [RecordIndex], [CounterValue], [CounterDateTime] " +
								"from [PerfDB].[dbo].[CounterData] cd " +
								"WHERE [CounterDateTime] between '" + ctx.Session["StartTime"] + "' and '" + ctx.Session["StopTime"] + "' AND " +
								"GUID='" + ctx.Session["logname"] + "' AND " +
								"[CounterID]=" + cinfo.counterID.ToString() +
								" ORDER BY [RecordIndex]",cn);
				    
							if(cn.State == System.Data.ConnectionState.Closed)
								cn.Open();
							dReader = PopulateCsvFile.ExecuteReader();

							const int RECORDINDEX = 0;
							const int COUNTERVALUE = 1;
							int instanceRecordIndex = MinRecordIndex;
							firstWrite = 0;
							CsvInfo[0] += "," + cinfo.machineName + "/" + cinfo.objectName + "/" + cinfo.displayName + "/" + cinfo.counterName;
							while (dReader.Read())
							{
								instanceRecordIndex = dReader.GetInt32(RECORDINDEX);
								// fill in array
								if (firstWrite == 0)
								{
									firstWrite = 1;
									
									if (instanceRecordIndex > MinRecordIndex)
									{
										for (int j = 1 ; j < instanceRecordIndex - MinRecordIndex + 1; j++)
										{
											CsvInfo[j] += ",";
										}
									}
								}
								CsvInfo[instanceRecordIndex - MinRecordIndex + 1] += "," + dReader.GetDouble(COUNTERVALUE).ToString();
							
							}
							if (instanceRecordIndex < MaxRecordIndex)
							{
								for (int j = instanceRecordIndex - MinRecordIndex + 1 ; j <= MaxRecordIndex - MinRecordIndex; j++)
								{
									CsvInfo[j] += ",";
								}
							}
							if(dReader != null)
								dReader.Close();
							if(cn != null)
								cn.Close();
							
						}
					}

					// Write out CSV file
					for (int i = 0; i < MaxRecordIndex - MinRecordIndex + 1; i++)
					{
						ctx.Response.Write(CsvInfo[i] + "\n");
					}
					ctx.Response.ContentType = "application/msexcel-comma" ;
					ctx.Response.StatusCode = 200;
					ctx.Response.End ();
				}
				else
				{
					ctx.Response.Redirect(@"default.aspx");
				}
			

		}

		public void InitializeSQL()
		{
			this.cn = new System.Data.SqlClient.SqlConnection();
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source="+SQLserver.value+";persist security" +
				" info=False;initial catalog=PerfDB";
		}

		public string[] SetupCsvStructure (ref int MaxRecordIndex,ref int MinRecordIndex, HttpContext ctx)
		{
			SqlCommand sqlCommand;
			SqlDataReader dReader;
			int NumRecordIndex = 0;
			string[] csvInfo = null;
			
			sqlCommand = new SqlCommand("SELECT MIN(RecordIndex), MAX(RecordIndex)" 
				+ " FROM [PerfDB].[dbo].[CounterData]" + " WHERE GUID = '" + ctx.Session["logname"] + "' AND [CounterDateTime] between '" + 
				ctx.Session["StartTime"] + "' and '" + ctx.Session["StopTime"] + "'",cn);
		   

			const int MINRECORDINDEX = 0;
			const int MAXRECORDINDEX = 1;
		   
			if(cn.State == System.Data.ConnectionState.Closed)
				cn.Open();
			dReader = sqlCommand.ExecuteReader();
			if (dReader.Read() ==  true)
			{
				MaxRecordIndex = dReader.GetInt32(MAXRECORDINDEX); 
				MinRecordIndex = dReader.GetInt32(MINRECORDINDEX); 
			}
			if(dReader != null)
				dReader.Close();
//			cn.Close();
			if (MaxRecordIndex != 0 && MinRecordIndex != 0)
			{


				NumRecordIndex = MaxRecordIndex - MinRecordIndex;
				csvInfo = new string[NumRecordIndex + 2];
				csvInfo[0] = "RecordIndex,CounterDateTime";
					
				
				
				sqlCommand = new SqlCommand("SELECT DISTINCT RecordIndex, CounterDateTime" 
					+ " FROM [PerfDB].[dbo].[CounterData]" + " WHERE GUID = '" + ctx.Session["logname"] + "' AND [CounterDateTime] between '" + 
					ctx.Session["StartTime"] + "' and '" + ctx.Session["StopTime"] + "'" + 
					" ORDER BY RecordIndex",cn);

				const int RECORDINDEX = 0;
				const int COUNTERDATETIME = 1;
//				if(cn.State == System.Data.ConnectionState.Closed)
//					cn.Open();
				dReader = sqlCommand.ExecuteReader();
				int i = 1;
				int uniqueRecordIndex = -1;
				while (dReader.Read())
				{
					// Populate csvInfo	
					if (dReader.GetInt32(RECORDINDEX) != uniqueRecordIndex)
					{
						csvInfo[i++] = dReader.GetInt32(RECORDINDEX).ToString()+ "," + dReader.GetString(COUNTERDATETIME);
						uniqueRecordIndex = dReader.GetInt32(RECORDINDEX);
					}
				}
				if(dReader != null)
					dReader.Close();
				if(cn != null)
					cn.Close();

			}
			else
			{
				csvInfo = null;
			}

			return csvInfo;

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\ConfigPerfDB\ConfigPerfDB.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

namespace ConfigPerfDB
{

	class serverinfo
	{
		public serverinfo(string name ,string stype )
		{
			servername=name;
			type=stype;
		}
		public string servername;
		public string type;
	}
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class ConfigPerfDB
	{
		protected static string npdb;
		protected static string perfdb;
		protected static string enviroment;
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
		

			if(args.Length!=6)
			{
					System.Console.WriteLine("Usage: configperfdb -npdb <npdb> -perfdb <perfdb> -env <enviroment>");
					System.Console.WriteLine("		<enviroment> could be testnet/bvtnet/partnernet/production/xblob");
					System.Console.WriteLine("		<npdb> is the server where npdb resides. In testnet it's xenpdbsqlv01");
					System.Console.WriteLine("		<perfdb> is the server where perfdb is. In testnet it's xetestsql001");
					return;
			}

			for(int i=0;i<args.Length;i++)
			{
				if(args[i].ToLower() =="-npdb")
				{
					npdb= args[++i];
				}
				else if(args[i].ToLower() =="-perfdb")
				{
					perfdb= args[++i];
				}
				else if(args[i].ToLower() =="-env")
				{
					enviroment= args[++i];
				}
			}
			
			serverinfo[] sinfolist = GetServerList();

			foreach( serverinfo sinfo in sinfolist)
			{
				if(sinfo.type!="ALL")
				{
					string[] temp =GetComponents(sinfo.type);
					System.Console.WriteLine("cat = "+sinfo.type+" machine ="+sinfo.servername+" comp ="+temp[0]);
					foreach(string comp in temp)
					{
						AddComponents(sinfo.servername,sinfo.type,comp);
					}
				}

			}

			SetMangling("frontdoor");
			SetMangling("inh");
			ResetPerfTool();

			AddDefaultCounter(sinfolist);


		}

		public static  void AddDefaultCounter(serverinfo[] sinfolist)
		{
			foreach( serverinfo sinfo in sinfolist)
			{
				string tmp=  sinfo.type.Trim();
				if(tmp!="ALL" && tmp!="svcadmin" &&  tmp!="test_database" )
				{
					AddCounter(sinfo.servername);
				}
			}
		}
		public static void AddCounter(string server)
		{
			SqlDataReader   result  = null;
			SqlConnection perfdbConnection =null;
			try
			{

				perfdbConnection = new SqlConnection(PerfdbConnectionString);
				perfdbConnection.Open();

				
				SqlCommand myCommand = new SqlCommand("p_AddCounterInfo",perfdbConnection);
				myCommand.CommandType = CommandType.StoredProcedure;
				SqlParameter ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				myCommand.Parameters.Add("@MachineName", SqlDbType.VarChar).Value =  @"\\"+server;
				myCommand.Parameters.Add("@ObjectName", SqlDbType.VarChar).Value = "Process";
				myCommand.Parameters.Add("@CounterName", SqlDbType.VarChar).Value ="% Processor Time";
                myCommand.Parameters.Add("@CounterType",SqlDbType.Int).Value= 73728;
				myCommand.Parameters.Add("@DefaultScale",SqlDbType.Int).Value= 0;
				myCommand.Parameters.Add("@DisplayInstanceName",SqlDbType.VarChar).Value= "_Total";
				
				
				// Execute the command
				result = myCommand.ExecuteReader();
				result.Close(); 
		   
				if((int)ret.Value != 0)
				{
					System.Console.WriteLine("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
					throw new Exception("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
				}
			}
			catch(Exception e)
			{
				System.Console.WriteLine(e);
			}
			finally
			{
				if(result != null)
				{
					result.Close();
					result = null;
				}

				if(perfdbConnection !=null)
					perfdbConnection.Close();
		
			}


			




		}


		public static string NpdbConnectionString
		{
			get
			{
				return "Data Source="+npdb+";Initial Catalog=npdb;Integrated Security=SSPI";
			}
		
		}

		public static string PerfdbConnectionString
		{
			get
			{
				return "Data Source="+perfdb+";Initial Catalog= perfdb;Integrated Security=SSPI";
			}
		
		}



		public static serverinfo[] GetServerList()
		{
			SqlDataReader myReader=null;
			ArrayList temp = new ArrayList();

			try
			{
				
				string mySelectQuery = "SELECT distinct vc_server,vc_interface FROM [t_server_interfaces] where vc_environment='"+enviroment+"'";

				SqlConnection npdbConnection = new SqlConnection(NpdbConnectionString);
				npdbConnection.Open();

				SqlCommand myCommand = new SqlCommand(mySelectQuery, npdbConnection);
				myReader =myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					serverinfo tmp = new serverinfo(myReader.GetString(0),myReader.GetString(1));
					temp.Add(tmp);
					
				}
			}
			finally
			{
				if(myReader!=null)
					myReader.Close();
			}


			serverinfo[] sinfo = new serverinfo[temp.Count];
			temp.CopyTo(sinfo, 0);
			return sinfo;




		}


		public static string[] GetComponents(string serverType)
		{
            return new string[]{serverType};
		}


		public static void AddComponents(string server, string type, string component)
		{
			SqlDataReader   result  = null;
			SqlConnection perfdbConnection =null;
			try
			{

				perfdbConnection = new SqlConnection(PerfdbConnectionString);
				perfdbConnection.Open();

				
				SqlCommand myCommand = new SqlCommand("p_AddComponent",perfdbConnection);
				myCommand.CommandType = CommandType.StoredProcedure;
				SqlParameter ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				myCommand.Parameters.Add("@MachineName", SqlDbType.VarChar).Value =  server;
				myCommand.Parameters.Add("@Category", SqlDbType.VarChar).Value =  type;
				myCommand.Parameters.Add("@ComponentName", SqlDbType.VarChar).Value =  component;
				// Execute the command
				result = myCommand.ExecuteReader();
				result.Close(); 
		   
				if((int)ret.Value != 0)
				{
					System.Console.WriteLine("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
					throw new Exception("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
				}
			}
			catch(Exception e)
			{
			System.Console.WriteLine(e);
			}
			finally
			{
				if(result != null)
				{
					result.Close();
					result = null;
				}

				if(perfdbConnection !=null)
					perfdbConnection.Close();
		
			}


			




		}


		public static void ResetPerfTool()
		{
			SqlConnection perfdbConnection =null;
			try
			{

				perfdbConnection = new SqlConnection(PerfdbConnectionString);
				perfdbConnection.Open();

				
				SqlCommand myCommand = new SqlCommand("p_Reset",perfdbConnection);
				myCommand.CommandType = CommandType.StoredProcedure;
				SqlParameter ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				// Execute the command
				 myCommand.ExecuteNonQuery();
				
		   
				if((int)ret.Value != 0)
				{
					System.Console.WriteLine("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
					throw new Exception("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
				}
			}
			catch(Exception e)
			{
				System.Console.WriteLine(e);
			}
			finally
			{
				if(perfdbConnection !=null)
					perfdbConnection.Close();
		
			}


			




		}


		public static void SetMangling(string ServerType)
		{
			
			SqlConnection perfConnection =null;
			try
			{
				

				perfConnection = new SqlConnection(PerfdbConnectionString);
				perfConnection.Open();

				string mySelectQuery = "update Category set Monitor=1 where CategoryName='"+ServerType+"'";

				SqlCommand myCommand = new SqlCommand(mySelectQuery, perfConnection);
				myCommand.ExecuteNonQuery();
				
			}
			finally
			{
				if(perfConnection !=null)
					perfConnection.Close();
			}


		}




	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\DHtmlControl.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Security.Principal;

namespace PerfGraphTool
{
	public class CounterSelect : Control, IPostBackDataHandler
	{
		public event EventHandler CounterInfoChanged;
		const int maxSubmittedCounters = 100;
		public int displayedRows;

/*			protected string HelperID
			{
				  get
				  {
						return "__" + ClientID + "_State";
				  }
			}*/

		protected override void OnInit(EventArgs e)
		{
			base.OnInit(e);

			if (Page != null)
			{
				Page.RegisterRequiresPostBack(this);
			}
		}

		  
		protected override void OnPreRender(EventArgs e)
		{
			base.OnPreRender(e);

			if (Page != null)
			{
				for (int i = 0; i < maxSubmittedCounters; i++)
				{
					Page.RegisterHiddenField("counterID"+i.ToString(), "0");
					Page.RegisterHiddenField("counterScale"+i.ToString(), "0");
				}
				Page.RegisterHiddenField("counterSave", "0");
				Page.RegisterHiddenField("numberDisplayRows",displayedRows.ToString());
			}
		}

		protected override void Render(HtmlTextWriter writer)
		{
			string postback = "";
			if (Page != null)
			{
				postback = Page.GetPostBackEventReference(this) + ";";
			}

			/*string click = "onclick=\"var sel=getAttribute('selected'); sel = (sel.toLowerCase() == 'true'); sel=!sel; setAttribute('selected', sel.toString());this.style.backgroundColor=sel?'red':'white';document.Form1." + HelperID +".value=sel.toString();" + postback + "\"";
			  string style = "style=\"cursor:hand;background-color:" + (Selected ? "red" : "white") + "\"";
			  string selected = "selected=\"" + Selected.ToString() + "\"";
			  writer.Write("<span " + style + " " + click + " " + selected + ">" + Text + "</span>");*/
			writer.Write("var postbackString=\"" + postback+ "\"; var form=\"document.Form1.\";");
		}


		bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection)
		{
			ArrayList cinfolist = (ArrayList)Page.Session["cinfolist"];
			bool returnValue = false;
			if(cinfolist != null)
			{
				foreach (CounterInfo cinfo in cinfolist)
				{
					if ((cinfo != null) && (cinfo.isViewing == CounterInfo.Viewing))
					{
						cinfo.isViewing = CounterInfo.notViewing;
						cinfo.isChanged = 1;
					}
				}
			}
			for (int i = 0; i < maxSubmittedCounters; i++)
			{
				string cntrIDString = postCollection["counterID"+i.ToString()];
				string cntrScaleString = postCollection["counterScale"+i.ToString()];
				
				int cntrID = Int32.Parse(cntrIDString);
				float cntrScale = float.Parse(cntrScaleString);
				//reset the isViewing flag
				
				if (cntrID != 0)
				{
					if(cinfolist != null)
					{
						foreach (CounterInfo cinfo in cinfolist)
						{
							if ((cinfo != null) && (cinfo.counterID == cntrID))
							{
								// found CounterInfo Record that matches the click item on web page
								// call stored procedure to add 
								cinfo.isViewing = CounterInfo.Viewing;
								cinfo.isChanged = 1;
								cinfo.scale = cntrScale;
								break;

							}
						}
					}
				}
			}
			Page.Session["cinfolist"] = cinfolist;
			//always call CounterInfoChanged
			Page.Session["numRecordsDisplayed"] = postCollection["numberDisplayRows"];
			
			if ("1" == postCollection["counterSave"])
			{
				returnValue = true;
			}
			return returnValue;
		}

		void IPostBackDataHandler.RaisePostDataChangedEvent()
		{
			// There was a change,  so raise any events.
			if (CounterInfoChanged != null)
			{
				CounterInfoChanged(this, EventArgs.Empty);
			}
		}
		
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\default.aspx.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Web;
using System.IO;
using System.Data;
using OWC11;
using System.Data.SqlClient;
using System.Xml;
using System.Web.UI.WebControls;
using System.Web.UI;
using System.Text.RegularExpressions;
using System.Drawing;


namespace PerfGraphTool
{
	
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class _default : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.DropDownList DropDownList1;
		protected System.Web.UI.WebControls.DropDownList DisplayGraphDlist;
		protected System.Web.UI.WebControls.PlaceHolder CounterDataPH;

		protected System.Data.SqlClient.SqlCommand PopulateDlist_DisplayGraph;
		protected System.Data.SqlClient.SqlCommand PopulateDlistGUIDSql;
		protected System.Data.SqlClient.SqlCommand PopulateLogLabelSql;
		protected System.Data.SqlClient.SqlConnection cn;
		protected System.Web.UI.WebControls.Panel DefaultPanel;
		protected System.Web.UI.HtmlControls.HtmlForm Form1;
		protected System.Web.UI.WebControls.Button LogOut_Btn;
		protected System.Web.UI.WebControls.Panel MenuPanel;
		protected System.Web.UI.WebControls.Label LogStopTime;
		protected System.Web.UI.WebControls.Button addCounter_btn;
		protected System.Web.UI.WebControls.TextBox GraphStartTime;
		protected System.Web.UI.WebControls.TextBox GraphStopTime;
		protected System.Web.UI.WebControls.Button Refresh_btn;
		protected System.Web.UI.WebControls.Image imgPerfGraph;
		protected System.Web.UI.WebControls.Button Graph_Save_btn;
		protected System.Web.UI.WebControls.Button DeleteGraph_btn;
		protected System.Web.UI.WebControls.Button NewTable_btn;
		protected System.Web.UI.WebControls.TextBox NewTable_textbox;
		protected System.Web.UI.WebControls.Button ViewGraph_btn;
		protected System.Web.UI.WebControls.Label Label3;
		protected System.Web.UI.WebControls.Literal PageLink;

		
		protected System.Data.SqlClient.SqlCommand CountersByGraph_sql;
		
		private void ProcessHttpRequest () 
		{
			int loop1;
			// Load NameValueCollection object.
			NameValueCollection coll=Request.QueryString; 
			// Get names of all keys into a string array.
			String[] arr1 = coll.AllKeys; 
			for (loop1 = 0; loop1 < arr1.Length; loop1++) 
			{
				String[] arr2 = coll.GetValues(arr1[loop1]);
				if (arr1[loop1].CompareTo("Username") == 0)
				{
					Session["UserName"] = arr2[0];
				}
				else if (arr1[loop1].CompareTo("Log") == 0)
				{
					Session["logname"]=arr2[0];
				}
				else if (arr1[loop1].CompareTo("StartTime") == 0)
				{
					Session["StartTime"] = arr2[0];
				}
				else if (arr1[loop1].CompareTo("StopTime") == 0)
				{
					Session["StopTime"] = arr2[0];
				}
				else if (arr1[loop1].CompareTo("GraphName") == 0)
				{
					Session["Graphname"]=arr2[0];
				}
			}
		} 

		virtual protected void Page_Load(object sender, System.EventArgs e)
		{
			Session["Error"] = null;
			// Put user code to initialize the page here
			HttpCookie UserName_Cookie = Request.Cookies["UserName"];
			ProcessHttpRequest ();
			if (Session["Username"] == null)
			{
				if (UserName_Cookie == null)
				{
					// redirect to login page
					Response.Redirect(@".\login.aspx");
				}
				else
				{
					Session["UserName"] = UserName_Cookie.Value;
					UserName_Cookie.Expires = System.DateTime.Now.AddDays(30);
					Response.Cookies.Add(UserName_Cookie);
				}
			}
			else
			{
				UserName_Cookie = new HttpCookie("UserName",(string)Session["UserName"]);
				UserName_Cookie.Expires = System.DateTime.Now.AddDays(30);
				Response.Cookies.Add(UserName_Cookie);
			}
			if (!Page.IsPostBack)
			{
				//Session["PageState"]=PageStates.init;
				PopulateDlistGUID();
				PopulateDlistDisplayGraph();
				if (Session["StopTime"] == null)
				{
					BindLabels(true);
				}
				else
				{
					BindLabels(false);
				}
				if (Session["cinfolist"]==null)
				{
					PopulateCounterInfo();
				}	
				//PopulateCounterTable();
				Label3.Visible = false;
				
				ShowGraph();
			}
		}

		override protected void OnPreRender(EventArgs e)
		{
			PopulateCounterTable();
			PageLink.Text = "<a href=\"default.aspx?Username=" + Session["UserName"] + "&Log=" + Session["logname"] +"&GraphName="+ Session["graphname"]+"&StartTime="+Session["StartTime"]+"&StopTime="+Session["StopTime"]+"\">Page URL</a>";
			if(Session["error"] != null)
			{
				Label3.Visible = true;
				Label3.Text = (string)Session["error"];
			}
			base.OnPreRender(e);
		}
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.DropDownList1.SelectedIndexChanged += new System.EventHandler(this.DropDownList1_SelectedIndexChanged);
			this.DisplayGraphDlist.SelectedIndexChanged += new System.EventHandler(this.DisplayGraphDlist_SelectedIndexChanged);
			this.Graph_Save_btn.Click += new System.EventHandler(this.Graph_Save_btn_Click);
			this.DeleteGraph_btn.Click += new System.EventHandler(this.DeleteGraph_btn_Click);
			this.LogOut_Btn.Click += new System.EventHandler(this.LogOut_Btn_Click);
			this.NewTable_btn.Click += new System.EventHandler(this.NewTable_btn_Click);
			this.addCounter_btn.Click += new System.EventHandler(this.addCounter_btn_Click);
			this.Refresh_btn.Click += new System.EventHandler(this.Refresh_btn_Click);
			this.ViewGraph_btn.Click += new System.EventHandler(this.ViewGraph_btn_Click);
			this.Load += new System.EventHandler(this.Page_Load);

			this.PopulateDlistGUIDSql = new System.Data.SqlClient.SqlCommand();
			this.cn = new System.Data.SqlClient.SqlConnection();
			this.PopulateLogLabelSql = new System.Data.SqlClient.SqlCommand();
			this.PopulateDlist_DisplayGraph = new System.Data.SqlClient.SqlCommand();
			this.CountersByGraph_sql = new System.Data.SqlClient.SqlCommand();
			// 
			// PopulateDlistGUIDSql
			// 
			this.PopulateDlistGUIDSql.CommandText = "Select DISTINCT [LogStartTime],[GUID] from [PerfDB].[dbo].[DisplayToID] ORDER BY " +
				"[LogStartTime] DESC";
			this.PopulateDlistGUIDSql.Connection = this.cn;
			// 
			// cn
			// 
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source="+SQLserver.value+";persist security" +
				" info=False;initial catalog=PerfDB";
			// 
			// PopulateLogLabelSql
			// 
			this.PopulateLogLabelSql.Connection = this.cn;
			this.DropDownList1.SelectedIndexChanged += new System.EventHandler(this.DropDownList1_SelectedIndexChanged);
			// 
			// PopulateDlist_DisplayGraph
			// CountersByGraph_sql
			this.PopulateDlist_DisplayGraph.CommandText = "Select DISTINCT [GraphName] from [PerfDB].[dbo].[DisplayGraph] where [Owner] = '" + Session["UserName"] + "'";
			this.PopulateDlist_DisplayGraph.Connection = this.cn;
			// 
			// PopulateDlist_DisplayGraph
			// 
			this.CountersByGraph_sql.Connection = this.cn;						

		}
		#endregion

		protected void DropDownList1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Session["logname"] = DropDownList1.SelectedItem.Value;
			PopulateCounterInfo();
			//PopulateCounterTable();
			BindLabels(true);
			ShowGraph();
		}

		protected void ShowGraph()
		{
			Label3.Text = "Check Format in Log Start / Stop Textbox";
			if (CheckLogTimeTextBox(GraphStartTime.Text,GraphStopTime.Text))
			{
				Label3.Visible = false;
				DateTime myGraphTimeStart = DateTime.Parse(GraphStartTime.Text);
				DateTime myGraphTimeStop = DateTime.Parse(GraphStopTime.Text);
				DateTime myLogTimeStop = DateTime.Parse(LogStopTime.Text);
				if (myGraphTimeStart > myLogTimeStop)
				{
					Label3.Visible = true;
					Label3.Text = "Graph Start Time is GREATER than Log End Time";
				}
				else
				{
					Session["StartTime"] = GraphStartTime.Text;
					Session["StopTime"] = GraphStopTime.Text;
					BuildCharts ();
				}
			}
			else
			{
				Label3.Visible = true;
			}
			//PopulateCounterTable();		
		}
		
		protected void DisplayGraphDlist_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Session["graphname"]=DisplayGraphDlist.SelectedValue;
			PopulateCounterInfo();
			//PopulateCounterTable();
			ShowGraph();		
		}

		protected void Graph_Save_btn_Click(object sender, System.EventArgs e)
		{
			// Save Counter Data to SQL Database
			if (Session["cinfolist"] != null)
			{
				ArrayList cinfolist = (ArrayList)Session ["cinfolist"];
			
				foreach (CounterInfo cinfo in cinfolist)
				{
					if (cinfo.isChanged == 1)
					{
						if (cinfo.isViewing == 1)
						{
							// -- Perform SQL Stored Procedure - add counter to displayGraph table

							SqlCommand sqlCommand = new SqlCommand("p_SaveUserCounter_DisplayGraph", cn);
							sqlCommand.CommandType = CommandType.StoredProcedure;
							sqlCommand.Parameters.Add("@username", SqlDbType.VarChar, 20).Value = Session["UserName"];
							sqlCommand.Parameters.Add("@graphname", SqlDbType.VarChar, 30).Value = DisplayGraphDlist.SelectedItem.Value;
							sqlCommand.Parameters.Add("@counterID", SqlDbType.Int, 20).Value = cinfo.counterID;
							sqlCommand.Parameters.Add("@isviewing", SqlDbType.Bit, 20).Value = cinfo.isViewing;
							sqlCommand.Parameters.Add("@scale", SqlDbType.Float, 8).Value = cinfo.scale;
							// return value parameter
							SqlParameter retval = new SqlParameter();
							retval.Direction = ParameterDirection.ReturnValue;
							sqlCommand.Parameters.Add(retval);
							
							try
							{
								if(cn.State == System.Data.ConnectionState.Closed)
									cn.Open();
								sqlCommand.ExecuteNonQuery();
							}
							catch(Exception ex)
							{
								Session["error"] += "Exception caught:" + ex.Message;
							}
							finally
							{
								if(cn != null)
									cn.Close();
							}
						}
						else
						{
							// delete counter from DisplayGraph Table
							SqlCommand sqlCommand = new SqlCommand("p_DeleteViewingCounter_DisplayGraph", cn);
							sqlCommand.CommandType = CommandType.StoredProcedure;
							sqlCommand.Parameters.Add("@UserName", SqlDbType.VarChar, 20).Value = Session["UserName"];
							sqlCommand.Parameters.Add("@graphname", SqlDbType.VarChar, 30).Value = DisplayGraphDlist.SelectedItem.Value;
							sqlCommand.Parameters.Add("@counterID", SqlDbType.VarChar, 20).Value = cinfo.counterID;
							// return value parameter
							SqlParameter retval = new SqlParameter();
							retval.Direction = ParameterDirection.ReturnValue;
							sqlCommand.Parameters.Add(retval);

							try
							{
								if(cn.State == System.Data.ConnectionState.Closed)
									cn.Open();
								sqlCommand.ExecuteNonQuery();
							}
							catch (Exception ex)
							{
								Session["error"] += "Exception caught:" + ex.Message;
							}
							finally
							{
								if(cn != null)
									cn.Close();
							}
						}
						cinfo.isChanged = 0;
					}
				}
			}
			else
			{
				Label3.Text = "Session State has expired. Log out and log back in";
				Label3.Visible = true;
			}
			//PopulateCounterTable();	
			
		}

		protected void DeleteGraph_btn_Click(object sender, System.EventArgs e)
		{
			SqlCommand sqlCommand = new SqlCommand("p_DeleteGraph_DisplayGraph", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;
			sqlCommand.Parameters.Add("@UserName", SqlDbType.VarChar, 20).Value = Session["UserName"];
			sqlCommand.Parameters.Add("@graphname", SqlDbType.VarChar, 30).Value = DisplayGraphDlist.SelectedItem.Value;
			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();	
				sqlCommand.ExecuteNonQuery();
			}
			catch (Exception ex)
			{
				Session["error"] += "Exception caught:" + ex.Message;
			}
			finally
			{
				if(cn != null)
					cn.Close();
			}

			// Update Graph Dlist
			PopulateDlistDisplayGraph();
			PopulateCounterInfo();
			//PopulateCounterTable();		
		}

		protected void LogOut_Btn_Click(object sender, System.EventArgs e)
		{
			LogOutNow();		
		}

		protected void NewTable_btn_Click(object sender, System.EventArgs e)
		{
			Label3.Visible = false;
			if (NewTable_textbox.Text != "")
			{
				SqlCommand sqlCommand = new SqlCommand("p_AddUser_DisplayGraph", cn);
				sqlCommand.CommandType = CommandType.StoredProcedure;
				sqlCommand.Parameters.Add("@UserName", SqlDbType.VarChar, 20).Value = Session["UserName"];
				sqlCommand.Parameters.Add("@graphname", SqlDbType.VarChar, 30).Value = NewTable_textbox.Text;
				// return value parameter
				SqlParameter retval = new SqlParameter();
				retval.Direction = ParameterDirection.ReturnValue;
				sqlCommand.Parameters.Add(retval);

				try
				{
					if(cn.State == System.Data.ConnectionState.Closed)
						cn.Open();
					sqlCommand.ExecuteNonQuery();
				}
				catch(Exception ex)
				{
					Session["error"] += "Exception caught:" + ex.Message;
				}
				finally
				{
					if(cn != null)
						cn.Close();
				}

				// Update Graph Dlist
				PopulateDlistDisplayGraph();
				Session["graphname"]= NewTable_textbox.Text;
				PopulateCounterInfo();
				Server.Transfer(@".\Addcounter.aspx");
			}
			else
			{
				Label3.Text = "Enter name for graph";
				Label3.Visible = true;
			}
		}

		// click "Edit" button on the default page
		private void addCounter_btn_Click(object sender, System.EventArgs e)
		{
			Server.Transfer(@".\Addcounter.aspx");
		}

		private void Refresh_btn_Click(object sender, System.EventArgs e)
		{
			Session["StartTime"] = GraphStartTime.Text;
			Session ["StopTime"]=null;
			BindLabels(false);
			ShowGraph();
		}
		#region PerfGraphDataValidation
		// ------------------------------------------------------------------
		protected void PopulateDlistGUID ()
		{
			
			BindDrop(DropDownList1, PopulateDlistGUIDSql, "LogStartTime", "GUID");
			if (DropDownList1.SelectedIndex == -1)
			{//Uh oh.. something went horribly wrong. Cannot get any log information. Logout!
				LogOutNow();
			}
			else
			{
				// Record the currently selected graph name
				if (Session["logname"] != null)
				{
					FindinValue (ref DropDownList1,(string)Session["logname"]);
				}
				Session["logname"]=DropDownList1.SelectedItem.Value;
			}
			
		}

		// ------------------------------------------------------------------
		protected void PopulateDlistDisplayGraph ()
		{
			this.PopulateDlist_DisplayGraph.CommandText = "Select DISTINCT [GraphName] from [PerfDB].[dbo].[DisplayGraph] where [Owner] = '" + Session["UserName"] + "'";
			BindDrop(DisplayGraphDlist, PopulateDlist_DisplayGraph, "GraphName", "GraphName");
			if (DisplayGraphDlist.SelectedIndex == -1)
			{//Uh oh.. something went horribly wrong. Cannot get any graph information. Logout!
				LogOutNow();
			}
			else
			{
				// Record the currently selected graph name
				if (Session["graphname"]!= null)
				{
					FindinText (ref DisplayGraphDlist,(string)Session["graphname"]);
				}
				Session["graphname"]=DisplayGraphDlist.SelectedValue;
			}
		}

		protected void BindDrop(DropDownList control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
		{
			SqlDataReader dReader = null;
			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				dReader = sqlCommand.ExecuteReader();
				control.DataSource = dReader;
				control.DataTextField = dataTextField;
				control.DataValueField = dataValueField;
				control.DataBind();
			}
			catch(Exception e)
			{
				Session["error"] += "Exception caught:" + e.Message;
			}
			finally
			{
				if(dReader != null)
					dReader.Close();	
				if(cn != null)
					cn.Close();
			}
		}

		
		protected void BindLabels(bool resetTime)
		{
			//int newDate;
			//int M
			//bool resetTime = false;
			SqlDataReader	dReader = null;
			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				PopulateLogLabelSql.CommandText = "SELECT  [LogStartTime], [LogStopTime] FROM [PerfDB].[dbo].[DisplayToID] where [GUID]='" + DropDownList1.SelectedItem.Value + "'";
				dReader = PopulateLogLabelSql.ExecuteReader();
				dReader.Read();
				DateTime myDateTimeStart = DateTime.Parse(dReader.GetString(0));
				DateTime myDateTimeStop = DateTime.Parse(dReader.GetString(1));
				LogStopTime.Text = dReader.GetString(1);

				if (Session["StartTime"] != null)
				{
					if (Session["StopTime"] == null)
					{
						Session["StopTime"] = LogStopTime.Text;
					}
					if (CheckLogTimeTextBox((string)Session["StartTime"],(string)Session["StopTime"]))
					{
						GraphStopTime.Text = (string)Session["StopTime"];	
						GraphStartTime.Text = (string)Session["StartTime"];		
					}
					else
					{
						resetTime = true;
					}
				}
				else
				{
					resetTime = true;
				}

				if (resetTime)
				{
					GraphStopTime.Text = dReader.GetString(1);
					myDateTimeStop = myDateTimeStop.ToUniversalTime();
		
					if (myDateTimeStop.AddDays(-3) > myDateTimeStart)
					{
						GraphStartTime.Text = myDateTimeStop.AddDays(-3).ToString("u");
					}
					else
					{
						GraphStartTime.Text = myDateTimeStart.ToString("u");
					}
				}
			}
			catch(Exception e)
			{
				Session["error"] += "Exception caught:" + e.Message;
			}
			finally
			{
				if(dReader != null)
					dReader.Close();	
				if(cn != null)
					cn.Close();
			}
		}

		protected bool CheckLogTimeTextBox (string CheckString1, string CheckString2)
		{
			bool isLogTimeValid;
			
			// Matching	: 2004-10-25 20:39:22Z 
			string e = @"(20\d\d)-"	+
				@"([01]\d)-" +
				@"([0-3]\d)\s" +
				@"([0-2]\d):" +
				@"([0-5]\d):" +
				@"([0-5]\d).+";

			//string e = @"(.+)-(.+)-(.+)\s(.+):(.+):(.+)";
			Match m	= Regex.Match(CheckString1,e);
			Match m2 = Regex.Match(CheckString2,e);
			if (m.Success && m2.Success)
			{
			
				if ( int.Parse(m.Groups[2].Value) >	12 | 
					int.Parse(m.Groups[3].Value) > 31 |
					int.Parse(m.Groups[4].Value) > 23 |
					int.Parse(m.Groups[5].Value) > 60 |
					int.Parse(m.Groups[6].Value) > 60)
				{
					isLogTimeValid = false;
				}
				else if ( int.Parse(m.Groups[2].Value) >	12 | 
					int.Parse(m.Groups[3].Value) > 31 |
					int.Parse(m.Groups[4].Value) > 23 |
					int.Parse(m.Groups[5].Value) > 60 |
					int.Parse(m.Groups[6].Value) > 60)
				{
					isLogTimeValid = false;
				}
				else
				{
					isLogTimeValid = true;	
				}
			}
			else
			{
				isLogTimeValid = false;	
			}
			return isLogTimeValid;
		}

		protected void PopulateCounterTable()
		{
			Label3.Visible = false;
			
			double	avg;

			string CounterTableData = "";
			if (Session["cinfolist"] != null)
			{
						
				ArrayList cinfolist = (ArrayList)Session ["cinfolist"];
				int i = 0;
				foreach (CounterInfo cinfo in cinfolist)
				{
					if (cinfo.isViewing == 1)
					{
						// get average value for this counter first
						avg = Average(cinfo.counterID,DropDownList1.SelectedItem.Value);
						CounterTableData += @"tableData[" + i.ToString() + "]=new dataArray('"+ cinfo.machineName + " ','" 
							+ cinfo.objectName + "','" + cinfo.displayName + "','" + cinfo.counterName + "'" + ",'" 
							+ cinfo.counterID.ToString() + "','" + cinfo.scale.ToString() + "','" + avg
							+ "','#" + cinfo.color.ToString("X6") + "','";
						if ((cinfo.color & 0xFFFF) < 0x9900)
						{
							CounterTableData += "white";
						}
						else
						{
							CounterTableData += "black";
						}
						CounterTableData += "');\n" ;
						i++;
					}
				}
				// -- Write Data to Page
				LiteralControl lc = new LiteralControl(CounterTableData );
				CounterDataPH.Controls.Add(lc);
			}
			else
			{
				Label3.Text = "Session state has expired. Log out and log back in.";
				Label3.Visible = true;
			}
		}

		protected void FindinText(ref DropDownList Dlist, string searchString)
		{
			searchString = searchString.Trim();
			for (int i = 0; i < Dlist.Items.Count;i++)
			{
				string newstring = Dlist.Items[i].Text.Trim();
				if(newstring.CompareTo(searchString)==0)
				{
					Dlist.SelectedItem.Selected = false;
					Dlist.Items[i].Selected = true;
					break;
				}
			}
			return;
		}

		protected void FindinValue(ref DropDownList Dlist, string searchString)
		{
			searchString = searchString.Trim();
			for (int i = 0; i < Dlist.Items.Count;i++)
			{
				string newstring = Dlist.Items[i].Value;
				if (newstring.IndexOf(searchString) >= 0)
				{
					Dlist.SelectedItem.Selected = false;
					Dlist.Items[i].Selected = true;
					break;
				}
			}
			return;
		}
		#endregion
		#region PerfGraphDataFunctions

		protected void LogOutNow()
		{
			// Set the cookie to expire now
			HttpCookie UserName_Cookie = new HttpCookie("UserName","");
			Response.Cookies.Add(UserName_Cookie);
			// go to login page
			Response.Redirect(@".\login.aspx");
		}

		protected double Average(int counterid, string guid)
		{
			string query = "SELECT avg([CounterValue]) FROM [PerfDB].[dbo].[CounterData] where " +
				"counterID ="+counterid+ " and GUID='"+guid+"'" +
				"and CounterDateTime between '" + GraphStartTime.Text + "' and '" + GraphStopTime.Text + "'";
			double val=0;
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText=query;
			SqlComm.Connection= cn;

			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				val = (double)SqlComm.ExecuteScalar();
				
			}
			catch(System.Exception e)
			{
			//	Session["error"] += "Exception caught:" + e.Message;
				val = 0;
			}
			finally
			{
				if(cn != null)
					cn.Close();
			}
			return val;
		}
		protected void PopulateCounterInfo ()
		{
			Label3.Visible = false;
			// -- Perform SQL Stored Procedure
			// This stored procedure will get all counters in the CounterDetails table 
			// and put them into cinfolist regardless of GUID
			SqlCommand sqlCommand = new SqlCommand("p_GetAllCounterInfo", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;
			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);
			SqlDataReader	dReader = null;

			ArrayList cinfolist = new ArrayList();
			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				dReader = sqlCommand.ExecuteReader();
			
				// Columns in the returned data reader
			
				const int MACHINENAME = 0;
				const int OBJECTNAME = 1;
				const int DISPLAYNAME = 2;
				const int COUNTERNAME = 3;
				const int COUNTERID = 4;

	//			ArrayList cinfolist = new ArrayList();
			
				while (dReader.Read())
				{
					CounterInfo cinfo = new CounterInfo(dReader.GetString(MACHINENAME),dReader.GetString(OBJECTNAME),dReader.GetString(DISPLAYNAME),dReader.GetString(COUNTERNAME),dReader.GetInt32(COUNTERID),0,1);
					cinfolist.Add(cinfo);
				}
			}
			catch(Exception e)
			{
				Session["error"] += "Exception caught:" + e.Message;
			}
			finally
			{
				if(dReader != null)
					dReader.Close();
				if(cn != null)
					cn.Close();
			}
			GetViewingCounters(ref cinfolist);
			Session["cinfolist"]=cinfolist;
		}

		// ------------------------------------------------------------------
		protected void GetViewingCounters(ref ArrayList cinfolist)
		{
			// -- Perform SQL Stored Procedure

			SqlCommand sqlCommand = new SqlCommand("p_GetViewingCounters_DisplayGraph", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;
			sqlCommand.Parameters.Add("@username", SqlDbType.VarChar, 20).Value = Session["UserName"];
			sqlCommand.Parameters.Add("@graphname", SqlDbType.VarChar, 30).Value = Session["graphname"];
			sqlCommand.Parameters.Add("@GUID", SqlDbType.VarChar, 1024).Value = DropDownList1.SelectedItem.Value;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);
			SqlDataReader dReader = null;
			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				dReader = sqlCommand.ExecuteReader();

				const int COUNTERID = 0;
				const int SCALE = 1;
				int CounterID = 0;
				float scale = 0;
				int cinfo_pointer = 0;
				while (dReader.Read())
				{
					CounterID = dReader.GetInt32(COUNTERID);
					scale = (float)dReader.GetDouble(SCALE);
					for (; (cinfo_pointer < cinfolist.Count); cinfo_pointer++)
					{
						if (CounterID > ((CounterInfo)cinfolist[cinfo_pointer]).counterID)
						{
							((CounterInfo)cinfolist[cinfo_pointer]).isViewing = 0;
						}
						else if(CounterID == ((CounterInfo)cinfolist[cinfo_pointer]).counterID)
						{
							((CounterInfo)cinfolist[cinfo_pointer]).isViewing = 1;
							((CounterInfo)cinfolist[cinfo_pointer]).scale = scale;
							cinfo_pointer++;
							break;
						}
						else
						{
							break;
						}
					}
				}
			}
			catch(Exception e)
			{
				Session["error"] += "Exception caught:" + e.Message;
			}
			finally
			{
				if(dReader != null)
					dReader.Close();
				if(cn != null)
					cn.Close();
			}
		}
		// ------------------------------------------------------------------
		protected ArrayList GetCounterByGraph ()
		{
			//p_GetViewingCounters_DisplayGraph
			this.CountersByGraph_sql.CommandText = "Select DISTINCT [CounterID] from [PerfDB].[dbo].[DisplayGraph] where [Owner] = '" + Session["UserName"] + "'";
			ArrayList CounterByGraph = new ArrayList();
			const int COUNTERID = 0;
			int CounterID = 0;
			
			SqlDataReader dReader = CountersByGraph_sql.ExecuteReader();
			
			while (dReader.Read())
			{
				CounterID = dReader.GetInt32(COUNTERID);
				CounterByGraph.Add(CounterID);
			}
			dReader.Close();
			
			return CounterByGraph;
			
		}
		// ------------------------------------------------------------------
		protected void BuildCharts ()
		{
			System.IO.StringWriter sw;
			XmlDocument xDoc = new XmlDocument();
			DataSet ds;		
			OWC11.ChartSpaceClass       oChartSpace = new OWC11.ChartSpaceClass ();
			string timeMin = String.Empty;
			string timeMax = String.Empty;
			int recordMin = -1;
			int recordMax = -1;
			if (Session["cinfolist"] != null)
			{
				ArrayList cinfolist = (ArrayList)Session ["cinfolist"];
			
				SqlDataAdapter adapter;

				oChartSpace.Border.Color = "white";
				oChartSpace.Charts.Add(0);
			
				oChartSpace.Charts[0].Type = ChartChartTypeEnum.chChartTypeLine;
			
				int numLines = 1;
				int max_nCount = 0;
			
				foreach (CounterInfo cinfo in cinfolist)
				{
					if (cinfo.isViewing == 1)
					{
						adapter = new SqlDataAdapter();
						adapter.SelectCommand = new SqlCommand("Select [RecordIndex], [CounterValue], [CounterDateTime] " +
							"from [PerfDB].[dbo].[CounterData] cd " +
							"WHERE [CounterDateTime] between '" + GraphStartTime.Text + "' and '" + GraphStopTime.Text + "' AND " +
							"GUID='" + DropDownList1.SelectedItem.Value + "' AND " +
							"[CounterID]=" + cinfo.counterID.ToString() +
							" ORDER BY [RecordIndex]", cn);
					
						ds = new DataSet("Chart");
						if(cn.State != System.Data.ConnectionState.Open)
							this.cn.Open();
						adapter.Fill(ds);
						cn.Close();
						// clean up	
						
						adapter.Dispose();
						sw = new System.IO.StringWriter();
						ds.WriteXml(sw);
						ds.Dispose();
						xDoc.LoadXml(sw.ToString());
						sw.Close();
						System.Xml.XmlNodeList nodes;
						nodes = xDoc.ChildNodes.Item(0).ChildNodes;
						int nCount = nodes.Count;
						if (nCount > max_nCount)
						{
							max_nCount = nCount;
						}
						string[] aNames = new string[nCount+1];
						string[] aTotals = new string[nCount+1];
						string[] aTimes = new string[nCount+1];
						string names=String.Empty;
						string totals =String.Empty;
						string times =String.Empty;
						double tempnum;
							
					
						int i = 0;
						for(i=1;i<=nCount;i++)
						{
							aNames[i]= nodes.Item(i-1).ChildNodes.Item(0).InnerText;     
							tempnum = double.Parse(nodes.Item(i-1).ChildNodes.Item(1).InnerText);
							aTotals[i]= (tempnum*cinfo.scale).ToString();  
							aTimes[i]= nodes.Item(i-1).ChildNodes.Item(2).InnerText.Trim();  
						}
						if (nCount > 0)
						{
							if (timeMin.CompareTo(String.Empty)==0)
							{
								// setup min and max high watermarks to some default value
								timeMin = timeMax = nodes.Item(nCount-1).ChildNodes.Item(2).InnerText;
							}
							if (timeMin.CompareTo(nodes.Item(0).ChildNodes.Item(2).InnerText) > 0)
							{
								timeMin = nodes.Item(0).ChildNodes.Item(2).InnerText;
							}
					
							if (timeMax.CompareTo(nodes.Item(nCount-1).ChildNodes.Item(2).InnerText) < 0 )
							{
								timeMax = nodes.Item(nCount-1).ChildNodes.Item(2).InnerText;
							}

							if (recordMin == -1 || recordMax == -1)
							{
								recordMin = recordMax = Int32.Parse(nodes.Item(nCount-1).ChildNodes.Item(0).InnerText);
							}

							if (recordMin > Int32.Parse(nodes.Item(0).ChildNodes.Item(0).InnerText))
							{
								recordMin = Int32.Parse(nodes.Item(0).ChildNodes.Item(0).InnerText);
							}

							if (recordMax < Int32.Parse(nodes.Item(nCount-1).ChildNodes.Item(0).InnerText))
							{
								recordMax = Int32.Parse(nodes.Item(nCount-1).ChildNodes.Item(0).InnerText);
							}
	        
							names= String.Join("\t", aNames);  //Chart control accepts tab-delimited string of values
							totals= String.Join("\t", aTotals);  //Chart control accepts tab-delimited string of values
							times= String.Join("\t", aTimes);  //Chart control accepts tab-delimited string of values
						
				
							oChartSpace.Charts[0].SeriesCollection.Add(numLines-1);
							oChartSpace.Charts[0].SeriesCollection[numLines-1].Caption = cinfo.counterID.ToString();
						
							oChartSpace.Charts[0].SeriesCollection[numLines-1].SetData (OWC11.ChartDimensionsEnum.chDimCategories,
								Convert.ToInt32(OWC11.ChartSpecialDataSourcesEnum.chDataLiteral), names);
						
							oChartSpace.Charts[0].SeriesCollection[numLines-1].SetData (OWC11.ChartDimensionsEnum.chDimValues,
								Convert.ToInt32(OWC11.ChartSpecialDataSourcesEnum.chDataLiteral), totals);
							cinfo.color = (int)oChartSpace.Charts[0].SeriesCollection[numLines-1].Line.Color;
						
							// switch order of high order byte
							cinfo.color = ((cinfo.color & 0xff)<<16)|(cinfo.color & 0x00ff00)|((cinfo.color &0xff0000)>>16);
							numLines++;

						
						}
					
					}

				}

			


				oChartSpace.Charts[0].HasTitle = false;
				//		oChartSpace.Charts[0].Title.Caption = "Performance Data from:" + timeMin.Trim() + "\n to:" + timeMax.Trim();
				//		oChartSpace.Charts[0].Title.Font.Bold = true;
				oChartSpace.Charts[0].HasLegend = true;
				oChartSpace.Charts[0].Legend.Position = ChartLegendPositionEnum.chLegendPositionBottom;
				oChartSpace.Charts[0].Axes[0].HasTickLabels = false;
		
				/*ChAxis newaxis = oChartSpace.Charts[0].Axes[1];
				newaxis.Scaling.HasAutoMaximum = false;
				newaxis.Scaling.HasAutoMinimum = false;
				newaxis.Scaling.Maximum = recordMax;
				newaxis.Scaling.Minimum = recordMin;*/
			
				if (max_nCount > 4)
				{
					oChartSpace.Charts[0].Axes[0].TickMarkSpacing = ((max_nCount)/4); 
					//oChartSpace.Charts[0].Axes[0].TickLabelSpacing = ((max_nCount)/4); 
				}

				// ------------------------------------------------------------------------
				// Pick your favorite image format
				// ------------------------------------------------------------------------
				byte[]  byteArr = (byte[]) oChartSpace.GetPicture ("png", 500, 500);

				// ------------------------------------------------------------------------
				// Store the chart image in Session to be picked up by an HttpHandler later
				// ------------------------------------------------------------------------
				HttpContext     ctx = HttpContext.Current;
				string          chartID = Guid.NewGuid ().ToString ();
            
				ctx.Session [chartID] = byteArr;
				imgPerfGraph.ImageUrl = string.Concat ("chart.ashx?", chartID);
			}
			else
			{
				Label3.Text = "Session State has expired. Log out and log back in.";
				//Label3.Visible = true;
			}
		}

		private void ViewGraph_btn_Click(object sender, System.EventArgs e)
		{
			if(CheckLogTimeTextBox(GraphStartTime.Text, GraphStopTime.Text))
			{
				if(DateTime.Parse(GraphStartTime.Text)>DateTime.Parse(GraphStopTime.Text))
				{
					Label3.Visible = true;
					Label3.Text = "StopTime should be greater than StartTime!";
					return;
				}
				else
				{
					Label3.Visible = false;
					Session["StartTime"] = GraphStartTime.Text;
					Session ["StopTime"]= GraphStopTime.Text;
					ShowGraph();
				}
			}
			else
			{
				Label3.Visible = true;
				Label3.Text = "Wrong Time Format entered!";
				return;
			}
		}	
		#endregion
	}

	public class SQLserver
	{
		public const string value = "localhost";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Report\CreateReport.aspx.cs ===
using System;
using System.Text;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace Report
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.PlaceHolder PlaceHolder1;
		protected System.Web.UI.WebControls.DropDownList CategoryList1;
		

		protected System.Data.SqlClient.SqlConnection cn = new SqlConnection();
		protected System.Web.UI.WebControls.DropDownList ComponentList1;
		protected System.Web.UI.WebControls.Panel DefaultPanel;
		protected System.Web.UI.HtmlControls.HtmlForm Form1;
		protected System.Web.UI.WebControls.Label ReportName;
		protected System.Web.UI.WebControls.Panel MenuPanel;
		protected System.Web.UI.WebControls.Label ErrorLabel;
		protected System.Web.UI.WebControls.Button Button1;
		protected System.Web.UI.WebControls.DataGrid NameFormula;
		protected System.Web.UI.WebControls.DropDownList MachineList1;

		
		
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			

			// Put user code to initialize the page here
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security i" +
				"nfo=False;initial catalog=PerfDB";
			if(!this.IsPostBack)
			{
				FillCategories();
				FillComponents();
				FillMachineList();
				
				
			}

			if((string)Session["RedirectToCreate"]=="True")
			{
				Session["RedirectToCreate"]="False";
				if(Session["ReportName"]!=null)
				{
					PopulateNameFormuls();
				}
			}

			Session["SelectedMachine"] = MachineList1.SelectedIndex;
		}

		override protected void OnPreRender(EventArgs e)
		{
			//PopulateCounterInfo();
			PopulateCounterTable();
			base.OnPreRender(e);
		}


		
		protected void PopulateNameFormuls()
		{

			ReportName.Text=(string)Session["ReportName"];
			string Query = "SELECT [ID], [Name], [Formula], [Criteria] FROM [PerfDB].[dbo].[Report_Formula] rf ";
			Query += "inner join [PerfDB].[dbo].[Report] r on r.ReportID= rf.ReportID";
			Query+= " where Reportname='"+(string) Session["ReportName"]+"'";

			DataTable  dt = new DataTable();
			if (Session["NameFormuls"] == null)     
			{
				dt.Columns.Add(new DataColumn("id",typeof(int)));
				dt.Columns.Add(new DataColumn("Name",typeof(string)));
				dt.Columns.Add(new DataColumn("Formula",typeof(string)));
				dt.Columns.Add(new DataColumn("Criteria",typeof(double)));

				Session["NameFormuls"]= dt;
			}
			else
			{
				dt= (DataTable) Session["NameFormuls"];
			}
			dt.Rows.Clear();
			
			DataRow dr = dt.NewRow();
			dt.Rows.Add(dr);
            NameFormula.EditItemIndex = 0;
			

			if(Query != null)
			{
				
				SqlCommand SqlComm= new SqlCommand();
				SqlComm.CommandText=Query;
				SqlComm.Connection= cn;

				cn.Open();
				SqlDataReader dReader= null;
				try
				{
					dReader = SqlComm.ExecuteReader();
					while (dReader.Read())
					{
						DataRow drt = dt.NewRow();
						drt[0] = dReader.GetInt32(0);
						drt[1] = dReader.GetString(1);
						drt[2] = dReader.GetString(2);
						drt[3] =dReader.GetDouble(3);
						dt.Rows.Add(drt);
					}
					
				}
				catch(System.Exception exp)
				{
					string tmp = exp.ToString();
					//set error here 
				}
				finally
				{
					if(dReader!=null)
						dReader.Close();
					cn.Close();
				}
			}
			

			BindGrid();
		}

		protected void BindGrid()
		{
			DataTable dt =(DataTable) Session["NameFormuls"];
			DataView dView = new DataView(dt);
			NameFormula.DataSource=dView;
			NameFormula.DataBind();
		}

		protected void PopulateCounterInfo ()
		{
			// -- Perform SQL Stored Procedure

			SqlCommand sqlCommand = new SqlCommand("p_GetRealCounters", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;
			
			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			cn.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			
			// Columns in the returned data reader
			
			const int MACHINENAME = 1;
			const int OBJECTNAME = 2;
			const int DISPLAYNAME = 3;
			const int COUNTERNAME = 4;
			const int COUNTERID = 0;

			ArrayList cinfolist = new ArrayList();
			
			while (dReader.Read())
			{
				CounterInfo cinfo = new CounterInfo(dReader.GetString(MACHINENAME),dReader.GetString(OBJECTNAME),dReader.GetString(DISPLAYNAME),dReader.GetString(COUNTERNAME),dReader.GetInt32(COUNTERID),0,1);
				cinfolist.Add(cinfo);
			}
			dReader.Close();
			cn.Close();
			//GetViewingCounters(ref cinfolist);
			Session["cinfolist"]=cinfolist;
		}



		public void PopulateCounterTable()
		{
			string tableData = "";
			//int j = 0;
			string selectedCategory = CategoryList1.SelectedItem.Text;
			//string cname;
			
			if (MachineList1.SelectedIndex == 1)
			{
				tableData =  p_GetAggCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue));
			}
			else
			{
				tableData = p_GetRealCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue), MachineList1.SelectedIndex);
			}
			
						
			// write out counter info to webpage
		/*	foreach (CounterInfo cinfo in cinfolist)
			{
				cname = cinfo.objectName;
				tableData += @"tableData[" + j.ToString() + "]=new dataArray('"+ cinfo.machineName + " ','" 
					+ cinfo.objectName + "','" + cinfo.displayName + "','" + cinfo.counterName + "'" + ",'" + cinfo.counterID.ToString() + "','"+ cinfo.scale.ToString() + "');\n" ;
				j++;
				
			}
			*/
			//numFilteredCounters.Text = "Filtered Counters: " + j.ToString();
			// -- Write Data to Page
			LiteralControl lc = new LiteralControl(tableData );
			PlaceHolder1.Controls.Add(lc);

		}

		public string p_GetRealCounterInfo(
			int CategoryID,
			int ComponentID,
			int MachineIndex)
		{
			
			SqlCommand sqlCommand = new SqlCommand("p_GetRealCounterInfo", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			if (CategoryID > 0) 
				sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
			if (ComponentID > 0)
				sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
			if (MachineIndex > 0)
				sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineList1.SelectedItem.Text;
			//else "All normal" is selected as "Machines"
			cn.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			
			// Columns in the returned data reader
			const int COUNTERID =   0;
			const int MACHINENAME = 1;
			const int OBJECTNAME =  2;
			const int COUNTERNAME = 3;
			const int DISPLAYNAME = 4;
			
			

			
			StringBuilder tableData= new StringBuilder();
			int j=0;
			while (dReader.Read())
			{
				/*CounterInfo cinfo = new CounterInfo(dReader.GetString(MACHINENAME),dReader.GetString(OBJECTNAME),dReader.GetString(DISPLAYNAME),dReader.GetString(COUNTERNAME),dReader.GetInt32(COUNTERID),0,1);
				cinfo.isViewing=CounterInfo.Viewing;
				cinfolist.Add(cinfo);
				*/
				tableData.Append(@"tableData[" + j.ToString() + "]=new dataArray('"+ dReader.GetString(MACHINENAME) + " ','" 
					+ dReader.GetString(OBJECTNAME) + "','" + dReader.GetString(DISPLAYNAME) + "','" + dReader.GetString(COUNTERNAME) + "'" + ",'" + dReader.GetInt32(COUNTERID) + "','"+ 0 + "');\n") ;
					

			
				j++;
			}

			dReader.Close();
			cn.Close();

			return tableData.ToString();
		}

		public string p_GetAggCounterInfo(
			int CategoryID,
			int ComponentID)
		{
			SqlCommand sqlCommand = new SqlCommand("p_GetAggCounterInfo", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			if (CategoryID > 0) 
				sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
			if (ComponentID > 0)
				sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
			cn.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			
			// Columns in the returned data reader
			// Columns in the returned data reader
			const int COUNTERID =   0;
			const int OBJECTNAME =  1;
			const int COUNTERNAME = 2;
			const int DISPLAYNAME = 4;
			
			//ArrayList cinfolist = new ArrayList();
			StringBuilder tableData = new StringBuilder();
			int j=0;
			while (dReader.Read())
			{
				/*CounterInfo cinfo = new CounterInfo("Aggregate",dReader.GetString(OBJECTNAME),dReader.GetString(DISPLAYNAME),dReader.GetString(COUNTERNAME),dReader.GetInt32(COUNTERID),0,1);
				cinfo.isViewing=CounterInfo.Viewing;
				cinfolist.Add(cinfo);
				*/
				tableData.Append( @"tableData[" + j.ToString() + "]=new dataArray('Aggregate','" 
					+ dReader.GetString(OBJECTNAME) + "','" + dReader.GetString(DISPLAYNAME) + "','" + dReader.GetString(COUNTERNAME) + "'" + ",'" + dReader.GetInt32(COUNTERID) + "','"+ 0 + "');\n" );
				j++;
			}

			dReader.Close();
			cn.Close();
			
			return tableData.ToString();
		}            


	
		protected void FillCategories()
		{
			SqlCommand sqlcmdSelectCategories= new System.Data.SqlClient.SqlCommand();
			sqlcmdSelectCategories.CommandText = "SELECT CategoryID, CategoryName FROM Category ORDER BY CategoryName";
			sqlcmdSelectCategories.Connection = this.cn;
			BindDrop(CategoryList1, sqlcmdSelectCategories, "CategoryName", "CategoryID");
			CategoryList1.Items.Insert(0, new ListItem("(All)","0"));
			if (Session["SelectedCategory"] != null)
			{
				CategoryList1.SelectedItem.Selected = false;
				CategoryList1.Items[(int)Session["SelectedCategory"]].Selected = true;
			}	
			else
			{
				Session["SelectedCategory"] = 0;
			}
		}

		protected void FillComponents()
		{
			SqlCommand sqlcmdSelectComponents= new System.Data.SqlClient.SqlCommand();
			sqlcmdSelectComponents.CommandText = "SELECT ComponentID, ComponentName FROM Component";
			sqlcmdSelectComponents.Connection = this.cn;
			
			if (CategoryList1.SelectedIndex == 0)
				BindDrop(ComponentList1, sqlcmdSelectComponents, "ComponentName", "ComponentID");
			else
			{
				sqlcmdSelectComponents.CommandText = @"SELECT DISTINCT Component.ComponentID AS ComponentID, Component.ComponentName AS ComponentName FROM Component INNER JOIN CompCatMach ON Component.ComponentID = CompCatMach.ComponentID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Component.ComponentName";
				sqlcmdSelectComponents.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
				sqlcmdSelectComponents.Parameters["@catid"].Value = CategoryList1.SelectedValue;
				BindDrop(ComponentList1, sqlcmdSelectComponents, "ComponentName", "ComponentID");
			}
			ComponentList1.Items.Insert(0, new ListItem("(All)","0"));
//			if (Session["SelectedComponent"] != null)
//			{
//				ComponentList1.SelectedItem.Selected = false;
//				ComponentList1.Items[(int)Session["SelectedComponent"]].Selected = true;
//			}
//			else
//			{
				Session["SelectedComponent"] = 0;
//			}
		}

		
		private void FillMachineList()
		{
			SqlCommand sqlcmdSelectMachines= new System.Data.SqlClient.SqlCommand();
			sqlcmdSelectMachines.Connection = this.cn;

			// no categories selected?
			if (CategoryList1.SelectedIndex == 0)
			{
				if (ComponentList1.SelectedIndex == 0)
				{
					sqlcmdSelectMachines.CommandText = "SELECT MachineID, MachineName FROM Machines ORDER BY MachineName";
					BindDrop(MachineList1, sqlcmdSelectMachines, "MachineName", "MachineID");
				}
					// All categories, 1 component
				else
				{
					sqlcmdSelectMachines.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
						"ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
						"hineID WHERE (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
					sqlcmdSelectMachines.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
					sqlcmdSelectMachines.Parameters["@compid"].Value = ComponentList1.SelectedValue;
					BindDrop(MachineList1, sqlcmdSelectMachines, "MachineName", "MachineID");
				}                                                                                                         
			}
			else
			{
				if (ComponentList1.SelectedIndex == 0)
				{
					sqlcmdSelectMachines.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
						"ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
						"hineID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Machines.MachineName";
					sqlcmdSelectMachines.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
					sqlcmdSelectMachines.Parameters["@catid"].Value = CategoryList1.SelectedValue;
					BindDrop(MachineList1,sqlcmdSelectMachines, "MachineName", "MachineID");
				}
					// 1 category, 1 component
				else
				{
					sqlcmdSelectMachines.CommandText = @"SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineName FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.MachineID WHERE (CompCatMach.CategoryID = @catid) AND (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
					sqlcmdSelectMachines.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
					sqlcmdSelectMachines.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
					sqlcmdSelectMachines.Parameters["@compid"].Value = ComponentList1.SelectedValue;
					sqlcmdSelectMachines.Parameters["@catid"].Value = CategoryList1.SelectedValue;
					BindDrop(MachineList1, sqlcmdSelectMachines, "MachineName", "MachineID");
				}                                                                                                         
			}
			MachineList1.Items.Insert(0, new ListItem("(All normal)","0"));
			MachineList1.Items.Insert(1, new ListItem("(All aggregate)","1"));
			if (Session["SelectedMachine"] != null)
			{
				MachineList1.SelectedItem.Selected = false;
				MachineList1.Items[(int)Session["SelectedMachine"]].Selected = true;
			}
			else
			{
				Session["SelectedMachine"] = 0;
			}
		}

		
		protected void BindDrop(DropDownList control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
		{
			cn.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			control.DataSource = dReader;
			control.DataTextField = dataTextField;
			control.DataValueField = dataValueField;
			control.DataBind();
			dReader.Close();
			cn.Close();
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Button1.Click += new System.EventHandler(this.Button1_Click);
			this.CategoryList1.SelectedIndexChanged += new System.EventHandler(this.CategoryList1_SelectedIndexChanged);
			this.ComponentList1.SelectedIndexChanged += new System.EventHandler(this.ComponentList1_SelectedIndexChanged);
			this.NameFormula.CancelCommand += new System.Web.UI.WebControls.DataGridCommandEventHandler(this.NameFormula_CancelCommand);
			this.NameFormula.EditCommand += new System.Web.UI.WebControls.DataGridCommandEventHandler(this.NameFormula_EditCommand);
			this.NameFormula.UpdateCommand += new System.Web.UI.WebControls.DataGridCommandEventHandler(this.NameFormula_UpdateCommand);
			this.NameFormula.DeleteCommand += new System.Web.UI.WebControls.DataGridCommandEventHandler(this.NameFormula_DeleteCommand);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void CategoryList1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			FillComponents();
			FillMachineList();
			Session["SelectedCategory"] = CategoryList1.SelectedIndex;
		}

		private void ComponentList1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			FillMachineList();
			Session["SelectedComponent"] = ComponentList1.SelectedIndex;
		}

		private void NameFormula_EditCommand(object source, System.Web.UI.WebControls.DataGridCommandEventArgs e)
		{
			NameFormula.EditItemIndex = (int)e.Item.ItemIndex;
			BindGrid();

		}

		protected int getReportid(string name)
		{
			int Reportid=0;
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="SELECT [ReportID] FROM [PerfDB].[dbo].[Report] where Reportname='"+name+"'";
			SqlComm.Connection= cn;

			cn.Open();
			try
			{
				Reportid= (int)SqlComm.ExecuteScalar();
				
			}
			catch(System.Exception)
			{
				//set error here 
			}
			finally
			{
				cn.Close();
			}
			return Reportid;

		}

		private bool insertFormula(int Reportid,string Name, string Formula, double Criteria)
		{
			bool retval = true;
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="INSERT INTO [PerfDB].[dbo].[Report_Formula]([ReportID], [Name], [Formula], [Criteria])";
			SqlComm.CommandText+="VALUES( '"+Reportid+"', '"+Name+"', '"+Formula+"',"+Criteria+")";
			SqlComm.Connection= cn;

			cn.Open();
			try
			{
				SqlComm.ExecuteNonQuery();
				
				
			}
			catch(System.Exception ep)
			{
				ErrorLabel.Text=ep.ToString();
				//set error here
				retval = false;
			}
			finally
			{
				cn.Close();
			}
			return retval;
		}

		private bool UpdateFormula(int id,string Name, string Formula, double Criteria)
		{
			bool retval = true;
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="UPDATE [PerfDB].[dbo].[Report_Formula]";
			SqlComm.CommandText +=" SET [Name]='"+Name + "', [Formula]='"+Formula+"', [Criteria]="+Criteria;
			SqlComm.CommandText +="	WHERE [ID]= "+id;
			SqlComm.Connection= cn;

			cn.Open();
			try
			{
				SqlComm.ExecuteNonQuery();
				
				
			}
			catch(System.Exception ep)
			{
				ErrorLabel.Text=ep.ToString();
				//set error here 
				retval= false;
			}
			finally
			{
				cn.Close();
			}
			return retval;

		}


		protected bool verifyFormula(string formula)
		{
			bool retval = true;

			FormulaEval eval = new FormulaEval();
			try
			{
				eval.verify(formula);
			}
			catch( System.Exception e)
			{
				ErrorLabel.Text= "Error Formula :-"+ e.Message;
				retval= false;
			}
			return retval;
		}

		private void NameFormula_UpdateCommand(object source, System.Web.UI.WebControls.DataGridCommandEventArgs e)
		{
			ErrorLabel.Text="";
			bool passed= false;
			try
			{
				string Name = ((TextBox)e.Item.Cells[0].Controls[0]).Text;;
				string Formula = ((TextBox)e.Item.Cells[1].Controls[0]).Text;
				((TextBox)e.Item.Cells[1].Controls[0]).Text = Formula= Formula.ToLower();
				string Criteria = ((TextBox)e.Item.Cells[2].Controls[0]).Text;
				string ID = e.Item.Cells[3].Text;
				double iCriteria;

				if(Name==null || Name=="")
				{
					ErrorLabel.Text= "Error Invalid Name ";
					return ;
				}

				if(Formula==null || Formula=="")
				{
					ErrorLabel.Text= "Error Invalid Formula ";
					return ;
				}

				try
				{
					iCriteria = Double.Parse(Criteria);
				}
				catch(System.Exception)
				{
					ErrorLabel.Text= "Error Criteria :- only numbers allowed";
					
					return ;
				}
				if(!verifyFormula(Formula))
				{
					return ;
				}
				//Update Database.
				int Reportid= getReportid((string) Session["ReportName"]);

				if(ID ==null || ID =="" || ID =="&nbsp;")
					passed= insertFormula(Reportid,Name,Formula,iCriteria);
				else
					passed =UpdateFormula(Int32.Parse(ID),Name,Formula,iCriteria);

				if(passed)
					PopulateNameFormuls();
			}
			catch( System.Exception )
			{
				//set error here.
			}
		}

		private void NameFormula_DeleteCommand(object source, System.Web.UI.WebControls.DataGridCommandEventArgs e)
		{
				bool passed = true;
				string ID = e.Item.Cells[3].Text;
				SqlCommand SqlComm= new SqlCommand();
				SqlComm.CommandText="delete [PerfDB].[dbo].[Report_Formula]";
				SqlComm.CommandText +="	WHERE [ID]= "+Int32.Parse(ID);
				SqlComm.Connection= cn;

				cn.Open();
				try
				{
					SqlComm.ExecuteNonQuery();
				}
				catch(System.Exception ep)
				{
					ErrorLabel.Text=ep.ToString();
					//set error here 
					passed= false;
				}
				finally
				{
					cn.Close();
				}

			if(passed)
				PopulateNameFormuls();
		}

		private void NameFormula_CancelCommand(object source, System.Web.UI.WebControls.DataGridCommandEventArgs e)
		{
			PopulateNameFormuls();
		}

		private void Button1_Click(object sender, System.EventArgs e)
		{
			Session["RedirectToView"]="True";
			Server.Transfer(@".\Reportview.aspx");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\Login.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace PerfGraphTool
{
	/// <summary>
	/// Summary description for Login.
	/// </summary>
	public class Login_Page : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.TextBox TextBox1_UserName;
		protected System.Web.UI.WebControls.DropDownList Existing_UserName_DropBox;
		protected System.Data.SqlClient.SqlCommand PopulateDListUserNames_SQL;
		protected System.Data.SqlClient.SqlConnection cn;
		protected System.Web.UI.WebControls.Button New_Login_btn;
		protected System.Web.UI.WebControls.Button Login_btn;
		protected HttpCookie UserNameCookie;

		private void Create_Cookie(string username)
		{
			Session["UserName"] = username;
			UserNameCookie = new HttpCookie("UserName",username);
			UserNameCookie.Expires = System.DateTime.Now.AddDays(30);
			Response.Cookies.Add(UserNameCookie);
			Response.Redirect(@".\default.aspx");
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.PopulateDListUserNames_SQL = new System.Data.SqlClient.SqlCommand();
			this.cn = new System.Data.SqlClient.SqlConnection();
			this.New_Login_btn.Click += new System.EventHandler(this.New_Login_btn_Click);
			// 
			// PopulateDListUserNames_SQL
			// 
			this.PopulateDListUserNames_SQL.CommandText = "Select DISTINCT [Owner] from [PerfDB].[dbo].[DisplayGraph]";
			this.PopulateDListUserNames_SQL.Connection = this.cn;
			// 
			// cn
			// 
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security i" +
				"nfo=False;initial catalog=PerfDB";
			this.Login_btn.Click += new System.EventHandler(this.Login_btn_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Page_Load(object sender, System.EventArgs e)
		{
			HttpCookie UserName_Cookie = Request.Cookies["UserName"];
			if (!Page.IsPostBack)
			{
				if (UserName_Cookie != null)
				{	
					if (UserName_Cookie.Value == "")
					{
						BindDrop(Existing_UserName_DropBox, PopulateDListUserNames_SQL, "Owner", "Owner");
					}
					else
					{
						Session["UserName"] = UserName_Cookie.Value;
						// redirect to main page
						Response.Redirect(@".\default.aspx");
					}
				}
				else
				{
					BindDrop(Existing_UserName_DropBox, PopulateDListUserNames_SQL, "Owner", "Owner");
				}
			}
			
		}


		private void BindDrop(DropDownList control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
		{
			SqlDataReader dReader = null;
			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				dReader = sqlCommand.ExecuteReader();
				control.DataSource = dReader;
				control.DataTextField = dataTextField;
				control.DataValueField = dataValueField;
				control.DataBind();
			}
			catch
			{
			}
			finally
			{
				dReader.Close();
				cn.Close();
			}
		}

		private void New_Login_btn_Click(object sender, System.EventArgs e)
		{
			//create entry for new user in DisplayGraph table.
			SqlCommand sqlCommand = new SqlCommand("p_AddUser_DisplayGraph", cn);
			sqlCommand.CommandType = CommandType.StoredProcedure;
			sqlCommand.Parameters.Add("@UserName", SqlDbType.VarChar, 20).Value = TextBox1_UserName.Text;
			sqlCommand.Parameters.Add("@graphname", SqlDbType.VarChar, 30).Value = "Graph1";
			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			try
			{
				if(cn.State == System.Data.ConnectionState.Closed)
					cn.Open();
				sqlCommand.ExecuteNonQuery();
			}
			catch
			{
				
			}
			finally
			{
				if(cn != null)
					cn.Close();
			}

			Create_Cookie(TextBox1_UserName.Text);
		}

		private void Login_btn_Click(object sender, System.EventArgs e)
		{
			Create_Cookie(Existing_UserName_DropBox.SelectedItem.Value);
		}


	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Report\CounterInfo.cs ===
using System;

namespace Report
{
	public class CounterInfo
	{
		public string machineName;
		public string objectName;
		public string displayName;
		public string counterName;
		public int counterID;
		public int isViewing;
		public int isChanged;
		public float scale;
		public int color;
		public float avgValue;
		public const int notViewing = 0;
		public const int Viewing = 1;
		public const int Filtered = 2;			
		
		
		//public int 

		public CounterInfo(string MachineName, string ObjectName, string DisplayName, string CounterName, int CounterID, int IsViewing, float Scale)
		{
			this.machineName = MachineName;
			this.objectName = ObjectName;
			this.displayName = DisplayName;
			this.counterName = CounterName;
			this.counterID = CounterID;
			this.isViewing = IsViewing;
			this.isChanged = 0;
			this.scale = Scale;
			this.color = 0xCFCFCF;
			this.avgValue = 0;
		}

		public CounterInfo()
		{
			this.machineName = String.Empty;
			this.objectName = String.Empty;
			this.displayName = String.Empty;
			this.counterName = String.Empty;
			this.counterID = 0;
			this.isViewing = 0;
			this.isChanged = 0;
			this.scale = 1;
			this.color = 0xCFCFCF;
			this.avgValue = 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\PerfGraphTool\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace PerfGraphTool 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;

namespace XBLPerfLogService
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller XBLPerfLogService;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
			this.XBLPerfLogService = new System.ServiceProcess.ServiceInstaller();
			// 
			// serviceProcessInstaller1
			// 
			this.serviceProcessInstaller1.Password = null;
			this.serviceProcessInstaller1.Username = null;
			// 
			// XBLPerfLogService
			// 
			this.XBLPerfLogService.ServiceName = "XBLPerfLogService";
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.serviceProcessInstaller1,
																					  this.XBLPerfLogService});

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Report\Reportview.aspx.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace Report
{
	/// <summary>
	/// Summary description for Reportview.
	/// </summary>
	public class Reportview : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Panel Panel1;
		protected System.Web.UI.WebControls.TextBox TxtReportName;
		protected System.Web.UI.WebControls.Button Button1;
		protected System.Web.UI.WebControls.Label ErrorLabel;
		protected System.Web.UI.WebControls.Panel MenuPanel;
		protected System.Web.UI.HtmlControls.HtmlForm Form1;
		protected System.Web.UI.WebControls.DropDownList ReportList;
		protected System.Web.UI.WebControls.DataGrid ReportGrid;
		protected System.Web.UI.WebControls.Button ViewReport;
		protected System.Web.UI.WebControls.Label LogStopTime;
		protected System.Web.UI.WebControls.DropDownList LogList;
		protected System.Web.UI.WebControls.Button Button2;
		protected System.Web.UI.WebControls.TextBox viewStartTimeTextBox;
		protected System.Web.UI.WebControls.TextBox viewStopTimeTextBox;
		protected System.Web.UI.WebControls.Label ErrorLbl;
		protected System.Web.UI.WebControls.Literal PageUrl;
		protected System.Data.SqlClient.SqlConnection cn = new SqlConnection();
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security i" +
				"nfo=False;initial catalog=PerfDB";

			if(!IsPostBack)
			{
				if((Session["RedirectToView"] == null) ||(string)Session["RedirectToView"]!="True")
				{
					FillReports(null);
					FillCollectionGuids();
					Session["CurrentGuid"]= LogList.SelectedValue;
					BindLabelTextBox();
					Session["ReportName"]= ReportList.SelectedItem.Text;
					GenerateReport();
				}
			}

			if((string)Session["RedirectToView"]=="True")
			{
				Session["RedirectToView"]="False";
				if(Session["ReportName"]!=null)
				{
					FillReports((string)Session["ReportName"]);
					FillCollectionGuids();
					BindLabelTextBox();
					GenerateReport();
				}
			}
		
			NameValueCollection nameValueCol=Request.QueryString; 
			// Get names of all keys into a string array.
			String[] arr1 = nameValueCol.AllKeys; 
			if(arr1.Length > 0)
			{
				for (int i = 0; i < arr1.Length; i++) 
				{
					String[] nameValueColTemp = nameValueCol.GetValues(arr1[i]);
					if (arr1[i].CompareTo("ReportName") == 0)
					{
						for(int k = 0; k < ReportList.Items.Count; k++)
						{
							if(ReportList.Items[k].Value == nameValueColTemp[0])
								ReportList.SelectedIndex = k;
						}
						Session["ReportName"] = nameValueColTemp[0];
					}
					else if (arr1[i].CompareTo("Log") == 0)
					{
						for(int k = 0; k < LogList.Items.Count; k++)
						{
							if(LogList.Items[k].Value == nameValueColTemp[0])
								LogList.SelectedIndex = k;
						}
						Session["CurrentGuid"]=nameValueColTemp[0];
					}
					else if (arr1[i].CompareTo("StartTime") == 0)
					{
						viewStartTimeTextBox.Text = nameValueColTemp[0];
						Session["StartTime"] = nameValueColTemp[0];
					}
					else if (arr1[i].CompareTo("StopTime") == 0)
					{
						viewStopTimeTextBox.Text = nameValueColTemp[0];
						Session["StopTime"] = nameValueColTemp[0];
					}
				}
				GenerateReport();
			}
		}
		override protected void OnPreRender(EventArgs e)
		{
						
			PageUrl.Text = "<a href=\"http://livetest/Report/reportview.aspx?ReportName=" + Session["ReportName"] + 
				"&Log=" + Session["CurrentGuid"] +"&StartTime="+Session["StartTime"]+
				"&StopTime="+Session["StopTime"]+"\">Page URL</a>";

			base.OnPreRender(e);
		}
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.ReportList.SelectedIndexChanged += new System.EventHandler(this.ReportList_SelectedIndexChanged);
			this.LogList.SelectedIndexChanged += new System.EventHandler(this.LogList_SelectedIndexChanged);
			this.ViewReport.Click += new System.EventHandler(this.ViewReport_Click);
			this.Button2.Click += new System.EventHandler(this.Button2_Click);
			this.Button1.Click += new System.EventHandler(this.Button1_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Button1_Click(object sender, System.EventArgs e)
		{
			if(TxtReportName.Text == "")
			{
				ErrorLbl.Text = "Please enter a name for this report";
				return;
			}
			bool passed = false;
			Session["ReportName"] = TxtReportName.Text.Trim();
			
			//create new report and redirect to createreport page to add counters.
			
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="INSERT INTO [PerfDB].[dbo].[Report]([Reportname]) VALUES('"+ Session["ReportName"]+"')";
			SqlComm.Connection= cn;

			cn.Open();
			try
			{
				int rows = SqlComm.ExecuteNonQuery();
				passed=true;
			}
			catch(System.Exception)
			{
				//set error here 
			}
			finally
			{
				cn.Close();
			}

			if(passed)
			{
				Session["RedirectToCreate"]="True";
				Server.Transfer(@".\CreateReport.aspx");
			}
		}

		protected void FillReports(string selectedreport)
		{
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="SELECT [ReportID], [Reportname] FROM [PerfDB].[dbo].[Report]";
			SqlComm.Connection= cn;
			BindDrop(ReportList,SqlComm,"Reportname","ReportID");

			if(selectedreport!=null)
			{
				for(int i=0; i<ReportList.Items.Count;i++)
				{
					if(ReportList.Items[i].Text == selectedreport)
					{
						ReportList.SelectedIndex=i;
					}
				}
			}
		}
		
		protected void FillCollectionGuids()
		{
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="Select DISTINCT [LogStartTime],[GUID] from [PerfDB].[dbo].[DisplayToID] ORDER BY " +
				"[LogStartTime] DESC";
			SqlComm.Connection= cn;
			BindDrop(LogList,SqlComm,"LogStartTime","GUID");

			if(Session["CurrentGuid"]!=null)
			{
				LogList.SelectedValue=(string)Session["CurrentGuid"];
			}			
		}
		protected void BindDrop(DropDownList control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
		{
			cn.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();
			control.DataSource = dReader;
			control.DataTextField = dataTextField;
			control.DataValueField = dataValueField;
			control.DataBind();
			dReader.Close();
			cn.Close();
		}
		protected void BindGrid()
		{
			DataTable dt =(DataTable) Session["ReportGrid"];
			DataView dView = new DataView(dt);
			ReportGrid.DataSource=dView;
			ReportGrid.DataBind();
		}
		protected void BindLabelTextBox()
		{
			cn.Open();
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="SELECT  [LogStartTime], [LogStopTime] FROM [PerfDB].[dbo].[DisplayToID] "
								+"where [GUID]='" + LogList.SelectedValue + "'";
			SqlComm.Connection= cn;
			SqlDataReader	dReader = SqlComm.ExecuteReader();
			dReader.Read();
			LogStopTime.Text = dReader.GetString(1);

			if(Session["StartTime"] != null)
			{
				if(Session["StopTime"] == null)
				{
					Session["StopTime"] = LogStopTime.Text;
					viewStartTimeTextBox.Text = (string)Session["StartTime"];
					viewStopTimeTextBox.Text = (string)Session["StopTime"];
				}
				else
				{
					viewStartTimeTextBox.Text = (string)Session["StartTime"];
					viewStopTimeTextBox.Text = (string)Session["StopTime"];
				}
			}
			else
			{
				Session["StartTime"] = dReader.GetString(0);
				Session["StopTime"] = LogStopTime.Text;
				viewStartTimeTextBox.Text = (string)Session["StartTime"];
				viewStopTimeTextBox.Text = (string)Session["StopTime"];
			}

			dReader.Close();
			cn.Close();
		}
		protected void GenerateReport()
		{
			Session["StartTime"] = viewStartTimeTextBox.Text;
			Session["StopTime"] = viewStopTimeTextBox.Text;

			FormulaEval Fromal = new FormulaEval(LogList.SelectedValue, (string)Session["StartTime"], (string)Session["StopTime"]);

			string Query = "SELECT  [Name], [Formula], [Criteria],[ID] FROM [PerfDB].[dbo].[Report_Formula] rf ";
			Query += "inner join [PerfDB].[dbo].[Report] r on r.ReportID= rf.ReportID";
			Query+= " where Reportname='"+(string) Session["ReportName"]+"'";

			DataTable  dt = new DataTable();
			if (Session["ReportGrid"] == null)     
			{
				dt.Columns.Add(new DataColumn("Name",typeof(string)));
				dt.Columns.Add(new DataColumn("value",typeof(double)));
				dt.Columns.Add(new DataColumn("Criteria",typeof(double)));
				dt.Columns.Add(new DataColumn("Diff",typeof(double)));

				Session["ReportGrid"]= dt;
			}
			else
			{
				dt= (DataTable) Session["ReportGrid"];
			}
			dt.Rows.Clear();
			if(Query != null)
			{
				SqlCommand SqlComm= new SqlCommand();
				SqlComm.CommandText=Query;
				SqlComm.Connection= cn;

				cn.Open();
				SqlDataReader dReader= null;
				try
				{
					dReader = SqlComm.ExecuteReader();
					while (dReader.Read())
					{
						DataRow drt = dt.NewRow();
						drt[0] = dReader.GetString(0);
						double val = Fromal.Calculate(dReader.GetString(1));
						drt[1] = val;
						double criteria= dReader.GetDouble(2);
						drt[2] = criteria;
						drt[3] = (100* val)/criteria ;
						dt.Rows.Add(drt);
					}
				}
				catch(System.Exception exp)
				{
					string tmp = exp.ToString();
					//set error here 
				}
				finally
				{
					if(dReader!=null)
						dReader.Close();
					cn.Close();
				}
			}
			BindGrid();
		}

		private void Button2_Click(object sender, System.EventArgs e)
		{
			int idx = ReportList.SelectedIndex;
			Session["ReportName"] = ReportList.SelectedItem.Text.Trim();
			Session["RedirectToCreate"]="True";
			Server.Transfer(@".\CreateReport.aspx");
		}

		private void ReportList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Session["ReportName"] = ReportList.SelectedItem.Text.Trim();
			GenerateReport();
		}

		private void LogList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Session["CurrentGuid"]= LogList.SelectedValue;
			Session["StartTime"] = LogList.SelectedItem.Text;
			Session["StopTime"] = null;
			BindLabelTextBox();
			GenerateReport();
		}

		private void ViewReport_Click(object sender, System.EventArgs e)
		{
			Session["StartTime"] = viewStartTimeTextBox.Text;
			Session["StopTime"] = viewStopTimeTextBox.Text;
			GenerateReport();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\InstanceNameAndAppPoolIDMapper.cs ===
using System;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Management;
using System.Text.RegularExpressions;
using System.Threading;

namespace InstanceMapper
{
	/// <summary>
	/// Provides a type-safe way to associate an AppPoolID with its corresponding InstanceName
	/// </summary>
	public struct InstanceNameAndAppPoolIDMap
	{
		public string AppPoolID;
		public string InstanceName;
	}

	/// <summary>
	/// When an specialized exception (i.e. COMException) is logged by an inner function with extra context dependent
	/// details but can't be handled, it is re-thrown wrapped in this LoggedException class so that the main try/catch
	/// block doesn't re-log the exception.
	/// </summary>
	public class LoggedException : System.Exception
	{
		public LoggedException(System.Exception e)
		{
			this.e = e;
		}
		public System.Exception e;
	}

	/// <summary>
	/// Given a list of machine names, maps out the relationship between AppPoolIDs and PerfMon instance names
	/// </summary>
	class InstanceNameAndAppPoolIDMapper
	{
		private const string wmiConnect  = "\\\\{0}\\root\\cimv2";
		ManualResetEvent[] ThreadCompletionEvents;

		private struct TheadData
		{
			public HybridDictionary MachinesDict;
			public string MachineName;
			public ManualResetEvent OnCompletionEvent;

			public TheadData(string MachineName, ref HybridDictionary MachinesDict, ref ManualResetEvent OnCompletionEvent)
			{
				this.MachinesDict = MachinesDict;
				this.MachineName = MachineName;
				this.OnCompletionEvent = OnCompletionEvent;
			}
		}

		/// <summary>
		/// IIS includes the AppPoolID as part of the command line when it launches w3wp.exe.  Given the command line,
		/// this method extracts and returns the AppPoolID
		/// </summary>
		private static string ExtractAppPoolID(string commandLine)
		{
			Regex r = new Regex("-ap \"(?<name>\\w*)-[a-zA-Z]+\\w*\"", RegexOptions.IgnoreCase | RegexOptions.Compiled);
			Match m = r.Match(commandLine);
			System.Diagnostics.Debug.Assert(m.Success);

			string ret="";
			try
			{
				ret = m.Result("${name}");
			}
			catch(System.NotSupportedException )
			{
				//////XBLPerfLog.XBLPerfLogEvent.LogError("ExtractAppPoolID:commandLine="+commandLine);
				//throw e;
			}
			return ret;
		}

		/// <summary>
		/// Stores an IIS AppPoolID for a w3wp.exe process, indexed by that process's PID
		/// </summary>
		private static void GetAppPoolIDsByPID(HybridDictionary processMap, string machineName)
		{
			// The connection credentials - not needed if the logged in account has access
			ConnectionOptions oConnectionOptions = new ConnectionOptions();
			oConnectionOptions.Impersonation = ImpersonationLevel.Impersonate;
			//oConnectionOptions.Username = "JohnDoe"; 
			//oConnectionOptions.Password = "JohnsPass"; 

			// The scope
			string wmiScope = string.Format(wmiConnect, machineName);;
			ManagementScope oScope = new ManagementScope(wmiScope, oConnectionOptions);

			// The query
			string[] SelectProperties = { "Name", "ProcessID", "CommandLine" };
			SelectQuery oQuery = new SelectQuery("Win32_Process", "Name=\"w3wp.exe\"", SelectProperties);

			// Run the query within the scope
			ManagementObjectSearcher oSearcher = new ManagementObjectSearcher(oScope, oQuery);

			try
			{
				foreach(ManagementObject oReturn in oSearcher.Get())
				{
					InstanceNameAndAppPoolIDMap Mapping = new InstanceNameAndAppPoolIDMap();
					Mapping.AppPoolID = ExtractAppPoolID(oReturn["CommandLine"].ToString());
					int PID = int.Parse(oReturn["ProcessId"].ToString());
					processMap.Add(PID, Mapping);
				}
			}
			catch (System.Runtime.InteropServices.COMException COMException)
			{
				string ErrorMsg = string.Format("Exception thrown accessing {0}\nCOM Error:\n{1}", machineName, COMException.ToString());
				XBLPerfLog.XBLPerfLogEvent.LogError(ErrorMsg);
				throw(new LoggedException(COMException));
			}
			catch (System.Management.ManagementException WMIException)
			{
				string ErrorMsg = string.Format("Exception thrown accessing {0}\nWMI Error:\n{1}", machineName, WMIException.ToString());
				XBLPerfLog.XBLPerfLogEvent.LogError(ErrorMsg);
				throw(new LoggedException(WMIException));
			}
		}

		/// <summary>
		/// Stores a PerfMon instance name for a w3wp.exe process, indexed by that process's PID
		/// </summary>
		private static void GetInstanceNamesByPID(HybridDictionary processMap, string machineName)
		{
			PerformanceCounterCategory PerfCat = new PerformanceCounterCategory("Process", machineName);

			//NOTE: This is an extremely expensive call
			string[] InstanceNames = PerfCat.GetInstanceNames();

			foreach (string InstanceName in InstanceNames)
			{
				if (InstanceName.StartsWith("w3wp"))
				{
					PerformanceCounter PC = new PerformanceCounter("Process", "ID Process", InstanceName, machineName);
					int PID = int.Parse(PC.NextValue().ToString());
					if (processMap.Contains(PID))
					{
						InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
						Mapping.InstanceName = InstanceName;
						processMap[PID] = Mapping;
					}
				}
			}
		}

		/// <summary>
		/// Worker thread that owns collecting the data for a single machine and signaling the main thread when it's done
		/// </summary>
		static void GetInstanceNameAndAppPoolIDMapsWorker(object TargetDetails)
		{
			TheadData td = (TheadData)TargetDetails;

			try
			{
				HybridDictionary ProcessDict = new HybridDictionary();
				GetAppPoolIDsByPID(ProcessDict, td.MachineName);
				GetInstanceNamesByPID(ProcessDict, td.MachineName);
				lock(td.MachinesDict)
				{
					td.MachinesDict.Add(td.MachineName, ProcessDict);
				}
			}
			catch(LoggedException)
			{
				return;
			}
			catch(Exception e)
			{
				XBLPerfLog.XBLPerfLogEvent.LogError(string.Format("Machine Name: {0}\nUnhandled Error:\n{1}\n", td.MachineName, e.ToString()));
				//throw;
			}
			finally
			{
				td.OnCompletionEvent.Set();
			}
		}

		/// <summary>
		/// Launches 1 thread per machine and waits for them to gather the data before returning the complete results
		/// </summary>
		public HybridDictionary GetInstanceNameAndAppPoolIDMaps(string[] machineNames)
		{
			int EventsIndex = 0;
			ThreadCompletionEvents = new ManualResetEvent[machineNames.GetLength(0)];
			HybridDictionary MachinesDict = new HybridDictionary();

			DateTime StartDT = DateTime.Now;
			foreach (string MachineName in machineNames)
			{
				ThreadCompletionEvents[EventsIndex] = new ManualResetEvent(false);
				ThreadPool.QueueUserWorkItem(new WaitCallback(GetInstanceNameAndAppPoolIDMapsWorker), new TheadData(MachineName, ref MachinesDict, ref ThreadCompletionEvents[EventsIndex++]));
				Thread.Sleep(0);
			}
			WaitHandle.WaitAll(ThreadCompletionEvents);
			Console.WriteLine("WMI/PerfMon information gathering elapsed time = " + DateTime.Now.Subtract(StartDT).ToString());

			return(MachinesDict);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Report\Formulaeval.cs ===
using System;
using System.Data.SqlClient;

namespace Report
{
	/// <summary>
	/// Summary description for Formulaeval.
	/// </summary>
	public class FormulaEval
	{
		string guid;
		string stime;
		string etime;
		protected System.Data.SqlClient.SqlConnection cn = new SqlConnection();

		public FormulaEval()
		{
			//
			// TODO: Add constructor logic here
			//
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security i" +
				"nfo=False;initial catalog=PerfDB";
		}
		public FormulaEval(string GUID , string STime, string ETime)
		{
			guid=GUID;
			stime=STime;
			etime=ETime;
			this.cn.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security i" +
				"nfo=False;initial catalog=PerfDB";
		}

		public void verify(string formula)
		{
			int defaultval= -1;
			verifyRecurcive(formula.ToLower(),0,ref defaultval,-1);
			
		}

		public double Calculate(string formula)
		{
			int defaultval= -1;
			return CalRecurcive(formula.ToLower(),0,ref defaultval,-1);
			
		}

		protected double ExecuteQuery(string query )
		{
			double val=0;
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText=query;
			SqlComm.Connection= cn;

			cn.Open();
			try
			{
				val = (double)SqlComm.ExecuteScalar();
				
			}
			catch(System.Exception)
			{
				//set error here 
			}
			finally
			{
				cn.Close();
			}
			return val;
		}
		protected double Average(int counterid )
		{
			string query = "SELECT avg([CounterValue]) FROM [PerfDB].[dbo].[CounterData] where ";
			query +=" CounterID ="+counterid+ " and GUID='"+guid+"'";
			query += " and CounterDateTime >'"+stime+"' and CounterDateTime <'"+etime+"'";
			return ExecuteQuery(query);
		}
		protected double Sum(int counterid )
		{
			string query = "SELECT sum ([CounterValue]) FROM [PerfDB].[dbo].[CounterData] where ";
			query +=" CounterID ="+counterid+ " and GUID='"+guid+"'";
			query += " and CounterDateTime >'"+stime+"' and CounterDateTime <'"+etime+"'";
			return ExecuteQuery(query);
		}

		protected bool verifyCounter(int id)
		{
			int val;
			SqlCommand SqlComm= new SqlCommand();
			SqlComm.CommandText="SELECT count(*) FROM [PerfDB].[dbo].[CounterDetails] where Deleted =0 and";
			SqlComm.CommandText +=" CounterID="+ id;
			SqlComm.Connection= cn;

			cn.Open();
			try
			{
				val = (int)SqlComm.ExecuteScalar();
				if(val>0)
					return true;
				
			}
			catch(System.Exception)
			{
				//set error here 
			}
			finally
			{
				cn.Close();
			}
			return false;
		}
		protected double CalRecurcive(string formula, int idx,ref int cbracket,int sbracket)
		{
			int closed= -1;
			double cval=0;
			bool decimalflg= false;
			int place =1;

			for ( int i=idx; i<formula.Length;)
			{
				switch(formula[i])
				{
					case '(' :
					{	
						cval = CalRecurcive(formula,i+1,ref closed,i);
						if(closed >0)
							i=closed+1;
						else
							throw new System.Exception("Invalid Expression");
						break;
					}
					case ')' :
					{
						if(sbracket <0 )
							throw new System.Exception("Invalid Expression");
						cbracket=i; 
						return cval;
							
					}
					case '+':
						return cval+CalRecurcive(formula,i+1,ref cbracket,sbracket);
					case '-':
						return cval-CalRecurcive(formula,i+1,ref cbracket,sbracket);
					case '*':
						return cval*CalRecurcive(formula,i+1,ref cbracket,sbracket);
					case '/':
						return cval/CalRecurcive(formula,i+1,ref cbracket,sbracket);
					case 'a':
					{
						if(i+2 < formula.Length && formula[i+1]=='v' && formula[i+2]=='g') 	
						{
							int bstart = 1+formula.IndexOf("(",i+2);
							int bend = formula.IndexOf(")",i+2);
							string tmp = formula.Substring(bstart,(bend-bstart));
							int counterid= Int32.Parse(tmp);
							cval = Average(counterid);
							i=bend+1;
						}
						else
							throw new System.Exception("Invalid Expression");
						break;
					}
					case 's':
					{
						if(i+2 < formula.Length && formula[i+1]=='u' && formula[i+2]=='m') 	
						{
							int bstart = 1+formula.IndexOf("(",i+2);
							int bend = formula.IndexOf(")",i+2);
							string tmp = formula.Substring(bstart,(bend-bstart));
							int counterid= Int32.Parse(tmp);
							cval = Sum(counterid);
							i=bend+1;
						}
						else
							throw new System.Exception("Invalid Expression");
						break;
					}
									
					default:
					{
						int num= (int)formula[i];
						if(formula[i]>='0' && formula[i] <=(int)'9')
						{
							if(!decimalflg)
								cval= cval*10+(formula[i]-'0');
							else
							{
								place*=10;
								double ctmp= (formula[i]-'0');
								cval= cval+(ctmp/place);
							}
						}
						else if(formula[i] =='.')
						{
							if(!decimalflg)
								decimalflg=true;
							else
								throw new System.Exception("Invalid Expression");
						}
						else if(formula[i] !=' ')
							throw new System.Exception("Invalid Expression");
							
						i+=1;
						break;
					}
				}

			}
			return cval;
		}


		protected double verifyRecurcive(string formula, int idx,ref int cbracket,int sbracket)
		{
			int closed= -1;
			double cval=0;
			bool decimalflg= false;
			int place =1;

			for ( int i=idx; i<formula.Length;)
			{
				switch(formula[i])
				{
					case '(' :
					{	
						cval = verifyRecurcive(formula,i+1,ref closed,i);
						if(closed >0)
							i=closed+1;
						else
							throw new System.Exception("Invalid Expression");
						break;
					}
					case ')' :
					{
						if(sbracket <0 )
							throw new System.Exception("Invalid Expression");
						cbracket=i; 
						return cval;
					}
					case '+':
						return cval+verifyRecurcive(formula,i+1,ref cbracket,sbracket);
					case '-':
						return cval-verifyRecurcive(formula,i+1,ref cbracket,sbracket);
					case '*':
						return cval*verifyRecurcive(formula,i+1,ref cbracket,sbracket);
					case '/':
						return cval/verifyRecurcive(formula,i+1,ref cbracket,sbracket);
					case 'a':
					{
						if(i+2 < formula.Length && formula[i+1]=='v' && formula[i+2]=='g') 	
						{
							int bstart = 1+formula.IndexOf("(",i+2);
							int bend = formula.IndexOf(")",i+2);
							string tmp = formula.Substring(bstart,(bend-bstart));
							int counterid= Int32.Parse(tmp);
							cval = 1;
							if(!verifyCounter(counterid))
								throw new System.Exception("Invalid Counter ID");
							i=bend+1;
						}
						else
							throw new System.Exception("Invalid Expression");
						break;
					}
					case 's':
					{
						if(i+2 < formula.Length && formula[i+1]=='u' && formula[i+2]=='m') 	
						{
							int bstart = 1+formula.IndexOf("(",i+2);
							int bend = formula.IndexOf(")",i+2);
							string tmp = formula.Substring(bstart,(bend-bstart));
							int counterid= Int32.Parse(tmp);
							cval = 1;
							if(!verifyCounter(counterid))
								throw new System.Exception("Invalid Counter ID");
							i=bend+1;
						}
						else
							throw new System.Exception("Invalid Expression");
						break;
					}
									
					default:
					{
						int num= (int)formula[i];
						if(formula[i]>='0' && formula[i] <=(int)'9')
						{
							if(!decimalflg)
								cval= cval*10+(formula[i]-'0');
							else
							{
								place*=10;
								double ctmp= (formula[i]-'0');
								cval= cval+(ctmp/place);
							}
						}
						else if(formula[i] =='.')
						{
							decimalflg=true;
						}
						else if(formula[i] !=' ')
							throw new System.Exception("Invalid Expression");
							
						i+=1;
						break;
					}
				}

			}
			return cval;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\Service1.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using XBLPerfLog;
using System.Threading;
using System.Data.SqlClient;
using System.Globalization;
using Microsoft.Win32;

namespace XBLPerfLog
{
	public class XBLPerfLogService : System.ServiceProcess.ServiceBase
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public XBLPerfLogService()
		{
			InitializeComponent();
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;

			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new XBLPerfLogService() };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// XBLPerfLogService
			// 
			this.ServiceName = "XBLPerfLogService";

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			// TODO: Add code here to start your service.
			bool			exit = false;
			SqlConnection   mySqlConn = null;
			SqlCommand      myCommand = null;
			SqlDataReader   sqlReader = null;
			SqlParameter    ret = null;

			// read sql server and updateInterval from registry
			try
			{
				RegistryKey		rk = Registry.Users.OpenSubKey(@".DEFAULT\Environment\XBLPerfLog");
				XBLPerfLogMain.sqlIP = (string)rk.GetValue("SQLIP");
				XBLPerfLogMain.updateInterval = (int)rk.GetValue("UpdateInterval");
			}
			catch (Exception e)
			{
				XBLPerfLogEvent.LogError("Cannot get registry key settings(SQLIP and UpdateInterval) " +
										"from local machine:HKEY_USERS\\DEFAULT\\Enviroment\\XBLPerfLog\\..."+e,3,1);
				return;
			}

			try
			{
				string myConnStr = "Data Source=" + XBLPerfLogMain.sqlIP + @";Database=PerfDB" + 
					@";Trusted_Connection=true";

				// open a connection to the perfCounterDB in SQL server
				mySqlConn = new SqlConnection(myConnStr);
				mySqlConn.Open();

				// add an entry in DisplayToID table
				myCommand = new SqlCommand();
				myCommand.Connection = mySqlConn;
				myCommand.CommandType = CommandType.StoredProcedure;
				myCommand.CommandText = "p_StartNewLog";

				ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				myCommand.Parameters.Add("@GUID",SqlDbType.UniqueIdentifier).Value  = XBLPerfLogMain.guid;
				myCommand.Parameters.Add("@DisplayString",SqlDbType.VarChar).Value  = DateTime.Now.ToString("u",DateTimeFormatInfo.InvariantInfo);
        
				myCommand.ExecuteNonQuery();
            
				if((int)ret.Value != 0)
					throw new Exception("Calling p_StartNewLog failed");

				// get real counters and create machine hashtable
				myCommand.CommandText = "p_GetRealCounters";
				myCommand.Parameters.Clear();
				myCommand.Parameters.Add(ret);
				sqlReader = myCommand.ExecuteReader();

				// build the machineHT
				while(sqlReader.Read())
				{
					XBLPerfLogMain.AddCounterToTable(sqlReader);
				}
				sqlReader.Close();
				sqlReader = null;
				if((int)ret.Value != 0)
					throw new Exception("Calling p_GetRealCounters failed");                

				// get aggregated counters
				myCommand.CommandText = "p_GetAggregateCounters";
				myCommand.Parameters.Clear();
				myCommand.Parameters.Add(ret);
				sqlReader = myCommand.ExecuteReader();  

				// build the aggregated counter HT
				while(sqlReader.Read())
				{
					XBLPerfLogMain.AddAggCounterToTable(sqlReader);
				}
				sqlReader.Close();
				sqlReader = null;
				if((int)ret.Value != 0)
					throw new Exception("Calling p_GetAggregateCounters failed");                
			}
			catch(Exception e)
			{
				XBLPerfLogEvent.LogError("Exception: " + e.Message + e.StackTrace,4,1);
				exit = true;
			}
			finally
			{
				if(mySqlConn != null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
			}
			if(exit)
				return;

			// start WriteDataThread thread that writes collected data to the CounterData table
			XBLPerfLogMain.writeDataThread = new Thread(new ThreadStart(XBLPerfLogMain.WriteDataThread));
			XBLPerfLogMain.writeDataThread.Start();

			// start data collection threads on all boxes.
			XBLPerfLogMain.StartDataCollection();

			// create another thread to check any new counters being added and any instance changes
			Thread checkUpdateThread = new Thread(new ThreadStart(XBLPerfLogMain.CheckChangesThread));
			checkUpdateThread.Start();

			// start InstanceMapperThread thread that keeps the InstanceDisplayName table up to date
			XBLPerfLogMain.instanceMapperThread = new Thread(new ThreadStart(XBLPerfLog.InstanceMapper.InstanceMapperThread));
			XBLPerfLogMain.instanceMapperThread.Start();
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			// TODO: Add code here to perform any tear-down necessary to stop your service.
			XBLPerfLogEvent.log.Close();
			XBLPerfLogMain.shutdown.Set();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\InstanceMapperThread.cs ===
using System;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Threading;
using InstanceMapper;

namespace XBLPerfLog
{
	/// <summary>
	/// The InstanceMapper class is the bridge between the larger XBLPerfLog appplication and the core InstanceMapper
	/// functionality, allowing InstanceMapper to integrate cleanly with XBLPerfLog
	/// </summary>
	public class InstanceMapper
	{
		private const int SecsPerCycle	= 300;

		/// <summary>
		/// Helper function for demo'ing and debugging
		/// </summary>
		private static void WriteMappingsToConsole(string MachineName, HybridDictionary processMap)
		{
			Console.WriteLine("Machine Name: {0}", MachineName);
			Console.WriteLine("Mappings Count = " + processMap.Count);
			foreach (int PID in processMap.Keys)
			{
				InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
				Console.WriteLine("PID: {0}\tAppPoolID: {1}\tInstanceName: {2}", PID, Mapping.AppPoolID, Mapping.InstanceName);
			}
			Console.WriteLine("");
		}

		/// <summary>
		/// Assigns the contents of a StringCollection to a new String Array
		/// </summary>
		private static string[] StringCollectionToStringArray(System.Collections.Specialized.StringCollection SourceCollection)
		{
			string[] TargetArray = new string[SourceCollection.Count];
			int i = 0;
			foreach (string s in SourceCollection)
			{
				TargetArray[i++] = s;
			}
            return(TargetArray);
		}

		/// <summary>
		/// open connection to perfDB
		/// </summary>
		/// <param name="sqlConn"></param>
		/// <returns></returns>
		private static bool openPerfDBConn(out SqlConnection XOnlineTestConn)
		{
			XOnlineTestConn = new SqlConnection("Data Source=" + XBLPerfLogMain.sqlIP + "; Integrated Security=SSPI; Initial Catalog=PerfDB");
			bool	openConnFail = true;
			int		i = 0;

			while(openConnFail == true)
			{
				try
				{
					XOnlineTestConn.Open();
				}
				catch (Exception e)
				{
					openConnFail = true;
					XBLPerfLogEvent.LogError(e.GetType().ToString()+": " + e.Message + e.StackTrace);
					Thread.Sleep(60000);	// wait for 1 minute before try again
					i++;
					XBLPerfLogEvent.LogInfo("Retry to open connection to perfDB for: "+i+" times");
					if(i == 60)	// retry for 1 hour already
					{
						return false;
					}
					else
						continue;
				}
				openConnFail = false;
			}
			return true;
		}
		/// <summary>
		/// Calls p_GetWebServerMachineNames in the DB to retrieve the list of machine names registered as WebServers.
		/// </summary>
		private static string[] GetWebServerMachineNames(ref SqlConnection XOnlineTestConn)
		{
			SqlCommand WebServerMachineNamesCmd = new SqlCommand("p_GetWebServerMachineNames", XOnlineTestConn);
			WebServerMachineNamesCmd.CommandType = System.Data.CommandType.StoredProcedure;

			SqlDataReader MachineNamesReader = WebServerMachineNamesCmd.ExecuteReader();
			Console.WriteLine("{0}", MachineNamesReader.GetName(0));

			System.Collections.Specialized.StringCollection MachineNames = new System.Collections.Specialized.StringCollection();
			while (MachineNamesReader.Read())
			{
				Console.WriteLine("{0}", MachineNamesReader.GetString(0));
				MachineNames.Add(MachineNamesReader.GetString(0));
			}

			MachineNamesReader.Close();

			return(StringCollectionToStringArray(MachineNames));
		}

		/// <summary>
		/// Calls p_SetInstanceDisplayName in the DB to insert/update corresponding Display Name and Instance Name data
		/// for a specific machine
		/// </summary>
		private static void SetInstanceDisplayName(string MachineName, string AppPoolID, string InstanceName, ref SqlConnection XOnlineTestConn)
		{
			SqlCommand WebServerMachineNamesCmd = new SqlCommand("p_SetInstanceDisplayName", XOnlineTestConn);
			WebServerMachineNamesCmd.CommandType = System.Data.CommandType.StoredProcedure;

			WebServerMachineNamesCmd.Parameters.Add("@MachineName", System.Data.SqlDbType.VarChar, 1024).Value = MachineName;
			WebServerMachineNamesCmd.Parameters.Add("@DisplayName", System.Data.SqlDbType.VarChar, 1024).Value = AppPoolID+@"_w3wp";
			WebServerMachineNamesCmd.Parameters.Add("@InstanceName", System.Data.SqlDbType.VarChar, 1024).Value = InstanceName;

			SqlDataReader MachineNamesReader = WebServerMachineNamesCmd.ExecuteReader();
//			if ((MachineNamesReader.RecordsAffected != 1) &&
//				(MachineNamesReader.RecordsAffected != -1))
//			{
//				XBLPerfLogEvent.LogWarning("SetInstanceDisplayName: The # of records affected should always be 1 or -1;"
//											+ "actual number is " + MachineNamesReader.RecordsAffected
//											+ ";Details are: " + MachineName + " " + AppPoolID + " " + InstanceName);
//			}

			MachineNamesReade