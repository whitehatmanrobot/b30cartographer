  .IgnoresArgumentsAt(2, 3)
                .WhenAssertingThat(l => l.LogEvent("TfsPublishSTFResultsTaskModule", LoggingLevel.Warning, null))
                .WasCalledAtLeastOneTime();
        }

        [TestMethod]
        [ExpectedException(typeof(ApplicationException))]
        public void AddParameters_throws_when_passed_a_parameter_block_that_is_not_a_parameter_block()
        {
            //Arrange
            var logStub = StubFactory.Create<ILogger>();
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.Logger = logStub.Target;

            //Act
            theModule.AddParameters(
                "<somethingelse>" +
                "  <something></something>" +
                "</somethingelse>");

            //Assert
        }

        [TestMethod]
        public void AddParameters_logs_an_error_passed_a_parameter_block_that_is_not_a_parameter_block()
        {
            //Arrange
            var logStub = StubFactory.Create<ILogger>();
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.Logger = logStub.Target;

            //Act
            try
            {
                theModule.AddParameters(
                    "<somethingelse>" +
                    "  <something></something>" +
                    "</somethingelse>");
            }
            catch (ApplicationException)
            { 
            }

            //Assert
            logStub
                .IgnoresArgumentsAt(2, 3)
                .WhenAssertingThat(l => l.LogEvent("TfsPublishSTFResultsTaskModule", LoggingLevel.Error, null))
                .WasCalledAtLeastOneTime();
        }

        [TestMethod]
        public void RemoveAllParameters_removes_build_name()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.BuildName = "foo";

            //act
            theModule.RemoveAllParameters();

            //assert
            Assert.IsTrue(string.IsNullOrEmpty(theModule.BuildName));
        }

        [TestMethod]
        public void RemoveAllParameters_removes_build_number()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.BuildNumber = "foo";

            //act
            theModule.RemoveAllParameters();

            //assert
            Assert.IsTrue(string.IsNullOrEmpty(theModule.BuildNumber));
        }

        [TestMethod]
        public void RemoveAllParameters_removes_stf_log_path()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.STFLogFolder = "foo";

            //act
            theModule.RemoveAllParameters();

            //assert
            Assert.IsTrue(string.IsNullOrEmpty(theModule.STFLogFolder));
        }

        [TestMethod]
        public void STFLogFinder_returns_all_xml_files_in_given_directory()
        {
            //Arrange
            var stubLogger = StubFactory.Create<ILogger>();
            var logFinder = new STFLogFinder(stubLogger.Target);
            var tempPath = Path.GetTempPath();
            var randomFilename = Path.GetTempFileName() + ".xml";
            using (FileStream fs = File.Create(randomFilename, 1, FileOptions.DeleteOnClose))
            {
                
                //Act
                var logfiles = logFinder.FindLogFiles(tempPath);
            

                //Assert
                var allXMLFiles = Directory.GetFiles(tempPath, "*.xml");
                Assert.AreEqual(allXMLFiles.Length, logfiles.Length);
                foreach (var file in allXMLFiles)
                {
                    Assert.IsTrue(logfiles.Contains(file));
                }
            }
        }

        [TestMethod]
        public void STFLogFinder_returns_empty_list_when_path_does_not_exist()
        {
            //Arrange
            var stubLogger = StubFactory.Create<ILogger>();
            var logFinder = new STFLogFinder(stubLogger.Target);

            //Act
            var result = logFinder.FindLogFiles(@"directory\that\does\not\exist\");

            //Assert
            Assert.AreEqual(0, result.Length);
        }

        [TestMethod]
        public void STFLogFinder_logs_errors_that_occurr_when_finding_filse()
        {
            //Arrange
            var stubLogger = StubFactory.Create<ILogger>();
            var logFinder = new STFLogFinder(stubLogger.Target);

            //Act
            var result = logFinder.FindLogFiles(@"c:\directory\that\does\not\exist\");

            //Assert
            stubLogger
                .IgnoresArgumentsAt(3)
                .WhenAssertingThat(l => l.LogEvent(
                    "TfsPublishSTFResultsTaskModule.STFLogFinder", 
                    LoggingLevel.Error,
                    "Could not find a part of the path 'c:\\directory\\that\\does\\not\\exist'."))
                .WasCalledAtLeastOneTime();
        }

        [TestMethod]
        public void Perform_looks_for_logs_in_the_STFLogFolder()
        {
            //Arrange
            var expectedLogPath = @"\the\path\to\stflogs";
            var stubLogFinder = StubFactory.Create<ISTFLogFinder>();
            stubLogFinder
                .Returns(new string[0])
                .On(lf => lf.FindLogFiles(expectedLogPath));
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.TheLogFinder = stubLogFinder.Target;
            theModule.STFLogFolder = expectedLogPath;
            theModule.BuildName = "xonline_r2";
            theModule.BuildNumber = "00.00.0000.00";

            //Act
            theModule.Perform();

            //Assert
            stubLogFinder.AssertsThat(lf => lf.FindLogFiles(expectedLogPath))
                .WasCalledAtLeastOneTime();
        }

        [TestMethod]
        public void Perform_launches_one_process_for_each_stf_log_file_found()
        {
            //Arrange
            var stubLogFinder = StubFactory.Create<ISTFLogFinder>();
            stubLogFinder
                .IgnoresAllArguments()
                .AndReturns(new string[]{"log1.xml","log2.xml"})
                .On(lf => lf.FindLogFiles(null));
            var stubProcessLauncher = StubFactory.Create<IProcessLauncher>();
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.TheLogFinder = stubLogFinder.Target;
            theModule.TheProcessLauncher = stubProcessLauncher.Target;
            theModule.STFLogFolder = "\\theLogFolder";
            theModule.BuildName = "xonline_r2";
            theModule.BuildNumber = "00.00.0000.00";

            //Act
            theModule.Perform();

            //Assert
            stubProcessLauncher
                .IgnoresAllArguments()
                .WhenAssertingThat(pl => pl.RunProccess(null, null))
                .WasCalledAtLeastTwoTimes();                    
        }

        [TestMethod]
        public void Perform_launches_correct_command()
        {
            //Arrange
            var stubLogFinder = StubFactory.Create<ISTFLogFinder>();
            stubLogFinder
                .IgnoresAllArguments()
                .AndReturns(new string[] { "expectedLog.xml" })
                .On(lf => lf.FindLogFiles(null));
            var stubProcessLauncher = StubFactory.Create<IProcessLauncher>();
            var theModule = new TfsPublishSTFResultsTaskModule();

            theModule.TheLogFinder = stubLogFinder.Target;
            theModule.TheProcessLauncher = stubProcessLauncher.Target;
            theModule.BuildName = @"xonline_r2";
            theModule.BuildNumber = @"09.02.0126.00";
            theModule.STFLogFolder = @"\the\path\to\stflogs";
            theModule.Frequency = "BVT";
            theModule.Environment = "AutoNet";

            //Act
            theModule.Perform();

            //Assert
            stubProcessLauncher
                .Calls((args) =>
                    {
                        Assert.AreEqual("TfsPublishResults.exe", args[0]);
                        Assert.AreEqual(
                                @"/buildDefinition:xonline_r2 /buildNumber:09.02.0126.00 /flavor:retail " +
                                @"/platform:x86 /nunit:expectedLog.xml /frequency:BVT /logPath:\the\path\to\stflogs " + 
                                @"/env:AutoNet",
                            args[1]);
                        return true;
                    })
                .ToAssertThat(pl => pl.RunProccess("TfsPublishResults.exe",
                    null))
                    .WasCalledOneTime();
        }

        [TestMethod]
        public void Perform_returns_success_when_log_publish_succeeds()
        {
            //Arrange
            var stubLogFinder = StubFactory.Create<ISTFLogFinder>();
            stubLogFinder
                .IgnoresAllArguments()
                .AndReturns(new string[] { "stfLog.xml" })
                .On(lf => lf.FindLogFiles(null));
            var stubProcessLauncher = StubFactory.Create<IProcessLauncher>();
            stubProcessLauncher
                .IgnoresAllArguments()
                .AndReturns(0)
                .On(pl => pl.RunProccess(null, null));

            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.TheLogFinder = stubLogFinder.Target;
            theModule.TheProcessLauncher = stubProcessLauncher.Target;
            theModule.STFLogFolder = "\\theLogFolder";
            theModule.BuildName = "xonline_r2";
            theModule.BuildNumber = "00.00.0000.00";

            //Act
            var result = theModule.Perform();

            //Assert
            Assert.AreEqual(true, result.ExecutedSuccessfully);
        }

        [TestMethod]
        public void Perform_returns_failure_when_log_publish_fails()
        {
            //Arrange
            var stubLogFinder = StubFactory.Create<ISTFLogFinder>();
            stubLogFinder
                .IgnoresAllArguments()
                .AndReturns(new string[] {"stfLog.xml"})
                .On(lf => lf.FindLogFiles(null));
            var stubProcessLauncher = StubFactory.Create<IProcessLauncher>();
            stubProcessLauncher
                .IgnoresAllArguments()
                .AndReturns(1)
                .On(pl => pl.RunProccess(null, null));

            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.TheLogFinder = stubLogFinder.Target;
            theModule.TheProcessLauncher = stubProcessLauncher.Target;
            theModule.STFLogFolder = "\\theLogFolder";
            theModule.BuildName = "xonline_r2";
            theModule.BuildNumber = "00.00.0000.00";

            //Act
            var result = theModule.Perform();

            //Assert
            Assert.AreEqual(false, result.ExecutedSuccessfully);
            stubProcessLauncher
                .IgnoresAllArguments()
                .WhenAssertingThat(pl => pl.RunProccess(null, null))
                .WasCalled();
        }

        [TestMethod]
        public void Perform_logs_an_error_for_each_failure_to_publish()
        {
            //Arrange
            var stubLogger = StubFactory.Create<ILogger>();
            var stubLogFinder = StubFactory.Create<ISTFLogFinder>();
            stubLogFinder
                .IgnoresAllArguments()
                .AndReturns(new string[] { "stfLog.xml" })
                .On(lf => lf.FindLogFiles(null));
            var stubProcessLauncher = StubFactory.Create<IProcessLauncher>();
            stubProcessLauncher
                .IgnoresAllArguments()
                .AndReturns(1)
                .On(pl => pl.RunProccess(null, null));

            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.Logger = stubLogger.Target;
            theModule.TheLogFinder = stubLogFinder.Target;
            theModule.TheProcessLauncher = stubProcessLauncher.Target;
            theModule.STFLogFolder = "\\theLogFolder";
            theModule.BuildName = "xonline_r2";
            theModule.BuildNumber = "00.00.0000.00";

            //Act
            var result = theModule.Perform();

            //Assert
            stubLogger
                .IgnoresArgumentsAt(3)
                .WhenAssertingThat(l => l.LogEvent(
                    "TfsPublishSTFResultsTaskModule",
                    LoggingLevel.Error,
                    "Failed to publish stfLog.xml"))
                .WasCalledAtLeastOneTime();
        }

        [TestMethod]
        public void Perform_returns_failure_if_BuildName_not_set()
        {
            //Arrange
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.BuildNumber = "00.00.0000.00";
            theModule.STFLogFolder = "\\logFolder";

            //Act
            var result = theModule.Perform();

            //Assert
            Assert.AreEqual(false,result.ExecutedSuccessfully);
        }

        [TestMethod]
        public void Perform_returns_failure_if_BuildNumber_not_set()
        {
            //Arrange
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.BuildName = "xonline_r2";
            theModule.STFLogFolder = "\\logFolder";

            //Act
            var result = theModule.Perform();

            //Assert
            Assert.AreEqual(false, result.ExecutedSuccessfully);
        }

        [TestMethod]
        public void Perform_returns_failure_if_STFLogFolder_not_set()
        {
            //Arrange
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.BuildNumber = "00.00.0000.00";
            theModule.BuildName = "xonline_r2";

            //Act
            var result = theModule.Perform();

            //Assert
            Assert.AreEqual(false, result.ExecutedSuccessfully);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\STFTaskModule\STFTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.stftaskmodule
{
    [DeploymentTaskModule("STFTaskModule")]
	public class STFTaskModule : ITaskModule
	{
        private const string STFLocationParameter = "stflocation";
        private const string SuiteParameter = "suite";
        private const string EnvironmentParameter = "environment";
        private const string FileLogParameter = "filelog";
        private const string AllowTagParameter = "allowtag";
        private const string IgnoreTagParameter = "ignoretag";
        private const string TryCountParameter = "trycount";
        private const string XMLOutputParameter = "xmloutput";
        private const string EnvReqParameter = "envreq";
        private const string FrequencyParameter = "frequency";
        private const string TimeoutParameter = "timeout";
        private const string CodeCoverageParameter = "codecoverage";

        private Dictionary<string, string> _parameters;
        private TaskModuleInfo _info;
        private StringBuilder _stfOutput;
        private TaskResult _result;

        public STFTaskModule()
        {
            _stfOutput = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "STF Test Runner";
            _info.Description = "Runs STF tests.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("STFLocation", "The fully-qualified path to the STF tests."),
                new ParameterDescriptor("Suite", "Full path and filename of the test suite to run."),
                new ParameterDescriptor("Environment", "The name of the environment in which the tests are running."),
                new ParameterDescriptor("XMLOutput", "The location to save the XML output from the test run."),
                new ParameterDescriptor("AllowTag", "[Optional] The name of the tag used to include cases in the run."),
                new ParameterDescriptor("IgnoreTag", "[Optional] The name of the tag used to exclude cases from the run."),
                new ParameterDescriptor("TryCount", "[Optional] The number of times to rerun a failed case."),
                new ParameterDescriptor("FileLog", "[Optional] Flag indicating whether to output result to a text file. Default is FALSE."),
                new ParameterDescriptor("EnvReq", "[Optional] Run only those tests that match the environmental resource requirements."),
                new ParameterDescriptor("Frequency", "[Optional] Run only the tests that are encapsulated by the given frequency. Use Daily, or Regression."),
                new ParameterDescriptor("Timeout", "[Optional] The number of seconds to wait for the test run to complete before giving up and killing it. The default is indefinite."),
                new ParameterDescriptor("CodeCoverage", "[Optional] Use 'noimport' to run without importing the results in realtime.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(STFLocationParameter, "");
            _parameters.Add(SuiteParameter, "");
            _parameters.Add(EnvironmentParameter, "");
            _parameters.Add(FileLogParameter, "");
            _parameters.Add(AllowTagParameter, "");
            _parameters.Add(IgnoreTagParameter, "");
            _parameters.Add(TryCountParameter, "");
            _parameters.Add(XMLOutputParameter, "");
            _parameters.Add(EnvReqParameter, "");
            _parameters.Add(FrequencyParameter, "");
            _parameters.Add(TimeoutParameter, "");
            _parameters.Add(CodeCoverageParameter, "");
        }

        #region ITaskModule Members

        public void AddParameters(string xmlParameterBlock) { }

        public void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (String.IsNullOrEmpty(_parameters[STFLocationParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'STFLocation' parameter is required, but not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[EnvironmentParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'Environment' parameter is required, but not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[SuiteParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'Suite' parameter is required, but not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[XMLOutputParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'XMLOutput' parameter is required, but not specified."));
            }

            if (_result.ExecutedSuccessfully)
            {
                //set up parameters for STFConsole
                StringBuilder args = new StringBuilder();
                Int16 timeoutSeconds = -1;

                args.AppendFormat("\"{0}\" /env:{1} /xmlfile:\"{2}\"", _parameters[SuiteParameter],
                    _parameters[EnvironmentParameter], _parameters[XMLOutputParameter]);

                if (!String.IsNullOrEmpty(_parameters[TryCountParameter]))
                    args.Append(" /trycount:" + _parameters[TryCountParameter]);
                if (!String.IsNullOrEmpty(_parameters[FileLogParameter]) && Convert.ToBoolean(_parameters[FileLogParameter]))
                    args.Append(" /filelog");
                if (!String.IsNullOrEmpty(_parameters[CodeCoverageParameter]))
                    args.Append(" /codecoverage:" + _parameters[CodeCoverageParameter]);

                //The -envreq, -freq, and -allowtag parameters were removed.  -exprun is used instead now, so convert those properties into an expression.
                string expressionToRun = "";

                if (!String.IsNullOrEmpty(_parameters[AllowTagParameter]))
                {
                    expressionToRun += "TrunkHasTag(Tag(" + _parameters[AllowTagParameter] + "))";
                }

                if (!String.IsNullOrEmpty(_parameters[FrequencyParameter]))
                {
                    if (!string.IsNullOrEmpty(expressionToRun))
                    {
                        expressionToRun += " && ";
                    }

                    expressionToRun += "Frequency(Val(" + _parameters[FrequencyParameter] + "))";
                }

                if (!String.IsNullOrEmpty(_parameters[EnvReqParameter]))
                {
                    if (!string.IsNullOrEmpty(expressionToRun))
                    {
                        expressionToRun += " && ";
                    }

                    expressionToRun += "EnvRequirement(Val(" + _parameters[EnvReqParameter] + "))";
                }

                if (!string.IsNullOrEmpty(expressionToRun))
                {
                    string tempFilename = System.IO.Path.GetTempFileName();
                    System.IO.File.WriteAllText(tempFilename, expressionToRun);

                    args.AppendFormat(" /exprun:\"{0}\"", tempFilename);
                }

                //The -ignoretag parameter was removed.  -expignore is used instead now, so convert that property into an expression.
                string expressionToIgnore = "";

                if (!String.IsNullOrEmpty(_parameters[IgnoreTagParameter]))
                {
                    expressionToIgnore += "TrunkHasTag(Tag(" + _parameters[IgnoreTagParameter] + "))";
                }

                if (!string.IsNullOrEmpty(expressionToIgnore))
                {
                    string tempFilename = System.IO.Path.GetTempFileName();
                    System.IO.File.WriteAllText(tempFilename, expressionToIgnore);

                    args.AppendFormat(" /expignore:\"{0}\"", tempFilename);
                }

                //run STFConsole
                if (!Int16.TryParse(_parameters[TimeoutParameter], out timeoutSeconds))
                    timeoutSeconds = -1;

                ProcessStartInfo psi = new ProcessStartInfo();
                psi.WorkingDirectory = _parameters[STFLocationParameter];
                psi.FileName = Path.Combine(psi.WorkingDirectory, "STFConsoleLive.exe");
                psi.Arguments = args.ToString();
                psi.RedirectStandardError = true;
                psi.RedirectStandardOutput = true;
                psi.UseShellExecute = false;

                try
                {
                    Process stfProcess = new Process();
                    stfProcess.StartInfo = psi;
                    stfProcess.OutputDataReceived += new DataReceivedEventHandler(OutputDataHandler);
                    stfProcess.ErrorDataReceived += new DataReceivedEventHandler(OutputDataHandler);
                    stfProcess.Start();
                    stfProcess.BeginOutputReadLine();
                    stfProcess.BeginErrorReadLine();
                    if (timeoutSeconds > 0)
                    {
                        if (!stfProcess.WaitForExit(timeoutSeconds * 1000))
                        {
                            stfProcess.Kill();
                            throw new Exception(String.Format("The {0} second timeout expired while waiting for the test run to complete.", timeoutSeconds));
                        }
                    }
                    else
                    {
                        stfProcess.WaitForExit();
                    }

                    _result.ExecutedSuccessfully = (stfProcess.ExitCode == 0);

                    // Attach all output text files associated with this run.
                    string outputDir = Path.Combine(_parameters[STFLocationParameter], "FuncOutput");
                    string[] outputFiles = Directory.GetFiles(outputDir, String.Format("{0}*.txt", Path.GetFileNameWithoutExtension(_parameters[XMLOutputParameter])));
                    foreach (string outputFile in outputFiles)
                    {
                        // The test output file needs to be copied over to the logs directory and added to the results log
                        try
                        {
                            File.Copy(outputFile, Path.Combine(Path.GetDirectoryName(_parameters[XMLOutputParameter]), Path.GetFileName(outputFile)), true);
                            Log textLog = new Log();
                            textLog.Path = Path.GetDirectoryName(_parameters[XMLOutputParameter]);
                            textLog.FileName = Path.GetFileName(outputFile);
                            _result.AddLog(textLog);
                        }
                        catch (Exception ex)
                        {
                            DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to copy the text output file to the Log directory:\r\n{0}", ex);
                        }
                    }

                    // Do some processing of the XML output file and add it to the log
                    ProcessOutputFile(_parameters[XMLOutputParameter]);
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("An exception occurred while trying to run STFConsoleLive:\r\n{0}", ex.Message));
                }
            }

            return _result;
        }

        public void RemoveAllParameters()
        {
            _parameters[STFLocationParameter] = "";
            _parameters[SuiteParameter] = "";
            _parameters[EnvironmentParameter] = "";;
            _parameters[FileLogParameter] = "";;
            _parameters[AllowTagParameter] = "";;
            _parameters[IgnoreTagParameter] = "";;
            _parameters[TryCountParameter] = "";;
            _parameters[XMLOutputParameter] = "";
            _parameters[EnvReqParameter] = "";
            _parameters[FrequencyParameter] = "";
            _parameters[TimeoutParameter] = "";
        }

        #endregion

        private void OutputDataHandler(object sender, DataReceivedEventArgs e)
        {
            _stfOutput.AppendLine(e.Data);
        }

        private void ProcessOutputFile(string xmlPath)
        {
            try
            {
                XPathDocument doc = new XPathDocument(xmlPath);
                XPathNavigator docNav = doc.CreateNavigator();

                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "test-results", true) == 0)
                {
                    // Create a summary and add it to the results log
                    int total = 0;
                    int failed = 0;
                    int notRun = 0;
                    int passPercent = 0;

                    total = Int32.Parse(docNav.GetAttribute("total", docNav.NamespaceURI));
                    failed = Int32.Parse(docNav.GetAttribute("failures", docNav.NamespaceURI));
                    notRun = Int32.Parse(docNav.GetAttribute("not-run", docNav.NamespaceURI));
                    if (notRun < total)
                        passPercent = (int)(((double)(total - failed - notRun) / (double)(total - notRun)) * 100.0);
                    if (failed != 0)
                        _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("Run Summary: Total: {0}  Passed: {1}  Failed: {2}  Ignored: {3}  Run/Pass: {4}%",
                        total, (total - failed - notRun), failed, notRun, passPercent));

                    // Add the results to the log
                    _result.AddLog(new Log(docNav.OuterXml));
                }
                else
                {
                    // doesn't seem to be a valid nunit-style results file - encode the result file before saving it
                    DACommon.LogEvent(LoggingLevel.Warning, "{0} doesn't seem to be a valid nunit-style results file - unable to find the 'test-results' element.", xmlPath);
                    _result.AddLog(new Log(System.Web.HttpUtility.HtmlEncode(docNav.OuterXml)));
                }

                // Add a log file entry to the log
                Log log = new Log();
                log.Path = Path.GetDirectoryName(xmlPath);
                log.FileName = Path.GetFileName(xmlPath);
                _result.AddLog(log);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Warning, "An exception occurred while processing the STF output XML file:\r\n{0}", ex);
                Log log = new Log();
                log.FileName = Path.GetFileName(xmlPath);
                log.Path = Path.GetDirectoryName(xmlPath);
                _result.AddLog(log);
            }
        }
    }

    [DeploymentTaskModule("TestPassTaskModule")]
    public class TestPassTaskModule : ITaskModule
    {
        #region TestPass Class - Defines the properties of a test pass
        protected class TestPass
        {
            public string Build { get; private set; }
            public string Version { get; private set; }
            public DateTime CutoffTime { get; private set; }
            public string Env { get; private set; }
            public string Frequency { get; private set; }
            public string TimingDataPath { get; private set; }
            public string ClientResultPath { get; private set; }
            public string LocalResultPath { get; private set; }
            public string STFLocation { get; private set; }
            public UInt16 SuiteTimeoutSeconds { get; private set; }
            public string EnvReqs { get; private set; }
            public List<string> Clients { get; private set; }
            public List<Suite> Suites { get; private set; }
            public bool DetailsOnly { get; private set; }
            public bool NoAsync { get; private set; }
            public bool NoPreRun { get; private set; }
            public bool NoPostRun { get; private set; }
            public bool DryRun { get; private set; }
            public int TryCount { get; private set; }
            public string CodeCoverage { get; private set; }
            public string AllowTags { get; private set; }

            public static TestPass Parse(XPathNavigator node)
            {
                TestPass tp = new TestPass();
                XPathNodeIterator itor = node.SelectChildren(XPathNodeType.Element);

                tp.SuiteTimeoutSeconds = 7200; // Default to 2 hours
                tp.Clients = new List<string>();
                tp.Suites = new List<Suite>();
                tp.CutoffTime = DateTime.MaxValue;
                tp.DetailsOnly = false;
                tp.NoPreRun = false;
                tp.NoPostRun = false;
                tp.NoAsync = false;
                tp.DryRun = false;
                tp.TryCount = 0;
                tp.CodeCoverage = "";
                tp.AllowTags = "";

                // Get the attributes from the TestPass element
                if (node.MoveToFirstAttribute())
                {
                    do
                    {
                        switch (node.Name.ToLower())
                        {
                            case "env":
                                tp.Env = node.Value;
                                break;
                            case "frequency":
                                tp.Frequency = node.Value;
                                break;
                            case "build":
                                tp.Build = node.Value;
                                break;
                            case "version":
                                tp.Version = node.Value;
                                break;
                            case "cutofftime":
                                {
                                    DateTime tmp;
                                    if (DateTime.TryParse(node.Value, out tmp))
                                        tp.CutoffTime = tmp;
                                }
                                break;
                            case "dumpsuitedetails":
                                {
                                    bool tmp;
                                    if (bool.TryParse(node.Value, out tmp))
                                        tp.DetailsOnly = tmp;
                                }
                                break;
                            default:
                                DACommon.LogEvent(LoggingLevel.Warning, "Unsupported attribute on the TestPass element: {0}", node.Name);
                                break;
                        }
                    } while (node.MoveToNextAttribute());
                }
                else
                    throw new ApplicationException("No attributes defined on the 'TestPass' node.");

                // walk the list of child elements
                while (itor.MoveNext())
                {
                    switch(itor.Current.Name.ToLower())
                    {
                        case "timingdatapath":
                            tp.TimingDataPath = itor.Current.Value;
                            break;
                        case "clientresultpath":
                            tp.ClientResultPath = itor.Current.Value;
                            break;
                        case "localresultpath":
                            tp.LocalResultPath = itor.Current.Value;
                            break;
                        case "stflocation":
                            tp.STFLocation = itor.Current.Value;
                            break;
                        case "stfparams":
                            {
                                bool tmpBool;
                                int tmpInt;

                                if (Boolean.TryParse(itor.Current.GetAttribute("NoPreRun", node.NamespaceURI), out tmpBool))
                                    tp.NoPreRun = tmpBool;
                                if (Boolean.TryParse(itor.Current.GetAttribute("NoPostRun", node.NamespaceURI), out tmpBool))
                                    tp.NoPostRun = tmpBool;
                                if (Boolean.TryParse(itor.Current.GetAttribute("NoAsync", node.NamespaceURI), out tmpBool))
                                    tp.NoAsync = tmpBool;
                                if (Boolean.TryParse(itor.Current.GetAttribute("DryRun", node.NamespaceURI), out tmpBool))
                                    tp.DryRun = tmpBool;
                                if (Int32.TryParse(itor.Current.GetAttribute("TryCount", node.NamespaceURI), out tmpInt))
                                    tp.TryCount = tmpInt;
                                tp.CodeCoverage = itor.Current.GetAttribute("CodeCoverage", node.NamespaceURI);
                                tp.AllowTags = itor.Current.GetAttribute("AllowTags", node.NamespaceURI);
                            }
                            break;
                        case "suitetimeoutseconds":
                            {
                                ushort timeout;
                                if (UInt16.TryParse(itor.Current.Value, out timeout))
                                    tp.SuiteTimeoutSeconds = timeout;
                            }
                            break;
                        case "environmentrequirements":
                            tp.EnvReqs = itor.Current.Value;
                            break;
                        case "clients":
                            tp.Clients = new List<string>(itor.Current.InnerXml.Split(',')); 
                            break;
                        case "suites":
                            XPathNodeIterator suites = itor.Current.SelectChildren(XPathNodeType.Element);
                            while (suites.MoveNext())
                            {
                                if (String.Compare(suites.Current.Name, "suite", true) == 0)
                                {
                                    tp.Suites.Add(Suite.Parse(suites.Current));
                                }
                            }
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "Unsupported TestPass element: {0}", itor.Current.Name);
                            break;
                    }
                }

                return tp;
            }
        }
        #endregion

        #region Suite Class - Defines a test suite
        protected class Suite
        {
            public string Name { get; private set; }
            public string Architecture { get; private set; }
            public string AdditionalParameter { get; private set; }

            public static Suite Parse(XPathNavigator node)
            {
                Suite suite = new Suite();

                suite.Name = "";
                suite.Architecture = "32";
                suite.AdditionalParameter = "";

                if (node.MoveToFirstAttribute())
                {
                    do
                    {
                        switch (node.Name.ToLower())
                        {
                            case "name":
                                // If the suite name was passed with the .dll extension, remove it
                                if (node.Value.ToLower().EndsWith(".dll"))
                                    suite.Name = node.Value.Substring(0, node.Value.Length - 4);
                                else
                                    suite.Name = node.Value;
                                break;
                            case "architecture":
                                suite.Architecture = node.Value;
                                break;
                            case "additionalparameter":
                                suite.AdditionalParameter = node.Value;
                                break;
                            default:
                                break;
                        }
                    } while (node.MoveToNextAttribute());
                    node.MoveToParent();
                }

                return suite;
            }

            public override string ToString()
            {
                return ToString(0);
            }

            public string ToString(int indent)
            {
                StringBuilder sb = new StringBuilder();

                if (indent < 0 || indent > 16)
                    indent = 0;

                string padding = new string(' ', indent);
                sb.AppendFormat("{0}Name: {1}\r\n", padding, Name);
                sb.AppendFormat("{0}Architecture: {1}\r\n", padding, Architecture);
                sb.AppendFormat("{0}Additional Param: {1}\r\n", padding, AdditionalParameter);

                return sb.ToString();
            }
        }
        #endregion

        #region ThreadData Class
        protected class ThreadData
        {
            public string Client { get; set; }
            public Suite TestSuite { get; set; }
            public DateTime TestPassStart { get; set; }
            public ManualResetEvent Finish { get; set; }

            public ThreadData(string client, Suite testSuite, ManualResetEvent finish)
            {
                Client = client;
                TestSuite = testSuite;
                Finish = finish;
                TestPassStart = DateTime.Now;
            }
        }
        #endregion

        protected TaskModuleInfo _info;
        protected TaskResult _result;
        protected TestPass _testPass;
        protected TestPassSummary _summary;
        protected SuiteTiming _suiteTiming;
        protected CutoffTimer _cutoffTimer;
        protected ManualResetEvent _cutoffTimeEvent;
        protected bool _cutoffTimePassed = false;
        protected bool _useSuiteTiming;
        protected string _suiteStylesheet;

        public TestPassTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "TestPassTaskModule";
            _info.Description = "Provides support for running test suites on multiple client machines.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <ResultXmlStylesheetName>HREF of a stylesheet that should be associated with the NUnit result XML files</ResultXmlStylesheetName>");
            desc.AppendLine("  <TestPass Env=\"environment\" Frequency=\"testFrequency\" Build=\"buildName\" Version=\"buildVersion\" CutoffTime=\"Time to stop running suites (in 24-hour format)\" [DumpSuiteDetails=\"true|false\">");
            desc.AppendLine("    <TimingDataPath>Location of the suite timing data file</TimingDataPath>");
            desc.AppendLine("    <ClientResultPath>Local path on the client where results will be stored</ClientResultPath>");
            desc.AppendLine("    <LocalResultPath>Local path to store client results</LocalResultPath>");
            desc.AppendLine("    <STFLocation>Local path (on the client) where the STF files are located</STFLocation>");
            desc.AppendLine("    <STFParams NoPreRun=\"true|false\" NoPostRun=\"true|false\" NoAsync=\"true|false\" DryRun=\"true|false\" TryCount=\"Failure retry count\" CodeCoverage=\"noimport|...\" AllowTags=\"Comma-separated list of tags\" />");
            desc.AppendLine("    <SuiteTimoutSeconds>Number of seconds to wait for a suite to finish before killing it. Default is 7200 (2 hours).</SuiteTimeoutSeconds>");
            desc.AppendLine("    <EnvironmentRequirements>Comma-separated list of requirements that the current environment satisfies.</EnvironmentRequirements>");
            desc.AppendLine("    <Clients>Comma-separated list of client machines</Clients>");
            desc.AppendLine("    <Suites Src=\"Local path (on the client) to the test suite dlls\">");
            desc.AppendLine("      <Suite Name=\"suiteName\" Architecture\"32|64\" [AdditionalParameter=\"suite-specific parameter\"] />");
            desc.AppendLine("    </Suites>");
            desc.AppendLine("  </TestPass>");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("* Specify the DumpSuiteDetails to also create a set of csv files containing details about the suite.");
            desc.AppendLine("* There may be multiple Suite elements describing the suites to be run as part of the test pass.");
            desc.AppendLine("* The suite name is expected to be the base name of the suite, without any extension.");
            desc.AppendLine("* The Src attribute on the Suites element needs to be set to the directory containing the 'suites' and 'suites64' subdirectories.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _suiteStylesheet = null;
            _suiteTiming = new SuiteTiming();
            _cutoffTimer = new CutoffTimer();
            _cutoffTimeEvent = new ManualResetEvent(false);
        }

        public DateTime CutoffTime
        {
            get
            {
                if (_testPass != null)
                    return _testPass.CutoffTime;
                else
                    return DateTime.Now;
            }
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void AddParameter(string parameterName, string value)
        {
            throw new NotImplementedException("This module does not support Name/Value parameters. Please define an XML parameter block instead.");
        }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "resultxmlstylesheetname":
                            _suiteStylesheet = itor.Current.Value;
                            break;
                        case "testpass":
                            _testPass = TestPass.Parse(itor.Current);
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public void RemoveAllParameters()
        {
            _suiteStylesheet = null;
            _testPass = null;
        }

        public TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate required parameters
            if (null == _testPass)
            {
                _result.AddLog(new Log("The TestPass element is required, but was not specified."));
                _result.ExecutedSuccessfully = false;
                return _result;
            }
            if (_testPass.Clients.Count == 0)
            {
                _result.AddLog(new Log("There are no clients defined."));
                _result.ExecutedSuccessfully = false;
            }

            // Set up and start the cutoff timer
            _cutoffTimer.Condition = () => DateTime.Now >= this.CutoffTime;
            _cutoffTimer.OnCondition += new Action(_cutoffTimer_OnCondition);
            _cutoffTimer.StartTimer();

            // Perform Test Pass initialization
            if (_result.ExecutedSuccessfully)
            {
                try
                {
                    // Create the local result file path
                    FileUtils.CreatePath(_testPass.LocalResultPath);
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to create the local result location:\r\n{0}", ex);
                    _result.AddLog(new Log("Unable to create the local result location:\r\n{0}", ex.Message));
                    _result.ExecutedSuccessfully = false;
                }

                // Create the 4 XML transform files in the local results directory
                try
                {
                    CreateXSLT(_testPass.LocalResultPath, "TestPassSummary.xslt");
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to write the TestPassSummary.xslt file:\r\n{0}", ex);
                }
                try
                {
                    CreateXSLT(_testPass.LocalResultPath, "TestPassSummaryQuick.xml");
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to write the TestPassSummaryQuick.xml file:\r\n{0}", ex);
                }
                try
                {
                    CreateXSLT(_testPass.LocalResultPath, "TestPassSummaryQuick.xslt");
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to write the TestPassSummaryQuick.xslt file:\r\n{0}", ex);
                }
                try
                {
                    CreateXSLT(_testPass.LocalResultPath, "TestSuiteSummary.xslt");
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to write the TestSuiteSummary.xslt file:\r\n{0}", ex);
                }

                // Initialize the suite time tracking
                try
                {
                    _useSuiteTiming = _suiteTiming.Init(_testPass.TimingDataPath);
                    if (_useSuiteTiming)
                    {
                        DACommon.LogEvent(_info.Name, LoggingLevel.Debug, "Reordering test suites based on run time.");
                        _suiteTiming.LoadSuiteTimingData(_testPass.Frequency);
                        _testPass.Suites.Sort(new Comparison<Suite>(CompareSuitesByRunTime));
                    }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to use suite timing data to re-order the suite list:\r\n{0}", ex);
                    _result.AddLog(new Log("Unable to use suite timing data to re-order the suite list:\r\n{0}", ex.Message));
                }

                // Create the summary XML file in the local results directory
                try
                {
                    _summary = new TestPassSummary(_testPass.LocalResultPath, _testPass.Env, _testPass.Build, _testPass.Version, _testPass.Frequency, DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss"));
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to create the test pass summary file at '{0}':\r\n{1}", _testPass.LocalResultPath, ex);
                    _summary = null;
                }
            }

            if (_result.ExecutedSuccessfully)
            {
                List<ManualResetEvent> waitHandles = new List<ManualResetEvent>();
                waitHandles.Add(_cutoffTimeEvent);

                // Assign the first suites to clients
                for (int i = 0; i < _testPass.Clients.Count && _testPass.Suites.Count > 0; i++)
                {
                    lock (_testPass.Suites)
                    {
                        if (!_cutoffTimeEvent.WaitOne(0, false))
                        {
                            ManualResetEvent finishEvent = new ManualResetEvent(false);
                            waitHandles.Add(finishEvent);
                            ThreadData td = new ThreadData(_testPass.Clients[i], DequeueSuite(), finishEvent);
                            DACommon.LogEvent(_info.Name, LoggingLevel.Information, "Assigning suite '{0}' to client '{1}'",
                                td.TestSuite.Name, td.Client);
                            ThreadPool.QueueUserWorkItem(new WaitCallback(RunSTFSuite), td);
                        }
                        else
                        {
                            DACommon.LogEvent(_info.Name, LoggingLevel.Information, "The cutoff time has passed - no more suites will be scheduled.");
                            break;
                        }
                    }
                }

                // Enter the wait loop - this waits for any of the threads to exit
                // and assigns the next test suite to that client machine
                int waitIndex;
                while (true)
                {
                    try
                    {
                        waitIndex = WaitHandle.WaitAny(waitHandles.ToArray());
                        if (0 == waitIndex)
                        {
                            // The cutoff time has passed
                            StringBuilder msg = new StringBuilder();
                            msg.AppendLine("The cutoff time has passed.");
                            msg.AppendFormat("There are {0} suites currently running.\r\n", waitHandles.Count - 1);
                            if (_testPass.Suites.Count > 0)
                            {
                                lock (_testPass.Suites)
                                {
                                    msg.AppendLine("The following suites will not be scheduled:");
                                    while (_testPass.Suites.Count > 0)
                                    {
                                        msg.AppendLine(DequeueSuite().Name);
                                    }
                                }
                            }
                            else
                            {
                                msg.AppendLine("There are no suites left in the queue.");
                            }
                            DACommon.LogEvent(_info.Name, LoggingLevel.Information, msg.ToString());

                            // Reset the event and turn off the timer
                            _cutoffTimePassed = true;
                            waitHandles[0].Reset();
                            _cutoffTimer.StopTimer();
                        }
                        else
                        {
                            // Since the wait handle array contains the cutoff event handle, the client index will be one less than the wait index
                            int clientIndex = waitIndex - 1;

                            DACommon.LogEvent(_info.Name, LoggingLevel.Debug, "Client {0} finished running.", _testPass.Clients[clientIndex]);
                            if (_testPass.Suites.Count > 0)
                            {
                                lock (_testPass.Suites)
                                {
                                    ThreadData td = new ThreadData(_testPass.Clients[clientIndex], DequeueSuite(), waitHandles[waitIndex]);
                                    DACommon.LogEvent(_info.Name, LoggingLevel.Information, "Assigning suite '{0}' to client '{1}'",
                                        td.TestSuite.Name, td.Client);
                                    waitHandles[waitIndex].Reset();
                                    ThreadPool.QueueUserWorkItem(new WaitCallback(RunSTFSuite), td);
                                }
                            }
                            else
                            {
                                // no more suites to schedule so remove this client from the pool
                                DACommon.LogEvent(_info.Name, LoggingLevel.Information, "Removing client {0} from the pool.", _testPass.Clients[clientIndex]);
                                waitHandles[waitIndex].Close();
                                waitHandles.RemoveAt(waitIndex);
                                _testPass.Clients.RemoveAt(clientIndex);

                                // When the client pool is empty, we can exit
                                if (_testPass.Clients.Count < 1)
                                {
                                    DACommon.LogEvent(_info.Name, LoggingLevel.Information, "The client pool is empty - exiting the wait loop.");
                                    break;
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unhandled exception while running test suites:\r\n{0}", ex);
                    }
                }

                // Add the local result file location to the log file
                // In order for the LocalLogTarget to work, this needs to be a UNC path
                Log resultLog = new Log();
                if (!_testPass.LocalResultPath.StartsWith(@"\\"))
                {
                    resultLog.Path = _testPass.LocalResultPath.Replace(Path.GetPathRoot(_testPass.LocalResultPath), @"\\" + Environment.MachineName + @"\");
                }
                else
                {
                    resultLog.Path = _testPass.LocalResultPath;
                }
                lock (_result)
                {
                    _result.AddLog(resultLog);
                }
            }

            _cutoffTimer.StopTimer();
            return _result;
        }

        void _cutoffTimer_OnCondition()
        {
            DACommon.LogEvent(_info.Name, LoggingLevel.Information, "The cutoff time has passed - signalling the test pass to stop.");
            _cutoffTimeEvent.Set();
        }

        #endregion

        /// <summary>
        /// This method wraps access to the suite list. Suites are removed from
        /// the end of the list.
        /// </summary>
        private Suite DequeueSuite()
        {
            Suite suite = null;
            lock (_testPass)
            {
                if (_testPass.Suites.Count > 0)
                {
                    suite = _testPass.Suites[_testPass.Suites.Count - 1];
                    _testPass.Suites.RemoveAt(_testPass.Suites.Count - 1);
                }
            }
            return suite;
        }

        /// <summary>
        /// This comparison method is used to sort the suite list by run time.
        /// The final list will be sorted fastest to slowest.
        /// </summary>
        private int CompareSuitesByRunTime(Suite s1, Suite s2)
        {
            if (_suiteTiming != null)
            {
                long s1Time = _suiteTiming.GetTiming(s1.Name);
                long s2Time = _suiteTiming.GetTiming(s2.Name);

                if (s1Time > s2Time)
                    return 1;
                else if (s1Time < s2Time)
                    return -1;
                else
                    return String.Compare(s1.Name, s2.Name, true);
            }
            else
                return 0;
        }

        private void RunSTFSuite(object state)
        {
            ThreadData td = state as ThreadData;
            StringBuilder args = new StringBuilder();
            string remoteLogDir;
            string outputXml;

            if (null == td)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The data passed to the RunSTFSuite method is invalid (null or not of type ThreadData)");
                return;
            }

            int passes = _testPass.DetailsOnly ? 2 : 1;
            bool detailsOnly = _testPass.DetailsOnly;

            try
            {
                // Convert the local log path to a remote UNC path
                string[] pathParts = _testPass.ClientResultPath.Split('\\');
                StringBuilder sbRemote = new StringBuilder();
                sbRemote.AppendFormat(@"\\{0}\{1}\", td.Client, pathParts[0].Replace(':', '$'));
                for (int i = 1; i < pathParts.Length; i++)
                    sbRemote.AppendFormat(@"{0}\", pathParts[i]);
                remoteLogDir = sbRemote.ToString();

                // Make sure the results path exists
                FileUtils.CreatePath(remoteLogDir);

                for (int pass = 0; pass < passes; pass++)
                {
                    args.Length = 0;

                    // Create the output filename depending on the run type
                    if (detailsOnly)
                    {
                        // <suiteName>-<yyyyMMddHHmmss>.csv
                        outputXml = String.Format("{0}-{1}.csv", td.TestSuite.Name.Replace('-', '_'), td.TestPassStart.ToString("yyyyMMddHHmmss"));
                    }
                    else
                    {
                        // <suiteName>-<env>-<build>-<version>-<frequency>-<yyyyMMddHHmmss>.xml
                        outputXml = String.Format("{0}-{1}-{2}-{3}-{4}-{5}.xml", td.TestSuite.Name.Replace('-', '_'), _testPass.Env, _testPass.Build,
                            _testPass.Version, _testPass.Frequency, td.TestPassStart.ToString("yyyyMMddHHmmss"));
                    }

                    // Build the STFConsoleLive argument list
                    if (detailsOnly)
                    {
                        args.AppendFormat("\"{0}.dll\" -env:{1} -detailsonly:\"{2}\"",
                            Path.Combine(_testPass.STFLocation, String.Format("suites{0}\\{1}", td.TestSuite.Architecture == "64" ? "64" : "", td.TestSuite.Name)),
                            _testPass.Env, Path.Combine(_testPass.ClientResultPath, outputXml));
                    }
                    else
                    {
                        args.AppendFormat("\"{0}.dll\" -env:{1} -xmlfile:\"{2}\"",
                            Path.Combine(_testPass.STFLocation, String.Format("suites{0}\\{1}", td.TestSuite.Architecture == "64" ? "64" : "", td.TestSuite.Name)),
                            _testPass.Env, Path.Combine(_testPass.ClientResultPath, outputXml));
                        if (_testPass.NoAsync)
                            args.Append(" -noasync");
                        if (_testPass.NoPreRun)
                            args.Append(" -noprerun");
                        if (_testPass.NoPostRun)
                            args.Append(" -nopostrun");
                        if (_testPass.DryRun)
                            args.Append(" -dryrun");
                        if (_testPass.TryCount > 0)
                            args.AppendFormat(" -trycount:{0}", _testPass.TryCount);
                        if (!String.IsNullOrEmpty(_testPass.CodeCoverage))
                            args.AppendFormat(" -codecoverage:{0}", _testPass.CodeCoverage);
                        if (td.TestSuite.AdditionalParameter.Length > 0)
                            args.AppendFormat(" \"{0}\"", td.TestSuite.AdditionalParameter);

                        //The -envreq, -freq, and -allowtag parameters were removed.  -exprun is used instead now, so convert those properties into an expression.
                        string expressionToRun = "";

                        if (!String.IsNullOrEmpty(_testPass.AllowTags))
                        {
                            expressionToRun += "TrunkHasTag(Tag(" + _testPass.AllowTags + "))";
                        }

                        if (!String.IsNullOrEmpty(_testPass.Frequency))
                        {
                            if (!string.IsNullOrEmpty(expressionToRun))
                            {
                                expressionToRun += " && ";
                            }

                            expressionToRun += "Frequency(Val(" + _testPass.Frequency + "))";
                        }

                        if (!String.IsNullOrEmpty(_testPass.EnvReqs))
                        {
                            if (!string.IsNullOrEmpty(expressionToRun))
                            {
                                expressionToRun += " && ";
                            }

                            expressionToRun += "EnvRequirement(Val(" + _testPass.EnvReqs + "))";
                        }

                        if (!string.IsNullOrEmpty(expressionToRun))
                        {
                            string tempFilename = System.IO.Path.GetTempFileName();
                            System.IO.File.WriteAllText(tempFilename, expressionToRun);

                            args.AppendFormat(" -exprun:\"{0}\"", tempFilename);
                        }

                        //The -ignoretag parameter was removed.  -expignore is used instead now, but this block of code doesn't used -ignoretag so we're good
                    }

                    RemoteCommandResponse rcr = null;
                    try
                    {
                        // Run the command on the specified client machine
                        RemoteCommandArgs rca = new RemoteCommandArgs(
                            Path.Combine(_testPass.STFLocation, "STFConsoleLive.exe"),
                            args.ToString(),
                            _testPass.SuiteTimeoutSeconds);
                        DACommon.LogEvent(_info.Name, LoggingLevel.Debug, "Running the following command on client {0}:\r\n{1} {2}", td.Client, rca.ExeName, rca.Arguments);
                        rcr = DACommon.RunRemoteCommand(td.Client, rca);
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Exception caught running STF remotely:\r\n{0}", ex);
                    }

                    if (rcr != null)
                    {
                        string resultLog = null;
                        if (rcr.Completed)
                        {
                            // Exit codes 0 and 1 indicate the suite finished and there should be a result file
                            if (0 == rcr.ExitCode || 1 == rcr.ExitCode)
                            {
                                if (!detailsOnly)
                                {
                                    resultLog = ProcessOutputFile(Path.Combine(remoteLogDir, outputXml), td.TestSuite.Name, td.Client);
                                }
                            }
                            else
                            {
                                if (!detailsOnly)
                                    resultLog = String.Format("{0}[{1}] STFConsoleLive returned {2}", td.TestSuite.Name, td.Client, rcr.ExitCode);
                            }

                            // Record the suite timing
                            if (_useSuiteTiming && !detailsOnly)
                                _suiteTiming.SetTiming(td.TestSuite.Name, _testPass.Frequency, rcr.RunTimeTicks);

                            // Move the result files back to the deployment server
                            try
                            {
                                // Move the XML result file
                                string resultFile = Path.Combine(remoteLogDir, outputXml);
                                if (File.Exists(resultFile))
                                {
                                    File.Move(resultFile, Path.Combine(_testPass.LocalResultPath, Path.GetFileName(resultFile)));
                                }

                                // Save the console output
                                if (!String.IsNullOrEmpty(rcr.Output))
                                {
                                    using (StreamWriter sw = new StreamWriter(Path.Combine(_testPass.LocalResultPath, Path.GetFileNameWithoutExtension(outputXml) + ".txt")))
                                    {
                                        sw.Write(rcr.Output);
                                        sw.Flush();
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to move the result files for suite '{0}' from {1} to {2}:\r\n{3}",
                                    td.TestSuite.Name, remoteLogDir, _testPass.LocalResultPath, ex);
                            }
                        }
                        else if (rcr.TimedOut)
                        {
                            resultLog = String.Format("{0}[{1}] Ran longer than {2} seconds and was terminated.", td.TestSuite.Name, td.Client, _testPass.SuiteTimeoutSeconds);
                            
                            // There will likely be an output test file in the FuncOutput subdirectory that we can copy to the logs location
                            try
                            {
                                // Convert the local log path to a remote UNC path
                                pathParts = _testPass.STFLocation.Split('\\');
                                sbRemote = new StringBuilder();
                                sbRemote.AppendFormat(@"\\{0}\{1}\", td.Client, pathParts[0].Replace(':', '$'));
                                for (int i = 1; i < pathParts.Length; i++)
                                    sbRemote.AppendFormat(@"{0}\", pathParts[i]);
                                string funcOutputDir = Path.Combine(sbRemote.ToString(), "FuncOutput");
                                File.Copy(funcOutputDir, _testPass.LocalResultPath);
                            }
                            catch (Exception ex)
                            {
                                DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to move the result file for suite '{0}' into {1}:\r\n{2}",
                                    td.TestSuite.Name, _testPass.LocalResultPath, ex);
                            }
                        }
                        else if (rcr.Exception != null)
                        {
                            resultLog = String.Format("{0}[{1}] Exception: {2}", td.TestSuite.Name, td.Client, rcr.Exception.Message);
                        }

                        // Report the result information to the log file
                        if (null != resultLog)
                        {
                            lock (_result)
                            {
                                _result.AddLog(new Log(resultLog));
                            }
                        }
                    }

                    // In case we're going around a second time, make sure we're actually running the suite
                    detailsOnly = false;
                }
            }
            catch (ThreadAbortException) { }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "An unhandled exception occurred while running a suite:\r\nClient:\r\n  {0}\r\nTest Suite:\r\n{1}\r\nException:\r\n{2}",
                    td.TestSuite.ToString(2), td.Client, ex);
            }
            finally
            {
                // Signal completion
                td.Finish.Set();
            }
        }

        private string ProcessOutputFile(string xmlPath, string suite, string client)
        {
            XmlDocument doc = null;
            StringBuilder summary = new StringBuilder();
            summary.AppendFormat("{0}[{1}] ", suite, client);

            // There are times when the XML file is there, but is not yet available for processing.
            // This loop will try 3 times to read it before giving up and reporting an error.
            int readAttempts = 0;
            while (null == doc)
            {
                try
                {
                    readAttempts++;
                    doc = new XmlDocument();
                    doc.Load(xmlPath);
                }
                catch (Exception ex)
                {
                    doc = null;
                    if (readAttempts >= 3)
                    {
                        // That's it - we can't read the file
                        DACommon.LogEvent(LoggingLevel.Warning, "Unable to read the STF output XML file: {0}\r\n{1}", xmlPath, ex);
                        summary.AppendFormat("Can't read file: {0}", ex.Message);
                        break;
                    }
                    else
                    {
                        // Let's give the file system some wait time
                        Thread.Sleep(2000);
                    }
                }
            }

            if (null != doc)
            {
                // If there's no stylesheet processing instruction, we need to add one
                if (!String.IsNullOrEmpty(_suiteStylesheet))
                {
                    try
                    {
                        bool found = false;
                        XmlNode node = doc.FirstChild;
                        while (!found && node.NodeType != XmlNodeType.Element)
                        {
                            found = (node.NodeType == XmlNodeType.ProcessingInstruction &&
                                node.OuterXml.ToLower().Contains("xsl"));
                        }

                        if (!found)
                        {
                            doc.InsertBefore(doc.CreateProcessingInstruction("xml-stylesheet", "type='text/xsl' href='" + _suiteStylesheet + "'"), doc.FirstChild);
                            doc.Save(xmlPath);
                        }
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(LoggingLevel.Warning, "Unable to add the Stylesheet processing instruction to '{0}':\r\n{1}", xmlPath, ex);
                    }
                }

                try
                {
                    XPathNavigator docNav = doc.CreateNavigator().SelectSingleNode("/test-results");
                    if (null != docNav)
                    {
                        // First get the "time" attribute from the first "test-suite" element
                        string runTime = "";
                        XPathNavigator testSuite = docNav.SelectSingleNode("test-suite");
                        if (testSuite != null)
                            runTime = testSuite.GetAttribute("time", docNav.NamespaceURI);

                        // using testSuite, get all owners
                        XPathNodeIterator iterator = testSuite.Select("//test-case/@owner");
                        string owners = String.Empty;
                        while (iterator.MoveNext())
                        {
                            if (!owners.Contains(iterator.Current.Value.ToLowerInvariant()))
                            {
                                owners += iterator.Current.Value.ToLowerInvariant() + ";";
                            }
                        }

                        owners = owners.TrimEnd(';');

                        // These four attributes are used later, so store them here
                        string total = docNav.GetAttribute("total", docNav.NamespaceURI);
                        string failures = docNav.GetAttribute("failures", docNav.NamespaceURI);
                        string notRun = docNav.GetAttribute("not-run", docNav.NamespaceURI);

                        // Create a summary line based on the attributes of the "test-results" element
                        if (null != _summary)
                        {
                            _summary.AddSummary(suite, docNav.GetAttribute("date", docNav.NamespaceURI), docNav.GetAttribute("time", docNav.NamespaceURI),
                                runTime, total, failures, notRun, docNav.GetAttribute("totalcases", docNav.NamespaceURI), docNav.GetAttribute("filtered", docNav.NamespaceURI),
                                docNav.GetAttribute("filteredEnv", docNav.NamespaceURI), docNav.GetAttribute("filteredSuite", docNav.NamespaceURI),
                                Path.GetFileName(xmlPath), owners);
                        }

                        // Create a summary and add it to the results log
                        int nTotal = 0;
                        int nFailed = 0;
                        int nNotRun = 0;
                        int passPercent = 0;

                        nTotal = Int32.Parse(total);
                        nFailed = Int32.Parse(failures);
                        nNotRun = Int32.Parse(notRun);
                        if (nNotRun < nTotal)
                            passPercent = (int)(((double)(nTotal - nFailed - nNotRun) / (double)(nTotal - nNotRun)) * 100.0);
                        summary.AppendFormat("Total:{0}  Passed:{1}  Failed:{2}  Ignored:{3}  Run/Pass:{4}%",
                            total, (nTotal - nFailed - nNotRun), nFailed, nNotRun, passPercent);
                    }
                    else
                    {
                        // doesn't seem to be a valid nunit-style results file - encode the result file before saving it
                        DACommon.LogEvent(LoggingLevel.Warning, "{0} doesn't seem to be a valid nunit-style results file - unable to find the 'test-results' element.", xmlPath);
                        summary.AppendFormat("{0} is not a valid xml results file.", xmlPath);
                    }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(LoggingLevel.Warning, "An exception occurred while processing the STF output XML file: {0}\r\n{1}", xmlPath, ex);
                    summary.AppendFormat("Processing error: {0}", ex.Message);
                }
            }

            return summary.ToString();
        }

        private void CreateXSLT(string targetPath, string xsltName)
        {
            string xsltFileName = Path.Combine(targetPath, xsltName);

            using (FileStream xsltOutStream = new FileStream(xsltFileName, FileMode.Create, FileAccess.Write, FileShare.Read))
            {
                using (Stream xsltInStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(xsltName))
                {
                    Byte[] block = new Byte[8192];
                    int bytesRead;

                    while ((bytesRead = xsltInStream.Read(block, 0, 8192)) != 0)
                    {
                        xsltOutStream.Write(block, 0, bytesRead);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TitlePropTaskModule\TitlePropTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.titleproptaskmodule
{
    [DeploymentTaskModule("TitlePropTaskModule")]
	public class TitlePropTaskModule : ITaskModule
	{
        private const string EnvParameter = "env";
        private const string MachineParameter = "machine";
        private const string ManifestParameter = "manifest";
        private const string ThreadsParameter = "threads";
        private const string TitleParameter = "title";
        private const string TitleSourceParameter = "titlesource";
        private const string ToolsPathParameter = "toolspath";
        private const string TPPPathParameter = "tpppath";
        private const string TimeoutParameter = "timeout";
        private const string PropFailuresParameter = "propfailuresarefatal";
        private const UInt16 Command_Timeout = 5400;     // 90 minutes;

        private Dictionary<string, string> _parameters;
        private TaskModuleInfo _info;

        public TitlePropTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "TitlePropTaskModule";
            _info.Description = "Props titles using TitlePropPro.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Machine", " The name of the machine where TPP.exe is installed."),
                new ParameterDescriptor("TPPPath", "The local path of TPP.exe on the TPP machine."),
                new ParameterDescriptor("Env", "The name of the environment in which propping is taking place."),
                new ParameterDescriptor("Title", "What to prop - can be either a single Title ID, a list of Title IDs, or a bulk-propping group: BVT, Acceptance, Extended, or All"),
                new ParameterDescriptor("Timeout", "[Optional] Number of seconds to wait for TPP to finish before killing the process. Default is 5400 (90 minutes)."),
                new ParameterDescriptor("Manifest", "[Optional] Overrides the location of the manifest file from the TPPSettings.xml file."),
                new ParameterDescriptor("Threads", "[Optional] Overrides the Threads setting in the TPPSettings.xml file. The maximum is 20. The default is 10."),
                new ParameterDescriptor("TitleSource", "[Optional] Overrides the Title Source location from the TPPSettings.xml file."),
                new ParameterDescriptor("ToolsPath", "[Optional] Overrides the LiveToolsLocation path in the TPPSettings.xml file."),
                new ParameterDescriptor("PropFailuresAreFatal", "[Optional] Indicates whether propping failures are considered fatal. Default is true.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(MachineParameter, "");
            _parameters.Add(TPPPathParameter, "");
            _parameters.Add(EnvParameter, "");
            _parameters.Add(ManifestParameter, "");
            _parameters.Add(ThreadsParameter, "");
            _parameters.Add(TitleParameter, "");
            _parameters.Add(TitleSourceParameter, "");
            _parameters.Add(ToolsPathParameter, "");
            _parameters.Add(TimeoutParameter, "");
            _parameters.Add(PropFailuresParameter, "");
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void AddParameters(string xmlParameterBlock) { }

        public void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public void RemoveAllParameters()
        {
            _parameters[MachineParameter] = "";
            _parameters[TPPPathParameter] = "";
            _parameters[EnvParameter] = "";
            _parameters[ManifestParameter] = "";
            _parameters[ThreadsParameter] = "";
            _parameters[TitleParameter] = "";
            _parameters[TitleSourceParameter] = "";
            _parameters[ToolsPathParameter] = "";
            _parameters[TimeoutParameter] = "";
            _parameters[PropFailuresParameter] = "true";
        }

        public TaskResult Perform()
        {
            bool propFailuresAreFatal;
            UInt16 cmdTimeout = 0;
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            // Perform basic validation of the parameters
            if (String.IsNullOrEmpty(_parameters[MachineParameter]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'Machine' parameter is required, but was not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[TPPPathParameter]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'TPPPath' parameter is required, but was not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[EnvParameter]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'Env' parameter is required, but was not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[TitleParameter]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'Title' parameter is required, but was not specified."));
            }

            // Get the command timeout
            if (!UInt16.TryParse(_parameters[TimeoutParameter], out cmdTimeout))
                cmdTimeout = Command_Timeout;

            // Make sure the TPP path contains the name of the executable
            if (String.Compare(Path.GetFileName(_parameters[TPPPathParameter]), "TPP.exe", true) != 0)
            {
                _parameters[TPPPathParameter] = Path.Combine(_parameters[TPPPathParameter], "TPP.exe");
            }

            // Create the argument list
            StringBuilder args = new StringBuilder();
            args.AppendFormat("/env:{0} /title:{1}", _parameters[EnvParameter], _parameters[TitleParameter]);
            if (!String.IsNullOrEmpty(_parameters[ManifestParameter]))
            {
                args.AppendFormat(" /manifest:\"{0}\"", _parameters[ManifestParameter]);
            }
            if (!String.IsNullOrEmpty(_parameters[ThreadsParameter]))
            {
                args.AppendFormat(" /threads:{0}", _parameters[ThreadsParameter]);
            }
            if (!String.IsNullOrEmpty(_parameters[TitleSourceParameter]))
            {
                args.AppendFormat(" /titleSource:\"{0}\"", _parameters[TitleSourceParameter]);
            }
            if (!String.IsNullOrEmpty(_parameters[ToolsPathParameter]))
            {
                args.AppendFormat(" /toolsPath:\"{0}\"", _parameters[ToolsPathParameter]);
            }

            if (!Boolean.TryParse(_parameters[PropFailuresParameter], out propFailuresAreFatal))
                propFailuresAreFatal = true;

            RemoteCommandResponse rcr = null;
            try
            {
                RemoteCommandArgs rca = new RemoteCommandArgs(_parameters[TPPPathParameter], args.ToString(), cmdTimeout);
                rcr = DACommon.RunRemoteCommand(_parameters[MachineParameter], rca);
            }
            catch (Exception ex)
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("Unable to run TPP remotely:\r\n{0}", ex));
            }

            if (rcr != null)
            {
                // Check the Completed flag to determine if the process completed
                if (rcr.Completed)
                {
                    Log log = null;
                    string logLocation = null;
                    switch (rcr.ExitCode)
                    {
                        case -1:
                            result.ExecutedSuccessfully = false;
                            result.AddLog(new Log("TPP failed to run successfully.\r\n{0}", rcr.Output));
                            break;
                        case 0:
                            result.ExecutedSuccessfully = true;
                            log = new Log();
                            try
                            {
                                logLocation = GetLogsLocation(rcr.Output);
                                log.Path = Path.GetDirectoryName(logLocation);
                                log.FileName = Path.GetFileName(logLocation);
                            }
                            catch (Exception ex)
                            {
                                DACommon.LogEvent(LoggingLevel.Error, "TitlePropTaskModule: Error finding the log file location:\r\n{0}", ex);
                            }
                            result.AddLog(log);
                            break;
                        case 1:
                            result.ExecutedSuccessfully = !propFailuresAreFatal;
                            result.AddLog(new Log("One or more titles failed to prop. Check the log files for details."));
                            log = new Log();
                            try
                            {
                                logLocation = GetLogsLocation(rcr.Output);
                                log.Path = Path.GetDirectoryName(logLocation);
                                log.FileName = Path.GetFileName(logLocation);
                            }
                            catch (Exception ex)
                            {
                                DACommon.LogEvent(LoggingLevel.Error, "TitlePropTaskModule: Error finding the log file location:\r\n{0}", ex);
                            }
                            result.AddLog(log);
                            break;
                    }
                }
                else if (rcr.TimedOut)
                {
                    result.ExecutedSuccessfully = false;
                    result.AddLog(new Log("The timeout of {0} seconds expired while waiting for TPP to complete.", Command_Timeout));
                }
                else if (rcr.Exception != null)
                {
                    result.ExecutedSuccessfully = false;
                    result.AddLog(new Log("An exception occurred while running TPP.\r\n{0}", rcr.Exception));
                }
            }

            return result;
        }

        private string GetLogsLocation(string output)
        {
            int index = output.IndexOf("Log Location : ");
            if (index >= 0)
            {
                int lineEnd = output.IndexOf("\r\n", index);
                index += 15;
                return output.Substring(index, lineEnd - index);
            }
            else
                return "";
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMCleanUpTaskModule\Test\VMCleanUpTaskModuleTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Security.Principal;
using System.ComponentModel;
using System.Xml;
using System.Xml.XPath;
using System.Text.RegularExpressions;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.vmtaskmodule;
using xonline.test.deployment.automation.taskmodules.vmcleanuptaskmodule;

namespace xonline.test.deployment.automation.taskmodules.vmcleanuptaskmodule.test
{
    public class VMCleanUpTaskModuleTest
    {
        #region SnapKeyword Class - Object representation of the SnapKeyword element.
        protected class SnapKeywordTest
        {
            public Regex RegExString { get; set; }
            public int KeepCount { get; set; }
            public SnapKeywordTest(string regExString, int keepCount)
            {
                this.RegExString = new Regex(regExString);
                this.KeepCount = keepCount;
            }
        }
        #endregion

        private static string _xmlParamaterBlock;

        static VMCleanUpTaskModuleTest()
        {
            string _hostList = "XeCoreVSrv001";
            string _vmSpec = "VXe%";
            string _ignoreVMList = "VXeInfrStg%";
            List<SnapKeywordTest> snapKeywordList = new List<SnapKeywordTest>();
            bool _deleteChildren = false;
            bool _debug = true;
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R2 09\.02\.\d{4}\.\d{2} - Service", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R2 09\.02\.\d{4}\.\d{2} - Service Deployed", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R2 09\.02\.\d{4}\.\d{2} - LKG Testing", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R2 09\.02\.\d{4}\.\d{2} - LKG Testing Passed", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R1 08\.02\.\d{4}\.\d{2} - Service", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R1 08\.02\.\d{4}\.\d{2} - Service Deployed", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R1 08\.02\.\d{4}\.\d{2} - LKG Testing", 1));
            snapKeywordList.Add(new SnapKeywordTest(@"XOnline_R1 08\.02\.\d{4}\.\d{2} - LKG Testing Passed", 1));
            snapKeywordList.Add(new SnapKeywordTest(".Current", -1));

            StringBuilder xmlParamBldr = new StringBuilder();

            xmlParamBldr.AppendLine("<Parameters>");
            xmlParamBldr.AppendLine(String.Format("  <HostList Hosts=\"{0}\" />", _hostList));
            xmlParamBldr.AppendLine(String.Format("  <VMList VMSpec=\"{0}\" IgnoreVMList=\"{1}\" DelChildren=\"{2}\" />", _vmSpec, _ignoreVMList, _deleteChildren.ToString()));
            foreach (SnapKeywordTest snapKeyword in snapKeywordList)
            {
                xmlParamBldr.AppendLine(String.Format("  <SnapKeyword String=\"{0}\" KeepCount=\"{1}\" />", snapKeyword.RegExString.ToString(), snapKeyword.KeepCount.ToString()));
            }
            if (_debug == true)
                xmlParamBldr.AppendLine("  <ListOnly />");
            xmlParamBldr.AppendLine("</Parameters>\r\n");

            _xmlParamaterBlock = xmlParamBldr.ToString();
        }

        static void Main(string[] args)
        {

            Dictionary<string, string> parameters = new Dictionary<string,string>();
            try
            {
                if (args.Length == 1)
                {
                    XmlDocument paramDoc = new XmlDocument();
                    paramDoc.Load(args[0]);
                    _xmlParamaterBlock = paramDoc.ToString();
                }
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex.ToString());
                PrintUsage();
                return;
            }

            try
            {
                Console.WriteLine("Parameter Block:\r\n{0}", _xmlParamaterBlock.ToString());
                VMCleanupSnapshotModule vmcleanupVerifier = new VMCleanupSnapshotModule();
                vmcleanupVerifier.AddParameters(_xmlParamaterBlock.ToString());
                TaskResult vmcleanupResults = vmcleanupVerifier.Perform();

                Console.WriteLine("Snapshot Cleanup succeeded = {0}", vmcleanupResults.ExecutedSuccessfully);
                foreach (Log log in vmcleanupResults.Logs)
                {
                    //Console.WriteLine("Log:");
                    if(log.Path != null)
                        Console.WriteLine("Path: {0}", log.Path);
                    if (log.FileName != null)
                        Console.WriteLine("File: {0}", log.FileName);
                    if (log.Text != null)
                        Console.WriteLine("Text: {0}", log.Text);
                }

                Console.WriteLine();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
                PrintUsage();
            }
        }

        static void PrintUsage()
        {
            Console.WriteLine("Usage: VMCleanupSnapshots [Parameters]");
            Console.WriteLine();
            Console.WriteLine("Parameters/Defaults:");
            Console.WriteLine("<Parameters>");
            Console.WriteLine("  <HostList Hosts=\"Comma-Delimetted Host List\" Username=\"Username\" Password=\"Password\" PasswordEncrypted=\"true|false\" />");
            Console.WriteLine("  <VMList VMSpec=\"WQL-compliant string\" IgnoreVMList=\"Comma-Delimetted Ignore List\" DelChildren=\"true|false\" />");
            Console.WriteLine("  <SnapKeyword String=\"RegularExpressionString\" KeepCount=\"[0-x]\" />");
            Console.WriteLine("  <ListOnly />");
            Console.WriteLine("</Parameters>\r\n");
            Console.WriteLine();
            Console.WriteLine("Default:\r\n{0}", _xmlParamaterBlock);
            Console.WriteLine();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMTaskModule\HyperVHost.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Management;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.vmtaskmodule
{
	public class HyperVHost : HyperVBase
	{
        public HyperVHost(string hostName) : this(hostName, null, null) { }
        public HyperVHost(string hostName, string userName, string password)
        {
            HostName = hostName;
            UserName = userName;
            Password = password;
        }

        public string HostName { get; private set; }
        public string UserName { get; private set; }
        public string Password { get; private set; }

        /// <summary>
        /// Connects to the Hyper-V host server.
        /// </summary>
        public void Connect()
        {
            WmiObj = WMI.GetServiceObject(
                WMI.ConnectToHost(HostName, "Virtualization", UserName, Password),
                "Msvm_VirtualSystemManagementService");
        }

        private delegate void AsyncConnect();
        private AsyncConnect _connectDelegate = null;
        /// <summary>
        /// Asynchronously connects to the host server
        /// </summary>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        public IAsyncResult BeginConnect(AsyncCallback callback, object state)
        {
            Debug.Assert(_connectDelegate == null);

            _connectDelegate = new AsyncConnect(Connect);
            return _connectDelegate.BeginInvoke(callback, state);
        }
        public void EndConnect(IAsyncResult result)
        {
            Debug.Assert(_connectDelegate != null);

            if (null == result)
                throw new ArgumentNullException();
            _connectDelegate.EndInvoke(result);
            _connectDelegate = null;
        }

        /// <summary>
        /// Gets a list of all virtual machines hosted on this server.
        /// </summary>
        /// <param name="nameSpec">(Optional) A WQL-compliant string to use to filter the results.</param>
        /// <param name="ignoreNameSpec">(Optional) A WQL-compliant string to use to ignore virtual machine names.</param>
        /// <returns>A list of VirtualMachine objects.</returns>
        public VirtualMachines GetVirtualMachineList() { return GetVirtualMachineList(null); }
        public VirtualMachines GetVirtualMachineList(string nameSpec) { return GetVirtualMachineList(nameSpec, null); }
        public VirtualMachines GetVirtualMachineList(string nameSpec, string ignoreNameSpec)
        {
            if (null == WmiObj)
                throw new InvalidOperationException();

            VirtualMachines vms = new VirtualMachines();
            StringBuilder query = new StringBuilder();
            query.AppendFormat("Select * From Msvm_ComputerSystem Where Name != '{0}'", HostName);
            if (!String.IsNullOrEmpty(nameSpec))
                query.AppendFormat(" And ElementName LIKE '{0}'", nameSpec);
            ManagementObjectCollection vmList = WMI.QueryObjects(WmiObj.Scope, query.ToString());
            ManagementObjectCollection ignoreList = null;

            // If an ignoreNameSpec is specified, we need to find all VMs that match that name,
            // then exclude them manually from the final list.
            if (vmList.Count > 0 && !String.IsNullOrEmpty(ignoreNameSpec))
            {
                query.Length = 0;
                query.AppendFormat("Select * From Msvm_ComputerSystem Where Name != '{0}' AND ElementName LIKE '{1}'",
                    HostName, ignoreNameSpec);
                ignoreList = WMI.QueryObjects(WmiObj.Scope, query.ToString());
            }

            foreach (ManagementObject obj in vmList)
            {
                bool ignore = false;
                if (ignoreList != null && ignoreList.Count > 0)
                {
                    // if the name of the VM that we're adding matches a name
                    // in the Ignore List, just skip it
                    foreach (ManagementObject ignoreObj in ignoreList)
                    {
                        if (String.Compare(obj["ElementName"] as string,
                            ignoreObj["ElementName"] as string, true) == 0)
                        {
                            ignore = true;
                            break;
                        }
                    }
                }
                if (!ignore)
                    vms.Add(new VirtualMachine(obj));
            }

            return vms;
        }

        /// <summary>
        /// Asynchronously gets a list of all Virtual Machines on this host.
        /// </summary>
        /// <param name="nameSpec">(Optional) A WQL-compliant string to use to filter the results.</param>
        /// <param name="ignoreNameSpec">(Optional) A WQL-compliant string to use to ignore virtual machine names.</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate VirtualMachines AsyncGetVirtualMachineList(string nameSpec, string ignoreNameSpec);
        private AsyncGetVirtualMachineList _getvmlDelegate = null;
        public IAsyncResult BeginGetVirtualMachineList(AsyncCallback callback, object state) { return BeginGetVirtualMachineList(null, callback, state); }
        public IAsyncResult BeginGetVirtualMachineList(string nameSpec, AsyncCallback callback, object state) { return BeginGetVirtualMachineList(nameSpec, null, callback, state); }
        public IAsyncResult BeginGetVirtualMachineList(string nameSpec, string ignoreNameSpec, AsyncCallback callback, object state)
        {
            _getvmlDelegate = new AsyncGetVirtualMachineList(GetVirtualMachineList);
            return _getvmlDelegate.BeginInvoke(nameSpec, ignoreNameSpec, callback, state);
        }
        public VirtualMachines EndGetVirtualMachineList(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _getvmlDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Gets a flat list of all snapshots defined on this host.
        /// </summary>
        /// <param name="nameSpec">(Optional) A WQL-compliant name string to use to filter the snapshots. May contain the '%' wildcard character.</param>
        /// <param name="sortMethod">(Optional) One of the SnapshotSortMethod enumeration values specfying how the list should be sorted.</param>
        /// <returns>A list of Snapshot objects.</returns>
        public Snapshots GetSnapshotList()
        {
            return GetSnapshotList(null, SnapshotSortMethod.None);
        }
        public Snapshots GetSnapshotList(string nameSpec)
        {
            return GetSnapshotList(nameSpec, SnapshotSortMethod.None);
        }
        public Snapshots GetSnapshotList(SnapshotSortMethod sortMethod)
        {
            return GetSnapshotList(null, sortMethod);
        }
        public Snapshots GetSnapshotList(string nameSpec, SnapshotSortMethod sortMethod)
        {
            if (null == WmiObj)
                throw new InvalidOperationException();

            List<Snapshot> snapshots = new List<Snapshot>();
            StringBuilder query = new StringBuilder();
            query.AppendFormat("Select * From Msvm_VirtualSystemSettingData Where SettingType=5");
            if (!String.IsNullOrEmpty(nameSpec))
                query.AppendFormat(" and ElementName like '{0}'", nameSpec);

            // Get the list of snapshots defined on this host
            ManagementObjectCollection snapshotList = WMI.QueryObjects(WmiObj.Scope, query.ToString());
            foreach (ManagementObject vssd in snapshotList)
            {
                snapshots.Add(new Snapshot(vssd));
            }

            // Sort the resulting list
            if (sortMethod != SnapshotSortMethod.None)
            {
                SnapshotComparer sc = new SnapshotComparer(sortMethod);
                snapshots.Sort(sc);
            }

            return new Snapshots(snapshots);
        }

        /// <summary>
        /// Asynchronously gets a list of snapshots defined for all Virtual Machines on this host.
        /// </summary>
        /// <param name="nameSpec">(Optional) A WQL-compliant name string to use to filter the snapshots. May contain the '%' wildcard character.</param>
        /// <param name="sortMethod">(Optional) One of the SnapshotSortMethod enumeration values specfying how the list should be sorted.</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate Snapshots AsyncGetSnapshotList(string nameSpec, SnapshotSortMethod sortMethod);
        private AsyncGetSnapshotList _getslDelegate = null;
        public IAsyncResult BeginGetSnapshotList(AsyncCallback callback, object state) { return BeginGetSnapshotList(null, SnapshotSortMethod.None, callback, state); }
        public IAsyncResult BeginGetSnapshotList(string nameSpec, AsyncCallback callback, object state) { return BeginGetSnapshotList(nameSpec, SnapshotSortMethod.None, callback, state); }
        public IAsyncResult BeginGetSnapshotList(SnapshotSortMethod sortMethod, AsyncCallback callback, object state) { return BeginGetSnapshotList(null, sortMethod, callback, state); }
        public IAsyncResult BeginGetSnapshotList(string nameSpec, SnapshotSortMethod sortMethod, AsyncCallback callback, object state)
        {
            _getslDelegate = new AsyncGetSnapshotList(GetSnapshotList);
            return _getslDelegate.BeginInvoke(nameSpec, sortMethod, callback, state);
        }
        public Snapshots EndGetSnapshotList(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _getslDelegate.EndInvoke(result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\DACommonLogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    class DACommonLogger : ILogger
    {
        public void LogEvent(string eventSource, LoggingLevel level, string format, params object[] args)
        {
            DACommon.LogEvent(eventSource, level, format, args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMTaskModule\HyperVBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Management;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.vmtaskmodule
{
	public class HyperVBase
	{
        private ManagementObject _wmiObj = null;
        protected HyperVBase() { Timeout = 1800; }

        #region Properties
        protected ManagementObject WmiObj
        {
            get { return _wmiObj; }
            set { _wmiObj = value; }
        }
        public string Path
        {
            get
            {
                return GetProperty("__PATH") as string;
            }
        }
        public string Server
        {
            get
            {
                return GetProperty("__SERVER") as string;
            }
        }
        public int Timeout { get; set; }
        #endregion

        protected ManagementObject GetVirtualSystemManagementService()
        {
            if (null == _wmiObj)
                return null;
            return WMI.QuerySingleObject(
                _wmiObj.Scope,
                String.Format("Select * From Msvm_VirtualSystemManagementService Where __SERVER = '{0}'", Server));
        }

        protected object GetProperty(string propertyName)
        {
            if (String.IsNullOrEmpty(propertyName))
                return null;
            if (_wmiObj != null)
            {
                return _wmiObj.GetPropertyValue(propertyName);
            }
            return null;
        }

        protected ManagementObject GetRelatedObject(string className)
        {
            ManagementObject relatedObj = null;

            ManagementObjectCollection moc = _wmiObj.GetRelated(className);
            if (moc != null)
            {
                foreach (ManagementObject obj in moc)
                {
                    relatedObj = obj;
                    break;
                }
            }

            return relatedObj;
        }

        protected ManagementObject GetRelatedObject(string className, string relationshipClass)
        {
            ManagementObject relatedObj = null;

            ManagementObjectCollection moc = _wmiObj.GetRelated(
                className,
                relationshipClass,
                null,
                null,
                null,
                null,
                false,
                null);
            if (moc != null)
            {
                foreach (ManagementObject obj in moc)
                {
                    relatedObj = obj;
                    break;
                }
            }

            return relatedObj;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMTaskModule\Snapshot.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Management;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.vmtaskmodule
{
    public enum SnapshotSortMethod
    {
        None = 0,
        NameAscending,
        NameDescending,
        DateAscending,
        DateDescending
    }

    public class Snapshot : HyperVBase
    {
        private VirtualMachine _vm = null;

        /// <summary>
        /// Internal c'tor. This is used by VirtualMachine and
        /// HyperVHost objects to construct a snapshot object.
        /// If the VM object is not provided here, the parent
        /// VM will be retrieved the first time it is needed.
        /// </summary>
        /// <param name="vssd">The snapshot WMI object. Must not be null.</param>
        /// <param name="vm">(Optional) The VirtualMachine object representing the owner of this snapshot.</param>
        internal Snapshot(ManagementObject vssd) : this(vssd, null) { }
        internal Snapshot(ManagementObject vssd, VirtualMachine vm) : base()
        {
            if (null == vssd)
                throw new ArgumentNullException();

            _vm = vm;
            WmiObj = vssd;
        }

        #region Properties
        public DateTime CreationTime
        {
            get
            {
                return WMI.ParseCIMDateTime(GetProperty("CreationTime") as string, true);
            }
        }
        public DateTime CreationTimeUtc
        {
            get
            {
                return WMI.ParseCIMDateTime(GetProperty("CreationTime") as string, false);
            }
        }
        public string InstanceId
        {
            get
            {
                return GetProperty("InstanceID") as string;
            }
        }
        public string Name
        {
            get
            {
                return GetProperty("ElementName") as string;
            }
        }
        public string ParentId
        {
            get
            {
                return GetProperty("Parent") as string;
            }
        }
        public string SystemName
        {
            get
            {
                return GetProperty("SystemName") as string;
            }
        }
        public VirtualMachine VMOwner
        {
            get
            {
                return _vm;
            }
        }
        #endregion

        #region Comparison Methods
        public static bool operator ==(Snapshot a, Snapshot b)
        {
            if (Object.ReferenceEquals(a, b))
                return true;

            if (null == a || null == b)
                return false;

            return a.Equals(b);
        }

        public static bool operator !=(Snapshot a, Snapshot b)
        {
            return !(a == b);
        }

        public override bool Equals(object obj)
        {
            Snapshot snapshot = obj as Snapshot;
            if (null == snapshot)
                return false;

            return snapshot.InstanceId == InstanceId;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        #endregion

        #region Public Methods

        /// <summary>
        /// Refreshes the properties of the Snapshot object.
        /// </summary>
        public void Refresh()
        {
            if (null == WmiObj)
                throw new InvalidOperationException();
            
            // Re-query the host server for this snapshot
            WmiObj = WMI.QuerySingleObject(WmiObj.Scope, String.Format("Select * From Msvm_VirtualSystemSettingData Where InstanceID = '{0}'", InstanceId));
        }

        /// <summary>
        /// Returns a list of the immediate child snapshots of this snapshot.
        /// </summary>
        /// <returns>A list of Snapshot objects representing the list of children. An empty list is returned if there are no children.</returns>
        public Snapshots GetChildSnapshots()
        {
            if (null == WmiObj)
                throw new InvalidOperationException();
            Snapshots childSnapshots = new Snapshots();

            ManagementObjectCollection moc = WMI.QueryObjects(WmiObj.Scope,
                String.Format("Select * From Msvm_VirtualSystemSettingData Where Parent LIKE '%{0}%'", InstanceId));
            foreach (ManagementObject obj in moc)
            {
                childSnapshots.Add(new Snapshot(obj));
            }

            return childSnapshots;
        }

        /// <summary>
        /// Asynchronously retrieves a list of child snapshots.
        /// </summary>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate Snapshots AsyncGetChildSnapshots();
        private AsyncGetChildSnapshots _getChildSnapshotsDelegate = null;
        public IAsyncResult BeginGetChildSnapshots(AsyncCallback callback, object state)
        {
            _getChildSnapshotsDelegate = new AsyncGetChildSnapshots(GetChildSnapshots);
            return _getChildSnapshotsDelegate.BeginInvoke(callback, state);
        }
        public Snapshots EndGetChildSnapshots(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _getChildSnapshotsDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Gets the parent snapshot.
        /// </summary>
        /// <returns>A Snapshot object representing the parent snapshot. Null if this snapshot doesn't have a parent.</returns>
        public Snapshot GetParentSnapshot()
        {
            if (null == WmiObj)
                throw new InvalidOperationException();

            ManagementObject obj = WMI.QuerySingleObject(WmiObj.Scope,
                String.Format("Select * From Msvm_VirtualSystemSettingData Where __PATH='{0}'", ParentId));
            if (obj != null)
                return new Snapshot(obj);
            return null;
        }

        /// <summary>
        /// Asynchronously retrieves the parent snapshot.
        /// </summary>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate Snapshot AsyncGetParentSnapshot();
        private AsyncGetParentSnapshot _getParentSnapshotDelegate = null;
        public IAsyncResult BeginGetParentSnapshot(AsyncCallback callback, object state)
        {
            _getParentSnapshotDelegate = new AsyncGetParentSnapshot(GetParentSnapshot);
            return _getParentSnapshotDelegate.BeginInvoke(callback, state);
        }
        public Snapshot EndGetParentSnapshot(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _getParentSnapshotDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Applies the snapshot.
        /// </summary>
        /// <param name="allowMerge">
        ///     (Optional) Flag indicating whether or not to wait for the merge operation to complete before restarting the Virtual Machine.
        ///     Defaults to true.
        /// </param>
        /// <returns>true if the operation is successful, false otherwise</returns>
        public bool Apply() { return Apply(true); }
        public bool Apply(bool allowMerge)
        {
            // Snapshot methods are on the Msvm_VirtualSystemManagementService object
            ManagementObject vsms = GetVirtualSystemManagementService();
            bool success = true;

            // If the VM hasn't been provided, get it now
            if (null == _vm)
            {
                GetVM();
            }

            // Make sure the virtual machine is not in a transition state
            _vm.WaitForTransition();

            // Get the VM into the proper state for snapshot application
            switch (_vm.EnabledState)
            {
                case EnabledState.Enabled:
                    // It's better to shutdown the VM because that will
                    // kick off the merge job
                    _vm.Shutdown(allowMerge, true, "Applying snapshot");
                    break;
                case EnabledState.Paused:
                    // Paused VMs need to be turned off
                    _vm.TurnOff();
                    break;
                case EnabledState.Disabled:
                case EnabledState.Saved:
                    // Do nothing - a snapshot can be applied in any of these states
                    break;
            }

            success = WMI.InvokeMethod(vsms,
                "ApplyVirtualSystemSnapshot",
                Timeout,
                new MethodParam("ComputerSystem", _vm.Path),
                new MethodParam("SnapshotSettingData", Path));

            if (success)
            {
                // Restart the VM once the snapshot has been applied
                success = _vm.Start(true);
            }

            return success;
        }

        /// <summary>
        /// Applies this snapshot to the virtual machine. Snapshots can only be applied when the VM
        /// is in the Stopped (or Disabled) state.
        /// </summary>
        /// <param name="allowMerge">
        ///     (Optional) Flag indicating whether or not to wait for the merge operation to complete before restarting the Virtual Machine.
        ///     Defaults to true.
        /// </param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncApply(bool allowMerge);
        private AsyncApply _applyDelegate = null;
        public IAsyncResult BeginApply(AsyncCallback callback, object state) { return BeginApply(true, callback, state); }
        public IAsyncResult BeginApply(bool allowMerge, AsyncCallback callback, object state)
        {
            _applyDelegate = new AsyncApply(Apply);
            return _applyDelegate.BeginInvoke(allowMerge, callback, state);
        }
        public bool EndApply(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _applyDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Renames the snapshot.
        /// </summary>
        /// <param name="newName">The new name for the snapshot.</param>
        /// <returns>true is successful, false otherwise</returns>
        public bool Rename(string newName)
        {
            if (String.IsNullOrEmpty(newName))
                throw new ArgumentException("Invalid snapshot name");

            // If the VM hasn't been provided, get it now
            if (null == _vm)
            {
                GetVM();
            }

            // Snapshot methods are on the Msvm_VirtualSystemManagementService object
            ManagementObject vsms = GetVirtualSystemManagementService();

            WmiObj["ElementName"] = newName;
            bool success = WMI.InvokeMethod(
                vsms,
                "ModifyVirtualSystem",
                Timeout,
                new MethodParam("ComputerSystem", _vm.Path),
                new MethodParam("SystemSettingData", WmiObj.GetText(TextFormat.WmiDtd20)));

            return success;
        }

        /// <summary>
        /// Asynchronously renames the snapshot.
        /// </summary>
        /// <param name="newName">The new name of the snapshot</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncRename(string newName);
        private AsyncRename _renameDelegate = null;
        public IAsyncResult BeginRename(string newName, AsyncCallback callback, object state)
        {
            _renameDelegate = new AsyncRename(Rename);
            return _renameDelegate.BeginInvoke(newName, callback, state);
        }
        public bool EndRename(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _renameDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Deletes the snapshot. Once the snapshot is deleted, the object should be considered invalid.
        /// </summary>
        /// <param name="deleteChildren">(Optional) Flag indicating whether the children of this snapshot should be deleted with the snapshot. Defaults to false.</param>
        /// <returns>true if the operation succeeded, false otherwise.</returns>
        public bool Delete(bool deleteChildren)
        {
            bool success = false;
            string methodName = deleteChildren ? "RemoveVirtualSystemSnapshotTree" : "RemoveVirtualSystemSnapshot";

            // Snapshot methods are on the Msvm_VirtualSystemManagementService object
            ManagementObject vsms = GetVirtualSystemManagementService();

            success = WMI.InvokeMethod(vsms,
                methodName,
                Timeout,
                new MethodParam("SnapshotSettingData", Path));

            if (success)
            {
                // Set the underlying WMI object to null to indicate that the snapshot is no longer valid.
                WmiObj = null;
            }

            return success;
        }

        /// <summary>
        /// Asynchronously deletes the snapshot.
        /// </summary>
        /// <param name="deleteChildren">(Optional) Flag indicating whether the children of this snapshot should be deleted with the snapshot. Defaults to false.</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncDelete(bool deleteChildren);
        private AsyncDelete _deleteDelegate = null;
        public IAsyncResult BeginDelete(AsyncCallback callback, object state) { return BeginDelete(false, callback, state); }
        public IAsyncResult BeginDelete(bool deleteChildren, AsyncCallback callback, object state)
        {
            _deleteDelegate = new AsyncDelete(Delete);
            return _deleteDelegate.BeginInvoke(deleteChildren, callback, state);
        }
        public bool EndDelete(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _deleteDelegate.EndInvoke(result);
        }

        #endregion

        #region Private Helper Methods
        private VirtualMachine GetVM()
        {
            return new VirtualMachine(WMI.QuerySingleObject(WmiObj.Scope,
                String.Format("Select * From Msvm_ComputerSystem Where Name='{0}'", SystemName)));
        }
        #endregion
    }
    
    public class Snapshots : Collection<Snapshot>
    {
        public Snapshots() : base() { }
        public Snapshots(IList<Snapshot> list) : base(list) { }
    }

    internal class SnapshotComparer : IComparer<Snapshot>
    {
        SnapshotSortMethod _sortMethod = SnapshotSortMethod.NameAscending;

        public SnapshotComparer() { }
        public SnapshotComparer(SnapshotSortMethod sortMethod) { _sortMethod = sortMethod; }

        #region IComparer<Snapshot> Members

        public int Compare(Snapshot x, Snapshot y)
        {
            if (Object.ReferenceEquals(x, y))
                return 0;

            if ((null == x) || (null == y))
                return -1;

            int ret = 0;
            switch (_sortMethod)
            {
                case SnapshotSortMethod.NameAscending:
                    ret = String.Compare(x.Name, y.Name);
                    break;
                case SnapshotSortMethod.NameDescending:
                    ret = String.Compare(y.Name, x.Name);
                    break;
                case SnapshotSortMethod.DateAscending:
                    ret = x.CreationTimeUtc.CompareTo(y.CreationTimeUtc);
                    break;
                case SnapshotSortMethod.DateDescending:
                    ret = y.CreationTimeUtc.CompareTo(x.CreationTimeUtc);
                    break;
            }

            return ret;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMTaskModule\VirtualMachine.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Management;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.vmtaskmodule
{
    public enum EnabledState : ushort
    {
        Unknown = 0,
        Enabled = 2,
        Disabled = 3,
        Paused = 32768,
        Saved,
        Starting,
        Snapshotting,
        Saving = 32773,
        Stopping,
        Pausing = 32776,
        Resuming
    }

    public enum HealthState : ushort
    {
        Ok = 5,
        MajorFailure = 20,
        CriticalFailure = 25
    }

    public enum OperationalStatus : ushort
    {
        Unknown = 0,
        Ok = 2,
        Degraded = 3,
        PredictiveFailure = 5,
        InService = 11,
        CreatingSnapshot = 32768,
        ApplyingSnapshot,
        DeletingSnapshot,
        WaitingToStart,
        MergingDisks,
        ExportingVM,
        MigratingVM
    }

    public class VirtualMachine : HyperVBase
    {
        #region Properties
        public string Caption
        {
            get
            {
                return GetProperty("Caption") as string;
            }
        }
        public string Description
        {
            get
            {
                return GetProperty("Description") as string;
            }
        }
        public EnabledState EnabledState
        {
            get
            {
                object obj = GetProperty("EnabledState");
                if (obj != null)
                    return (EnabledState)(UInt16)obj;
                else
                    return 0;
            }
        }
        public HealthState HealthState
        {
            get
            {
                object obj = GetProperty("HealthState");
                if (obj != null)
                    return (HealthState)(UInt16)obj;
                else
                    return 0;
            }
        }
        public string Name
        {
            get
            {
                return GetProperty("ElementName") as string;
            }
        }
        public UInt64 OnTime
        {
            get
            {
                object obj = GetProperty("OnTimeInMilliseconds");
                if (obj != null)
                    return (UInt64)obj;
                else
                    return 0;
            }
        }
        public OperationalStatus Status
        {
            get
            {
                Array ar = GetProperty("OperationalStatus") as Array;
                OperationalStatus os = OperationalStatus.Unknown;
                if (ar != null && ar.Length > 0)
                {
                    os = (OperationalStatus)(UInt16)ar.GetValue(0);
                    // Check for a secondary status value
                    if (ar.Length > 1)
                        os = (OperationalStatus)(UInt16)ar.GetValue(1);
                }
                return os;
            }
        }
        public string UniqueId
        {
            get
            {
                return GetProperty("Name") as string;
            }
        }
        #endregion

        internal VirtualMachine(ManagementObject vm)
            : base()
        {
            WmiObj = vm;
        }

        #region Public Methods
        public static VirtualMachine Find(string vmName, string server)
        {
            return Find(vmName, server, null, null);
        }
        public static VirtualMachine Find(string vmName, string server, string userName, string password)
        {
            return new VirtualMachine(WMI.QuerySingleObject(WMI.ConnectToHost(server, "Virtualization", userName, password),
                String.Format("SELECT * FROM Msvm_ComputerSystem WHERE ElementName = '{0}'", vmName)));
        }

        /// <summary>
        /// Refreshes the existing Virtual Machine object from the host server.
        /// </summary>
        public void Refresh()
        {
            if (null == WmiObj)
                throw new InvalidOperationException();

            // Re-query the host server for this VM
            WmiObj = WMI.QuerySingleObject(WmiObj.Scope, String.Format("Select * From Msvm_ComputerSystem Where Name = '{0}'", UniqueId));
        }

        /// <summary>
        /// Returns the first snapshot that matches the provided name.
        /// </summary>
        /// <param name="snapshotNameSpec">A WQL-compliant name string. This string may contain the '%' wildcard character.</param>
        /// <returns>A Snapshot object representing the first snapshot that matches the given name. Null if no matches are found.</returns>
        public Snapshot GetSnapshot(string snapshotNameSpec)
        {
            if (null == WmiObj)
                return null;

            Snapshots snapshots = GetSnapshotList(snapshotNameSpec);
            if (snapshots.Count > 0)
                return snapshots[0];

            return null;
        }

        /// <summary>
        /// Asynchronously gets the specified snapshot.
        /// </summary>
        /// <param name="snapshotNameSpec">A WQL-compliant name string. This string may contain the '%' wildcard character.</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate Snapshot AsyncGetSnapshot(string snapshotNameSpec);
        private AsyncGetSnapshot _getSnapshotDeletegate = null;
        public IAsyncResult BeginGetSnapshot(string snapshotNameSpec, AsyncCallback callback, object state)
        {
            _getSnapshotDeletegate = new AsyncGetSnapshot(GetSnapshot);
            return _getSnapshotDeletegate.BeginInvoke(snapshotNameSpec, callback, state);
        }
        public Snapshot EndGetSnapshot(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _getSnapshotDeletegate.EndInvoke(result);
        }

        /// <summary>
        /// Gets a flat list of snapshots defined for this Virtual Machine.
        /// </summary>
        /// <param name="nameSpec">(Optional) A WQL-compliant name string to use to filter the snapshots. May contain the '%' wildcard character.</param>
        /// <param name="sortMethod">(Optional) One of the SnapshotSortMethod enumeration values specfying how the list should be sorted.</param>
        /// <returns>A list of Snapshot objects for this Virtual Machine.</returns>
        public Snapshots GetSnapshotList()
        {
            return GetSnapshotList(null, SnapshotSortMethod.None);
        }
        public Snapshots GetSnapshotList(string nameSpec)
        {
            return GetSnapshotList(nameSpec, SnapshotSortMethod.None);
        }
        public Snapshots GetSnapshotList(SnapshotSortMethod sortMethod)
        {
            return GetSnapshotList(null, sortMethod);
        }
        public Snapshots GetSnapshotList(string nameSpec, SnapshotSortMethod sortMethod)
        {
            if (null == WmiObj)
                throw new InvalidOperationException();

            List<Snapshot> snapshots = new List<Snapshot>();
            StringBuilder query = new StringBuilder();
            query.AppendFormat("Select * From Msvm_VirtualSystemSettingData Where SystemName='{0}' and SettingType=5", UniqueId);
            if (!String.IsNullOrEmpty(nameSpec))
                query.AppendFormat(" and ElementName like '{0}'", nameSpec);

            // Get the list of snapshots associated with this VM
            ManagementObjectCollection snapshotList = WMI.QueryObjects(WmiObj.Scope, query.ToString());
            foreach (ManagementObject vssd in snapshotList)
            {
                snapshots.Add(new Snapshot(vssd, this));
            }

            // Sort the resulting list
            if (sortMethod != SnapshotSortMethod.None)
            {
                SnapshotComparer sc = new SnapshotComparer(sortMethod);
                snapshots.Sort(sc);
            }

            return new Snapshots(snapshots);
        }

        /// <summary>
        /// Asynchronously gets a list of snapshots defined for this Virtual Machine
        /// </summary>
        /// <param name="nameSpec">(Optional) A WQL-compliant name string to use to filter the snapshots. May contain the '%' wildcard character.</param>
        /// <param name="sortMethod">(Optional) One of the SnapshotSortMethod enumeration values specfying how the list should be sorted.</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate Snapshots AsyncGetSnapshotList(string nameSpec, SnapshotSortMethod sortMethod);
        private AsyncGetSnapshotList _getSnapshotListDelegate = null;
        public IAsyncResult BeginGetSnapshotList(AsyncCallback callback, object state) { return BeginGetSnapshotList(null, SnapshotSortMethod.None, callback, state); }
        public IAsyncResult BeginGetSnapshotList(string nameSpec, AsyncCallback callback, object state) { return BeginGetSnapshotList(nameSpec, SnapshotSortMethod.None, callback, state); }
        public IAsyncResult BeginGetSnapshotList(SnapshotSortMethod sortMethod, AsyncCallback callback, object state) { return BeginGetSnapshotList(null, sortMethod, callback, state); }
        public IAsyncResult BeginGetSnapshotList(string nameSpec, SnapshotSortMethod sortMethod, AsyncCallback callback, object state)
        {
            _getSnapshotListDelegate = new AsyncGetSnapshotList(GetSnapshotList);
            return _getSnapshotListDelegate.BeginInvoke(nameSpec, sortMethod, callback, state);
        }
        public Snapshots EndGetSnapshotList(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _getSnapshotListDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Starts the virtual machine
        /// </summary>
        /// <param name="waitForReady">flag indicating whether or not the method waits for the virtual machine to become responsive once started</param>
        /// <returns>true if the operation succeeded, false otherwise</returns>
        public bool Start(bool waitForReady)
        {
            bool success;
            success = WMI.InvokeMethod(
                WmiObj,
                "RequestStateChange",
                Timeout,
                new MethodParam("RequestedState", VMState.Enabled.ToString()));

            if (success && waitForReady)
            {
                WaitForHeartbeat();
            }

            // Refresh the underlying WMI object
            Refresh();

            return success;
        }

        /// <summary>
        /// Asychronously starts the virtual machine.
        /// </summary>
        /// <param name="waitForReady">Flag indicating whether or not the method waits for the virtual machine to become responsive once started</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncStart(bool waitForReady);
        private AsyncStart _startDelegate = null;
        public IAsyncResult BeginStart(bool waitForReady, AsyncCallback callback, object state)
        {
            _startDelegate = new AsyncStart(Start);
            return _startDelegate.BeginInvoke(waitForReady, callback, state);
        }
        public bool EndStart(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _startDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Turns off the virtual machine. This is different than Shutdown in that this is analagous to turning off the power switch on a physical server.
        /// </summary>
        /// <returns>true if the operation succeeded, false otherwise</returns>
        public bool TurnOff()
        {
            bool success = WMI.InvokeMethod(
                WmiObj,
                "RequestStateChange",
                Timeout,
                new MethodParam("RequestedState", VMState.Disabled.ToString()));
            Refresh();
            return success;
        }

        /// <summary>
        /// Asynchronously turns off a virtual machine
        /// </summary>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncTurnOff();
        private AsyncTurnOff _turnOffDelegate = null;
        public IAsyncResult BeginTurnOff(AsyncCallback callback, object state)
        {
            _turnOffDelegate = new AsyncTurnOff(TurnOff);
            return _turnOffDelegate.BeginInvoke(callback, state);
        }
        public bool EndTurnOff(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            if (null == _turnOffDelegate)
                throw new InvalidOperationException();
            return _turnOffDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Shuts down the virtual machine.
        /// </summary>
        /// <param name="allowMerge">Flag indicating whether or not to wait for Hyper-V to finish merging changes.</param>
        /// <param name="force">Flag indicating whether or not to force the virtual machine to shut down</param>
        /// <param name="reason">(Optional) A reason for the shutdown</param>
        /// <returns>true if the operation was successful, false otherwise</returns>
        public bool Shutdown(bool allowMerge, bool force) { return Shutdown(allowMerge, force, null); }
        public bool Shutdown(bool allowMerge, bool force, string reason)
        {
            // The Shutdown functionality is on the Msvm_ShutdownComponent object
            ManagementObject sc = GetRelatedObject("Msvm_ShutdownComponent");

            if (null == reason)
                reason = String.Empty;

            bool success = WMI.InvokeMethod(sc,
                "InitiateShutdown",
                Timeout,
                new MethodParam("Force", force.ToString()),
                new MethodParam("Reason", reason));

            // Hyper-V will start a merge job when the VM is shut down
            // Use the WaitForStateChange method to wait for the VM to be ready to continue
            WaitForStateChange(EnabledState.Disabled, allowMerge);

            // Refresh the underlying WMI object
            Refresh();

            return success;
        }

        /// <summary>
        /// Asynchronously shuts down a virtual machine
        /// </summary>
        /// <param name="reason">(Optional) A reason for the shutdown</param>
        /// <param name="allowMerge">Flag indicating whether or not to wait for Hyper-V to finish merging changes.</param>
        /// <param name="force">Flag indicating whether or not to force the virtual machine to shut down</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncShutdown(bool allowMerge, bool force, string reason);
        private AsyncShutdown _shutdownDelegate = null;
        public IAsyncResult BeginShutdown(bool allowMerge, bool force, AsyncCallback callback, object state) { return BeginShutdown(allowMerge, force, null, callback, state); }
        public IAsyncResult BeginShutdown(bool allowMerge, bool force, string reason, AsyncCallback callback, object state)
        {
            _shutdownDelegate = new AsyncShutdown(Shutdown);
            return _shutdownDelegate.BeginInvoke(allowMerge, force, reason, callback, state);
        }
        public bool EndShutdown(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _shutdownDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Reboots the virtual machine.
        /// </summary>
        /// <param name="allowMerge">Flag indicating whether or not to wait for Hyper-V to finish merging changes.</param>
        /// <param name="force">Flag indicating whether or not to force the virtual machine to shut down</param>
        /// <param name="waitForReady">Flag indicating whether or not the method waits for the virtual machine to become responsive once started</param>
        /// <param name="reason">(Optional) A reason for the reboot</param>
        /// <returns>true if the operation was successful, false otherwise</returns>
        public bool Reboot(bool allowMerge, bool force, bool waitForReady) { return Reboot(allowMerge, force, waitForReady, null); }
        public bool Reboot(bool allowMerge, bool force, bool waitForReady, string reason)
        {
            if (Shutdown(allowMerge, force, reason))
            {
                return Start(waitForReady);
            }

            return false;
        }

        /// <summary>
        /// Asynchronously reboots the virtual machine
        /// </summary>
        /// <param name="allowMerge">Flag indicating whether or not to wait for Hyper-V to finish merging changes.</param>
        /// <param name="force">Flag indicating whether or not to force the virtual machine to shut down</param>
        /// <param name="waitForReady">Flag indicating whether or not the method waits for the virtual machine to become responsive once started</param>
        /// <param name="reason">(Optional) A reason for the reboot</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncReboot(bool allowMerge, bool force, bool waitForReady, string reason);
        private AsyncReboot _rebootDelegate = null;
        public IAsyncResult BeginReboot(bool allowMerge, bool force, bool waitForReady, AsyncCallback callback, object state) { return BeginReboot(allowMerge, force, waitForReady, null, callback, state); }
        public IAsyncResult BeginReboot(bool allowMerge, bool force, bool waitForReady, string reason, AsyncCallback callback, object state)
        {
            _rebootDelegate = new AsyncReboot(Reboot);
            return _rebootDelegate.BeginInvoke(allowMerge, force, waitForReady, reason, callback, state);
        }
        public bool EndReboot(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            if (null == _rebootDelegate)
                throw new InvalidOperationException();
            return _rebootDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Pauses a virtual machine. The virtual machine must be running.
        /// </summary>
        /// <returns>true if the operation was successful, false otherwise</returns>
        public bool Pause()
        {
            bool success = WMI.InvokeMethod(
                WmiObj,
                "RequestStateChange",
                Timeout,
                new MethodParam("RequestedState", VMState.Paused.ToString()));
            Refresh();
            return success;
        }

        /// <summary>
        /// Asynchronously pauses the virtual machine
        /// </summary>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate bool AsyncPause();
        private AsyncPause _pauseDelegate = null;
        public IAsyncResult BeginPause(AsyncCallback callback, object state)
        {
            _pauseDelegate = new AsyncPause(Pause);
            return _pauseDelegate.BeginInvoke(callback, state);
        }
        public bool EndPause(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            if (null == _pauseDelegate)
                throw new InvalidOperationException();
            return _pauseDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Creating a snapshot with a specific name is a two step process:
        /// 1. Create the snapshot
        /// 2. Rename the new snapshot
        /// </summary>
        /// <param name="snapshotName">The name of the new snapshot</param>
        /// <returns>A Snapshot object representing the new snapshot</returns>
        public Snapshot CreateSnapshot(string snapshotName)
        {
            // Snapshot functionality is exposed from the Msvm_VirtualSystemManagementService object
            ManagementObject vsms = GetVirtualSystemManagementService();
            Snapshot newSnapshot = null;

            // Create the snapshot
            bool success = WMI.InvokeMethod(vsms,
                "CreateVirtualSystemSnapshot",
                Timeout,
                new MethodParam("SourceSystem", Path));

            if (success)
            {
                // Now that the snapshot is created, use the GetRelated method to retrieve it
                newSnapshot = new Snapshot(GetRelatedObject("Msvm_VirtualSystemSettingData", "Msvm_PreviousSettingData"), this);
                newSnapshot.Rename(snapshotName);
            }

            // Refresh the underlying WMI object
            Refresh();

            return newSnapshot;
        }

        /// <summary>
        /// Asynchronously creates a new snapshot for the virtual machine.
        /// </summary>
        /// <param name="snapshotName">The name of the new snapshot.</param>
        /// <param name="callback">(Optional) The method to call when the operation is complete</param>
        /// <param name="state">
        ///     (Optional) A user-defined object that contains information about the operation.
        ///     This object is passed to the requestCallback delegate when the operation is complete.</param>
        /// <returns>An IAsyncResult instance that references the asynchronous request.</returns>
        private delegate Snapshot AsyncCreateSnapshot(string snapshotName);
        private AsyncCreateSnapshot _createSnapshotDelegate = null;
        public IAsyncResult BeginCreateSnapshot(string snapshotName, AsyncCallback callback, object state)
        {
            _createSnapshotDelegate = new AsyncCreateSnapshot(CreateSnapshot);
            return _createSnapshotDelegate.BeginInvoke(snapshotName, callback, state);
        }
        public Snapshot EndCreateSnapshot(IAsyncResult result)
        {
            if (null == result)
                throw new ArgumentNullException();
            return _createSnapshotDelegate.EndInvoke(result);
        }

        /// <summary>
        /// Waits for the Virtual Machine to enter the desired state. This will optionally wait for
        /// any asynchronous jobs to complete before returning. If the Virtual Machine takes longer
        /// to reach the desired state than the Timeout property specifies, a VMTimeoutException is raised.
        /// </summary>
        /// <param name="desiredState">An EnabledState enum value specifying the target state of the VM.</param>
        /// <param name="waitForJobCompletion">(Optional) A flag indicating whether or not to wait for any cancellable jobs to complete. Defaults to false.</param>
        public void WaitForStateChange(EnabledState desiredState) { WaitForStateChange(desiredState, false); }
        public void WaitForStateChange(EnabledState desiredState, bool waitForJobCompletion)
        {
            int waitTime = 0;
            while (true)
            {
                if (EnabledState == desiredState)
                {
                    // If waitForJobCompletion is true, check the Operational Status
                    if (waitForJobCompletion && OperationalStatus.Ok == Status)
                        break;
                }

                if (waitTime > Timeout)
                    throw new VMTimeoutException(String.Format("The timeout of {0} seconds expired waiting for the VM to change state.", Timeout));

                System.Threading.Thread.Sleep(1000);
                waitTime++;
                Refresh();
            }
        }

        /// <summary>
        /// Waits for the VM to come off of one of the transition states:
        ///     Starting
        ///     Stopping
        ///     Pausing
        ///     Resuming
        ///     Saving
        ///     Snapshotting
        /// </summary>
        public void WaitForTransition()
        {
            EnabledState currentState = EnabledState;
            // If the current state is not one of the transition states, bail now to avoid the infinite loop
            if (this.EnabledState == EnabledState.Disabled ||
                this.EnabledState == EnabledState.Enabled ||
                this.EnabledState == EnabledState.Paused ||
                this.EnabledState == EnabledState.Saved)
                return;

            int waitTime = 0;
            while (this.EnabledState == currentState)
            {
                if (waitTime > Timeout)
                {
                    throw new VMTimeoutException(String.Format("The timeout of {0} seconds expired waiting for the VM to transition off the {1} state.",
                        Timeout, currentState));
                }

                System.Threading.Thread.Sleep(1000);
                waitTime++;
                Refresh();
            }
        }

        /// <summary>
        /// Waits for the VM to be ready to use. This is done by waiting for the VM's boot sequence to load the Hyper-V
        /// Heartbeat component. This is a good indication that the server is ready to use.
        /// </summary>
        public void WaitForHeartbeat()
        {
            int waitTime = 0;
            UInt16 status = HeartbeatStatus.NoContact;
            do
            {
                if (waitTime > Timeout)
                    throw new VMTimeoutException(String.Format("The timeout of {0} seconds expired waiting for the heartbeat.", Timeout));

                ManagementObject hc = GetRelatedObject("Msvm_HeartbeatComponent");
                status = (UInt16)(hc["OperationalStatus"] as Array).GetValue(0);
                System.Threading.Thread.Sleep(1000);
                waitTime++;
            } while (HeartbeatStatus.Ok != status);
        }

        #endregion
    }

    public class VirtualMachines : Collection<VirtualMachine>
    {
        public VirtualMachines() : base() { }
        public VirtualMachines(IList<VirtualMachine> list) : base(list) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\IConditionalTimer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    public delegate bool Condition();

    public interface IConditionalTimer
    {
        Condition Condition
        {
            get;
            set;
        }

        bool TimerStarted
        {
            get;
        }

        event Action OnCondition;
        void StartTimer();
        void StopTimer();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\ConditionalTimer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Timers;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    class ConditionalTimer : IConditionalTimer
    {
        Timer _timer;

        public ConditionalTimer()
            : this(TimeSpan.FromSeconds(1))
        {
        }

        public ConditionalTimer(TimeSpan delta)
        {
            _timer = new Timer(delta.TotalMilliseconds);
        }

        public Condition Condition
        {
            get;
            set;
        }

        public bool TimerStarted
        {
            get { return _timer.Enabled; }
        }

        public event Action OnCondition;

        public void StartTimer()
        {
            _timer.AutoReset = true;
            _timer.Elapsed += new ElapsedEventHandler(_timer_Elapsed);
            _timer.Start();
        }

        public void StopTimer()
        {
            _timer.Stop();
        }

        void _timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            if (Condition())
            {
                if (OnCondition != null)
                {
                    OnCondition();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\IProcessWrapper.cs ===
﻿using System;
namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    public interface IProcessWrapper
    {
        bool HasExited { get; }
        void Start();
        System.Diagnostics.ProcessStartInfo StartInfo { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\IWttStfPreparer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    public interface IWttStfPreparer
    {
        IProcessWrapper PrepareSyncroneousWttStfCall(TestDescription stfSuite, string stfFrequency, string network, int daysTimeout);
        IProcessWrapper PrepareCancelAllCurrentOperationsOnWttClient(string client);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\ILogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    public interface ILogger
    {
        void LogEvent(string eventSource, LoggingLevel level, string format, params object[] args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\ITestListParser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    public interface ITestListParser
    {
        IEnumerable<TestDescription> ParseTestList(string testList);
        IEnumerable<TestDescription> ParseFileToList(string path);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\ILogRetriever.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    public interface ILogRetriever
    {
        IEnumerable<Log> GetLogs(string path, string searchPattern);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\LogRetriever.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    class LogRetriever : ILogRetriever
    {
        public IEnumerable<Log> GetLogs(string path, string searchPattern)
        {
            string[] files = new string[0];

            if (Directory.Exists(path))
            {
                files = Directory.GetFiles(path, searchPattern, SearchOption.AllDirectories);
            }

            return Array.ConvertAll(files,
                new Converter<string, Log>(
                    delegate(string fileFullPath)
                    {
                        Log l = new Log();
                        l.Path = Path.GetDirectoryName(fileFullPath);
                        l.FileName = Path.GetFileName(fileFullPath);
                        return l;
                    }));                                        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMTaskModule\VMTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management;
using System.Reflection;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Schema;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.vmtaskmodule
{
    public static class VMState
    {
        public const UInt16 Enabled = 2;
        public const UInt16 Disabled = 3;
        public const UInt16 Paused = 32768;
        public const UInt16 Suspended = 32769;
        public const UInt16 Starting = 32770;
        public const UInt16 Snapshotting = 32771;
        public const UInt16 Saving = 32773;
        public const UInt16 Stopping = 32774;
        public const UInt16 Pausing = 32776;
        public const UInt16 Resuming = 32777;
    }

    public static class HeartbeatStatus
    {
        public const UInt16 Ok = 2;
        public const UInt16 Error = 6;
        public const UInt16 NoContact = 12;
        public const UInt16 LostCommunication = 16;
    }

    public class VMTimeoutException : Exception
    {
        public VMTimeoutException() : base() { }
        public VMTimeoutException(string message) : base(message) { }
        public VMTimeoutException(string message, Exception innerException) : base(message, innerException) { }
    }

    public class VMTaskModuleBase : ITaskModule
    {
        public const int DEFAULT_TIMEOUT = 1800;  // 30 minute default timeout (seconds)

        protected TaskModuleInfo _info;
        protected Dictionary<string, string> _parameters;
        protected TaskResult _result;
        protected string _hostName;

        // This base class cannot be instantiated directly
        protected VMTaskModuleBase()
        {
            _result = new TaskResult();
        }

        public TaskResult Result
        {
            get { return _result; }
        }

        #region ITaskModule Implementation

        public TaskModuleInfo Info
        {
            get
            {
                if (null == _info)
                    throw new ApplicationException("A derived VM class did not create the TaskModuleInfo object.");
                return _info;
            }
        }

        public virtual void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public virtual void AddParameters(string xmlParameterBlock) { }

        public virtual void RemoveAllParameters()
        {
            throw new NotImplementedException();
        }

        public virtual TaskResult Perform()
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Base Virtual Machine Methods

        protected ManagementObject FindVM(string hostName, string vmName)
        {
            return FindVM(hostName, vmName, null, null);
        }
        protected ManagementObject FindVM(string hostName, string vmName, string userName, string password)
        {
            return FindVM(WMI.ConnectToHost(hostName, "Virtualization", userName, password), vmName);
        }
        protected ManagementObject FindVM(ManagementScope scope, string vmName)
        {
            return (WMI.QuerySingleObject(scope,
                String.Format("SELECT * FROM Msvm_ComputerSystem WHERE ElementName = '{0}'", vmName)));
        }

        protected List<ManagementObject> FindVMs(List<string> hosts, string vmName)
        {
            return FindVMs(hosts, vmName, null, null, null);
        }
        protected List<ManagementObject> FindVMs(List<string> hosts, string vmName, List<string> ignoreList, string userName, string password)
        {
            List<ManagementObject> vms = new List<ManagementObject>();
            foreach (string host in hosts)
            {
                StringBuilder query = new StringBuilder();
                ManagementScope scope = WMI.ConnectToHost(host, "Virtualization", userName, password);
                if (scope != null)
                {
                    // Build the query
                    query.AppendFormat("SELECT * FROM Msvm_ComputerSystem WHERE ElementName LIKE '{0}'", vmName);

                    // Add the entries from the ignore VM list
                    if (null != ignoreList)
                    {
                        foreach (string ignoreVM in ignoreList)
                        {
                            if (!String.IsNullOrEmpty(ignoreVM))
                                query.AppendFormat(" AND (NOT ElementName LIKE '{0}')", ignoreVM);
                        }
                    }

                    // Run the query
                    ManagementObjectCollection objList = WMI.QueryObjects(scope, query.ToString());
                    foreach (ManagementObject obj in objList)
                    {
                        vms.Add(obj);
                    }
                }
            }
            return vms;
        }

        protected List<ManagementObject> GetVMSnapshots(ManagementObject vm)
        {
            List<ManagementObject> snapshots = new List<ManagementObject>();
            ManagementObjectCollection objList = vm.GetRelated("Msvm_VirtualSystemSettingData");
            foreach (ManagementObject obj in objList)
            {
                if (5 == ((UInt16)obj["SettingType"]))
                {
                    snapshots.Add(obj);
                }
            }

            return snapshots;
        }

        protected bool StartVM(ManagementObject vm)
        {
            bool success = true;
            try
            {
                if (!WMI.InvokeMethod(vm, "RequestStateChange", DEFAULT_TIMEOUT, new MethodParam("RequestedState", ((ushort)VMState.Enabled).ToString())))
                {
                    _result.AddLog(new Log("Unable to start '{0}'", (string)vm["ElementName"]));
                    success = false;
                }
            }
            catch (WMIExecuteException ex)
            {
                success = false;
                _result.AddLog(new Log(ex.ToString()));
            }

            return success;
        }

        protected bool ShutdownVM(ManagementObject vm, bool force, string reason)
        {
            bool success = true;

            // Only try to shut down if the VM is running
            if (VMState.Enabled == (UInt16)vm["EnabledState"])
            {
                ManagementObject sc = WMI.QuerySingleObject(vm.Scope, "SELECT * FROM Msvm_ShutdownComponent WHERE SystemName='" + vm["Name"].ToString() + "'");
                try
                {
                    if (!WMI.InvokeMethod(sc, "InitiateShutdown", DEFAULT_TIMEOUT, new MethodParam("Force", force.ToString()), new MethodParam("Reason", reason)))
                    {
                        _result.AddLog(new Log("Unable to shut down '{0}'.", vm["ElementName"]));
                        success = false;
                    }
                }
                catch (WMIExecuteException ex)
                {
                    success = false;
                    _result.AddLog(new Log(ex.ToString()));
                }
            }

            return success;
        }

        protected void WaitForReady(ManagementObject vm, int timeout)
        {
            int waitTime = 0;
            UInt16 status = HeartbeatStatus.NoContact;
            do
            {
                if (waitTime > timeout)
                    throw new VMTimeoutException(String.Format("The timeout of {0} seconds expired waiting for the heartbeat.", timeout));

                ManagementObjectCollection objs = vm.GetRelated("Msvm_HeartbeatComponent");
                foreach (ManagementObject obj in objs)
                {
                    status = (UInt16)(obj["OperationalStatus"] as Array).GetValue(0);
                }
                System.Threading.Thread.Sleep(1000);
                waitTime++;
            } while (HeartbeatStatus.Ok != status);
        }

        protected void WaitForStateChange(ManagementObject vm, UInt16 desiredState, int timeout)
        {
            int waitTime = 0;
            UInt16 currentState = (UInt16)vm["EnabledState"];
            while (currentState != desiredState)
            {
                if (waitTime > timeout)
                    throw new VMTimeoutException(String.Format("The timeout of {0} seconds expired waiting for the VM to change state.", timeout));

                System.Threading.Thread.Sleep(1000);
                waitTime++;
                vm = FindVM(vm.Scope, (string)vm["ElementName"]);
                currentState = (UInt16)vm["EnabledState"];
            }
        }

        #endregion

        #region Process Methods

        protected bool KillProcess(ManagementScope scope, UInt32 processId)
        {
            bool success = false;
            ManagementObject process = WMI.QuerySingleObject(scope, String.Format("Select * from Win32_Process where ProcessId = {0}", processId));
            if (process != null)
            {
                try
                {
                    success = WMI.InvokeMethod(process, "Terminate", DEFAULT_TIMEOUT, new MethodParam("Reason", "1"));
                }
                catch (WMIExecuteException ex)
                {
                    success = false;
                    _result.AddLog(new Log(ex.ToString()));
                }
            }

            return success;
        }

        #endregion
    }

    [DeploymentTaskModule("VMGeneralModule")]
    public class VMGeneralModule : VMTaskModuleBase
    {
        private const string ActionParameter = "action";
        private const string MachineNameParameter = "machinename";
        private const string VMNameParameter = "vmname";
        private const string ForceParameter = "force";
        private const string ActionDataParameter = "actiondata";

        public VMGeneralModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "VMGeneralModule";
            _info.Description = "Provides general Virtual Machine management functions using Hyper-V.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Action", "The action to perform on the VM. Valid values are START, SHUTDOWN, and REBOOT"),
                new ParameterDescriptor("MachineName", "The name of the machine that is hosting the virtual machine."),
                new ParameterDescriptor("VMName", "The name of the virtual machine on which to perform the action."),
                new ParameterDescriptor("Force", "[OPTIONAL] Flag indicating that the desired action should be forced, no matter the current state of the VM. Default is FALSE."),
                new ParameterDescriptor("ActionData", "[OPTIONAL] Action-specific data. START & REBOOT : Number of seconds to wait for the VM to become responsive; SHUTDOWN : Reason for shutting down.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(ActionParameter, "");
            _parameters.Add(MachineNameParameter, "");
            _parameters.Add(VMNameParameter, "");
            _parameters.Add(ForceParameter, "false");
            _parameters.Add(ActionDataParameter, "");
        }

        public override void RemoveAllParameters()
        {
            _parameters[ActionParameter] = "";
            _parameters[MachineNameParameter] = "";
            _parameters[VMNameParameter] = "";
            _parameters[ForceParameter] = "false";
            _parameters[ActionDataParameter] = "";
        }

        public override TaskResult Perform()
        {
            bool force = false;

            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (String.IsNullOrEmpty(_parameters[ActionParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("VMGeneralModule : The 'Action' parameter is required but was not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[MachineNameParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("VMGeneralModule : The 'MachineName' parameter is required but was not specified."));
            }
            if (String.IsNullOrEmpty(_parameters[VMNameParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("VMGeneralModule : The 'VMName' parameter is required but was not specified."));
            }

            Boolean.TryParse(_parameters[ForceParameter], out force);

            // Find the VM on the host machine
            ManagementObject vm = null;
            try
            {
                vm = FindVM(_parameters[MachineNameParameter], _parameters[VMNameParameter]);
            }
            catch (Exception ex)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("An error occurred searching for the vm '{0}' on '{1}'.\r\n{2}",
                    _parameters[VMNameParameter], _parameters[MachineNameParameter], ex));
                return _result;
            }
            if (null == vm)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("Unable to find the vm '{0}' on '{1}'.",
                    _parameters[VMNameParameter], _parameters[MachineNameParameter]));
                return _result;
            }

            switch (_parameters[ActionParameter].ToLower())
            {
                case "start":
                    {
                        int timeout;
                        if (!Int32.TryParse(_parameters[ActionDataParameter], out timeout))
                        {
                            _result.AddLog(new Log("Start VM: Invalid timeout value - the default of 300 seconds will be used."));
                            timeout = 300;
                        }

                        StartVirtualMachine(vm, timeout);
                    }
                    break;
                case "shutdown":
                    ShutdownVirtualMachine(vm, _parameters[ActionDataParameter], force);
                    break;
                case "reboot":
                    {
                        int timeout;
                        if (!Int32.TryParse(_parameters[ActionDataParameter], out timeout))
                        {
                            _result.AddLog(new Log("Reboot VM: Invalid timeout value - the default of 300 seconds will be used."));
                            timeout = 300;
                        }

                        RebootVirtualMachine(vm, timeout, force);
                    }
                    break;
                default:
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("Unsupported 'Action' parameter value : '{0}'",
                        _parameters[ActionParameter]));
                    break;
            }

            return _result;
        }

        public void StartVirtualMachine(ManagementObject vm, int timeout)
        {
            _result.ExecutedSuccessfully = StartVM(vm);
            if (_result.ExecutedSuccessfully && timeout > 0)
            {
                // Monitor the heartbeat to determine when the system has come back up
                try
                {
                    WaitForReady(vm, timeout);
                }
                catch (VMTimeoutException)
                {
                    _result.AddLog(new Log("StartVirtualMachine: The timeout of {0} seconds expired waiting for the virtual machine '{1}' to start.",
                        timeout, vm["ElementName"]));
                }
            }
        }

        public void ShutdownVirtualMachine(ManagementObject vm, string reason, bool force)
        {
            _result.ExecutedSuccessfully = ShutdownVM(vm, force, reason);
            if (_result.ExecutedSuccessfully)
            {
                // Wait up to 5 minutes for the VM to shut down
                try
                {
                    WaitForStateChange(vm, VMState.Disabled, 300);
                }
                catch (VMTimeoutException)
                {
                    _result.AddLog(new Log("ShutdownVirtualMachine: The virtual machine '{0}' did not reach the 'Stopped' state within 5 minutes.",
                        vm["ElementName"]));
                }
            }
        }

        public void RebootVirtualMachine(ManagementObject vm, int timeout, bool force)
        {
            _result.ExecutedSuccessfully = ShutdownVM(vm, true, "Reboot requested");
            if (_result.ExecutedSuccessfully)
            {
                // Wait up to 5 minutes for the VM to shut down
                try
                {
                    WaitForStateChange(vm, VMState.Disabled, 300);
                }
                catch (VMTimeoutException)
                {
                    _result.AddLog(new Log("RebootVirtualMachine: The virtual machine '{0}' did not reach the 'Stopped' state within 5 minutes.",
                        vm["ElementName"]));
                }

                // Restart the VM
                vm = new ManagementObject(vm.Scope, vm.Path, null);
                //vm = FindVM(_parameters[MachineNameParameter], _parameters[VMNameParameter]);
                _result.ExecutedSuccessfully = StartVM(vm);
                if (_result.ExecutedSuccessfully)
                {
                    // Monitor the heartbeat to determine when the system has come back up
                    try
                    {
                        WaitForReady(vm, timeout);
                    }
                    catch (VMTimeoutException)
                    {
                        _result.AddLog(new Log("RebootVirtualMachine: The timeout of {0} seconds expired waiting for the virtual machine '{1}' to start.",
                            timeout, vm["ElementName"]));
                    }
                }
            }
        }
    }

    [DeploymentTaskModule("VMSnapshotModule")]
    public class VMSnapshotModule : VMTaskModuleBase
    {
        private const string ActionParameter = "action";
        private const string MachineNameParameter = "machinename";
        private const string VMNameParameter = "vmname";
        private const string SnapshotNameParameter = "snapshotname";
        private const string NewSnapshotNameParameter = "newsnapshotname";
        private const string ForceParameter = "force";

        public VMSnapshotModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "VMSnapshotModule";
            _info.Description = "Manages virtual machine snapshots using Hyper-V.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Action", "The Snaphot action to perform on the VM. Valid values are CREATE, DELETE, APPLY, RENAME, and COLLAPSE"),
                new ParameterDescriptor("MachineName", "The name of the machine that is hosting the virtual machine."),
                new ParameterDescriptor("VMName", "The name of the virtual machine on which to perform the action."),
                new ParameterDescriptor("SnapshotName", "The name of the snapshot."),
                new ParameterDescriptor("NewSnapshotName", "The new name of the snapshot (used with the RENAME action only)."),
                new ParameterDescriptor("Force", "Flag indicating whether to force the virtual machine into the desired state for the action. Specify TRUE or FALSE. Defaults to FALSE.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(ActionParameter, "");
            _parameters.Add(MachineNameParameter, "");
            _parameters.Add(VMNameParameter, "");
            _parameters.Add(SnapshotNameParameter, "");
            _parameters.Add(NewSnapshotNameParameter, "");
            _parameters.Add(ForceParameter, "");
        }

        public override void RemoveAllParameters()
        {
            _parameters[ActionParameter] = "";
            _parameters[MachineNameParameter] = "";
            _parameters[VMNameParameter] = "";
            _parameters[SnapshotNameParameter] = "";
            _parameters[NewSnapshotNameParameter] = "";
            _parameters[ForceParameter] = "";
        }

        public override TaskResult Perform()
        {
            bool force = false;

            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the parameters
            if (String.IsNullOrEmpty(_parameters[MachineNameParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'MachineName' parameter is invalid."));
            }
            if (String.IsNullOrEmpty(_parameters[VMNameParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'VMName' parameter is invalid."));
            }
            if (String.IsNullOrEmpty(_parameters[SnapshotNameParameter]))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'SnapshotName' parameter is invalid."));
            }
            if (!String.IsNullOrEmpty(_parameters[ForceParameter]) &&
                !Boolean.TryParse(_parameters[ForceParameter], out force))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("Unsupported 'Force' parameter value: '{0}'", _parameters[ForceParameter]));
            }

            // If the parameters are all valid, perform the task
            if (_result.ExecutedSuccessfully)
            {
                // Find the VM on the host machine
                ManagementObject vm = null;
                try
                {
                    vm = FindVM(_parameters[MachineNameParameter], _parameters[VMNameParameter]);
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("An error occurred searching for the vm '{0}' on '{1}'.\r\n{2}",
                        _parameters[VMNameParameter], _parameters[MachineNameParameter], ex));
                    vm = null;
                }
                if (null != vm)
                {
                    // Perform the snapshot action
                    switch (_parameters[ActionParameter].ToLower())
                    {
                        case "create":
                            _result.ExecutedSuccessfully = CreateSnapshot(vm, _parameters[SnapshotNameParameter], force);
                            break;
                        case "apply":
                            _result.ExecutedSuccessfully = ApplySnapshot(vm, _parameters[SnapshotNameParameter], force);
                            break;
                        case "delete":
                            _result.ExecutedSuccessfully = DeleteSnapshot(vm, _parameters[SnapshotNameParameter], force);
                            break;
                        case "rename":
                            if (!String.IsNullOrEmpty(_parameters[NewSnapshotNameParameter]))
                            {
                                _result.ExecutedSuccessfully = RenameSnapshot(vm, _parameters[SnapshotNameParameter], _parameters[NewSnapshotNameParameter]);
                            }
                            else
                            {
                                _result.ExecutedSuccessfully = false;
                                _result.AddLog(new Log("The 'NewSnapshotName' parameter is invalid."));
                            }
                            break;
                        default:
                            _result.ExecutedSuccessfully = false;
                            _result.AddLog(new Log("Unsupported 'Action' parameter value : '{0}'",
                                _parameters[ActionParameter]));
                            break;
                    }
                }
                else
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("Unable to find the vm '{0}' on '{1}'.",
                        _parameters[VMNameParameter], _parameters[MachineNameParameter]));
                }
            }

            return _result;
        }

        public bool CreateSnapshot(ManagementObject vm, string snapshotName, bool force)
        {
            bool success = true;
            bool timeout = false;
            ManagementObject vsms = WMI.GetServiceObject(vm.Scope, "Msvm_VirtualSystemManagementService");

            try
            {
                success = WMI.InvokeMethod(vsms, "CreateVirtualSystemSnapshot", DEFAULT_TIMEOUT, new MethodParam("SourceSystem", vm.Path.Path));
            }
            catch (VMTimeoutException)
            {
                timeout = true;
            }
            catch (WMIExecuteException ex)
            {
                _result.AddLog(new Log(ex.ToString()));
                success = false;
            }

            // If the creation times out, we likely have a stuck VM worker process.
            if (timeout)
            {
                // Get the PID of the worker process that is associated with the stuck VM, then kill that process
                UInt32 pid = (UInt32)vm["ProcessId"];
                ManagementScope scope = WMI.ConnectToHost(vm.Scope, "cimv2");
                KillProcess(scope, pid);

                // Now we wait for the VM to become resposive and try to take the snapshot again
                WaitForStateChange(vm, VMState.Enabled, DEFAULT_TIMEOUT);
                try
                {
                    success = WMI.InvokeMethod(vsms, "CreateVirtualSystemSnapshot", DEFAULT_TIMEOUT, new MethodParam("SourceSystem", vm.Path.Path));
                }
                catch (WMIExecuteException ex)
                {
                    success = false;
                    _result.AddLog(new Log(ex.ToString()));
                }
            }

            if (success)
            {
                // Now that the snapshot was created, try renaming it.
                // Note that the 'SnapshotSettingData' out parameter is almost always null
                // so we need to find the data via some other means.
                ManagementObject snapshot = GetLatestSnapshot(vm);
                if (snapshot != null)
                {
                    snapshot["ElementName"] = snapshotName;
                    try
                    {
                        success = WMI.InvokeMethod(vsms, "ModifyVirtualSystem", DEFAULT_TIMEOUT, new MethodParam("ComputerSystem", vm.Path.Path),
                            new MethodParam("SystemSettingData", snapshot.GetText(TextFormat.WmiDtd20)));
                    }
                    catch (WMIExecuteException ex)
                    {
                        success = false;
                        _result.AddLog(new Log(ex.ToString()));
                    }

                    if (!success)
                    {
                        _result.AddLog(new Log("The snapshot was created, but could not be renamed."));
                    }
                }
                else
                {
                    _result.AddLog(new Log("The snapshot was created, but Hyper-V failed to find it, therefore it could not be given the specified name."));
                    success = false;
                }
            }

            return success;
        }

        public bool RenameSnapshot(ManagementObject vm, string snapshotName, string newName)
        {
            bool success = true;
            ManagementObject snapshot = GetSnapshot(vm, snapshotName);
            if (null != snapshot)
            {
                ManagementObject vsms = WMI.GetServiceObject(vm.Scope, "Msvm_VirtualSystemManagementService");

                snapshot["ElementName"] = newName;
                try
                {
                    success = WMI.InvokeMethod(vsms, "ModifyVirtualSystem", DEFAULT_TIMEOUT, new MethodParam("ComputerSystem", vm.Path.Path),
                        new MethodParam("SystemSettingData", snapshot.GetText(TextFormat.WmiDtd20)));
                }
                catch (WMIExecuteException ex)
                {
                    success = false;
                    _result.AddLog(new Log(ex.ToString()));
                }

                if (!success)
                {
                    _result.AddLog(new Log("The snapshot '{0}' could not be renamed.", snapshotName));
                }
            }
            else
            {
                success = false;
                _result.AddLog(new Log("Unable to locate the snapshot '{0}'.", snapshotName));
            }

            return success;
        }

        public bool ApplySnapshot(ManagementObject vm, string snapshotName, bool force)
        {
            bool success = true;
            ManagementObject snapshot = GetSnapshot(vm, snapshotName);
            if (null != snapshot)
            {
                ManagementObject vsms = WMI.GetServiceObject(vm.Scope, "Msvm_VirtualSystemManagementService");

                // The virtual machine must be stopped in order to apply the snapshot.
                if ((UInt16)vm["EnabledState"] != VMState.Disabled)
                {
                    if (force)
                    {
                        DACommon.LogEvent(LoggingLevel.Debug, "ApplySnapshot : Stopping {0}.", vm["ElementName"]);
                        success = ShutdownVM(vm, force, "Applying snapshot");
                        if (success)
                        {
                            // Wait for the VM to report that it has been shut down
                            try
                            {
                                WaitForStateChange(vm, VMState.Disabled, 300);
                            }
                            catch (VMTimeoutException)
                            {
                                _result.AddLog(new Log("ApplySnapshot: The virtual machine '{0}' did not reach the 'Stopped' state within 5 minutes.",
                                    vm["ElementName"]));
                            }
                        }
                        else
                        {
                            _result.AddLog(new Log("Unable to force the virtual machine into the 'Stopped' state. The snapshot cannot be applied."));
                        }
                    }
                    else
                    {
                        success = false;
                        _result.AddLog(new Log("A snapshot cannot be applied to a virtual machine that is not stopped. Specify the 'Force' parameter to automatically stop the virtual machine prior to applying the snapshot."));
                    }
                }

                if (success)
                {
                    DACommon.LogEvent(LoggingLevel.Debug, "ApplySnapshot : Applying the '{0}' snapshot to {1}.", snapshot["ElementName"], vm["ElementName"]);
                    try
                    {
                        success = WMI.InvokeMethod(vsms, "ApplyVirtualSystemSnapshot", DEFAULT_TIMEOUT, new MethodParam("ComputerSystem", vm.Path.Path),
                            new MethodParam("SnapshotSettingData", snapshot.Path.Path));
                    }
                    catch (WMIExecuteException ex)
                    {
                        success = false;
                        _result.AddLog(new Log(ex.ToString()));
                    }

                    if (success)
                    {
                        // Restart the VM
                        DACommon.LogEvent(LoggingLevel.Debug, "Restarting {0}.", vm["ElementName"]);
                        vm = FindVM(vm.Scope, (string)vm["ElementName"]);
                        success = StartVM(vm);
                        if (success)
                        {
                            // Wait for the VM to become responsive again
                            try
                            {
                                WaitForReady(vm, 300);
                            }
                            catch (VMTimeoutException)
                            {
                                _result.AddLog(new Log("ApplyAnapshot: The 5 minute timeout expired waiting for the vm to become responsive again."));
                            }
                        }
                        else
                        {
                            _result.AddLog(new Log("Unable to restart the virtual machine after applying the snapshot '{0}'", snapshotName));
                        }
                    }
                }
            }
            else
            {
                success = false;
                _result.AddLog(new Log("Unable to locate the snapshot '{0}' on {1}.", snapshotName, vm["ElementName"]));
            }

            return success;
        }

        public bool DeleteSnapshot(ManagementObject vm, string snapshotName, bool force)
        {
            return DeleteSnapshot(vm, snapshotName, force, false);
        }

        public bool DeleteSnapshot(ManagementObject vm, string snapshotName, bool force, bool delTree)
        {
            bool success = true;
            ManagementObject snapshot = GetSnapshot(vm, snapshotName);
            if (null != snapshot)
            {
                ManagementObject vsms = WMI.GetServiceObject(vm.Scope, "Msvm_VirtualSystemManagementService");
                try
                {
                    if (delTree)
                        success = WMI.InvokeMethod(vsms, "RemoveVirtualSystemSnapshotTree", DEFAULT_TIMEOUT, new MethodParam("SnapshotSettingData", snapshot.Path.Path));
                    else
                        success = WMI.InvokeMethod(vsms, "RemoveVirtualSystemSnapshot", DEFAULT_TIMEOUT, new MethodParam("SnapshotSettingData", snapshot.Path.Path));
                }
                catch (WMIExecuteException ex)
                {
                    success = false;
                    _result.AddLog(new Log(ex.ToString()));
                }
            }
            else
            {
                _result.AddLog(new Log("Unable to locate the snapshot '{0}'.", snapshotName));
            }

            return success;
        }

        private ManagementObject GetLatestSnapshot(ManagementObject vm)
        {
            ManagementObjectCollection settings = vm.GetRelated(
                "msvm_VirtualSystemSettingData",
                "msvm_PreviousSettingData",
                null,
                null,
                "SettingData",
                "ManagedElement",
                false,
                null);
            ManagementObject vss = null;
            foreach (ManagementObject setting in settings)
            {
                vss = setting;
            }

            return vss;
        }

        private ManagementObject GetSnapshot(ManagementObject vm, string snapshotName)
        {
            ManagementObject snapshot = null;
            string srchName = null;
            bool exactMatch = true;

            if (snapshotName.Contains('%'))
            {
                // Perform a Contains search
                srchName = snapshotName.Replace("%", "").ToLower();
                exactMatch = false;
            }

            ManagementObjectCollection settings = vm.GetRelated("Msvm_VirtualSystemSettingData");
            foreach (ManagementObject setting in settings)
            {
                if (exactMatch)
                {
                    if (String.Compare(snapshotName, (string)setting["ElementName"], true) == 0)
                    {
                        // Found it - break the loop
                        snapshot = setting;
                        break;
                    }
                }
                else
                {
                    string elementName = ((string)setting["ElementName"]).ToLower();
                    if (elementName.Contains(srchName))
                    {
                        // Found it - break the loop
                        snapshot = setting;
                        break;
                    }
                }
            }

            return snapshot;
        }
    }

    [DeploymentTaskModule("AsyncVMGeneralModule")]
    public class AsyncVMGeneralModule : VMTaskModuleBase
    {
        private const string ActionParameter = "action";
        private const string HostListParameter = "hostlist";
        private const string VMNameParameter = "vmnamespec";
        private const string IgnoreVMList = "ignorevmlist";
        private const string ForceParameter = "force";
        private const string ActionDataParameter = "actiondata";
        private const string UserNameParameter = "username";
        private const string PasswordParameter = "password";
        private const string PasswordEncryptedParameter = "passwordencrypted";

        public AsyncVMGeneralModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "AsyncVMGeneralModule";
            _info.Description = "Provides asnychronous management of multiple virtual machines.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Action", "The action to perform on the VMs. Valid values are START, SHUTDOWN, and REBOOT."),
                new ParameterDescriptor("HostList", "A comma-separated list of Hyper-V host servers."),
                new ParameterDescriptor("VMNameSpec", "A WQL-compliant string used to match Virtual Machine names."),
                new ParameterDescriptor("IgnoreVMList", "A comma-separated list of WQL-compliant virtual machine names to ignore if they are matched by the VMNameSpec parameter."),
                new ParameterDescriptor("Force", "[OPTIONAL] Flag indicating that the desired action should be forced, no matter the current state of the VM. Default is FALSE."),
                new ParameterDescriptor("ActionData", "[OPTIONAL] Action-specific data. START & REBOOT : Number of seconds to wait for the VM to become responsive; SHUTDOWN : Reason for shutting down."),
                new ParameterDescriptor("UserName", "[OPTIONAL] The username to use when connecting to the host server."),
                new ParameterDescriptor("Password", "[OPTIONAL] The password to use when connecting to the host server."),
                new ParameterDescriptor("PasswordEncrypted", "[OPTIONAL] Flag indicating whether or not the password is encrypted.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(ActionParameter, "");
            _parameters.Add(HostListParameter, "");
            _parameters.Add(VMNameParameter, "");
            _parameters.Add(IgnoreVMList, "");
            _parameters.Add(ForceParameter, "false");
            _parameters.Add(ActionDataParameter, "");
            _parameters.Add(UserNameParameter, "");
            _parameters.Add(PasswordParameter, "");
            _parameters.Add(PasswordEncryptedParameter, "false");
        }

        #region ITaskModule Members

        public override void AddParameter(string parameterName, string value)
        {
            base.AddParameter(parameterName, value);
        }

        public override void RemoveAllParameters()
        {
            _parameters[ActionParameter] = "";
            _parameters[HostListParameter] = "";
            _parameters[VMNameParameter] = "";
            _parameters[IgnoreVMList] = "";
            _parameters[ForceParameter] = "false";
            _parameters[ActionDataParameter] = "";
            _parameters[UserNameParameter] = "";
            _parameters[PasswordParameter] = "";
            _parameters[PasswordEncryptedParameter] = "false";
        }

        public override TaskResult Perform()
        {
            bool force = false;
            string password = "";

            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (String.IsNullOrEmpty(_parameters[ActionParameter]))
            {
                _result.AddLog(new Log("{0} : The 'Action' parameter is required but was not specified.", _info.Name));
                _result.ExecutedSuccessfully = false;
            }
            if (String.IsNullOrEmpty(_parameters[HostListParameter]))
            {
                _result.AddLog(new Log("{0} : The 'HostList' parameter is required but was not specified.", _info.Name));
                _result.ExecutedSuccessfully = false;
            }
            if (String.IsNullOrEmpty(_parameters[VMNameParameter]))
            {
                _result.AddLog(new Log("{0} : The 'VMNameSpec' parameter is required but was not specified.", _info.Name));
                _result.ExecutedSuccessfully = false;
            }
            Boolean.TryParse(_parameters[ForceParameter], out force);

            // Decrypt the password parameter, if needs be
            if (!String.IsNullOrEmpty(_parameters[PasswordParameter]))
            {
                bool encrypted = false;
                Boolean.TryParse(_parameters[PasswordEncryptedParameter], out encrypted);
                if (encrypted)
                    password = DataProtector.DecryptFromHexString(_parameters[PasswordParameter]);
                else
                    password = _parameters[PasswordParameter];
            }

            if (_result.ExecutedSuccessfully)
            {
                List<ManagementObject> vmList;
                try
                {
                    vmList = FindVMs(new List<string>(_parameters[HostListParameter].Split(',')),
                        _parameters[VMNameParameter], new List<string>(_parameters[IgnoreVMList].Split(',')),
                        _parameters[UserNameParameter], password);
                    if (vmList.Count > 0)
                    {
                        switch (_parameters[ActionParameter].ToLower())
                        {
                            case "start":
                                {
                                    int timeout;
                                    if (!Int32.TryParse(_parameters[ActionDataParameter], out timeout))
                                    {
                                        _result.AddLog(new Log("Start VM: Invalid timeout value - the default of 300 seconds will be used."));
                                        timeout = 300;
                                    }
                                    StartVMAsync(vmList, timeout);
                                }
                                break;
                            case "shutdown":
                                ShutdownVMAsync(vmList, _parameters[ActionDataParameter], force);
                                break;
                            case "reboot":
                                {
                                    int timeout;
                                    if (!Int32.TryParse(_parameters[ActionDataParameter], out timeout))
                                    {
                                        _result.AddLog(new Log("Reboot VM: Invalid timeout value - the default of 300 seconds will be used."));
                                        timeout = 300;
                                    }
                                    RebootVMAsync(vmList, timeout, force);
                                }
                                break;
                            default:
                                _result.AddLog(new Log("{0} : Unknown Action : '{1}'", _info.Name, _parameters[ActionParameter]));
                                break;
                        }
                    }
                    else
                    {
                        _result.ExecutedSuccessfully = false;
                        _result.AddLog(new Log("No VMs matching the name '{0}' were found on the host(s) '{1}'.",
                            _parameters[VMNameParameter], _parameters[HostListParameter]));
                    }
                }
                catch (Exception ex)
                {
                    _result.AddLog(new Log("{0} : Unhandled exception processing the '{1}' action:\r\n{1}",
                        _info.Name, _parameters[ActionParameter], ex));
                    _result.ExecutedSuccessfully = false;
                }
            }

            return _result;
        }

        #endregion

        private void StartVMAsync(List<ManagementObject> vmList, int timeout)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(StartVM), new ThreadData(vmList[i], timeout, false, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the StartVM threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the StartVM threads to exit."));
            }
        }

        private void StartVM(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMGeneralModule object and use that to start the VM
                VMGeneralModule vmgm = new VMGeneralModule();
                Log log = null;
                try
                {
                    vmgm.StartVirtualMachine(td.VM, (int)td.Data);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("StartVM: " + ex.Message);
                }

                // update the common results object
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = vmgm.Result.ExecutedSuccessfully;
                    if (vmgm.Result.Logs.Length > 0)
                        _result.AddLogs(vmgm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        private void ShutdownVMAsync(List<ManagementObject> vmList, string reason, bool force)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(ShutdownVM), new ThreadData(vmList[i], reason, force, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the ShutdownVM threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the ShutdownVM threads to exit."));
            }
        }

        private void ShutdownVM(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMGeneralModule object and use that to start the VM
                VMGeneralModule vmgm = new VMGeneralModule();
                Log log = null;
                try
                {
                    vmgm.ShutdownVirtualMachine(td.VM, td.Data as string, td.Force);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("ShutdownVM: " + ex.Message);
                }

                // update the common results object
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = vmgm.Result.ExecutedSuccessfully;
                    if (vmgm.Result.Logs.Length > 0)
                        _result.AddLogs(vmgm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        private void RebootVMAsync(List<ManagementObject> vmList, int timeout, bool force)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(RebootVM), new ThreadData(vmList[i], timeout, force, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the RebootVM threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the RebootVM threads to exit."));
            }
        }

        private void RebootVM(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMGeneralModule object and use that to start the VM
                VMGeneralModule vmgm = new VMGeneralModule();
                Log log = null;
                try
                {
                    vmgm.RebootVirtualMachine(td.VM, (int)td.Data, td.Force);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("RebootVM: " + ex.Message);
                }

                // update the common results object
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = vmgm.Result.ExecutedSuccessfully;
                    if (vmgm.Result.Logs.Length > 0)
                        _result.AddLogs(vmgm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        #region ThreadData class
        internal class ThreadData
        {
            public ManagementObject VM { get; set; }
            public bool Force { get; set; }
            public object Data { get; set; }
            public ManualResetEvent FinishedEvent { get; set; }

            public ThreadData() { }
            public ThreadData(ManagementObject vm, object data, bool force, ManualResetEvent finishedEvent)
            {
                VM = vm;
                Data = data;
                Force = force;
                FinishedEvent = finishedEvent;
            }
        }
        #endregion
    }

    [DeploymentTaskModule("AsyncVMSnapshotModule")]
    public class AsyncVMSnapshotModule : VMTaskModuleBase
    {
        private const string ActionParameter = "action";
        private const string HostListParameter = "hostlist";
        private const string VMNameParameter = "vmnamespec";
        private const string IgnoreVMList = "ignorevmlist";
        private const string SnapshotNameParameter = "snapshotnamespec";
        private const string ForceParameter = "force";
        private const string ActionDataParameter = "actiondata";
        private const string UserNameParameter = "username";
        private const string PasswordParameter = "password";
        private const string PasswordEncryptedParameter = "passwordencrypted";

        public AsyncVMSnapshotModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "AsyncVMSnapshotModule";
            _info.Description = "Provides asnychronous snapshot management for multiple virtual machines.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Action", "The action to perform on the VMs. Valid values are CREATESNAP, APPLYSNAP, RENAMESNAP, DELETESNAP"),
                new ParameterDescriptor("HostList", "A comma-separated list of Hyper-V host servers."),
                new ParameterDescriptor("VMNameSpec", "A WQL-compliant string used to match Virtual Machine names."),
                new ParameterDescriptor("SnapshotNameSpec", "A WQL-compliant string used to match snapshot names."),
                new ParameterDescriptor("IgnoreVMList", "[OPTIONAL] A comma-separated list of WQL-compliant virtual machine names to ignore if they are matched by the VMNameSpec parameter."),
                new ParameterDescriptor("Force", "[OPTIONAL] Flag indicating that the desired action should be forced, no matter the current state of the VM. Default is FALSE."),
                new ParameterDescriptor("ActionData", "[OPTIONAL] Action-specific data."),
                new ParameterDescriptor("UserName", "[OPTIONAL] The username to use when connecting to the host server."),
                new ParameterDescriptor("Password", "[OPTIONAL] The password to use when connecting to the host server."),
                new ParameterDescriptor("PasswordEncrypted", "[OPTIONAL] Flag indicating whether or not the password is encrypted.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(ActionParameter, "");
            _parameters.Add(HostListParameter, "");
            _parameters.Add(VMNameParameter, "");
            _parameters.Add(IgnoreVMList, "");
            _parameters.Add(SnapshotNameParameter, "");
            _parameters.Add(ForceParameter, "false");
            _parameters.Add(ActionDataParameter, "");
            _parameters.Add(UserNameParameter, "");
            _parameters.Add(PasswordParameter, "");
            _parameters.Add(PasswordEncryptedParameter, "false");
        }

        #region ITaskModule Members

        public override void AddParameter(string parameterName, string value)
        {
            base.AddParameter(parameterName, value);
        }

        public override TaskResult Perform()
        {
            bool force = false;
            string password = "";

            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (String.IsNullOrEmpty(_parameters[ActionParameter]))
            {
                _result.AddLog(new Log("{0} : The 'Action' parameter is required but was not specified.", _info.Name));
                _result.ExecutedSuccessfully = false;
            }
            if (String.IsNullOrEmpty(_parameters[HostListParameter]))
            {
                _result.AddLog(new Log("{0} : The 'HostList' parameter is required but was not specified.", _info.Name));
                _result.ExecutedSuccessfully = false;
            }
            if (String.IsNullOrEmpty(_parameters[VMNameParameter]))
            {
                _result.AddLog(new Log("{0} : The 'VMNameSpec' parameter is required but was not specified.", _info.Name));
                _result.ExecutedSuccessfully = false;
            }
            Boolean.TryParse(_parameters[ForceParameter], out force);

            // Decrypt the password parameter, if needs be
            if (!String.IsNullOrEmpty(_parameters[PasswordParameter]))
            {
                bool encrypted = false;
                Boolean.TryParse(_parameters[PasswordEncryptedParameter], out encrypted);
                if (encrypted)
                    password = DataProtector.DecryptFromHexString(_parameters[PasswordParameter]);
                else
                    password = _parameters[PasswordParameter];
            }

            if (_result.ExecutedSuccessfully)
            {
                List<ManagementObject> vmList;
                try
                {
                    vmList = FindVMs(new List<string>(_parameters[HostListParameter].Split(',')),
                        _parameters[VMNameParameter], new List<string>(_parameters[IgnoreVMList].Split(',')),
                        _parameters[UserNameParameter], password);
                    if (vmList.Count > 0)
                    {
                        switch (_parameters[ActionParameter].ToLower())
                        {
                            case "createsnap":
                                // The snapshot name parameter must not contain WQL wildcards
                                if (_parameters[SnapshotNameParameter].Contains("%"))
                                {
                                    _result.ExecutedSuccessfully = false;
                                    _result.AddLog(new Log("{0} : Invalid snapshot name '{1}' - the '%' character is not allowed.",
                                        _info.Name, _parameters[SnapshotNameParameter]));
                                }
                                else
                                {
                                    // The final snapshot name will have the form '<snapshotName> - (MM/dd/yyyy HH:mm:ss)'
                                    string name = String.Format("{0} - ({1})", _parameters[SnapshotNameParameter],
                                        DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss"));
                                    CreateSnapshotAsync(vmList, name, force);
                                }
                                break;
                            case "applysnap":
                                ApplySnapshotAsync(vmList, _parameters[SnapshotNameParameter], force);
                                break;
                            case "renamesnap":
                                if (_parameters[ActionDataParameter].Contains("%"))
                                {
                                    _result.ExecutedSuccessfully = false;
                                    _result.AddLog(new Log("{0} : Invalid snapshot name '{1}' - the '%' character is not allowed.",
                                        _info.Name, _parameters[ActionDataParameter]));
                                }
                                else
                                {
                                    // The new snapshot name will have the form '<snapshotName> - (MM/dd/yyyy HH:mm:ss)'
                                    string name = String.Format("{0} - ({1})", _parameters[ActionDataParameter],
                                        DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss"));
                                    RenameSnapshotAsync(vmList, _parameters[SnapshotNameParameter], name, force);
                                }
                                break;
                            case "deletesnap":
                                DeleteSnapshotAsync(vmList, _parameters[SnapshotNameParameter], force);
                                break;
                            default:
                                _result.AddLog(new Log("{0} : Unknown Action : '{1}'", _info.Name, _parameters[ActionParameter]));
                                break;
                        }
                    }
                    else
                    {
                        _result.ExecutedSuccessfully = false;
                        _result.AddLog(new Log("No VMs matching the name '{0}' were found on the host(s) '{1}'.",
                            _parameters[VMNameParameter], _parameters[HostListParameter]));
                    }
                }
                catch (Exception ex)
                {
                    _result.AddLog(new Log("{0} : Unhandled exception processing the '{1}' action:\r\n{2}",
                        _info.Name, _parameters[ActionParameter], ex));
                    _result.ExecutedSuccessfully = false;
                }
            }

            return _result;
        }

        public override void RemoveAllParameters()
        {
            _parameters[ActionParameter] = "";
            _parameters[HostListParameter] = "";
            _parameters[VMNameParameter] = "";
            _parameters[IgnoreVMList] = "";
            _parameters[SnapshotNameParameter] = "";
            _parameters[ForceParameter] = "false";
            _parameters[ActionDataParameter] = "";
            _parameters[UserNameParameter] = "";
            _parameters[PasswordParameter] = "";
            _parameters[PasswordEncryptedParameter] = "false";
        }

        #endregion

        private void CreateSnapshotAsync(List<ManagementObject> vmList, string snapshotName, bool force)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(CreateSnapshot), new ThreadData(vmList[i], snapshotName, force, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the CreateSnapshot threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the CreateSnapshot threads to exit."));
            }
        }

        private void CreateSnapshot(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMSnapshotModule object and use that to create the snapshot
                VMSnapshotModule vmsm = new VMSnapshotModule();
                Log log = null;
                bool success = false;
                try
                {
                    success = vmsm.CreateSnapshot(td.VM, td.SnapshotName, td.Force);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("CreateSnapshot : " + ex.Message);
                }

                // update the results
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = success;
                    if (vmsm.Result.Logs.Length > 0)
                        _result.AddLogs(vmsm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        private void ApplySnapshotAsync(List<ManagementObject> vmList, string snapshotName, bool force)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(ApplySnapshot), new ThreadData(vmList[i], snapshotName, force, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the ApplySnapshot threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the ApplySnapshot threads to exit."));
            }
        }

        private void ApplySnapshot(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMSnapshotModule object and use that to apply the snapshot
                VMSnapshotModule vmsm = new VMSnapshotModule();
                Log log = null;
                bool success = false;
                try
                {
                    success = vmsm.ApplySnapshot(td.VM, td.SnapshotName, td.Force);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("ApplySnapshot : " + ex.Message);
                }

                // update the common results object
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = success;
                    if (vmsm.Result.Logs.Length > 0)
                        _result.AddLogs(vmsm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        private void RenameSnapshotAsync(List<ManagementObject> vmList, string snapshotName, string newSnapshotName, bool force)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(RenameSnapshot), new ThreadData(vmList[i], snapshotName, force, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the RenameSnapshot threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the RenameSnapshot threads to exit."));
            }
        }

        private void RenameSnapshot(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMSnapshotModule object and use that to apply the snapshot
                VMSnapshotModule vmsm = new VMSnapshotModule();
                Log log = null;
                bool success = false;
                try
                {
                    success = vmsm.RenameSnapshot(td.VM, td.SnapshotName, td.Data);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("RenameSnaphot : " + ex.Message);
                }

                // update the common results object
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = success;
                    if (vmsm.Result.Logs.Length > 0)
                        _result.AddLogs(vmsm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        private void DeleteSnapshotAsync(List<ManagementObject> vmList, string snapshotName, bool force)
        {
            ManualResetEvent[] finishedEvents = new ManualResetEvent[vmList.Count];
            for (int i = 0; i < vmList.Count; i++)
            {
                finishedEvents[i] = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(DeleteSnapshot), new ThreadData(vmList[i], snapshotName, force, finishedEvents[i]));
            }

            // wait for all the thread pool threads to exit
            if (!ManualResetEvent.WaitAll(finishedEvents, DEFAULT_TIMEOUT * 1000, false))
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "The timeout value expired waiting for all the DeleteSnapshot threads to exit.");
                _result.AddLog(new Log("The timeout value expired waiting for all the DeleteSnapshot threads to exit."));
            }
        }

        private void DeleteSnapshot(object state)
        {
            ThreadData td = state as ThreadData;

            try
            {
                // Create a VMSnapshotModule object and use that to apply the snapshot
                VMSnapshotModule vmsm = new VMSnapshotModule();
                Log log = null;
                bool success = false;
                try
                {
                    success = vmsm.DeleteSnapshot(td.VM, td.SnapshotName, td.Force);
                }
                catch (VMTimeoutException ex)
                {
                    log = new Log("DeleteSnapshot : " + ex.Message);
                }

                // update the common results object
                lock (_result)
                {
                    if (_result.ExecutedSuccessfully)
                        _result.ExecutedSuccessfully = success;
                    if (vmsm.Result.Logs.Length > 0)
                        _result.AddLogs(vmsm.Result.Logs);
                    if (log != null)
                        _result.AddLog(log);
                }
            }
            finally
            {
                // set the finished event
                if (td.FinishedEvent != null)
                    td.FinishedEvent.Set();
            }
        }

        #region ThreadData class
        internal class ThreadData
        {
            public ManagementObject VM { get; set; }
            public string SnapshotName { get; set; }
            public bool Force { get; set; }
            public string Data { get; set; }
            public ManualResetEvent FinishedEvent { get; set; }

            public ThreadData() { }
            public ThreadData(ManagementObject vm, string snapshotName, bool force, ManualResetEvent finishedEvent)
            {
                VM = vm;
                SnapshotName = snapshotName;
                Force = force;
                FinishedEvent = finishedEvent;
            }
            public ThreadData(ManagementObject vm, string snapshotName, string data, bool force, ManualResetEvent finishedEvent)
            {
                VM = vm;
                SnapshotName = snapshotName;
                Data = data;
                Force = force;
                FinishedEvent = finishedEvent;
            }
        }
        #endregion
    }

    [DeploymentTaskModule("VMTaskModule")]
    public class VMTaskModule : ITaskModule
    {
        private TaskModuleInfo _info = null;
        private string[] _hostList = null;
        private string _vmNameSpec = null;
        private string _ignoreNameSpec = null;
        private string _userName = null;
        private string _password = null;
        private bool _encrypted = false;
        private string _action = null;
        private bool _waitForHeartbeat = true;
        private bool _allowMerge = true;
        private bool _force = false;
        private bool _replaceExisting = false;
        private bool _deleteChildren = false;
        private int _waitSeconds = 0;
        private string _reason = null;
        private string _nameSpec = null;
        private string _newName = null;

        public VMTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "VMTaskModule";
            _info.Description = "Provides administrative tasks for Virtual Machines.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder usage = new StringBuilder();
            usage.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            usage.AppendLine("<Parameters>");
            usage.AppendLine("    <Hosts>Comma-separated list of servers hosting the target VMs</Hosts>");
            usage.AppendLine("    [<Credentials UserName=\"User name\" Password=\"Password\" [Encrypted=\"true|false\"] />]");
            usage.AppendLine("    <VM NameSpec=\"WQL-compliant Virtual Machine name. May contain the '%' wildcard character.\" [IgnoreNameSpec=\"WQL-compliant name of VMs to ignore.\"]");
            usage.AppendLine("Any one of the following commands:");
            usage.AppendLine("    <StartVM [WaitForHeartbeat=\"true|false\"] [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("    <ShutdownVM [AllowMerge=\"true|false\"] [Force=\"true|false\"] [Reason=\"Reason for the shutdown\"] [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("    <RebootVM [AllowMerge=\"true|false\"] [Force=\"true|false\"] [Reason=\"Reason for the shutdown\"] [WaitForHeartbeat=\"true|false\"] [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("    <ApplySnapshot SnapshotNameSpec=\"WQL-compliant name of the snapshot. May contains the '%' wildcard character\" [AllowMerge=\"true|false\"] [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("    <CreateSnapshot NewSnapshotName=\"Name of the new snapshot.\" [ReplaceExisting=\"true|false\"] [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("    <RenameSnapshot SnapshotNameSpec=\"WQL-compliant name of the snapshot. May contains the '%' wildcard character\" NewSnapshotName=\"Name of the new snapshot.\" [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("    <DeleteSnapshot SnapshotNameSpec=\"WQL-compliant name of the snapshot. May contains the '%' wildcard character\" [DeleteChildren=\"true|false\"] [WaitSeconds=\"Number of seconds before timeout\"] />");
            usage.AppendLine("</Parameters>\r\n");
            usage.AppendLine("* Only one command element may be specified at a time.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", usage.ToString());
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public XmlSchema Schema
        {
            get { return GetSchema(); }
        }

        public void AddParameter(string parameterName, string value)
        {
            throw new NotImplementedException();
        }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlReader reader;
            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.IgnoreComments = true;
            readerSettings.IgnoreProcessingInstructions = true;
            readerSettings.IgnoreWhitespace = true;
            XmlSchema schema = GetSchema();
            if (schema != null)
            {
                // Validate the xmlParameterBlock against the schema
                readerSettings.Schemas.Add(schema);
                readerSettings.ValidationType = ValidationType.Schema;
                readerSettings.ValidationFlags = XmlSchemaValidationFlags.None;
            }

            reader = XmlReader.Create(new MemoryStream(Encoding.ASCII.GetBytes(xmlParameterBlock)), readerSettings);
            XmlDocument doc = new XmlDocument();
            doc.Load(reader);

            // Parse the parameter block
            foreach (XmlNode node in doc.ChildNodes[0].ChildNodes)
            {
                if (node.NodeType != XmlNodeType.Element)
                    continue;

                string nodeName = node.Name.ToLower();
                switch (nodeName)
                {
                    case "hosts":
                        _hostList = node.InnerText.Split(',');
                        break;
                    case "credentials":
                        _userName = node.Attributes["UserName"].Value;
                        _password = node.Attributes["Password"].Value;
                        _encrypted = Boolean.Parse(node.Attributes["Encrypted"].Value);
                        break;
                    case "vm":
                        _vmNameSpec = node.Attributes["NameSpec"].Value;
                        _ignoreNameSpec = node.Attributes["IgnoreNameSpec"].Value;
                        break;
                    case "startvm":
                        _action = nodeName;
                        _waitForHeartbeat = Boolean.Parse(node.Attributes["WaitForHeartbeat"].Value);
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                    case "shutdownvm":
                        _action = nodeName;
                        _allowMerge = Boolean.Parse(node.Attributes["AllowMerge"].Value);
                        _force = Boolean.Parse(node.Attributes["Force"].Value);
                        _reason = node.Attributes["Reason"].Value;
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                    case "rebootvm":
                        _action = nodeName;
                        _allowMerge = Boolean.Parse(node.Attributes["AllowMerge"].Value);
                        _force = Boolean.Parse(node.Attributes["Force"].Value);
                        _reason = node.Attributes["Reason"].Value;
                        _waitForHeartbeat = Boolean.Parse(node.Attributes["WaitForHeartbeat"].Value);
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                    case "createsnapshot":
                        _action = nodeName;
                        _newName = node.Attributes["NewSnapshotName"].Value;
                        _replaceExisting = Boolean.Parse(node.Attributes["ReplaceExisting"].Value);
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                    case "applysnapshot":
                        _action = nodeName;
                        _nameSpec = node.Attributes["SnapshotNameSpec"].Value;
                        _allowMerge = Boolean.Parse(node.Attributes["AllowMerge"].Value);
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                    case "renamesnapshot":
                        _action = nodeName;
                        _nameSpec = node.Attributes["SnapshotNameSpec"].Value;
                        _newName = node.Attributes["NewSnapshotName"].Value;
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                    case "deletesnapshot":
                        _action = nodeName;
                        _nameSpec = node.Attributes["SnapshotNameSpec"].Value;
                        _deleteChildren = Boolean.Parse(node.Attributes["DeleteChildren"].Value);
                        _waitSeconds = Int32.Parse(node.Attributes["WaitSeconds"].Value);
                        break;
                }
            }
        }

        public void RemoveAllParameters()
        {
            _hostList = null;
            _vmNameSpec = null;
            _ignoreNameSpec = null;
            _userName = null;
            _password = null;
            _encrypted = false;
            _action = null;
            _waitForHeartbeat = true;
            _allowMerge = true;
            _force = false;
            _replaceExisting = false;
            _deleteChildren = false;
            _waitSeconds = 0;
            _reason = null;
            _nameSpec = null;
            _newName = null;
        }

        public TaskResult Perform()
        {
            ManualResetEvent done = new ManualResetEvent(false);
            int requests = 0;
            TaskResult result = new TaskResult();
            string password = null;

            if (_encrypted && !String.IsNullOrEmpty(_password))
                password = DataProtector.DecryptFromHexString(_password);
            else
                password = _password;

            foreach (string hostName in _hostList)
            {
                HyperVHost host = new HyperVHost(hostName, _userName, password);
                Interlocked.Increment(ref requests);
                if (_waitSeconds > 0)
                    host.Timeout = _waitSeconds;
                host.BeginConnect(connectResult =>
                {
                    host.EndConnect(connectResult);
                    Interlocked.Increment(ref requests);
                    host.BeginGetVirtualMachineList(_vmNameSpec, _ignoreNameSpec, getVMResult =>
                    {
                        VirtualMachines vmList = host.EndGetVirtualMachineList(getVMResult);
                        foreach (VirtualMachine vm in vmList)
                        {
                            try
                            {
                                switch (_action)
                                {
                                    case "startvm":
                                        Interlocked.Increment(ref requests);
                                        vm.BeginStart(_waitForHeartbeat, startResult =>
                                        {
                                            try
                                            {
                                                result.ExecutedSuccessfully = (startResult.AsyncState as VirtualMachine).EndStart(startResult);
                                            }
                                            catch (Exception ex)
                                            {
                                                result.ExecutedSuccessfully = false;
                                                result.AddLog(new Log("Failed to start the Virtual Machine '{0}' on {1}:\r\n{2}",
                                                    (startResult.AsyncState as VirtualMachine).Name, host.Server, ex));
                                            }
                                            if (Interlocked.Decrement(ref requests) <= 0)
                                                done.Set();
                                        },
                                        vm);
                                        break;
                                    case "shutdownvm":
                                        Interlocked.Increment(ref requests);
                                        vm.BeginShutdown(_allowMerge, _force, _reason, shutdownResult =>
                                        {
                                            try
                                            {
                                                result.ExecutedSuccessfully = (shutdownResult.AsyncState as VirtualMachine).EndShutdown(shutdownResult);
                                            }
                                            catch (Exception ex)
                                            {
                                                result.ExecutedSuccessfully = false;
                                                result.AddLog(new Log("Failed to shut down the Virtual Machine '{0}' on {1}:\r\n{2}",
                                                    (shutdownResult.AsyncState as VirtualMachine).Name, host.Server, ex));
                                            }
                                            if (Interlocked.Decrement(ref requests) <= 0)
                                                done.Set();
                                        },
                                        vm);
                                        break;
                                    case "rebootvm":
                                        Interlocked.Increment(ref requests);
                                        vm.BeginReboot(_allowMerge, _force, _waitForHeartbeat, _reason, rebootResult =>
                                        {
                                            try
                                            {
                                                result.ExecutedSuccessfully = (rebootResult.AsyncState as VirtualMachine).EndReboot(rebootResult);
                                            }
                                            catch (Exception ex)
                                            {
                                                result.ExecutedSuccessfully = false;
                                                result.AddLog(new Log("Failed to reboot the Virtual Machine '{0}' on {1}:\r\n{2}",
                                                    (rebootResult.AsyncState as VirtualMachine).Name, host.Server, ex));
                                            }
                                            if (Interlocked.Decrement(ref requests) <= 0)
                                                done.Set();
                                        },
                                        vm);
                                        break;
                                    case "createsnapshot":
                                        Interlocked.Increment(ref requests);
                                        vm.BeginCreateSnapshot(String.Format("{0} - ({1})", _newName, DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss")), createSnapshotResult =>
                                        {
                                            VirtualMachine vm1 = (createSnapshotResult.AsyncState as VirtualMachine);
                                            Snapshot newSnapshot = null;
                                            try
                                            {
                                                newSnapshot = vm1.EndCreateSnapshot(createSnapshotResult);
                                                result.ExecutedSuccessfully = (null != newSnapshot);
                                            }
                                            catch (Exception ex)
                                            {
                                                result.ExecutedSuccessfully = false;
                                                result.AddLog(new Log("Failed to create the '{0}' snapshot on {1}:\r\n{2}",
                                                    _newName, vm1.Name, ex));
                                            }

                                            // If the Replace Existing flag is set, get a list of snapshots that match 
                                            // the given name. If more than one is found, start deleting them.
                                            if (_replaceExisting && result.ExecutedSuccessfully)
                                            {
                                                Interlocked.Increment(ref requests);
                                                vm1.BeginGetSnapshotList(_newName + "%", SnapshotSortMethod.DateDescending, getSSLResult =>
                                                {
                                                    Snapshots snapshots = null;
                                                    try
                                                    {
                                                        snapshots = (getSSLResult.AsyncState as VirtualMachine).EndGetSnapshotList(getSSLResult);
                                                    }
                                                    catch (Exception ex)
                                                    {
                                                        result.AddLog(new Log("The Replace Existing flag is set, but the list of snapshots couldn't be retrieved from {0}:\r\n{1}",
                                                            vm1.Name, ex));
                                                    }

                                                    if (snapshots != null && snapshots.Count > 1)
                                                    {
                                                        // Delete all but the new snapshot
                                                        foreach (Snapshot snap in snapshots)
                                                        {
                                                            if (snap != newSnapshot)
                                                            {
                                                                Interlocked.Increment(ref requests);
                                                                snap.BeginDelete(false, deleteResult =>
                                                                {
                                                                    try
                                                                    {
                                                                        (deleteResult.AsyncState as Snapshot).EndDelete(deleteResult);
                                                                    }
                                                                    catch (Exception ex)
                                                                    {
                                                                        // This being an optional step, we don't want to fail the task if it doesn't work
                                                                        result.AddLog(new Log("Unable to delete a duplicate '{0}' snapshot on {1}:\r\n{2}",
                                                                            _newName, vm1.Name, ex));
                                                                    }
                                                                    if (Interlocked.Decrement(ref requests) <= 0)
                                                                        done.Set();
                                                                },
                                                                snap);
                                                            }
                                                        }
                                                    }
                                                    if (Interlocked.Decrement(ref requests) <= 0)
                                                        done.Set();
                                                },
                                                vm1);
                                            }
                                            if (Interlocked.Decrement(ref requests) <= 0)
                                                done.Set();
                                        },
                                        vm);
                                        break;
                                    case "applysnapshot":
                                    case "renamesnapshot":
                                    case "deletesnapshot":
                                        Interlocked.Increment(ref requests);
                                        vm.BeginGetSnapshot(_nameSpec, getSnapshotResult =>
                                        {
                                            VirtualMachine vm1 = (getSnapshotResult.AsyncState as VirtualMachine);
                                            Snapshot snapShot = null;

                                            try
                                            {
                                                snapShot = vm1.EndGetSnapshot(getSnapshotResult);
                                            }
                                            catch (Exception ex)
                                            {
                                                result.ExecutedSuccessfully = false;
                                                result.AddLog(new Log("Failed to get the '{0}' snapshot from {1}:\r\n{2}",
                                                    _nameSpec, (getSnapshotResult.AsyncState as VirtualMachine).Name, ex));
                                            }

                                            if (snapShot != null)
                                            {
                                                Interlocked.Increment(ref requests);
                                                if (_action == "applysnapshot")
                                                {
                                                    snapShot.BeginApply(_allowMerge, applyResult =>
                                                    {
                                                        try
                                                        {
                                                            result.ExecutedSuccessfully = (applyResult.AsyncState as Snapshot).EndApply(applyResult);
                                                        }
                                                        catch (Exception ex)
                                                        {
                                                            result.ExecutedSuccessfully = false;
                                                            result.AddLog(new Log("Failed to apply the '{0}' snapshot on {1}:\r\n{2}",
                                                                (applyResult.AsyncState as Snapshot).Name, vm1.Name, ex));
                                                        }
                                                        if (Interlocked.Decrement(ref requests) <= 0)
                                                            done.Set();
                                                    },
                                                    snapShot);
                                                }
                                                else if (_action == "renamesnapshot")
                                                {
                                                    snapShot.BeginRename(String.Format("{0} - ({1})", _newName, DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss")), renameResult =>
                                                    {
                                                        try
                                                        {
                                                            result.ExecutedSuccessfully = (renameResult.AsyncState as Snapshot).EndRename(renameResult);
                                                        }
                                                        catch (Exception ex)
                                                        {
                                                            result.ExecutedSuccessfully = false;
                                                            result.AddLog(new Log("Failed to rename the '{0}' snapshot to '{1}' on {2}:\r\n{3}",
                                                                (renameResult.AsyncState as Snapshot).Name, _newName, vm1.Name, ex));
                                                        }
                                                        if (Interlocked.Decrement(ref requests) <= 0)
                                                            done.Set();
                                                    },
                                                    snapShot);
                                                }
                                                else if (_action == "deletesnapshot")
                                                {
                                                    snapShot.BeginDelete(_deleteChildren, deleteResult =>
                                                    {
                                                        try
                                                        {
                                                            result.ExecutedSuccessfully = (deleteResult.AsyncState as Snapshot).EndDelete(deleteResult);
                                                        }
                                                        catch (Exception ex)
                                                        {
                                                            result.ExecutedSuccessfully = false;
                                                            result.AddLog(new Log("Failed to delete the '{0}' snapshot from {1}:\r\n{2}",
                                                                (deleteResult.AsyncState as Snapshot).Name, vm1.Name, ex));
                                                        }
                                                        if (Interlocked.Decrement(ref requests) <= 0)
                                                            done.Set();
                                                    },
                                                    snapShot);
                                                }
                                            }
                                            else
                                            {
                                                // No matching snapshot on this virtual machine
                                                result.ExecutedSuccessfully = false;
                                                result.AddLog(new Log("A snapshot matching the name '{0}' doesn't exist on {1}",
                                                    _nameSpec, (getSnapshotResult.AsyncState as VirtualMachine).Name));
                                            }
                                            if (Interlocked.Decrement(ref requests) <= 0)
                                                done.Set();
                                        },
                                        vm);
                                        break;
                                    default:
                                        break;
                                }
                            }
                            catch (Exception ex)
                            {
                                result.ExecutedSuccessfully = false;
                                result.AddLog(new Log("Unable to process the '{0}' action for the Virtual Machine {1} on {2}:\r\n{3}",
                                    _action, vm.Name, host.Server, ex));
                                if (Interlocked.Decrement(ref requests) <= 0)
                                    done.Set();
                            }
                        }
                        if (Interlocked.Decrement(ref requests) <= 0)
                            done.Set();
                    },
                    null);
                    if (Interlocked.Decrement(ref requests) <= 0)
                        done.Set();
                },
                null);
            }

            // Wait for everything to finish before returning the result
            done.WaitOne();
            done.Close();
            return result;
        }

        #endregion

        private XmlSchema GetSchema()
        {
            Stream schemaStream = null;
            XmlSchema schema = null;

            try
            {
                schemaStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(_info.Name);
                schema = XmlSchema.Read(schemaStream, null);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to get the schema:\r\n{0}", ex);
            }
            finally
            {
                if (schemaStream != null)
                    schemaStream.Close();
            }

            return schema;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\TestDescription.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
	public class TestDescription
	{
	    public string Name;
	    public string Architecture;
	    public string EnvRequirement;
	    public string AdditionalParameters;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\ProcessWrapper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    class ProcessWrapper : xonline.test.deployment.automation.taskmodules.wttstftaskmodule.IProcessWrapper
    {
        Process p;

        public ProcessWrapper()
        {
            p = new Process();
            HasExited = false;
        }

        public ProcessStartInfo StartInfo
        {
            get
            {
                return p.StartInfo;
            }
        }

        public void Start()
        {
            var rca = new RemoteCommandArgs(p.StartInfo.FileName, p.StartInfo.Arguments, ushort.MaxValue);
            var rcr = DACommon.RunRemoteCommand("HxWTTController", rca);
            if (rcr.Exception != null)
                throw new Exception(
                    string.Format(
                        "Exception occured while running {0} on remote machine. See innerException for more details",
                        p.StartInfo.FileName), rcr.Exception);
            HasExited = true;

        }

        public bool HasExited
        {
            get; private set;
        }

        public void WaitForExit()
        {
            p.WaitForExit();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\HyperNetIntegrationTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("HyperNetIntegrationTests")]
[assembly: AssemblyDescription("Integration tests to be run in the hypernet environment")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8a2c7018-1c00-4a63-a8e8-f4727074f9cd")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\HyperNetIntegrationTests\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace HyperNetIntegrationTests
{
    class Program
    {
        static void Main(string[] args)
        {
            WttStfTaskModule_runs_successfully_on_hyper_net_and_sets_logs_correctly();

            Console.ReadLine();
        }

        public static void WttStfTaskModule_runs_successfully_on_hyper_net_and_sets_logs_correctly()
        {
            WttStfTaskModule module = new WttStfTaskModule();

            string parameterString =
                "<Parameters>" +
                "  <TestList Path=\"C:\\TestList\\BVT.txt\"/>" +
                "  <Environment Name=\"AutoNet\" />" +
                "  <WttClient Name=\"ATNCLIENT001\"/>" +
                "  <StfArgs Frequency=\"BVT\" />" +
                "  <DailyCutoff CutoffTime=\""+DateTime.Now.AddMinutes(1).ToString("HH:mm") +"\" />" +
                "</Parameters>\r\n";

            module.AddParameters(parameterString);

            Console.WriteLine("About to run...");
            Console.ReadLine();

            var result = module.Perform();

            Console.WriteLine("Execution state: ");
            Console.WriteLine(result.ExecutedSuccessfully);

            Console.WriteLine("Logs gotten:");
            foreach (var l in result.Logs)
            {
                Console.WriteLine("{0} {1}", l.Path, l.FileName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfPreparer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    class WttStfPreparer : IWttStfPreparer
    {
        public IProcessWrapper PrepareSyncroneousWttStfCall(TestDescription stfSuite, string stfFrequency, string network, int daysTimeout)
        {
            //C:\Program Files\WTT 2.2\Studio>wttcl schedulejob /DataStore:HxWTTController /Jo
            //bId:13 /MachinePool:$\AutoNet /Wait:True /ExecutionTimeout { /Days:1 /Hours:0 /M
            //inutes:0 } /CommonParameter { /Name:STF_SUITE_NAME /Value:LiveBVT.dll /FailIfPar
            //ameterNotFound:False /LimitScopeTo:local } /CommonParameter { /Name:STF_ARGS /Va
            //lue:"/env:AutoNet /freq:BVT" /FailIfParameterNotFound:False /LimitScopeTo:local }
            ProcessWrapper process = new ProcessWrapper();
            process.StartInfo.FileName = @"C:\Program Files\WTT 2.2\Studio\wttcl.exe";
            StringBuilder builder = new StringBuilder();
            builder.Append("schedulejob ");
            builder.Append("/DataStore:HxWTTController ");
            builder.Append("/JobId:13 ");
            builder.Append("/Wait:True ");
            builder.AppendFormat("/MachinePool:$\\{0} ", network);

            if (daysTimeout > 0)
            {
                builder.Append("/ExecutionTimeout { /Days:" + daysTimeout + " /Hours:0 /Minutes:0 } ");
            }

            builder.Append("/CommonParameter { /Name:STF_SUITE_NAME /Value:" + stfSuite.Name + ".dll /FailIfParameterNotFound:False /LimitScopeTo:local } ");
            builder.Append("/CommonParameter { /Name:STF_SUITE_FLAVOR /Value:" + SuiteFlavorString(stfSuite) + " } ");
            builder.Append("/CommonParameter { /Name:STF_ARGS /Value:\"" + StfArguments(stfSuite, network, stfFrequency) + "\" /FailIfParameterNotFound:False /LimitScopeTo:local }");
            process.StartInfo.Arguments = builder.ToString();
            process.StartInfo.UseShellExecute = true;

            return process;
        }

        private static string SuiteFlavorString(TestDescription stfSuite)
        {
            return (stfSuite.Architecture == "64" ? "Suites64" : "Suites");
        }

        public IProcessWrapper PrepareCancelAllCurrentOperationsOnWttClient(string client)
        {
            //C:\Program Files\WTT 2.2\Controller>WTTCmd.exe /CancelJob /TargetMachine:ATNCLIE
            //NT001
            ProcessWrapper process = new ProcessWrapper();
            process.StartInfo.FileName = @"C:\Program Files\WTT 2.2\Controller\WTTCmd.exe";
            StringBuilder builder = new StringBuilder();
            builder.Append("/CancelJob ");
            builder.AppendFormat("/TargetMachine:{0}", client);
            process.StartInfo.Arguments = builder.ToString();
            process.StartInfo.UseShellExecute = true;

            return process;
        }

        public static string StfArguments(TestDescription testDescription, string network, string stfFrequency)
        {
            string standardParams = "/env:" + network + " /freq:" + stfFrequency;
            string envReq = String.IsNullOrEmpty(testDescription.EnvRequirement)
                                ? String.Empty
                                : " /EnvReq:" + testDescription.EnvRequirement;
            string additionalParams = String.IsNullOrEmpty(testDescription.AdditionalParameters)
                                          ? String.Empty
                                          : " " + testDescription.AdditionalParameters;
            return standardParams + envReq + additionalParams;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModule.cs ===
﻿using System;
using System.Timers;
using System.Text;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Linq;
using System.Diagnostics;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    [DeploymentTaskModule("WttStfTaskModule")]
    public class WttStfTaskModule : ITaskModule
    {
        //BUGBUG: I'm not sure if there's a better way to define all
        //of the XML parameter constants than this.
        private const string TestListNodeName = "testlist";
        private const string TestListPathParameter = "Path";

        private const string DailyCutoffNodeName = "dailycutoff";
        private const string DailyCutoffUseCutoffParameter = "UseCutoff";
        private const string DailyCutoffCutoffTimeParameter = "CutoffTime";

        private const string EnvironmentNodeName = "environment";
        private const string EnvironmentNameParameter = "Name";

        private const string WttClientNodeName = "wttclient";
        private const string WttClientNameParameter = "Name";

        private const string StfArgsNodeName = "stfargs";
        private const string StfArgsFrequencyParameter = "Frequency";

        //internal strings (for testing)
        internal const string AddParameterError = "Can't add ({0}, {1}). Don't use this function to add parameters, use the other, which takes an xml blob";
        internal const string UnknownParameterError = "Unknown parameter block element: {0}";
        internal const string ParameterParseError = "Unable to parse the parameter block: {0}";
        internal const string WTTTaskModuleName = "WTT STF Job Runner";
        internal const string WTTTaskModuleDescription = "Runs WTT STF Jobs.";

        /// <summary>
        /// The cutoff time, any task started after this time will immediately return.
        /// </summary>
        public DateTime CutoffTime
        {
            get;
            internal set;
        }

        /// <summary>
        /// The LIVE Environment to run against.
        /// </summary>
        public string Environment
        {
            get;
            internal set;
        }

        /// <summary>
        /// The path to the STF test list.
        /// </summary>
        public string TestListPath
        {
            get;
            internal set;
        }

        /// <summary>
        /// The WTT client
        /// </summary>
        public string WttClient
        {
            get;
            internal set;
        }

        /// <summary>
        /// The Frequency
        /// </summary>
        public string Frequency
        {
            get;
            internal set;
        }
        
        //internals (for testing)
        internal ILogger _logger;
        internal IWttStfPreparer _wttController;
        internal IConditionalTimer _timer;
        internal IProcessWrapper _currentWttJob;
        internal ITestListParser _testListParser;
        internal ILogRetriever _logRetriever;
        
        //privates
        private TimeSpan _timeToWaitForWttJobToFinish = TimeSpan.FromMinutes(1);
        private bool _timerFired = false;

        /// <summary>
        /// Creates a new WTTTaskModule, logs to DACommon.
        /// </summary>
        public WttStfTaskModule()
            : this(new DACommonLogger(), new WttStfPreparer(), 
                new ConditionalTimer(), new TestListParser(), 
                new LogRetriever())
        {
        }

        /// <summary>
        /// Creates a new WTTTaskModule
        /// </summary>
        /// <param name="logger">the logger to use on errors in the module</param>
        //BUGBUG: If we ever start using an IOC container in here, you don't need the contructor
        //injection here. The timer should be resolved in Perform()
        public WttStfTaskModule(ILogger logger, IWttStfPreparer wttPreparer, 
            IConditionalTimer timer, ITestListParser testListParser, 
            ILogRetriever logRetriever)
        {
            _logger = logger;
            _wttController = wttPreparer;
            _timer = timer;
            _testListParser = testListParser;
            _logRetriever = logRetriever;

            //fire the timer event when now > cutoff time
            _timer.Condition = () => DateTime.Now > this.CutoffTime;
            _timer.OnCondition += new Action(_timer_OnCutoffTime);

            Info = new TaskModuleInfo();

            //Initialize the Info object
            Info.Name = WTTTaskModuleName;
            Info.Description = WTTTaskModuleDescription;
            Info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <TestList Path=\"Path to Text List of STF cases\"/>");
            desc.AppendLine("  <DailyCutoff CutoffTime=\"DateTime of cutoff. I.e. 23:30\" />");
            desc.AppendLine("  <Environment Name=\"The name of the environment to run the STF test cases on\" />");
            desc.AppendLine("  <WttClient Name=\"The name of the wtt client to use\" />");
            desc.AppendLine("  <StfArgs Frequency=\"The freq argument to stf\"/>");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("The CutoffTime on the DailyCutoff tag can be omitted if UseCutoff is false");
            Info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            InitializeParameters();
        }

        /// <summary>
        /// a helper object to hold information for this task module
        /// </summary>
        public TaskModuleInfo Info
        {
            get;
            private set;
        }

        /// <summary>
        /// Adds a parameter through a name, value paring
        /// </summary>
        /// <param name="parameterName">the name of the parameter</param>
        /// <param name="value">the value to assign to it.</param>
        public void AddParameter(string parameterName, string value)
        {
            _logger.LogEvent(Info.Name, LoggingLevel.Error, AddParameterError, parameterName, value);
        }

        /// <summary>
        /// Adds a set of parameters through a generic XML blob, parameters that are not
        /// understood cause this to throw an ArgumentException.
        /// </summary>
        /// <param name="xmlParameterBlock"></param>
        public void AddParameters(string xmlParameterBlock)
        {
            //Parse XML block
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);

                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                //BUGBUG: This is okay for now, but can get pretty heinous as the number of parameters to this
                //dll grows. Make sure you watch how this grows.
                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    var node = itor.Current;

                    switch (node.Name.ToLower())
                    {
                        case WttStfTaskModule.TestListNodeName:
                            this.TestListPath = 
                                node.GetAttribute(TestListPathParameter, node.NamespaceURI);
                            break;
                        case WttStfTaskModule.DailyCutoffNodeName:
                                this.CutoffTime = DateTime.Parse(
                                    node.GetAttribute(DailyCutoffCutoffTimeParameter, node.NamespaceURI));
                            break;
                        case WttStfTaskModule.EnvironmentNodeName:
                            this.Environment = 
                                node.GetAttribute(EnvironmentNameParameter, node.NamespaceURI);
                            break;
                        case WttStfTaskModule.WttClientNodeName:
                            this.WttClient =
                                node.GetAttribute(WttClientNameParameter, node.NamespaceURI);
                            break;
                        case WttStfTaskModule.StfArgsNodeName:
                            this.Frequency =
                                node.GetAttribute(StfArgsFrequencyParameter, node.NamespaceURI);
                            break;
                        default:
                            _logger.LogEvent(Info.Name, LoggingLevel.Warning, UnknownParameterError, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogEvent(Info.Name, LoggingLevel.Error, ParameterParseError, ex);
                throw;
            }
        }

        /// <summary>
        /// Removes any parameters that have been set.
        /// </summary>
        public void RemoveAllParameters()
        {
            InitializeParameters();
        }

        public TaskResult Perform()
        {
            TaskResult result = new TaskResult();
            _timer.StartTimer();

            if (DateTime.Now < CutoffTime)
            {
                //parse the test list into a list
                var testList =
                    _testListParser.ParseFileToList(TestListPath);

                int testTimeoutInDays = 1;
                if (CutoffTime == DateTime.MaxValue) testTimeoutInDays = -1;

                //loop over each test and run it
                foreach (var stfTestSuite in testList)
                {
                    if (_timerFired)
                        break;

                    _currentWttJob = _wttController.PrepareSyncroneousWttStfCall(
                            stfTestSuite, Frequency, Environment,
                            testTimeoutInDays);
                    _currentWttJob.Start();

                    //get the logs.
                    IEnumerable<Log> logs = _logRetriever.GetLogs(@"\\HxWttController\StfResults", "*");
                    result.AddLogs(logs);
                }
            }

            _timer.StopTimer();
            result.ExecutedSuccessfully = true;
            return result;
        }

        /// <summary>
        /// Initializes the dictionary with the parameters that this dll takes
        /// </summary>
        private void InitializeParameters()
        {
            //Initialize the parameter dictionary
            this.TestListPath = null;
            this.CutoffTime = DateTime.MaxValue;
            this.Environment = null;
            this.WttClient = null;
        }

        internal void _timer_OnCutoffTime()
        {
            _timerFired = true;
            //FYI: there's no need to lock _currentWttJob as only one
            //thread should be accessing it at one time.
            if (_currentWttJob != null && !_currentWttJob.HasExited)
            {
                IProcessWrapper cancelProcess = _wttController.PrepareCancelAllCurrentOperationsOnWttClient(WttClient);

                //try to cancel the process.
                //BUGBUG: I've never seen calling cancel on a job take longer than
                //a minute, so I'm assuming that it will always come back. If this 
                //winds up not to be the case, you should put a timeout on this
                //wait
                cancelProcess.Start();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\TestListParser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml.Linq;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    class TestListParser : ITestListParser
    {
        ILogger _logger;

        public TestListParser()
            : this(new DACommonLogger())
        {
        }

        public TestListParser(ILogger logger)
        {
            _logger = logger;
        }

        public IEnumerable<TestDescription> ParseTestList(string xmlString)
        {
            
            XElement root = XElement.Parse(xmlString);
            var result =
                from seg in root.Descendants("test")
                select new TestDescription
                            {
                                Name = (string) seg.Attribute("Name"),
                                Architecture = (string) seg.Attribute("Architecture"),
                                EnvRequirement = (string) seg.Attribute("EnvRequirement"),
                                AdditionalParameters = (string)seg.Attribute("AdditionalParameters")
                            };

            return result;
        }

        public IEnumerable<TestDescription> ParseFileToList(string path)
        {
            return ParseTestList(File.ReadAllText(path));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleIntegrationTests\ProcessThatTakesALongTime.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleIntegrationTests
{
    class ProcessThatTakesALongTime : IProcessWrapper
    {
        public bool HasExited
        {
            get;
            set;
        }

        public void Start()
        {
            HasExited = false;
            while (!HasExited)
            {
            }
        }

        public System.Diagnostics.ProcessStartInfo StartInfo
        {
            get { return new System.Diagnostics.ProcessStartInfo(); }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WttStfTaskModule")]
[assembly: AssemblyDescription("A Task Module to run Stf Test Cases with WTT")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("2d554eae-f53f-4fb6-80fa-6602bcbd047b")]

[assembly: InternalsVisibleTo("WttStfTaskModuleUnitTests"),
           InternalsVisibleTo("WttStfTaskModuleIntegrationTests")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleIntegrationTests\TestListParserIntegrationTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.MMF;
using System.IO;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace xonline.test.deployment.automation.taskmodules.wttstftaskmodule
{
    [TestClass]
    public class TestListParserIntegrationTests
    {
        [TestMethod]
        public void Integration_Parse_actual_file_returns_correctly()
        {
            //Arrange
            //write out a test list file
            string testListFile = Path.GetRandomFileName();
            using(var stream = File.CreateText(testListFile))
            {
                stream.WriteLine(@"<tests><test Name='Suite' Type='STF' Architecture='32' TestFrequency='Full' EnvRequirement='Billing,Catalog' /></tests>");

            }

            TestListParser target = new TestListParser();

            //Act
            var actualList = target.ParseFileToList(testListFile);

            //Assert
            Assert.AreEqual("Suite", actualList.First().Name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleIntegrationTests\LogRetrieverIntegrationTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.IO;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleIntegrationTests
{
    /// <summary>
    /// Summary description for LogRetrieverIntegrationTests
    /// </summary>
    [TestClass]
    public class LogRetrieverIntegrationTests
    {
        [TestMethod]
        public void Integration_FetchLogs_takes_logs_from_given_location()
        {
            //Arrange
            LogRetriever target = new LogRetriever();

            string file = Path.GetTempFileName();
            using (var stream = File.CreateText(file))
            {
                stream.WriteLine("foo");
            }

            //Act
            var logs = target.GetLogs(System.IO.Path.GetTempPath(),
                Path.GetFileName(file));

            //Assert
            Assert.AreEqual(1, logs.Count());
            Assert.AreEqual(Path.GetDirectoryName(file), logs.First().Path);
            Assert.AreEqual(Path.GetFileName(file), logs.First().FileName);
        }

        [TestMethod]
        public void Integration_FetchLogs_returns_no_logs_if_directory_does_not_exist()
        {
            //Arrange
            LogRetriever target = new LogRetriever();

            string file = Path.GetTempFileName();
            using (var stream = File.CreateText(file))
            {
                stream.WriteLine("foo");
            }

            //Act
            var logs = target.GetLogs(@"C\foo",
                Path.GetFileName(file));

            //Assert
            Assert.AreEqual(0, logs.Count());
        }

        [TestMethod]
        public void Integration_FetchLogs_returns_logs_in_subdirectory_as_well()
        {
            //Arrange
            LogRetriever target = new LogRetriever();

            string innerDir = Path.Combine(Path.GetTempPath(), "foo");
            Directory.CreateDirectory(innerDir);
            string innerInnerDir = Path.Combine(innerDir, "bar");
            Directory.CreateDirectory(innerInnerDir);

            string file = Path.Combine(innerInnerDir, "baz.txt");
            using (var stream = File.CreateText(file))
            {
                stream.WriteLine("foo");
            }

            //Act
            var logs = target.GetLogs(innerDir,
                Path.GetFileName(file));

            //Assert
            Assert.AreEqual(1, logs.Count());
            Assert.AreEqual("baz.txt", logs.First().FileName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleIntegrationTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WttStfTaskModuleIntegrationTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WttStfTaskModuleIntegrationTests")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("93995e28-f652-4662-9c11-6f376b1167aa")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleUnitTests\ConditionalTimerTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleUnitTests
{
    /// <summary>
    /// Summary description for ConditionalTimerTests
    /// </summary>
    [TestClass]
    public class ConditionalTimerTests
    {
        [TestMethod]
        [Timeout(500)]
        public void ConditionalTimer_fires_event_within_half_second_when_condition_is_true()
        {
            //Arrange
            ConditionalTimer target = new ConditionalTimer(TimeSpan.FromMilliseconds(1));
            target.Condition = () => true;
            bool conditionFired = false;
            target.OnCondition += new Action(() => {conditionFired = true;});

            //Act
            target.StartTimer();

            while (conditionFired == false)
            {
                System.Threading.Thread.Sleep(1);
            }

            //Assert
            Assert.IsTrue(conditionFired);
        }

        [TestMethod]
        [Timeout(500)]
        public void ConditionalTimer_does_not_fire_event_when_condition_is_not_true()
        {
            //Arrange
            bool conditionChecked = false;
            ConditionalTimer target = new ConditionalTimer(TimeSpan.FromMilliseconds(1));
            target.Condition = () =>
                    {
                        conditionChecked = true;
                        return false;
                    };
            bool conditionFired = false;
            target.OnCondition += new Action(() => { conditionFired = true; });

            //Act
            target.StartTimer();

            while (conditionChecked == false)
            {
                System.Threading.Thread.Sleep(1);
            }

            //Assert
            Assert.IsTrue(conditionChecked);
            Assert.IsFalse(conditionFired);
        }

        [TestMethod]
        [Timeout(500)]
        public void StopTimer_sets_TimerStarted_to_false()
        {
            //Arrange
            ConditionalTimer target = new ConditionalTimer(TimeSpan.FromMilliseconds(1));
            target.Condition = () => false;
            target.OnCondition += new Action(() => {});

            //Act
            target.StartTimer();
            if (!target.TimerStarted) Assert.Fail();
            target.StopTimer();

            //Assert
            Assert.IsFalse(target.TimerStarted);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleIntegrationTests\MockWttStfPreparer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleIntegrationTests
{
    class MockWttStfPreparer : IWttStfPreparer
    {
        public delegate IProcessWrapper ReturnProcessWrapperDelegate();

        public ReturnProcessWrapperDelegate PrepareSyncroneousWttStfCall_Hook;
        public IProcessWrapper PrepareSyncroneousWttStfCall(TestDescription stfSuite, string stfFrequency, string network, int daysTimeout)
        {
            if (PrepareSyncroneousWttStfCall_Hook != null)
            {
                return PrepareSyncroneousWttStfCall_Hook();
            }

            throw new NotImplementedException();
        }

        public ReturnProcessWrapperDelegate PrepareCancelAllCurrentOperationsOnWttClient_Hook;
        public IProcessWrapper PrepareCancelAllCurrentOperationsOnWttClient(string client)
        {
            if (PrepareCancelAllCurrentOperationsOnWttClient_Hook != null)
            {
                return PrepareCancelAllCurrentOperationsOnWttClient_Hook();
            }

            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleIntegrationTests\WttStfTaskModuleIntegrationTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.MMF;
using System.IO;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleIntegrationTests
{
    /// <summary>
    /// Summary description for WttStfTaskModuleIntegrationTests
    /// </summary>
    [TestClass]
    public class WttStfTaskModuleIntegrationTests
    {
        [TestMethod]
        [Timeout(10000)]
        public void Integration_Perform_returns_non_error_when_process_is_cancelled()
        {
            //Setup
            WttStfTaskModule target = new WttStfTaskModule();
            MockWttStfPreparer wttStfPreparerHook = new MockWttStfPreparer();
            target._wttController = wttStfPreparerHook;
            ProcessThatTakesALongTime longTimeProcess = new ProcessThatTakesALongTime();
            wttStfPreparerHook.PrepareSyncroneousWttStfCall_Hook = 
                () => longTimeProcess;

            //when cancel is called, stop the process.
            var stubProcess = StubFactory.Create<IProcessWrapper>();
            wttStfPreparerHook.PrepareCancelAllCurrentOperationsOnWttClient_Hook =
                () => { longTimeProcess.HasExited = true; return stubProcess.Target; };

            DateTime throwTime = DateTime.Now + TimeSpan.FromSeconds(3);

            //write out a test list file
            string testListFile = Path.GetRandomFileName();
            using(var stream = File.CreateText(testListFile))
            {
                stream.WriteLine(@"<tests><test Name='Suite' Type='STF' Architecture='32' TestFrequency='Full' EnvRequirement='Billing,Catalog' /></tests>");
            }

            //add  something known to the log
            var stubRetriever = StubFactory.Create<ILogRetriever>();
            target._logRetriever = stubRetriever.Target;

            Log returnMe = new Log();
            returnMe.FileName = Path.GetFileName(testListFile);
            returnMe.Path = Path.GetDirectoryName(testListFile);
            stubRetriever
                .Returns((IEnumerable<Log>)new Log[]{returnMe})
                .On(s => s.GetLogs(@"\\HxWttController\StfResults", "*"));

            string parameterString =
                "<Parameters>" +
                "  <TestList Path=\"" + testListFile + "\"/>" + 
                "  <DailyCutoff UseCutoff=\"true\" CutoffTime=\"{0}:{1}:{2}\" />" +
                "</Parameters>\r\n";

            parameterString = String.Format(parameterString,
                throwTime.Hour, throwTime.Minute, throwTime.Second);

            target.AddParameters(parameterString);

            //Perform!
            var result = target.Perform();

            //Validate that the process is done.
            Assert.IsTrue(longTimeProcess.HasExited);
            Assert.AreEqual(1, result.Logs.Length);
            Assert.AreEqual(returnMe, result.Logs[0]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleUnitTests\DACommonLoggerTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleUnitTests
{
    /// <summary>
    /// Summary description for DACommonLoggerTests
    /// </summary>
    [TestClass]
    public class DACommonLoggerTests
    {
        [TestMethod]
        public void DACommonLogger_can_be_created_to_log_to_DACommon()
        {
            //Arrange

            //Act
            var target = new DACommonLogger();

            //Assert
            Assert.IsNotNull(target);
        }

        [TestMethod]
        public void LogEvent_can_be_called_without_Exception()
        {
            //Arrange
            var target = new DACommonLogger();

            //Act
            target.LogEvent("a", LoggingLevel.Information, "{0}", 1);

            //Assert
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleUnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WttStfTaskModuleUnitTests")]
[assembly: AssemblyDescription("Unit tests")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ae26e400-10de-4f8d-9da3-2c68870ab0fe")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleUnitTests\WttStfTaskModuleUnitTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.MMF;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleUnitTests
{
    /// <summary>
    /// Summary description for WTTTaskModuleUnitTests
    /// </summary>
    [TestClass]
    public class WTTTaskModuleTests
    {
        WttStfTaskModule _target;
        StubObjectWrapper<ILogger> _stubLogger;
        StubObjectWrapper<IWttStfPreparer> _stubController;
        StubObjectWrapper<IConditionalTimer> _stubCutoffTimer;
        StubObjectWrapper<ITestListParser> _stubTestListParser;
        StubObjectWrapper<ILogRetriever> _stubLogRetriever;

        [TestInitialize]
        public void Setup()
        {
            _stubLogger = StubFactory.Create<ILogger>();
            _stubController = StubFactory.Create<IWttStfPreparer>();
            _stubCutoffTimer = StubFactory.Create<IConditionalTimer>();
            _stubTestListParser = StubFactory.Create<ITestListParser>();
            _stubLogRetriever = StubFactory.Create<ILogRetriever>();
            _target = new WttStfTaskModule(_stubLogger.Target, 
                _stubController.Target, _stubCutoffTimer.Target,
                _stubTestListParser.Target, _stubLogRetriever.Target);
        }

        [TestMethod]
        public void AddParameter_name_value_pair_tells_user_to_use_other_AddParameter()
        {
            //Arrange
                       
            //Act
            _target.AddParameter("dailycutoff", "something");

            //Assert
            //ignore the parameters that come in from the params array.
            _stubLogger
                .IgnoresArgumentsAt(3, 4)
                .WhenAssertingThat(l => l.LogEvent(_target.Info.Name,
                        LoggingLevel.Error,
                        WttStfTaskModule.AddParameterError,
                        null, null))
                .WasCalledOneTime();
        }

        [TestMethod]
        public void Info_is_set_correctly_with_name_description_and_parameter_description()
        {
            //Arrange

            //Act
            var targetInfo = _target.Info;

            //Assert
            Assert.AreEqual(WttStfTaskModule.WTTTaskModuleName, targetInfo.Name);
            Assert.AreEqual(WttStfTaskModule.WTTTaskModuleDescription, targetInfo.Description);
            Assert.AreEqual(1, targetInfo.ParameterDescriptions.Length);
            Assert.AreEqual("XML Parameter Block", targetInfo.ParameterDescriptions[0].ParameterName);
        }

        [TestMethod]
        public void RemoveAllParameters_reinitializes_parameters()
        {
            //Arrange
            _target.TestListPath = string.Empty;
            _target.Environment = string.Empty;
            _target.CutoffTime = DateTime.MinValue;

            //Act
            _target.RemoveAllParameters();

            //Assert
            Assert.AreEqual(null, _target.TestListPath);
            Assert.AreEqual(null, _target.Environment);
            Assert.AreEqual(DateTime.MaxValue, _target.CutoffTime);
        }

        [TestMethod]
        public void WTTTaskModule_default_constructor_creates_correct_logger()
        {
            //Arrange

            //Act
            _target = new WttStfTaskModule();

            //Assert
            Assert.IsInstanceOfType(_target._logger, typeof(DACommonLogger));
        }

        [TestMethod]
        public void WTTTaskModule_default_constructor_creates_correct_test_list_parser()
        {
            //Arrange

            //Act
            _target = new WttStfTaskModule();

            //Assert
            Assert.IsInstanceOfType(_target._testListParser, typeof(TestListParser));
        }

        [TestMethod]
        public void WTTTaskModule_default_constructor_creates_correct_timer()
        {
            //Arrange

            //Act
            _target = new WttStfTaskModule();

            //Assert
            Assert.IsInstanceOfType(_target._timer, typeof(ConditionalTimer));
        }

        [TestMethod]
        public void WTTTaskModule_default_constructor_creates_correct_wtt_controller()
        {
            //Arrange

            //Act
            _target = new WttStfTaskModule();

            //Assert
            Assert.IsInstanceOfType(_target._wttController, typeof(WttStfPreparer));
        }

        [TestMethod]
        public void WTTTaskModule_default_constructor_creates_correct_log_retriever()
        {
            //Arrange

            //Act
            _target = new WttStfTaskModule();

            //Assert
            Assert.IsInstanceOfType(_target._logRetriever, typeof(LogRetriever));
        }

        [TestMethod]
        public void AddParameter_xml_blob_sets_cutoff_time_correctly()
        {
            //Arrange
            string parameterString = 
                "<Parameters>" + 
                "  <DailyCutoff CutoffTime=\"23:30\" />" +
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
            DateTime today = DateTime.Today;
            DateTime expectedTime = new DateTime(today.Year, today.Month, today.Day, 23, 30, 0);
            Assert.AreEqual(expectedTime, _target.CutoffTime);
        }

        [TestMethod]
        public void AddParameter_xml_blob_sets_path_correctly()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <TestList Path=\"Path\"/>" + 
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
            Assert.AreEqual("Path", _target.TestListPath);
        }

        [TestMethod]
        public void AddParameter_xml_blob_sets_environment_correctly()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <Environment Name=\"AutoNet\" />" +
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
            Assert.AreEqual("AutoNet", _target.Environment);
        }

        [TestMethod]
        public void AddParameter_xml_blob_sets_wtt_client_correctly()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <WttClient Name=\"ATNCLIENT001\"/>" + 
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
            Assert.AreEqual("ATNCLIENT001", _target.WttClient);
        }

        [TestMethod]
        public void AddParameter_xml_blob_sets_use_cutoff_correctly()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <DailyCutoff CutoffTime=\"23:30\" />" +
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);
            Assert.AreEqual(DateTime.Parse("23:30"), _target.CutoffTime);
        }

        [TestMethod]
        public void AddParameter_xml_blob_sets_use_frequency_correctly()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <StfArgs Frequency=\"BVT\" />" +
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
            Assert.AreEqual("BVT", _target.Frequency);
        }

        [TestMethod]
        public void AddParameter_xml_blob_logs_unknown_parameters()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <Unknown Path=\"Path\"/>" +
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
            _stubLogger
                .IgnoresArgumentsAt(3, 4)
                .WhenAssertingThat(l => l.LogEvent(_target.Info.Name,
                        LoggingLevel.Warning,
                        WttStfTaskModule.UnknownParameterError,
                        null, null))
                .WasCalledOneTime();
        }

        [TestMethod]
        [ExpectedException(typeof(ApplicationException))]
        public void AddParameter_xml_blob_throws_ApplicationException_on_invalid_parameter_node_name()
        {
            //Arrange
            string parameterString =
                "<x>" +
                "</x>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
        }

        [TestMethod]
        [ExpectedException(typeof(FormatException))]
        public void AddParameter_xml_blob_throws_FormatException_on_invalid_parse_of_CutoffTime()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <DailyCutoff CutoffTime=\"not a datetime\" />" +
                "</Parameters>\r\n";

            //Act
            _target.AddParameters(parameterString);

            //Assert
        }

        [TestMethod]
        public void Perform_does_not_return_execution_failure_if_current_time_is_past_cutoff_time()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <DailyCutoff CutoffTime=\"00:00\" />" +
                "</Parameters>\r\n";
            _target.AddParameters(parameterString);

            //Act
            var result = _target.Perform();

            //Assert
            Assert.IsTrue(result.ExecutedSuccessfully);
        }

        [TestMethod]
        public void Perform_does_not_get_a_test_list_if_current_time_is_past_cutoff_time()
        {
            //Arrange
            string parameterString =
                "<Parameters>" +
                "  <DailyCutoff CutoffTime=\"00:00\" />" +
                "</Parameters>\r\n";
            _target.AddParameters(parameterString);

            //Act
            var result = _target.Perform();

            //Assert
            _stubTestListParser
                .IgnoresAllArguments()
                .WhenAssertingThat(s => s.ParseFileToList(null))
                .WasNotCalled();
        }

        [TestMethod]
        public void WttStfTaskModule__timer_OnCutoffTime_does_not_try_to_call_cancel_if_no_wtt_job_is_running()
        {
            //Arrange
            _target._currentWttJob = null;

            //Act
            _target._timer_OnCutoffTime();

            //Assert
            _stubController
                .IgnoresAllArguments()
                .WhenAssertingThat(s => s.PrepareCancelAllCurrentOperationsOnWttClient(null))
                .WasNotCalled();
        }

        [TestMethod]
        public void WttStfTaskModule__timer_OnCutoffTime_calls_to_cancel_if_wtt_job_is_running()
        {
            //Arrange
            var stubJob = StubFactory.Create<IProcessWrapper>();
            _target._currentWttJob = stubJob.Target;
            stubJob
                .Returns(false)
                .On(s => s.HasExited);

            var mockCancelProcess = MockFactory.Create<IProcessWrapper>();

            _stubController
                .Returns(mockCancelProcess.Target)
                .On(s => s.PrepareCancelAllCurrentOperationsOnWttClient(_target.WttClient));

            using (Recorder.StartOrderedRecording())
            {
                mockCancelProcess
                    .Expects(m => m.Start())
                    .ToBeCalledOneTime();

            }

            //Act
            _target._timer_OnCutoffTime();

            //Assert
            _stubController
                .AssertsThat(s => s.PrepareCancelAllCurrentOperationsOnWttClient(_target.WttClient))
                .WasCalledOneTime();
            Recorder.ValidateReplay();
        }

        [TestMethod]
        public void WttStfTaskModule__timer_OnCutoffTime_does_not_try_to_call_cancel_if_wtt_job_has_exited()
        {
            //Arrange
            var stubJob = StubFactory.Create<IProcessWrapper>();
            _target._currentWttJob = stubJob.Target;
            stubJob.Returns(true)
                .On(s => s.HasExited);

            //Act
            _target._timer_OnCutoffTime();

            //Assert
            _stubController
                .IgnoresAllArguments()
                .WhenAssertingThat(s => s.PrepareCancelAllCurrentOperationsOnWttClient(null))
                .WasNotCalled();
        }

        [TestMethod]
        public void Perform_passes_test_list_file_to_test_list_parser()
        {
            //Arrange
            _target.TestListPath = "Path";
            _target.CutoffTime = DateTime.MaxValue;
            _stubTestListParser
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<TestDescription>)new TestDescription[0])
                .On(s => s.ParseFileToList(null));

            //Act
            _target.Perform();

            //Assert
            _stubTestListParser
                .AssertsThat(s => s.ParseFileToList("Path"))
                .WasCalledOneTime();
        }

        [TestMethod]
        public void Perform_passes_test_to_wtt_controller()
        {
            //Arrange
            var list = new[] { new TestDescription { Name = "Suite.dll" } };
            _stubTestListParser
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<TestDescription>)list)
                .On(s => s.ParseFileToList(string.Empty));
            _target.Environment = "AutoNet";
            _target.Frequency = "BVT";
            _target.CutoffTime = DateTime.Now.AddDays(1);
            var stubJob = StubFactory.Create<IProcessWrapper>();
            _stubController.IgnoresAllArguments()
                    .AndReturns(stubJob.Target)
                    .On(s => s.PrepareSyncroneousWttStfCall(null, null, null, 0));

            _stubLogRetriever
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<Log>)new Log[0])
                .On(s => s.GetLogs(null, null));

            //Act
            _target.Perform();

            //Assert
            _stubController
                .Calls((args) =>
                    {
                        Assert.AreEqual("Suite.dll", ((TestDescription)args[0]).Name);
                        Assert.AreEqual("BVT", args[1]);
                        Assert.AreEqual("AutoNet", args[2]);
                        Assert.AreEqual(1, args[3]);
                        return true;
                    })
                .ToAssertThat((s) => s.PrepareSyncroneousWttStfCall(null,null,null,0))
                .WasCalledOneTime();
                
        }

        [TestMethod]
        public void Perform_runs_process_to_completion()
        {
            //Arrange
            var list = new[] { new TestDescription { Name = "Suite.dll" } };
            _stubTestListParser
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<TestDescription>)list)
                .On(s => s.ParseFileToList(string.Empty));
            _target.CutoffTime = DateTime.MaxValue;

            var mockJob = MockFactory.Create<IProcessWrapper>();
            _stubController.IgnoresAllArguments()
                .AndReturns(mockJob.Target)
                .On(s => s.PrepareSyncroneousWttStfCall(null, null, null, 0));

            using (Recorder.StartOrderedRecording())
            {
                mockJob
                    .Expects(m => m.Start())
                    .ToBeCalledOneTime();
            }

            _stubLogRetriever
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<Log>) new Log[0])
                .On(s => s.GetLogs(null, null));

            //Act
            _target.Perform();

            //Assert
            Recorder.ValidateReplay();
        }

        [TestMethod] public void Perform_Stops_Running_Subsequent_Suites_When_Timer_Fires()
        {
            //Arrange
            var list = new[] { new TestDescription { Name = "Suite.dll" },new TestDescription { Name = "Suite2.dll" },new TestDescription { Name = "Suite3.dll" }};
            _stubTestListParser
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<TestDescription>) list)
                .On(s => s.ParseFileToList(string.Empty));
            _target.CutoffTime = DateTime.MaxValue;

            var stubJob = StubFactory.Create<IProcessWrapper>();
            stubJob.StubsByCalling((args) => _target._timer_OnCutoffTime()).On(s => s.Start());


            _stubController.IgnoresAllArguments()
                .AndReturns(stubJob.Target)
                .On(s => s.PrepareSyncroneousWttStfCall(null, null, null, 0));

            var cancelJob = StubFactory.Create<IProcessWrapper>();
            _stubController.IgnoresAllArguments()
                .AndReturns(cancelJob.Target)
                .On(s => s.PrepareCancelAllCurrentOperationsOnWttClient(null));

            _stubLogRetriever
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<Log>)new Log[0])
                .On(s => s.GetLogs(null, null));


            _target.Perform();
            stubJob.AssertsThat(s=>s.Start()).WasCalledOneTime();
        }
        [TestMethod]
        public void Perform_gets_logs_and_appends_them_to_the_result()
        {
            //Arrange
            var list = new[] { new TestDescription { Name = "Suite.dll" } };
            _stubTestListParser
                .IgnoresAllArguments()
                .AndReturns((IEnumerable<TestDescription>)list)
                .On(s => s.ParseFileToList(string.Empty));
            _target.CutoffTime = DateTime.MaxValue;

            var stubJob = StubFactory.Create<IProcessWrapper>();
            _stubController.IgnoresAllArguments()
                .AndReturns(stubJob.Target)
                .On(s => s.PrepareSyncroneousWttStfCall(null, null, null, 0));

            IEnumerable<Log> logs = new Log[]{new Log()};

            _stubLogRetriever
                .Returns(logs)
                .On((s) => s.GetLogs(@"\\HxWttController\StfResults", "*"));

            //Act
            var result = _target.Perform();

            //Assert
            Assert.AreEqual(1, result.Logs.Length);
            Assert.AreEqual(logs.First(), result.Logs[0]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleUnitTests\WttStfPreparerTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleUnitTests
{
    /// <summary>
    /// Summary description for WttStfPreparerTests
    /// </summary>
    [TestClass]
    public class WttStfPreparerTests
    {
        [TestMethod]
        public void PrepareSyncroneousWttStfCall_adds_dll_to_suite_name()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();

            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription{Name="LiveBVT"}, "BVT", "AutoNet", 2);

            //Assert
            Assert.IsTrue(actualProcess.StartInfo.Arguments.Contains("/Name:STF_SUITE_NAME /Value:LiveBVT.dll"));
        }

        [TestMethod]
        public void PrepareSyncroneousWttStfCall_adds_suite_flavor_WTT_parameter_64bit()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();
            
            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription { Name = "LiveBVT", Architecture="64" }, "BVT", "AutoNet", 2);

            //Assert
            Assert.IsTrue(actualProcess.StartInfo.Arguments.Contains("/CommonParameter { /Name:STF_SUITE_FLAVOR /Value:Suites64 }"));
        }

        [TestMethod]
        public void PrepareSyncroneousWttStfCall_adds_build_flavor_WTT_parameter_32bit()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();

            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription { Name = "LiveBVT", Architecture = "32" }, "BVT", "AutoNet", 2);

            //Assert
            Assert.IsTrue(actualProcess.StartInfo.Arguments.Contains("/CommonParameter { /Name:STF_SUITE_FLAVOR /Value:Suites }"));
        }

        [TestMethod]
        public void PrepareSyncroneousWttStfCall_default_build_flavor_WTT_parameter_is_32bit()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();

            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription { Name = "LiveBVT" }, "BVT", "AutoNet", 2);

            //Assert
            Assert.IsTrue(actualProcess.StartInfo.Arguments.Contains("/CommonParameter { /Name:STF_SUITE_FLAVOR /Value:Suites }"));
        }

        [TestMethod]
        public void PrepareSyncroneousWttStfCall_Full_Arguments_Test()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();
            var expectedProcessLocation = @"C:\Program Files\WTT 2.2\Studio\wttcl.exe";
            var expectedProcessArgs = 
                @"schedulejob /DataStore:HxWTTController /JobId:13 /Wait:True /MachinePool:$\AutoNet /ExecutionTimeout { /Days:2 /Hours:0 /Minutes:0 } "+
            @"/CommonParameter { /Name:STF_SUITE_NAME /Value:LiveBVT.dll /FailIfParameterNotFound:False /LimitScopeTo:local } "+
            @"/CommonParameter { /Name:STF_SUITE_FLAVOR /Value:Suites } "+
            @"/CommonParameter { /Name:STF_ARGS /Value:""/env:AutoNet /freq:BVT"" /FailIfParameterNotFound:False /LimitScopeTo:local }";

            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription { Name = "LiveBVT", Architecture="32" }, "BVT", "AutoNet", 2);

            //Assert
            Assert.AreEqual(expectedProcessLocation, actualProcess.StartInfo.FileName);
            Assert.AreEqual(expectedProcessArgs, actualProcess.StartInfo.Arguments);
        }
        [TestMethod]
        public void PrepareSyncroneousWttStfCall_sets_up_Process_with_correct_timeout_when_timeout_is_positive()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();
            var timeoutString = "/ExecutionTimeout { /Days:2 /Hours:0 /Minutes:0 }";
            
            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription { Name = "LiveBVT" }, "BVT", "AutoNet", 2);

            //Assert
            Assert.IsTrue(actualProcess.StartInfo.Arguments.Contains(timeoutString));
        }

        [TestMethod]
        public void PrepareSyncroneousWttStfCall_sets_up_Process_with_no_timeout_if_timeout_value_is_negative()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();
            var timeoutString = "/ExecutionTimeout";

            //Act
            var actualProcess = target.PrepareSyncroneousWttStfCall(new TestDescription { Name = "LiveBVT" }, "BVT", "AutoNet", -1);

            //Assert
            Assert.IsFalse(actualProcess.StartInfo.Arguments.Contains(timeoutString));
        }

        [TestMethod]
        public void PrepareCancelAllCurrentOperationsOnWttClient_sets_up_Process_with_correct_arguments()
        {
            //Arrange
            WttStfPreparer target = new WttStfPreparer();
            var expectedProcessLocation = @"C:\Program Files\WTT 2.2\Controller\WTTCmd.exe";
            var expectedProcessArgs = "/CancelJob /TargetMachine:ATNCLIENT001";

            //Act
            var actualProcess = target.PrepareCancelAllCurrentOperationsOnWttClient("ATNCLIENT001");

            //Assert
            Assert.AreEqual(expectedProcessLocation, actualProcess.StartInfo.FileName);
            Assert.AreEqual(expectedProcessArgs, actualProcess.StartInfo.Arguments);
        }

        [TestMethod]
        public void StfArguments_Works_for_empty_envreqs_and_additional_params()
        {
            Assert.AreEqual("/env:AutoNet /freq:BVT", WttStfPreparer.StfArguments(new TestDescription(), "AutoNet", "BVT"));
        }

        [TestMethod]
        public void StfArguments_adds_nonempty_envreq()
        {
            Assert.AreEqual("/env:AutoNet /freq:BVT /EnvReq:Billing,Catalog",
                WttStfPreparer.StfArguments(new TestDescription{EnvRequirement = "Billing,Catalog"}, "AutoNet", "BVT"));
        }

        [TestMethod]
        public void StfArguments_adds_Additional_Params()
        {
            Assert.AreEqual("/env:AutoNet /freq:BVT Params",
                WttStfPreparer.StfArguments(new TestDescription { AdditionalParameters = "Params" }, "AutoNet", "BVT"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TFSUploader\ProcessRunner.cs ===
﻿using System;
using System.Diagnostics;
using System.Text;

namespace xonline.test.deployment.automation.tfsuploader
{
	internal class ProcessRunner
	{
        private StringBuilder _output;
        public ProcessRunner(StringBuilder output)
        {
            _output = output;
        }

        public int Run(string executable, string arguments)
        {
            Process p = new Process();
            p.StartInfo.FileName = executable;
            p.StartInfo.Arguments = arguments;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.ErrorDataReceived += new DataReceivedEventHandler(OutputDataHandler);
            p.OutputDataReceived += new DataReceivedEventHandler(OutputDataHandler);
            p.Start();
            p.BeginOutputReadLine();
            p.BeginErrorReadLine();
            p.WaitForExit();
            return p.ExitCode;
        }

        private void OutputDataHandler(object sendingProcess, DataReceivedEventArgs e)
        {
            if (!String.IsNullOrEmpty(e.Data))
                _output.Append(e.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\WttStfTaskModule\WttStfTaskModuleUnitTests\TestListParserTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.MMF;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.wttstftaskmodule;

namespace WttStfTaskModuleUnitTests
{
    /// <summary>
    /// Summary description for TestListParserTests
    /// </summary>
    [TestClass]
    public class TestListParserTests
    {
        [TestMethod]
        public void Parse_returns_empty_list_if_there_are_no_test_cases()
        {
            //Arrange
            TestListParser parser = new TestListParser();

            //Act
            var actual = parser.ParseTestList("<tests/>");
            
            //Assert
            Assert.AreEqual(0, actual.Count());
        }

        [TestMethod]
        public void Parse_returns_correct_list()
        {
            //Arrange
            TestListParser parser = new TestListParser();
            var testXml =
                @"<tests>  <test Name='MsgToolTest' Type='STF' Architecture='32' TestFrequency='Full' EnvRequirement='Billing,Catalog' />
  <test Name='PresTest' Type='STF' Architecture='32' TestFrequency='Full' EnvRequirement='Billing,Catalog' /></tests>";

            //Act
            var actual = parser.ParseTestList(testXml);

            //Assert
            Assert.AreEqual(2, actual.Count());
            Assert.AreEqual(1, actual.Count(td => td.Name=="MsgToolTest"));
            Assert.AreEqual(1, actual.Count(td => td.Name == "PresTest"));
        }

        [TestMethod]
        public void Parse_Can_Extract_Attributes()
        {
            //Arrange
            TestListParser parser = new TestListParser();
            var testXml =
                @"<tests>  <test Name='MsgToolTest' Type='STF' Architecture='32' TestFrequency='Full' EnvRequirement='Billing,Catalog' /></tests>";

            //Act
            var td = parser.ParseTestList(testXml).First();

            //Assert
            Assert.AreEqual("MsgToolTest", td.Name);
            Assert.AreEqual("32", td.Architecture);
            Assert.AreEqual("Billing,Catalog", td.EnvRequirement);
            Assert.IsNull(td.AdditionalParameters);
        }

        [TestMethod]
        public void Parse_Extracts_Optional_Parameters()
        {
            TestListParser parser = new TestListParser();
            var testXml =
                @"<tests>  <test Name='MsgToolTest' Type='STF' Architecture='32' TestFrequency='Full' EnvRequirement='Billing,Catalog' AdditionalParameters='params' /></tests>";

            var td = parser.ParseTestList(testXml).First();

            Assert.AreEqual("params", td.AdditionalParameters);
        }
        [TestMethod]
        [ExpectedException(typeof(System.IO.FileNotFoundException))]
        public void Parse_throws_IOException_if_file_does_not_exist()
        {
            //Arrange
            TestListParser parser = new TestListParser();

            //Act
            var actual = parser.ParseFileToList(@"C:\foobarbaz.txt");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TFSUploader\TFSUploaderConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.tfsuploader
{
	internal class TFSUploaderConfig
	{
        private string _location;

        public string BaseDirectory { get; private set; }
        public string ArchiveDirectory { get; private set; }
        public string LogsBaseDirectory { get; private set; }
        public List<ParamDef> RequiredParams {get; private set;}
        public string UploaderExe { get; private set; }

        public TFSUploaderConfig(string location)
        {
            _location = location;
        }

        public void LoadConfig()
        {
            XPathDocument doc = new XPathDocument(_location);
            XPathNavigator docNav = doc.CreateNavigator();
            docNav.MoveToChild(XPathNodeType.Element);

            if (String.Compare(docNav.Name, "TFSUploader", true) != 0)
                throw new ApplicationException(String.Format("Invalid config file - bad root element: {0}", docNav.Name));

            // Walk the list of child elements
            XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
            if (itor.Count == 0)
                throw new ApplicationException("Invalid config file - the root element contains no child elements.");
            while (itor.MoveNext())
            {
                switch (itor.Current.Name.ToLower())
                {
                    case "basedirectory":
                        BaseDirectory = System.IO.Path.GetFullPath(itor.Current.Value);
                        break;
                    case "archivedirectory":
                        ArchiveDirectory = System.IO.Path.GetFullPath(itor.Current.Value);
                        break;
                    case "logsbasedirectory":
                        LogsBaseDirectory = System.IO.Path.GetFullPath(itor.Current.Value);
                        break;
                    case "uploader":
                        {
                            UploaderExe = itor.Current.GetAttribute("Path", docNav.NamespaceURI);
                            // Walk the parameter list
                            XPathNodeIterator paramItor = itor.Current.SelectChildren(XPathNodeType.Element);
                            RequiredParams = new List<ParamDef>();
                            while (paramItor.MoveNext())
                            {
                                if (String.Compare(paramItor.Current.Name, "Parameter", true) == 0)
                                {
                                    ParamDef def = new ParamDef(paramItor.Current.GetAttribute("Name", docNav.NamespaceURI),
                                        paramItor.Current.GetAttribute("Value", docNav.NamespaceURI));
                                    RequiredParams.Add(def);
                                }
                            }
                        }
                        break;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TFSUploader\TFSUploader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.ServiceProcess;
using System.Text;
using System.Threading;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.tfsuploader
{
	public class TFSUploader : XLFServiceBase
	{
        private const string RESULT_FILE_PATTERN = "*.xml";

        private object _syncLock = new object();
        private TFSUploaderConfig _config;
        private FileSystemWatcher _tfsWatcher;
        private Queue<string> _resultFiles = null;
        private List<string> _inProgress = null;
        private short _maxThreads = 2;
        private Thread _queueThread = null;
        private List<ThreadInfo> _threadPool = null;
        private AutoResetEvent _startQueue = null;
        private AutoResetEvent _shutdown = null;
        private bool _drain = false;
        private int _filesProcessed = 0;
        private int _filesSucceeded = 0;
        private int _filesFailed = 0;
        private DateTime _startDateTime = DateTime.MinValue;

        public TFSUploader() : base()
        {
#if DEBUG
            DACommon.LogLevel = LoggingLevel.Debug;
#endif
            CanStop = true;
            CanShutdown = true;
            CanPauseAndContinue = true;
            ServiceName = "TFSUploader";
            AutoLog = false;

            // Add the supported commands
            LogEvent(LoggingLevel.Debug, "Adding command handlers");
            AddCommandHandler("Status", Status);
            AddCommandHandler("Drain", Drain);
            AddCommandHandler("ProcessFile", ProcessFile);
        }

        protected override void OnStart(string[] args)
        {
            // Keep track of the timestamp when the service was started
            _startDateTime = DateTime.Now;

            // Create the worker thread pool (empty, of course)
            _threadPool = new List<ThreadInfo>(_maxThreads);

            // Calling the base starts the communication thread
            base.OnStart(args);

            // Create 2 events
            _startQueue = new AutoResetEvent(false);
            _shutdown = new AutoResetEvent(false);

            // First load the configuration file
            // The configuration xml file must be in the same directory as the service exe
            string configXmlPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "TFSUploader.xml");
            LogEvent(LoggingLevel.Debug, "Loading the configuration file from '{0}'", configXmlPath);
            _config = new TFSUploaderConfig(configXmlPath);
            try
            {
                _config.LoadConfig();
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Error, "Unable to load the configuration file:\r\n{0}", ex);
                return;
            }

            // Create 2 lists: One that contains all the files that need to be processed
            // and one that contains the list of files currently being processed
            _resultFiles = new Queue<string>();
            _inProgress = new List<string>();

            // Start the queue processing thread
            LogEvent(LoggingLevel.Debug, "Starting the Queue Processing thread.");
            _queueThread = new Thread(new ThreadStart(ProcessQueue));
            _queueThread.Name = "Queue Processor";
            _queueThread.Start();

            // Before beginning to watch for files, crawl the directory
            // structure looking for existing result files that require processing
            LogEvent(LoggingLevel.Debug, "Building the initial filelist.");
            BuildResultFileList(_config.BaseDirectory);
            if (_resultFiles.Count > 0)
                _startQueue.Set();

            // Start the file watcher
            LogEvent(LoggingLevel.Debug, "Starting the file watcher.");
            try
            {
                _tfsWatcher = new FileSystemWatcher(_config.BaseDirectory, RESULT_FILE_PATTERN);
                _tfsWatcher.Created += new FileSystemEventHandler(OnTFSFileCreated);
                _tfsWatcher.IncludeSubdirectories = true;
                _tfsWatcher.EnableRaisingEvents = true;
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Error, "The FileWatcher could not be created for the path '{0}':\r\n{1}", _config.BaseDirectory, ex);
            }
        }

        protected override void OnStop()
        {
            base.OnStop();
            _shutdown.Set();
        }

        protected override void OnShutdown()
        {
            base.OnShutdown();
            _shutdown.Set();
        }

        private void BuildResultFileList(string directory)
        {
            string[] dirs = null;
            try
            {
                // If this call throws, then we likely will not be able to get the file list, either
                dirs = Directory.GetDirectories(directory);
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Warning, "Unable to get a sub-directory list for '{0}':\r\n{1}", directory, ex);
                return;
            }

            // Process each subdirectory first
            foreach (string dir in dirs)
            {
                BuildResultFileList(dir);
            }

            string[] files = null;
            try
            {
                files = Directory.GetFiles(directory, RESULT_FILE_PATTERN);
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Warning, "Unable to get a file list for '{0}':\r\n{1}", directory, ex);
                return;
            }

            foreach (string file in files)
            {
                Enqueue(file);
            }
        }

        private void OnTFSFileCreated(object sender, FileSystemEventArgs e)
        {
            // If the queue doesn't contain this file, add it
            if (!QueueContains(e.FullPath))
            {
                Enqueue(e.FullPath);
                _startQueue.Set();
            }
        }

        private void ProcessQueue()
        {
#if DEBUG
            Thread.Sleep(30000);
#endif
            List<WaitHandle> waitHandles = new List<WaitHandle>();

            // Build the initial list of wait handles
            // the first 2 are for the QueueStart and Shutdown events
            // the rest are for the processing threads
            waitHandles.Add(_startQueue);
            waitHandles.Add(_shutdown);

            while (true)
            {
                int waitIndex = WaitHandle.WaitAny(waitHandles.ToArray());
                if (waitIndex == 0)
                {
                    // If we're trying to drain the queue, don't add any more threads
                    if (!_drain)
                    {
                        // The queue is being signalled to start, or a file has been added to the queue
                        while ((_threadPool.Count <= _maxThreads) && _resultFiles.Count > 0)
                        {
                            ThreadInfo worker = new ThreadInfo(new ParameterizedThreadStart(UploadTFSFile));
                            worker.Thread.Name = "QueueThread";
                            worker.FileName = Dequeue();
                            // A null filename means there are no more items in the queue
                            if (worker.FileName != null)
                            {
                                worker.DoneEvent.Reset();
                                waitHandles.Add(worker.DoneEvent);
                                _threadPool.Add(worker);
                                worker.Thread.Start(worker);
                            }
                        }
                    }
                }
                else if (waitIndex == 1)
                {
                    // The shutdown event has been signalled
                    for (int i = 0; i < _threadPool.Count; i++)
                        _threadPool[i].Thread.Abort();
                    break;
                }
                else
                {
                    int threadIndex = waitIndex - 2;
                    if (threadIndex < 0)
                    {
                        LogEvent(LoggingLevel.Error, "Invalid threadIndex {0} from waitIndex {1}.", threadIndex, waitIndex);
                        ((ManualResetEvent)waitHandles[waitIndex]).Reset();
                        continue;
                    }

                    // Remove the completed thread from the pool
                    _threadPool.RemoveAt(threadIndex);
                    waitHandles.RemoveAt(waitIndex);

                    // If we're trying to drain the queue, don't process more files
                    if (!_drain)
                    {
                        // Set the Start Queue event to create more queue worker threads
                        _startQueue.Set();
                    }
                }
            }
        }

        private void UploadTFSFile(object data)
        {
            if (null == data)
            {
                LogEvent(LoggingLevel.Error, "The data passed into the '{0}' thread is null. Very bad.", Thread.CurrentThread.Name);
                return;
            }

            ThreadInfo tinfo = data as ThreadInfo;
            if (null == tinfo)
            {
                // Someone passed in some bad data
                LogEvent(LoggingLevel.Error, "The data passed into the thread '{0}' was of type '{1}' instead of a ThreadInfo object.",
                    Thread.CurrentThread.Name, data.GetType().Name);
                return;
            }

            try
            {
                // The name of the results file contains all the information we need to upload into TFS:
                // <suiteName>-<env>-<build>-<version>-<frequency>-<yyyyMMddHHmmss>.xml
                string[] tfsData = Path.GetFileNameWithoutExtension(tinfo.FileName).Split('-');
                if (tfsData.Length != 6)
                {
                    LogEvent(LoggingLevel.Error, "The result file '{0}' does not have a valid filename. Automation results have an expected filename in the form:\r\n<suiteName>-<env>-<build>-<version>-<frequency>-<yyyyMMddHHmmss>.xml",
                        tinfo.FileName);
                    tinfo.DoneEvent.Set();
                    return;
                }

                StringBuilder args = new StringBuilder();
                foreach (ParamDef param in _config.RequiredParams)
                {
                    switch (param.ParamValue)
                    {
                        case "##ArchivePath##":
                            args.AppendFormat(" /{0}:\"{1}\"", param.ParamName, _config.ArchiveDirectory);
                            break;
                        case "##BuildName##":
                            args.AppendFormat(" /{0}:{1}", param.ParamName, tfsData[2]);
                            break;
                        case "##BuildVersion##":
                            args.AppendFormat(" /{0}:{1}", param.ParamName, tfsData[3]);
                            break;
                        case "##FileName##":
                            args.AppendFormat(" /{0}:\"{1}\"", param.ParamName, tinfo.FileName);
                            break;
                        case "##Frequency##":
                            args.AppendFormat(" /{0}:{1}", param.ParamName, tfsData[4]);
                            break;
                        case "##LogPath##":
                            args.AppendFormat(" /{0}:\"{1}\\{2}\\TestPassResults\\{3}\\{4}\"", param.ParamName,
                                _config.LogsBaseDirectory, tfsData[1], tfsData[2], tfsData[3]);
                            break;
                        case "##Environment##":
                            args.AppendFormat(" /{0}:{1}", param.ParamName, tfsData[1]);
                            break;
                        default:
                            {
                                if (param.ParamValue.StartsWith("##"))
                                {
                                    LogEvent(LoggingLevel.Warning, "Unknown token in the TfsPublishResults command line definition: '{0}'", param.ParamValue);
                                }
                                else
                                {
                                    // Use the literal value
                                    args.AppendFormat(" /{0}:{1}", param.ParamName, param.ParamValue);
                                }
                            }
                            break;
                    }
                }

                // Run the uploader
                LogEvent(LoggingLevel.Information, "Calling {0} {1}", _config.UploaderExe, args.ToString());
                if (File.Exists(_config.UploaderExe))
                {
                    StringBuilder output = new StringBuilder();
                    ProcessRunner procRunner = new ProcessRunner(output);
                    int retValue = 0;
                    bool runFinished = true;
                    try
                    {
                        retValue = procRunner.Run(_config.UploaderExe, args.ToString());

                        // Take the lock only to update the file counts
                        lock (_syncLock)
                        {
                            _filesProcessed++;
                            if (retValue == 0)
                                _filesSucceeded++;
                            else
                                _filesFailed++;
                        }
                    }
                    catch (Exception ex)
                    {
                        LogEvent(LoggingLevel.Error, "An exception occurred while processing the result file '{0}':\r\n{1}", tinfo.FileName, ex);
                        runFinished = false;
                    }

                    if (runFinished)
                    {
                        // Perform any post-processing
                        string trxFile = tinfo.FileName + ".trx";

                        // Move the result xml file to the appropriate bin
                        try
                        {
                            MoveResultFile(tinfo.FileName, (0 == retValue));
                        }
                        catch (Exception ex)
                        {
                            LogEvent(LoggingLevel.Error, "Unable to move the results file '{0}' to '{1}':\r\n{2}", tinfo.FileName, _config.ArchiveDirectory, ex);
                        }

                        // Delete the intermediate trx file
                        try
                        {
                            File.Delete(trxFile);
                        }
                        catch (Exception ex)
                        {
                            LogEvent(LoggingLevel.Error, "Unable to delete the file '{0}':\r\n{1}", trxFile, ex);
                        }
                    }
                }
                else
                {
                    LogEvent(LoggingLevel.Error, "The specified uploader exe location is invalid: '{0}'", _config.UploaderExe);
                }
            }
            catch (ThreadAbortException)
            {
                LogEvent(LoggingLevel.Information, "Thread '{0}' has been aborted. Poor thread - it was never given a chance at life...", Thread.CurrentThread.Name);
                return;
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Error, "An execption occurred while processing a results file:\r\nThread: {0}\r\nFile: {1}\r\nException:\r\n{2}",
                    Thread.CurrentThread.Name, tinfo.FileName, ex);
            }

            // Signal completion
            tinfo.DoneEvent.Set();
        }

        private void MoveResultFile(string filename, bool succeeded)
        {
            string dst = Path.Combine(Path.Combine(_config.ArchiveDirectory, succeeded ? "Succeeded" : "Failed"), Path.GetFileName(filename));

            // Copy the file, then delete it
            File.Copy(filename, dst, true);
            File.Delete(filename);
        }

        #region Protected Queue Access Methods
        private void Enqueue(string fileName)
        {
            if (_resultFiles != null)
            {
                lock (_resultFiles) { _resultFiles.Enqueue(fileName.ToLower()); }
            }
        }

        private string Dequeue()
        {
            string ret = null;
            if (_resultFiles != null && _resultFiles.Count > 0)
            {
                lock (_resultFiles) { ret = _resultFiles.Dequeue(); }
            }
            return ret;
        }

        private bool QueueContains(string fileName)
        {
            bool ret = false;
            if (_resultFiles != null && _resultFiles.Count > 0)
            {
                lock (_resultFiles) { ret = _resultFiles.Contains(fileName.ToLower()); }
            }
            return ret;
        }
        #endregion

        #region Command Handlers
        private string Status(string parameters)
        {
            StringBuilder status = new StringBuilder();

            // Check to see if the Queue thread is running
            status.AppendLine("Queue Thread:");
            if (_queueThread != null)
            {
                status.AppendFormat("  Name:{0}\r\n", _queueThread.Name);
                status.AppendFormat("  IsAlive:{0}\r\n", _queueThread.IsAlive);
                status.AppendFormat("  There are {0} files in the processing queue.\r\n", _resultFiles.Count);
            }
            else
            {
                status.AppendLine("  The Queue thread does not exist.");
            }

            // Check the state of the FileSystemWatcher
            status.AppendLine("Results File Watcher:");
            if (_tfsWatcher != null)
            {
                status.AppendFormat("  Path:{0}\r\n", _tfsWatcher.Path);
                status.AppendFormat("  Filter:{0}\r\n", _tfsWatcher.Filter);
                status.AppendFormat("  IncludeSubdirectories:{0}\r\n", _tfsWatcher.IncludeSubdirectories);
                status.AppendFormat("  EventsEnabled:{0}\r\n", _tfsWatcher.EnableRaisingEvents);
            }
            else
            {
                status.AppendLine("  The results file watcher doesn't exist.");
            }

            // List out the processing threads
            status.AppendLine("Processing Threads:");
            if (_threadPool != null && _threadPool.Count > 0)
            {
                for (int i = 0; i < _threadPool.Count; i++)
                {
                    // Be careful - a thread may exit while we're in this loop
                    if (i < _threadPool.Count)
                    {
                        ThreadInfo info = _threadPool[i];
                        status.AppendFormat("  Thread:{0}\r\n", info.Thread.Name);
                        status.AppendFormat("  File Name:{0}\r\n", info.FileName);
                    }
                }

                // Report if the processing threads are being drained
                if (_drain)
                    status.AppendLine("  The processing threads are being drained.");
            }
            else
            {
                status.AppendLine("  There are no result files being processed at this time.");
            }

            // Output the statistics for this instance
            status.AppendLine("Processing Statistics:");
            status.AppendFormat("  Total Uptime: {0}\r\n", DateTime.Now.Subtract(_startDateTime));
            status.AppendFormat("  Files Processed: {0}\r\n", _filesProcessed);
            status.AppendFormat("  Files Successful: {0}\r\n", _filesSucceeded);
            status.AppendFormat("  Files Failed: {0}\r\n", _filesFailed);

            return status.ToString();
        }

        private string Drain(string parameters)
        {
            _drain = true;
            return _drain.ToString();
        }

        /* Expected command string: processfile <fileName> */
        private string ProcessFile(string parameters)
        {
            string ret = "";

            try
            {
                // The parameter should just be a filename
                // if there is no path information, assume it is in the BaseDirectory
                string fileName;
                if (!Path.IsPathRooted(parameters))
                    fileName = Path.Combine(_config.BaseDirectory, parameters);
                else
                    fileName = parameters;

                fileName = fileName.ToLower();

                // Add the file to the queue
                if (_resultFiles != null)
                {
                    if (!QueueContains(fileName))
                    {
                        // Check all the processing threads to see if this file is currently being processed
                        bool addFile = true;
                        foreach (ThreadInfo ti in _threadPool)
                        {
                            if (String.Compare(ti.FileName, fileName, true) == 0)
                            {
                                ret = String.Format("'{0}' is being processed on the '{1}' thread.", fileName, ti.Thread.Name);
                                addFile = false;
                                break;
                            }
                        }

                        if (addFile)
                        {
                            Enqueue(fileName);
                            _startQueue.Set();
                            ret = String.Format("Added '{0}' to the processing queue.", fileName);
                        }
                    }
                    else
                    {
                        ret = String.Format("'{0}' already exists in the processing queue.", fileName);
                    }
                }
                else
                {
                    ret = String.Format("The processing queue has not been set up - unable to add '{0}' to it.", fileName);
                }
            }
            catch (Exception ex)
            {
                ret = String.Format("Unable to add '{0}' to the processing queue: {1}", parameters, ex.Message);
            }

            return ret;
        }
        #endregion

        #region Main entry point
        static void Main(string[] args)
        {
            if (args.Length > 0)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i][0] == '/' || args[i][0] == '-')
                    {
                        string cmd = args[i].Substring(1);
                        switch (cmd.ToLower())
                        {
                            case "install":
                            case "i":
                                {
                                }
                                break;
                            case "uninstall":
                            case "u":
                                {
                                }
                                break;
                            default:
                                Console.WriteLine("Unknown command line parameter: " + args[i]);
                                break;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Invalid command line parameter: " + args[i]);
                    }
                }
            }
            else
            {
                ServiceBase[] ServicesToRun;
                ServicesToRun = new ServiceBase[] 
                { 
				    new TFSUploader() 
                };
                ServiceBase.Run(ServicesToRun);
            }
        }
        #endregion
	}

    internal class ParamDef
    {
        public string ParamName { get; private set; }
        public string ParamValue { get; private set; }
        public ParamDef(string name, string value)
        {
            ParamName = name;
            ParamValue = value;
        }
    }

    internal class ThreadInfo
    {
        public string FileName { get; set; }
        public Thread Thread { get; private set; }
        public ManualResetEvent DoneEvent { get; private set; }

        public ThreadInfo(ParameterizedThreadStart target)
        {
            FileName = "";
            Thread = new Thread(target);
            DoneEvent = new ManualResetEvent(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TFSUploader\TFSUploaderInstaller.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.ServiceProcess;

namespace xonline.test.deployment.automation.tfsuploader
{
    [RunInstaller(true)]
    public class TFSUploaderInstaller : Installer
    {
        private ServiceProcessInstaller _processInstaller;
        private ServiceInstaller _tfsUploaderInstaller;

        public TFSUploaderInstaller()
        {
            _processInstaller = new ServiceProcessInstaller();
            _processInstaller.Account = ServiceAccount.User;

            _tfsUploaderInstaller = new ServiceInstaller();
            _tfsUploaderInstaller.ServiceName = "TFSUploader";
            _tfsUploaderInstaller.DisplayName = "Xbox LIVE TFS Uploader";
            _tfsUploaderInstaller.Description = "Uploads automation results into TFS.";
            _tfsUploaderInstaller.StartType = ServiceStartMode.Automatic;

            Installers.Add(_tfsUploaderInstaller);
            Installers.Add(_processInstaller);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\Environments.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

using xonline.test.deployment.automation.bdservice;
using xonline.test.deployment.automation.taskmodules.vmtaskmodule;

public partial class Environments : System.Web.UI.Page
{
    private const int EnvLockedColumn = 0;
    private const int EnvNameColumn = 1;
    private const int EnvPrefixColumn = 2;
    private const int EnvHostListColumn = 3;
    private const int EnvStagerColumn = 4;
    private const int EnvBuildColumn = 5;
    private const int EnvTitleColumn = 6;

    private UserPrivileges _userPrivs = null;

    protected void Page_Load(object sender, EventArgs e)
    {
        // Load the user's privileges
        _userPrivs = new UserPrivileges(Request.LogonUserIdentity.Name);

        RefreshEnvList();
    }

    private void RefreshEnvList()
    {
        DataTable dt = GetEnvironments();
        gvEnvList.DataSource = dt;
        gvEnvList.DataBind();
        gvEnvList.SelectedIndex = -1;

        pnlEnvList_Content.Update();
    }

    private DataTable GetEnvironments()
    {
        DataTable dt = null;
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM vw_Portal_Envs ORDER BY Name ASC";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    dt = new DataTable();
                    da.Fill(dt);
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }

        return dt;
    }

    private DataTable GetSubEnvironments(long envId)
    {
        DataTable dt = null;
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM vw_Portal_SubEnvs WHERE ParentID = " + envId.ToString() + " ORDER BY Name ASC";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    dt = new DataTable();
                    da.Fill(dt);
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }

        return dt;
    }

    private EnvironmentInfo GetEnvironment(long envId)
    {
        EnvironmentInfo env = null;
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "p_env_get_environment_by_id";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@envId", envId);

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            env = new EnvironmentInfo();
                            env.Id = (long)reader["i_env_id"];
                            env.Name = reader["vc_environment_name"] as string;
                            env.UserName = reader["vc_user_name"] as string;
                            env.StagerName = reader["vc_stager_name"] as string;
                            env.BuildShare = reader["vc_build_share"] as string;
                            env.TitlesShare = reader["vc_titles_share"] as string;
                            env.ServerPrefix = reader["vc_machine_prefix"] as string;
                            env.HostList = reader["vc_hostList"] as string;
                            env.Virtual = (Boolean)reader["b_is_virtual"];
                            env.DNSFlipped = (Boolean)reader["b_is_dns_flipped"];
                            env.ClientPoolIpBegin = reader["vc_clientpool_ip_begin"] as string;
                            env.ClientPoolIpEnd = reader["vc_clientpool_ip_end"] as string;
                            env.ClientPoolGateway = reader["vc_clientpool_gateway"] as string;
                            env.ClientPoolNetmask = reader["vc_internet_netmask"] as string;
                            env.INHInternetIp = reader["vc_inh_internet_ip"] as string;
                            env.InternetGateway = reader["vc_internet_gateway"] as string;
                            env.InternetNetmask = reader["vc_internet_netmask"] as string;
                            env.SGInternetIp = reader["vc_sg_internet_ip"] as string;
                            env.SGAdminIp = reader["vc_sg_admin_ip"] as string;
                            env.XDSInternetIp = reader["vc_xds_internet_ip"] as string;
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }

        return env;
    }

    protected void GetEnvironmentSnapshots(string hostList, string envPrefix)
    {
        string[] hosts = hostList.Split(',');
        foreach (string host in hosts)
        {
            HyperVHost hvh = new HyperVHost(host, "HYPER\\Octopus", "XblC0reP");
            hvh.BeginConnect(connResult =>
            {
                hvh.EndConnect(connResult);
                hvh.BeginGetVirtualMachineList(envPrefix + "%", getVMResult =>
                {
                    VirtualMachines vms = hvh.EndGetVirtualMachineList(getVMResult);
                    foreach (VirtualMachine vm in vms)
                    {
                        vm.BeginGetSnapshotList(SnapshotSortMethod.NameAscending, getSSResult =>
                        {
                            VirtualMachine vm1 = getSSResult.AsyncState as VirtualMachine;
                            Snapshots snapshots = vm1.EndGetSnapshotList(getSSResult);
                            MergeSnapshots(snapshots);
                        },
                        vm);
                    }
                },
                null);
            },
            null);
        }
    }

    private void MergeSnapshots(Snapshots snapShots)
    {
    }

    protected void mnuMainMenu_MenuItemClick(Object sender, MenuEventArgs e)
    {
    }

//    protected void tvEnvList_TreeNodePopulate(Object sender, TreeNodeEventArgs e)
//    {
//        DataTable dt = GetEnvironments();
//        if (dt != null)
//        {
//            foreach (DataRow row in dt.Rows)
//            {
//                TreeNode node = new TreeNode();
//                node.Text = row["Name"] as string;
//                node.Value = row["ID"].ToString();
//                if (Convert.ToBoolean(row["Locked"]))
//                    node.ImageUrl = "Images\\Lock_icon_sm.png";
//                if (Convert.ToBoolean(row["DNSFlipped"]))
//                {
//                    // This environment is DNS flipped, so we need to get the names of it's sub-environments
//                    DataTable subs = GetSubEnvironments((long)row["ID"]);
//                    if (subs != null)
//                    {
//                        foreach (DataRow subRow in subs.Rows)
//                        {
//                            TreeNode subNode = new TreeNode();
//                            subNode.Text = subRow["Name"] as string;
//                            subNode.Value = subRow["ID"].ToString();
//                            node.ChildNodes.Add(subNode);
//                            node.Expanded = false;
//                            node.SelectAction = TreeNodeSelectAction.SelectExpand;
//                        }
//                    }
//                }
//                e.Node.ChildNodes.Add(node);
//            }
//        }
//    }

//    protected void tvEnvList_SelectedNodeChanged(Object sender, EventArgs e)
//    {
//        if (tvEnvList.SelectedNode != null)
//        {
//            long envId = long.Parse(tvEnvList.SelectedNode.Value);
//            EnvironmentInfo env = GetEnvironment(envId);
//            if (env != null)
//            {
//                lblEnvironmentName.Text = env.Name;
//                lblServerPrefix.Text = env.ServerPrefix;
//                lblUserAccount.Text = env.UserName;
//                lblStager.Text = env.StagerName;
//                lblBuildShare.Text = env.BuildShare;
//                lblTitleSourceShare.Text = env.TitlesShare;
//                lblVirtual.Text = env.Virtual.ToString();
//                if (!String.IsNullOrEmpty(env.HostList))
//                    lblHostList.Text = env.HostList;
//                else
//                    lblHostList.Text = "N/A";

////                GetEnvironmentSnapshots(env.HostList);
//            }
//        }

//        pnlEnvDetails_Content.Update();
//    }

    //protected void gvEnvServerList_RowDataBound(Object sender, GridViewRowEventArgs e)
    //{
    //    if (e.Row.RowType != DataControlRowType.DataRow)
    //        return;

    //    DataRowView data = e.Row.DataItem as DataRowView;
    //    e.Row.Cells[0].Text = data["ServerName"] as string;
    //}

    protected void gvEnvList_RowDataBound(Object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType != DataControlRowType.DataRow)
            return;

        DataRowView data = e.Row.DataItem as DataRowView;

        // Add the Environment name as an attribute of the row
        e.Row.Attributes.Add("EnvName", data["Name"].ToString());
        e.Row.Attributes.Add("EnvId", data["ID"].ToString());

        // If the environment is locked, display the lock icon
        e.Row.Cells[EnvLockedColumn].Width = 12;

        if (Convert.ToBoolean(data["Locked"]))
        {
            e.Row.Cells[EnvLockedColumn].Text = "<img alt=\"\" src=\"Images\\Lock_icon.png\" width=\"12\" height=\"12\" style=\"vertical-align: bottom\" />";
        }
        else
        {
            e.Row.Cells[EnvLockedColumn].Text = "";
        }
        /*
        (e.Row.Cells[0].Controls[1] as LinkButton).CommandArgument = data["ID"].ToString();
        // If the environment is locked, add the lock icon to the text of the link
        if (Convert.ToBoolean(data["Locked"]))
        {
            (e.Row.Cells[0].Controls[1] as LinkButton).Text = data["Name"].ToString() + "&nbsp;<img alt=\"\" src=\"Images\\Lock_icon.png\" width=\"12\" height=\"12\" border=\"none\" style=\"vertical-align: bottom\" />";
        }
        else
        {
            (e.Row.Cells[0].Controls[1] as LinkButton).Text = data["Name"].ToString();
        }
        */
    }

    protected void gvEnvList_SelectedItemChanged(Object sender, EventArgs e)
    {
        if (gvEnvList.SelectedIndex >= 0)
        {
            // Update the details pages
            //UpdateEnvironmentDetails(long.Parse(gvEnvList.SelectedRow.Attributes["Id"]));
        }
    }

    protected void pnlActionList_OnPreRender(Object sender, EventArgs e)
    {
        // Find the containing DataGridRow
        GridViewRow gvRow = (sender as Control).Parent.Parent as GridViewRow;
        if (gvRow != null)
        {
            string envName = gvRow.Attributes["EnvName"];
            bool locked = gvRow.Cells[EnvLockedColumn].Text.Length > 0;

            // Enable/Disable the Action LinkButtons
            foreach (Control ctrl in (sender as Control).Controls)
            {
                if (ctrl is LinkButton)
                {
                    LinkButton lb = (ctrl as LinkButton);
                    lb.Enabled = Utils.GetEnvCommandEnableState(lb.CommandName, _userPrivs.GetPrivileges(envName));
                    if ("LockEnv" == lb.CommandName)
                    {
                        if (locked)
                            lb.Text = "Unlock";
                        else
                            lb.Text = "Lock";
                    }
                }
            }
        }
    }

    protected void Action_Click(Object sender, CommandEventArgs e)
    {
        GridViewRow gvRow = (sender as Control).Parent.Parent.Parent as GridViewRow;

        // Close the popup
        AjaxControlToolkit.PopupControlExtender.GetProxyForCurrentPopup(Page).Commit(e.CommandArgument as string);

        // The environment name is an attribute of the row
        string envName = gvRow.Attributes["EnvName"];
        bool locked = gvRow.Cells[EnvLockedColumn].Text.Length > 0;

        switch (e.CommandName)
        {
            case "LockEnv":
                Utils.SetEnvLock(envName, !locked);
                RefreshEnvList();
                break;
            case "EditEnv":
                break;
            case "DeleteEnv":
                break;
        }
    }

    protected void lblEnvName_Command(object sender, CommandEventArgs e)
    {
        if (e.CommandName == "EnvSelect")
        {
//            mpeEditEnvironment.Show();
        }
    }

    private void ShowEditEnvironmentDialog(long envId, bool create)
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\JobDetails.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

using xonline.test.deployment.automation.common;

public partial class JobDetails : System.Web.UI.Page
{
    private const int TaskIDColumn = 0;
    private const int TaskStateColumn = 1;
    private const int TaskNameColumn = 2;
    private const int TaskStartColumn = 3;
    private const int TaskDurationColumn = 4;
    private const int TaskLogsColumn = 5;

    private const string Session_CurrentJob = "CurrentJob";

    private string currentGroup = "";
    private long _jobId = 0;
    private UserPrivileges _userPrivs = null;

    protected void Page_Load(object sender, EventArgs e)
    {
        Response.Cache.SetCacheability(HttpCacheability.NoCache);

        // Load the user's privileges
        _userPrivs = new UserPrivileges(Request.LogonUserIdentity.Name);

        if (!Int64.TryParse(Request.QueryString["JobId"], out _jobId))
        {
            Response.Write("Need to pass a JobId in the query string.");
            Response.End();
        }

        Session[Session_CurrentJob] = _jobId;
        Job currentJob = Utils.GetJobDetails(_jobId);
        if (currentJob != null)
        {
            lblJobDetailPanelHeader.Text = String.Format("'{0}' Details", currentJob.Name);
            PopulateDetailsPane(currentJob);
            pnlJobDetails_Content.Update();
            RefreshTaskList();

            // If the job is complete, disable the timer
            if (currentJob.State == JobState.Complete)
            {
                tmrTaskList.Enabled = false;
                lblTaskListLastRefresh.Visible = false;
            }
        }
    }

    private void PopulateDetailsPane(string jobId)
    {
        Int64 id = 0;
        Int64.TryParse(jobId, out id);
        PopulateDetailsPane(id);
    }
    private void PopulateDetailsPane(Int64 jobId) { PopulateDetailsPane(Utils.GetJobDetails(jobId)); }
    private void PopulateDetailsPane(Job job)
    {
        lblJobDetails_JobID.Text = job.Id.ToString();
        lblJobDetails_Status.Text = job.State.ToString();
        lblJobDetails_Result.Text = job.Result.ToString();
        switch (job.State)
        {
            case JobState.NotReady:
                lblJobDetails_Status.ForeColor = Color.Black;
                lblJobDetails_Status.Text = "Not Ready";
                break;
            case JobState.Ready:
                lblJobDetails_Status.ForeColor = Color.MidnightBlue;
                break;
            case JobState.Running:
                lblJobDetails_Status.ForeColor = Color.Blue;
                break;
            case JobState.Paused:
                lblJobDetails_Status.ForeColor = Color.OrangeRed;
                break;
            case JobState.Complete:
                switch (job.Result)
                {
                    case Result.Succeeded:
                        lblJobDetails_Status.ForeColor = Color.Green;
                        break;
                    case Result.Failed:
                        lblJobDetails_Status.ForeColor = Color.DarkRed;
                        break;
                    case Result.Cancelled:
                        lblJobDetails_Status.ForeColor = Color.Sienna;
                        break;
                }
                break;
        }
        lblJobDetails_Build.Text = job.Build;
        lblJobDetails_Version.Text = job.BuildVersion;
        lblJobDetails_Environment.Text = job.Environment;
        lblJobDetails_JobType.Text = job.Type.ToString();
        lblJobDetails_Priority.Text = job.Priority.ToString();
        lblJobDetails_Creator.Text = job.Creator;

        if (job.LogsLocation.Length > 0)
        {
            lblJobDetails_LogsLocation.Text = job.LogsLocation;
            lblJobDetails_LogsLocation.NavigateUrl = lblJobDetails_LogsLocation.Text;
        }
        else
        {
            lblJobDetails_LogsLocation.Text = "N/A";
            lblJobDetails_LogsLocation.NavigateUrl = "";
            lblJobDetails_LogsLocation.ForeColor = Color.Black;
        }

        if (job.State == JobState.Complete)
        {
            lblJobDetails_Duration_Label.Text = "Duration:";
            lblJobDetails_Duration.Text = Utils.FormatDuration((int)(job.EndDate.Subtract(job.StartDate).TotalSeconds));
        }
        else if (job.State == JobState.Running || job.State == JobState.Paused)
        {
            lblJobDetails_Duration_Label.Text = "Elapsed Time:";
            lblJobDetails_Duration.Text = Utils.FormatDuration((int)(DateTime.Now.Subtract(job.StartDate).TotalSeconds));
        }
        else
            lblJobDetails_Duration.Text = "N/A";

        lblJobDetails_CreateDate.Text = job.CreateDate.ToString("MM/dd/yyyy HH:mm:ss");
        if (job.StartDate > DateTime.MinValue)
            lblJobDetails_StartDate.Text = job.StartDate.ToString("MM/dd/yyyy HH:mm:ss");
        else
            lblJobDetails_StartDate.Text = "N/A";
        if (job.EndDate > DateTime.MinValue)
            lblJobDetails_EndDate.Text = job.EndDate.ToString("MM/dd/yyyy HH:mm:ss");
        else
            lblJobDetails_EndDate.Text = "N/A";

        // Retrieve the list of issues entered for this job
        GetIssues(job.Id);
    }

    private void RefreshTaskList()
    {
        lblTaskListLastRefresh.Text = "Last Refresh Time: " + DateTime.Now.ToString("G");
        GetTasks((Int64)(Session[Session_CurrentJob]));
        pnlTaskList.Update();
        pnlLastRefreshTime.Update();
    }

    private void GetTasks(long jobId)
    {
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM vw_Portal_Tasks WHERE JobID=" + jobId.ToString() + " ORDER BY RunOrder asc";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    DataTable dt = new DataTable();
                    da.Fill(dt);

                    // Walk the data table and perform 2 actions:
                    //  1. Convert all LogFile fields to links
                    //  2. Combine logs from rows with identical IDs into one row
                    for (int i = 1; i < dt.Rows.Count; i++)
                    {
                        // 1. Convert all LogFile fields to links
                        if (!(dt.Rows[i]["LogFile"] is DBNull))
                        {
                            dt.Rows[i]["LogFile"] = String.Format("<a href=\"{0}\">{0}</a>", dt.Rows[i]["LogFile"]);
                        }

                        // 2. Collapse logs into a single row
                        if ((Int64)dt.Rows[i]["ID"] == (Int64)dt.Rows[i - 1]["ID"])
                        {
                            // Two rows with the same index - collapse the logs into the first row and delete the repeat row
                            if (!(dt.Rows[i]["LogFile"] is DBNull))
                            {
                                if (!(dt.Rows[i - 1]["LogFile"] is DBNull))
                                {
                                    dt.Rows[i - 1]["LogFile"] = String.Format("{0}<br />{1}", dt.Rows[i - 1]["LogFile"], dt.Rows[i]["LogFile"]);
                                }
                                else
                                {
                                    dt.Rows[i - 1]["LogFile"] = (dt.Rows[i]["LogFile"] as string);
                                }
                            }

                            if (!(dt.Rows[i]["LogData"] is DBNull))
                            {
                                // Ignore log data that is XML
                                if (!(dt.Rows[i]["LogData"] as string).StartsWith("<"))
                                {
                                    if (!(dt.Rows[i - 1]["LogData"] is DBNull))
                                    {
                                        dt.Rows[i - 1]["LogData"] = String.Format("{0}<hr style=\"text-align: left; width: 33%\" />{1}", dt.Rows[i - 1]["LogData"], dt.Rows[i]["LogData"]);
                                    }
                                    else
                                    {
                                        dt.Rows[i - 1]["LogData"] = (dt.Rows[i]["LogData"] as string);
                                    }
                                }
                            }

                            dt.Rows.RemoveAt(i--);
                        }
                    }

                    // Now bind the table to the task list
                    gvTaskList.DataSource = dt;
                    gvTaskList.DataBind();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    private void GetIssues(long jobId)
    {
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM vw_Portal_Issues WHERE JobID=" + jobId.ToString() + " ORDER BY ID asc";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    DataTable dt = new DataTable();
                    da.Fill(dt);
                    gvIssuesList.DataSource = dt;
                    gvIssuesList.DataBind();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    private void PopulateCategories(DropDownList dropDown)
    {
        dropDown.Items.Clear();
        dropDown.Items.Add(new ListItem("", "0"));

        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT i_category_id,vc_category_Name FROM t_categories ORDER BY vc_category_name";
                    cmd.CommandType = CommandType.Text;

                    SqlDataReader reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        dropDown.Items.Add(new ListItem(reader.GetString(1), reader.GetInt32(0).ToString()));
                    }
                    reader.Close();
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }
    }

    private void PopulateSubCatories(DropDownList dropDown, string categoryId)
    {
        dropDown.Items.Clear();
        dropDown.Items.Add(new ListItem("", "0"));

        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT i_subcategory_id,vc_subcategory_Name FROM t_subcategories WHERE i_category_id=" + categoryId + " ORDER BY vc_subcategory_name";
                    cmd.CommandType = CommandType.Text;

                    SqlDataReader reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        dropDown.Items.Add(new ListItem(reader.GetString(1), reader.GetInt32(0).ToString()));
                    }
                    reader.Close();
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }
    }

    private void PopulateIssueDialogFields(string issueId)
    {
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT Category, SubCategory, BugID, PSDatabase, Notes FROM vw_Portal_Issues WHERE ID = " + issueId;
                    cmd.CommandType = CommandType.Text;

                    SqlDataReader reader = cmd.ExecuteReader();
                    ListItem item = null;
                    if (reader.Read())
                    {
                        if (!reader.IsDBNull(0))
                        {
                            item = ddlIssueCategory.Items.FindByText(reader.GetString(0));
                            if (item != null)
                            {
                                item.Selected = true;
                                PopulateSubCatories(ddlIssueSubCategory, item.Value);
                            }
                            if (!reader.IsDBNull(1))
                            {
                                item = ddlIssueSubCategory.Items.FindByText(reader.GetString(1));
                                if (item != null)
                                    item.Selected = true;
                            }
                            else
                            {
                                ddlIssueSubCategory.SelectedIndex = 0;
                            }
                        }
                        else
                        {
                            ddlIssueCategory.SelectedIndex = 0;
                        }
                        if (!reader.IsDBNull(2))
                        {
                            txtAddIssueDialogBugNumber.Text = reader.GetInt32(2).ToString();
                        }
                        if (!reader.IsDBNull(3))
                        {
                            cbAddIssueDialogPSDB.Items.FindByText(reader.GetString(3));
                            if (item != null)
                                item.Selected = true;
                        }
                        if (!reader.IsDBNull(4))
                        {
                            txtAddIssueDialog_Notes.Text = reader.GetString(4);
                        }

                    }
                    reader.Close();
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }
    }

    protected void mnuMainMenu_MenuItemClick(Object sender, MenuEventArgs e)
    {
        switch (e.Item.Value)
        {
            case "Jobs_Home":
                break;
        }
    }

    protected void tmrTaskList_Tick(object sender, EventArgs e)
    {
    }

    protected void gvTaskList_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType != DataControlRowType.DataRow)
            return;

        DataRowView data = e.Row.DataItem as DataRowView;
        string groupName = "";

        /*
         * Task Grouping
         */
        if (!(data.Row["GroupName"] is DBNull))
            groupName = data.Row["GroupName"] as string;

        e.Row.Cells[0].CssClass = "resultRow";
        if (String.Compare(groupName, currentGroup, true) != 0)
        {
            // This task is not is the current group
            if (groupName.Length > 0)
            {
                // New group - add the group separator
                Table table = gvTaskList.Controls[0] as Table;
                GridViewRow groupRow = new GridViewRow(e.Row.RowIndex, 0, DataControlRowType.Separator, DataControlRowState.Normal);
                TableCell groupCell = new TableCell();
                groupCell.ColumnSpan = gvTaskList.Columns.Count;
                groupCell.CssClass = "groupSeparator";
                groupCell.Text = groupName;
                groupRow.Cells.Add(groupCell);
                table.Controls.AddAt(table.Controls.Count - 1, groupRow);
                currentGroup = groupName;
            }
            else
                currentGroup = "";
        }

        if (groupName.Length == 0)
        {
            // This task is not part of a group
            e.Row.Cells[0].CssClass = "resultRowNoGroup";
        }


        /*
         * Task Display
         */

        // Display the task name as a link
        e.Row.Cells[TaskNameColumn].Text = String.Format("<a href=\"TaskDetails.aspx?TaskId={0}\">{1}</a>", data["ID"], data["Name"]);

        // Format the Task State depending on state and result
        System.Drawing.Color fontColor = System.Drawing.Color.Black;
        bool bold = false;
        switch (data["State"] as string)
        {
            case "Ready":
                fontColor = System.Drawing.Color.MidnightBlue;
                bold = false;
                break;
            case "Running":
                fontColor = System.Drawing.Color.Blue;
                bold = true;
                break;
            case "Complete":
                bold = true;
                e.Row.Cells[TaskStateColumn].Text = data["Result"] as String;
                switch (data["Result"] as string)
                {
                    case "Succeeded":
                        fontColor = System.Drawing.Color.Green;
                        break;
                    case "Failed":
                        fontColor = System.Drawing.Color.DarkRed;
                        break;
                    case "Skipped":
                        fontColor = System.Drawing.Color.SlateGray;
                        break;
                    default:
                        bold = false;
                        fontColor = System.Drawing.Color.Black;
                        break;
                }
                break;
        }

        e.Row.Cells[TaskStateColumn].ForeColor = fontColor;
        e.Row.Cells[TaskStateColumn].Font.Bold = bold;

        // Format the Duration value to be more clear
        // The value comes from the database in seconds,
        // so perform some manipulations to format the
        // value in hours, minutes, and seconds
        if (!(data["Duration"] is DBNull))
            e.Row.Cells[TaskDurationColumn].Text = Utils.FormatDuration((Int32)data["Duration"]);

        // Combine the logs - LogFile first, the LogData
        e.Row.Cells[TaskLogsColumn].Text = "";
        if (!(data["LogFile"] is DBNull))
        {
            e.Row.Cells[TaskLogsColumn].Text = data["LogFile"].ToString();
        }

        if (!(data["LogData"] is DBNull))
        {
            if (e.Row.Cells[TaskLogsColumn].Text.Length > 0)
                e.Row.Cells[TaskLogsColumn].Text = String.Format("{0}<hr />{1}", e.Row.Cells[TaskLogsColumn].Text, data["LogData"].ToString().Replace("\r\n", "<br />"));
            else
                e.Row.Cells[TaskLogsColumn].Text = data["LogData"].ToString();
        }
    }

    protected void gvIssuesList_RowDataBound(Object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType != DataControlRowType.DataRow)
            return;

        DataRowView data = e.Row.DataItem as DataRowView;

        // Fix up the edit issues link
        (e.Row.Cells[0].Controls[1] as LinkButton).Text = data["ID"].ToString();
        (e.Row.Cells[0].Controls[1] as LinkButton).CommandArgument = data["ID"].ToString();

        // Combine the Category & SubCategory
        string category = "None";
        if (!(data["Category"] is DBNull))
        {
            category = data["Category"].ToString();
            if (!(data["SubCategory"] is DBNull))
            {
                category += " :: " + data["SubCategory"].ToString();
            }
        }
        e.Row.Cells[2].Text = category;

        // If there is a bug ID, append this information to the Notes
        if (!(data["BugID"] is DBNull))
        {
            StringBuilder text = new StringBuilder();
            if (!(data["Notes"] is DBNull))
            {
                text.Append(data["Notes"]);
                text.Append(" ");
            }
            text.AppendFormat("[{0} #{1}]", data["PSDatabase"], data["BugID"]);
            e.Row.Cells[1].Text = text.ToString();
        }
    }

    protected void cmdButton_PreRender(Object sender, EventArgs e)
    {
        LinkButton bttn = (sender as LinkButton);
        bttn.Enabled = Utils.GetJobCommandEnableState(bttn.CommandName, lblJobDetails_Status.Text,
            lblJobDetails_Result.Text, lblJobDetails_Creator.Text, lblJobDetails_Environment.Text, _userPrivs);
        if ("PauseJob" == bttn.CommandName)
        {
            if ("Paused" == lblJobDetails_Status.Text)
                bttn.Text = "Continue";
            else
                bttn.Text = "Pause";
        }
    }

    protected void Action_Click(Object sender, CommandEventArgs e)
    {
        string jobId = lblJobDetails_JobID.Text;

        switch (e.CommandName as String)
        {
            case "ScheduleJob":
                Utils.ScheduleJob(jobId);
                PopulateDetailsPane(jobId);
                break;
            case "UnscheduleJob":
                Utils.UnscheduleJob(jobId);
                PopulateDetailsPane(jobId);
                break;
            case "PauseJob":
                Utils.PauseContinueJob(jobId, lblJobDetails_Status.Text);
                PopulateDetailsPane(jobId);
                break;
            case "CancelJob":
                lblCancelJobDialogJobId.Text = jobId;
                mpeCancelJobDialog.Show();
                break;
            case "RestartJob":
                lblRestartJobDialogJobId.Text = jobId;
                mpeRestartJobDialog.Show();
                break;
            case "AddJobIssue":
                lblDialogTitle.Text = "Add Issue";
                btnAddIssue_OK.Text = "OK";
                txtAddIssueDialogBugNumber.Text = "";
                txtAddIssueDialog_Notes.Text = "";

                lblAddIssueDialogJobId.Text = jobId;

                // Populate the Issue Category and SubCategory dropdowns
                PopulateCategories(ddlIssueCategory);
                PopulateSubCatories(ddlIssueSubCategory, ddlIssueCategory.SelectedValue);
                pnlAddIssueDialog.Update();

                mpeAddIssueDialog.Show();
                break;
            case "EditJobIssue":
                lblDialogTitle.Text = "Update Issue";

                // For editing issues, we need the issue ID instead of the job ID
                lblAddIssueDialogJobId.Text = e.CommandArgument.ToString();

                // Populate the Issue Category dropdown
                PopulateCategories(ddlIssueCategory);

                // Populate the dialog fields with the issue data from the database
                PopulateIssueDialogFields(e.CommandArgument as string);

                // Change the text of the OK button to Update
                btnAddIssue_OK.Text = "Update";

                pnlAddIssueDialog.Update();
                mpeAddIssueDialog.Show();
                break;
        }
    }

    protected void btnRestartJob_Ok_OnClick(Object sender, EventArgs e)
    {
        mpeRestartJobDialog.Hide();
        Utils.RestartJob(lblRestartJobDialogJobId.Text, chkRestartJob_ClearLogs.Checked, chkRestartJob_Resume.Checked);
        PopulateDetailsPane(lblRestartJobDialogJobId.Text);
        
        // Re-enable the timer
        tmrTaskList.Enabled = false;
        lblTaskListLastRefresh.Visible = true;

        RefreshTaskList();
    }

    protected void btnRestartJob_Cancel_OnClick(Object sender, EventArgs e)
    {
        mpeRestartJobDialog.Hide();
    }

    protected void btnCancelJob_Yes_OnClick(Object sender, EventArgs e)
    {
        mpeCancelJobDialog.Hide();
        Utils.CancelJob(lblCancelJobDialogJobId.Text);
        PopulateDetailsPane(lblCancelJobDialogJobId.Text);
        RefreshTaskList();
    }

    protected void btnCancelJob_No_OnClick(Object sender, EventArgs e)
    {
        mpeCancelJobDialog.Hide();
    }

    protected void ddlIssueCategory_SelectedIndexChanged(Object sender, EventArgs e)
    {
        // Populate the SubCategory drop down
        PopulateSubCatories(ddlIssueSubCategory, ddlIssueCategory.SelectedValue);
        pnlAddIssueDialog.Update();
    }

    protected void btnAddIssue_OK_OnClick(Object sender, EventArgs e)
    {
        int bugNumber = 0;
        long Id = 0;
        int category = 0;
        int subCategory = 0;
        string notes = txtAddIssueDialog_Notes.Text;
        string psDb = cbAddIssueDialogPSDB.SelectedItem.Text;

        Int64.TryParse(lblAddIssueDialogJobId.Text, out Id);
        Int32.TryParse(txtAddIssueDialogBugNumber.Text, out bugNumber);
        Int32.TryParse(ddlIssueCategory.SelectedValue, out category);
        Int32.TryParse(ddlIssueSubCategory.SelectedValue, out subCategory);

        if (String.Compare(btnAddIssue_OK.Text, "OK", true) == 0)
            Utils.AddJobIssue(Id, bugNumber, category, subCategory, psDb, notes, _userPrivs.UserName);
        else
            Utils.UpdateJobIssue(Id, bugNumber, category, subCategory, psDb, notes);

        mpeAddIssueDialog.Hide();
        GetIssues(_jobId);
    }

    protected void btnAddIssue_Cancel_OnClick(Object sender, EventArgs e)
    {
        mpeAddIssueDialog.Hide();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\TaskDetails.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

using xonline.test.deployment.automation.common;

public partial class TaskDetails : System.Web.UI.Page
{
    private const string DBConnectionString = "server=XLFINFRTLS001;database=DeploymentDB;Integrated Security=SSPI";

    private const int TaskIDColumn = 0;
    private const int TaskStateColumn = 1;
    private const int TaskNameColumn = 2;
    private const int TaskStartColumn = 3;
    private const int TaskDurationColumn = 4;
    private const int TaskLogsColumn = 5;

    private const string Session_CurrentTask = "CurrentTask";

    private long _taskId = 0;
    private UserPrivileges _userPrivs = null;

    protected void Page_Load(object sender, EventArgs e)
    {
        // Load the user's privileges
        _userPrivs = new UserPrivileges(Request.LogonUserIdentity.Name);

        // Get the task ID from the request string
        if (!Int64.TryParse(Request.QueryString["TaskId"], out _taskId))
        {
            Response.Write("Need to pass a TaskId in the query string.");
            Response.End();
        }

        DataRow currentTask = GetTaskDetails(_taskId);
        if (currentTask != null)
        {
            lblTaskDetailPanelHeader.Text = String.Format("'{0}' Task Details", currentTask["Name"]);
            PopulateDetailsPane(currentTask);
            pnlTaskDetails_Content.Update();

            // If the task is complete, disable the timer
            if (currentTask["State"].ToString() == "Complete" || currentTask["State"].ToString() == "None")
            {
                tmrTaskDetails.Enabled = false;
                lblTaskDetailsLastRefresh.Visible = false;
            }
        }

        lblTaskDetailsLastRefresh.Text = "Last Refresh Time: " + DateTime.Now.ToString("G");
        pnlLastRefreshTime.Update();
    }

    private void PopulateDetailsPane(string taskId)
    {
        Int64 id = 0;
        Int64.TryParse(taskId, out id);
        PopulateDetailsPane(id);
    }
    private void PopulateDetailsPane(Int64 taskId) { PopulateDetailsPane(GetTaskDetails(taskId)); }
    private void PopulateDetailsPane(DataRow task)
    {
        string state = task["State"] as string;
        string result = task["Result"] as string;
        DateTime startTime = DateTime.MinValue;
        DateTime endTime = DateTime.MinValue;

        if (!(task["StartTime"] is DBNull))
            startTime = (DateTime)task["StartTime"];
        if (!(task["EndTime"] is DBNull))
            endTime = (DateTime)task["EndTime"];

        lblTaskDetails_ID.Text = task["ID"].ToString();
        lblTaskDetails_JobId.Text = task["JobID"].ToString();
        lblTaskDetails_Status.Text = state;
        lblTaskDetails_Result.Text = result;
        switch (state)
        {
            case "None":
                lblTaskDetails_Status.ForeColor = Color.Black;
                lblTaskDetails_Duration.Text = "N/A";
                break;
            case "Ready":
                lblTaskDetails_Status.ForeColor = Color.MidnightBlue;
                lblTaskDetails_Duration.Text = "N/A";
                break;
            case "Running":
                lblTaskDetails_Status.ForeColor = Color.Blue;
                lblTaskDetails_Duration_Label.Text = "Elapsed Time:";
                lblTaskDetails_Duration.Text = Utils.FormatDuration((int)(DateTime.Now.Subtract(startTime).TotalSeconds));
                break;
            case "Complete":
                switch (result)
                {
                    case "Succeeded":
                        lblTaskDetails_Status.ForeColor = Color.Green;
                        break;
                    case "Failed":
                        lblTaskDetails_Status.ForeColor = Color.DarkRed;
                        break;
                    case "Cancelled":
                        lblTaskDetails_Status.ForeColor = Color.Sienna;
                        break;
                    case "Skipped":
                        lblTaskDetails_Status.ForeColor = Color.SlateGray;
                        break;
                }
                lblTaskDetails_Duration_Label.Text = "Duration:";
                lblTaskDetails_Duration.Text = Utils.FormatDuration((int)(endTime.Subtract(startTime).TotalSeconds));
                break;
        }
        lblTaskDetails_Group.Text = task["GroupName"].ToString();
        lblTaskDetails_Condition.Text = ((RunCondition)task["RunCondition"]).ToString();
        lblTaskDetails_LogTarget.Text = task["LocalLogTarget"].ToString();
        lblTaskDetails_Module.Text = task["Module"].ToString();
        lblTaskDetails_TaskType.Text = ((TaskType)task["TaskType"]).ToString();
        if (task["StartTime"] is DBNull)
            lblTaskDetails_StartDate.Text = "N/A";
        else
            lblTaskDetails_StartDate.Text = startTime.ToString("MM/dd/yyyy HH:mm:ss");
        if (task["EndTime"] is DBNull)
            lblTaskDetails_EndDate.Text = "N/A";
        else
            lblTaskDetails_EndDate.Text = endTime.ToString("MM/dd/yyyy HH:mm:ss");

        // Populate the Parameters
        DataTable paramList = GetTaskParameters((long)task["ID"]);
        if (paramList.Rows.Count > 0)
        {
            // If the parameters are in a PARAM_BLOCK, display the XML in a TextBox,
            // Otherwise display the name/value pairs in a GridView
            if (paramList.Rows[0]["ParamName"].ToString() == "PARAM_BLOCK")
            {
                txtParamBlock.Text = paramList.Rows[0]["ParamValue"].ToString();
                // Replace the password with asteriks
                int pwdStart = txtParamBlock.Text.IndexOf("Password=");
                if (pwdStart > 0)
                {
                    pwdStart += 10;
                    int pwdEnd = txtParamBlock.Text.IndexOf('\"', pwdStart);
                    string pwd = txtParamBlock.Text.Substring(pwdStart, pwdEnd - pwdStart);
                    txtParamBlock.Text = txtParamBlock.Text.Replace(pwd, "**********");
                }
                txtParamBlock.Width = 800;
                gvParamList.Visible = false;
                txtParamBlock.Visible = true;
                txtParamBlock.Rows = 20;
            }
            else
            {
                gvParamList.DataSource = paramList;
                gvParamList.DataBind();
                txtParamBlock.Visible = false;
                gvParamList.Visible = true;
            }
        }
    }

    private DataRow GetTaskDetails(long taskId)
    {
        DataTable dt = new DataTable();

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM vw_Portal_Task_Details WHERE ID=" + taskId.ToString() + " ORDER BY RunOrder asc";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    da.Fill(dt);

                    // Walk the data table and perform 2 actions:
                    //  1. Convert all LogFile fields to links
                    //  2. Combine logs from rows with identical IDs into one row
                    for (int i = 1; i < dt.Rows.Count; i++)
                    {
                        // 1. Convert all LogFile fields to links
                        if (!(dt.Rows[i]["LogFile"] is DBNull))
                        {
                            dt.Rows[i]["LogFile"] = String.Format("<a href=\"{0}\">{0}</a>", dt.Rows[i]["LogFile"]);
                        }

                        // 2. Collapse logs into a single row
                        if ((Int64)dt.Rows[i]["ID"] == (Int64)dt.Rows[i - 1]["ID"])
                        {
                            // Two rows with the same index - collapse the logs into the first row and delete the repeat row
                            if (!(dt.Rows[i]["LogFile"] is DBNull))
                            {
                                if (!(dt.Rows[i - 1]["LogFile"] is DBNull))
                                {
                                    dt.Rows[i - 1]["LogFile"] = String.Format("{0}<br />{1}", dt.Rows[i - 1]["LogFile"], dt.Rows[i]["LogFile"]);
                                }
                                else
                                {
                                    dt.Rows[i - 1]["LogFile"] = (dt.Rows[i]["LogFile"] as string);
                                }
                            }

                            if (!(dt.Rows[i]["LogData"] is DBNull))
                            {
                                // Ignore log data that is XML
                                if (!(dt.Rows[i]["LogData"] as string).StartsWith("<"))
                                {
                                    if (!(dt.Rows[i - 1]["LogData"] is DBNull))
                                    {
                                        dt.Rows[i - 1]["LogData"] = String.Format("{0}<hr style=\"text-align: left; width: 33%\" />{1}", dt.Rows[i - 1]["LogData"], dt.Rows[i]["LogData"]);
                                    }
                                    else
                                    {
                                        dt.Rows[i - 1]["LogData"] = (dt.Rows[i]["LogData"] as string);
                                    }
                                }
                            }

                            dt.Rows.RemoveAt(i--);
                        }
                    }
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }

        if (dt.Rows.Count > 0)
            return dt.Rows[0];
        else
            return null;
    }

    private DataTable GetTaskParameters(long taskId)
    {
        DataTable dt = new DataTable();

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM vw_Portal_Task_Parameters WHERE TaskID=" + taskId.ToString() + " ORDER BY ID ASC";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    da.Fill(dt);
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }

        return dt;
    }

    protected void mnuMainMenu_MenuItemClick(Object sender, MenuEventArgs e)
    {
        switch (e.Item.Value)
        {
            case "Jobs_Home":
                break;
        }
    }

    protected void tmrTaskDetails_Tick(object sender, EventArgs e)
    {
    }

    protected void gvParamList_RowDataBound(Object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType != DataControlRowType.DataRow || !gvParamList.Visible)
            return;

        DataRowView data = (e.Row.DataItem as DataRowView);

        // If the Parameter name is "Password", don't display the actual password value
        if (String.Compare(data["ParamName"] as string, "Password", true) == 0)
            e.Row.Cells[2].Text = "**********";

        // Convert the Condition value to a string
        e.Row.Cells[3].Text = ((RunCondition)(e.Row.DataItem as DataRowView).Row["Condition"]).ToString();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\RequestJob.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.bdservice;

public partial class RequestJob : System.Web.UI.Page
{
    private const int JobIDColumn = 0;
    private const int JobStateColumn = 1;
    private const int JobNameColumn = 2;
    private const int JobEnvColumn = 3;
    private const int JobBuildColumn = 4;
    private const int JobOwnerColumn = 5;
    private const int JobStartColumn = 6;
    private const int JobDurationColumn = 7;

    private UserPrivileges _userPrivs = null;
    private EnvironmentInfo _currentEnv = null;
    private string _privateDeploymentEnv = "GauntletNet";

    protected void Page_Load(object sender, EventArgs e)
    {
        Response.Cache.SetCacheability(HttpCacheability.NoCache);

        // Load the user's privileges
        _userPrivs = new UserPrivileges(Request.LogonUserIdentity.Name);

        // Initialize the BDServiceLib
        DbAccess.Init(Utils.DBServer, Utils.DBDatabase);

        // Load the environment data
        _currentEnv = EnvironmentInfo.Load(_privateDeploymentEnv);

        // If the user is not an admin in the Private Deployment environment,
        // show the Private Deployment section by default and hide the others
        //cpePrivateDeploymentPanel.Collapsed = ((_userPrivs.GetPrivileges(_privateDeploymentEnv) & Privileges.ControlAllJobs) != Privileges.None);

        // If the user doesn't have permissions at all, display an error message and disable the Schedule button
        if ((_userPrivs.GetPrivileges(_privateDeploymentEnv) & Privileges.CreateJob) == Privileges.None)
        {
            lblErrorText.Text = "You do not have permissions to schedule a Private Deployment job. Please contact the HyperAdm group for assistance.";
            lblErrorText.Visible = true;
            btnPrivateDeployment_Schedule.Enabled = false;
        }
        else
        {
            lblErrorText.Visible = false;
            btnPrivateDeployment_Schedule.Enabled = true;
        }

        // Refresh the Private Deployment Queue on a full page reload
        if (!IsPostBack)
        {
            RefreshJobList();
        }

        PopulateJobTypeCombobox(ddlJobType);
        PopulateEnvironmentList(cblEnvironment);
    }

    private void RefreshJobList()
    {
        lblPrivateDeploymentQueueLastRefresh.Text = "Last Refresh Time: " + DateTime.Now.ToString("G");
        GetJobs();
        DataTable dt = gvPrivateDeploymentQueue.DataSource as DataTable;
        if (dt != null)
        {
            lblPrivateDeploymentQueueRecordCount.Text = String.Format("Displaying records [{0}-{1}] of {2} results.",
                (gvPrivateDeploymentQueue.PageSize * gvPrivateDeploymentQueue.PageIndex) + 1,
                (gvPrivateDeploymentQueue.PageSize * gvPrivateDeploymentQueue.PageIndex) + gvPrivateDeploymentQueue.Rows.Count,
                dt.Rows.Count);
        }
        pnlPrivateDeploymentQueue_Content.Update();
        pnlLastRefreshTime.Update();
    }

    private void GetJobs()
    {
        try
        {
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    // Non-environment admins only get to see those jobs that either in the queue or belong to them
                    // Admins get to see all jobs
                    if (_userPrivs.GetPrivileges(_privateDeploymentEnv) != Privileges.SystemAdmin)
                        cmd.CommandText = "SELECT * FROM vw_Portal_Jobs WHERE Version='PRIVATE_VERSION' and (State != 'Complete' or Owner = '"+_userPrivs.UserName+"') ORDER BY ID desc";
                    else
                        cmd.CommandText = "SELECT * FROM vw_Portal_Jobs WHERE Version='PRIVATE_VERSION' ORDER BY ID desc";
                    cmd.CommandType = CommandType.Text;

                    SqlDataAdapter da = new SqlDataAdapter(cmd);
                    DataTable dt = new DataTable();
                    da.Fill(dt);
                    gvPrivateDeploymentQueue.DataSource = dt;
                    gvPrivateDeploymentQueue.DataBind();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    protected void mnuMainMenu_MenuItemClick(Object sender, MenuEventArgs e)
    {
    }

    protected void btnPrivateDeployment_Schedule_OnClick(Object sender, EventArgs e)
    {
        // Create a BuildInfo object that defines this build
        BuildInfo bi = new BuildInfo();
        bi.BuildName = cbBranch.SelectedValue;
        bi.BuildType = (rbDebugBuild.Checked ? "debug" : "retail");
        bi.BuildSourcePath = txtPrivateBuildLocation.Text;

        // Validate the provided build location before trying to schedule the job
        if (bi.BuildSourcePath.Length < 1)
        {
            RaiseErrorDialog("The Build Location has not been specified.\r\nPlease provide a UNC path to the location of the private deployment files.", txtPrivateBuildLocation.ID);
            return;
        }

        // Load the proper default job description based on the selected branch
        DeploymentJob job = null;
        try
        {
            job = LoadDefaultJobDescription(bi.BuildName);
        }
        catch (Exception ex)
        {
            RaiseErrorDialog(String.Format("Loading the default private deployment job definition failed.\r\nYour private deployment cannot be processed at this time.\r\n\r\nError:\r\n{0}", ex.Message), null);
            return;
        }

        // Update parts of the job
        job.EnvName = _currentEnv.Name;
        job.Version = "PRIVATE_VERSION";
        job.Owner = _userPrivs.UserName.Substring(_userPrivs.UserName.LastIndexOf('\\') + 1);
        job.LogBase = txtLogBaseLocation.Text;
        job.Report.ToList = job.Owner;

        // Create the list of token replacement delegates
        ParameterTokens.TokenValue[] tokenReplacers = new ParameterTokens.TokenValue[3];
        tokenReplacers[0] = _currentEnv.GetEnvTokenValue;
        tokenReplacers[1] = job.GetJobTokenValue;
        tokenReplacers[2] = bi.GetBuildTokenValue;

        // Create the job
        Int64 jobId = 0;
        try
        {
            jobId = job.CreatePrivate(tokenReplacers);
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }

        if (0 == jobId)
        {
            RaiseErrorDialog("Unable to create the job.\r\nPlease contact the HyperAdm team for assistance.", null);
            return;
        }

        // Take the user to the JobDetails page
        Response.Redirect("JobDetails.aspx?jobId=" + jobId.ToString());
    }

    protected void gvPrivateDeploymentQueue_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        gvPrivateDeploymentQueue.SelectedIndex = -1;
        gvPrivateDeploymentQueue.PageIndex = e.NewPageIndex;
        RefreshJobList();
    }

    protected void tmrPrivateDeploymentQueue_Tick(object sender, EventArgs e)
    {
        RefreshJobList();
    }

    protected void gvPrivateDeploymentQueue_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType != DataControlRowType.DataRow)
            return;

        DataRowView data = e.Row.DataItem as DataRowView;
        StringBuilder sb = new StringBuilder();
        foreach (object col in data.Row.ItemArray)
            sb.AppendFormat("{0},", col);
        sb.Length--;
        Debug.WriteLine(sb.ToString());

        System.Drawing.Color fontColor = System.Drawing.Color.Black;
        bool bold = false;
        e.Row.Attributes.Add("JobState", data["State"] as string);
        e.Row.Attributes.Add("JobResult", data["Result"] as string);
        e.Row.Attributes.Add("EnvName", data["Environment"] as string);
        switch (data["State"] as string)
        {
            case "Ready":
                fontColor = System.Drawing.Color.MidnightBlue;
                bold = false;
                break;
            case "Running":
                fontColor = System.Drawing.Color.Blue;
                bold = true;
                break;
            case "Paused":
                fontColor = System.Drawing.Color.OrangeRed;
                bold = true;
                break;
            case "Complete":
                bold = true;
                e.Row.Cells[JobStateColumn].Text = data["Result"] as String;
                switch (e.Row.Cells[JobStateColumn].Text)
                {
                    case "Passed":
                        fontColor = System.Drawing.Color.Green;
                        break;
                    case "Failed":
                        fontColor = System.Drawing.Color.DarkRed;
                        break;
                    case "Cancelled":
                        fontColor = System.Drawing.Color.Sienna;
                        break;
                }
                break;
        }

        // Set the formatting for the Job State text
        e.Row.Cells[JobStateColumn].ForeColor = fontColor;
        e.Row.Cells[JobStateColumn].Font.Bold = bold;

        // Format the Duration value to be more clear
        // The value comes from the database in seconds,
        // so perform some manipulations to format the
        // value in hours, minutes, and seconds
        if (!((e.Row.DataItem as DataRowView).Row[8] is DBNull))
            e.Row.Cells[JobDurationColumn].Text = Utils.FormatDuration((Int32)(e.Row.DataItem as DataRowView).Row[8]);

        // If the environment is locked, display the lock icon
        if (data != null)
        {
            if (Convert.ToBoolean(data[9]))
            {
                e.Row.Cells[JobEnvColumn].Text = String.Format("{0}&nbsp;<img alt=\"\" src=\"Images\\Lock_icon.png\" width=\"12\" height=\"12\" style=\"vertical-align: bottom\" />", data[2]);
            }
        }
    }

    protected void pnlActionList_OnPreRender(Object sender, EventArgs e)
    {
        // Find the containing DataGridRow
        GridViewRow gvRow = (sender as Control).Parent.Parent as GridViewRow;
        if (gvRow != null)
        {
            // Get the state of the job represented by this row
            string jobState = gvRow.Attributes["JobState"];
            string jobResult = gvRow.Attributes["JobResult"];
            string envName = gvRow.Attributes["EnvName"];
            string jobOwner = gvRow.Cells[JobOwnerColumn].Text;

            // Enable/Disable the Action LinkButtons
            foreach (Control ctrl in (sender as Control).Controls)
            {
                if (ctrl is LinkButton)
                {
                    LinkButton lb = (ctrl as LinkButton);
                    lb.Enabled = Utils.GetJobCommandEnableState(lb.CommandName, jobState, jobResult, jobOwner, envName, _userPrivs);
                    if ("PauseJob" == lb.CommandName)
                    {
                        if ("Running" == jobState)
                            lb.Text = "Pause";
                        else if ("Paused" == jobState)
                            lb.Text = "Continue";
                    }
                }
            }
        }
    }

    protected void Action_Click(Object sender, CommandEventArgs e)
    {
        // Find the containing GridViewRow so we can get the JobID
        string jobId = null;
        string jobState = null;
        int rowIndex = -1;
        GridViewRow gvRow = (sender as Control).Parent.Parent.Parent as GridViewRow;
        if (gvRow != null)
        {
            rowIndex = gvRow.RowIndex;
            jobId = gvRow.Cells[JobIDColumn].Text;
            jobState = gvRow.Cells[JobStateColumn].Text;
        }

        bool refreshJobs = false;
        switch (e.CommandName as String)
        {
            case "ScheduleJob":
                Utils.ScheduleJob(jobId);
                refreshJobs = true;
                break;
            case "UnscheduleJob":
                Utils.UnscheduleJob(jobId);
                refreshJobs = true;
                break;
            case "PauseJob":
                Utils.PauseContinueJob(jobId, jobState);
                refreshJobs = true;
                break;
            case "CancelJob":
                lblCancelJobDialogJobId.Text = jobId;
                mpeCancelJobDialog.Show();
                break;
            case "RestartJob":
                lblRestartJobDialogJobId.Text = jobId;
                mpeRestartJobDialog.Show();
                break;
            case "DeleteJob":
                lblDeleteJobDialogJobId.Text = jobId;
                mpeDeleteJobDialog.Show();
                break;
        }

        // Close the popup
        AjaxControlToolkit.PopupControlExtender.GetProxyForCurrentPopup(Page).Commit(e.CommandArgument as string);

        // Refresh the job list
        if (refreshJobs)
        {
            Debug.WriteLine("Action_Click: Refreshing job list.");
            RefreshJobList();
        }
    }

    protected void btnRestartJob_Ok_OnClick(Object sender, EventArgs e)
    {
        mpeRestartJobDialog.Hide();
        Utils.RestartJob(lblRestartJobDialogJobId.Text, chkRestartJob_ClearLogs.Checked, chkRestartJob_Resume.Checked);
        RefreshJobList();
    }

    protected void btnRestartJob_Cancel_OnClick(Object sender, EventArgs e)
    {
        mpeRestartJobDialog.Hide();
    }

    protected void btnCancelJob_Yes_OnClick(Object sender, EventArgs e)
    {
        mpeCancelJobDialog.Hide();
        Utils.CancelJob(lblCancelJobDialogJobId.Text);
        RefreshJobList();
    }

    protected void btnCancelJob_No_OnClick(Object sender, EventArgs e)
    {
        mpeCancelJobDialog.Hide();
    }

    protected void btnDeleteJob_Yes_OnClick(Object sender, EventArgs e)
    {
        mpeDeleteJobDialog.Hide();
        Utils.DeleteJob(lblDeleteJobDialogJobId.Text);
        RefreshJobList();
    }

    protected void btnDeleteJob_No_OnClick(Object sender, EventArgs e)
    {
        mpeDeleteJobDialog.Hide();
    }

    protected void btnErrorDialog_Ok_OnClick(Object sender, EventArgs e)
    {
        mpeErrorDialog.Hide();
        if (lblErrorDialog_FocusCtrlId.Text.Length > 0)
        {
            // Set the focus to the specified control
            Control ctrl = pnlErrorDialog.FindControl(lblErrorDialog_FocusCtrlId.Text);
            if (ctrl != null)
                ctrl.Focus();
        }
    }

    private void RaiseErrorDialog(string msg, string focusCtrlId)
    {
        if (null != focusCtrlId)
            lblErrorDialog_FocusCtrlId.Text = focusCtrlId;
        else
            lblErrorDialog_FocusCtrlId.Text = "";
        lblErrorMsg.Text = msg.Replace("\r\n", "<br>");
        pnlErrorDialog.Update();
        mpeErrorDialog.Show();
    }

    private DeploymentJob LoadDefaultJobDescription(string buildName)
    {
        DeploymentJob job = null;
        XmlDocument jobDoc = new XmlDocument();
        string xmlFile = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "PrivateDeploymentJobDescription.xml");

        jobDoc.Load(xmlFile);
        XPathNavigator nav = jobDoc.CreateNavigator();
        XPathNavigator jobNode = nav.SelectSingleNode("PrivateDeploymentJobs/Job[@Build='" + buildName + "']");
        job = DeploymentJob.Parse(jobNode);

        return job;
    }

    private void PopulateEnvironmentList(CheckBoxList cblEnvironment)
    {
        if (null == cblEnvironment)
            return;

        try
        {
            cblEnvironment.Items.Clear();
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;
                    cmd.CommandText = "select vc_environment_name from t_environments where i_env_id not in (select i_sub_env_id from t_sub_env) order by vc_environment_name asc";
                    cmd.CommandType = CommandType.Text;
                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            // only list the environment if the user has the permission to create jobs
                            string env = reader["vc_environment_name"] as string;
                            if ((_userPrivs.GetPrivileges(env) & Privileges.CreateJob) != Privileges.None)
                                cblEnvironment.Items.Add(env);
                        }
                    }
                    finally
                    {
                        if (null != reader)
                            reader.Close();
                    }
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    private void PopulateJobTypeCombobox(DropDownList cbJobType)
    {
        if (null == cbJobType)
            return;

        try
        {
            cbJobType.Items.Clear();
            using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;
                    cmd.CommandText = "select ti_job_type, vc_job_type from t_job_types order by vc_job_type asc";
                    cmd.CommandType = CommandType.Text;
                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            cbJobType.Items.Add(new ListItem(reader["vc_job_type"] as string, reader["ti_job_type"] as string));
                        }
                    }
                    finally
                    {
                        if (null != reader)
                            reader.Close();
                    }
                }
            }
        }
        catch (Exception)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\App_Code\JobFilter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;

using xonline.test.deployment.automation.common;

public enum JobFilterDateRangeType
{
    All = 0,
    Today,
    Yesterday,
    ThisWeek,
    LastWeek,
    Custom
}

/// <summary>
/// Defines a filter for the main Jobs view
/// </summary>
public class JobFilter
{
    public string Environment { get; set; }
    public string Build { get; set; }
    public JobFilterDateRangeType DateRangeType { get; set; }
    public DateTime FromDate { get; set; }
    public DateTime ToDate { get; set; }
    public bool NotReady { get; set; }
    public bool Ready { get; set; }
    public bool Running { get; set; }
    public bool Paused { get; set; }
    public bool Complete { get; set; }
    public bool Succeeded { get; set; }
    public bool Failed { get; set; }
    public bool Cancelled { get; set; }
    
    public JobFilter()
	{
        Environment = "All";
        Build = "All";
        DateRangeType = JobFilterDateRangeType.ThisWeek;
        FromDate = DateTime.MinValue;
        ToDate = DateTime.MinValue;
        NotReady = true;
        Ready = true;
        Running = true;
        Paused = true;
        Complete = true;
        Succeeded = true;
        Failed = true;
        Cancelled = true;
	}

    public override string ToString()
    {
        bool clauseAdded = false;
        StringBuilder filter = new StringBuilder();
        filter.Append("(");

        // Environment
        if (String.Compare(Environment, "All", false) != 0)
        {
            filter.AppendFormat("{0}([Environment]='{1}')", clauseAdded ? "AND " : "", Environment);
            clauseAdded = true;
        }

        // Build
        if (String.Compare(Build, "All", false) != 0)
        {
            filter.AppendFormat("{0}([Build]='{1}')", clauseAdded ? "AND " : "", Build);
            clauseAdded = true;
        }

        // Job State and Result
        StringBuilder jobState = new StringBuilder();
        StringBuilder jobResult = new StringBuilder();
        if (NotReady)
            jobState.Append("([State]='Not Ready') OR ");
        if (Ready)
            jobState.Append("([State]='Ready') OR ");
        if (Running)
            jobState.Append("([State]='Running') OR ");
        if (Paused)
            jobState.Append("([State]='Paused') OR ");
        if (Complete)
        {
            if (Succeeded)
                jobResult.Append("([Result]='Passed') OR ");
            if (Failed)
                jobResult.Append("([Result]='Failed') OR ");
            if (Cancelled)
                jobResult.Append("([Result]='Cancelled') OR ");
            if (jobResult.Length > 0)
            {
                jobResult.Length -= 4;
                jobState.AppendFormat("([State]='Complete' AND ({0})) OR ", jobResult);
            }
            else
                jobState.AppendFormat("([State]='Complete') OR ");
        }
        if (jobState.Length > 0)
        {
            jobState.Length -= 4;
            filter.AppendFormat("{0}({1})", clauseAdded ? "AND " : "", jobState.ToString());
            clauseAdded = true;
        }

        // Date Range
        switch (DateRangeType)
        {
            case JobFilterDateRangeType.All:
                FromDate = DateTime.MinValue;
                ToDate = DateTime.MinValue;
                break;
            case JobFilterDateRangeType.Today:
                FromDate = DateTime.Today;
                ToDate = FromDate.AddDays(1);
                break;
            case JobFilterDateRangeType.Yesterday:
                ToDate = DateTime.Today;
                FromDate = ToDate.AddDays(-1);
                break;
            case JobFilterDateRangeType.ThisWeek:
                FromDate = DateTime.Today.AddDays(-(int)DateTime.Today.DayOfWeek);
                ToDate = FromDate.AddDays(8);
                break;
            case JobFilterDateRangeType.LastWeek:
                ToDate = DateTime.Today.AddDays(-(int)DateTime.Today.DayOfWeek);
                FromDate = ToDate.AddDays(-7);
                break;
        }
        if (FromDate > DateTime.MinValue && ToDate > DateTime.MinValue)
        {
            filter.AppendFormat("{0}(([CreateDate]>='{1}' AND [CreateDate]<'{2}') OR ([StartTime]>='{1}' AND [StartTime]<'{2}'))", clauseAdded ? " AND " : "",
                FromDate.ToShortDateString(), ToDate.ToShortDateString());
            clauseAdded = true;
        }

        filter.Append(")");
        if (clauseAdded)
            return filter.ToString();
        else
            return "";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\App_Code\Utils.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Linq;
using System.Web;

using xonline.test.deployment.automation.common;

[Flags]
public enum Privileges : ushort
{
    None = 0,
    View = 1,
    CreateJob = 2,
    ScheduleJob = 4,
    PauseJob = 8,
    CancelJob = 16,
    DeleteJob = 32,
    AnnotateJob = 64,
    CreateEnvironment = 128,
    EditEnvironment = 256,
    LockEnvironment = 512,
    DeleteEnvironment = 1024,
    EditPrivileges = 2048,
    ControlAllJobs = 32768,
    EnvironmentAdmin = 33407,   // ControlAllJobs + LockEnvironment + AnnotateJobs (and below)
    SystemAdmin = 65535
}

/// <summary>
/// Summary description for Utils
/// </summary>
public static class Utils
{
    private const string c_DBServer = "XLFINFRTLS001";
    private const string c_DBDatabase = "DeploymentDB";
    public static string DBServer { get { return c_DBServer; } }
    public static string DBDatabase { get { return c_DBDatabase; } }
    public static string DBConnectionString
    {
        get { return String.Format("server={0};database={1};Integrated Security=SSPI", c_DBServer, c_DBDatabase); }
    }

    public static Dictionary<string, Privileges> GetUserPrivileges(string userName)
    {
        Dictionary<string, Privileges> userPrivs = new Dictionary<string, Privileges>();
        using (SqlConnection conn = new SqlConnection(DBConnectionString))
        {
            conn.Open();
            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_priv_get_user_privileges";
                cmd.Parameters.AddWithValue("@userName", userName);

                SqlDataReader reader = null;

                try
                {
                    reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        int i = reader.GetOrdinal("TargetEnvironment");
                        Privileges priv = (Privileges)((ushort)reader.GetInt16(reader.GetOrdinal("Privileges")));
                        string env = "All";
                        if (!reader.IsDBNull(i))
                        {
                            env = reader.GetString(i);
                        }

                        if (!userPrivs.ContainsKey(env))
                            userPrivs.Add(env, priv);
                    }
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }
            }
        }
        return userPrivs;
    }

    public static bool GetJobCommandEnableState(string command, string jobState, string jobResult, string jobOwner, string envName, UserPrivileges userPrivileges)
    {
        Privileges privs = userPrivileges.GetPrivileges(envName);
        if (null == jobOwner)
            jobOwner = "";

        bool enable = false;
        switch (command)
        {
            case "ScheduleJob":
                enable = ("Not Ready" == jobState) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
            case "UnscheduleJob":
                enable = ("Ready" == jobState) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
            case "PauseJob":
                enable = ("Running" == jobState || "Paused" == jobState) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
            case "CancelJob":
                enable = ("Running" == jobState || "Paused" == jobState) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
            case "RestartJob":
                enable = ("Complete" == jobState) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
            case "DeleteJob":
                enable = ("Not Ready" == jobState || "Ready" == jobState || "Complete" == jobState) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
            case "AddJobIssue":
                enable = ("Complete" == jobState) && (("Failed" == jobResult) || ("Cancelled" == jobResult)) &&
                    ((privs & Privileges.ScheduleJob) != Privileges.None) &&
                    (((privs & Privileges.ControlAllJobs) != Privileges.None) || (String.Compare(jobOwner, userPrivileges.UserName, true) == 0));
                break;
        }
        return enable;
    }

    public static bool GetEnvCommandEnableState(string command, Privileges userPrivileges)
    {
        bool enable = false;
        switch (command)
        {
            case "LockEnv":
                enable = (userPrivileges & Privileges.LockEnvironment) != Privileges.None;
                break;
            case "EditEnv":
                enable = (userPrivileges & Privileges.EditEnvironment) != Privileges.None;
                break;
            case "DeleteEnv":
                enable = (userPrivileges & Privileges.DeleteEnvironment) != Privileges.None; 
                break;
            case "EditPrivileges":
                enable = (userPrivileges & Privileges.EditPrivileges) != Privileges.None;
                break;
        }

        return enable;
    }

    public static Job GetJobDetails(long jobId)
    {
        Job job = null;

        using (SqlConnection conn = new SqlConnection(DBConnectionString))
        {
            conn.Open();
            using (SqlCommand cmd = conn.CreateCommand())
            {
                SqlDataReader reader = null;

                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_job_get_job";
                cmd.Parameters.AddWithValue("@jobid", jobId);

                try
                {
                    reader = cmd.ExecuteReader();
                    if (reader.Read())
                    {
                        job = new Job();
                        job.Id = jobId;
                        job.Name = reader["vc_job_name"] as string;
                        job.Environment = reader["vc_environment_name"] as string;
                        job.Build = reader["vc_build_name"] as string;
                        job.BuildVersion = reader["vc_version"] as string;
                        job.Type = (JobType)reader["ti_job_type"];
                        job.Creator = reader["vc_requestor_username"] as string;
                        job.CreateDate = (DateTime)reader["dt_create_date"];
                        job.Priority = (JobPriority)reader["ti_priority"];
                        if (reader["dt_job_start_date"] is DateTime)
                            job.StartDate = (DateTime)reader["dt_job_start_date"];
                        if (reader["dt_job_end_date"] is DateTime)
                            job.EndDate = (DateTime)reader["dt_job_end_date"];
                        job.State = (JobState)reader["ti_job_state"];
                        job.Result = (Result)reader["ti_job_result"];
                        job.LogBase = reader["vc_log_base"] as string;
                    }
                }
                catch (SqlException)
                {
                    // Display exception
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }
            }
        }

        return job;
    }

    public static void ScheduleJob(string jobId)
    {
        if (String.IsNullOrEmpty(jobId)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_schedule_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    public static void AddJobIssue(long jobId, int bugNumber, int category, int subCategory, string database, string notes, string userName)
    {
        if (jobId == 0 || (bugNumber == 0 && String.IsNullOrEmpty(notes)))
            return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "p_job_add_issue";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.Parameters.AddWithValue("@categoryId", category);
                    if (subCategory > 0)
                        cmd.Parameters.AddWithValue("@subCategoryId", subCategory);
                    cmd.Parameters.AddWithValue("@userName", userName);
                    if (bugNumber > 0)
                    {
                        cmd.Parameters.AddWithValue("@psDatabase", database);
                        cmd.Parameters.AddWithValue("@bugId", bugNumber);
                    }
                    if (!String.IsNullOrEmpty(notes))
                        cmd.Parameters.AddWithValue("@notes", notes);
                    SqlParameter outParam = new SqlParameter("@issueId", SqlDbType.BigInt);
                    outParam.Direction = ParameterDirection.Output;
                    cmd.Parameters.Add(outParam);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }
    }

    public static void UpdateJobIssue(long issueId, int bugNumber, int category, int subCategory, string database, string notes)
    {
        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "p_issue_update_issue";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@issueId", issueId);
                    cmd.Parameters.AddWithValue("@categoryId", category);
                    if (subCategory > 0)
                        cmd.Parameters.AddWithValue("@subCategoryId", subCategory);
                    cmd.Parameters.AddWithValue("@psDatabase", database);
                    if (bugNumber > 0)
                        cmd.Parameters.AddWithValue("@bugId", bugNumber);
                    else
                        cmd.Parameters.AddWithValue("@bugId", DBNull.Value);
                    cmd.Parameters.AddWithValue("@notes", notes);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex);
        }
    }

    public static string FormatDuration(int duration)
    {
        string durationString = "";
        if (0 == duration)
        {
            durationString = "< 1s";
        }
        else if (duration < 60)
        {
            durationString = duration.ToString() + "s";
        }
        else if (duration < 3600)
        {
            int minutes = duration / 60;
            int seconds = duration - (minutes * 60);
            durationString = String.Format("{0}m {1}s", minutes, seconds);
        }
        else
        {
            int hours = duration / 3600;
            int minutes = (duration - (hours * 3600)) / 60;
            int seconds = duration - (hours * 3600) - (minutes * 60);
            durationString = String.Format("{0}h {1}m {2}s", hours, minutes, seconds);
        }

        return durationString;
    }

    public static void UnscheduleJob(string jobId)
    {
        if (String.IsNullOrEmpty(jobId)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_unschedule_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    public static void PauseContinueJob(string jobId, string jobState)
    {
        if (String.IsNullOrEmpty(jobId)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    if ("Paused" == jobState)
                        cmd.CommandText = "p_job_resume_job";
                    else
                        cmd.CommandText = "p_job_pause_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    public static void CancelJob(string jobId)
    {
        if (String.IsNullOrEmpty(jobId)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_cancel_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    public static void RestartJob(string jobId, bool clearLogs, bool resumeFromFailure)
    {
        if (String.IsNullOrEmpty(jobId)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_restart_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.Parameters.AddWithValue("@clearLogs", clearLogs);
                    cmd.Parameters.AddWithValue("@resumeFromFailure", resumeFromFailure);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    public static void DeleteJob(string jobId)
    {
        if (String.IsNullOrEmpty(jobId)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_delete_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }

    public static void SetEnvLock(string envName, bool setLock)
    {
        if (String.IsNullOrEmpty(envName)) return;

        try
        {
            using (SqlConnection conn = new SqlConnection(DBConnectionString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_env_set_lock";
                    cmd.Parameters.AddWithValue("@envName", envName);
                    cmd.Parameters.AddWithValue("@lock", setLock);
                    cmd.ExecuteNonQuery();
                }
            }
        }
        catch (Exception)
        {
            // Display error
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\DeployBvtNet\BuildManger.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Diagnostics;
using Microsoft.Win32;

namespace BvtNetAutomation
{
    /// <summary>
    /// This class checks if the new build comes in the latest build. If we have new build it deletes the bvtnetcurrent
    /// files and copy the new build from latest to bvtnetcureent. Also, it logs any information at the log directory.
    /// </summary>
    public class BuildManger
    {

        private static string _latest;
        private static string _current;
        private static string _latestEMS;
        private static string _currentEMS;
        PopulateConfigXml populateConfigXml;
        public BuildManger(string path)
        {
            populateConfigXml = PopulateConfigXml.GetInstance(path);
        }

        /// <summary>
        /// this method checks if new build is dropped in latest.tst and compare with bvtnetCureent build
        /// </summary>
        /// <returns></returns>
        public bool CheckNewBuild()
        {
            try
            {
                _latest = GetBuildString(populateConfigXml.LatestPath);
                _current = GetBuildString(populateConfigXml.BvtNetCurrentPath);
                _latestEMS = GetBuildString(populateConfigXml.EmsLatestPath);
                _currentEMS = GetBuildString(populateConfigXml.EmsBvtNetCurrentPath);
                return (IsLatestGreater(_latest, _current) || IsLatestGreater(_latestEMS, _currentEMS));
            }
            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }
            return false;
        }

        /// <summary>
        ///to get a file that has a build number.
        ///this assumes we have only one aa.aa.aaaa.aa formated file in the directory
        /// </summary>
        /// <param name="path"></param>
        /// <returns>the file which has a build number</returns>
        private string GetBuildString(string path)
        {
            if (Directory.Exists(path))
            {
                try
                {
                    string[] files = Directory.GetFiles(path);

                    if (files.Length >= 0)
                    {
                        for (int i = 0; i < files.Length; i++)
                        {
                            string fileName = Path.GetFileName(files[i]);
                            if ((fileName.Split('.')).Length == 4)
                                return fileName;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Logger.WriteToLog(ex.Message);
                }
            }
            else
            {
                Logger.WriteToLog("the directory is no t exit ");
                return null;
            }
            Console.WriteLine("There is no file such as 00.00.0000.00 format");

            Logger.WriteToLog("There is no file such as 00.00.0000.00 format");
            return null;
        }

        /// <summary>
        ///compares two files and return true if latest greater than current else false 
        /// </summary>
        /// <param name="latest"></param>
        /// <param name="current"></param>
        /// <returns></returns>
        private bool IsLatestGreater(string latest, string current)
        {
            if (string.IsNullOrEmpty(latest) || string.IsNullOrEmpty(current))
            {
                Console.WriteLine("The Path is null");
                Logger.WriteToLog("The Path is null");
                return false;
            }
            string[] latestValues = latest.Split('.');
            string[] currentValues = current.Split('.');

            if (latestValues.Length != currentValues.Length)
            {
                Console.WriteLine("The two Paths are not equal length");
                Logger.WriteToLog("The two paths do not have same length");
                return false;
            }

            for (int i = 0; i < latestValues.Length; i++)
            {
                try
                {
                    if ((Convert.ToInt32(latestValues[i])) > (Convert.ToInt32(currentValues[i])))
                        return true;
                }
                catch (Exception ex)
                {
                    Logger.WriteToLog("The file has different format that cannot convert in ToInt32" + ex.Message);
                    return false;
                }
            }
            return false;
        }
        /// <summary>
        /// deleted the targetd directory
        /// </summary>
        public void DeleteAllDirectoriesFromBvtNet()
        {
            DeleteAllDirectoriesFromBvtNet(new DirectoryInfo(populateConfigXml.BvtNetCurrentPath));
        }

        /// <summary>
        /// deleted all directories and files
        /// </summary>
        /// <param name="bvtNetCurrentPath"></param>
        public void DeleteAllDirectoriesFromBvtNet(DirectoryInfo bvtNetCurrentPath)
        {
            // Check if the target directory exists
            if (Directory.Exists(bvtNetCurrentPath.FullName))
            {
                //delete each file 
                foreach (FileInfo fileInfo in bvtNetCurrentPath.GetFiles())
                {
                    try
                    {
                        File.Delete(fileInfo.FullName);
                    }
                    catch (Exception ex)
                    {
                        Logger.WriteToLog("Unable to delete the file  " + ex.Message);
                    }
                }

                // delete each subdirectory files using
                foreach (DirectoryInfo bvtNetCurrentSubDir in bvtNetCurrentPath.GetDirectories())
                {
                    try
                    {
                        bvtNetCurrentSubDir.Delete(true);
                    }
                    catch (Exception ex)
                    {
                        Logger.WriteToLog("Unable to delete the directory  " + ex.Message);
                    }
                }
            }
            else
            {
                Logger.WriteToLog("unable to delete the directory is not found");
            }

        }

        /// <summary>
        /// Copy from latest.tst Path to bvtnetcurrent
        /// </summary>
        public void MakeCopyFromLatestToBvtNet()
        {
            MakeCopyFromLatestToBvtNet(new DirectoryInfo(populateConfigXml.LatestPath), new DirectoryInfo(populateConfigXml.BvtNetCurrentPath));
        }

        /// <summary>
        /// Copy from latest Path to bvtNetCurrent path
        /// </summary>
        /// <param name="latestPathsource"></param>
        /// <param name="bvtNetCurrentPathTarget"></param>
        private void MakeCopyFromLatestToBvtNet(DirectoryInfo latestPathSource, DirectoryInfo bvtNetCurrentPathTarget)
        {
            try
            {
                // Check if the bvtnet.current directory exists, if not, create it.
                if (!Directory.Exists(bvtNetCurrentPathTarget.FullName))
                {
                    Directory.CreateDirectory(bvtNetCurrentPathTarget.FullName);
                }
            }
            catch (Exception ex)
            {
                Logger.WriteToLog("Unable to create a new directory   " + ex.Message);
            }

            // Copy each file into bvtNet.current
            foreach (FileInfo fileInfo in latestPathSource.GetFiles())
            {
                try
                {
                    fileInfo.CopyTo(Path.Combine(bvtNetCurrentPathTarget.ToString(), fileInfo.Name), true);
                }
                catch (Exception ex)
                {
                    Logger.WriteToLog("Unable to copy: " + fileInfo.Name + " " + ex.Message);
                }
            }

            // Copy each subdirectory using recursion.
            foreach (DirectoryInfo latestPathSourceSubDir in latestPathSource.GetDirectories())
            {
                try
                {
                    DirectoryInfo nextLatestPathSourceSubDir =
                         bvtNetCurrentPathTarget.CreateSubdirectory(latestPathSourceSubDir.Name);
                    MakeCopyFromLatestToBvtNet(latestPathSourceSubDir, nextLatestPathSourceSubDir);
                }
                catch (Exception ex)
                {
                    Logger.WriteToLog("Unable to create subdirectories,  " + ex.Message);
                }
            }
        }

        public static string Latest
        {
            get { return BuildManger._latest; }
            set { BuildManger._latest = value; }
        }


        public static string Current
        {
            get { return BuildManger._current; }
            set { BuildManger._current = value; }
        }

    }//class
}//ns
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\Default.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Drawing;
using System.Web.UI.HtmlControls;
using System.IO;
//using ProductStudio;
using AjaxControlToolkit;


public partial class _Default : System.Web.UI.Page 
{
    const Int32 JOB_ID = 11;  // hard-coded job id by design. We only allow this job to be scheduled. From DepAutoWeb..
    const Int32 ENV_ID = 1; // hard-coded environment. We only scheduled jobs to this environment for this page (currently BVTNet)

    private static string s_reportingDBName = "DeploymentDB_V2";
    private Dictionary<String,List<String>> AuthDictionaryByEnvName;
    private Dictionary<Int64, List<String>> AuthDictionaryByEnvId;
    
    private const string FOCUS_SCRIPT2 =
    @"window.setTimeout('DoFocus()', 1);
    function DoFocus()
    {
        try {
            document.getElementById('REQUEST_LASTFOCUS').focus();
        } catch (ex) {}
    }";

    private const string FOCUS_SCRIPT1 =
        @"var textAreas = document.getElementsByTagName('textarea');

    for (var i = 0; i < textAreas.length; i++) {
        if (!textAreas[i].disabled) {
            textAreas[i].focus();
            setCaretPosition(textAreas[i].id, textAreas[i].value.length);
        }
    }

    textAreas = null;

    function setCaretPosition(elemId, caretPos) {
        var elem = document.getElementById(elemId);

        if (elem != null) {
            if (elem.createTextRange) {
                var range = elem.createTextRange();
                range.move('character', caretPos);
                range.select();
            }
            else {
                if (elem.selectionStart) {
                    elem.focus();
                    elem.setSelectionRange(caretPos, caretPos);
                }
                else
                    elem.focus();
            }
        }
    }";


    protected void Page_Load(object sender, EventArgs e)
    {
        AuthDictionaryByEnvName = Auth.GetAuthDictionaryByEnvName();
        AuthDictionaryByEnvId = Auth.GetAuthDictionaryByEnvId();

        this.lblRefreshTime.Text = "Last Refresh Time: " + DateTime.Now.ToString("G");

        if (!this.Page.IsPostBack)
        {
            if (Session["CurrentPageIndex"] != null)
            {
                Int32 currentPageIndex = (Int32)Session["CurrentPageIndex"];
                this.gvJobsReport.PageIndex = currentPageIndex;
            }


            //this.Menu1.Items[1].Selected = true;
            this.PopulateEnvironments();
            this.PopulateStatus();
            this.PopulateResults();
            this.PopulateBuilds();
            this.PopulateScheduler();
            this.RefreshJobs();
            this.mvMain.ActiveViewIndex = 0;
            //this.metaRefresh.Attributes["content"] = "30";        
            //HookOnFocus(this.Page as Control);

            if (Session["SelectedJobReportId"] != null)
            {
                Int32 selectedJobReportId = (Int32)Session["SelectedJobReportId"];                
                this.gvIssues.Visible = true;
                this.gvJobTasks.Visible = true;                
                //this.gvTaskParams.Visible = false;            
                FillJobTasks(selectedJobReportId);
                this.gvJobTasks.DataBind();


                SetSelectedJobReportRow(selectedJobReportId);

                //ReduceIssuesIfNoAuth(this.gvJobsReport.SelectedRow.Cells[4].Text);
            }


        }



        //ScriptManager.RegisterStartupScript(
        //this,
        //typeof(_Default),
        //"ScriptDoFocus",
        //SCRIPT_DOFOCUS2.Replace("REQUEST_LASTFOCUS", Request["__LASTFOCUS"]),
        //true);

        
        //ScriptManager.RegisterStartupScript(this,typeof(_Default),"ScriptDoFocus",SCRIPT_DOFOCUS2.Replace("REQUEST_LASTFOCUS", Request["__LASTFOCUS"]),true);
        ScriptManager.RegisterStartupScript(this, typeof(_Default), "ScriptDoFocus", FOCUS_SCRIPT1, true);


    }

    protected void btn_Ok_OnClick(object sender, EventArgs e)
    {
        // need to fix this to work with latest Job sig...
        throw new System.NotImplementedException();

        //this.lblCreateJobStatus.Visible = true;
        //Int32 JobIdToSchedule = (Int32)Session["JobIdToSchedule"];
        //Int32 EnvId = Int32.Parse(this.ddJobScheduleEnv.SelectedValue);
        //String BuildNum = this.txtCreateJobBuildNumber.Text;
        //Job newJob = new Job(JobIdToSchedule, EnvId, BuildNum, Request.LogonUserIdentity.Name);
        //try
        //{
        //    newJob.CreateJob();
        //}
        //catch (Exception ex)
        //{
        //    this.lblCreateJobStatus.Text = "Failed to create job:<br>" + ex.Message;            
        //}
        //this.lblCreateJobStatus.Text = "Job created successfully.";
    }


    public void Page_PreRender()
    {
        //HookOnFocus(this.Page as Control);
    }

    protected void SetSelectedJobReportRow(long JobReportId)
    {
        for (int i = 0; i < gvJobsReport.Rows.Count; i++)
        { 
            long currentKey = (long) gvJobsReport.DataKeys[i].Value;
            if (currentKey == JobReportId)
            {
                this.gvJobsReport.SelectedIndex = i;
                return;
            }
        }
    }

    private void FillBuilds()
    {
        string sql = "SELECT * FROM t_builds";
        this.gvBuilds.DataSource = GetData(sql,"DeploymentDB_V2").DefaultView;
        
    }

    private void FillEnvironments()
    {
        string sql = "SELECT * FROM t_environments";
        this.gvEnvironments.DataSource = GetData(sql,"DeploymentDB_V2").DefaultView;
    }

    private void FillTasks()
    {
        //string sql = "SELECT * FROM vw_tasks";
        //this.gvTasks.DataSource = GetData(sql).DefaultView;
    }

    private void FillAudit()
    {
        string sql = "SELECT * FROM vw_audit ORDER BY dt_timestamp DESC";
        this.gvAudit.DataSource = GetData(sql, "DeploymentDB_V2").DefaultView;
    }

    private void FillJobs()
    {
        string sql = "SELECT * FROM vw_AllJobs";
        this.gvJobs.DataSource = GetData(sql).DefaultView;
    }

    private DataTable GetData(String sql)
    {        
        return GetData(sql, "DepAutoWebDb");
    }


    private DataTable GetData(String sql, string db)
    {
        SqlConnection cn = new SqlConnection(ConfigurationManager.ConnectionStrings[db].ConnectionString);
        cn.Open();

        SqlCommand cmd = new SqlCommand(sql, cn);

        SqlDataAdapter da = new SqlDataAdapter(cmd);
        DataTable dt = new DataTable();

        da.Fill(dt);
        cn.Close();
        return dt;
    }


    protected void gvJobs_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblJobErrorText.Visible = false;

        switch (e.CommandName)
        {
            case "Insert":
                //DropDownList ddBldInsert = this.gvJobs.FooterRow.FindControl("ddInsertBuild") as DropDownList;                
                DropDownList ddTypeInsert = this.gvJobs.FooterRow.FindControl("ddInsertJobType") as DropDownList;
                DropDownList ddPriInsert = this.gvJobs.FooterRow.FindControl("ddInsertPriority") as DropDownList;
                TextBox txtJobNameInsert = this.gvJobs.FooterRow.FindControl("txtInsertJobName") as TextBox;
                Job.AddJob(txtJobNameInsert.Text, Int32.Parse(ddTypeInsert.SelectedValue), ddPriInsert.SelectedValue);
                FillJobs();
                this.gvJobs.DataBind();
                break;
            case "EmptyInsert":
                //DropDownList ddBld = this.gvJobs.Controls[0].Controls[0].FindControl("ddEmptyInsertBuild") as DropDownList;                
                DropDownList ddType = this.gvJobs.Controls[0].Controls[0].FindControl("ddEmptyInsertJobType") as DropDownList;
                DropDownList ddPri = this.gvJobs.Controls[0].Controls[0].FindControl("ddEmptyInsertPri") as DropDownList;
                TextBox txtJobName = this.gvJobs.Controls[0].Controls[0].FindControl("txtEmptyInsertJobName") as TextBox;
                Job.AddJob(txtJobName.Text, Int32.Parse(ddType.SelectedValue), ddPri.SelectedValue);
                FillJobs();
                this.gvJobs.DataBind();
                break;
            case "Delete":
                Int32 JobIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                try
                {
                    Job.DeleteJob(JobIdToDelete);
                }
                catch (Exception ex)
                {
                    this.lblJobErrorText.Text = "Failed to delete job. Delete all task groups linked to this job first. " + ex.Message;
                    this.lblJobErrorText.Visible = true;
                }

                FillJobs();
                this.gvJobs.DataBind();
                break;
            case "Select":
                Int32 SelectedJobId = Int32.Parse(e.CommandArgument.ToString());
                Session.Add("SelectedJobId", SelectedJobId);
                FillJobTaskgroups(SelectedJobId);
                this.gvJobTaskgroups.DataBind();                              
                break;
            case "Create":
                {
                    Int32 JobIdToSchedule = Int32.Parse(e.CommandArgument.ToString());
                    Session.Add("JobIdToSchedule", JobIdToSchedule);
                    this.myModalPopupExtender.Show();
                    //ModalPopupExtender extender = this.gvJobs.Controls[0].Controls[0].FindControl("myModalPopupExtender") as ModalPopupExtender;
                    //if (extender != null) extender.Show();
                    //
                    //Job newJob = new Job(JobIdToSchedule, Request.LogonUserIdentity.Name);
                    //newJob.ScheduleJob();
  
                    //try
                    //{

                    //}
                    //catch (Exception ex)
                    //{
                    //    this.lblJobErrorText.Visible = true;
                    //    this.lblJobErrorText.ForeColor = System.Drawing.Color.Red;
                    //    string msg = "Failed to schedule job. " + ex.Message;
                    //    if (ex.InnerException != null)
                    //    {
                    //        msg += "<br>" + ex.InnerException.Message;
                    //    }
                    //    this.lblJobErrorText.Text = msg;
                    //    return;
                    //}
                    //this.lblJobErrorText.Visible = true;
                    //this.lblJobErrorText.ForeColor = System.Drawing.Color.Green;
                    //this.lblJobErrorText.Text = "Job Scheduled Successfully";
                }
                break;
        }
    }


    private void FillJobTaskgroups(Int32 SelectedJobId)
    {
        string sql = "SELECT * FROM vw_job_taskgroups " +
            " WHERE i_job_id=" + SelectedJobId.ToString() +
            " ORDER BY i_order" ;

        this.gvJobTaskgroups.DataSource = GetData(sql).DefaultView;
    }

    protected void gvJobs_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }

    protected void gvTasks_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblTaskErrorText.Visible = false;
        this.lblParamMessage.Visible = false;

        switch (e.CommandName)
        {
            case "Insert":
                {
                    TextBox txtInsertTaskName = this.gvTasks.FooterRow.FindControl("txtInsertTaskName") as TextBox;
                    TextBox txtInsertModule = this.gvTasks.FooterRow.FindControl("txtInsertModule") as TextBox;
                    DropDownList ddInsertTaskType = this.gvTasks.FooterRow.FindControl("ddInsertTaskType") as DropDownList;                    
                    Task.AddTask(txtInsertTaskName.Text, txtInsertModule.Text, Int32.Parse(ddInsertTaskType.SelectedValue));                    
                    FillTasks();
                    this.gvTasks.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    TextBox txtTaskName = this.gvTasks.Controls[0].Controls[0].FindControl("txtEmptyInsertTaskName") as TextBox;
                    TextBox txtModule = this.gvTasks.Controls[0].Controls[0].FindControl("txtEmptyInsertModule") as TextBox;
                    DropDownList ddEmptyInsertTaskType = this.gvTasks.Controls[0].Controls[0].FindControl("txtEmptyInsertTaskType") as DropDownList;
                    Task.AddTask(txtTaskName.Text, txtModule.Text, Int32.Parse(ddEmptyInsertTaskType.SelectedValue));
                    
                    FillTasks();
                    this.gvTasks.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 TaskIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Task.DeleteTask(TaskIdToDelete);
                    }
                    catch (Exception ex)
                    {
                        string msg = "Failed to delete Task. Ensure all linked parameters and taskgroups are dropped first.<br>";
                        msg += ex.Message;
                        this.lblTaskErrorText.Text = msg;
                        this.lblTaskErrorText.Visible = true;
                        return;
                    }
                    this.gvParameters.Visible = false;
                    FillTasks();
                    this.gvTasks.DataBind();
                }
                break;
            case "Select":
                {
                    this.gvParameters.Visible = true;
                    Int32 SelectedTaskId = Int32.Parse(e.CommandArgument.ToString());
                    Session.Add("SelectedTaskId", SelectedTaskId);
                    FillParameters(SelectedTaskId);
                    this.gvParameters.DataBind();
                }
                break;
            case "Edit":
                { 
                    
                }
                break;
                
                
        }
    }

    private void FillParameters(Int32 TaskId)
    {
        string sql = "SELECT * FROM t_parameters WHERE i_task_id=" + TaskId.ToString();
        this.gvParameters.DataSource = GetData(sql).DefaultView;
    }

    

    protected void gvTasks_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvParameters_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblParamMessage.Visible = false;

        switch (e.CommandName)
        {
            case "Insert":
                {
                    TextBox txtInsertParam = this.gvParameters.FooterRow.FindControl("txtInsertParamName") as TextBox;
                    if (txtInsertParam.Text.ToUpper() == "PARAM_BLOCK")
                    {
                        this.lblParamMessage.Visible = true;
                        this.lblParamMessage.Text = "Add parameter failed. Delete all other task parameters before adding a 'PARAM_BLOCK' parameter.";
                        return;
                    }
                    TextBox txtInsertValue = this.gvParameters.FooterRow.FindControl("txtInsertParamValue") as TextBox;
                    DropDownList ddInsertRunCondition = this.gvParameters.FooterRow.FindControl("ddInsertRunCondition") as DropDownList;

                    Int32 insertTaskId = (Int32)Session["SelectedTaskId"];
                    try
                    {
                        Parameter.AddParameter(insertTaskId, txtInsertParam.Text, txtInsertValue.Text, ddInsertRunCondition.SelectedValue);
                    }
                    catch (Exception ex)
                    {
                        this.lblParamMessage.Text = ex.Message;
                        this.lblParamMessage.Visible = true;
                    }
                    FillParameters((Int32)Session["SelectedTaskId"]);
                    this.gvParameters.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    TextBox txtEmptyInsertParamName = this.gvParameters.Controls[0].Controls[0].FindControl("txtEmptyInsertParamName") as TextBox;
                    TextBox txtEmptyInsertParamValue = this.gvParameters.Controls[0].Controls[0].FindControl("txtEmptyInsertParamValue") as TextBox;
                    DropDownList ddEmptyInsertRunCondition = this.gvParameters.Controls[0].Controls[0].FindControl("ddEmptyInsertRunCondition") as DropDownList;

                    Int32 emptyInsertTaskId = (Int32)Session["SelectedTaskId"];
                    Parameter.AddParameter(emptyInsertTaskId, txtEmptyInsertParamName.Text, txtEmptyInsertParamValue.Text, ddEmptyInsertRunCondition.SelectedValue);
                    FillParameters((Int32)Session["SelectedTaskId"]);
                    this.gvParameters.DataBind();
                }
                break;
            case "Delete":
                Int32 ParamIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                Parameter.DeleteParameter(ParamIdToDelete);
                FillParameters((Int32) Session["SelectedTaskId"]);
                this.gvParameters.DataBind();
                break;
        }
    }



    protected void gvTaskGroups_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblTaskGroupError.Visible = false;

        switch (e.CommandName)
        {
            case "Insert":
                {
                    TextBox txtInsertTaskGroupName = this.gvTaskGroups.FooterRow.FindControl("txtInsertTaskGroupName") as TextBox;
                    DropDownList ddInsertCondition = this.gvTaskGroups.FooterRow.FindControl("ddInsertCondition") as DropDownList;
                    CheckBox cbInsertRollup = this.gvTaskGroups.FooterRow.FindControl("cbInsertRollup") as CheckBox;
                    TaskGroup.AddTaskGroup(txtInsertTaskGroupName.Text, Int32.Parse(ddInsertCondition.SelectedValue), cbInsertRollup.Checked);                    
                    FillTaskGroups();
                    this.gvTaskGroups.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    TextBox txtEmptyInsertTaskGroupName = this.gvTaskGroups.Controls[0].Controls[0].FindControl("txtEmptyInsertTaskGroupName") as TextBox;
                    DropDownList ddEmptyInsertCondition = this.gvTaskGroups.Controls[0].Controls[0].FindControl("ddEmptyInsertCondition") as DropDownList;
                    CheckBox cbEmptyInsertRollup = this.gvTaskGroups.Controls[0].Controls[0].FindControl("cbEmptyInsertRollup") as CheckBox;
                    TaskGroup.AddTaskGroup(txtEmptyInsertTaskGroupName.Text, Int32.Parse(ddEmptyInsertCondition.SelectedValue), cbEmptyInsertRollup.Checked);                    
                    FillTaskGroups();
                    this.gvTaskGroups.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 TaskGroupIdToDelete = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        TaskGroup.DeleteTaskGroup(TaskGroupIdToDelete);
                    }
                    catch (Exception ex)
                    {
                        string msg = "Failed to delete task group. Delete all tasks and jobs linked to this task group first.";
                        msg += "<br>";
                        msg += ex.Message;
                        this.lblTaskGroupError.Text = msg;
                        this.lblTaskGroupError.Visible = true;
                        return;
                    }
                    this.gvTaskGroupTasks.Visible = false;
                    FillTaskGroups();
                    this.gvTaskGroups.DataBind();
                }
                break;
            case "Select":
                {
                    this.gvTaskGroupTasks.Visible = true;
                    Int32 SelectedTaskGroupId = Int32.Parse(e.CommandArgument.ToString());
                    Session.Add("SelectedTaskGroupId", SelectedTaskGroupId);
                    FillTaskGroupTasks(SelectedTaskGroupId);
                    this.gvTaskGroupTasks.DataBind();
                }
                break;
        }
    }

    private void FillTaskGroupTasks(Int32 SelectedTaskGroupId)
    {
        string sql = "SELECT i_taskgroup_task_id, vc_task_name, i_order " +
            "FROM t_tasks t, t_taskgroup_tasks tgt " +
            "WHERE t.i_task_id=tgt.i_task_id " +
            "AND tgt.i_taskgroup_id=" + SelectedTaskGroupId.ToString() +
            " ORDER BY i_order";

        this.gvTaskGroupTasks.DataSource = GetData(sql).DefaultView;
    }

    private void FillTaskGroups()
    {
        string sql = "SELECT * FROM vw_TaskGroups ";
        this.gvTaskGroups.DataSource = GetData(sql).DefaultView;
    }

    protected void gvTaskGroups_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvParameters_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }

    protected void gvTaskGroupTasks_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }

    protected void gvJobTaskGroups_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvEnvironments_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblAuthStatus.Visible = false;
        this.lblEnvErrorText.Visible = false;        
        this.gvAuth.Visible = false;
        this.gvEnvCredentials.Visible = false;
        this.gvSubEnvs.Visible = false;

        switch (e.CommandName)
        {
            case "Insert":
                {
                    TextBox txtInsertEnvironmentName = this.gvEnvironments.FooterRow.FindControl("txtInsertEnvironmentName") as TextBox;
                    CheckBox cbLocked = this.gvEnvironments.FooterRow.FindControl("cbInsertLocked") as CheckBox;
                    CheckBox cbIsVirtual = this.gvEnvironments.FooterRow.FindControl("cbInsertVirtual") as CheckBox;
                    TextBox txtInsertStagerName = this.gvEnvironments.FooterRow.FindControl("txtInsertStagerName") as TextBox;
                    TextBox txtInsertBuildShare = this.gvEnvironments.FooterRow.FindControl("txtInsertBuildShare") as TextBox;
                    TextBox txtInsertTitleShare = this.gvEnvironments.FooterRow.FindControl("txtInsertTitleShare") as TextBox;
                    TextBox txtInsertEnvUserName = this.gvEnvironments.FooterRow.FindControl("txtInsertEnvUserName") as TextBox;
                    TextBox txtInsertHostList = this.gvEnvironments.FooterRow.FindControl("txtInsertHostList") as TextBox;
                    TextBox txtInsertMachinePrefix = this.gvEnvironments.FooterRow.FindControl("txtInsertMachinePrefix") as TextBox;

                    try
                    {
                        Environment.AddEnvironment(txtInsertEnvironmentName.Text, cbLocked.Checked,
                            txtInsertStagerName.Text, txtInsertBuildShare.Text, txtInsertTitleShare.Text,
                            txtInsertEnvUserName.Text, User.Identity.Name, cbIsVirtual.Checked, txtInsertHostList.Text, txtInsertMachinePrefix.Text);
                    }
                    catch (Exception ex)
                    {
                        this.lblEnvErrorText.Text = ex.Message;
                        this.lblEnvErrorText.Visible = true;
                    }

                    // new env means new auth.  Refill auth dictionaries.
                    AuthDictionaryByEnvName = Auth.GetAuthDictionaryByEnvName();
                    AuthDictionaryByEnvId = Auth.GetAuthDictionaryByEnvId();

                    FillEnvironments();
                    this.gvEnvironments.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    // Should never hit this since we should never drop all environments....
                    throw new NotImplementedException("Empty Insert not implemented for environments.");

                    //DropDownList ddEmptyInsertJobTaskGroups = this.gvJobTaskGroups.Controls[0].Controls[0].FindControl("ddEmptyInsertJobTaskGroups") as DropDownList;
                    //TextBox txtEmptyInsertJobTaskgroupOrder = this.gvJobTaskGroups.Controls[0].Controls[0].FindControl("txtEmptyInsertJobTaskgroupOrder") as TextBox;
                    //Int32 SelectedJobId = (Int32)Session["SelectedJobId"];
                    //Job.AddTaskGroup(SelectedJobId, Int32.Parse(ddEmptyInsertJobTaskGroups.SelectedValue), Int32.Parse(txtEmptyInsertJobTaskgroupOrder.Text));
                    //FillJobTaskGroups(SelectedJobId);
                    //this.gvJobTaskGroups.DataBind();
                }
                //break;
            case "Delete":
                {
                    Int32 EnvId = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Environment.DeleteEnvironment(EnvId);
                    }
                    catch (Exception ex)
                    {
                        this.lblEnvErrorText.Visible = true;
                        this.lblEnvErrorText.Text = "Failed to delete environment. Delete all references to this environment, like Jobs and Credentials first.<br>" + ex.Message;
                        return;
                    }
                    FillEnvironments();
                    this.gvEnvironments.DataBind();
                }
                break;
            case "Select":
                {
                    this.gvEnvServers.Visible = true;
                    this.gvAuth.Visible = true;
                    this.gvEnvCredentials.Visible = true;
                    this.gvSubEnvs.Visible = true;
                    Int32 EnvId = Int32.Parse(e.CommandArgument.ToString());                    
                    Session.Add("SelectedEnvironmentId", EnvId);                    
                    FillCredentials(EnvId);
                    FillAuth(EnvId);
                    FillServers(EnvId);
                    FillSubEnvs(EnvId);

                    this.gvEnvCredentials.DataBind();

                    if (!this.AuthDictionaryByEnvId.ContainsKey(EnvId))
                    {
                        if (this.AuthDictionaryByEnvId[EnvId].Contains(User.Identity.Name))
                        {
                            this.gvAuth.ShowFooter = true;
                            this.gvAuth.Columns[1].Visible = true;

                            this.gvEnvServers.Visible = true;
                            //this.gvEnvServers.AutoGenerateEditButton = true;
                            this.gvEnvServers.ShowFooter = true;
                            this.gvEnvServers.Columns[3].Visible = true;
                        }
                        else
                        {
                            this.gvAuth.ShowFooter = false;
                            this.gvAuth.Columns[1].Visible = false;

                            if (this.gvEnvServers.Rows.Count == 0)
                            {
                                this.gvEnvServers.Visible = false;
                            }
                            else
                            {
                                this.gvEnvServers.AutoGenerateEditButton = false;
                                this.gvEnvServers.FooterRow.Visible = false;
                                this.gvEnvServers.Columns[3].Visible = false;
                            }
                        }
                    }
                    this.gvSubEnvs.DataBind();
                    this.gvEnvServers.DataBind();
                    this.gvAuth.DataBind();

                }
                break;
        }
    }

    private void FillSubEnvs(Int32 EnvId)
    {
        string sql = "SELECT * FROM vw_SubEnvironments WHERE ParentEnvId=" + EnvId.ToString();
        this.gvSubEnvs.DataSource = GetData(sql, "DeploymentDB_V2").DefaultView;
    }

    private void FillServers(Int32 EnvironmentId)
    {
        string sql = "SELECT * FROM vw_env_servers WHERE i_env_id=" + EnvironmentId.ToString();
        this.gvEnvServers.DataSource = GetData(sql, "DeploymentDB_V2").DefaultView;
    }

    private void FillAuth(Int32 EnvironmentId)
    {
        string sql = "SELECT * FROM t_auth WHERE i_env_id=" + EnvironmentId.ToString();
        this.gvAuth.DataSource = GetData(sql, "DeploymentDB_V2").DefaultView;
    }

    private void FillCredentials(Int32 EnvironmentId)
    {
        string sql = "SELECT * FROM t_env_passwords WHERE i_env_id=" + EnvironmentId.ToString();
        this.gvEnvCredentials.DataSource = GetData(sql, "DeploymentDB_V2").DefaultView;
    }


    protected void gvEnvironments_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }

    protected void gvTasks_RowEditing(object sender, GridViewEditEventArgs e)
    {

    }

    protected void gvJobTaskgroups_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        switch (e.CommandName)
        {
            case "Insert":
                {
                    Int32 SelectedJobId = (Int32)Session["SelectedJobId"];
                    DropDownList ddInsertJobTaskgroups = this.gvJobTaskgroups.FooterRow.FindControl("ddInsertJobTaskgroups") as DropDownList;
                    Job.AddTaskGroup(SelectedJobId, Int32.Parse(ddInsertJobTaskgroups.SelectedValue));
                    FillJobTaskgroups(SelectedJobId);
                    this.gvJobTaskgroups.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    Int32 SelectedJobId = (Int32) Session["SelectedJobId"];
                    DropDownList ddEmptyInsertJobTaskGroups = this.gvJobTaskgroups.Controls[0].Controls[0].FindControl("ddEmptyInsertJobTaskGroups") as DropDownList;
                    Job.AddTaskGroup(SelectedJobId, Int32.Parse(ddEmptyInsertJobTaskGroups.SelectedValue));
                    FillJobTaskgroups(SelectedJobId);
                    this.gvJobTaskgroups.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 SelectedJobId = (Int32)Session["SelectedJobId"];
                    Int32 JobTaskGroupId = Int32.Parse(e.CommandArgument.ToString());
                    Job.DeleteTaskGroup(JobTaskGroupId);
                    FillJobTaskgroups(SelectedJobId);
                    this.gvJobTaskgroups.DataBind();
                }
                break;
            case "MoveTaskgroupUp":
                {
                    Int32 SelectedJobId = (Int32)Session["SelectedJobId"];
                    Int32 JobTaskGroupId = Int32.Parse(e.CommandArgument.ToString());
                    Job.MoveTaskGroupUp(JobTaskGroupId);
                    FillJobTaskgroups(SelectedJobId);
                    this.gvJobTaskgroups.DataBind();
                }
                break;
            case "MoveTaskgroupDown":
                {
                    Int32 SelectedJobId = (Int32)Session["SelectedJobId"];
                    Int32 JobTaskGroupId = Int32.Parse(e.CommandArgument.ToString());
                    Job.MoveTaskGroupDown(JobTaskGroupId);
                    FillJobTaskgroups(SelectedJobId);
                    this.gvJobTaskgroups.DataBind();
                }
                break;
        }
    }
    protected void gvJobTaskgroups_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvTaskGroupTasks_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        switch (e.CommandName)
        {
            case "Insert":
                {
                    Int32 SelectedTaskgroupId = (Int32)Session["SelectedTaskgroupId"];
                    DropDownList ddInsertTaskGroupTask = this.gvTaskGroupTasks.FooterRow.FindControl("ddInsertTaskGroupTask") as DropDownList;
                    TaskGroup.AddTask(SelectedTaskgroupId, Int32.Parse(ddInsertTaskGroupTask.SelectedValue));
                    FillTaskGroupTasks(SelectedTaskgroupId);
                    this.gvTaskGroupTasks.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    Int32 SelectedTaskgroupId = (Int32)Session["SelectedTaskgroupId"];
                    DropDownList ddEmptyInsertTaskGroupTask = this.gvTaskGroupTasks.Controls[0].Controls[0].FindControl("ddEmptyInsertTaskGroupTask") as DropDownList;
                    TaskGroup.AddTask(SelectedTaskgroupId, Int32.Parse(ddEmptyInsertTaskGroupTask.SelectedValue));
                    FillTaskGroupTasks(SelectedTaskgroupId);
                    this.gvTaskGroupTasks.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 SelectedTaskGroupId = (Int32)Session["SelectedTaskgroupId"];
                    Int32 TaskGroupTaskId = Int32.Parse(e.CommandArgument.ToString());
                    TaskGroup.DeleteTask(TaskGroupTaskId);
                    FillTaskGroupTasks(SelectedTaskGroupId);
                    this.gvTaskGroupTasks.DataBind();
                }
                break;
            case "MoveTaskUp":
                {
                    Int32 SelectedTaskGroupId = (Int32)Session["SelectedTaskgroupId"];
                    Int32 TaskgroupTaskId = Int32.Parse(e.CommandArgument.ToString());
                    TaskGroup.MoveTaskUp(TaskgroupTaskId);
                    FillTaskGroupTasks(SelectedTaskGroupId);
                    this.gvTaskGroupTasks.DataBind();
                }
                break;
            case "MoveTaskDown":
                {
                    Int32 SelectedTaskGroupId = (Int32)Session["SelectedTaskgroupId"];
                    Int32 TaskgroupTaskId = Int32.Parse(e.CommandArgument.ToString());
                    TaskGroup.MoveTaskDown(TaskgroupTaskId);
                    FillTaskGroupTasks(SelectedTaskGroupId);
                    this.gvTaskGroupTasks.DataBind();
                }
                break;
        }
    }
    protected void gvTaskGroupTasks_RowDeleting1(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvBuilds_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblBuildErrorText.Visible = false;
        switch (e.CommandName)
        {
            case "Insert":
                {
                    TextBox txtInsertBuildName = this.gvBuilds.FooterRow.FindControl("txtInsertBuildName") as TextBox;
                    TextBox txtInsertBuildPath = this.gvBuilds.FooterRow.FindControl("txtInsertBuildPath") as TextBox;

                    Build.AddBuild(txtInsertBuildName.Text, txtInsertBuildPath.Text);
                    FillBuilds();
                    this.gvBuilds.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    //Int32 SelectedTaskgroupId = (Int32)Session["SelectedTaskgroupId"];
                    //DropDownList ddEmptyInsertTaskGroupTask = this.gvTaskGroupTasks.Controls[0].Controls[0].FindControl("ddEmptyInsertTaskGroupTask") as DropDownList;
                    //TaskGroup.AddTask(SelectedTaskgroupId, Int32.Parse(ddEmptyInsertTaskGroupTask.SelectedValue));
                    //FillTaskGroupTasks(SelectedTaskgroupId);
                    //this.gvTaskGroupTasks.DataBind();
                }
                break;
            case "Delete":
                {                    
                    Int32 BuildId = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Build.DeleteBuild(BuildId);
                    }
                    catch (Exception ex)
                    {
                        this.lblBuildErrorText.Visible = true;
                        this.lblBuildErrorText.Text = "Failed to delete build. Must first remove the jobs that reference this build.<br>" + ex.Message;
                        return;
                    }
                    FillBuilds();
                    this.gvBuilds.DataBind();
                }
                break;
        }
    }
    protected void gvBuilds_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvEnvCredentials_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvEnvCredentials_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        switch (e.CommandName)
        {
            case "Insert":
                {
                    Int32 SelectedEnvironmentId = (Int32)Session["SelectedEnvironmentId"];
                    TextBox txtInsertServer = this.gvEnvCredentials.FooterRow.FindControl("txtInsertServer") as TextBox;
                    CheckBox cbInsertEncrypted = this.gvEnvCredentials.FooterRow.FindControl("cbInsertEncrypted") as CheckBox;
                    DropDownList ddInsertCredType = this.gvEnvCredentials.FooterRow.FindControl("ddInsertCredType") as DropDownList;
                    TextBox txtInsertPassword = this.gvEnvCredentials.FooterRow.FindControl("txtInsertPassword") as TextBox;

                    Byte byteCredType = Byte.Parse(ddInsertCredType.SelectedValue);

                    Environment.AddCredentials(SelectedEnvironmentId, txtInsertServer.Text,
                        cbInsertEncrypted.Checked, byteCredType, txtInsertPassword.Text);

                    FillCredentials(SelectedEnvironmentId);
                    this.gvEnvCredentials.DataBind();
                }
                break;
            case "EmptyInsert":
                {
                    Int32 SelectedEnvironmentId = (Int32)Session["SelectedEnvironmentId"];
                    TextBox txtEmptyInsertUserName = this.gvEnvCredentials.Controls[0].Controls[0].FindControl("txtEmptyInsertUserName") as TextBox;
                    TextBox txtEmptyInsertServer = this.gvEnvCredentials.Controls[0].Controls[0].FindControl("txtEmptyInsertServer") as TextBox;
                    CheckBox cbEmptyInsertEncrypted = this.gvEnvCredentials.Controls[0].Controls[0].FindControl("cbEmptyInsertEncrypted") as CheckBox;
                    DropDownList ddEmptyInsertCredType = this.gvEnvCredentials.Controls[0].Controls[0].FindControl("ddEmptyInsertCredType") as DropDownList;
                    TextBox txtEmptyInsertPassword = this.gvEnvCredentials.Controls[0].Controls[0].FindControl("txtEmptyInsertPassword") as TextBox;

                    Byte byteCredType = Byte.Parse(ddEmptyInsertCredType.SelectedValue);

                    Environment.AddCredentials(SelectedEnvironmentId, txtEmptyInsertServer.Text, 
                        cbEmptyInsertEncrypted.Checked, byteCredType, txtEmptyInsertPassword.Text);
                    FillCredentials(SelectedEnvironmentId);
                    this.gvEnvCredentials.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 SelectedEnvironmentId = (Int32)Session["SelectedEnvironmentId"];
                    Int32 CredentialId = Int32.Parse(e.CommandArgument.ToString());
                    Credential.DeleteCredencial(CredentialId);
                    FillCredentials(SelectedEnvironmentId);
                    this.gvEnvCredentials.DataBind();
                }
                break;
        }
    }



    private void PopulateEnvironments()
    {
        if (ddlEnv.SelectedItem == null)
        {
            string sql = "select * from t_environments";
            try
            {
                DataTable dt = GetData(sql, s_reportingDBName);
                ddlEnv.Items.Add("");
                foreach (DataRow row in dt.Rows)
                {
                    ddlEnv.Items.Add(new ListItem((string)row["vc_environment_name"], Convert.ToString(row["i_env_id"])));
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = ex.Message;
            }
        }
    }

    private void PopulateScheduler()
    {
        if (this.ddlScheduler.SelectedItem == null)
        {
            string sql = "select distinct vc_requestor_username FROM t_jobs";
            try
            {
                DataTable dt = GetData(sql, s_reportingDBName);
                ddlScheduler.Items.Add("");
                foreach (DataRow row in dt.Rows)
                {
                    this.ddlScheduler.Items.Add(new ListItem((string)row["vc_requestor_username"], (string)row["vc_requestor_username"]));
                }
            }
            catch (Exception ex)
            {
                this.lblStatus.Text = ex.Message;
            }
        }
    }

    private void PopulateStatus()
    {
        if (ddlStatus.SelectedItem == null)
        {
            string sql = "select * from t_job_states";
            try
            {
                DataTable dt = GetData(sql, s_reportingDBName);
                ddlStatus.Items.Add("");
                foreach (DataRow row in dt.Rows)
                {
                    ddlStatus.Items.Add(new ListItem((string)row["vc_job_state"], Convert.ToString(row["ti_job_state"])));
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = ex.Message;
            }
        }
    }

    private void PopulateResults()
    {
        if (ddlResult.SelectedItem == null)
        {
            string sql = "select * from t_job_results";
            try
            {
                DataTable dt = GetData(sql, s_reportingDBName);
                ddlResult.Items.Add("");
                foreach (DataRow row in dt.Rows)
                {
                    ddlResult.Items.Add(new ListItem((string)row["vc_job_result"], Convert.ToString(row["ti_job_result"])));
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = ex.Message;
            }
        }
    }

    private void PopulateBuilds()
    {
        if (ddlBuild.SelectedItem == null)
        {
            string sql = "select * from t_builds";
            try
            {
                DataTable dt = GetData(sql, s_reportingDBName);
                ddlBuild.Items.Add("");
                foreach (DataRow row in dt.Rows)
                {
                    ddlBuild.Items.Add(new ListItem((string)row["vc_build_name"], Convert.ToString(row["i_build_id"])));
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = ex.Message;
            }
        }
    }

    private string BuildQueryString()
    {
        StringBuilder builder = new StringBuilder("select * from vw_AllJobs");
        string env = String.Empty;
        string status = String.Empty;
        string result = String.Empty;
        string build = String.Empty;
        string scheduler = String.Empty;

        if (this.ddlScheduler.SelectedItem != null)
        {
            scheduler = this.ddlScheduler.SelectedItem.Text;
        }

        if (ddlEnv.SelectedItem != null)
        {
            env = ddlEnv.SelectedItem.Text;
        }

        if (ddlStatus.SelectedItem != null)
        {
            status = ddlStatus.SelectedItem.Text;
        }

        if (ddlResult.SelectedItem != null)
        {
            result = ddlResult.SelectedItem.Text;
        }

        if (ddlBuild.SelectedItem != null)
        {
            build = ddlBuild.SelectedItem.Text;
        }

        List<string> whereItems = new List<string>();

        if (!String.IsNullOrEmpty(scheduler))
        {
            string schedulerCmd = String.Format("vc_requestor_username = \'{0}\' ", scheduler);
            whereItems.Add(schedulerCmd);
        }

        if (!String.IsNullOrEmpty(env))
        {
            string envCmd = String.Format("vc_environment_name = \'{0}\' ", env);
            whereItems.Add(envCmd);
        }

        if (!String.IsNullOrEmpty(status))
        {
            string statusCmd = String.Format("vc_job_state = \'{0}\' ", status);
            whereItems.Add(statusCmd);
        }

        if (!String.IsNullOrEmpty(result))
        {
            string resultCmd = String.Format("vc_job_result = \'{0}\' ", result);
            whereItems.Add(resultCmd);
        }

        if (!String.IsNullOrEmpty(build))
        {
            string buildCmd = String.Format("vc_build_name = \'{0}\' ", build);
            whereItems.Add(buildCmd);
        }

        int i = 0;
        foreach (string item in whereItems)
        {
            if (i == 0)
            {
                builder.Append(" WHERE ");
            }

            builder.Append(item);
            if (i < whereItems.Count - 1)
            {
                builder.Append(" AND ");
            }
            i++;
        }

        builder.Append(" ORDER BY dt_create_date DESC ");

        return builder.ToString();
    }

    private void RefreshJobs()
    {
        //StringBuilder builder = new StringBuilder("SELECT * FROM t_jobs");
        //string env = ddlEnv.SelectedValue;
        //string status = ddlStatus.SelectedValue;
        //string build = ddlBuild.SelectedValue;

        string queryString = BuildQueryString();

        try
        {
            this.gvJobsReport.DataSource = GetData(queryString, s_reportingDBName).DefaultView;
            this.gvJobsReport.DataBind();
        }
        catch (Exception ex)
        {
            lblStatus.Text = ex.Message;
        }
    }



    protected void gvJobsReport_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblStatus.Visible = false;        
        this.gvIssues.Visible = false;

        switch (e.CommandName)
        {
            case "Select":
                {
                    this.gvJobTasks.Visible = true;                    
                    this.gvTaskParams.Visible = false;
                    Int32 jobId = Int32.Parse(e.CommandArgument.ToString());
                    Session.Add("SelectedJobsEnvName", Environment.GetEnvironmentNameFromJobId(jobId));
                    Session.Add("SelectedJobReportId", jobId);
                    FillJobTasks(jobId);
                    this.gvJobTasks.DataBind();
                                        
                    this.gvIssues.Visible = true;
                    //FillIssues(jobId);  // moved to Object data source.
                    this.gvIssues.DataBind();

                    //TextBox txtNotes = this.gvIssues.Controls[0].Controls[0].FindControl("txtEmptyInsertNotes") as TextBox;
                    //txtNotes.Attributes.Add("onfocus", "javascript:__doPostBack('gvJobsReport$ctl02$SelectJob','')");
                    
                    //ReduceIssuesIfNoAuth(((GridViewRow)((WebControl)e.CommandSource).NamingContainer).Cells[4].Text);                    

                    //HookOnFocus(this.Page as Control);
                }
                break;
            case "Restart":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    Boolean ClearLogs = cbClearLogs.Checked;
                    Job.RestartJob(JobId, ClearLogs);
                    RefreshJobs();
                    this.gvJobsReport.DataBind();
                }
                break;
            case "Resume":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    Job.ResumeJob(JobId);
                    RefreshJobs();
                    this.gvJobsReport.DataBind();
                }
                break;

            case "Pause":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    Job.PauseJob(JobId);
                    RefreshJobs();
                    this.gvJobsReport.DataBind();                    
                }
                break;
            case "CancelJob":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    Job.CancelJob(JobId);
                    RefreshJobs();
                    this.gvJobsReport.DataBind();  
                }
                break;
            case "Delete":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Job.DeleteJobReport(JobId);
                    }
                    catch (Exception ex)
                    {
                        this.lblStatus.Text = "Failed to delete Job.<br>" + ex.Message;
                        return;
                    }
                    RefreshJobs();
                }
                break;
            case "Report":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    Response.Redirect("JobResults.aspx?JobId=" + JobId.ToString());                
                }
                break;
            case "Schedule":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Job.ScheduleJob(JobId);
                    }
                    catch (Exception ex)
                    {
                        this.lblStatus.Text = "Failed to schedule Job.<br>" + ex.Message;
                        return;
                    }
                    RefreshJobs();
                }
                break;
            case "UnSchedule":
                {
                    Int32 JobId = Int32.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Job.UnScheduleJob(JobId);
                    }
                    catch (Exception ex)
                    {
                        this.lblStatus.Text = "Unschedule failed.<br>" + ex.Message;
                        return;
                    }
                    RefreshJobs();
                }
                break;
        }
    }

    private void FillIssues(Int32 JobId)
    {
        string sql = "SELECT * FROM t_issues WHERE i_job_id=" + JobId.ToString();
        this.gvIssues.DataSource = GetData(sql, "DeploymentDB_V2").DefaultView;
    }

    private void FillJobTasks(Int32 JobId)
    {
        string sql = "SELECT * FROM vw_JobTasks WHERE i_job_id=" + JobId.ToString();
        this.gvJobTasks.DataSource = GetData(sql,"DeploymentDB_V2").DefaultView;
    }


    protected void ddlEnv_SelectedIndexChanged(object sender, EventArgs e)
    {
        // unselect any job report after filter change.
        Session.Remove("SelectedJobReportId");


        this.gvJobTasks.Visible = false;
        this.gvIssues.Visible = false;
        RefreshJobs();
    }
    protected void ddlStatus_SelectedIndexChanged(object sender, EventArgs e)
    {
        // unselect any job report after filter change.
        Session.Remove("SelectedJobReportId");


        this.gvJobTasks.Visible = false;
        this.gvIssues.Visible = false;

        RefreshJobs();
    }
    protected void ddlResult_SelectedIndexChanged(object sender, EventArgs e)
    {
        // unselect any job report after filter change.
        Session.Remove("SelectedJobReportId");

        this.gvJobTasks.Visible = false;
        this.gvIssues.Visible = false;

        RefreshJobs();
    }
    protected void ddlBuild_SelectedIndexChanged(object sender, EventArgs e)
    {
        // unselect any job report after filter change.
        Session.Remove("SelectedJobReportId");

        this.gvJobTasks.Visible = false;
        this.gvIssues.Visible = false;

        RefreshJobs();
    }
    protected void gvJobsReport_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        String alias = User.Identity.Name.Substring(8);

        if (e.Row.RowType == DataControlRowType.DataRow)
        {

            // fix the Action Button
            if (e.Row.Cells[7].Text == "Not Ready")
            {
                Button b1 = e.Row.Cells[9].Controls[1] as Button;
                b1.Text = "Schedule";
                b1.CommandName = "Schedule";

                Button b2 = e.Row.Cells[9].Controls[3] as Button;
                b2.Text = "Delete";
                b2.CommandName = "Delete";
            }
            else if (e.Row.Cells[7].Text == "Complete")
            {
                Button b1 = e.Row.Cells[9].Controls[1] as Button;                
                b1.Text = "Restart";
                b1.CommandName = "Restart";

                Button b2 = e.Row.Cells[9].Controls[3] as Button;
                b2.Visible = false;                
            }
            else if (e.Row.Cells[7].Text == "Ready")
            {
                Button b1 = e.Row.Cells[9].Controls[1] as Button;
                b1.Text = "UnSchedule";
                b1.CommandName = "UnSchedule";

                Button b2 = e.Row.Cells[9].Controls[3] as Button;
                b2.Visible = false;
            }
            else if (e.Row.Cells[7].Text == "Running")
            {
                Button b1 = e.Row.Cells[9].Controls[1] as Button;
                b1.Text = "Pause";
                b1.CommandName = "Pause";

                Button b2 = e.Row.Cells[9].Controls[3] as Button;
                b2.Text = "Cancel";
                b2.CommandName = "CancelJob";
            }
            else if (e.Row.Cells[7].Text == "Paused")
            {
                Button b1 = e.Row.Cells[9].Controls[1] as Button;
                b1.Text = "Resume";
                b1.CommandName = "Resume";

                Button b2 = e.Row.Cells[9].Controls[3] as Button;
                b2.Visible = false;
            }

            // remove button if user is not authorized.
            string env = e.Row.Cells[4].Text;
            if (this.AuthDictionaryByEnvName.ContainsKey(env))
            {
                // should always hit this since there must be 1 auth user for any environment.
                if (!this.AuthDictionaryByEnvName[env].Contains(User.Identity.Name))
                {
                    Button b1 = e.Row.Cells[9].Controls[1] as Button;
                    b1.Visible = false;

                    Button b2 = e.Row.Cells[9].Controls[3] as Button;
                    b2.Visible = false;

                }
            }
            else
            { 
                // this case is when the current env is not in the t_environments table.
                Button b1 = e.Row.Cells[9].Controls[1] as Button;
                b1.Visible = false;

                Button b2 = e.Row.Cells[9].Controls[3] as Button;
                b2.Visible = false;
            }
            
            // Colorize the Job Result cell            
            //if (e.Row.Cells[8].Text == "None")
            //{
            //    e.Row.Cells[8].BackColor = System.Drawing.Color.Yellow;
            //}
            if (e.Row.Cells[8].Text == "Passed")
            {
                e.Row.Cells[8].BackColor = System.Drawing.Color.LightGreen;
            }
            else if (e.Row.Cells[8].Text == "Failed")
            {
                e.Row.Cells[8].BackColor = System.Drawing.Color.Red;
            }

            // colorize env if env is locked.
            if (e.Row.Cells[11].Text == "True")
            {
                e.Row.Cells[4].BackColor = System.Drawing.Color.Yellow;                
            }

            e.Row.Cells[11].Text = String.Empty;
        }
    }

    protected void gvJobsReport_PageIndexChanged(object sender, EventArgs e)
    {

    }

    protected void gvJobsReport_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        RefreshJobs();
        this.gvJobTasks.Visible = false;       
        this.gvJobsReport.PageIndex = e.NewPageIndex;
        this.gvJobsReport.DataBind();
        Session.Add("CurrentPageIndex", gvJobsReport.PageIndex);
    }

    protected void gvJobTasks_RowCommand1(object sender, GridViewCommandEventArgs e)
    {
        switch (e.CommandName)
        {
            case "Select":
                {
                    this.gvTaskParams.Visible = true;
                    this.gvTaskLogs.Visible = true;
                    if (this.gvJobsReport.SelectedRow.Cells[6].Text != "Not Ready")
                    {
                        this.gvTaskParams.Columns[0].Visible = false;
                    }
                    else
                    {
                        this.gvTaskParams.Columns[0].Visible = true;
                    }
                    int taskId = int.Parse(e.CommandArgument.ToString());
                    Session.Add("MonitorSelectedTaskId", taskId);
                    this.FillTaskLogs(taskId);
                    this.gvTaskLogs.DataBind();
                }
                break;
        }
    }

    private void FillTaskLogs(int TaskId)
    {
        string sql = "SELECT * FROM vw_tasklogs WHERE i_task_id=" + TaskId.ToString();
        this.gvTaskLogs.DataSource = this.GetData(sql, "DeploymentDB_V2");
    }

    private void FillTaskParameters(Int32 TaskId)
    {
        string sql = "SELECT * FROM t_task_parameters WHERE i_task_id=" + TaskId.ToString();
        this.gvTaskParams.DataSource = GetData(sql, "DeploymentDB_V2");
    }

    protected void gvJobTasks_PageIndexChanged(object sender, EventArgs e)
    {
    }
    protected void gvJobTasks_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        Int32 selectedJobReportId = (Int32)Session["SelectedJobReportId"];
        FillJobTasks(selectedJobReportId);
        this.gvTaskParams.Visible = false;
        this.gvJobTasks.PageIndex = e.NewPageIndex;
        this.gvJobTasks.DataBind();
    }
    protected void gvTaskParams_RowEditing(object sender, GridViewEditEventArgs e)
    {
        this.gvTaskParams.EditIndex = e.NewEditIndex;
        
    }
    protected void gvJobsReport_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvJobTasks_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType == DataControlRowType.DataRow)
        {
            if (e.Row.Cells[6].Text == "Succeeded")
            {
                e.Row.Cells[6].BackColor = Color.LightGreen;
            }
            else if (e.Row.Cells[6].Text == "Failed")
            {
                e.Row.Cells[6].BackColor = Color.Red;
            }
            else if (e.Row.Cells[6].Text == "Skipped")
            {
                e.Row.Cells[6].BackColor = Color.Yellow;
            }
            int result = 0;
            if (int.TryParse(e.Row.Cells[4].Text, out result))
            {
                e.Row.Cells[4].Text = (((float)result) / 60f).ToString("F1");
            }
        }
    }
    protected void gvTaskLogs_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType == DataControlRowType.DataRow)
        {
            if (e.Row.Cells[0].Text == "&nbsp;")
            {
                e.Row.Cells[0].Text = e.Row.Cells[1].Text;
                e.Row.Cells[1].Text = string.Empty;
            }
            if (e.Row.Cells[0].Text.StartsWith(@"\\"))
            {
                e.Row.Cells[0].Text = "<a href='" + e.Row.Cells[0].Text + "'>DeploymentSession.xml</a>";
            }
            else if (e.Row.Cells[0].Text.Length > 0)
            {
                TextBox child = new TextBox();
                child.TextMode = TextBoxMode.MultiLine;
                child.Rows = 10;
                child.Text = e.Row.Cells[0].Text;
                child.Width = 800;
                e.Row.Cells[0].Text = string.Empty;
                e.Row.Cells[0].Controls.Add(child);
            }
        }

    }
    protected void gvTaskLogs_DataBound(object sender, EventArgs e)
    {
        //this.gvTaskLogs.Columns[1].Visible = false;
        //this.gvTaskLogs.Columns[1].HeaderText = String.Empty;
    }
    protected void gvTasks_PageIndexChanging(object sender, GridViewPageEventArgs e)
    {
        this.FillTasks();
        this.gvTasks.PageIndex = e.NewPageIndex;
        this.gvTasks.DataBind();
    }


    protected void ddlScheduler_SelectedIndexChanged(object sender, EventArgs e)
    {
        // unselect any job report after filter change.
        Session.Remove("SelectedJobReportId");

        this.gvJobTasks.Visible = false;        
        RefreshJobs();
    }
    protected void gvTasks_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        GridView gridView = (GridView)sender;

        if (e.Row.RowType == DataControlRowType.Header)
        {
            e.Row.Cells[2].CssClass = "headerstyle";
            e.Row.Cells[3].CssClass = "headerstyle";
            e.Row.Cells[4].CssClass = "headerstyle";

            if (String.IsNullOrEmpty(gridView.SortExpression)) return;
            
            int cellIndex = -1;
            foreach (DataControlField field in gridView.Columns)
            {
                if (field.SortExpression == gridView.SortExpression)
                {
                    cellIndex = gridView.Columns.IndexOf(field);
                }
            }

            if (cellIndex > -1)
            {
                //  this is a header row,
                //  set the sort style
                e.Row.Cells[cellIndex].CssClass =
                    gridView.SortDirection == SortDirection.Ascending
                    ? "sortascheaderstyle" : "sortdescheaderstyle";
            }
        }

    }
    protected void gvParameters_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        GridView gridView = (GridView)sender;

        if (e.Row.RowType == DataControlRowType.DataRow)
        {
            Label lblName = (Label)e.Row.Cells[0].Controls[1];
            Label lblVal = (Label)e.Row.Cells[1].Controls[1];
            if (lblName.Text.ToUpper() == "PARAM_BLOCK")
            {
                lblVal.Text = lblVal.Text.Replace("<", "&lt;");
                lblVal.Text = lblVal.Text.Replace(">", "&gt;");
                lblVal.Text = lblVal.Text.Replace("\r\n", "<br>");
                
                //gridView.FooterRow.Visible = false;
            }
        }
    }
    protected void gvAuth_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblAuthStatus.Visible = false;
        Int32 SelectedEnvironmentId = (Int32)Session["SelectedEnvironmentId"];
        switch (e.CommandName)
        {
            case "Insert":
                {
                    TextBox txtAlias = this.gvAuth.FooterRow.FindControl("txtInsertAuth") as TextBox;
                    try
                    {
                        Auth.AddAuth(SelectedEnvironmentId, txtAlias.Text);
                    }
                    catch (Exception ex)
                    {
                        this.lblAuthStatus.Text = ex.Message;
                        this.lblAuthStatus.Visible = true;
                    }
                    FillAuth(SelectedEnvironmentId);
                    this.gvAuth.DataBind();
                }
                break;
            case "Delete":
                {
                    
                    int AuthId = int.Parse(e.CommandArgument.ToString());
                    try
                    {
                        Auth.DeleteAuth(AuthId);
                    }
                    catch (Exception ex)
                    {
                        this.lblAuthStatus.Text = ex.Message;
                        this.lblAuthStatus.Visible = true;
                    }

                    if (this.AuthDictionaryByEnvId[SelectedEnvironmentId].Contains(User.Identity.Name))
                    {
                        this.gvAuth.ShowFooter = true;
                        this.gvAuth.Columns[1].Visible = true;
                    }
                    else
                    {
                        this.gvAuth.ShowFooter = false;
                        this.gvAuth.Columns[1].Visible = false;
                    }
                    
                    // refill auth dictionaries.
                    this.AuthDictionaryByEnvName = Auth.GetAuthDictionaryByEnvName();
                    this.AuthDictionaryByEnvId = Auth.GetAuthDictionaryByEnvId();

                    FillEnvironments();
                    FillAuth(SelectedEnvironmentId);
                    this.gvEnvironments.DataBind();
                    this.gvAuth.DataBind();
                }
                break;
        }
    }
    protected void gvAuth_RowDeleting(object sender, GridViewDeleteEventArgs e)
    { 
    
    }

    protected void gvEnvironments_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType == DataControlRowType.DataRow)
        {
            // env in col 1. delete link button in col 7.
            string envName = ((Label)e.Row.Cells[1].Controls[1]).Text;
            string user = User.Identity.Name;

            if (this.AuthDictionaryByEnvName.ContainsKey(envName))
            {
                if (!this.AuthDictionaryByEnvName[envName].Contains(user))
                {
                    // current user is not auth for this env.
                    LinkButton lb = e.Row.Cells[10].Controls[1] as LinkButton;
                    lb.Visible = false;
                }
            }
            else
            {
                LinkButton lb = e.Row.Cells[10].Controls[1] as LinkButton;
                lb.Visible = false;
            }
        }
    }

    protected void gvIssues_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        this.lblIssueStatus.Visible = false;

        Int32 SelectedJobReportId = (Int32)Session["SelectedJobReportId"];
        switch (e.CommandName)
        {
            case "EmptyInsert":
                {
                    TextBox txtEmptyInsertBugNumber = this.gvIssues.Controls[0].Controls[0].FindControl("txtEmptyInsertBugNumber") as TextBox;
                    TextBox txtEmptyInsertNotes = this.gvIssues.Controls[0].Controls[0].FindControl("txtEmptyInsertNotes") as TextBox;
                    DropDownList ddEmptyInsertPsDatabase = this.gvIssues.Controls[0].Controls[0].FindControl("ddEmptyInsertPsDatabase") as DropDownList;
                    Int32 BugId = 0;
                    Int32.TryParse(txtEmptyInsertBugNumber.Text, out BugId);
                    Issue.AddIssue(SelectedJobReportId, BugId, ddEmptyInsertPsDatabase.SelectedValue, txtEmptyInsertNotes.Text);                                        
                    this.gvIssues.DataBind();
                }
                break;
            case "Delete":
                {
                    //Int32 IssueId = Int32.Parse(e.CommandArgument.ToString());
                    //Issue.DeleteIssue(IssueId);
                    //FillIssues(SelectedJobReportId);
                    //this.gvIssues.DataBind();                    
                }
                break;
            case "Insert":
                {
                    TextBox txtInsertBugNumber = this.gvIssues.FooterRow.FindControl("txtInsertBugNumber") as TextBox;
                    TextBox txtInsertNotes = this.gvIssues.FooterRow.FindControl("txtInsertNotes") as TextBox;
                    DropDownList ddPSDatabase = this.gvIssues.FooterRow.FindControl("ddPSDatabase") as DropDownList;
                    Int32 BugId = 0;
                    // don't care if the values stays zero.  This will be treated as empty bug id later.
                    Int32.TryParse(txtInsertBugNumber.Text, out BugId);                    
                    Issue.AddIssue(SelectedJobReportId, BugId, ddPSDatabase.SelectedValue, txtInsertNotes.Text);
                    //FillIssues(SelectedJobReportId);
                    this.gvIssues.DataBind();
                }
                break;
        }
    }
    protected void gvIssues_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }

    protected void cbLocked_CheckedChanged(object sender, EventArgs e)
    {
        Int32 envId = Int32.Parse(((CheckBox)sender).ToolTip);
        Environment.FlipEnvLock(envId);
        FillEnvironments();
        this.gvEnvironments.DataBind();

    }

    protected void Timer1_Tick(object sender, EventArgs e)
    {
        this.RefreshJobs();
        this.gvJobsReport.DataBind();

        this.lblRefreshTime.Text = "Last Refresh Time: " + DateTime.Now.ToString("G");

        if (Session["SelectedJobReportId"] != null)
        {
            Int32 selectedJobReportId = (Int32)Session["SelectedJobReportId"];
            this.gvIssues.Visible = true;
            this.gvJobTasks.Visible = true;
            //this.gvTaskParams.Visible = false;
            FillJobTasks(selectedJobReportId);
            this.gvJobTasks.DataBind();
            if (Session["MonitorSelectedTaskId"] != null)
            {
                Int32 selectedTaskId = (Int32)Session["MonitorSelectedTaskId"];
                FillTaskLogs(selectedTaskId);
                this.gvTaskLogs.DataBind();
            }

            //ReduceIssuesIfNoAuth(this.gvJobsReport.SelectedRow.Cells[4].Text);
        }

        //ScriptManager.RegisterStartupScript(this, typeof(_Default), "ScriptDoFocus", SCRIPT_DOFOCUS2.Replace("REQUEST_LASTFOCUS", Request["__LASTFOCUS"]), true);
    }

    //private void HookOnFocus(Control CurrentControl)
    //{
    //    //checks if control is one of TextBox, DropDownList, ListBox or Button
    //    if ((CurrentControl is TextBox) ||
    //        (CurrentControl is DropDownList) ||
    //        (CurrentControl is ListBox) ||
    //        (CurrentControl is Button))
    //        //adds a script which saves active control on receiving focus 
    //        //in the hidden field __LASTFOCUS.
    //        (CurrentControl as WebControl).Attributes.Add(
    //       "onfocus",
    //       "try{document.getElementById('__LASTFOCUS').value=this.id} catch(e) {}");
    //    //checks if the control has children
    //    if (CurrentControl.HasControls())
    //        //if yes do them all recursively
    //        foreach (Control CurrentChildControl in CurrentControl.Controls)
    //            HookOnFocus(CurrentChildControl);
    //}





    protected void gvIssues_PreRender(object sender, EventArgs e)
    {
        // do not gvIssues.DataBind() here because it will delete any existing text that user may have typed.
        //this.gvIssues.DataBind();
        String EnvName = (String) Session["SelectedJobsEnvName"];
        // if user is not authorized for this jobs env, then do not allow issue edit.
        // but still show list of issues.
        if (this.AuthDictionaryByEnvName.ContainsKey(EnvName))
        {
            if (!this.AuthDictionaryByEnvName[EnvName].Contains(User.Identity.Name))
            {
                if (this.gvIssues.Rows.Count == 0)
                {                    
                    this.gvIssues.Visible = false;
                }
                else
                {
                    this.gvIssues.AutoGenerateEditButton = false;
                    this.gvIssues.ShowFooter = false;
                    this.gvIssues.Columns[4].Visible = false;
                }
            }
            else
            {
                this.gvIssues.Visible = true;                
                this.gvIssues.AutoGenerateEditButton = true;
                this.gvIssues.ShowFooter = true;
                this.gvIssues.Columns[3].Visible = true;
            }
        }
        else
        {
            if (this.gvIssues.Rows.Count == 0)
            {                
                this.gvIssues.Visible = false;
            }
            else
            {
                this.gvIssues.AutoGenerateEditButton = false;
                this.gvIssues.ShowFooter = false;
                this.gvIssues.Columns[4].Visible = false;
            }
        }
    }
    protected void lnkSetAutoRefresh_Click(object sender, EventArgs e)
    {
        if (this.Timer1.Enabled)
        {
            this.Timer1.Enabled = false;
            this.lnkSetAutoRefresh.Text = "Auto Refresh is OFF";
        }
        else
        {
            this.Timer1.Enabled = true;
            this.lnkSetAutoRefresh.Text = "Auto Refresh is ON";
        }
    }
    protected void gvEnvServers_RowCommand(object sender, GridViewCommandEventArgs e)
    {        
        Int32 SelectedEnvironmentId = (Int32)Session["SelectedEnvironmentId"];
        switch (e.CommandName)
        {
            case "EmptyInsert":
                {
                    TextBox txtEmptyInsertServerName = this.gvEnvServers.Controls[0].Controls[0].FindControl("txtEmptyInsertServerName") as TextBox;
                    CheckBox cbEmptyInsertSnapshotIgnore = this.gvEnvServers.Controls[0].Controls[0].FindControl("cbEmptyInsertSnapshotIgnore") as CheckBox;
                    DropDownList ddEmptyInsertRole = this.gvEnvServers.Controls[0].Controls[0].FindControl("ddEmptyInsertRole") as DropDownList;
                    Environment.AddServer(SelectedEnvironmentId, txtEmptyInsertServerName.Text, cbEmptyInsertSnapshotIgnore.Checked, Int32.Parse(ddEmptyInsertRole.SelectedValue));
                    FillServers(SelectedEnvironmentId);
                    this.gvEnvServers.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 ServerId = Int32.Parse(e.CommandArgument.ToString());
                    Environment.DeleteServer(ServerId);
                    FillServers(SelectedEnvironmentId);
                    this.gvEnvServers.DataBind();                                      
                }
                break;
            case "Insert":
                {
                    TextBox txtInsertServerName = this.gvEnvServers.FooterRow.FindControl("txtInsertServerName") as TextBox;
                    CheckBox cbInsertSnapshotIgnore = this.gvEnvServers.FooterRow.FindControl("cbInsertSnapshotIgnore") as CheckBox;
                    DropDownList ddInsertRole = this.gvEnvServers.FooterRow.FindControl("ddInsertRole") as DropDownList;

                    Environment.AddServer(SelectedEnvironmentId, txtInsertServerName.Text, cbInsertSnapshotIgnore.Checked, Int32.Parse(ddInsertRole.SelectedValue));
                    FillServers(SelectedEnvironmentId);
                    this.gvEnvServers.DataBind();  
                }
                break;
        }
    }
    protected void gvEnvServers_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvEnvServers_PreRender(object sender, EventArgs e)
    {
        
        //if (Session["SelectedEnvironmentId"] == null) return;

        //Int32 EnvId = (Int32)Session["SelectedEnvironmentId"];
                        
        //if (!this.AuthDictionaryByEnvId[EnvId].Contains(User.Identity.Name))
        //{
        //    if (this.gvEnvServers.Rows.Count == 0)
        //    {
        //        this.gvEnvServers.Visible = false;
        //    }
        //    else
        //    {
        //        this.gvEnvServers.AutoGenerateEditButton = false;
        //        this.gvEnvServers.FooterRow.Visible = false;                
        //        this.gvEnvServers.Columns[3].Visible = false;
        //    }
        //}
        //else
        //{
        //    this.gvEnvServers.Visible = true;
        //    this.gvEnvServers.AutoGenerateEditButton = true;
        //    this.gvEnvServers.ShowFooter = true;
        //    this.gvEnvServers.Columns[3].Visible = true;
        //}        
    }

    protected void Menu1_MenuItemClick(object sender, MenuEventArgs e)
    {
        switch (this.Menu1.SelectedItem.Text)
        {
            case "Job Monitor":                
                PopulateEnvironments();
                PopulateStatus();
                PopulateResults();
                PopulateBuilds();
                PopulateScheduler();
                RefreshJobs();
                break;
            case "Jobs":
                FillJobs();
                this.gvJobs.DataBind();
                break;
            case "Environments":
                FillEnvironments();
                this.gvEnvironments.DataBind();
                break;
            case "Builds":
                FillBuilds();
                this.gvBuilds.DataBind();
                break;
            case "TaskGroups":
                FillTaskGroups();
                this.gvTaskGroups.DataBind();
                break;
            case "Tasks":
                FillTasks();
                this.gvTasks.DataBind();
                break;
            case "Audit":
                FillAudit();
                this.gvAudit.DataBind();
                break;
            case "Private Deployment":
                this.lblPrivateBuildInfo.Visible = false;
                break;
            case "HealthCheck Monitors":
                Response.Redirect("http://xon123:8888/Log/HealthCheckMonitor.xml");
                break;
        }

        this.mvMain.ActiveViewIndex = Int32.Parse(e.Item.Value);
    }
    protected void btnSchedulePrivateJob_Click(object sender, EventArgs e)
    {
        //if (!Directory.Exists(this.txtPrivateBuildLocation.Text))
        //{
        //    this.lblError.Text = "Directory not found: " + this.txtPrivateBuildLocation.Text;
        //    return;
        //}

        string buildName = "PRIVATE_BUILD";

        Int32 buildId = Build.AddBuild(buildName, this.txtPrivateBuildLocation.Text);
        try
        {
            Job newJob = new Job(JOB_ID, ENV_ID, buildId, "PRIVATE_VERSION", User.Identity.Name);
            newJob.CreateJob();
            this.lblPrivateBuildInfo.Text = "Job created successfully. Click 'Job Monitor' to monitor progress.";
            this.lblPrivateBuildInfo.Visible = true;
            this.lblPrivateBuildInfo.ForeColor = System.Drawing.Color.Green;
        }
        catch (Exception ex)
        {
            this.lblPrivateBuildInfo.Text = "Job creation failed.<br>" + ex.Message;
            this.lblPrivateBuildInfo.Visible = true;
            this.lblPrivateBuildInfo.ForeColor = System.Drawing.Color.Red;
        }

    }

    protected void gvSubEnvs_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        Int32 SelectedEnvironmentId = (Int32)Session["SelectedEnvironmentId"];
        switch (e.CommandName)
        {
            case "EmptyInsert":
                {
                    DropDownList ddEmptyInsertSubEnv = this.gvSubEnvs.Controls[0].Controls[0].FindControl("ddEmptyInsertSubEnvName") as DropDownList;
                    Environment.AddSubEnvironment(SelectedEnvironmentId, Int64.Parse(ddEmptyInsertSubEnv.SelectedValue));
                    //Environment.AddServer(SelectedEnvironmentId, txtEmptyInsertServerName.Text, cbEmptyInsertSnapshotIgnore.Checked, Int32.Parse(ddEmptyInsertRole.SelectedValue));
                    FillSubEnvs(SelectedEnvironmentId);
                    this.gvSubEnvs.DataBind();
                }
                break;
            case "Delete":
                {
                    Int32 SubEnvId = Int32.Parse(e.CommandArgument.ToString());
                    Environment.DeleteSubEnvironment(SelectedEnvironmentId, SubEnvId);
                    FillSubEnvs(SelectedEnvironmentId);
                    this.gvSubEnvs.DataBind();
                }
                break;
            case "Insert":
                {
                    DropDownList ddInsertSubEnvironment = this.gvSubEnvs.FooterRow.FindControl("ddInsertSubEnv") as DropDownList;
                    Int32 subEnvId = Int32.Parse(ddInsertSubEnvironment.SelectedValue);
                    Environment.AddSubEnvironment(SelectedEnvironmentId, subEnvId);                    
                    FillSubEnvs(SelectedEnvironmentId);
                    this.gvSubEnvs.DataBind();
                }
                break;
            case "SetActive":
                {
                    Int32 subEnvId = Int32.Parse(e.CommandArgument.ToString());
                    Environment.SetSubEnvironment(SelectedEnvironmentId, subEnvId);
                    FillSubEnvs(SelectedEnvironmentId);
                    this.gvSubEnvs.DataBind();
                }
                break;
        }
    }
    protected void gvSubEnvs_RowDeleting(object sender, GridViewDeleteEventArgs e)
    {

    }
    protected void gvSubEnvs_RowDataBound(object sender, GridViewRowEventArgs e)
    {
        if (e.Row.RowType == DataControlRowType.DataRow)
        {
            LinkButton lb = (LinkButton)e.Row.Cells[1].Controls[1];
            if (lb.Text.Equals("True"))
            {
                lb.Text = "Active";
                lb.Enabled = false;
            }
            else
            {
                lb.Text = "Inactive";
                lb.Enabled = true;
            }
        }
    }
    protected void gvJobsReport_PreRender(object sender, EventArgs e)
    {
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\App_Code\UserPrivileges.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Web;

/// <summary>
/// Summary description for UserPrivileges
/// </summary>
public class UserPrivileges
{
    public string UserName { get; private set; }
    private Dictionary<string, Privileges> _privileges;
    
    public UserPrivileges(string userName)
	{
        // Store the user name without the domain
        string [] userNameParts = userName.Split('\\');
        if (userNameParts.Length > 1)
            UserName = userNameParts[1];
        else
            UserName = userName;
        _privileges = new Dictionary<string, Privileges>();
        using (SqlConnection conn = new SqlConnection(Utils.DBConnectionString))
        {
            conn.Open();
            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_priv_get_user_privileges";
                cmd.Parameters.AddWithValue("@userName", userName);

                SqlDataReader reader = null;

                try
                {
                    reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        _privileges.Add(reader["TargetEnvironment"] as string, (Privileges)(Int32)reader["Privileges"]);
                    }
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }
            }
        }
	}

    public Privileges GetPrivileges(string envName)
    {
        if (_privileges.ContainsKey(envName))
            return _privileges[envName];
        else if (_privileges.ContainsKey("All"))
            return _privileges["All"];
        else
            return Privileges.None;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\DeployBvtNet\Logger.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Diagnostics;


namespace BvtNetAutomation
{
    /// <summary>
    /// This class logs file for each day. The log file has the time related to each message. 
    /// The Log file located in the current working directory with the name of ..............
    /// </summary>
    public class Logger
    {
        private const string LOGFILENAME = "AutomationLog_";
        public const string LOGFILEFOLDER = "Log";

        /// <summary>
        /// Logs file in the current directory 
        /// </summary>
        /// <param name="Message"></param>
        public static void WriteToLog(string Message)
        {
            StreamWriter writer = null;
            try
            {
                if (!Directory.Exists(Directory.GetCurrentDirectory() + "\\" + Logger.LOGFILEFOLDER))
                    Directory.CreateDirectory(Directory.GetCurrentDirectory() + "\\" + Logger.LOGFILEFOLDER);
                writer = File.AppendText(Directory.GetCurrentDirectory() + "\\" + Logger.LOGFILEFOLDER +
                    "\\" + Logger.LOGFILENAME + DateTime.Today.ToString("MM-dd-yyyy") + ".log");
                writer.WriteLine(DateTime.Now + "\t" + Message);
                writer.WriteLine();
                writer.Close();
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }
        }

    }//class
}//ns
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\DeployBvtNet\OctopusProcess.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace BvtNetAutomation
{
    public enum OctopusPendingRebootOperation
    {
        Ignore, Error, Reboot
    }

    public enum OctopusInstallationType
    {
        Install, Uninstall
    }
    /// <summary>
    /// this class used to set the necessary parameters to run octopus and run it
    /// </summary>
    public class OctopusProcess
    {
        private bool _useFakeAgent;
        private bool _useVerboseMsiLogging;
        private string _password;
        private string _pathToConfigurationFile;
        private string _pathToLogLocationFile;
        private OctopusPendingRebootOperation _pendingRebootOperation = OctopusPendingRebootOperation.Ignore;
        private OctopusInstallationType _installationType = OctopusInstallationType.Install;

        /// <summary>
        /// this method pass the argument lists to Octopus to start the process
        /// </summary>
        public void Run()
        {
            //argumentListBuilder to append the info for execution file
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.Append("-");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusInstallationType), InstallationType));
            argumentListBuilder.Append(" ");
            argumentListBuilder.Append("-onpendingrebootoperation ");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusPendingRebootOperation), PendingRebootOperation));
            argumentListBuilder.Append(" ");
            if (UseFakeAgent)
                argumentListBuilder.Append("-fakeAgent");
            else
                argumentListBuilder.Append("-adminpassword " + Password);
            argumentListBuilder.Append(" ");

            if (PathToConfigurationFile != null)
                argumentListBuilder.Append(String.Format("-config \"{0}\"", PathToConfigurationFile));
            argumentListBuilder.Append(" ");

            if (PathToLogLocationFile != null)
                argumentListBuilder.Append(String.Format("-recordlogfolderin \"{0}\"", PathToLogLocationFile));
            argumentListBuilder.Append(" ");

            if (UseVerboseMsiLogging)
                argumentListBuilder.Append("-verbosemsilogging");
            argumentListBuilder.Append(" ");

            //Command-line arguments to pass to the application when the process starts.
            ProcessStartInfo processStartInfo = new ProcessStartInfo(
             "octopuscli.exe", argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;

            Process octopus = Process.Start(processStartInfo);
            octopus.WaitForExit();
        }

        public bool UseFakeAgent
        {
            get { return _useFakeAgent; }
            set { _useFakeAgent = value; }
        }
        public bool UseVerboseMsiLogging
        {
            get { return _useVerboseMsiLogging; }
            set { _useVerboseMsiLogging = value; }
        }

        public string Password
        {
            get { return _password; }
            set { _password = value; }
        }

        public string PathToConfigurationFile
        {
            get { return _pathToConfigurationFile; }
            set { _pathToConfigurationFile = value; }
        }
        public string PathToLogLocationFile
        {
            get { return _pathToLogLocationFile; }
            set { _pathToLogLocationFile = value; }
        }

        public OctopusPendingRebootOperation PendingRebootOperation
        {
            get { return _pendingRebootOperation; }
            set { _pendingRebootOperation = value; }
        }
        public OctopusInstallationType InstallationType
        {
            get { return _installationType; }
            set { _installationType = value; }
        }

    }//class
}//ns
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Website\App_Code\DepAutoDBAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.ComponentModel;


/// <summary>
/// Summary description for DepAutoDBAccess
/// </summary>
public class Job
{
    private Int32 jobId;
    private Build build;
    private Environment env;
    private JobType jobType;
    private string jobName;
    private JobPriority priority;
    private string version;  // will either be the build number or 'PRIVATE' for private builds.
    private List<TaskGroup> taskGroupList;
    private string scheduler;
    //private DateTime startTime;
    //private DateTime endTime;
    //private string result;

    // Parameter tokens. This is the list of replaceable parameter tokens understood by BDService (and website)
    internal const string ParamTokenBuildName = "##BuildName##";
    internal const string ParamTokenBuildPath = "##BuildPath##";
    internal const string ParamTokenBuildVersion = "##BuildVersion##";
    internal const string ParamTokenEnvironment = "##Environment##";
    internal const string ParamTokenJobId = "##JobId##";
    internal const string ParamTokenJobType = "##JobType##";
    internal const string ParamTokenStagerName = "##StagerName##";
    internal const string ParamTokenStagerBuildShare = "##StagerBuildShare##";
    internal const string ParamTokenStagerTitleShare = "##StagerTitleShare##";
    internal const string ParamTokenEnvUserName = "##EnvUserName##";
    internal const string ParamTokenLocalPassword = "##LocalPassword##";
    internal const string ParamTokenLocalPasswordEncrypted = "##LocalPasswordEncrypted##";
    internal const string ParamTokenRemotePassword = "##RemotePassword##";
    internal const string ParamTokenRemotePasswordEncrypted = "##RemotePasswordEncrypted##";
    internal const string ParamTokenEnvHostList = "##EnvHostList##";
    internal const string ParamTokenEnvServerPrefix = "##EnvServerPrefix##";
    internal const string ParamTokenEnvAllSQL1 = "##EnvAllSQL1##";
    internal const string ParamTokenEnvAllSQL2 = "##EnvAllSQL2##";
    internal const string ParamTokenEnvCatrSQL = "##EnvCatrSQL##";
    internal const string ParamTokenEnvMstrSQL = "##EnvMstrSQL##";
    internal const string ParamTokenEnvPoolIIS = "##EnvPoolIIS##";
    internal const string ParamTokenEnvPoolINH = "##EnvPoolINH##";
    internal const string ParamTokenEnvSecuINH = "##EnvSecuINH##";
    internal const string ParamTokenEnvInfrTLS = "##EnvInfrTLS##";
    internal const string ParamTokenEnvClient = "##EnvClient##";
    internal const string ParamTokenEnvAllServersList = "##EnvAllServersList##";
    internal const string ParamTokenEnvClientPoolIpBegin = "##EnvClientPoolIpBegin##";
    internal const string ParamTokenEnvClientPoolIpEnd = "##EnvClientPoolIpEnd##";
    internal const string ParamTokenEnvSGAdminIp = "##EnvSGAdminIp##";
    internal const string ParamTokenEnvSGInternetIp = "##EnvSGInternetIp##";
    internal const string ParamTokenEnvXDSInternetIp = "##EnvXDSInternetIp##";
    internal const string ParamTokenEnvClientPoolNetmask = "##EnvClientPoolNetmask##";
    internal const string ParamTokenEnvClientPoolGateway = "##EnvClientPoolGateway##";
    internal const string ParamTokenEnvInternetNetmask = "##EnvInternetNetmask##";
    internal const string ParamTokenEnvInternetGateway = "##EnvInternetGateway##";
    internal const string ParamTokenEnvCatalogIp = "##EnvCatalogIp##";
    
    public Job(Int32 JobId, Int32 EnvId, Int32 BuildId, String Version, String Scheduler)
    {
        this.scheduler = Scheduler;

        this.taskGroupList = new List<TaskGroup>();
        this.jobId = JobId;

        //BuildInfo buildInfo = GetBuildInfoFromJobId(JobId);
        //this.version = GetNewBuildVersion(buildInfo.BuildSourcePath);
        // should not need build number any more.  We are getting the drop location from the build.path which
        // should include build number if not a custom build location or latest.tst build type.
        //this.version = BuildNumber;

        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM vw_AllJobs WHERE i_job_id=" + JobId.ToString(), cn);

        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        this.version = Version;
        this.build = new Build(BuildId);
        this.env = new Environment(EnvId);
        this.jobType = (JobType) Enum.Parse(typeof(JobType), (string)dr["vc_job_type"]);
        this.jobName = (string)dr["vc_job_name"];
        this.priority = (JobPriority) Enum.Parse(typeof(JobPriority), (string) dr["vc_priority"]);
        //this.startTime = (DateTime)dr["dt_job_start_date"];
        //this.endTime = (DateTime)dr["dt_job_end_date"];
        //this.result = (string)dr["vc_job_result"];

        dr.Close();
        
        cmd = new SqlCommand("SELECT i_taskGroup_id FROM t_job_taskgroups WHERE i_job_id=" + JobId.ToString() + " ORDER BY i_order", cn);
        dr = cmd.ExecuteReader();
        while (dr.Read())
        {
            Int32 TaskGroupId = (Int32) dr["i_taskgroup_id"];

            TaskGroup tg = new TaskGroup(TaskGroupId);
            this.taskGroupList.Add(tg);
        }
        dr.Close();
        cn.Close();
    }

    public Build JobBuild
    {
        get { return this.build; }
    }

    public Environment Env
    {
        get { return this.env; }
    }

    //public String Version
    //{
    //    get { return this.version; }
    //}

    //public DateTime StartTime
    //{
    //    get { return this.startTime; }
    //}

    //public DateTime EndTime
    //{
    //    get { return this.endTime; }
    //}

    //public String Result
    //{
    //    get { return this.result; }
    //}

    public static void RestartJob(Int32 JobId, Boolean ClearLogs)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_restart_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));
        cmd.Parameters.Add(new SqlParameter("@clearLogs", ClearLogs));
        cmd.ExecuteNonQuery();
        cn.Close();       
    }

    public static void ResumeJob(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_resume_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));        
        cmd.ExecuteNonQuery();
        cn.Close(); 
    }

    public static void ScheduleJob(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_schedule_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void UnScheduleJob(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_unschedule_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));
        cmd.ExecuteNonQuery();
        cn.Close(); 
    }

    public static void PauseJob(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_pause_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));        
        cmd.ExecuteNonQuery();
        cn.Close(); 
    }

    public static void CancelJob(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_cancel_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));
        cmd.ExecuteNonQuery();
        cn.Close(); 
    }


    public static void ChangeState(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_change_job_state", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobId", JobId));
        cmd.ExecuteNonQuery();
        cn.Close();
    }


    public static void AddJob(string JobName, Int32 JobType, string Priority)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddJob", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobName", JobName));       
        cmd.Parameters.Add(new SqlParameter("@jobTypeId", JobType));
        cmd.Parameters.Add(new SqlParameter("@priority", Priority));

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void DeleteJob(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_jobs WHERE i_job_id=" + JobId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void DeleteJobReport(Int32 JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_job_delete_job", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobid", JobId));        
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void MoveTaskGroupUp(Int32 JobTaskGroupId)
    { 
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_MoveTaskgroupUp", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobTaskgroupId", JobTaskGroupId));
        cmd.ExecuteNonQuery();
        cn.Close();        
    }

    public static void MoveTaskGroupDown(Int32 JobTaskGroupId)
    { 
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_MoveTaskgroupDown", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobTaskgroupId", JobTaskGroupId));
        cmd.ExecuteNonQuery();
        cn.Close();   
        
    }

    public static void AddTaskGroup(Int32 JobId, Int32 TaskGroupId)
    {
        // By default, the new taskgroup will be added to the bottom (with respect to order).
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddJobTaskgroup", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobId", JobId));
        cmd.Parameters.Add(new SqlParameter("@taskGroupId", TaskGroupId));

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void DeleteTaskGroup(Int32 JobTaskGroupId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_job_taskgroups WHERE i_job_taskgroup_id=" + JobTaskGroupId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }


    public void CreateJob()
    { 
        // 1. Create Job and get back the job_id
        // 2. Foreach TaskGroup in this job
        //   a. Create the taskgroup
        //   b. Foreach Task in Taskgroup
        //     - Create the task.
        //     - Token replace all param values, and add each parameter.
        // 3. DO NOT Schedule the job. Job will be scheduled by the user after confirming parameters are correct.
        // See /private/test/deployment/automation/bdservice/bdservice.cs ScheduleJob method for template.
        
        long NewJobId = Scheduler.CreateJob(this.jobType, this.jobName, this.build.BuildId, this.scheduler, this.env.EnvironmentId, this.priority, this.version);

        if (NewJobId == 0)
        {
            throw new ApplicationException("JobId=0. This job has already been scheduled.  Not re-scheduling. Change the Environment, Build, Version, or JobType to enable scheduling.");
        }
        
        foreach (TaskGroup tg in this.taskGroupList)
        {
            long NewTaskGroupId = Scheduler.AddTaskGroup(NewJobId, tg.TaskGroupName, tg.Rollup, tg.Condition);
            foreach (Task t in tg.TaskList)
            {
                long NewTaskId = Scheduler.AddTask(NewJobId, NewTaskGroupId, t.TaskName, t.Module, t.TaskType, t.Condition, String.Empty);
                foreach (Parameter p in t.ParameterList)
                {
                    TokenReplaceParam(p);
                    Scheduler.AddTaskParameters(NewTaskId, p.Name, p.Val, p.Condition);
                }
            }
        }
    }

    private void TokenReplaceParam(Parameter p)
    {
        p.Val = p.Val.Replace(ParamTokenBuildVersion, this.version);
        p.Val = p.Val.Replace(ParamTokenJobId, this.jobId.ToString());
        p.Val = p.Val.Replace(ParamTokenJobType, this.jobType.ToString());

        p.Val = p.Val.Replace(ParamTokenBuildName, this.build.BuildName);
        p.Val = p.Val.Replace(ParamTokenBuildPath, this.build.BuildPath);

        p.Val = p.Val.Replace(ParamTokenEnvironment, this.env.EnvironmentName);
        p.Val = p.Val.Replace(ParamTokenStagerName, this.env.StagerName);
        p.Val = p.Val.Replace(ParamTokenStagerBuildShare, this.env.BuildShare);
        p.Val = p.Val.Replace(ParamTokenStagerTitleShare, this.env.TitleShare);
        p.Val = p.Val.Replace(ParamTokenEnvUserName, this.env.UserName);
        p.Val = p.Val.Replace(ParamTokenRemotePassword, this.env.RemotePassword);

        // p.Val = p.Val.Replace(ParamTokenRemotePasswordEncrypted, this.); // need to investigate
        // p.Val = p.Val.Replace(ParamTokenLocalPassword, localPassword);  // need to investigate.
        // p.Val = p.Val.Replace(ParamTokenLocalPasswordEncrypted, pwdEncrypted);  // need to investigate.

        if (p.Val.Contains(ParamTokenRemotePassword))
        {
            string remotePassword = "";

            foreach (Credential c in this.env.CredentialList)
            {
                if (c.PasswordType == 2)
                {
                    remotePassword = c.Password;
                    break;
                }
            }
            p.Val = p.Val.Replace(ParamTokenRemotePassword, remotePassword);
        }


        if (p.Val.Contains(ParamTokenRemotePasswordEncrypted))
        {
            string pwdEncrypted = "false";
            foreach (Credential c in this.env.CredentialList)
            {
                if (c.PasswordType == 2)
                {
                    pwdEncrypted = c.Encrypted.ToString();
                    break;
                }
            }
            p.Val = p.Val.Replace(ParamTokenRemotePasswordEncrypted, pwdEncrypted);
        }

        if (p.Val.Contains(ParamTokenLocalPassword))
        {
            string localPassword = "false";
            foreach (Credential c in this.env.CredentialList)
            {
                if (c.PasswordType == 1)
                {
                    localPassword = c.Password;
                    break;
                }
            }
            p.Val = p.Val.Replace(ParamTokenLocalPassword, localPassword);
        }

        if (p.Val.Contains(ParamTokenLocalPasswordEncrypted))
        {
            string pwdEncrypted = "";
            foreach (Credential c in this.env.CredentialList)
            {
                if (c.PasswordType == 1)
                {
                    pwdEncrypted = c.Encrypted.ToString();
                    break;
                }
            }
            p.Val = p.Val.Replace(ParamTokenLocalPasswordEncrypted, pwdEncrypted);
        }



        p.Val = p.Val.Replace(ParamTokenEnvAllServersList, this.env.GetServerList);
        p.Val = p.Val.Replace(ParamTokenEnvAllSQL1, this.env.GetServerListByRole("AllSQL1"));
        p.Val = p.Val.Replace(ParamTokenEnvAllSQL2, this.env.GetServerListByRole("AllSQL2"));
        p.Val = p.Val.Replace(ParamTokenEnvCatrSQL, this.env.GetServerListByRole("CatrSQL"));
        p.Val = p.Val.Replace(ParamTokenEnvMstrSQL, this.env.GetServerListByRole("MstrSQL"));
        p.Val = p.Val.Replace(ParamTokenEnvPoolIIS, this.env.GetServerListByRole("PoolIIS"));
        p.Val = p.Val.Replace(ParamTokenEnvPoolINH, this.env.GetServerListByRole("PoolINH"));
        p.Val = p.Val.Replace(ParamTokenEnvSecuINH, this.env.GetServerListByRole("SecuINH"));
        p.Val = p.Val.Replace(ParamTokenEnvInfrTLS, this.env.GetServerListByRole("InfrTLS"));
        p.Val = p.Val.Replace(ParamTokenEnvClient, this.env.GetServerListByRole("Client"));

        p.Val = p.Val.Replace(ParamTokenEnvHostList, this.env.HostList);
        p.Val = p.Val.Replace(ParamTokenEnvServerPrefix, this.env.MachinePrefix);

        p.Val = p.Val.Replace(ParamTokenEnvCatalogIp, this.env.IPList["Catalog"]);
        p.Val = p.Val.Replace(ParamTokenEnvClientPoolIpBegin, this.env.IPList["ClientPoolBegin"]);
        p.Val = p.Val.Replace(ParamTokenEnvClientPoolIpEnd, this.env.IPList["ClientPoolEnd"]);
        p.Val = p.Val.Replace(ParamTokenEnvSGAdminIp, this.env.IPList["SGAdmin"]);
        p.Val = p.Val.Replace(ParamTokenEnvSGInternetIp, this.env.IPList["SGInternet"]);
        p.Val = p.Val.Replace(ParamTokenEnvXDSInternetIp, this.env.IPList["XDSInternet"]);
        p.Val = p.Val.Replace(ParamTokenEnvClientPoolNetmask, this.env.IPList["ClientPoolNetmask"]);
        p.Val = p.Val.Replace(ParamTokenEnvClientPoolGateway, this.env.IPList["ClientPoolGateway"]);
        p.Val = p.Val.Replace(ParamTokenEnvInternetNetmask, this.env.IPList["InternetNetmask"]);
        p.Val = p.Val.Replace(ParamTokenEnvInternetGateway, this.env.IPList["InternetGateway"]);
    }

    private static string GetNewBuildVersion(string BuildSharePath)
    {
        // Find the version file in the build drop directory
        string[] versionFiles = Directory.GetFiles(BuildSharePath);
        if (versionFiles.Length == 0)
        {
            //EventLog.WriteEntry("DeploymentAutomationWebApp", "Unable to locate any version files in " + BuildPath);
            return "";
        }
        return Path.GetFileName(versionFiles[0]);
    }

    private static BuildInfo GetBuildInfoFromJobId(Int32 JobId)
    {
        BuildInfo bi = new BuildInfo();

        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT vc_build_name, vc_build_source_path " +
            "FROM t_builds b JOIN t_jobs j ON b.i_build_id=j.i_build_id " +
            "AND j.i_job_id=" + JobId.ToString(), cn);

        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();
        bi.BuildName = (string)dr["vc_build_name"];
        bi.BuildSourcePath = (string)dr["vc_build_source_path"];

        cn.Close();

        return bi;
    }
}


public class Scheduler
{
    // no instance
    private Scheduler() { }

    public static long CreateJob(JobType jobType, string jobName, Int32 buildId, string creator, long envId, JobPriority priority, string version)
    {
        long jobId = 0;

        using (SqlConnection conn = new SqlConnection(ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString))
        {
            conn.Open();
            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_job_create_job";
                cmd.Parameters.AddWithValue("@jobName", jobName);
                cmd.Parameters.AddWithValue("@jobType", (byte)jobType);
                cmd.Parameters.AddWithValue("@buildId", buildId);
                cmd.Parameters.AddWithValue("@userName", creator);
                cmd.Parameters.AddWithValue("@priority", (byte)priority);
                cmd.Parameters.AddWithValue("@envId", envId);
                if (!String.IsNullOrEmpty(version))
                    cmd.Parameters.AddWithValue("@version", version);
                cmd.Parameters.Add("@jobid", SqlDbType.BigInt);
                cmd.Parameters["@jobid"].Direction = ParameterDirection.Output;
                
                try
                {
                    cmd.ExecuteNonQuery();
                    jobId = (long)cmd.Parameters["@jobid"].Value;
                }
                catch (SqlException ex)
                {
                    throw new ApplicationException("p_job_create_job failed", ex);
                }
            }
        }

        return jobId;
    }



    public static long AddTaskGroup(long JobId, string taskGroupName, bool rollup, Int32 condition)
    {
        long groupId = 0;

        using (SqlConnection conn = new SqlConnection(ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString))
        {
            try
            {
                conn.Open();
            }
            catch (SqlException ex)
            {
                throw new ApplicationException("Failed to open connection to DB.", ex);
            }

            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_job_add_task_group";
                cmd.Parameters.AddWithValue("@jobId", JobId);
                cmd.Parameters.AddWithValue("@groupName", taskGroupName);
                cmd.Parameters.AddWithValue("@rollup", rollup);
                cmd.Parameters.AddWithValue("@condition", condition);
                cmd.Parameters.Add("@groupId", SqlDbType.BigInt).Direction = ParameterDirection.Output;

                try
                {
                    cmd.ExecuteNonQuery();
                    groupId = (long)cmd.Parameters["@groupId"].Value;
                }
                catch (SqlException ex)
                {
                    throw new ApplicationException("p_job_add_task_group failed.", ex);
                }
            }
        }

        return groupId;
    }

    public static long AddTask(long JobId, long groupId, string taskName, string module, Int32 taskType, Int32 condition, string localLogTarget)
    {
        long taskId = 0;

        using (SqlConnection conn = new SqlConnection(ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString))
        {
            try
            {
                conn.Open();
            }
            catch (SqlException ex)
            {
                throw new ApplicationException("Failed to open connection to DB.", ex);
            }

            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_job_add_task";
                cmd.Parameters.AddWithValue("@jobId", JobId);
                cmd.Parameters.AddWithValue("@groupId", groupId);
                cmd.Parameters.AddWithValue("@taskName", taskName);
                cmd.Parameters.AddWithValue("@module", module);
                cmd.Parameters.AddWithValue("@taskType", taskType);
                cmd.Parameters.AddWithValue("@condition", condition);
                cmd.Parameters.AddWithValue("@localLogTarget", localLogTarget);
                cmd.Parameters.Add("@taskid", SqlDbType.BigInt).Direction = ParameterDirection.Output;

                try
                {
                    cmd.ExecuteNonQuery();
                    taskId = (long)cmd.Parameters["@taskid"].Value;
                }
                catch (SqlException ex)
                {
                    throw new ApplicationException("p_job_add_task failed.", ex);
                }
            }
        }

        return taskId;
    }

    public static void AddTaskParameters(long taskId, string paramName, string paramValue, RunCondition condition)
    {
        using (SqlConnection conn = new SqlConnection(ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString))
        {
            try
            {
                conn.Open();
            }
            catch (SqlException ex)
            {
                throw new ApplicationException("Failed to open db connection.", ex);
            }

            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_task_add_parameter";
                cmd.Parameters.AddWithValue("@taskId", taskId);
                cmd.Parameters.AddWithValue("@parameterName", paramName);
                cmd.Parameters.AddWithValue("@parameterValue", paramValue);
                cmd.Parameters.AddWithValue("@condition", (byte)condition);

                try
                {
                    cmd.ExecuteNonQuery();
                }
                catch (SqlException ex)
                {
                    throw new ApplicationException("p_task_add_parameter failed.", ex);
                }
            }
        }
    }

    public static void ScheduleJob(Int32 JobId)
    {
        using (SqlConnection conn = new SqlConnection(ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString))
        {
            try
            {
                conn.Open();
            }
            catch (SqlException ex)
            {
                throw new ApplicationException("Failed to open db connection.", ex);
            }

            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_job_schedule_job";
                cmd.Parameters.AddWithValue("@jobId", JobId);
                try
                {
                    cmd.ExecuteNonQuery();
                }
                catch (SqlException ex)
                {
                    throw new ApplicationException("p_job_schedule_job failed.", ex);
                }
            }
        }
    }
}



public enum JobType : byte
{
    Other = 0,
    Deployment,
    LKGTesting,
    TestRun
}

public enum JobPriority : byte
{
    Low = 0,
    Normal,
    High
}

public enum RunCondition : byte
{
    Inherit = 0,
    Always,
    IfPassing,
    IfFailing
}

public class BuildInfo
{
    public string BuildName;
    public string BuildSourcePath;
}

public class Environment
{
    private long envId;
    private string envName;        
    private string stagerName;
    private string buildshare;
    private string titleshare;
    private string userName;
    private string hostList;
    private string machinePrefix;
    private List<Credential> credentialList;
    private bool locked;
    private bool isVirtual;
    private List<Server> serverList;
    private Dictionary<string, string> ipList;


    public Environment(Int32 EnvironmentId) 
    {
        this.ipList = new Dictionary<string, string>();
        this.serverList = new List<Server>();
        this.credentialList = new List<Credential>();

        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM t_environments WHERE i_env_id=" + EnvironmentId, cn);
        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        this.envId = EnvironmentId;
        this.envName = (string) dr["vc_environment_name"];
        this.stagerName = (string)dr["vc_stager_name"];
        this.buildshare = (string)dr["vc_build_share"];
        this.titleshare = (string)dr["vc_titles_share"];
        this.userName = (string)dr["vc_user_name"];
        this.hostList = (string)dr["vc_hostList"];
        this.machinePrefix = (string)dr["vc_machine_prefix"];
        this.isVirtual = (bool)dr["b_is_virtual"];
        this.locked = (bool)dr["b_locked"];

        string catalogIP = (string)dr["vc_catalog_ip"];
        this.ipList.Add("Catalog", catalogIP);
        
        cn.Close();

        FillCredentialList();
        FillServerList();
        FillIPs();
    }

    private void FillServerList()
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM vw_env_servers WHERE i_env_id=" + this.envId, cn);
        SqlDataReader dr = cmd.ExecuteReader();
        while (dr.Read())
        {
            string serverName = (string)dr["vc_server_name"];
            string serverRole = (string)dr["vc_server_role"];
            Server s = new Server(serverName, serverRole);
            this.serverList.Add(s);
        }
    }

    private void FillIPs()
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        // should only be 1 row per environment.
        SqlCommand cmd = new SqlCommand("SELECT * FROM t_env_ips WHERE i_env_id=" + this.envId, cn);
        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        this.ipList.Add("ClientPoolBegin", (string)dr["vc_clientpool_ip_begin"]);
        this.ipList.Add("ClientPoolEnd", (string)dr["vc_clientpool_ip_end"]);
        this.ipList.Add("SGAdmin", (string)dr["vc_sg_admin_ip"]);
        this.ipList.Add("SGInternet", (string)dr["vc_sg_internet_ip"]);
        this.ipList.Add("XDSInternet", (string)dr["vc_xds_internet_ip"]);
        this.ipList.Add("ClientPoolNetmask", (string)dr["vc_clientpool_netmask"]);
        this.ipList.Add("ClientPoolGateway", (string)dr["vc_clientpool_gateway"]);
        this.ipList.Add("InternetNetmask", (string)dr["vc_internet_netmask"]);
        this.ipList.Add("InternetGateway", (string)dr["vc_internet_gateway"]);

        cn.Close();
    }

    private void FillCredentialList()
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM t_env_passwords WHERE i_env_id=" + this.envId, cn);
        SqlDataReader dr = cmd.ExecuteReader();
        while (dr.Read())
        {            
            string server = (string)dr["vc_context_server"];
            Byte passwordType = (Byte)dr["ti_type"];
            string password = (string)dr["vc_password"];
            bool encrypted = (bool)dr["b_encrypted"];
            Credential c = new Credential(server, passwordType, password, encrypted);
            this.credentialList.Add(c);
        }
        cn.Close();
    }

    public static String GetEnvironmentNameFromJobId(long JobId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT vc_environment_name FROM vw_AllJobs WHERE i_job_id=" + JobId.ToString(), cn);
        string envName = (String)cmd.ExecuteScalar();
        cn.Close();
        
        return envName;
    }

    public static void FlipEnvLock(Int32 envId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_env_flip_lock", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@envId", envId));
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public List<Credential> CredentialList
    {
        get { return this.credentialList; }
    }

    public Dictionary<string, string> IPList
    {
        get { return this.ipList; }
    }

    public string GetServerList
    {
        get
        {
            StringBuilder sb = new StringBuilder();

            foreach (Server s in this.serverList)
            {
                sb.Append(s.ServerName);
                sb.Append(",");
            }

            if (sb.Length == 0) return String.Empty;

            sb.Remove(sb.Length - 1, 1);
            return sb.ToString();
        }
    }

    public string GetServerListByRole(string Role)
    {
        StringBuilder sb = new StringBuilder();
        foreach (Server s in this.serverList)
        {
            if (s.Role.Equals(Role))
            {
                sb.Append(s.ServerName);
                sb.Append(",");
            }
        }

        if (sb.Length == 0) return String.Empty;

        sb.Remove(sb.Length - 1, 1);
        return sb.ToString();
    }


    public string RemotePassword
    {
        get 
        {
            foreach (Credential c in this.credentialList)
            {
                if (c.PasswordType == 2)
                    return c.Password;
            }
            throw new ApplicationException("No remote password defined for this environment: " + this.EnvironmentName);
        }
    }

    public long EnvironmentId
    {
        get { return this.envId; }
    }

    public string EnvironmentName
    {
        get { return this.envName; }
    }

    public string BuildShare
    {
        get { return this.buildshare; }
    }

    public string TitleShare
    {
        get { return this.titleshare; }
    }

    public string UserName
    {
        get { return this.userName; }
    }

    public string HostList
    {
        get { return this.hostList; }
    }

    public string MachinePrefix
    {
        get { return this.machinePrefix; }
    }

    public bool IsVirtual
    {
        get { return this.isVirtual; }
    }

    public bool Locked
    {
        get { return this.locked; }
    }

    public string StagerName
    {
        get { return this.stagerName; }
    }

    public static void AddSubEnvironment(long ParentEnvId, long SubEnvId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddSubEnv", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@ParentId", ParentEnvId));
        cmd.Parameters.Add(new SqlParameter("@SubEnvId", SubEnvId));

        cmd.ExecuteNonQuery();

        cn.Close();
    }

    public static void SetSubEnvironment(long ParentEnvId, long SubEnvId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_SetSubEnv", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@ParentId", ParentEnvId));
        cmd.Parameters.Add(new SqlParameter("@SubEnvId", SubEnvId));

        cmd.ExecuteNonQuery();

        cn.Close();
    }

    public static void DeleteSubEnvironment(long ParentEnvId, long SubEnvId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_DeleteSubEnv", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@ParentId", ParentEnvId));
        cmd.Parameters.Add(new SqlParameter("@SubEnvId", SubEnvId));

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void AddServer(Int32 EnvId, string ServerName, bool SnapshotIgnore, Int32 ServerRole)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_add_env_server", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@envId", EnvId));
        cmd.Parameters.Add(new SqlParameter("@roleId", ServerRole));
        cmd.Parameters.Add(new SqlParameter("@servername", ServerName));
        cmd.Parameters.Add(new SqlParameter("@snapshotIgnore", SnapshotIgnore));

        cmd.ExecuteNonQuery();
        cn.Close();

    }

    public static void DeleteServer(Int32 ServerId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_delete_env_server", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@serverId", ServerId));
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void AddEnvironment(string EnvName, bool Locked, string StagerName, string BuildShare, string TitleShare, string UserName, string Alias, bool IsVirtual, string HostList, string MachinePrefix)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_add_environment", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        if (Alias.StartsWith("REDMOND\\"))
            Alias = Alias.Substring(8);

        cmd.Parameters.Add(new SqlParameter("@envName", EnvName));
        cmd.Parameters.Add(new SqlParameter("@stagerName", StagerName));
        cmd.Parameters.Add(new SqlParameter("@buildShare", BuildShare));
        cmd.Parameters.Add(new SqlParameter("@titlesShare", TitleShare));
        cmd.Parameters.Add(new SqlParameter("@userName", UserName));
        cmd.Parameters.Add(new SqlParameter("@locked", Locked));
        cmd.Parameters.Add(new SqlParameter("@alias", Alias));
        cmd.Parameters.Add(new SqlParameter("@isVirtual", IsVirtual));
        cmd.Parameters.Add(new SqlParameter("@hostList", HostList));
        cmd.Parameters.Add(new SqlParameter("@machinePrefix", MachinePrefix));

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void AddCredentials(Int32 EnvironmentId, string Server, bool Encrypted, Byte CredType, string Password)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();
        /*
         create proc wp_AddEnvCreds
            @envId int,
            @userName nvarchar(64),
            @server nvarchar(64),
            @encrypted bit,
            @context nvarchar(16),
            @password nvarchar(512)
         */
        SqlCommand cmd = new SqlCommand("p_env_add_password", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@envId", EnvironmentId));
        cmd.Parameters.Add(new SqlParameter("@password", Password));
        cmd.Parameters.Add(new SqlParameter("@contextServer", Server));
        cmd.Parameters.Add(new SqlParameter("@type", CredType));
        cmd.Parameters.Add(new SqlParameter("@encrypted", Encrypted));

        SqlParameter pOut = new SqlParameter("@envPasswordId", SqlDbType.BigInt);
        pOut.Direction = ParameterDirection.Output;
        cmd.Parameters.Add(pOut);

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void DeleteEnvironment(Int32 EnvironmentId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_auth WHERE i_env_id=" + EnvironmentId.ToString(), cn);
        cmd.ExecuteNonQuery();

        cmd = new SqlCommand("DELETE FROM t_env_passwords WHERE i_env_id=" + EnvironmentId.ToString(), cn);
        cmd.ExecuteNonQuery();

        cmd = new SqlCommand("DELETE FROM t_environments WHERE i_env_id=" + EnvironmentId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }
}


public class Server
{
    private string serverName;
    private string role;

    public Server(string ServerName, string Role)
    {
        this.serverName = ServerName;
        this.role = Role;
    }

    public string ServerName
    {
        get { return this.serverName; }
    }

    public string Role
    {
        get { return this.role; }
    }
}

public class Credential
{    
    private string server;
    private Byte type; // local=1   remote=2
    private string password;
    private bool encrypted;

    public Credential(Int32 CredId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM t_credentials WHERE i_credential_id=" + CredId.ToString(), cn);        
        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        this.server = (string)dr["vc_context_server"];
        this.type = (Byte)dr["ti_type"];
        this.password = (string)dr["vc_password"];
        this.encrypted = (bool)dr["b_encrypted"];        
        cn.Close();
    }

    public Credential(string Server, Byte PasswordType, string Password, bool Encrypted)
    {
        this.server = Server;
        this.type = PasswordType;
        this.password = Password;
        this.encrypted = Encrypted;    
    }


    public string Server
    {
        get { return this.server; }
    }

    public Int32 PasswordType
    {
        get { return this.type; }
    }

    public string Password
    {
        get { return this.password; }
    }

    public bool Encrypted
    {
        get { return this.encrypted; }
    }


    public static void DeleteCredencial(Int32 EnvPasswordId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_env_delete_password", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@envPasswordId", EnvPasswordId));
        cmd.ExecuteNonQuery();
        cn.Close();
    }

}


public class Task
{
    private string taskName;
    private string module;
    private Int32 taskType;
    private Int32 condition; // 1=Always, 2=IfPassing, 3=IfFailing
    private List<Parameter> paramList;

    public Task(Int32 TaskGroupId, string TaskName, string Module, Int32 TaskType, Int32 Order)
    {
        //this.taskGroupId = TaskGroupId;
        this.taskName = TaskName;
        this.module = Module;
        this.taskType = TaskType;
        //this.order = Order;
        this.paramList = new List<Parameter>();
    }

    public string TaskName
    {
        get { return this.taskName; }
    }

    public string Module
    {
        get { return this.module; }
    }

    public Int32 TaskType
    {
        get { return this.taskType; }
    }

    public Int32 Condition
    {
        get { return this.condition; }
    }

    public List<Parameter> ParameterList
    {
        get { return this.paramList; }
    }

    public Task(Int32 TaskId)
    {
        this.paramList = new List<Parameter>();

        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM t_tasks WHERE i_task_id=" + TaskId.ToString(), cn);

        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        //this.taskGroupId = (Int32)dr["i_taskgroup_id"];
        this.taskName = (string)dr["vc_task_name"];
        this.module = (string)dr["vc_module"];
        this.taskType = (Int32)dr["i_task_type_id"];
        //this.order = (Int32)dr["i_order"];

        dr.Close();


        cmd = new SqlCommand("SELECT * FROM t_parameters WHERE i_task_id=" + TaskId.ToString(), cn);
        dr = cmd.ExecuteReader();
        while (dr.Read())
        {
            string name = (string)dr["vc_param"];
            string val = (string)dr["vc_value"];
            RunCondition condition = (RunCondition)Enum.Parse(typeof(RunCondition), (string) dr["vc_condition"]);
            Parameter p = new Parameter(name, val, condition);
            this.paramList.Add(p);
        }
        dr.Close();
        cn.Close();
    }


    public void AddParameter(Parameter newParam)
    {
        this.paramList.Add(newParam);
    }



    public static void AddTask(string TaskName, string Module, Int32 TaskType)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddTask", cn);
        cmd.CommandType = CommandType.StoredProcedure;
        
        cmd.Parameters.Add(new SqlParameter("@taskName", TaskName));
        cmd.Parameters.Add(new SqlParameter("@module", Module));
        cmd.Parameters.Add(new SqlParameter("@taskType", TaskType));        

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static DataTable GetTasks(string sortExpression)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        DataSet ds = new DataSet();

        string filter = string.Empty;

        if (!String.IsNullOrEmpty(sortExpression))
        {
            filter = " ORDER BY " + sortExpression;
        }

        SqlDataAdapter da = new SqlDataAdapter("SELECT * FROM vw_tasks" + filter, cn);
        da.Fill(ds);
        return ds.Tables[0];        
    }

    public static void DeleteTask(Int32 TaskId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_tasks WHERE i_task_id=" + TaskId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();  
    }

}


public class Build
{
    private Int32 buildId;
    private string name;
    private string path;

    public Build(Int32 BuildId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM t_builds WHERE i_build_id=" + BuildId, cn);
        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        this.buildId = BuildId;
        this.name = (string)dr["vc_build_name"];
        this.path = (string)dr["vc_build_source_path"];

        cn.Close();
    }

    public Int32 BuildId
    {
        get { return this.buildId; }
    }

    public string BuildName
    {
        get { return this.name; }
    }

    public string BuildPath
    {
        get { return this.path; }
    }


    public static Int32 AddBuild(string BuildName, string BuildPath)
    {
        // both builds and environments are in the DeploymentDB
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_build_add_build", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@buildName", BuildName));
        cmd.Parameters.Add(new SqlParameter("@sourcePath", BuildPath));

        SqlParameter pBuildId = new SqlParameter("@buildId", SqlDbType.Int);
        pBuildId.Direction = ParameterDirection.Output;
        cmd.Parameters.Add(pBuildId);
        cmd.ExecuteNonQuery();

        Int32 BuildId = (Int32)cmd.Parameters["@buildId"].Value;
        cn.Close();
        return BuildId;
    }

    public static void DeleteBuild(Int32 BuildId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_build_delete_build", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@buildId", BuildId));
        cmd.ExecuteNonQuery();
        cn.Close(); 
    }

}

[DataObject(true)]

public class Parameter
{
    private string name;
    private string val;
    private RunCondition condition;
    

    public Parameter(string Name, string Val, RunCondition Condition)
    {
        this.name = Name;
        this.val = Val;
        this.condition = Condition;
    }

    public string Name
    {
        get { return this.name; }
        set { this.name = value; }
    }

    public string Val
    {
        get { return this.val; }
        set { this.val = value; }
    }

    public RunCondition Condition
    {
        get { return this.condition; }
    }

    public static void AddParameter(Int32 TaskId, string ParamName, string ParamValue, string Condition)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddParameter", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@taskId", TaskId));
        cmd.Parameters.Add(new SqlParameter("@paramName", ParamName));
        cmd.Parameters.Add(new SqlParameter("@paramValue", ParamValue));
        cmd.Parameters.Add(new SqlParameter("@condition", Condition));
        try
        {
            cmd.ExecuteNonQuery();
        }
        catch
        {
            throw;
        }
        cn.Close();
    }

    public static DataSet GetParameters(Int64 TaskId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlDataAdapter da = new SqlDataAdapter("SELECT * FROM t_task_parameters WHERE i_task_id=" + TaskId.ToString(), cn);
        DataSet ds = new DataSet();
        da.Fill(ds);
        cn.Close();

        return ds;
    }

    [DataObjectMethod(DataObjectMethodType.Delete)]
    public static void DeleteParameter(Int32 ParamId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_parameters WHERE i_param_id=" + ParamId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }


    [DataObjectMethod(DataObjectMethodType.Update)]
    public static void UpdateParameter(string vc_param_name, string vc_param_value, byte ti_condition, Int64 i_task_parameter_id)
    {
        //create proc wp_update_parameter
        //    @paramId bigint,
        //    @paramName nvarchar(50),
        //    @paramValue text,
        //    @condition tinyint
        //AS
        //UPDATE t_task_parameters
        //SET vc_param_name=@paramName, vc_param_value=@paramValue, ti_condition=@condition
        //WHERE i_task_parameter_id=@paramId


        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_update_parameter", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@paramId", i_task_parameter_id));
        cmd.Parameters.Add(new SqlParameter("@paramName", vc_param_name));
        cmd.Parameters.Add(new SqlParameter("@paramValue", vc_param_value));
        cmd.Parameters.Add(new SqlParameter("@condition", ti_condition));

        cmd.ExecuteNonQuery();
        cn.Close();
    }

}

public class JobRunInfo
{
    Int64 jobId;
    DateTime jobStartDate;
    String version;
    String result;

    public JobRunInfo(Int64 JobId, DateTime JobStartDate, String Version, String Result)
    {
        this.jobId = JobId;
        this.jobStartDate = JobStartDate;
        this.version = Version;
        this.result = Result;
    }

    public Int64 JobId
    {
        get { return this.jobId; }
    }

    public DateTime JobStartDate
    {
        get { return this.jobStartDate; }
    }

    public String Version
    {
        get { return this.version; }
    }

    public String VersionReduced
    {          
        get 
        {            
            String reducedVersion = String.Empty;
            String[] parts = Version.Split('.');
            
            if (parts.Length != 4) return Version;

            Int32 MajorVer = Int32.Parse(parts[0]);
            Int32 MinorVer = Int32.Parse(parts[1]);
            Int32 Build = Int32.Parse(parts[2]);
            Int32 Dot = Int32.Parse(parts[3]);

            reducedVersion = MajorVer.ToString("0") + "." + MinorVer.ToString("0") + "." + Build.ToString("0") + "." + Dot.ToString("0");
            return reducedVersion;
        }
    }

    public String Result
    {
        get { return this.result; }
    }

    public static Dictionary<string, List<JobRunInfo>> GetJobRunInfosFromJobId(Int32 JobId)
    {
        // select i_job_id, vc_version, vc_job_result, dt_job_start_date from vw_AllJobs where i_env_id=@envId
        Dictionary<string, List<JobRunInfo>> returnTable = new Dictionary<string, List<JobRunInfo>>();
        
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_GetCalendarData", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@JobId", JobId));

        SqlDataReader dr = cmd.ExecuteReader();
        while (dr.Read())
        {
            // don't display in calendar if we are missing some needed data.
            if ((dr["dt_job_start_date"] is DBNull) || (dr["vc_version"] is DBNull) || (dr["vc_job_result"] is DBNull))
                continue;

            Int64 NextJobId = (Int64)dr["i_job_id"];
            String Version = (String)dr["vc_version"];
            DateTime StartDate = (DateTime)dr["dt_job_start_date"];
            String Result = (String)dr["vc_job_result"];
            JobRunInfo jri = new JobRunInfo(NextJobId, StartDate, Version, Result);
            if (!returnTable.ContainsKey(StartDate.ToString("d")))
            {
                returnTable.Add(StartDate.ToString("d"), new List<JobRunInfo>());                
            }
            returnTable[StartDate.ToString("d")].Add(jri);            
        }

        cn.Close();
        return returnTable;
    }

}

public class Auth
{ 
    public static void AddAuth(Int32 EnvId, String Alias)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddAuth", cn);
        cmd.CommandType = CommandType.StoredProcedure;
        
        cmd.Parameters.Add(new SqlParameter("@EnvId", EnvId));
        cmd.Parameters.Add(new SqlParameter("@Alias", Alias));

        try
        {
            cmd.ExecuteNonQuery();
        }
        finally
        {
            cn.Close();
        }
    }

    public static Dictionary<String, List<String>> GetAuthDictionaryByEnvName()
    {
        Dictionary<String, List<String>> authDictionary = new Dictionary<string, List<string>>();
        
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT vc_environment_name, vc_alias FROM t_auth a, t_environments e WHERE a.i_env_id=e.i_env_id", cn);
        SqlDataReader dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            string env = (string)dr["vc_environment_name"];
            string alias = (string)dr["vc_alias"];
            if (!authDictionary.ContainsKey(env))
                authDictionary.Add(env, new List<string>());

            authDictionary[env].Add("REDMOND\\" + alias);
        }
        cn.Close();

        return authDictionary;
    }


    public static Dictionary<Int64, List<String>> GetAuthDictionaryByEnvId()
    {
        Dictionary<Int64, List<String>> authDictionary = new Dictionary<Int64, List<string>>();

        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT i_env_id, vc_alias FROM t_auth", cn);
        SqlDataReader dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            Int64 envId = (Int64)dr["i_env_id"];
            string alias = (string)dr["vc_alias"];
            if (!authDictionary.ContainsKey(envId))
                authDictionary.Add(envId, new List<string>());

            authDictionary[envId].Add("REDMOND\\" + alias);
        }
        cn.Close();

        return authDictionary;
    }
    
    public static void DeleteAuth(Int32 AuthId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_DeleteAuth", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@AuthId", AuthId));
        try
        {
            cmd.ExecuteNonQuery();
        }
        finally
        {
            cn.Close();    
        }       
    }

    public static bool IsUserAuthorized(String Alias, Int32 EnvId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDB"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        if (Alias.StartsWith("REDMOND\\"))
        {
            Alias = Alias.Substring(8);
        }

        SqlCommand cmd = new SqlCommand("wp_AuthCheck", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@Alias", Alias));
        cmd.Parameters.Add(new SqlParameter("@EnvId", EnvId));

        SqlParameter p1 = new SqlParameter("RETURN_VALUE", SqlDbType.Int);
        p1.Direction = ParameterDirection.ReturnValue;
        cmd.Parameters.Add(p1);       
        
        cmd.ExecuteNonQuery();        
        cn.Close();

        Int32 retVal = (Int32)p1.Value;
        if (retVal == 1)
            return true;
        else
            return false;
    
    }
}


public class TaskGroup
{
    private string taskGroupName;
    private bool rollup;
    private Int32 condition;
    private List<Task> taskList;

    public TaskGroup(Int32 TaskGroupId)
    {
        this.taskList = new List<Task>();

        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("SELECT * FROM t_taskgroups WHERE i_taskgroup_id=" + TaskGroupId.ToString(), cn);
        SqlDataReader dr = cmd.ExecuteReader();
        dr.Read();

        this.taskGroupName = (string)dr["vc_taskgroup_name"];
        this.rollup = (bool)dr["b_rollup"];
        this.condition = (Int32) dr["i_condition_id"];

        dr.Close();

        // now add the tasks.
        cmd = new SqlCommand("SELECT i_task_id FROM t_taskgroup_tasks WHERE i_taskgroup_id=" + TaskGroupId.ToString() + " ORDER BY i_order", cn);
        dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            Int32 taskId = (Int32)dr["i_task_id"];
            Task t = new Task(taskId);
            this.taskList.Add(t);
        }
        dr.Close();
        cn.Close();
    }

    public string TaskGroupName
    {
        get {return this.taskGroupName;}
    }

    public bool Rollup
    {
        get {return this.rollup;}
    }

    public Int32 Condition
    {
        get {return this.condition;}
    }

    public List<Task> TaskList
    {
        get { return this.taskList; }
    }


    public static void AddTaskGroup(string TaskGroupName, Int32 ConditionId, bool Rollup)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_AddTaskGroup", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@taskGroupName", TaskGroupName));
        cmd.Parameters.Add(new SqlParameter("@condition", ConditionId));
        cmd.Parameters.Add(new SqlParameter("@rollup", Rollup));

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void DeleteTaskGroup(Int32 TaskGroupId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_taskGroups WHERE i_taskGroup_id=" + TaskGroupId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void MoveTaskUp(Int32 TaskgroupTaskId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_MoveTaskUp", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@taskGroupTaskId", TaskgroupTaskId));
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void MoveTaskDown(Int32 TaskgroupTaskId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_MoveTaskDown", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@taskGroupTaskId", TaskgroupTaskId));
        cmd.ExecuteNonQuery();
        cn.Close();  
    }

    public static void DeleteTask(Int32 TaskgroupTaskId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_taskgroup_tasks WHERE i_taskgroup_task_id=" + TaskgroupTaskId.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void AddTask(Int32 TaskGroupId, Int32 TaskId)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();
        
        SqlCommand cmd = new SqlCommand("wp_AddTaskgroupTask", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@taskGroupId", TaskGroupId));        
        cmd.Parameters.Add(new SqlParameter("@taskId", TaskId));
        
        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void DeleteTaskGroupTask(Int32 TaskGroupTaskKey)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DepAutoWebDb"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("DELETE FROM t_taskgroup_tasks WHERE i_taskGroup_task_key=" + TaskGroupTaskKey.ToString(), cn);
        cmd.ExecuteNonQuery();
        cn.Close();
    }

}


public class Issue
{
    public static DataSet GetIssues(Int64 JobId)
    {

        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        String sql = "SELECT * FROM t_issues WHERE i_job_id=" + JobId.ToString();

        SqlDataAdapter da = new SqlDataAdapter(sql, cn);
        DataSet ds = new DataSet();
        da.Fill(ds);
        cn.Close();

        return ds;
    }
    

    public static void AddIssue(long JobId, Int32 BugNumber, String PSDatabase, String Notes)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("p_issue_new_issue", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@jobId", JobId));
        cmd.Parameters.Add(new SqlParameter("@psDatabase", PSDatabase));

        if (BugNumber > 0)
        {
            cmd.Parameters.Add(new SqlParameter("@bugId", BugNumber));
        }
        else
        {
            cmd.Parameters.Add(new SqlParameter("@bugId", null));
        }

        cmd.Parameters.Add(new SqlParameter("@notes", Notes));

        SqlParameter pOut = new SqlParameter("@issueId",SqlDbType.BigInt);
        pOut.Direction = ParameterDirection.Output;
        cmd.Parameters.Add(pOut);

        cmd.ExecuteNonQuery();
        cn.Close();
    }

    public static void UpdateIssue(string i_bug_number, string vc_notes, DateTime dt_last_update, Int64 i_issue_id)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        Int32 BugNumber = 0;
        Int32.TryParse(i_bug_number, out BugNumber);

        if (String.IsNullOrEmpty(vc_notes))
            vc_notes = String.Empty;

        // NOTE: last update time will be set inside the stored proc.
        SqlCommand cmd = new SqlCommand("wp_UpdateIssue", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@IssueId", i_issue_id));
        cmd.Parameters.Add(new SqlParameter("@BugNumber", BugNumber));
        cmd.Parameters.Add(new SqlParameter("@Notes", vc_notes));

        cmd.ExecuteNonQuery();
        cn.Close();       
    }

    public static void DeleteIssue(long i_issue_id)
    {
        String cnString = ConfigurationManager.ConnectionStrings["DeploymentDB_V2"].ConnectionString;
        SqlConnection cn = new SqlConnection(cnString);
        cn.Open();

        SqlCommand cmd = new SqlCommand("wp_DeleteIssue", cn);
        cmd.CommandType = CommandType.StoredProcedure;

        cmd.Parameters.Add(new SqlParameter("@issueId", i_issue_id));

        cmd.ExecuteNonQuery();
        cn.Close();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\DeployBvtNet\TestResults.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace BvtNetAutomation
{
    public enum TestRunResult
    {
        NotRun, Passed, Failed
    }
    /// <summary>
    /// Test the result pass,fail or not run
    /// </summary>
    public class TestResults
    {
        private List<Uri> _negativeUris;
        private List<string> _passingUrls;
        private List<string> _failingUrls;
        private TestRunResult _installResult;
        private TestRunResult _installEmsResult;
        private TestRunResult _uninstallEmsResult;
        private TestRunResult _healthCheckResult;
        private TestRunResult _liveBvtsResult;


        public string[] PassingHealthChecks
        {
            get
            {
                return _passingUrls.ToArray();
            }
        }
        public string[] FailingHealthChecks
        {
            get
            {
                return _failingUrls.ToArray();
            }
        }

        // real results
        public TestRunResult InstallEms
        {
            get { return _installEmsResult; }
            set { _installEmsResult = value; }
        }

        public TestRunResult Install
        {
            set { _installResult = value; }
            get { return _installResult; }
        }

        public TestRunResult UninstallEms
        {
            set { _uninstallEmsResult = value; }
            get { return _uninstallEmsResult; }
        }
        public TestRunResult HealthChecks
        {
            get
            {
                if (DeploymentCycle == TestRunResult.Failed)
                    return TestRunResult.NotRun;
                else
                    return _healthCheckResult;
            }
            set
            {
                _healthCheckResult = value;
            }
        }
        public TestRunResult LiveBvts
        {
            set { _liveBvtsResult = value; }
            get { return _liveBvtsResult; }
        }

        // synthetic results
        public TestRunResult DeploymentCycle
        {
            get
            {
                if (UninstallEms == TestRunResult.Passed && Install == TestRunResult.Passed && InstallEms == TestRunResult.Passed)
                    return TestRunResult.Passed;
                else if (UninstallEms == TestRunResult.NotRun && Install == TestRunResult.NotRun && InstallEms == TestRunResult.NotRun)
                    return TestRunResult.NotRun;
                else
                    return TestRunResult.Failed;
            }
        }
        public TestRunResult OverallResult
        {
            get
            {
                if (AllResultsAreEqualTo(TestRunResult.Passed))
                    return TestRunResult.Passed;
                else if (AllResultsAreEqualTo(TestRunResult.NotRun))
                    return TestRunResult.NotRun;
                else
                    return TestRunResult.Failed;
            }
        }

        public TestResults()
        {
            Install = TestRunResult.NotRun;
            InstallEms = TestRunResult.NotRun;
            UninstallEms = TestRunResult.NotRun;
            HealthChecks = TestRunResult.NotRun;
            LiveBvts = TestRunResult.NotRun;

            _negativeUris = new List<Uri>();
            _failingUrls = new List<string>();
            _passingUrls = new List<string>();

            PopulateExpectedHealthCheckOutcomes();
        }

        private bool AllResultsAreEqualTo(TestRunResult result)
        {
            return (UninstallEms == result && Install == result && InstallEms == result &&
                HealthChecks == result && LiveBvts == result);
        }

        public void AddPassingUrl(string url)
        {
            UriBuilder uriBuilder = new UriBuilder(url);
            uriBuilder.Host = "localhost";

            if (_negativeUris.Contains(uriBuilder.Uri))
            {
                HealthChecks = TestRunResult.Failed;
                _failingUrls.Add(url + " [Should Be Blocked]");
            }
            else
            {
                if (HealthChecks == TestRunResult.NotRun)
                    HealthChecks = TestRunResult.Passed;
                _passingUrls.Add(url);
            }
        }

        public void AddFailingUrl(string url, string responseCode)
        {
            UriBuilder uriBuilder = new UriBuilder(url);
            uriBuilder.Host = "localhost";

            if (_negativeUris.Contains(uriBuilder.Uri))
            {
                if (HealthChecks == TestRunResult.NotRun)
                    HealthChecks = TestRunResult.Passed;
                _passingUrls.Add(url + " [Blocked]");
            }
            else
            {
                HealthChecks = TestRunResult.Failed;
                _failingUrls.Add(String.Format("{0} [{1}]", url, responseCode));
            }
        }

        private void PopulateExpectedHealthCheckOutcomes()
        {
            _negativeUris.Add(new Uri("http://localhost:10180/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:10190/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:11180/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:11190/xpnfront/health.ashx"));
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\MainBvtNetAutomation\MainApplication.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using HealthCheck;
using BvtNetAutomation;
using System.IO;

namespace MainBvtNetAutomation
{
    public class MainApplication
    {
        /// <summary>
        /// The main entry point for the program.
        /// </summary>
        /// <param name="args">
        /// Parameter 1: The path to the vault folder
        ///Parameter 2: The e-mail address to provide with results
        ///Parameter 3: The password for the currently logged in user.</param>
        /// <returns></returns>
        static void Main(string[] args)
        {
            if (args.Length != 3)
            {
                Console.WriteLine("Usage is: OctopusDailyTests <path to vault> <e-mail address> <password>");
                Logger.WriteToLog("Usage is: OctopusDailyTests <path to vault> <e-mail address> <password>");
                Environment.Exit(1);
            }


            string vaultPath = args[0];
            string emailAddress = args[1];
            string password = args[2];

            BuildManger buildManger = new BuildManger(vaultPath);

            bool isNewBuild = buildManger.CheckNewBuild();

            try
            {
                if (isNewBuild)
                {
                    RunOctopus runOctopus = new RunOctopus(vaultPath);
                    try
                    {
                        runOctopus.IntialzeOctopusPathInfo();
                        runOctopus.InitializeConfig(password);

                        bool isUninstallEmsFail = runOctopus.UninstallEms();
                        if (!isUninstallEmsFail)
                        {
                            Console.WriteLine("uninstall ems fail");
                            throw new InstallationFailureException("uninstall ems fail");
                        }

                        Console.WriteLine("Deleted the files");
                        buildManger.DeleteAllDirectoriesFromBvtNet();
                        Console.WriteLine("Copy the files");
                        buildManger.MakeCopyFromLatestToBvtNet();

                        bool isInstallXblsFail = runOctopus.InstallXbls();
                        if (!isInstallXblsFail)
                        {
                            Console.WriteLine("Install xbls fail");
                            throw new InstallationFailureException("Install xbls fail");
                        }
                        bool isInstallEmsFail = runOctopus.InstallEms();
                        if (!isInstallEmsFail)
                        {
                            Console.WriteLine("Install Ems fail");
                            throw new InstallationFailureException("Install Ems fail");
                        }

                        bool isBvtNetFail = runOctopus.InstallBvts(vaultPath);
                        if (!isBvtNetFail)
                        {
                            Console.WriteLine("Run Bvts fail");
                            throw new InstallationFailureException("Run Bvts fail");
                        }
                    }
                    catch (InstallationFailureException excep)
                    {
                        Logger.WriteToLog(excep.Message);
                        runOctopus.ResultsToFile();
                        return;
                    }
                    runOctopus.ResultsToFile();
                    return;
                }
                else
                {
                    Console.WriteLine("There is no new build");
                    Logger.WriteToLog("There is no new build");
                    return;
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine("Unable to run the overall Application  " + ex.Message);
                Logger.WriteToLog("Unable to run the overall Application  " + ex.Message);
            }
            return;
        }

        public class InstallationFailureException : Exception
        {
            public InstallationFailureException() { }
            public InstallationFailureException(string message) : base(message) { }
        }
    }//class
}//ns
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\DeployBvtNet\PopulateConfigXml.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Diagnostics;
using System.IO;

namespace BvtNetAutomation
{
    /// <summary>
    /// this class parse the pathConfig.xml which has path of latest.tst, BVTNetCurrent........
    /// </summary>
    public class PopulateConfigXml
    {
        private string _latestPath;
        private string _bvtNetCurrentPath;
        private string _emsLatestPath;
        private string _emsBvtNetCurrentPath;
        private string _bvtNetConfigPath;
        private string _emsConfigPath;

        private static PopulateConfigXml _instance = null;

        private PopulateConfigXml()
        { }

        public static PopulateConfigXml GetInstance(string path)
        {
            if (_instance == null)
            {
                if (_instance == null)
                {
                    _instance = new PopulateConfigXml();
                    _instance.ParseXml(path);
                }

            }
            return _instance;
        }

        /// <summary>
        /// This method parse the config xml which has the path from TstTLslnfrDep001 machine
        /// </summary>
        private void ParseXml(string vaultPath)
        {
            try
            {
                XmlDocument doc = new XmlDocument();
                doc.Load(Path.Combine(vaultPath, "PathConfig.xml"));

                XmlNodeList listLatestPath = doc.GetElementsByTagName("PathOfLatest");
                XmlNodeList listbvtNetCurrentPath = doc.GetElementsByTagName("PathOfBvtNet");
                XmlNodeList listLatestPathEms = doc.GetElementsByTagName("PathOfLatestEms");
                XmlNodeList listBvtNetCurrentPathEms = doc.GetElementsByTagName("PathOfBvtNetEms");
                XmlNodeList listBvtNetConfigPath = doc.GetElementsByTagName("PathToConfigBvtNet");
                XmlNodeList listEmsConfigPath = doc.GetElementsByTagName("PathToConfigEms");

                XmlNode latestNodePath = listLatestPath[0];
                XmlNode bvtNetNodePath = listbvtNetCurrentPath[0];
                XmlNode emsLatestNodePath = listLatestPathEms[0];
                XmlNode emsBvtNetNodePath = listBvtNetCurrentPathEms[0];
                XmlNode bvtNetNodeConfigPath = listBvtNetConfigPath[0];
                XmlNode emsNodeConfigPath = listEmsConfigPath[0];

                _latestPath = latestNodePath.Attributes["pathName"].InnerText;
                _bvtNetCurrentPath = bvtNetNodePath.Attributes["pathName"].InnerText;
                _emsLatestPath = emsLatestNodePath.Attributes["pathName"].InnerText;
                _emsBvtNetCurrentPath = emsBvtNetNodePath.Attributes["pathName"].InnerText;
                _bvtNetConfigPath = bvtNetNodeConfigPath.Attributes["pathName"].InnerText;
                _emsConfigPath = emsNodeConfigPath.Attributes["pathName"].InnerText;
            }
            catch (Exception ex)
            {
                Console.WriteLine("unable to parse the config xml  " + ex.Message);
                Logger.WriteToLog("unable to parse the config xml  " + ex.Message);
                Environment.Exit(1);
            }
        }

        public string LatestPath
        {
            get { return _latestPath; }
            set { _latestPath = value; }
        }

        public string BvtNetCurrentPath
        {
            get { return _bvtNetCurrentPath; }
            set { _bvtNetCurrentPath = value; }
        }

        public string BvtNetConfigPath
        {
            get { return _bvtNetConfigPath; }
            set { _bvtNetConfigPath = value; }
        }

        public string EmsConfigPath
        {
            get { return _emsConfigPath; }
            set { _emsConfigPath = value; }
        }

        public string EmsLatestPath
        {
            get { return _emsLatestPath; }
            set { _emsLatestPath = value; }
        }

        public string EmsBvtNetCurrentPath
        {
            get { return _emsBvtNetCurrentPath; }
            set { _emsBvtNetCurrentPath = value; }
        }

    }//class
}//ns
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\Assert.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace ConfigNPDB
{
    public static class Assert
    {

        #region Custom Assertions

        /// <summary>
        /// Used to indicate that a test case should never pass. This is usually only useful for test cases that
        /// are not finished and should not appear in any finished test case code.
        /// </summary>
        /// <param name="message">The reason why the test failed.</param>
        public static void Failure(string message)
        {
            throw new UnexpectedTestResultException(message);
        }

        /// <summary>
        /// A delegate used in combination with AssertThrowsException().
        /// </summary>
        public delegate void AssertionDelegate();

        /// <summary>
        /// Indicates that a specific block of code is expected to throw an exception of a certain type. Polymorphism for exception
        /// types is not supported. For example, this method will fail a test case if IllegalOperationException was thrown but Exception
        /// was expected.
        /// </summary>
        /// <param name="assertionDelegate">A single-cast delegate which represents the code that should not throw an exception</param>
        /// <param name="expectedExceptionType">The most specific type of the exception which is expected to be thrown.</param>
        public static void ThrowsException(AssertionDelegate assertionDelegate, Type expectedExceptionType)
        {
            bool caughtExpectedException = false;
            try
            {
                assertionDelegate();
            }
            catch (Exception e)
            {
                Type actualExceptionType = e.GetType();
                if (actualExceptionType != expectedExceptionType)
                {
                    throw new UnexpectedTestResultException(String.Format("Expected exception {0} to be thrown. Caught {1} instead.", expectedExceptionType, actualExceptionType), e);
                }
                caughtExpectedException = true;
            }

            if (!caughtExpectedException)
                throw new UnexpectedTestResultException(String.Format("Expected exception {0} to be thrown. No exception actually caught.", expectedExceptionType));
        }

        /// <summary>
        /// Indicates that value1 and value2 are not expected to be equal.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must implement IEquatable[T] interface</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public static void NotEqual<T>(T value1, T value2, string message) where T : IEquatable<T>
        {
            if (value1.Equals(value2))
            {
                if (message == null)
                    message = "Tested values are not supposed to be equal.";
                message = String.Format("{0}: {1} == {2}", message, value1, value2);
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to be equal.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must implement IEquatable[T] interface</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public static void Equal<T>(T value1, T value2, string message) where T : IEquatable<T>
        {
            if (!value1.Equals(value2))
            {
                if (message == null)
                    message = "Tested values are supposed to be equal.";
                message = String.Format("{0}: {1} != {2}", message, value1, value2);
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to reference the same object.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must be Object or a subclass of Object</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public static void ReferencesEqual<T>(T a, T b, string message)
        {
            if (!object.ReferenceEquals(a, b))
            {
                if (message == null)
                    message = "Tested values are supposed to have equal references.";
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that the reference o is not allowed to be null.
        /// </summary>
        /// <param name="o">The reference to test for null</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public static void NotNull(object o, string message)
        {
            if (o == null)
                throw new UnexpectedTestResultException(message); ;
        }

        /// <summary>
        /// Indicates that the operation must return true
        /// </summary>
        /// <param name="isTrue">the value to assert</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public static void True(Boolean isTrue, String message)
        {
            if (!isTrue)
                throw new UnexpectedTestResultException(message);
        }
        #endregion
    }
    /// <summary>
    /// An exception used to specify that we've encountered a problem. This is always a terminating condition.
    /// This intentionally shadows the STF exception of the same type. The one included in STF is not serializable
    /// and this is a requirement for throwing exceptions across AppDomains using remoting.
    /// </summary>
    [Serializable]
    public class UnexpectedTestResultException : Exception
    {
        public UnexpectedTestResultException(string message) : base(message) { }
        public UnexpectedTestResultException() { }
        public UnexpectedTestResultException(string message, Exception innerException) : base(message, innerException) { }
        public UnexpectedTestResultException(SerializationInfo serializationInfo, StreamingContext streamingContext)
            : base(serializationInfo, streamingContext) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\BvtNetAutomation\DeployBvtNet\RunOctopus.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Xml;
using System.Threading;
using HealthCheck;

namespace BvtNetAutomation
{
    /// <summary>
    /// this class has a method that runs an Octopus to Install xbls/Ems, Unistall xbls/ems ...
    /// </summary>
    public class RunOctopus
    {
        #region initaliztion
        OctopusProcess octopusProcess = new OctopusProcess();
        static TestResults Results = new TestResults();
        static string containingDirectory;
        static string installLogMarkerPath;
        static string uninstallLogMarkerPath;
        static string bvtLogMarkerPath;
        static string emsInstallLogMarkerPath;
        static string emsUninstallLogMarkerPath;
        static readonly string installLogMarker = "install_loglocation.txt";
        static readonly string uninstallLogMarker = "uninstall_loglocation.txt";
        static readonly string bvtLogMarker = "bvt_loglocation.txt";
        static readonly string emsInstallLogMarker = "emsInstall_loglocation.txt";
        static readonly string emsUninstallLogMarker = "emsUninstall_loglocation.txt";
        private string _BvtResultsPath;
        private string _HtmlReport = "";
        private static readonly string _BvtResultsFile = "bvt_results";
        #endregion

        #region initaliztion date time
        DateTime OverallStartTime = DateTime.Now;
        DateTime OverallEndTime = DateTime.Now;
        TimeSpan OverallRunTime = new TimeSpan(0);
        DateTime InstallStartTime = DateTime.Now;
        TimeSpan InstallRunTime = new TimeSpan(0);
        DateTime HealthCheckStartTime = DateTime.Now;
        TimeSpan HealthCheckRunTime = new TimeSpan(0);
        DateTime BvtStartTime = DateTime.Now;
        DateTime BvtEndTime = DateTime.Now;
        TimeSpan BvtRunTime = new TimeSpan(0);
        DateTime emsInstallStartTime = DateTime.Now;
        TimeSpan emsInstallRunTime = new TimeSpan(0);
        DateTime emsUninstallStartTime = DateTime.Now;
        TimeSpan emsUninstallRunTime = new TimeSpan(0);
        #endregion
        PopulateConfigXml populateConfigXml;
        public RunOctopus(string path)
        {
            populateConfigXml = PopulateConfigXml.GetInstance(path);
        }

        public void IntialzeOctopusPathInfo()
        {
            try
            {
                containingDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

                installLogMarkerPath = Path.Combine(containingDirectory, installLogMarker);
                if (File.Exists(installLogMarkerPath))
                    File.Delete(installLogMarkerPath);

                uninstallLogMarkerPath = Path.Combine(containingDirectory, uninstallLogMarker);
                if (File.Exists(uninstallLogMarkerPath))
                    File.Delete(uninstallLogMarkerPath);

                bvtLogMarkerPath = Path.Combine(containingDirectory, bvtLogMarker);
                if (File.Exists(bvtLogMarkerPath))
                    File.Delete(bvtLogMarkerPath);

                emsInstallLogMarkerPath = Path.Combine(containingDirectory, emsInstallLogMarker);
                if (File.Exists(emsInstallLogMarkerPath))
                    File.Delete(emsInstallLogMarkerPath);

                emsUninstallLogMarkerPath = Path.Combine(containingDirectory, emsUninstallLogMarker);
                if (File.Exists(emsUninstallLogMarkerPath))
                    File.Delete(emsUninstallLogMarkerPath);

            }
            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }

        }

        /// <summary>
        /// to get overall start time and Set up the Octopus Installer config
        /// </summary>
        /// <param name="password"></param>
        public void InitializeConfig(string password)
        {
            try
            {
                //Start timing the whole run
                OverallStartTime = DateTime.Now;
                //Set up the Octopus Installer config
                octopusProcess.UseFakeAgent = false;
                octopusProcess.PendingRebootOperation = OctopusPendingRebootOperation.Reboot;
                octopusProcess.Password = password;
                octopusProcess.UseVerboseMsiLogging = true;
            }
            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }
        }
        /// <summary>
        /// to unistall Ems
        /// </summary>
        /// <returns>true if the unstall result pass else false</returns>
        public bool UninstallEms()
        {
            try
            {
                Console.WriteLine("\t*** Uninstalling Ems Service ***");
                emsUninstallStartTime = DateTime.Now;
                CommonOctopusInitialization(OctopusInstallationType.Uninstall, Path.Combine(populateConfigXml.EmsConfigPath, "EmsInstall.xml"), emsUninstallLogMarkerPath);
                DateTime emsUninstallEndTime = DateTime.Now;
                emsUninstallRunTime = emsUninstallEndTime - emsUninstallStartTime;
                string emsUninstallLogPath = GetLogPathFromMarker(emsUninstallLogMarkerPath);
                if (!string.IsNullOrEmpty(emsUninstallLogPath) && File.Exists(emsUninstallLogPath))
                {
                    Results.UninstallEms = GetDeploymentResultFromLog(emsUninstallLogPath);
                    return ValidateResult(Results.UninstallEms, "Uninstall Ems result failed", "Uninstall Ems result pass", "Uninstall Ems result not run");
                }
            }
            catch (Exception ex)
            {
                Logger.WriteToLog("unable to unistall Ems " + ex.Message);
            }
            return false;
        }

        /// <summary>
        /// to install xbls
        /// </summary>
        /// <returns>true if install pass else false</returns>
        public bool InstallXbls()
        {
            try
            {
                Console.WriteLine("\t*** Installing Xbls Service ***");
                InstallStartTime = DateTime.Now;
                CommonOctopusInitialization(OctopusInstallationType.Install, Path.Combine(populateConfigXml.BvtNetConfigPath, "BvtNet.xml"), installLogMarkerPath);
                DateTime InstallEndTime = DateTime.Now;
                InstallRunTime = InstallEndTime - InstallStartTime;
                string installLogPath = GetLogPathFromMarker(installLogMarkerPath);
                if (!string.IsNullOrEmpty(installLogPath) && File.Exists(installLogPath))
                {
                    Results.Install = GetDeploymentResultFromLog(installLogPath);
                    return ValidateResult(Results.Install, "Install xbls result failed", "Install xbls result pass", "Install xbls result not run");
                }
            }
            catch (Exception ex)
            {
                Logger.WriteToLog("Unable to Install xbls " + ex.Message);
            }
            return false;
        }

        /// <summary>
        /// to install ems
        /// </summary>
        /// <returns>true if ems result pass esle false</returns>
        public bool InstallEms()
        {
            try
            {
                Console.WriteLine("\t*** Installing Ems***");
                emsInstallStartTime = DateTime.Now;
                CommonOctopusInitialization(OctopusInstallationType.Install, Path.Combine(populateConfigXml.EmsConfigPath, "EMSInstall.xml"), emsInstallLogMarkerPath);
                DateTime emsInstallEndTime = DateTime.Now;
                emsInstallRunTime = emsInstallEndTime - emsInstallStartTime;
                string emsInstallLogPath = GetLogPathFromMarker(emsInstallLogMarkerPath);
                if (!string.IsNullOrEmpty(emsInstallLogPath) && File.Exists(emsInstallLogPath))
                {
                    Results.InstallEms = GetDeploymentResultFromLog(emsInstallLogPath);
                    return ValidateResult(Results.InstallEms, "Install Ems result failed", "Install Ems result pass", "Install Ems result not run");

                }
            }
            catch (Exception ex)
            {
                Logger.WriteToLog("Unable to Install Ems" + ex.Message);
            }
            return false;
        }

        /// <summary>
        /// to run Bvts
        /// </summary>
        /// <param name="vaultPath">vaultpath has the config file which system health check uses to run 
        /// HealthCheckVerifier automation and bvt config file</param>
        public bool InstallBvts(string vaultPath)
        {
            try
            {
                Console.WriteLine("\t*** Running BVTs ***");
                BvtStartTime = DateTime.Now;
                CommonOctopusInitialization(OctopusInstallationType.Install, Path.Combine(vaultPath, "bvt001.xml"),bvtLogMarkerPath);
                //CommonOctopusInitialization(OctopusInstallationType.Install, Path.Combine(populateConfigXml.BvtNetConfigPath, "bvt001.xml"), bvtLogMarkerPath);
                string bvtLogPath = GetLogPathFromMarker(bvtLogMarkerPath);
                if (!string.IsNullOrEmpty(bvtLogPath) && File.Exists(bvtLogPath))
                {
                    ReviewSystemCheckResultsUsingLog(bvtLogPath, vaultPath);
                    Results.LiveBvts = GetResultForCommandInLog("run-live-bvts", bvtLogPath);
                    HealthCheckStartTime = GetTimeStampForCommandInLog("health-check", bvtLogPath, true);
                    DateTime HealthCheckEndTime = GetTimeStampForCommandInLog("health-check", bvtLogPath, false);
                    HealthCheckRunTime = HealthCheckEndTime - HealthCheckStartTime;
                    BvtStartTime = GetTimeStampForCommandInLog("run-live-bvts", bvtLogPath, true);
                    BvtEndTime = GetTimeStampForCommandInLog("run-live-bvts", bvtLogPath, false);
                    BvtRunTime = BvtEndTime - BvtStartTime;
                    OverallEndTime = DateTime.Now;
                    OverallRunTime = OverallEndTime - OverallStartTime;
                    return true;
                }
            }
            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }
            return false;
        }

        /// <summary>
        /// to get the result for emailing
        /// </summary>
        public void ResultsToFile()
        {
            try
            {
                //set to the result path
                _BvtResultsPath = Path.Combine(populateConfigXml.BvtNetConfigPath, Logger.LOGFILEFOLDER);
                StringBuilder resultsFileName = new StringBuilder(_BvtResultsFile);
                resultsFileName.Append(DateTime.Now.ToString("MM-dd-yyyy_HH-mm-ss"));
                resultsFileName.Append(".html");

                Console.WriteLine("\t*** Logging Results ***");
                string resultsFile = Path.Combine(_BvtResultsPath, resultsFileName.ToString());
                Console.WriteLine("Logging to: {0}", resultsFile);
                string buildNumber = BuildManger.Latest;
                Console.WriteLine("Build version = {0}", buildNumber);
                GetBvtNetHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed BvtNet Results");
                Console.WriteLine("*** Results: ***\n{0}", _HtmlReport);
                if (File.Exists(resultsFile) == true)
                {
                    File.Delete(resultsFile);
                }
                using (StreamWriter rfStream = File.CreateText(resultsFile))
                {
                    rfStream.Write(_HtmlReport);
                    rfStream.Close();
                }

            }
            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }
        }
        /// <summary>
        /// to initalize the octopus process
        /// </summary>
        /// <param name="octType"></param>
        /// <param name="pathConfig"></param>
        /// <param name="logMarkPath"></param>
        private void CommonOctopusInitialization(OctopusInstallationType octType, string pathConfig, string logMarkPath)
        {
            octopusProcess.InstallationType = octType;
            octopusProcess.PathToConfigurationFile = pathConfig;
            octopusProcess.PathToLogLocationFile = logMarkPath;
            octopusProcess.Run();
        }
        /// <summary>
        /// to validate the result
        /// </summary>
        /// <param name="results"></param>
        /// <param name="failedMessage"></param>
        /// <param name="passedMessage"></param>
        /// <param name="notRunMessage"></param>
        /// <returns></returns>
        private bool ValidateResult(TestRunResult results, string failedMessage, string passedMessage, string notRunMessage)
        {
            try
            {
                if (results == TestRunResult.Failed)
                {
                    Logger.WriteToLog(failedMessage);
                    return false;
                }
                else if (results == TestRunResult.Passed)
                {
                    Logger.WriteToLog(passedMessage);
                    return true;
                }
                else
                {
                    Logger.WriteToLog(notRunMessage);
                    return false;
                }
            }

            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }
            return false;
        }

        static string GetLogPathFromMarker(string path)
        {
            string returnValue = null;
            string logPath = GetLogFolderPathFromMarker(path);

            if (logPath != null && File.Exists(Path.Combine(logPath, "deploymentSession.xml")))
            {
                returnValue = Path.Combine(logPath, "deploymentSession.xml");
            }

            return returnValue;
        }

        static string GetLogFolderPathFromMarker(string path)
        {
            string returnValue = null;
            if (File.Exists(path))
            {
                string logPath = null;
                using (StreamReader s = new StreamReader(path))
                {
                    logPath = s.ReadLine();
                }
                if (logPath != null)
                {
                    returnValue = logPath;
                }
            }
            return returnValue;
        }
        /// <summary>
        /// to get the result pass, fail or not run 
        /// </summary>
        /// <param name="logFilePath"></param>
        /// <returns></returns>
        static TestRunResult GetDeploymentResultFromLog(string logFilePath)
        {
            TestRunResult returnValue = TestRunResult.NotRun;
            try
            {
                if (logFilePath != null)
                {
                    string[] errors = GetErrorsFromOctopusLog(logFilePath);
                    if (errors.Length == 0)
                    {
                        returnValue = TestRunResult.Passed;
                    }
                    else
                    {
                        returnValue = TestRunResult.Failed;
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.WriteToLog(ex.Message);
            }
            return returnValue;
        }

        ///<summary>
        ///Looks throught the healthchecks.xml file in an Octopus Log folder to determine whether or not the URLs run by
        ///SystemCheck passed as expected. These results are registered directly with the result object.
        ///</summary>
        ///<param name="logFilePath">The path to a text file containing the path to the folder containing healthchecks.xml. This is usually acquired by OctopusCLI's -recordLogFolderIn option. Although</param>
        /// <summary>
        /// Looks throught the healthchecks.xml file in an Octopus Log folder to determine whether or not the URLs run by
        /// SystemCheck passed as expected. These results are registered directly with the result object.
        /// </summary>
        /// <param name="logFilePath">The path to a text file containing the path to the folder containing healthchecks.xml. This is usually acquired by OctopusCLI's -recordLogFolderIn option. Although</param>
        static void ReviewSystemCheckResultsUsingLog(string logFilePath, string vaultPath)
        {
            if (logFilePath != null && File.Exists(Path.Combine(Path.GetDirectoryName(logFilePath), "healthchecks.xml")))
            {
                CheckResultManager manger = new CheckResultManager();
                string configXml = (@"HealthCheckConfig.xml");

                try
                {
                    manger.LoadXmlAndPopulateData(Path.Combine(Path.GetDirectoryName(logFilePath), "healthchecks.xml"), Path.Combine(vaultPath, configXml));
                }
                catch (Exception hcExcep)
                {
                    Console.WriteLine("Caught an Exception Parsing Healthchecks:\n{0}", hcExcep.ToString());
                }

                List<CheckResult> checkResultList = manger.CheckResults;

                foreach (CheckResult checkResult in checkResultList)
                {
                    if (checkResult.HealthStatus.Equals(HealthStatus.Fail))
                    {
                        //isFail = true;
                        Results.AddFailingUrl(checkResult.Url, checkResult.HealthStatus.ToString());
                    }
                    else
                    {
                        Results.AddPassingUrl(checkResult.Url);
                    }
                }
                //if (isFail)
                //    Results.HealthChecks = TestRunResult.Failed;
                //else
                //    Results.HealthChecks = TestRunResult.Passed;

                using (StreamWriter write = new StreamWriter(Path.Combine(Path.GetDirectoryName(logFilePath), (@"healthCheckVeriferLog.txt"))))
                {
                    write.Write(manger.ErrorsToBeLogged);
                    write.Close();
                }
            }
        }
        ///<summary>
        ///populate the errors if it has any error
        ///</summary>
        ///<param name="logPath"></param>
        ///<returns>list of errors</returns>
        private static string[] GetErrorsFromOctopusLog(string logPath)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(logPath);
            List<String> errorMessages = new List<String>();

            XmlNodeList elements = xmlDoc.GetElementsByTagName("msiError");
            foreach (XmlElement e in elements)
            {
                errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
            }

            //Command finished nodes are the only ones that carry errors
            elements = xmlDoc.GetElementsByTagName("commandFinished");
            foreach (XmlElement e in elements)
            {
                if (e.GetAttribute("eventLevel") == "Error")
                {
                    errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
                }
            }

            elements = xmlDoc.GetElementsByTagName("message");
            foreach (XmlElement e in elements)
            {
                if (e.GetAttribute("eventLevel") == "Error")
                {
                    errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
                }
            }

            elements = xmlDoc.GetElementsByTagName("messageError");
            foreach (XmlElement e in elements)
            {
                errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
            }
            return errorMessages.ToArray();

        }

        ///<summary>
        ///It loads the xml file and check the errors from the command 
        ///</summary>
        ///<param name="commandName"></param>
        ///<param name="logFilePath"></param>
        ///<returns></returns>
        public static TestRunResult GetResultForCommandInLog(string commandName, string logFilePath)
        {
            //this only works for one command
            TestRunResult returnValue = TestRunResult.NotRun;
            if (logFilePath != null)
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(logFilePath);
                List<String> errorMessages = new List<String>();

                //get all the elments that named commandfinished and then find that matches with the given caommand name
                //then the attribute match with the error or not 
                XmlNodeList elements = xmlDoc.GetElementsByTagName("commandFinished");
                foreach (XmlElement e in elements)
                {
                    if (e.GetAttribute("name") == commandName)
                    {
                        if (e.GetAttribute("eventLevel") == "Error")
                            returnValue = TestRunResult.Failed;
                        else
                            returnValue = TestRunResult.Passed;
                        break;
                    }
                }
            }

            return returnValue;
        }

        /// <summary>
        /// Checks the start and end time and return it
        /// </summary>
        /// <param name="commandName"></param>
        /// <param name="logFilePath"></param>
        /// <param name="isStartCommand"></param>
        /// <returns>DateTime</returns>
        public static DateTime GetTimeStampForCommandInLog(string commandName, string logFilePath, bool isStartCommand)
        {
            //this only works for one command
            DateTime returnValue = new DateTime(0);
            if (logFilePath != null)
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(logFilePath);
                List<String> errorMessages = new List<String>();
                XmlNodeList elements;

                if (isStartCommand == true)
                    elements = xmlDoc.GetElementsByTagName("commandStarted");
                else
                    elements = xmlDoc.GetElementsByTagName("commandFinished");
                foreach (XmlElement e in elements)
                {
                    if (e.GetAttribute("name") == commandName)
                    {
                        string timeStamp = e.GetAttribute("timeStamp");
                        if (timeStamp != "")
                        {
                            try
                            {
                                returnValue = DateTime.Parse(timeStamp);
                            }
                            catch (FormatException)
                            {
                                returnValue = new DateTime(0);
                            }
                        }
                        break; // We found the command, stop looking
                    }
                }
            }

            return returnValue;
        }

        public void GetBvtNetHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "BvtNet";
            String topology = "Expanded - Ops";
            String logLocation = "http://10.198.103.82/";
            AppendEmailReport(forLogFile, environment, topology, logLocation, version);
        }

        public static string GetColorStringForResult(TestRunResult result)
        {
            if (result == TestRunResult.Failed)
                return "red";
            else if (result == TestRunResult.NotRun)
                return "gray";
            else if (result == TestRunResult.Passed)
                return "green";
            else
                return "black";
        }

        public static string GetNameStringForResult(TestRunResult result)
        {
            if (result == TestRunResult.Failed)
                return "Failed";
            else if (result == TestRunResult.NotRun)
                return "Not Run";
            else if (result == TestRunResult.Passed)
                return "Passed";
            else
                return Enum.GetName(typeof(TestRunResult), result);
        }

        private void AppendEmailReport(bool forLogFile, string environment, string topology, string logLocation, string version)
        {
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if (forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>EMS Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", emsUninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", emsUninstallRunTime.Hours, emsUninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.UninstallEms), GetNameStringForResult(Results.UninstallEms));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>XBLES Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>EMS Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", emsInstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", emsInstallRunTime.Hours, emsInstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.InstallEms), GetNameStringForResult(Results.InstallEms));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            _HtmlReport = stringBuilder.ToString();
        }

    }//class
}//ns
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\BucketDelete.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;

namespace ConfigNPDB
{
    public partial class ConfigNPDBFunctionalTests : TestNode
    {
        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class BucketDeleteTests : TestNode
        {
            public abstract class BucketDeleteTestBase : ConfigNPDBTestBase
            {
                public override void PreRun()
                {
                    General.Report.Info("Ensuring clean environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }

                public override void PostRun()
                {
                    General.Report.Info("Cleaning up environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }
            }
            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Positive : TestNode
            {
                //Standard NPDB Tests - skipped (the same logic is used for this as other bucket modes)
                //Standard Interface Tests - skipped (the same logic is used for this as other bucket modes)
                //Standard Title Tests - skipped (the same logic is used for this as other bucket modes)
                [TestCase]
                public class DeleteBucket : BucketDeleteTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket delete");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("10");                                            // Bucket
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Assert.True(npdb.GetBucketInfo(General.EnvName1, General.Interface1, 0, 10) == null,
                            "bucket delete didn't remove the bucket!");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 19, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 19, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class DeleteTitleBucket : BucketDeleteTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket delete");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        configNPDB.Parameters.Add("10");                                            // Bucket
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 20), "Bucket striping is invalid");

                        Assert.True(npdb.GetBucketInfo(General.EnvName1, General.Interface1, 0, 20) == null,
                            "bucket delete didn't remove the bucket!");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 20);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 19, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 19, "Unexpected number of buckets");
                    }
                }
                [TestCase]
                public class DeleteNonExistantBucket : BucketDeleteTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket delete");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("2000");                                            // Bucket
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Assert.True(npdb.GetBucketInfo(General.EnvName1, General.Interface1, 0, 2000) == null,
                            "bucket delete didn't remove the bucket!");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");
                    }
                }
                [TestCase]
                public class DeleteNonExistantTitleBucket : BucketDeleteTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket delete");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        configNPDB.Parameters.Add("2000");                                            // Bucket
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 20), "Bucket striping is invalid");

                        Assert.True(npdb.GetBucketInfo(General.EnvName1, General.Interface1, 0, 2000) == null,
                            "bucket delete didn't remove the bucket!");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 20);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");
                    }
                }
            }
            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Negative : TestNode
            {
                [TestCase]
                public class InvalidBucketNumber : BucketDeleteTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket delete");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("full");                                          // Bucket
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class InvalidTitleId : BucketDeleteTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket delete");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add("titleId");                                       // TitleID
                        configNPDB.Parameters.Add("10");                                            // Bucket
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Assert.NotNull(npdb.GetBucketInfo(General.EnvName1, General.Interface1, 0, 10),
                            "The bucket lives!");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\BucketServersInstall.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;

namespace ConfigNPDB
{
    public partial class ConfigNPDBFunctionalTests : TestNode
    {
        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class BucketServersInstallTests : TestNode
        {
            public abstract class BucketServersInstallTestBase : ConfigNPDBTestBase
            {
                public override void PreRun()
                {
                    General.Report.Info("Ensuring clean environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }

                public override void PostRun()
                {
                    General.Report.Info("Cleaning up environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }
            }

            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Positive : TestNode
            {
                [TestCase]
                public class CreateOneServerOneBucket : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), 
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly"); 
                        Assert.Equal(configuration.Servers, 1, "Expected 1 server");
                        Assert.Equal(configuration.Buckets, 1, "Expected 1 bucket");
                    }
                }

                [TestCase]
                public class CreateOneServerTwoBuckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("2");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 1, "Expected 1 server");
                        Assert.Equal(configuration.Buckets, 2, "Expected 2 buckets");
                    }
                }

                [TestCase]
                public class CreateTwoServersTwoBuckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 2)); // Servers
                        configNPDB.Parameters.Add("2");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 2, "Expected 2 servers");
                        Assert.Equal(configuration.Buckets, 2, "Expected 2 buckets");
                    }
                }

                [TestCase]
                public class CreateTwoServersTwoBucketsWithHexTitleId : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 2)); // Servers
                        configNPDB.Parameters.Add("2");                                       // Buckets
                        configNPDB.Parameters.Add(String.Format("0x{0:x}", 1297285220));      // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1297285220);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 2, "Expected 2 servers");
                        Assert.Equal(configuration.Buckets, 2, "Expected 2 buckets");
                    }
                }

                [TestCase]
                public class CreateTwoServersTwoBucketsWithDecTitleId : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 2)); // Servers
                        configNPDB.Parameters.Add("2");                                       // Buckets
                        configNPDB.Parameters.Add("1297285220");                              // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1297285220);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 2, "Expected 2 servers");
                        Assert.Equal(configuration.Buckets, 2, "Expected 2 buckets");
                    }
                }

                [TestCase]
                public class CreateTwoServersTwoBucketsWithNonMatchingServerCase : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(                                            // Servers
                            General.GetServers(General.EnvServers1, 2).ToLower()); 
                        configNPDB.Parameters.Add("2");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 2, "Expected 2 servers");
                        Assert.Equal(configuration.Buckets, 2, "Expected 2 buckets");
                    }
                }

                [TestCase]
                public class CreateOneServer420Buckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("420");                                     // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 1, "Expected 1 server");
                        Assert.Equal(configuration.Buckets, 420, "Expected 420 buckets");
                    }
                }

                [TestCase]
                public class Create420Servers420Buckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                            // Environment
                        configNPDB.Parameters.Add(General.Interface1);                   // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 420)); // Servers
                        configNPDB.Parameters.Add("420");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 420, "Expected 420 servers");
                        Assert.Equal(configuration.Buckets, 420, "Expected 420 buckets");        
                    }
                }

                [TestCase]
                public class Create2184Server2184Buckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                             // Environment
                        configNPDB.Parameters.Add(General.Interface1);                    // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 2500)); // Servers
                        configNPDB.Parameters.Add("2500");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                          // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 2500, "Expected 2500 servers");
                        Assert.Equal(configuration.Buckets, 2500, "Expected 2500 buckets");           
                    }
                }

                [TestCase]
                public class Create420Server5KBuckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                             // Environment
                        configNPDB.Parameters.Add(General.Interface1);                    // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 420));  // Servers
                        configNPDB.Parameters.Add("5000");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                          // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 420, "Expected 420 servers");
                        Assert.Equal(configuration.Buckets, 5000, "Expected 5000 buckets");       
                    }
                }

                [TestCase]
                public class Create5Servers420BucketsInOtherEnv : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 1)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 1, "Expected 1 server");
                        Assert.Equal(configuration.Buckets, 420, "Expected 420 buckets");           
                    }
                }
                [TestCase]
                public class Create5DuplicateServers420Buckets : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                 // Interface
                        String serverList = General.GetServers(General.EnvServers1, 5) +
                            "," + General.GetServers(General.EnvServers1, 5);
                        configNPDB.Parameters.Add(serverList);                                // Servers
                        configNPDB.Parameters.Add("420");                                     // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 5, "Expected 5 servers");
                        Assert.Equal(configuration.Buckets, 420, "Expected 420 buckets");
                    }
                }

                [TestCase]
                public class Create5Servers420BucketsTwice : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 1)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 1, "Expected 1 server");
                        Assert.Equal(configuration.Buckets, 420, "Expected 420 buckets");
                    }
                }

                [TestCase]
                public class IncreaseBucketCount : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("421");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 5, "Expected 5 servers");
                        Assert.Equal(configuration.Buckets, 421, "Expected 421 buckets");
                    }
                }

                [TestCase]
                public class DecreaseBucketCount : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("419");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 5, "Expected 5 servers");
                        Assert.Equal(configuration.Buckets, 419, "Expected 419 buckets");
                   }
                }

                [TestCase]
                public class DecreaseBucketCountAddServer : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 6)); // Servers
                        configNPDB.Parameters.Add("419");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 6, "Expected 6 servers");
                        Assert.Equal(configuration.Buckets, 419, "Expected 419 buckets");
                    }
                }

                [TestCase]
                public class IncreaseBucketCountAddServer : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 6)); // Servers
                        configNPDB.Parameters.Add("421");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 6, "Expected 6 servers");
                        Assert.Equal(configuration.Buckets, 421, "Expected 421 buckets");
                    }
                }

                [TestCase]
                public class XDecreaseBucketCountAddMultipleServers : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 9)); // Servers
                        configNPDB.Parameters.Add("400");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 9, "Expected 9 servers");
                        Assert.Equal(configuration.Buckets, 400, "Expected 400 buckets");
                    }
                }

                [TestCase]
                public class XIncreaseBucketCountAddMultipleServers : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 9)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                  // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("421");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 9, "Expected 9 servers");
                        Assert.Equal(configuration.Buckets, 421, "Expected 421 buckets");
                    }
                }

                [TestCase]
                public class XIncreaseBucketCountDecreaseMultipleServers : BucketServersInstallTestBase
                {
                    // confnpdb.exe bucket servers install . SkyNET npdbcfg server1 56 2048s
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 5)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName2);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 2)); // Servers
                        configNPDB.Parameters.Add("421");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 5, "Expected 5 servers");
                        Assert.Equal(configuration.Buckets, 421, "Expected 421 buckets");
                    }
                }
            }

            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Negative : TestNode
            {
                [TestCase]
                public class CreateOneServerNegOneBucket : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("-1");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");

                        
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        
                        Assert.Equals(configuration,null);
                    }
                }
                [TestCase]
                public class CreateOneServerNOBuckets : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("0");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration,null);
                        //Assert.Equal(configuration.Servers, 0, "Expected 0 servers");
                        //Assert.Equal(configuration.Buckets, 0, "Expected 0 buckets");
                    }
                }

                [TestCase]
                public class CreateTwoServersOneBucket : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 2)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration, null);
                        //Assert.Equal(configuration.Servers, 0, "Expected 0 servers");
                        //Assert.Equal(configuration.Buckets, 0, "Expected 0 buckets");
                    }
                }

                [TestCase]
                public class Create420Servers420BucketsRestripedTo421Servers: BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");                        
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 420)); // Servers
                        configNPDB.Parameters.Add("420");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "First call to ConfigNPDB should pass.");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 421)); // Servers
                        configNPDB.Parameters.Add("420");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 420, "Expected 420 servers"); // no change
                        Assert.Equal(configuration.Buckets, 420, "Expected 420 buckets"); // no change
                    }
                }

                [TestCase]
                public class NonexistantNPDB : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add("DNE");                                     // NPDB Address
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration==null, "There should be no configuration.");

                    }
                }

                [TestCase]
                public class NonexistantServer : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add("DNE");                                     // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }

                [TestCase]
                public class NonexistantServerWithExistantServers : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1) + ",DNE"); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }
                [TestCase]
                public class NonexistantInterface : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add("DNE");                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }

                [TestCase]
                public class NonExistantEnvironment : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add("DNE");                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }

                [TestCase]
                public class InvalidTitleId : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("DNE");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }

                [TestCase]
                public class OverflowTitleId : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add(UInt64.MaxValue.ToString());                // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }

                [TestCase]
                public class AppendTrashToCommandLine : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("1");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        configNPDB.Parameters.Add("TRASH!");
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.Equals(configuration == null, "There should be no configuration.");
                    }
                }

                [TestCase]
                public class IncreaseServersDecreaseBucketsUnderServers : BucketServersInstallTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // Database Name
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("20");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\ConfigNPDB.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Threading;
using ServerTestFramework;

namespace ConfigNPDB
{
    public class ConfigNPDB
    {
        public String Mode
        {
            get { return _mode; }
            set { _mode = value; }
        }

        public List<String> Parameters
        {
            get { return _parameters; }
        }

        public ConfigNPDB(String mode)
        {
            _parameters = new List<String>();
            _mode = mode;
            _output = new List<String>();
        }

        public int Execute()
        {
            String[] arguments = _parameters.ToArray();

            _output.Clear();

            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "ConfNPDB.exe";
            startInfo.Arguments = _mode + " " + String.Join(" ", arguments);
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = true;
            startInfo.RedirectStandardOutput = true;
            startInfo.RedirectStandardError = true;

            outputReport.Info("[CMD] {0} {1}", startInfo.FileName, startInfo.Arguments);
            ProcessEx process = new ProcessEx(startInfo);
            process.OutputDataReceived += new DataReceivedEventHandler(process_OutputDataReceived);
            process.ErrorDataReceived += new DataReceivedEventHandler(process_ErrorDataReceived);
            process.EnableRaisingEvents = true;
            process.SemaphoreEnter();
            process.Start();
            process.BeginErrorReadLine();
            process.BeginOutputReadLine();
            process.SemaphoreWait();
            process.WaitForExit();
            
            foreach (String line in _output)
                outputReport.Debug(line);

            outputReport.Info("[RET] {0} exited with code {1}", Path.GetFileName(startInfo.FileName),
                process.ExitCode);

            return process.ExitCode;
        }

        void process_OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data == null)
            {
                (sender as ProcessEx).SemaphoreLeave();
            }
            else
            {
                _output.Add(String.Format("[OUT] {0}", e.Data));
            }
        }

        void process_ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data == null)
            {
                (sender as ProcessEx).SemaphoreLeave();
            }
            else
            {
                _output.Add(String.Format("[OUT] {0}", e.Data));
            }
        }

        public class ProcessEx : Process
        {
            protected Semaphore semaphore;

            public ProcessEx(ProcessStartInfo startInfo)
            {
                StartInfo = startInfo;
            }

            public void SemaphoreEnter()
            {
                semaphore = new Semaphore(0, 2);
            }

            public void SemaphoreLeave()
            {
                semaphore.Release();
            }

            public void SemaphoreWait()
            {
                semaphore.WaitOne();
                semaphore.WaitOne();
            }
        }

        private List<String> _parameters;
        private String _mode;
        private static Report outputReport = new Report("ConfigNPDB");
        private List<String> _output;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\BucketXML.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using System.IO;
using System.Xml;
using System.Data.Sql;
using System.Data.SqlClient;

namespace ConfigNPDB
{
    public partial class ConfigNPDBFunctionalTests : TestNode
    {
        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class BucketXMLTests : TestNode
        {

            static Report reportObj = new Report("BucketXmlTests");

            public abstract class BucketXMLTestBase : ConfigNPDBTestBase
            {
                public override void PreRun()
                {
                    General.Report.Info("Ensuring clean environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }

                public override void PostRun()
                {
                    General.Report.Info("Cleaning up environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }
            }
            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Positive : TestNode
            {
                [TestCase]
                public class ClearInterfaceBuckets : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket clear");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.True(configuration == null, "Bucket configuration not cleared");
                    }
                }

                [TestCase]
                public class ExportInterfaceBuckets : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportInterfaceBuckets.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);                        

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        //configNPDB.Parameters.Add("-title 0");                                      // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 0);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }
                         

                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        File.Delete(tempFile);
                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportMultipleTitlesNoSiteId : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportMultipleTitlesNoSiteId.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        // add 20 buckets with title id of 0
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        // add 20 more buckets with title id of 1
                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("1");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        //do not specify title id so that ALL titles should show up.
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportSingleTitleWhenMultipleTitlesExist : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportSingleTitleWhenMultipleTitlesExist.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        // add 20 buckets with title id of 0
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        // add 20 more buckets with title id of 1
                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("1");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name

                        //only export those titles with titleId of 1
                        configNPDB.Parameters.Add("-title 1");                                      // TitleID
                        
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 1);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportUsingOverwriteOption : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportUsingOverwriteOption.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        // add 20 buckets with title id of 0
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        // first export to create the file.
                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name

                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 0);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file after first export. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }



                        // second export to test overwrite
                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-options overwrite");                            // add overwrite option

                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 0);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file after first export. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }



                [TestCase]
                public class OverwriteOneSiteIdWhenMulipleSiteIdsExist : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportUsingOverwriteOption.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        // add 20 buckets with title id of 0
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        // add 20 buckets with title id of 1
                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("1");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        // first export both title id 1 and title id 0
                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 1), "Bucket striping is invalid");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file after first export. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }



                        // second export to test overwrite and specify only site id 1
                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 1");                                      // using title id 1
                        configNPDB.Parameters.Add("-options overwrite");                            // add overwrite option

                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 1), "Bucket striping is invalid");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        // title=1 filter because we are now deleting entire file when using overwrite.
                        BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 1);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file after first export. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportTitle0ThenExportTitle1Overwrite : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportTitle0ThenExportTitle1Overwrite.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        // add 20 buckets with title id of 0
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        // first export title id 0
                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");




                        // add 20 buckets with title id of 1
                        configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("1");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        // second export title id 1
                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 1");                                             // TitleID
                        configNPDB.Parameters.Add("-options overwrite");
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 1), "Bucket striping is invalid");

                        configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        // title=1 because we are deleting entire file on overwrite.
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 1);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file after first export. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }



                [TestCase]
                public class ExportInterfaceBucketsToShare : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = @"\\josephfo\Share\myFile.xml";

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        //configNPDB.Parameters.Add("-title 0");                                      // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 0);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        File.Delete(tempFile);
                        outputReport.Info("All validation passes.");
                    }
                }

                [TestCase]
                public class ExportInterfaceBucketsToWorkingDir : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = @"myExportFile.xml";

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        //configNPDB.Parameters.Add("-title 0");                                      // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 0);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        File.Delete(tempFile);
                        outputReport.Info("All validation passes.");
                    }
                }



                [TestCase]
                public class ExportTitleInterfaceBuckets : BucketXMLTestBase
                {

                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportTitleInterfaceBuckets.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile); 

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 20), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 20);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");


                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 20);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {                            
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }
                        

                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        File.Delete(tempFile);
                        outputReport.Info("All validation passes.");                        
                    }
                }



                [TestCase]
                public class ExportSingleBucket : BucketXMLTestBase
                {

                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "myExportFile.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        DateTime migrationTime = DateTime.Now;
                        String serverName = General.GetServers(General.EnvServers1, 1);

                        InterfaceBucket ib = new InterfaceBucket(General.EnvName1, General.Interface1, 22, 0, serverName, serverName, migrationTime, "myInfo1", "myInfo2", "myInfo3", "myInfo4");
                        InterfaceBucket.AddInterfaceBucketToDB(ib);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 22");                                     // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");


                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 22), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 22);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 1, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 1, "Unexpected number of buckets");


                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 22);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportEmptyBuckets : BucketXMLTestBase
                {

                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportTitleInterfaceBuckets.xml");
                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile); 

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 77");                                     // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 77);
                        Assert.Equals(configuration==null, "configuration expected to be null, but is not");
                        
                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 20);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                    }
                }


                [TestCase]
                public class ImportInterfaceBucketsOverExisting : BucketXMLTestBase
                {

                    // Note: import tests are failing with invalid handle when attempting to import.
                    // For now, I'm just running all import test manually.

                    public override void Test()
                    {
                        String tempFile = Path.Combine(Path.GetTempPath(), "ExportInterfaceBuckets.xml");

                        // delete the file if it already exists.
                        if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        //configNPDB.Parameters.Add("-title 0");                                      // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml import");
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 20, "Unexpected number of buckets");

                        Dictionary<string, InterfaceBucket> BucketsFromFile = InterfaceBucket.GetInterfaceBucketsFromFile(tempFile);
                        Dictionary<string, InterfaceBucket> BucketsFromDB = InterfaceBucket.GetInterfaceBucketsFromDB(General.EnvName1, General.Interface1, 0);
                        if (InterfaceBucket.CompareInterfaceBuckets(BucketsFromDB, BucketsFromFile))
                        {
                            reportObj.Info("Buckets from DB match buckets from file.");
                        }
                        else
                        {
                            Assert.Failure("Buckets from DB do not match buckets from file. See above.");
                        }


                        using (StreamReader reader = new StreamReader(tempFile))
                        {
                            String line;
                            while ((line = reader.ReadLine()) != null)
                            {
                                General.Report.Debug("[XML] {0}", line);
                            }
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


            }




            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Negative : TestNode
            {
                [TestCase]
                public class ExportToShareNoWriteAccess : BucketXMLTestBase
                {

                    public override void Test()
                    {
                        String tempFile = @"\\josephfo\tempShareNoWrite\myExportFile.xml";

                        // delete the file if it already exists.
                        // if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Int32 returnValue = configNPDB.Execute();
                        if (returnValue == 0)
                        {
                            Assert.Failure("ConfigNPDB.exe does not fail as expected.");
                        }
                        else
                        {
                            reportObj.Info("ConfigNPDB.exe fails as expeced.");
                        }

                        outputReport.Info("All validation passes.");
                    }
                }

                [TestCase]
                public class ExportToReadOnlyFile : BucketXMLTestBase
                {

                    public override void Test()
                    {
                        String tempFile = @"\\josephfo\tempShare\myReadOnlyFile.xml";

                        // delete the file if it already exists.
                        // if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Int32 returnValue = configNPDB.Execute();
                        if (returnValue == 0)
                        {
                            Assert.Failure("ConfigNPDB.exe does not fail as expected.");
                        }
                        else
                        {
                            reportObj.Info("ConfigNPDB.exe fails as expeced.");
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportToNoWriteAccessFile : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = @"\\josephfo\tempShare\myNoWriteAccessFile.xml";

                        // delete the file if it already exists.
                        // if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Int32 returnValue = configNPDB.Execute();
                        if (returnValue == 0)
                        {
                            Assert.Failure("ConfigNPDB.exe does not fail as expected.");
                        }
                        else
                        {
                            reportObj.Info("ConfigNPDB.exe fails as expeced.");
                        }

                        outputReport.Info("All validation passes.");
                    }
                }

                [TestCase]
                public class ExportToDirectoryThatDoesNotExist : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        String tempFile = @"\\josephfo\tempShare\FolderDNE\myNoWriteAccessFile.xml";

                        // delete the file if it already exists.
                        // if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Int32 returnValue = configNPDB.Execute();
                        if (returnValue == 0)
                        {
                            Assert.Failure("ConfigNPDB.exe does not fail as expected.");
                        }
                        else
                        {
                            reportObj.Info("ConfigNPDB.exe fails as expeced.");
                        }

                        outputReport.Info("All validation passes.");
                    }
                }


                [TestCase]
                public class ExportToDriveThatDoesNotExist : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        // X drive should not exist.
                        String tempFile = @"X:\myExportFile.xml";

                        // delete the file if it already exists.
                        // if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Int32 returnValue = configNPDB.Execute();
                        if (returnValue == 0)
                        {
                            Assert.Failure("ConfigNPDB.exe does not fail as expected.");
                        }
                        else
                        {
                            reportObj.Info("ConfigNPDB.exe fails as expeced.");
                        }

                        outputReport.Info("All validation passes.");
                    }
                }

                [TestCase]
                public class ExportToCDRomDrive : BucketXMLTestBase
                {
                    public override void Test()
                    {
                        // Assuming E: is CDRom drive.
                        String tempFile = @"E:\myExportFile.xml";

                        // delete the file if it already exists.
                        // if (File.Exists(tempFile)) File.Delete(tempFile);

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("20");                                            // Buckets
                        configNPDB.Parameters.Add("20");                                            // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket xml export");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                              // Interface
                        configNPDB.Parameters.Add(tempFile);                                        // File Name
                        configNPDB.Parameters.Add("-title 20");                                     // TitleID
                        Int32 returnValue = configNPDB.Execute();
                        if (returnValue == 0)
                        {
                            Assert.Failure("ConfigNPDB.exe does not fail as expected.");
                        }
                        else
                        {
                            reportObj.Info("ConfigNPDB.exe fails as expeced.");
                        }

                        outputReport.Info("All validation passes.");
                    }
                }

            }


            // represents a row in the t_interface_buckets table.
            public class InterfaceBucket
            {
                private string vc_environment;
                private string vc_interface;
                private Int32 i_title_id;
                private Int32 i_bucket;
                private string vc_server;
                private string vc_next_server;
                private DateTime dt_migration_start;
                private string vc_info1;
                private string vc_info2;
                private string vc_info3;
                private string vc_info4;

                public InterfaceBucket(string Env, string Intf, Int32 TitleId, Int32 Bucket, string Server, string NextServer, DateTime MigrationStart, string Info1, string Info2, string Info3, string Info4)
                {
                    this.vc_environment = Env;
                    this.vc_interface = Intf;
                    this.i_title_id = TitleId;
                    this.i_bucket = Bucket;
                    this.vc_server = Server;
                    this.vc_next_server = NextServer;
                    this.dt_migration_start = MigrationStart;
                    this.vc_info1 = Info1;
                    this.vc_info2 = Info2;
                    this.vc_info3 = Info3;
                    this.vc_info4 = Info4;
                }

                public static Dictionary<string,InterfaceBucket> GetInterfaceBucketsFromDB(string Environment, string vcInterface, Int32 SiteId)
                {
                    Dictionary<string,InterfaceBucket> buckets = new Dictionary<string,InterfaceBucket>();
                    string cnString = "Data Source=" + General.NPDBServer + ";Initial Catalog=" + General.NPDBCatalog + ";Integrated Security=True";
                    SqlConnection cn = new SqlConnection(cnString);
                    cn.Open();
                    string qry = "select * from t_interface_buckets where vc_environment='" + Environment + "' AND vc_interface='" + vcInterface + "' AND i_title_id=" + SiteId.ToString();
                    SqlCommand cmd = new SqlCommand(qry, cn);
                    SqlDataReader dr = cmd.ExecuteReader();
                    while (dr.Read())
                    {
                        String key = (string) dr["vc_environment"] + "~" + (string) dr["vc_interface"] + "~" + ((Int32)dr["i_title_id"]).ToString() + "~" + ((Int32)dr["i_bucket"]).ToString();

                        InterfaceBucket newBucket = new InterfaceBucket(
                            (string) dr["vc_environment"],
                            (string) dr["vc_interface"],
                            (Int32) dr["i_title_id"],
                            (Int32) dr["i_bucket"],
                            (string) dr["vc_server"],
                            (string) dr["vc_next_server"],
                            (DateTime) dr["dt_migration_start"],
                            (string) dr["vc_info1"],
                            (string) dr["vc_info2"],
                            (string) dr["vc_info3"],
                            (string) dr["vc_info4"]);
                        buckets.Add(key, newBucket);
                    }
                    dr.Close();
                    cn.Close();
                    return buckets;                    
                }

                // this version of GetInterfaceBucketsFromDB does not accept a SiteID, and will return all interfaces for all siteIds.
                public static Dictionary<string, InterfaceBucket> GetInterfaceBucketsFromDB(string Environment, string vcInterface)
                {
                    Dictionary<string, InterfaceBucket> buckets = new Dictionary<string, InterfaceBucket>();
                    string cnString = "Data Source=" + General.NPDBServer + ";Initial Catalog=" + General.NPDBCatalog + ";Integrated Security=True";
                    SqlConnection cn = new SqlConnection(cnString);
                    cn.Open();
                    string qry = "select * from t_interface_buckets where vc_environment='" + Environment + "' AND vc_interface='" + vcInterface + "'";
                    SqlCommand cmd = new SqlCommand(qry, cn);
                    SqlDataReader dr = cmd.ExecuteReader();
                    while (dr.Read())
                    {
                        String key = (string)dr["vc_environment"] + "~" + (string)dr["vc_interface"] + "~" + ((Int32)dr["i_title_id"]).ToString() + "~" + ((Int32)dr["i_bucket"]).ToString();

                        InterfaceBucket newBucket = new InterfaceBucket(
                            (string)dr["vc_environment"],
                            (string)dr["vc_interface"],
                            (Int32)dr["i_title_id"],
                            (Int32)dr["i_bucket"],
                            (string)dr["vc_server"],
                            (string)dr["vc_next_server"],
                            (DateTime)dr["dt_migration_start"],
                            (string)dr["vc_info1"],
                            (string)dr["vc_info2"],
                            (string)dr["vc_info3"],
                            (string)dr["vc_info4"]);
                        buckets.Add(key, newBucket);
                    }
                    dr.Close();
                    cn.Close();
                    return buckets;
                }

                public static Dictionary<string, InterfaceBucket> GetInterfaceBucketsFromFile(string FileName)
                {
                    Dictionary<string, InterfaceBucket> buckets = new Dictionary<string, InterfaceBucket>();
                    XmlDocument xml = new XmlDocument();
                    xml.Load(FileName);

                        XmlNodeList bucketNodes = xml.SelectNodes("//bucketInsert");
                        reportObj.Info("Starting bucket insert.");
                        foreach (XmlNode bucket in bucketNodes)
                        {
                            string key = bucket.Attributes["env"].Value + "~" + bucket.Attributes["iface"].Value + "~" + bucket.Attributes["title"].Value + "~" + bucket.Attributes["bucket"].Value;
                            reportObj.Info("Key: " + key);
                            InterfaceBucket newBucket = new InterfaceBucket(
                                bucket.Attributes["env"].Value,
                                bucket.Attributes["iface"].Value,
                                Int32.Parse(bucket.Attributes["title"].Value),
                                Int32.Parse(bucket.Attributes["bucket"].Value),
                                bucket.Attributes["server"].Value,
                                bucket.Attributes["next-server"].Value,
                                DateTime.Parse(bucket.Attributes["migration"].Value),
                                bucket.Attributes["info1"].Value,
                                bucket.Attributes["info2"].Value,
                                bucket.Attributes["info3"].Value,
                                bucket.Attributes["info4"].Value);
                            buckets.Add(key, newBucket);                                
                        }
                        reportObj.Info("Ending bucket insert.");
                        return buckets;
                }

                public override bool Equals(object obj)
                {
                    if (obj == null) return false;

                    if (this.GetType() != obj.GetType()) return false;

                    InterfaceBucket intBucket = (InterfaceBucket) obj;

                    if (Object.Equals(this.vc_environment, intBucket.vc_environment))
                    {                        
                        reportObj.Info("Verified vc_environment field matches. They are both: " + intBucket.vc_environment);
                    }
                    else
                    {
                        reportObj.Error("vc_environment fields to not match.");
                        reportObj.Error("Expected: " + this.vc_environment);
                        reportObj.Error("Actual: " + intBucket.vc_environment);
                        return false;
                    }

                    if (Object.Equals(this.vc_interface, intBucket.vc_interface))
                    {
                        reportObj.Info("Verified vc_interface field matches. They are both: " + intBucket.vc_interface);
                    }
                    else
                    {
                        reportObj.Error("vc_interface fields to not match.");
                        reportObj.Error("Expected: " + this.vc_interface);
                        reportObj.Error("Actual: " + intBucket.vc_interface);
                        return false;
                    }

                    if (Object.Equals(this.i_title_id, intBucket.i_title_id))
                    {
                        reportObj.Info("Verified i_title_id; field matches. They are both: " + intBucket.i_title_id.ToString());
                    }
                    else
                    {
                        reportObj.Error("i_title_id fields to not match.");
                        reportObj.Error("Expected: " + this.i_title_id.ToString());
                        reportObj.Error("Actual: " + intBucket.i_title_id.ToString());
                        return false;
                    }

                    if (Object.Equals(this.i_bucket, intBucket.i_bucket))
                    {
                        reportObj.Info("Verified i_bucket; field matches. They are both: " + intBucket.i_bucket.ToString());
                    }
                    else
                    {
                        reportObj.Error("i_title_id fields to not match.");
                        reportObj.Error("Expected: " + this.i_bucket.ToString());
                        reportObj.Error("Actual: " + intBucket.i_bucket.ToString());
                        return false;
                    }

                    if (Object.Equals(this.vc_server, intBucket.vc_server))
                    {
                        reportObj.Info("Verified vc_server field matches. They are both: " + intBucket.vc_server);
                    }
                    else
                    {
                        reportObj.Error("vc_server fields to not match.");
                        reportObj.Error("Expected: " + this.vc_server);
                        reportObj.Error("Actual: " + intBucket.vc_server);
                        return false;
                    }

                    if (Object.Equals(this.vc_next_server, intBucket.vc_next_server))
                    {
                        reportObj.Info("Verified vc_next_server field matches. They are both: " + intBucket.vc_next_server);
                    }
                    else
                    {
                        reportObj.Error("vc_next_server fields to not match.");
                        reportObj.Error("Expected: " + this.vc_next_server);
                        reportObj.Error("Actual: " + intBucket.vc_next_server);
                        return false;
                    }

                    if (Object.Equals(this.dt_migration_start.ToString(), intBucket.dt_migration_start.ToString()))
                    {
                        reportObj.Info("Verified dt_migration_start field matches. They are both: " + intBucket.dt_migration_start.ToString());
                    }
                    else
                    {
                        reportObj.Error("dt_migration_start fields to not match.");
                        reportObj.Error("Expected: " + this.dt_migration_start.ToString());
                        reportObj.Error("Actual: " + intBucket.dt_migration_start.ToString());
                        return false;
                    }

                    if (Object.Equals(this.vc_info1, intBucket.vc_info1))
                    {
                        reportObj.Info("Verified vc_info1 field matches. They are both: " + intBucket.vc_info1);
                    }
                    else
                    {
                        reportObj.Error("vc_info1 fields to not match.");
                        reportObj.Error("Expected: " + this.vc_info1);
                        reportObj.Error("Actual: " + intBucket.vc_info1);
                        return false;
                    }

                    if (Object.Equals(this.vc_info2, intBucket.vc_info2))
                    {
                        reportObj.Info("Verified vc_info2 field matches. They are both: " + intBucket.vc_info2);
                    }
                    else
                    {
                        reportObj.Error("vc_info2 fields to not match.");
                        reportObj.Error("Expected: " + this.vc_info2);
                        reportObj.Error("Actual: " + intBucket.vc_info2);
                        return false;
                    }

                    if (Object.Equals(this.vc_info3, intBucket.vc_info3))
                    {
                        reportObj.Info("Verified vc_info3 field matches. They are both: " + intBucket.vc_info3);
                    }
                    else
                    {
                        reportObj.Error("vc_info3 fields to not match.");
                        reportObj.Error("Expected: " + this.vc_info3);
                        reportObj.Error("Actual: " + intBucket.vc_info3);
                        return false;
                    }

                    if (Object.Equals(this.vc_info4, intBucket.vc_info4))
                    {
                        reportObj.Info("Verified vc_info4 field matches. They are both: " + intBucket.vc_info4);
                    }
                    else
                    {
                        reportObj.Error("vc_info4 fields to not match.");
                        reportObj.Error("Expected: " + this.vc_info4);
                        reportObj.Error("Actual: " + intBucket.vc_info4);
                        return false;
                    }

                    return true;
                }

                public override int GetHashCode()
                {
                    return base.GetHashCode();
                }

                public static void AddInterfaceBucketToDB(InterfaceBucket IntBucket)
                {
                    string cnString = "Data Source=" + General.NPDBServer + ";Initial Catalog=" + General.NPDBCatalog + ";Integrated Security=True";
                    SqlConnection cn = new SqlConnection(cnString);
                    cn.Open();
                    string qry = "INSERT INTO t_interface_buckets (vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4) " +
                        " VALUES ('" + IntBucket.vc_environment + "','" + IntBucket.vc_interface + "'," + IntBucket.i_title_id + "," + IntBucket.i_bucket + ",'" + IntBucket.vc_server + "','" + IntBucket.vc_next_server + "','" + IntBucket.dt_migration_start + "','" + IntBucket.vc_info1 + "','" + IntBucket.vc_info2 + "','" + IntBucket.vc_info3 + "','" + IntBucket.vc_info4 + "')";

                    SqlCommand cmd = new SqlCommand(qry, cn);
                    cmd.ExecuteNonQuery();
                }

                public static bool CompareInterfaceBuckets(Dictionary<string, InterfaceBucket> source, Dictionary<string, InterfaceBucket> dest)
                {
                    if (source.Count != dest.Count)
                    {
                        reportObj.Error("Interface counts are different:");
                        reportObj.Error("Source count is: " + source.Count);
                        reportObj.Error("Dest count is: " + dest.Count);
                        return false;
                    }
                    else
                    {
                        reportObj.Info("Bucket counts match: " + dest.Count.ToString());
                    }


                    foreach (KeyValuePair<string, InterfaceBucket> bucket in source)
                    {
                        if (dest.ContainsKey(bucket.Key))
                        {
                            if (bucket.Value.Equals(dest[bucket.Key]))
                            {
                                reportObj.Info("Entire bucket matches.");
                            }
                            else
                            {                                
                                Assert.Failure("Bucket does not match.  See above.");
                            }
                            dest.Remove(bucket.Key);
                        }
                        else
                        {
                            reportObj.Error("Missing key value in destination interface bucket: " + bucket.Key);
                            return false;
                        }
                    }

                    if (dest.Count > 0)
                    {
                        reportObj.Error("There are more rows in the destination interface bucket");
                        return false;
                    }

                    reportObj.Info("Destination and Source Interface Buckets are equal.");
                    return true;
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\BucketInsert.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;

namespace ConfigNPDB
{
    public partial class ConfigNPDBFunctionalTests : TestNode
    {
        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class BucketInsertTests : TestNode
        {
            public abstract class BucketInsertTestBase : ConfigNPDBTestBase
            {
                public override void PreRun()
                {
                    General.Report.Info("Ensuring clean environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }

                public override void PostRun()
                {
                    General.Report.Info("Cleaning up environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }
            }
            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Positive : TestNode
            {
                //Standard NPDB Tests - skipped (the same logic is used for this as other bucket modes)
                //Standard Interface Tests - skipped (the same logic is used for this as other bucket modes)
                //Standard Title Tests - skipped (the same logic is used for this as other bucket modes)
                [TestCase]
                public class InsertNewServer : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Server
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment                        
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("1000");                                          // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[200]);                        // Server
                        configNPDB.Parameters.Add(General.EnvServers1[200]);                        // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", DateTime.Now)); // Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[200]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[1000].NextServer, General.EnvServers1[200],
                            "Next server is not set correctly");

                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 22, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class AddServerBucket : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("1000");                                          // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", DateTime.Now)); // Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[1000].NextServer, General.EnvServers1[0],
                            "Next server is not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 22, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class AddServerDuplicateBucket : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("10");                                          // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", DateTime.Now)); // Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[10].NextServer, General.EnvServers1[0],
                            "Next server is not set correctly");

                        Assert.Equal(configuration.Servers, 19, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class AddServerDuplicateBucketDiffTitleId : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("50");                                            // TitleID
                        configNPDB.Parameters.Add("10");                                            // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", DateTime.Now)); // Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 50);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 50), "Bucket striping is invalid"); 
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 50, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[10].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(),
                            "Next server is not set correctly");

                        Assert.Equal(configuration.Servers, 1, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 1, "Unexpected number of buckets");

                        configuration = npdb.GetBucketConfiguration(
                                General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[10]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[10].NextServer.ToUpper(), General.EnvServers1[10].ToUpper(),
                            "Next server is not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");

                    }
                }


                [TestCase]
                public class UpdateServerBucketNextServer : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[1]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", DateTime.Now)); // Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        buckets[0].NextServer = General.EnvServers1[1];

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetMigrationTimePast : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        DateTime migrateTime = DateTime.Now;
                        migrateTime = migrateTime.Subtract(new TimeSpan(5, 0, 0, 0, migrateTime.Millisecond));

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        configNPDB.Parameters.Add(String.Format("-migration \"{0}\"", migrateTime));// Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].MigrationStart.ToString(), migrateTime.ToString(), "Migration times don't match");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }


                [TestCase]
                public class SetMigrationTime : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        DateTime migrateTime = DateTime.Now;
                        migrateTime = migrateTime.Subtract(new TimeSpan(0, 0, 0, 0, migrateTime.Millisecond));

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        configNPDB.Parameters.Add(String.Format("-migration \"{0}\"", migrateTime));// Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].MigrationStart.ToString(), migrateTime.ToString(), "Migration times don't match");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetMigrationTimeFuture : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        DateTime migrateTime = DateTime.Now;
                        migrateTime = migrateTime.Subtract(new TimeSpan(-5, 0, 0, 0, migrateTime.Millisecond));

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        configNPDB.Parameters.Add(String.Format("-migration \"{0}\"", migrateTime));// Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].MigrationStart.ToString(), migrateTime.ToString(), "Migration times don't match");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }


                [TestCase]
                public class SetZonedMigrationTime : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        DateTime migrateTime = DateTime.Now;
                        migrateTime = migrateTime.Subtract(new TimeSpan(0, 0, 0, 0, migrateTime.Millisecond));
                        migrateTime = migrateTime.ToUniversalTime();

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        configNPDB.Parameters.Add(String.Format("-migration \"{0} PT\"", migrateTime));// Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].MigrationStart.ToString(), migrateTime.ToString(), "Migration times don't match");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo1 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info1 {0}", "test"));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info1, "test", "Info1 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo2 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info2 {0}", "test"));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info2, "test", "Info2 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo3 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info3 {0}", "test"));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info3, "test", "Info3 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo4 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info4 {0}", "test"));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info4, "test", "Info4 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class ClearInfo1 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info1 {0}", "\"\""));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info1, "", "Info1 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class ClearInfo2 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info2 {0}", "\"\""));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info2, "", "Info2 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class ClearInfo3 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info3 {0}", "\"\""));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info3, "", "Info3 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class ClearInfo4 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info4 {0}", "\"\""));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 4
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer, General.EnvServers1[0], "Next server changed");
                        Assert.Equal(buckets[0].Info4, "", "Info4 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
            }
            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Negative : TestNode
            {
                //Standard NPDB Tests
                //Standard Interface Tests
                //Standard Title Tests
                //Specify invalid values for info parameters
                //Attempt to use info5 & info0.
                [TestCase]
                public class SetInfo0 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info0 {0}", "test"));             // Info 0
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo5 : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info5 {0}", "test"));             // Info 0
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                //Specify a migration time value thats not a date
                [TestCase]
                public class SetGarbageMigrationTime : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        DateTime migrateTime = DateTime.Now;
                        migrateTime = migrateTime.Subtract(new TimeSpan(0, 0, 0, 0, migrateTime.Millisecond));

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        configNPDB.Parameters.Add(String.Format("-migration \"{0}\"", "PeanutButterTime"));// Migration Start Time
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                //Exceed 256 characters for info1-info4
                [TestCase]
                public class SetInfo1Long : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        String longString =
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "ExtraStuffBeyond256";
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info1 {0}", longString));         // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");
                        // Assert.Equal(buckets[0].Info1, longString, "Info1 not set correctly");  Should not equal long string.
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo2Long : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        String longString =
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "ExtraStuffBeyond256";

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info2 {0}", longString));             // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");
                        //Assert.Equal(buckets[0].Info2, longString, "Info2 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo3Long : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        String longString =
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "ExtraStuffBeyond256";

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info3 {0}", longString));         // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info4 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");
                        //Assert.Equal(buckets[0].Info3, longString, "Info3 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }

                [TestCase]
                public class SetInfo4Long : BucketInsertTestBase
                {
                    public override void Test()
                    {
                        String longString =
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF" +
                            "ExtraStuffBeyond256";

                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 20));     // Servers
                        configNPDB.Parameters.Add("21");                                            // Buckets
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");                    

                        configNPDB = new ConfigNPDB("bucket insert");
                        configNPDB.Parameters.Add(General.NPDBServer);                              // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                             // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                                // Environment
                        configNPDB.Parameters.Add(General.Interface1);                           // Interface
                        configNPDB.Parameters.Add("0");                                             // TitleID
                        configNPDB.Parameters.Add("0");                                             // Bucket
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // Server
                        configNPDB.Parameters.Add(General.EnvServers1[0]);                          // NextServer
                        //configNPDB.Parameters.Add(String.Format("-migration {0}", migrateTime));  // Migration Start Time
                        configNPDB.Parameters.Add(String.Format("-info4 {0}", longString));         // Info 1
                        //configNPDB.Parameters.Add(String.Format("-info2 {0}", ""));               // Info 2
                        //configNPDB.Parameters.Add(String.Format("-info3 {0}", ""));               // Info 3
                        //configNPDB.Parameters.Add(String.Format("-info1 {0}", ""));               // Info 4
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0), "Bucket striping is invalid");
                        Dictionary<int, Npdb.BucketInfo> buckets = npdb.GetServerBucketInfo(
                            General.EnvName1, General.Interface1, 0, General.EnvServers1[0]);
                        Assert.NotEqual(buckets.Count, 0, "Expected bucket configuration");
                        Assert.Equal(buckets[0].NextServer.ToUpper(), General.EnvServers1[0].ToUpper(), "Next server changed");
                        //Assert.Equal(buckets[0].Info4, longString, "Info4 not set correctly");

                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\ConfigNPDBFunctionalTests.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;

namespace ConfigNPDB
{
    [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
    public partial class ConfigNPDBFunctionalTests : TestNode
    {
        private Npdb _npdb = new Npdb(General.NPDBServer, General.NPDBCatalog);

        public override void OneTimeSetup()
        {
            // Cleanup first
            OneTimeCleanup();

            General.Report.Info("Creating environments");

            // Create Env
            _npdb.CreateEnvironment(General.EnvName1, General.Type);
            _npdb.CreateComponent(General.ComponentName);
            _npdb.CreateInterface(General.Interface1, General.ComponentName);
            _npdb.CreateInterface(General.Interface2, General.ComponentName);
            _npdb.CreateDomain(General.DomainName);
            _npdb.Register(General.EnvName1, General.DomainName, 1);

            // Add Servers

            General.EnvServers1 = new String[2500];
            for (int i = 0; i < 2500; i++)
            {
                if (i > 0 && i % 500 == 0)
                    General.Report.Info("Created {0} servers in {1}", i, General.EnvName1);
                String serverName = String.Format("{0}{1:x4}", General.EnvName1, i);
                _npdb.AddServer(General.EnvName1, serverName);
                _npdb.AddServerInterface(General.EnvName1, serverName, General.Interface1);
                _npdb.AddServerInterface(General.EnvName1, serverName, General.Interface2);

                General.EnvServers1[i] = serverName;
            }

            // Create Env2
            _npdb.CreateEnvironment(General.EnvName2, General.Type);
            _npdb.Register(General.EnvName2, General.DomainName, 1);
            
            // Add Servers
            General.EnvServers2 = new String[2500];
            for (int i = 0; i < 2500; i++)
            {
                if (i > 0 && i % 500 == 0)
                    General.Report.Info("Created {0} servers in {1}", i, General.EnvName2);

                String serverName = String.Format("{0}{1:x4}", General.EnvName2, i);
                _npdb.AddServer(General.EnvName2, serverName);
                _npdb.AddServerInterface(General.EnvName2, serverName, General.Interface1);
                _npdb.AddServerInterface(General.EnvName2, serverName, General.Interface2);

                General.EnvServers2[i] = serverName;
            }
            
            // Set Current Environment to SkyNet
            _npdb.SetCurrentEnvironment(General.EnvName1);
            General.Report.Info("Environment Setup Complete");
        }

        public override void OneTimeCleanup()
        {
            General.Report.Info("Cleaning Environment");
            _npdb.RemoveEnvironment(General.EnvName1);
            _npdb.RemoveEnvironment(General.EnvName2);
            _npdb.RemoveInterface(General.Interface1);
            _npdb.RemoveInterface(General.Interface2);
            _npdb.RemoveComponent(General.ComponentName);
            _npdb.RemoveDomain(General.DomainName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\BucketServerRemove.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;

namespace ConfigNPDB
{
    public partial class ConfigNPDBFunctionalTests : TestNode
    {
        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class BucketServersRemoveTests : TestNode
        {
            public abstract class BucketServersRemoveTestBase : ConfigNPDBTestBase
            {
                public override void PreRun()
                {
                    General.Report.Info("Ensuring clean environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }

                public override void PostRun()
                {
                    General.Report.Info("Cleaning up environment");
                    npdb.RemoveBuckets(General.EnvName1);
                    npdb.RemoveBuckets(General.EnvName2);
                }
            }
            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Positive : TestNode
            {
                //Delete a server which exists
                [TestCase]
                public class DeleteExistingServer : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Delete a server which does not exist
                [TestCase]
                public class DeleteNonExistingServer : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21));// Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add("DNE");                                     // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }

                //Delete a server that does exist but with a different casing
                [TestCase]
                public class DeleteExistingServerWithDifferentCase : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1).ToLower()); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Use delete on an NPDB which is not reachable.
                [TestCase]
                public class NonexistantNPDB : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21));// Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add("DNE");                                     // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Specify an NPDB hostname which is completely invalid (contains bad characters)
                [TestCase]
                public class InvalidNPDBHostname : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add("R$#Q%$#Q@");                                // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1));  // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Use an IP address for NPDB (Or a hostname -- whichever isn't in use by the rest of the tests)
                //Delete a server from an interface which does not exist.
                [TestCase]
                public class DeleteNonExistingInterface : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add("DNE");                                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1));  // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }

                //Delete a server from an environment which is not the current environment.
                [TestCase]
                public class OtherEnvironment : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                          // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName2);                            // Environment
                        configNPDB.Parameters.Add(General.Interface1);                       // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName2);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers2, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName2, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }

                //Delete a server from an environment which does not exist.
                [TestCase]
                public class NonExistantEnvironment : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add("DNE");                                      // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Check that interface and environment are case insensitive
                [TestCase]
                public class CaseAgnosticInterface : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1.ToLower());                // Environment
                        configNPDB.Parameters.Add(General.Interface1.ToLower());           // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Specify a title ID in decimal
                [TestCase]
                public class DeleteByDecTitle : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("1297285220");                               // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("1297285220");                              // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1297285220);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Specify a title ID in hexadecimal
                //BUG: Change the initialization to HEX!!!
                [TestCase]
                public class DeleteByHexTitle : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("1297285220");                               // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0x4D530064");                              // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 1297285220);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Title that overflows a 32-bit integer
                [TestCase]
                public class OverFlowTitle : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add(Int64.MaxValue.ToString());                  // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Specify a title ID for title agnostic data
                [TestCase]
                public class InvalidTitleId : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("1297285220");                               // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 21, "Expected 21 buckets");
                    }
                }
                //Increase the bucket count without changing the number of servers
                [TestCase]
                public class IncreaseBucketSameServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add("\"\"");                                     // Servers
                        configNPDB.Parameters.Add("22");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 22, "Expected 22 buckets");
                    }
                }
                //Decrease the bucket count without changing the number of servers
                [TestCase]
                public class DecreaseBucketsSameServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 10)); // Servers
                        configNPDB.Parameters.Add("30");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add("\"\"");                                     // Servers
                        configNPDB.Parameters.Add("20");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 10, "Expected 10 servers");
                        Assert.Equal(configuration.Buckets, 20, "Expected 20 buckets");
                    }
                }
                //Decreate the bucket count and remove a server
                [TestCase]
                public class DecreaseBucketsRemoveServer : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("20");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 20, "Expected 20 buckets");
                    }
                }
                //Increase the bucket count and remove a server
                [TestCase]
                public class IncreaseBucketsRemoveServer : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("22");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                        // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 20, "Expected 20 servers");
                        Assert.Equal(configuration.Buckets, 22, "Expected 22 buckets");
                    }
                }
                //Decrease the bucket count and remove multiple servers
                [TestCase]
                public class DecreaseBucketsRemoveNServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 5)); // Servers
                        configNPDB.Parameters.Add("19");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 16, "Expected 21 servers");
                        Assert.Equal(configuration.Buckets, 19, "Expected 19 buckets");
                    }
                }
                //Increase the bucket count and remove multiple servers
                [TestCase]
                public class IncreaseBucketsRemoveNServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 5)); // Servers
                        configNPDB.Parameters.Add("30");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 16, "Expected 16 servers");
                        Assert.Equal(configuration.Buckets, 30, "Expected 30 buckets");
                    }
                }
                //Remove one server (resulting in no servers remaining)
                [TestCase]
                public class RemoveLastServer : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.True(configuration == null, "Expected no bucket configuration");
                    }
                }
                //Remove many servers (resulting in no servers remaining)
                [TestCase]
                public class RemoveAllServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 40)); // Servers
                        configNPDB.Parameters.Add("40");                                        // Buckets
                        configNPDB.Parameters.Add("0");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                         // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                           // Environment
                        configNPDB.Parameters.Add(General.Interface1);                      // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 40)); // Servers
                        configNPDB.Parameters.Add("40");                                       // Buckets
                        configNPDB.Parameters.Add("");                                         // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.True(configuration == null, "Expected no bucket configuration");
                    }
                }
                //Specify a no-op statement that doesn't change the number of buckets at all
                [TestCase]
                public class NoOp : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add("\"\"");                                    // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
            }

            [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
            public class Negative : TestNode
            {
                //Specify a number of buckets which isn't actually a number
                [TestCase]
                public class InvalidNumberOfBuckets : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("NAN");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Specify a negative number of buckets
                [TestCase]
                public class NegativeBuckets : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("-21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Specify 0 buckets
                [TestCase]
                public class ZeroBuckets : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("0");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Specify fewer buckets than there are servers for
                [TestCase]
                public class LessBucketsThanServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("5");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly"); 
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Don't specify the buckets parameter.
                [TestCase]
                public class UnspecifiedBuckets : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        //configNPDB.Parameters.Add("21");                                      // Buckets
                        //configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Specify the buckets parameter but don't specify any servers
                [TestCase]
                public class NoServers : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add("\"\"");                                    // Servers
                        configNPDB.Parameters.Add("19");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Include trailing data after the title paramater
                [TestCase]
                public class TrailingTrash : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        configNPDB.Parameters.Add("Trash at the end of the line");            // Trailing TRASH!
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
                //Specify a title which is not a number
                [TestCase]
                public class InvalidTitle : BucketServersRemoveTestBase
                {
                    public override void Test()
                    {
                        ConfigNPDB configNPDB = new ConfigNPDB("bucket servers install");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 21)); // Servers
                        configNPDB.Parameters.Add("21");                                       // Buckets
                        configNPDB.Parameters.Add("0");                                       // TitleID
                        Assert.Equal(configNPDB.Execute(), 0, "ConfigNPDB should succeed");

                        configNPDB = new ConfigNPDB("bucket servers remove");
                        configNPDB.Parameters.Add(General.NPDBServer);                        // NPDB Address
                        configNPDB.Parameters.Add(General.NPDBCatalog);                       // npdb catalog
                        configNPDB.Parameters.Add(General.EnvName1);                          // Environment
                        configNPDB.Parameters.Add(General.Interface1);                     // Interface
                        configNPDB.Parameters.Add(General.GetServers(General.EnvServers1, 1)); // Servers
                        configNPDB.Parameters.Add("21");                                      // Buckets
                        configNPDB.Parameters.Add("NAN");                                       // TitleID
                        Assert.NotEqual(configNPDB.Execute(), 0, "ConfigNPDB should fail");

                        Assert.True(npdb.InterfaceBucketSanity(
                            General.EnvName1, General.Interface1, 0),
                            "Bucket striping is invalid");
                        Npdb.BucketConfiguration configuration = npdb.GetBucketConfiguration(
                            General.EnvName1, General.Interface1, 0);
                        Assert.NotNull(configuration, "Bucket configuration cleared unexpectedly");
                        Assert.Equal(configuration.Servers, 21, "Unexpected number of servers");
                        Assert.Equal(configuration.Buckets, 21, "Unexpected number of buckets");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\ConfigNPDBTestBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using System.Diagnostics;
using System.IO;

namespace ConfigNPDB
{
    public abstract class ConfigNPDBTestBase : TestNode
    {
        protected Npdb npdb = new Npdb("ansxblob", "npdb");
        protected String[] serverList = null;
        protected Report outputReport = new Report("ConfigNPDB");
        
        
        public abstract void Test();

        public override void Run()
        {
            Test();
            return TEST_RESULTS.PASSED;
        }

        public int ConfigNPDB(params String[] arguments)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "ConfNPDB.exe";
            startInfo.Arguments = String.Join(" ", arguments);
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = true;
            startInfo.RedirectStandardOutput = true;
            startInfo.RedirectStandardError = true;

            outputReport.Debug("[CMD] {0} {1}", startInfo.FileName, startInfo.Arguments);
            ProcessEx process = new ProcessEx(startInfo);
            process.OutputDataReceived += new DataReceivedEventHandler(process_OutputDataReceived);
            process.ErrorDataReceived += new DataReceivedEventHandler(process_ErrorDataReceived);
            process.EnableRaisingEvents = true;
            process.SemaphoreEnter();
            process.Start();
            process.BeginErrorReadLine();
            process.BeginOutputReadLine();
            process.SemaphoreWait();
            process.WaitForExit();

            outputReport.Debug("[RET] {0} exited with code {1}", Path.GetFileName(startInfo.FileName),
                process.ExitCode);

            return process.ExitCode;
        }

        void process_OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data == null)
            {
                (sender as ProcessEx).SemaphoreLeave();
            }
            else
            {
                outputReport.Debug("[OUT] {0}", e.Data);
            }
        }

        void process_ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data == null)
            {
                (sender as ProcessEx).SemaphoreLeave();
            }
            else
            {
                outputReport.Debug("[ERR] {0}", e.Data);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\Npdb.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;

namespace ConfigNPDB
{
    public class Npdb
    {
        protected string m_connectionstring;

        public Npdb(string server, string database)
        {
            m_connectionstring = String.Format("Data Source={0};Initial Catalog={1};Integrated Security=True", server, database);
        }

        public Npdb(string connectionstring)
        {
            this.m_connectionstring = connectionstring;
        }
        #region Basic AdHoc Query Operations
        public SqlDataReader ExecuteReader(String query, params Object[] args)
        {
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.Text;
            command.CommandText = String.Format(query, args);
            command.Connection.Open();

            try
            {
                return command.ExecuteReader(CommandBehavior.CloseConnection);
            }
            catch
            {
                command.Connection.Close();
                throw;
            }
        }

        public int ExecuteNonQuery(String query, params Object[] args)
        {
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.Text;
            command.CommandText = String.Format(query, args);
            command.Connection.Open();

            try
            {
                return command.ExecuteNonQuery();
            }
            finally
            {
                command.Connection.Close();
            }
        }

        public int ForceExecuteNonQuery(String query, params Object[] args)
        {
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.Text;
            command.CommandText = String.Format(query, args);
            command.Connection.Open();

            try
            {
                return command.ExecuteNonQuery();
            }
            catch
            {
                // Don't care
                return 0;
            }
            finally
            {
                command.Connection.Close();
            }
        }

        public object ExecuteScalar(String query, params Object[] args)
        {
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.Text;
            command.CommandText = String.Format(query, args);
            command.Connection.Open();

            try
            {
                return command.ExecuteScalar();
            }
            finally
            {
                command.Connection.Close();
            }
        }
        #endregion

        #region Environment Operations
        public void CreateEnvironment(String name, String type)
        {
            // Clear the current environment
            ExecuteNonQuery(@"update t_environments set b_current = 0");

            // Create a new environment and make it current
            ExecuteNonQuery(@"insert into t_environments(vc_environment, vc_environment_type, b_current) values ('{0}', '{1}', 1)",
                name, type);
        }

        public void SetCurrentEnvironment(String env)
        {
            // Clear the current environment
            ExecuteNonQuery(@"update t_environments set b_current = 0");

            ExecuteNonQuery(@"update t_environments set b_current = 1 where vc_environment='{0}'", env);
        }

        public void CreateComponent(String componentName)
        {
            ExecuteNonQuery(@"insert into t_components(vc_component, vc_install_unit) values ('{0}', 'NoInstallUnit')", componentName);
        }

        public void CreateInterface(String interfaceName, String componentName)
        {
            ExecuteNonQuery(@"insert into t_interfaces(vc_interface, vc_component, vc_nic_role, vc_protocol, i_port, i_timeout) values ('{0}', '{1}', 'middle_tier', 'tcp', 3000, 30000)",
                interfaceName, componentName);
        }

        public void CreateDomain(String domainName)
        {
            ExecuteNonQuery(@"insert into t_domains values ('{0}')", domainName);
        }

        public void Register(String environment, String domain, int siteId)
        {
            ExecuteNonQuery(@"insert into t_sites(vc_environment, i_site_id, vc_domain, i_authdata_version) values ('{0}', {2}, '{1}', 3)",
                environment, domain, siteId);
        }

        public void AddServer(String environment, String serverName)
        {
            ExecuteNonQuery(@"insert into t_servers(vc_environment, vc_server, i_site_id, vc_server_state) values ('{0}', '{1}', 1, 'online')",
                environment, serverName);
        }

        public void AddServerInterface(String environment, String serverName, String interfaceName)
        {
            ExecuteNonQuery(@"insert into t_server_interfaces (vc_environment, vc_server, vc_interface) values ('{0}', '{1}', '{2}')",
                environment, serverName, interfaceName);
        }

        public void AddServerAndInterface(String environment, String serverName, String interfaceName)
        {
            AddServer(environment, serverName);
            AddServerInterface(environment, serverName, interfaceName);
        }

        public void RemoveComponent(String componentName)
        {
            ForceExecuteNonQuery(@"delete from t_components where vc_component = '{0}'", componentName);
        }

        public void RemoveInterface(String interfaceName)
        {
            ForceExecuteNonQuery(@"delete from t_interfaces where vc_interface = '{0}'", interfaceName);
        }

        public void RemoveDomain(String domain)
        {
            ForceExecuteNonQuery(@"delete from t_domains where vc_domain = '{0}'", domain);
        }

        public void RemoveBuckets(String environmentName)
        {
            ForceExecuteNonQuery(@"delete from t_interface_buckets where vc_environment = '{0}'", environmentName);
        }

        public void RemoveEnvironment(String environmentName)
        {
            ForceExecuteNonQuery(@"delete from t_interface_buckets where vc_environment = '{0}'", environmentName);
            ForceExecuteNonQuery(@"delete from t_server_interfaces where vc_environment = '{0}'", environmentName);
            ForceExecuteNonQuery(@"delete from t_servers where vc_environment = '{0}'", environmentName);
            ForceExecuteNonQuery(@"delete from t_sites where vc_environment = '{0}'", environmentName);
            ForceExecuteNonQuery(@"delete from t_environments where vc_environment = '{0}'", environmentName);
        }
        #endregion

        public Boolean ValidateBuckets(String environmentName, String interfaceName, int titleId, int serverCount, int bucketCount)
        {
            using (SqlDataReader reader = ExecuteReader(
                @"SELECT i_title_id, COUNT(distinct vc_server) as i_servers, COUNT(i_bucket) as i_buckets " +
                @"from t_interface_buckets " +
                @"where vc_environment = '{0}' " +
                @"and   vc_interface = '{1}' " +
                @"and   i_title_id = {2} " +
                @"group by i_title_id ",
                environmentName, interfaceName, titleId))
            {
                if (!reader.Read())
                    return false;

                int value = 0;

                value = reader.GetInt32(0);
                if (value != titleId)
                    return false;

                value = reader.GetInt32(1);
                if (value != serverCount)
                    throw new Exception(String.Format("Expected {0} servers, got {1}.",
                        serverCount, value));

                value = reader.GetInt32(2);
                if (value != bucketCount)
                    throw new Exception(String.Format("Expected {0} buckets, got {1}.",
                        bucketCount, value));
            }
            return true;
        }

        public class BucketConfiguration
        {
            public int Servers;
            public int Buckets;
        }

        public BucketConfiguration GetBucketConfiguration(String environmentName, String interfaceName, int titleId)
        {
            using (SqlDataReader reader = ExecuteReader(
                @"SELECT i_title_id, COUNT(distinct vc_server) as i_servers, COUNT(i_bucket) as i_buckets " +
                @"from t_interface_buckets " +
                @"where vc_environment = '{0}' " +
                @"and   vc_interface = '{1}' " +
                @"and   i_title_id = {2} " +
                @"group by i_title_id ",
                environmentName, interfaceName, titleId))
            {
                if (!reader.Read())
                    return null;

                BucketConfiguration configuration = new BucketConfiguration();
                configuration.Servers = reader.GetInt32(1);
                configuration.Buckets = reader.GetInt32(2);

                return configuration;
            }
        }

        public class BucketInfo
        {
            public String Server;
            public String NextServer;
            public DateTime MigrationStart;
            public String Info1;
            public String Info2;
            public String Info3;
            public String Info4;
        }
        public BucketInfo GetBucketInfo(String environmentName, String interfaceName, int titleId, int bucketId)
        {
            using (SqlDataReader reader = ExecuteReader(
                @"SELECT i_bucket, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4 " +
                @"from t_interface_buckets " +
                @"where i_bucket = '{3}' " +
                @"and   vc_environment = '{0}' " +
                @"and   vc_interface = '{1}' " +
                @"and   i_title_id = {2} ",
                environmentName, interfaceName, titleId, bucketId))
            {
                if (reader.Read())
                {
                    BucketInfo bucketInfo = new BucketInfo();
                    bucketInfo.NextServer = reader.GetString(1);
                    bucketInfo.MigrationStart = reader.GetDateTime(2);
                    bucketInfo.Info1 = reader.GetString(3);
                    bucketInfo.Info2 = reader.GetString(4);
                    bucketInfo.Info3 = reader.GetString(5);
                    bucketInfo.Info4 = reader.GetString(6);

                    return bucketInfo;
                }
                else
                {
                    return null;
                }
            }
        }

        public Dictionary<int, BucketInfo> GetServerBucketInfo(String environmentName, String interfaceName, int titleId, String serverName)
        {
            using (SqlDataReader reader = ExecuteReader(
                @"SELECT i_bucket, vc_server, vc_next_server, dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4 " +
                @"from t_interface_buckets " +
                @"where vc_environment = '{0}' " +
                @"and   vc_interface = '{1}' " +
                @"and   i_title_id = {2} " +
                @"and   vc_server = '{3}' ",
                environmentName, interfaceName, titleId, serverName))
            {
                Dictionary<int, BucketInfo> buckets = new Dictionary<int, BucketInfo>();

                while (reader.Read())
                {
                    BucketInfo bucketInfo = new BucketInfo();
                    bucketInfo.Server = reader.GetString(1);
                    bucketInfo.NextServer = reader.GetString(2);
                    bucketInfo.MigrationStart = reader.GetDateTime(3);
                    bucketInfo.Info1 = reader.GetString(4);
                    bucketInfo.Info2 = reader.GetString(5);
                    bucketInfo.Info3 = reader.GetString(6);
                    bucketInfo.Info4 = reader.GetString(7);

                    buckets[reader.GetInt32(0)] = bucketInfo;
                }

                return buckets;
            }
	    }

        public Boolean InterfaceBucketSanity(String environmentName, String interfaceName, int titleId)
        {
            using (SqlDataReader reader = ExecuteReader(
                @"select i_bucket, i_servers " +
                @"from ( " +
                @"	select i_bucket, COUNT(vc_server) as i_servers " +
                @"	from t_interface_buckets " +
                @"	where vc_environment = '{0}' " +
                @"	and   vc_interface = '{1}' " +
                @"	and   i_title_id = {2} " +
                @"	group by i_bucket " +
                @") t_server_counts " +
                @"where t_server_counts.i_servers > 1 ",
                environmentName, interfaceName, titleId))
            {
                return !reader.Read();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\General.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;

namespace ConfigNPDB
{
    public static class General
    {
        public static String Interface1 = "testInterface1";
        public static String Interface2 = "testInterface2";
        public static String ComponentName = "testComponent";
        public static String EnvName1 = "SkyNET";
        public static String EnvName2 = "EarthNET";
        public static String DomainName = "SkyNET";
        public static String Type = "development";
        public static String NPDBServer = "ansxblob";
        public static String NPDBCatalog = "npdb";
        public static int SiteId = 1;

        public static Report Report = new Report("General");

        
        public static String[] EnvServers1;
        public static String[] EnvServers2;

        public static String GetServers(String[] serverList, int count)
        {
            return String.Join(",", serverList, 0, count);
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\ProcessEx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Threading;

namespace ConfigNPDB
{
    public class ProcessEx : Process
    {
        protected Semaphore semaphore;

        public ProcessEx(ProcessStartInfo startInfo)
        {
            StartInfo = startInfo;
        }

        public void SemaphoreEnter()
        {
            semaphore = new Semaphore(0, 2);
        }

        public void SemaphoreLeave()
        {
            semaphore.Release();
        }

        public void SemaphoreWait()
        {
            semaphore.WaitOne();
            semaphore.WaitOne();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\HelperExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace xonline.test.deployment.deploymentconsole
{
    /// <summary>
    /// Collection of private helper extension methods. These are intentionally internal, to avoid having
    /// to consider a final interface to give them.
    /// </summary>
    internal static class HelperExtensions
    {
        public static string ValueForAttributeWithLocalName(this XElement element, string name)
        {
            return element.Attributes().Where(e => e.Name.LocalName == name).First().Value;
        }

        public static IEnumerable<XElement> DescendantsWithLocalName(this XElement element, string name)
        {
            return element.Descendants().Where(e => e.Name.LocalName == name);
        }

        public static IEnumerable<XElement> DescendantsWithLocalName(this XDocument element, string name)
        {
            return element.Descendants().Where(e => e.Name.LocalName == name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\JobDescription.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.deploymentconsole
{
    /// <summary>
    /// Model object which represents a series of tasks which have been loaded from some source.
    /// </summary>
    public class JobDescription
    {
        public string Name { set; get; }
        public TaskDescription[] Tasks { set; get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\ConfigNPDBTests\ConfigNPDB\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConfigNPDB")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ConfigNPDB")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("aa023026-2974-4485-ac48-649976c08e17")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\JobController.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.test.deployment.taskmodules.common;
using System.Reflection;
using System.IO;

using System.Xml.Linq;

namespace xonline.test.deployment.deploymentconsole
{
    /// <summary>
    /// Encapsulates the loading and processing of jobs.
    /// This class is not thread-safe.
    /// </summary>
    public class JobController
    {
        /// <summary>
        /// The default location to look for TaskModules. Must be a valid path
        /// </summary>
        private const string DefaultTaskModulePath = @"bin\";
        
        private string _taskModulePath;
        private bool _hasRunAtLeastOneJob;

        /// <summary>
        /// Changes where TaskModule paths are found. This must be called before RunJob, or else an InvalidOperationException is thrown.
        /// </summary>
        public string TaskModulePath
        {
            get { return _taskModulePath; }
            set
            {
                if (_hasRunAtLeastOneJob)
                    throw new InvalidOperationException("Cannot change the path to load TaskModules from after a job has been run.");
                _taskModulePath = value;
            }
        }

        /// <summary>
        /// Called when a Job starts being processed
        /// </summary>
        public event VoidFunc<JobController, JobDescription> OnStartedExecutingJob;
        
        /// <summary>
        /// Called when an individual task starts being processed
        /// </summary>
        public event VoidFunc<JobController, TaskDescription> OnStartedExecutingTask;
        
        /// <summary>
        /// Called when an individual task finishes processing 
        /// </summary>
        public event VoidFunc<JobController, TaskDescription, TaskResult> OnFinishedExecutingTask;
        
        /// <summary>
        /// Called when an entire job finishes processing
        /// </summary>
        public event VoidFunc<JobController, JobDescription, TaskResult[]> OnFinishedExecutingJob;

        public JobController()
        {
            TaskModulePath = DefaultTaskModulePath;
        }

        /// <summary>
        /// Loads a Job from disk. This may throw exceptions from the System.IO namespace in certain
        /// error conditions
        /// </summary>
        /// <param name="pathToJobsXml">Path to the XML file describing the job in question</param>
        /// <returns>A description of the job</returns>
        public JobDescription LoadJob(string pathToJobsXml)
        {
            XDocument document = XDocument.Load(pathToJobsXml);
            JobDescription jobDescription = new JobDescription();
            jobDescription.Name = document.DescendantsWithLocalName("Job").First().ValueForAttributeWithLocalName("name");
            IEnumerable<XElement> elements = document.DescendantsWithLocalName("Task");

            List<TaskDescription> taskDescriptions = new List<TaskDescription>();

            foreach (XElement element in elements)
            {
                IEnumerable<XElement> parameterElements = element.DescendantsWithLocalName("Parameter");
                Dictionary<string, string> parameterDictionary = new Dictionary<string,string>();

                foreach (XElement parameterElement in parameterElements)
                {
                    string name = parameterElement.ValueForAttributeWithLocalName("name");
                    string value = parameterElement.ValueForAttributeWithLocalName("value");
                    parameterDictionary.Add(name, value);
                }

                taskDescriptions.Add(
                    new TaskDescription(
                        element.ValueForAttributeWithLocalName("name"),
                        parameterDictionary)
                );
            }
            jobDescription.Tasks = taskDescriptions.ToArray();
            return jobDescription;
        }

        /// <summary>
        /// Runs all of the tasks in a job. Once this is called, the TaskModulePath can no longer be changed.
        /// This method attempts to load task modules. Once this gets called, the directory at
        /// TaskModulePath must exist.
        /// </summary>
        /// <param name="jobDescription">The description of the job to run</param>
        /// <returns>An array of results, one for each task.</returns>
        public TaskResult[] RunJob(JobDescription jobDescription)
        {
            _hasRunAtLeastOneJob = true;

            if (OnStartedExecutingJob != null)
                OnStartedExecutingJob(this, jobDescription);

            LoadTaskModules();
            foreach (string taskName in jobDescription.Tasks.Select(task => task.Name)) 
                if (!HasTaskModuleWithName(taskName))
                    throw new ArgumentException(String.Format("Description refers to task {0}, which does not exist.",
                        taskName));

            List<TaskResult> taskResults = new List<TaskResult>();

            foreach (TaskDescription taskDescription in jobDescription.Tasks)
            {
                if (OnStartedExecutingTask != null)
                    OnStartedExecutingTask(this, taskDescription);

                ITaskModule taskModule = GetTaskModuleWithName(taskDescription.Name);
                
                foreach (string parameterName in taskDescription.Parameters.Keys)
                    taskModule.AddParameter(parameterName, taskDescription.Parameters[parameterName]);

                TaskResult result;
                try
                {
                    result = taskModule.Perform();
                }

                catch (Exception e)
                {
                    result = new TaskResult();
                    result.Logs = new Log[] { new Log(taskDescription.Name,null, e.ToString()) };
                    result.ExecutedSuccessfully = false;
                }
                taskResults.Add(result);

                if (OnFinishedExecutingTask != null)
                    OnFinishedExecutingTask(this, taskDescription, result);
            }

            if (OnFinishedExecutingJob != null)
                OnFinishedExecutingJob(this, jobDescription, taskResults.ToArray());

            return taskResults.ToArray();
        }

        private ITaskModule GetTaskModuleWithName(string name)
        {
                return (ITaskModule)Activator.CreateInstance(TaskModules[name]);
        }

        private bool HasTaskModuleWithName(string name)
        {
            return TaskModules.ContainsKey(name);
        }

        private void LoadTaskModules()
        {
            DirectoryInfo info = new DirectoryInfo(Path.GetFullPath(TaskModulePath));
            Dictionary<string, Type> taskModuleMap = new Dictionary<string, Type>();
            foreach (FileInfo fileInfo in info.GetFiles().Where(file => file.Extension == ".dll"))
            {
                Assembly loadedAssembly = Assembly.LoadFile(fileInfo.FullName);
                foreach (Type type in loadedAssembly.GetExportedTypes())
                {
                    object[] attributes = type.GetCustomAttributes(typeof(DeploymentTaskModuleAttribute), false);
                    if (attributes.Length != 0)
                        taskModuleMap.Add(((DeploymentTaskModuleAttribute)attributes[0]).Name, type);
                }
            }
            TaskModules = taskModuleMap;
        }

        /// <summary>
        /// A mapping from TaskModule names to their respective types.
        /// </summary>
        private Dictionary<string, Type> TaskModules { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\VoidFunc.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.deploymentconsole
{
    //Void equivalents for the .NET 3.5 Func type.
    public delegate void VoidFunc<T0, T1, T2>(T0 arg0, T1 arg1, T2 arg2);
    public delegate void VoidFunc<T0, T1>(T0 arg0, T1 arg1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\TaskDescription.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.deploymentconsole
{
    /// <summary>
    /// Model object representing a task which should be run
    /// </summary>
    public class TaskDescription
    {
        /// <summary>
        /// The name of the TaskModule to run
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// A list of parameters used to configure the task module
        /// </summary>
        public Dictionary<string, string> Parameters { get; set; }

        /// <summary>
        /// Creates a new task description
        /// </summary>
        /// <param name="name">The name of the TaskModule to run</param>
        /// <param name="parameters">A list of parameters used to configure the task module</param>
        public TaskDescription(string name, Dictionary<string, string> parameters)
        {
            Name = name;
            Parameters = parameters;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\LogController.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using xonline.test.deployment.taskmodules.common;

namespace xonline.test.deployment.deploymentconsole
{
    /// <summary>
    /// General purpose logger which takes results from individual tasks and writes them out
    /// to disk.
    /// </summary>
    public class LogController
    {
        /// <summary>
        /// The location where log files should be placed. If this directory does not exist, it will be created.
        /// </summary>
        public String BaseLocation
        {
            private set;
            get;
        }
        
        private string _baseDirectoryFullPath;
        
        /// <summary>
        /// Gets incremented once every time logs from a result are written to disk. This is used
        /// to distinguish directories between tasks with the same name and to provide context regarding ordering.
        /// </summary>
        private uint _logNumber;

        /// <summary>
        /// Creates a new log controller.
        /// </summary>
        /// <param name="path">Path where this collection of logs should be written to.</param>
        /// <param name="logName">
        /// The name of the log file. This parameter need not be unique.
        /// This value will be used to generate a unique location to store files.
        /// </param>
        public LogController(string path, string logName)
        {
            BaseLocation = path;
            _baseDirectoryFullPath = Path.Combine(BaseLocation, logName + " - " + ReplaceInvalidFilenameCharacters(DateTime.Now.ToString()));
            _logNumber = 1;
        }

        /// <summary>
        /// Write all of the logs to disk for a given result. Note that the behavior for instances of LogFile that
        /// wrap on disk logs is undefined; this method does nothing currently, but this is subject to change.
        /// 
        /// Calling this method also triggers the creation of a parent folder for all logs created by this instance.
        /// </summary>
        /// <param name="logName">
        /// The name that these logs will be placed under. This name need not be unique. This method
        /// will use this name to generate a unique location to store the logs
        /// </param>
        /// <param name="result">A result object holding a collection of logs to store</param>
        /// <returns>The location where the logs were written to.</returns>
        public string WriteLogsForResult(string logName, TaskResult result)
        {
            string folderPath = Path.Combine(_baseDirectoryFullPath,
                ReplaceInvalidFilenameCharacters(_logNumber + " - " + logName));
            Directory.CreateDirectory(folderPath);

            foreach (Log logs in result.Logs)
            {
                if (logs.Path == null)
                {
                    using (BinaryWriter writer = new BinaryWriter(
                        File.Open(Path.Combine(folderPath, logs.FileName), FileMode.OpenOrCreate),
                        Encoding.UTF8))
                    {
                        // Leaks the stream
                        writer.Write(logs.Text);
                    }
                }
            }

            return folderPath;
        }

        private string ReplaceInvalidFilenameCharacters(string originalFilename)
        {
            foreach (char illegalCharacter in Path.GetInvalidFileNameChars())
            {
                originalFilename = originalFilename.Replace(illegalCharacter, '-');
            }
            return originalFilename;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using xonline.test.deployment.taskmodules.common;
using xonline.common.tools.console;

namespace xonline.test.deployment.deploymentconsole
{
    class Program
    {
        static LogController LogController;
        static void Main(string[] args)
        {
            ProgramParams programParams;

            if (!ArgReflector.Parse(out programParams, args))
            {
                ArgReflector.DisplayUsage(out programParams);
                Environment.Exit(1);
            }

            JobController controller = new JobController();
            if (programParams.TaskModulePath.IsSet)
                controller.TaskModulePath = programParams.TaskModulePath.Value;
            Console.WriteLine("Loading Job " + programParams.JobFilePath.Value);
            JobDescription jobDescription = controller.LoadJob(programParams.JobFilePath.Value);
            LogController = new LogController(programParams.LoggingPath.Value, jobDescription.Name);
            controller.OnStartedExecutingTask += LogStartedTask;
            controller.OnStartedExecutingJob += LogStartedJob;
            controller.OnFinishedExecutingTask += LogFinishedTask;
            controller.OnFinishedExecutingJob += LogFinishedJob;

            controller.OnFinishedExecutingTask += FinishedExecutingTask;
            controller.RunJob(jobDescription);
        }
        public static void LogStartedTask(JobController jobController, TaskDescription description)
        {
            Console.WriteLine("Started Processing Task {0}", description.Name);
        }

        public static void LogFinishedTask(JobController jobController, TaskDescription description, TaskResult result)
        {
            Console.WriteLine("Finished Processing Task {0}", description.Name);
        }

        public static void LogStartedJob(JobController controller, JobDescription description)
        {
            Console.WriteLine("Started Processing Job {0}", description.Name);
        }

        public static void LogFinishedJob(JobController controller, JobDescription description, TaskResult[] result)
        {
            Console.WriteLine("Finished Processing Job {0}", description.Name);
        }

        public static void FinishedExecutingTask(JobController jobController, TaskDescription description, TaskResult result) {
            LogController.WriteLogsForResult(description.Name, result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentTestVerifier\OctopusProcess.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace TestApplication
{
    public enum OctopusPendingRebootOperation
    {
        Ignore, Error, Reboot
    }

    public enum OctopusInstallationType
    {
        Install, Uninstall
    }

    class OctopusProcess
    {
        public bool UseFakeAgent;
        public bool UseVerboseMsiLogging;
        public string Password;
        public string PathToLogLocationFile;
        public string PathToConfigurationFile;
        public OctopusPendingRebootOperation PendingRebootOperation = OctopusPendingRebootOperation.Ignore;
        public OctopusInstallationType InstallationType = OctopusInstallationType.Install;

        public void Run()
        {
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.Append("-");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusInstallationType), InstallationType));
            argumentListBuilder.Append(" ");
            argumentListBuilder.Append("-onpendingrebootoperation ");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusPendingRebootOperation), PendingRebootOperation));
            argumentListBuilder.Append(" ");
            if (UseFakeAgent)
                argumentListBuilder.Append("-fakeAgent");
            else
                argumentListBuilder.Append("-adminpassword " + Password);
            argumentListBuilder.Append(" ");

            if (PathToConfigurationFile != null)
                argumentListBuilder.Append(String.Format("-config \"{0}\"", PathToConfigurationFile));
            argumentListBuilder.Append(" ");

            if (PathToLogLocationFile != null)
                argumentListBuilder.Append(String.Format("-recordlogfolderin \"{0}\"", PathToLogLocationFile));
            argumentListBuilder.Append(" ");

            if (UseVerboseMsiLogging)
                argumentListBuilder.Append("-verbosemsilogging");
            argumentListBuilder.Append(" ");


            ProcessStartInfo processStartInfo = new ProcessStartInfo(
    "octopuscli.exe", argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;

            Process octopus = Process.Start(processStartInfo);
            octopus.WaitForExit();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentConsole\ProgramParams.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.tools.console;

namespace xonline.test.deployment.deploymentconsole
{
    /// <summary>
    /// A class represeting command line arguments
    /// </summary>
    [ApplicationName("JobRunner")]
    [ApplicationDescription("Job runner runs a sequence of tasks in order and logs the results")]
    public class ProgramParams : CommandLineDefinition
    {
        [ParameterDescription("The path to the XML file which describes the job to run")]
        [ParameterRequired]
        public NamedParameter<string> JobFilePath;

        [ParameterDescription("The path that TaskModule assemblies should be loaded from.")]
        [ParameterOptional]
        public NamedParameter<string> TaskModulePath;

        [ParameterDescription("The path to place log files")]
        [ParameterRequired]
        public NamedParameter<string> LoggingPath;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\DataBases.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.HealthCheckVerifier
{
    public class DataBase
    {
        private string errorDetails = "No error";
        private string name;
        private HealthStatus healthStatus;

        public string ErrorDetails
        {
            get { return errorDetails; }
            set { errorDetails = value; }
        }

        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public HealthStatus HealthStatus
        {
            get { return healthStatus; }
            set { healthStatus = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\CheckResult.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// </summary>
    public class CheckResult
    {
        private string url;
        private HealthCheckVerifier healthCheck;

        /// <summary>
        /// prints the healthresult's url, healthstatus and\or return error messages
        /// </summary>
        public void Print()
        {
            CheckResultManager checkResult = new CheckResultManager();
            if (healthCheck.HealthStatus.Equals(HealthStatus.Fail)) // && !checkResult.ShowErrorMessage)
            {
                Console.WriteLine(String.Format("{0}: {1}", this.url, healthCheck.HealthStatus));

                foreach (HealthReport healthReport in healthCheck.HealthReports)
                {
                    if (healthReport.HealthStatus == HealthStatus.Red)
                    {
                        Console.WriteLine("Name: " + healthReport.Name);
                        Console.WriteLine("Error: " + healthReport.Error);
                    }
                }
            }
            else
            {
                Console.WriteLine(String.Format("{0}: {1}", this.url, healthCheck.HealthStatus));
            }
            Console.WriteLine();
        }

        public HealthCheckVerifier HealthCheck
        {
            get { return healthCheck; }
            set { healthCheck = value; }
        }

        public HealthStatus HealthStatus
        {
            get { return HealthCheck.HealthStatus; }
            set { HealthCheck.HealthStatus = value; }
        }

        public string Url
        {
            get { return url; }
            set { url = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentTestVerifier\TestResults.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace TestApplication
{
    public enum TestRunResult
    {
        NotRun, Passed, Failed
    }

    public class TestResults
    {
        private List<Uri> _negativeUris;
        private List<string> _passingUrls;
        private List<string> _failingUrls;
        private TestRunResult _installResult;
        private TestRunResult _uninstallResult;
        private TestRunResult _reinstallResult;
        private TestRunResult _healthCheckResult;
        private TestRunResult _liveBvtsResult;


        public string[] PassingHealthChecks
        {
            get
            {
                return _passingUrls.ToArray();
            }
        }
        public string[] FailingHealthChecks
        {
            get
            {
                return _failingUrls.ToArray();
            }
        }

        // real results
        public TestRunResult Install
        {
            set { _installResult = value; }
            get { return _installResult; }
        }
        public TestRunResult Uninstall
        {
            set { _uninstallResult = value; }
            get { return _uninstallResult; }
        }
        public TestRunResult Reinstall
        {
            set { _reinstallResult = value; }
            get { return _reinstallResult; }
        }
        public TestRunResult HealthChecks
        {
            get
            {
                if (DeploymentCycle == TestRunResult.Failed)
                    return TestRunResult.NotRun;
                else
                    return _healthCheckResult;
            }
            set
            {
                _healthCheckResult = value;
            }
        }
        public TestRunResult LiveBvts
        {
            set { _liveBvtsResult = value; }
            get { return _liveBvtsResult; }
        }

        // synthetic results
        public TestRunResult DeploymentCycle
        {
            get
            {
                if (Install == TestRunResult.Passed && Uninstall == TestRunResult.Passed && Reinstall == TestRunResult.Passed)
                    return TestRunResult.Passed;
                else if (Install == TestRunResult.NotRun && Uninstall == TestRunResult.NotRun && Reinstall == TestRunResult.NotRun)
                    return TestRunResult.NotRun;
                else
                    return TestRunResult.Failed;
            }
        }
        public TestRunResult OverallResult
        {
            get
            {
                if (AllResultsAreEqualTo(TestRunResult.Passed))
                    return TestRunResult.Passed;
                else if (AllResultsAreEqualTo(TestRunResult.NotRun))
                    return TestRunResult.NotRun;
                else
                    return TestRunResult.Failed;
            }
        }

        public TestResults()
        {
            Install = TestRunResult.NotRun;
            Uninstall = TestRunResult.NotRun;
            Reinstall = TestRunResult.NotRun;
            HealthChecks = TestRunResult.NotRun;
            LiveBvts = TestRunResult.NotRun;

            _negativeUris = new List<Uri>();
            _failingUrls = new List<string>();
            _passingUrls = new List<string>();

            PopulateExpectedHealthCheckOutcomes();
        }

        private bool AllResultsAreEqualTo(TestRunResult result)
        {
            return (Install == result && Uninstall == result && Reinstall == result &&
                HealthChecks == result && LiveBvts == result);
        }

        public void AddPassingUrl(string url)
        {
            UriBuilder uriBuilder = new UriBuilder(url);
            uriBuilder.Host = "localhost";

            if (_negativeUris.Contains(uriBuilder.Uri))
            {
                HealthChecks = TestRunResult.Failed;
                _failingUrls.Add(url + " [Should Be Blocked]");
            }
            else
            {
                if (HealthChecks == TestRunResult.NotRun)
                    HealthChecks = TestRunResult.Passed;
                _passingUrls.Add(url);
            }
        }

        public void AddFailingUrl(string url, string responseCode)
        {
            UriBuilder uriBuilder = new UriBuilder(url);
            uriBuilder.Host = "localhost";

            if (_negativeUris.Contains(uriBuilder.Uri))
            {
                if (HealthChecks == TestRunResult.NotRun)
                    HealthChecks = TestRunResult.Passed;
                _passingUrls.Add(url + " [Blocked]");
            }
            else
            {
                HealthChecks = TestRunResult.Failed;
                _failingUrls.Add(String.Format("{0} [{1}]", url, responseCode));
            }
        }

        private void PopulateExpectedHealthCheckOutcomes()
        {
            _negativeUris.Add(new Uri("http://localhost:10180/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:10190/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:11180/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:11190/xpnfront/health.ashx"));
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\ExpectedHealthCheckResult.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// Represents the ExpectedHealthCheckResult nodes in Config.xml
    /// </summary>
    public class ExpectedHealthCheckResult
    {
        private string url;
        private HealthStatus healthStatus;
        private Hashtable expectedHealthReports;

        public ExpectedHealthCheckResult()
        {
            expectedHealthReports = new Hashtable();
        }

        public Hashtable ExpectedHealthReports
        {
            get { return expectedHealthReports; }
            set { expectedHealthReports = value; }
        }

        public string Url
        {
            get { return url; }
            set { url = value; }
        }

        public HealthStatus HealthStatus
        {
            get { return healthStatus; }
            set { healthStatus = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentTestVerifier\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConsoleApplication1")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("ConsoleApplication1")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("564835e8-ff8c-4296-8833-be4f2315bcbb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\ExpectedHealthReport.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// Represents the ExpectedHealthReport nodes in Config.xml
    /// </summary>
    public class ExpectedHealthReport
    {
        private string name;
        private HealthStatus healthStatus;

        public HealthStatus HealthStatus
        {
            get { return healthStatus; }
            set { healthStatus = value; }
        }

        public string Name
        {
            get { return name; }
            set { name = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\CheckResultManager.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;


namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    ///This class reads the XML, parse it and provides a list of CheckResult objects, which we can loop through,
    /// access each object and determine
    /// if the HealthStatus if passed or failed and the corresponding errors associated with the failures
    /// </summary>
    public class CheckResultManager
    {
        XmlDocument doc2;
        private List<CheckResult> checkResults = new List<CheckResult>();
        private StringBuilder errorsToBeLogged = new StringBuilder();

        public void LoadXmlAndPopulateData(string inputXmlPath, string configXmlPath)
        {

            checkResults = new List<CheckResult>();
            XmlDocument doc = new XmlDocument();
            doc.Load(inputXmlPath);

            // Read the configXml into an expectedResultsObject
            //
            ExpectedResultObject expectedResultObject = Utilities.ParseExpectedResultsXML(configXmlPath);

            //getting all checkResults
            //
            XmlNodeList checkResultChildNodes = doc.GetElementsByTagName("CheckResult");

            // For each checkResult node, 
            //
            foreach (XmlNode checkResult in checkResultChildNodes)
            {
                // create an object of CheckResult
                //
                CheckResult checkResultObject = new CheckResult();

                // get all child nodes of check result
                //
                XmlNodeList checkResultChildren = checkResult.ChildNodes;
                XmlNode url = null;
                XmlNode response = null;
                foreach (XmlNode xmlnode in checkResultChildren)
                {
                    if (xmlnode.Name == "Url")
                    {
                        url = xmlnode;
                        checkResultObject.Url = url.InnerText;
                    }
                    if (xmlnode.Name == "Response")
                        response = xmlnode;
                }

                if (url == null)
                {
                    checkResultObject.HealthCheck = new HealthCheckVerifier();
                    checkResultObject.HealthCheck.HealthStatus = HealthStatus.NoUrl;
                    goto Found;
                }

                if (response != null && (!response.Attributes["httpResponseCode"].InnerXml.Equals("OK")))
                {
                    checkResultObject.HealthCheck = new HealthCheckVerifier();

                    if (expectedResultObject.BlockedHealthCheckUrls.Contains(checkResultObject.Url))
                    {
                        checkResultObject.HealthCheck.HealthStatus = HealthStatus.Pass;
                        goto Found;
                    }
                    else
                    {
                        checkResultObject.HealthCheck.HealthStatus = HealthStatus.Fail;
                        AppendError(checkResultObject);
                        goto Found;
                    }
                }

                XmlNode reponseText = null;

                foreach (XmlNode xmlnode in response.ChildNodes)
                {
                    if (xmlnode.Name == "ResponseText")
                        reponseText = xmlnode;
                }

                string responseTextXml = "";
                if (reponseText != null)
                {
                    responseTextXml = reponseText.InnerText;
                }
                else
                {
                    checkResultObject.HealthCheck = new HealthCheckVerifier();
                    checkResultObject.HealthCheck.HealthStatus = HealthStatus.NoResponseText;
                    goto Found;
                }
                if (!(responseTextXml.Contains("?xml version=\"1.0\" encoding=\"utf-8\"?")))
                {
                    checkResultObject.HealthCheck = new HealthCheckVerifier();
                    checkResultObject.HealthCheck.HealthStatus = HealthStatus.Pass;
                    goto Found;
                }

                doc2 = new XmlDocument();
                doc2.LoadXml(responseTextXml);

                XmlNode healthCheckNode = doc2.GetElementsByTagName("Healthcheck")[0];
                HealthCheckVerifier healthCheckObject = new HealthCheckVerifier();

                // httpResponseCode is ok and if healthCheck is not null
                //
                if (healthCheckNode != null)
                {
                    healthCheckObject.Name = healthCheckNode.Attributes["Name"].InnerXml;
                    healthCheckObject.HealthStatus = Utilities.SetHealthStatus(healthCheckNode.Attributes["HealthStatus"].InnerXml);
                    checkResultObject.HealthCheck = healthCheckObject;

                    if (healthCheckObject.HealthStatus.ToString().Equals("Green"))
                    {
                        // If we got Green but were expecting it to be blocked then xrlscan failed
                        if (expectedResultObject.BlockedHealthCheckUrls.Contains(checkResultObject.Url))
                        {
                            checkResultObject.HealthStatus = HealthStatus.Fail;
                            AppendError(checkResultObject);
                        }
                        else
                        {
                            checkResultObject.HealthStatus = HealthStatus.Pass;
                        }
                    }
                    else
                    {
                        //pass to the PopulateHealthReport reportChildNodes and the checkResultObject(CheckResult)
                        //
                        PopulateHealthReport(healthCheckNode, checkResultObject);

                        if (expectedResultObject.ExpectedHealthCheckResults.Contains(url.InnerXml))
                        {
                            ExpectedHealthCheckResult expectedHealthCheckResult = (ExpectedHealthCheckResult)expectedResultObject.ExpectedHealthCheckResults[url.InnerXml];

                            if (checkResultObject.HealthCheck.HealthStatus.Equals(expectedHealthCheckResult.HealthStatus)
                                || (checkResultObject.HealthCheck.HealthStatus.Equals(HealthStatus.Yellow) &&
                                expectedHealthCheckResult.HealthStatus.Equals(HealthStatus.Red)))
                            {

                                List<HealthReport> healthReports = checkResultObject.HealthCheck.HealthReports;

                                foreach (HealthReport healthReport in healthReports)
                                {
                                    if (healthReport.HealthStatus.Equals(HealthStatus.Red) || healthReport.HealthStatus.Equals(HealthStatus.Yellow))
                                    {
                                        //check the configxml has the healthReport name of hecalthcheck.xml
                                        if (expectedHealthCheckResult.ExpectedHealthReports.Contains(healthReport.Name))
                                        {
                                            ExpectedHealthReport expectedHealthReport = (ExpectedHealthReport)expectedHealthCheckResult.ExpectedHealthReports[healthReport.Name];

                                            if ((healthReport.HealthStatus.Equals(expectedHealthReport.HealthStatus)
                                             || (healthReport.HealthStatus.Equals(HealthStatus.Yellow) &&
                                                expectedHealthReport.HealthStatus.Equals(HealthStatus.Red))))
                                            {
                                                checkResultObject.HealthCheck.HealthStatus = HealthStatus.Pass;
                                            }
                                            else
                                            {
                                                healthReport.HealthStatusMatchedExpectedValue = false;
                                                checkResultObject.HealthCheck.HealthStatus = HealthStatus.Fail;
                                                AppendError(checkResultObject);
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            checkResultObject.HealthCheck.HealthStatus = HealthStatus.Fail;
                                            AppendError(checkResultObject);
                                            break;
                                        }
                                    }
                                }//end of foreach loop
                            }
                            else
                            {
                                checkResultObject.HealthCheck.HealthStatus = HealthStatus.Fail;
                                AppendError(checkResultObject);

                            }
                        }//end of if statement that checks the url is in the config.xml 

                        else
                        {
                            checkResultObject.HealthCheck.HealthStatus = HealthStatus.Fail;
                            AppendError(checkResultObject);
                        }

                    } //end of else statement that come if the healthstatus red or yellows 

                }//end of if statement that checks if healthcheck is not null

            // Adds checkResultObject to list of checkResults to be returned
            //
            Found:
                checkResults.Add(checkResultObject);

            }// End of foreach loop

        }

        /// <summary>
        /// Sets detailed information on the healthReport object if its healthStatus equals Red or yellow
        /// </summary>
        /// <param name="healthReportObject"></param>
        /// <param name="healthReport"></param>
        private void SetHealthReportDetailedInfo(HealthReport healthReportObject, XmlNode healthReport)
        {
            healthReportObject.FullName = healthReport.ChildNodes[0].InnerXml;
            if (healthReport.ChildNodes[4] != null && healthReport.ChildNodes[4].Name.Equals("ErrorDetails"))
            {
                healthReportObject.Error = healthReport.ChildNodes[4].InnerXml;
            }
        }
        /// <summary>
        /// to get each healthReport info and Database info
        /// </summary>
        /// <param name="healthCheck"></param>
        /// <param name="checkResultObject"></param>

        private void PopulateHealthReport(XmlNode healthCheckNode, CheckResult checkResultObject)
        {
            try
            {
                // For each healthReport node, create the corresponding healthReportObject and populate with the required info
                //
                XmlNodeList healthReports = healthCheckNode.ChildNodes[1].ChildNodes;

                foreach (XmlNode healthReport in healthReports)
                {
                    HealthReport healthReportObject = new HealthReport();
                    healthReportObject.Name = healthReport.Attributes["Name"].InnerXml;
                    healthReportObject.HealthStatus = Utilities.SetHealthStatus(healthReport.Attributes["HealthStatus"].InnerXml);

                    //if the status is red and the name is Databaseinfo, get all the dataBasebInfo 
                    //
                    if ((healthReportObject.HealthStatus.Equals(HealthStatus.Red) || healthReportObject.HealthStatus.Equals(HealthStatus.Yellow))
                        && healthReportObject.Name.Equals("DatabaseInfo"))
                    {
                        XmlNodeList dataBasebInfo = healthReport.ChildNodes[4].ChildNodes[0].ChildNodes;
                        DataBase dataBaseObject;
                        // For each dbReport node to get the error details
                        //
                        foreach (XmlNode dbReport in dataBasebInfo)  // For each dbReport node
                        {
                            dataBaseObject = new DataBase();
                            dataBaseObject.Name = dbReport.Attributes["Name"].InnerXml;
                            dataBaseObject.HealthStatus = Utilities.SetHealthStatus(dbReport.Attributes["HealthStatus"].InnerXml);

                            if (dbReport.ChildNodes[4] != null && dbReport.ChildNodes[4].Name.Equals("ErrorDetails"))
                            {
                                dataBaseObject.ErrorDetails = dbReport.ChildNodes[4].InnerXml;
                            }

                            // Adds each databaseObject to a list of databaseObjects in healthReportObject
                            //
                            healthReportObject.DataBases.Add(dataBaseObject);
                        }
                    }
                    else if ((healthReportObject.HealthStatus.Equals(HealthStatus.Red) || (healthReportObject.HealthStatus.Equals(HealthStatus.Yellow))))
                    {
                        SetHealthReportDetailedInfo(healthReportObject, healthReport); //call the method
                    }

                    checkResultObject.HealthCheck.HealthReports.Add(healthReportObject);
                }

            }
            catch (Exception ex)
            {
                errorsToBeLogged.AppendLine("Error Found:.. because Reports is not a second child of HealthCheck");
                errorsToBeLogged.AppendLine(ex.Message);
            }
        }


        public void PrintResults()
        {
            foreach (CheckResult checkResult in checkResults)
            {

                checkResult.Print();
            }

        }

        private void AppendError(CheckResult checkResult)
        {

            errorsToBeLogged.AppendLine("============================================================================================================");
            errorsToBeLogged.AppendLine("Info:\t" + string.Format("{0} ---- {1}", checkResult.Url, checkResult.HealthStatus));

            if (checkResult.HealthCheck.Name != null)
            {
                errorsToBeLogged.AppendLine(string.Format("{0}   {1}", "Health Check Name:", checkResult.HealthCheck.Name));
                errorsToBeLogged.AppendLine("------------------------------------------------------------------------------------------------------------");
                string healthReportError = checkResult.HealthCheck.HealthReportErrors();
                errorsToBeLogged.AppendLine(healthReportError);
            }
        }
        public StringBuilder ErrorsToBeLogged
        {
            get { return errorsToBeLogged; }
            set { errorsToBeLogged = value; }
        }

        public List<CheckResult> CheckResults
        {
            get { return checkResults; }
            set { checkResults = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\ExpectedResultObject.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// Represents the ExpectedResult nodes in Config.xml
    /// </summary>
	public class ExpectedResultObject
	{
		private Hashtable expectedHealthCheckResults; 
		private List<String> blockedHealthCheckUrls;

        public ExpectedResultObject()
        {
            expectedHealthCheckResults = new Hashtable();
            blockedHealthCheckUrls = new List<string>();
        }

		public List<String> BlockedHealthCheckUrls
		{
			get { return blockedHealthCheckUrls; }
			set { blockedHealthCheckUrls = value; }
		}		

		public Hashtable ExpectedHealthCheckResults
		{
			get { return expectedHealthCheckResults; }
		}

		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\HealthReport.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// Represents the HealthReport nodes in the HealthChecks.xml
    /// </summary>
    public class HealthReport
    {
        private string fullName;
        private string error;
        private string name;
        private HealthStatus healthStatus;
        private List<DataBase> dataBases = new List<DataBase>();
        private bool healthStatusMatchedExpectedValue = true;


        public bool HealthStatusMatchedExpectedValue
        {
            get { return healthStatusMatchedExpectedValue; }
            set { healthStatusMatchedExpectedValue = value; }
        }

        public string DataBaseErrors() 
        {
            StringBuilder errors = new StringBuilder();
            foreach (DataBase dataBaseReport in dataBases)
            {
                if (dataBaseReport.HealthStatus == HealthStatus.Red)
                {
                    errors.AppendLine("\t" + dataBaseReport.Name);
                    errors.AppendLine("\t" + dataBaseReport.ErrorDetails);
                    errors.AppendLine(" ");
                }
            }
            return errors.ToString();

        }
        public string FullName
        {
            get { return fullName; }
            set { fullName = value; }
        }
        public string Error
        {
            get { return error; }
            set { error = value; }
        }
        public string Name
        {
            get { return name; }
            set { name = value; }
        }
        public HealthStatus HealthStatus
        {
            get { return healthStatus; }
            set { healthStatus = value; }
        }
        public List<DataBase> DataBases
        {
            get { return dataBases; }
            set { dataBases = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\HealthCheck.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// Represents the HealthCheck node in the HealthChecks.xml
    /// </summary>
    public class HealthCheckVerifier
    {
        private string name;
        private HealthStatus healthStatus;
        private List<HealthReport> healthReports = new List<HealthReport>();

        public string HealthReportErrors()
        {
            StringBuilder errors = new StringBuilder();
            foreach (HealthReport healthReport in healthReports)
            {
                if (!healthReport.HealthStatusMatchedExpectedValue)
                {
                    if (healthReport.Name.Equals("DatabaseInfo"))
                    {
                        errors.AppendLine("Health Report Database:");
                        string dbStr = healthReport.DataBaseErrors(); 
                        errors.AppendLine("\t" + dbStr);
                    }
                    else
                    {
                        errors.AppendLine("Health Report:");
                        errors.AppendLine("\t" + healthReport.Name);
                        errors.AppendLine("ERROR:");
                        errors.AppendLine("\t" + healthReport.Error);
                        errors.AppendLine(" ");
                    }
                }
            }

            return errors.ToString();
        }

        public List<HealthReport> HealthReports
        {
            get { return healthReports; }
            set { healthReports = value; }
        }

        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public HealthStatus HealthStatus
        {
            get { return healthStatus; }
            set { healthStatus = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\Utilities.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace xonline.test.deployment.HealthCheckVerifier
{
    /// <summary>
    /// Author Tigist Ejigu
    /// July 10, 2008
    /// </summary>
    public enum HealthStatus
	{
        Green, Red, Yellow, Pass, Fail, NoHealthCheckReports, NoResponseText, NoUrl
	};

	public class Utilities
	{
        /// <summary>
        /// to parse the config file
        /// </summary>
        /// <param name="xmlPath"></param>
        /// <returns>ExpRsltObject</returns>
		public static ExpectedResultObject ParseExpectedResultsXML(string xmlPath)
		{
            ExpectedResultObject expectedResultObject = new ExpectedResultObject();

			// Load config xml file
			//
			XmlDocument doc = new XmlDocument();
			doc.Load(xmlPath);

			XmlNodeList expectedHealthCheckResults = doc.GetElementsByTagName("ExpectedHealthCheckResult");
			XmlNodeList blockedHealthChecks = doc.GetElementsByTagName("BlockedHealthCheck");

            //for each ExpectedHealthCheckResults node
            //
			foreach (XmlNode expectedHealthCheckResult in expectedHealthCheckResults)
			{
				ExpectedHealthCheckResult expectedHealthCheckResultObject = new ExpectedHealthCheckResult();
				expectedHealthCheckResultObject.Url = expectedHealthCheckResult.Attributes["Url"].InnerXml;
				expectedHealthCheckResultObject.HealthStatus = Utilities.SetHealthStatus(expectedHealthCheckResult.Attributes["HealthStatus"].InnerXml);

				XmlNodeList expectedHealthReports = expectedHealthCheckResult.ChildNodes;

                //for each expectedHealthResultReports node
                //
				foreach (XmlNode expectedHealthReport in expectedHealthReports)
				{
					ExpectedHealthReport expectedHealthReportObject = new ExpectedHealthReport();
					expectedHealthReportObject.Name = expectedHealthReport.Attributes["Name"].InnerXml;
					expectedHealthReportObject.HealthStatus = 
						Utilities.SetHealthStatus(expectedHealthReport.Attributes["HealthStatus"].InnerXml);
                        expectedHealthCheckResultObject.ExpectedHealthReports.Add(expectedHealthReportObject.Name, expectedHealthReportObject);
                    
				}

                expectedResultObject.ExpectedHealthCheckResults.Add(expectedHealthCheckResultObject.Url, expectedHealthCheckResultObject);
			}

			XmlNodeList blockedHealthCheckUrls = blockedHealthChecks[0].ChildNodes;

			foreach (XmlNode blockedHealthCheckUrl in blockedHealthCheckUrls)
			{
                expectedResultObject.BlockedHealthCheckUrls.Add(blockedHealthCheckUrl.Attributes["Url"].InnerXml);
			}

            return expectedResultObject;
		}

        /// <summary>
        /// Returns one of the enum values of HealthStatus
        /// </summary>
        /// <param name="healthStatus"></param>
        /// <returns></returns>
		public static HealthStatus SetHealthStatus(string healthStatus)
		{
			switch (healthStatus.ToUpper())
			{
				case "GREEN":
					return HealthStatus.Green;
				case "RED":
					return HealthStatus.Red;
				case "YELLOW":
					return HealthStatus.Yellow;
				case "PASS":
					return HealthStatus.Pass;
				case "FAIL":
					return HealthStatus.Fail;
				case "NORESPONSETEXT":
					return HealthStatus.NoResponseText;
                case "URL":
                    return HealthStatus.NoUrl;
			}

			return HealthStatus.NoHealthCheckReports;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OctopusDailyTests\OctopusDailyTests\OctopusProcess.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace OctopusDailyTests
{
    public enum OctopusPendingRebootOperation {
        Ignore, Error, Reboot
    }

    public enum OctopusInstallationType
    {
        Install, Uninstall
    }

    class OctopusProcess
    {
        public bool     UseFakeAgent;
        public bool UseVerboseMsiLogging;
        public string   Password;
        public string   PathToLogLocationFile;
        public string   PathToConfigurationFile;
        public OctopusPendingRebootOperation PendingRebootOperation = OctopusPendingRebootOperation.Ignore;
        public OctopusInstallationType InstallationType = OctopusInstallationType.Install;

        public void Run() {
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.Append("-");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusInstallationType), InstallationType));
            argumentListBuilder.Append(" ");
            argumentListBuilder.Append("-onpendingrebootoperation ");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusPendingRebootOperation), PendingRebootOperation));
            argumentListBuilder.Append(" ");
            if (UseFakeAgent)
                argumentListBuilder.Append("-fakeAgent");
            else
                argumentListBuilder.Append("-adminpassword " + Password);
            argumentListBuilder.Append(" ");

            if (PathToConfigurationFile != null)
                argumentListBuilder.Append(String.Format("-config \"{0}\"", PathToConfigurationFile));
            argumentListBuilder.Append(" ");

            if (PathToLogLocationFile != null)
                argumentListBuilder.Append(String.Format("-recordlogfolderin \"{0}\"", PathToLogLocationFile));
            argumentListBuilder.Append(" ");

            if (UseVerboseMsiLogging)
                argumentListBuilder.Append("-verbosemsilogging");
            argumentListBuilder.Append(" ");

       
            ProcessStartInfo processStartInfo = new ProcessStartInfo(
    "octopuscli.exe", argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;

            Process octopus = Process.Start(processStartInfo);
            octopus.WaitForExit();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("xbox1")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("xbox1")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7238863c-0bf3-4838-a3b6-ebb0456d5cfd")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OctopusDailyTests\OctopusDailyTests\TestResults.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace OctopusDailyTests
{
    public enum TestRunResult
    {
        NotRun, Passed, Failed
    }

    public class TestResults
    {
        private List<Uri> _negativeUris;
        private List<string> _passingUrls;
        private List<string> _failingUrls;
        private TestRunResult _installResult;
        private TestRunResult _uninstallResult;
        private TestRunResult _reinstallResult;
        private TestRunResult _healthCheckResult;
        private TestRunResult _liveBvtsResult;


        public string[] PassingHealthChecks
        {
            get
            {
                return _passingUrls.ToArray();
            }
        }
        public string[] FailingHealthChecks
        {
            get
            {
                return _failingUrls.ToArray();
            }
        }

        // real results
        public TestRunResult Install
        {
            set { _installResult = value; }
            get { return _installResult; }
        }
        public TestRunResult Uninstall
        {
            set { _uninstallResult = value; }
            get { return _uninstallResult; }
        }
        public TestRunResult Reinstall
        {
            set { _reinstallResult = value; }
            get { return _reinstallResult; }
        }
        public TestRunResult HealthChecks
        {
            get
            {
                if (DeploymentCycle == TestRunResult.Failed)
                    return TestRunResult.NotRun;
                else
                    return _healthCheckResult;
            }
            private set
            {
                _healthCheckResult = value;
            }
        }
        public TestRunResult LiveBvts
        {
            set { _liveBvtsResult = value; }
            get { return _liveBvtsResult; }
        }
        
        // synthetic results
        public TestRunResult DeploymentCycle
        {
            get
            {
                if (Install == TestRunResult.Passed && Uninstall == TestRunResult.Passed && Reinstall == TestRunResult.Passed)
                    return TestRunResult.Passed;
                else if (Install == TestRunResult.NotRun && Uninstall == TestRunResult.NotRun && Reinstall == TestRunResult.NotRun)
                    return TestRunResult.NotRun;
                else
                    return TestRunResult.Failed;
            }
        }
        public TestRunResult OverallResult
        {
            get
            {
                if (AllResultsAreEqualTo(TestRunResult.Passed))
                    return TestRunResult.Passed;
                else if (AllResultsAreEqualTo(TestRunResult.NotRun))
                    return TestRunResult.NotRun;
                else
                    return TestRunResult.Failed;
            }
        }

        public TestResults()
        {
            Install = TestRunResult.NotRun;
            Uninstall = TestRunResult.NotRun;
            Reinstall = TestRunResult.NotRun;
            HealthChecks = TestRunResult.NotRun;
            LiveBvts = TestRunResult.NotRun;

            _negativeUris = new List<Uri>();
            _failingUrls = new List<string>();
            _passingUrls = new List<string>();

            PopulateExpectedHealthCheckOutcomes();
        }

        private bool AllResultsAreEqualTo(TestRunResult result)
        {
            return (Install == result && Uninstall == result && Reinstall == result &&
                HealthChecks == result && LiveBvts == result);
        }
        
        public void AddPassingUrl(string url)
        {
            UriBuilder uriBuilder = new UriBuilder(url);
            uriBuilder.Host = "localhost";

            if (_negativeUris.Contains(uriBuilder.Uri))
            {
                HealthChecks = TestRunResult.Failed;
                _failingUrls.Add(url + " [Should Be Blocked]");
            }
            else
            {
                if (HealthChecks == TestRunResult.NotRun)
                    HealthChecks = TestRunResult.Passed;
                _passingUrls.Add(url);
            }
        }
        
        public void AddFailingUrl(string url, string responseCode)
        {
            UriBuilder uriBuilder = new UriBuilder(url);
            uriBuilder.Host = "localhost";

            if (_negativeUris.Contains(uriBuilder.Uri))
            {
                if (HealthChecks == TestRunResult.NotRun)
                    HealthChecks = TestRunResult.Passed;
                _passingUrls.Add(url + " [Blocked]");
            }
            else
            {
                HealthChecks = TestRunResult.Failed;
                _failingUrls.Add(String.Format("{0} [{1}]", url, responseCode));
            }
        }
        
        private void PopulateExpectedHealthCheckOutcomes()
        {
            _negativeUris.Add(new Uri("http://localhost:10180/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:10190/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:11180/xpnfront/health.ashx"));
            _negativeUris.Add(new Uri("http://localhost:11190/xpnfront/health.ashx"));
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\HealthCheckVerifier\Test\HealthCheckVerifierTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

using xonline.test.deployment.HealthCheckVerifier;

namespace xonline.test.deployment.HealthCheckVerifier.Test
{
    class HealthCheckVerifierTest
    {
        protected static CheckResultManager _healthcheckManager;
        protected static string _systemCheckOutFile = null;
        protected static string _healthCheckVerifierConfigFilePath = null;

        static void Main(string[] args)
        {

            try
            {
                ParseCommandLine(args);
                if ((_systemCheckOutFile == null) || (_healthCheckVerifierConfigFilePath == null))
                {
                    PrintUsage();
                    return;
                }

                if (_healthcheckManager == null)
                {
                    _healthcheckManager = new CheckResultManager();
                }

                Console.WriteLine();
                Console.WriteLine("Parsing HealthChecks:");
                Console.WriteLine("\tInputFile: {0}", _systemCheckOutFile);
                Console.WriteLine("\tConfigFile: {0}", _healthCheckVerifierConfigFilePath);
                Console.WriteLine();
                _healthcheckManager.LoadXmlAndPopulateData(_systemCheckOutFile, _healthCheckVerifierConfigFilePath);

                // Default to assume all passed. If we get a failed healthcheck we'll fail it.
                Console.WriteLine("Failed HealthChecks:");
                List<CheckResult> checkResultList = _healthcheckManager.CheckResults;
                if (checkResultList.Count == 0)
                    Console.WriteLine("None");
                foreach (CheckResult checkResult in checkResultList)
                {
                    if (checkResult.HealthStatus.Equals(HealthStatus.Fail))
                    {
                        //isFail = true;
                        StringBuilder healthReportsSummary = new StringBuilder("");
                        healthReportsSummary.AppendFormat("Health URL: {0} - {1}\r\n", checkResult.Url, checkResult.HealthStatus.ToString());
                        foreach (HealthReport failedHealthReport in checkResult.HealthCheck.HealthReports)
                        {
                            if (failedHealthReport.HealthStatus != HealthStatus.Green)
                            {
                                healthReportsSummary.AppendFormat("\tHealth Block: {0} - {1}\r\n", failedHealthReport.Name, failedHealthReport.HealthStatus.ToString());
                            }
                        }
                        Console.WriteLine("{0}", healthReportsSummary.ToString());
                    }
                    /*else
                    {
                        healthCheckLog = new Log();
                        healthCheckLog.Path = checkResult.Url;
                        healthCheckLog.Text = checkResult.HealthStatus.ToString();
                        result.AddLog(healthCheckLog);
                    }*/
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Caught an Exception Parsing Healthchecks:");
                Console.WriteLine(ex.ToString());
            }
        }

        static void ParseCommandLine(string[] args)
        {
            try
            {
                string inputfilestring = "/inputfile:";
                string configfilestring = "/configfile:";
                foreach (string argument in args)
                {
                    if (argument.Trim().IndexOf(inputfilestring, StringComparison.CurrentCultureIgnoreCase) == 0)
                    {
                        _systemCheckOutFile = argument.Trim().Substring(inputfilestring.Length);
                        if (File.Exists(_systemCheckOutFile) != true)
                        {
                            throw new ArgumentException("File does not exist: " + _systemCheckOutFile);
                        }
                    }
                    else if (argument.Trim().IndexOf(configfilestring, StringComparison.CurrentCultureIgnoreCase) == 0)
                    {
                        _healthCheckVerifierConfigFilePath = argument.Trim().Substring(configfilestring.Length);
                        if (File.Exists(_healthCheckVerifierConfigFilePath) != true)
                        {
                            throw new ArgumentException("File does not exist: " + _healthCheckVerifierConfigFilePath);
                        }
                    }
                    else
                    {
                        throw new System.ArgumentException("Invalid Parameter: " + argument);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
                PrintUsage();
            }
        }

        static void PrintUsage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("\tHealthCheckVerifierTest.exe /inputfile:<file path> /configfile:<file path>");
            Console.WriteLine();
            Console.WriteLine("\tInputfile - XML output from SystemCheck");
            Console.WriteLine("\tconfigfile - Configuration file of expected failures");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OctopusDailyTests\OctopusDailyTests\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace OctopusDailyTests.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "8.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://xblwiki/EditService.asmx")]
        public string OctopusDailyTests_Xblwiki_EditService {
            get {
                return ((string)(this["OctopusDailyTests_Xblwiki_EditService"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OutlookHelper\OutlookHelper\Class1.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Office.Interop.Outlook;

namespace OutlookHelper
{
    public class OutlookHelper
    {
        public static object GetBlankMailItem()
        {
            Application app = new Application();
            NameSpace mapiNamespace = app.GetNamespace("MAPI");
            //mapiNamespace.Logon(null, null, false, false);

            MAPIFolder outbox = app.Session.GetDefaultFolder(OlDefaultFolders.olFolderOutbox);

            _MailItem item = (MailItem)app.CreateItem(OlItemType.olMailItem);
            item.SaveSentMessageFolder = outbox;
            return item;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\DeploymentTestVerifier\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Reflection;
using System.IO;
using System.Net.Mail;
using System.Net;
using System.Xml;
using System.Threading;
using HealthCheckVerifier;

namespace TestApplication
{
    class Program
    {
        static TestResults Results = new TestResults();

        static readonly string PreInstallLogMarker = "preinstall_loglocation.txt";
        static readonly string InstallLogMarker = "install_loglocation.txt";
        static readonly string UninstallLogMarker = "uninstall_loglocation.txt";
        static readonly string ReinstallLogMarker = "reinstall_loglocation.txt";
        static readonly string BvtLogMarker = "bvt_loglocation.txt";
        static readonly string BvtResultsFile = "bvt_results.html";

        static string InstallLogPath;
        static string UninstallLogPath;
        static string ReinstallLogPath;
        static string BvtLogPath;
        static string BvtResultsPath;
        static string HtmlReport = "";

        //Timing variables
        static DateTime OverallStartTime = DateTime.Now;
        static DateTime OverallEndTime = DateTime.Now;
        static TimeSpan OverallRunTime = new TimeSpan(0);
        static DateTime InstallStartTime = DateTime.Now;
        static DateTime InstallEndTime = DateTime.Now;
        static TimeSpan InstallRunTime = new TimeSpan(0);
        static DateTime UninstallStartTime = DateTime.Now;
        static DateTime UninstallEndTime = DateTime.Now;
        static TimeSpan UninstallRunTime = new TimeSpan(0);
        static DateTime ReinstallStartTime = DateTime.Now;
        static DateTime ReinstallEndTime = DateTime.Now;
        static TimeSpan ReinstallRunTime = new TimeSpan(0);
        static DateTime HealthCheckStartTime = DateTime.Now;
        static DateTime HealthCheckEndTime = DateTime.Now;
        static TimeSpan HealthCheckRunTime = new TimeSpan(0);
        static DateTime BvtStartTime = DateTime.Now;
        static DateTime BvtEndTime = DateTime.Now;
        static TimeSpan BvtRunTime = new TimeSpan(0);

        /// <summary>
        /// The main entry point for the program.
        /// </summary>
        /// <param name="args">
        /// Parameter 1: The path to the vault folder
        /// Parameter 2: The e-mail address to provide with results
        /// Parameter 3: The password for the currently logged in user.
        /// </param>
        static void Main(string[] args)
        {
            try
            {
                if (args.Length != 3)
                {
                    PrintUsage();
                    Environment.Exit(1);
                }

                string vaultPath = args[0];
                string emailAddress = args[1];
                string password = args[2];

                string containingDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

                string preinstallLogMarkerPath = Path.Combine(containingDirectory, PreInstallLogMarker);
                if (File.Exists(preinstallLogMarkerPath))
                    File.Delete(preinstallLogMarkerPath);

                string installLogMarkerPath = Path.Combine(containingDirectory, InstallLogMarker);
                if (File.Exists(installLogMarkerPath))
                    File.Delete(installLogMarkerPath);

                string uninstallLogMarkerPath = Path.Combine(containingDirectory, UninstallLogMarker);
                if (File.Exists(uninstallLogMarkerPath))
                    File.Delete(uninstallLogMarkerPath);

                string reinstallLogMarkerPath = Path.Combine(containingDirectory, ReinstallLogMarker);
                if (File.Exists(reinstallLogMarkerPath))
                    File.Delete(reinstallLogMarkerPath);

                string bvtLogMarkerPath = Path.Combine(containingDirectory, BvtLogMarker);
                if (File.Exists(bvtLogMarkerPath))
                    File.Delete(bvtLogMarkerPath);

                // Start timing the whole run
                OverallStartTime = DateTime.Now;

                // Set up the Octopus Installer config
                OctopusProcess octopusProcess = new OctopusProcess();
                octopusProcess.UseFakeAgent = false;
                octopusProcess.PendingRebootOperation = OctopusPendingRebootOperation.Reboot;
                octopusProcess.Password = password;
                octopusProcess.UseVerboseMsiLogging = true;

                // Make sure wstagent and sql server agent are running
                Console.WriteLine("\t*** Starting Services ***");
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "servicesxb001.xml");
                octopusProcess.Run();

                // Xblob Prep Install
                Console.WriteLine("\t*** Running Pre-Install ***");
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToLogLocationFile = preinstallLogMarkerPath;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "prexb001.xml");
                octopusProcess.Run();

                // Install the Xbox Live Service
                Console.WriteLine("\t*** Installing Service ***");
                InstallStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "xb001.xml");
                octopusProcess.PathToLogLocationFile = installLogMarkerPath;
                octopusProcess.Run();
                InstallLogPath = GetLogPathFromMarker(installLogMarkerPath);
                InstallEndTime = DateTime.Now;
                InstallRunTime = InstallEndTime - InstallStartTime;

                // Install the Xbox Live Service
                Console.WriteLine("\t*** Uninstalling Service ***");
                UninstallStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Uninstall;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "xb001.xml");
                octopusProcess.PathToLogLocationFile = uninstallLogMarkerPath;
                octopusProcess.Run();
                UninstallLogPath = GetLogPathFromMarker(uninstallLogMarkerPath);
                UninstallEndTime = DateTime.Now;
                UninstallRunTime = UninstallEndTime - UninstallStartTime;

                // Make sure wstagent and sql server agent are running
                Console.WriteLine("\t*** Starting Services ***");
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "servicesxb001.xml");
                octopusProcess.PathToLogLocationFile = null;
                octopusProcess.Run();

                // Reinstall the Xbox Live Service
                Console.WriteLine("\t*** Reinstalling Service ***");
                ReinstallStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "xb001.xml");
                octopusProcess.PathToLogLocationFile = reinstallLogMarkerPath;
                octopusProcess.Run();
                ReinstallLogPath = GetLogPathFromMarker(reinstallLogMarkerPath);
                ReinstallEndTime = DateTime.Now;
                ReinstallRunTime = ReinstallEndTime - ReinstallStartTime;

                // Run the BVT's
                Console.WriteLine("\t*** Running BVTs ***");
                BvtStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "bvt001.xml");
                octopusProcess.PathToLogLocationFile = bvtLogMarkerPath;
                octopusProcess.Run();
                BvtLogPath = GetLogPathFromMarker(bvtLogMarkerPath);
                BvtResultsPath = Path.Combine(GetLogFolderPathFromMarker(bvtLogMarkerPath), BvtResultsFile);
                BvtEndTime = DateTime.Now;
                BvtRunTime = BvtEndTime - BvtStartTime;
                OverallEndTime = DateTime.Now;
                OverallRunTime = OverallEndTime - OverallStartTime;

                // Parse Results
                Console.WriteLine("\t*** Getting Results ***");
                Results.Install = GetDeploymentResultFromLog(InstallLogPath);
                Results.Uninstall = GetDeploymentResultFromLog(UninstallLogPath);
                Results.Reinstall = GetDeploymentResultFromLog(ReinstallLogPath);
                ReviewSystemCheckResultsUsingLog(BvtLogPath);
                Results.LiveBvts = GetResultForCommandInLog("run-live-bvts", BvtLogPath);
                HealthCheckStartTime = GetTimeStampForCommandInLog("health-check", BvtLogPath, true);
                HealthCheckEndTime = GetTimeStampForCommandInLog("health-check", BvtLogPath, false);
                HealthCheckRunTime = HealthCheckEndTime - HealthCheckStartTime;
                BvtStartTime = GetTimeStampForCommandInLog("run-live-bvts", BvtLogPath, true);
                BvtEndTime = GetTimeStampForCommandInLog("run-live-bvts", BvtLogPath, false);
                BvtRunTime = BvtEndTime - BvtStartTime;

                //Log Results to a file in case email fails
                Console.WriteLine("\t*** Logging Results ***");
                string resultsFile = Path.Combine(GetLogFolderPathFromMarker(bvtLogMarkerPath), BvtResultsFile);
                Console.WriteLine("Logging to: {0}", resultsFile);
                string buildNumber = GetBuildVersionAtPath(@"\\edge-svcs\Release\XONLINE\main\Latest.tst\retail\msi\esp");
                Console.WriteLine("Build version = {0}", buildNumber);
                GetXblobHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed Xblob Results");
                GetCoreNetHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed CoreNet Results");
                GetBvtNetHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed BvtNet Results");
                Console.WriteLine("*** Results: ***\n{0}", HtmlReport);
                if (File.Exists(resultsFile) == true)
                {
                    File.Delete(resultsFile);
                }
                using (StreamWriter rfStream = File.CreateText(resultsFile))
                {
                    rfStream.Write(HtmlReport);
                    rfStream.Close();
                }

                SendResults(emailAddress, buildNumber);
                //Console.ReadKey();
            }
            catch (Exception globalException)
            {
                Console.WriteLine("Caught a Global Exception:\n{0}", globalException.ToString());
            }
        }

        static string GetLogPathFromMarker(string path)
        {
            string returnValue = null;
            string logPath = GetLogFolderPathFromMarker(path);

            if (logPath != null && File.Exists(Path.Combine(logPath, "deploymentSession.xml")))
            {
                returnValue = Path.Combine(logPath, "deploymentSession.xml");
            }

            return returnValue;
        }

        static string GetLogFolderPathFromMarker(string path)
        {
            string returnValue = null;
            if (File.Exists(path))
            {
                string logPath = null;
                using (StreamReader s = new StreamReader(path))
                {
                    logPath = s.ReadLine();
                }
                if (logPath != null)
                {
                    returnValue = logPath;
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Prints the usage string for how to use the program
        /// </summary>
        static void PrintUsage()
        {
            Console.WriteLine("Usage is: OctopusDailyTests <path to vault> <e-mail address> <password>");
        }

        /// <summary>
        /// Gathers all of the results from running tests, updates the build number and results posted on the wiki,
        /// and then sends an e-mail with those results.
        /// </summary>
        /// <param name="emailAddress">The place to send e-mail to.</param>
        /// <param name="buildNumber">The Build number installed.</param>
        [Conditional("XBLOB")]
        static void SendResults(string emailAddress, string buildNumber)
        {
            GetXblobHtmlReportFromResultsWithVersion(buildNumber, false);

            MailMessage mailMessage = new MailMessage("emzephir@microsoft.com", emailAddress);
            mailMessage.Body = HtmlReport;
            mailMessage.IsBodyHtml = true;
            mailMessage.Subject = String.Format("{0}: Octopus Deployment (Xblob): {1}", GetNameStringForResult(Results.OverallResult), buildNumber);

            SmtpClient smtpClient = new SmtpClient("smtphost");
            smtpClient.UseDefaultCredentials = true;
            //smtpClient.Credentials = new NetworkCredential("espptest", "MSFTstock$", "redmond");
            try
            {
                smtpClient.Send(mailMessage);
            }
            catch (SmtpException smtpException)
            {
                Console.WriteLine("Failed to send email. Trying again.\n{0}", smtpException.ToString());
                try
                {
                    // retry
                    smtpClient.Send(mailMessage);
                }
                catch (SmtpException smtpException2)
                {
                    // give up
                    Console.WriteLine("Failed to send email. Giving up.\n{0}", smtpException2.ToString());
                }
            }

            //Update latest build
            try
            {
                Xblwiki.EditService editService = new OctopusDailyTests.Xblwiki.EditService();
                editService.UseDefaultCredentials = true;

                if (Results.OverallResult == TestRunResult.Passed && buildNumber != null)
                {

                    Xblwiki.AbsoluteTopicName absoluteTopicName = new OctopusDailyTests.Xblwiki.AbsoluteTopicName();
                    absoluteTopicName.Namespace = "Xblob";
                    absoluteTopicName.Name = "OctopusLKGBuild";
                    editService.SetTextForTopic(absoluteTopicName, buildNumber, "");
                }

                string wikitext = GetWikiReportFromResultsWithVersion(buildNumber);
                Xblwiki.AbsoluteTopicName lastDeploymentTopicName = new OctopusDailyTests.Xblwiki.AbsoluteTopicName();
                lastDeploymentTopicName.Namespace = "Xblob";
                lastDeploymentTopicName.Name = "OctopusLKGBuildLastDeployment";
                editService.SetTextForTopic(lastDeploymentTopicName, wikitext, "");

                if (Results.OverallResult == TestRunResult.Passed)
                {
                    lastDeploymentTopicName.Name = "OctopusLKGBuildLastPassedDeployment";
                    editService.SetTextForTopic(lastDeploymentTopicName, wikitext, "");
                }
            }
            catch (Exception wikiException)
            {
                Console.WriteLine("Caught an Exception Updating the Wiki:\n{0}", wikiException.ToString());
            }
        }

        /// <summary>
        /// Goes through a deployment log looking and reports the overall status from that log file as reported by Octopus.
        /// </summary>
        /// <param name="logFilePath">The path to a text file containing the path to the Octopus deployment log folder. This is usually acquired by OctopusCLI's -recordLogFolderIn option</param>
        /// <returns>If logFilePath does not exist, returns a NotRun result. Otherwise it returns the result of the deployment.</returns>
        static TestRunResult GetDeploymentResultFromLog(string logFilePath)
        {
            TestRunResult returnValue = TestRunResult.NotRun;
            if (logFilePath != null)
            {
                string[] errors = GetErrorsFromOctopusLog(logFilePath);
                if (errors.Length == 0)
                {
                    returnValue = TestRunResult.Passed;
                }
                else
                {
                    returnValue = TestRunResult.Failed;
                }
            }

            return returnValue;
        }

        /// <summary>
        /// Looks throught the healthchecks.xml file in an Octopus Log folder to determine whether or not the URLs run by
        /// SystemCheck passed as expected. These results are registered directly with the result object.
        /// </summary>
        /// <param name="logFilePath">The path to a text file containing the path to the folder containing healthchecks.xml. This is usually acquired by OctopusCLI's -recordLogFolderIn option. Although</param>
        static void ReviewSystemCheckResultsUsingLog(string logFilePath)
        {
            if (logFilePath != null && File.Exists(Path.Combine(Path.GetDirectoryName(logFilePath), "healthchecks.xml")))
            {
                CheckResultManager manger = new CheckResultManager();
                string configXml = (@"HealthCheckConfig.xml");

                manger.LoadXmlAndPopulateData(Path.Combine(Path.GetDirectoryName(logFilePath), "healthchecks.xml"), configXml);

                List<CheckResult> checkResultList = manger.CheckResults;
                bool isFail = false;

                foreach (CheckResult checkResult in checkResultList)
                {
                    if (checkResult.HealthStatus.Equals(HealthStatus.Fail))
                        isFail = true;
                }
                if (isFail)
                    Results.HealthChecks = TestRunResult.Failed;
                else
                    Results.HealthChecks = TestRunResult.Passed;

                using (StreamWriter write = new StreamWriter(Path.Combine(Path.GetDirectoryName(logFilePath), (@"healthCheckVeriferLog.txt"))))
                {
                    write.Write(manger.ErrorsToBeLogged);
                    write.Close();
                }

            }
            else
                Results.HealthChecks = TestRunResult.NotRun;
        }


        private static string[] GetErrorsFromOctopusLog(string logPath)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(logPath);
            List<String> errorMessages = new List<String>();

            XmlNodeList elements = xmlDoc.GetElementsByTagName("msiError");
            foreach (XmlElement e in elements)
            {
                errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
            }

            // Command finished nodes are the only ones that carry errors
            elements = xmlDoc.GetElementsByTagName("commandFinished");
            foreach (XmlElement e in elements)
            {
                if (e.GetAttribute("eventLevel") == "Error")
                {
                    errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
                }
            }

            elements = xmlDoc.GetElementsByTagName("message");
            foreach (XmlElement e in elements)
            {
                if (e.GetAttribute("eventLevel") == "Error")
                {
                    errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
                }
            }

            elements = xmlDoc.GetElementsByTagName("messageError");
            foreach (XmlElement e in elements)
            {
                errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
            }
            return errorMessages.ToArray();

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="commandName"></param>
        /// <param name="logFilePath"></param>
        /// <returns></returns>
        public static TestRunResult GetResultForCommandInLog(string commandName, string logFilePath)
        {
            // this only works for one command
            TestRunResult returnValue = TestRunResult.NotRun;
            if (logFilePath != null)
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(logFilePath);
                List<String> errorMessages = new List<String>();

                XmlNodeList elements = xmlDoc.GetElementsByTagName("commandFinished");
                foreach (XmlElement e in elements)
                {
                    if (e.GetAttribute("name") == commandName)
                    {
                        if (e.GetAttribute("eventLevel") == "Error")
                            returnValue = TestRunResult.Failed;
                        else
                            returnValue = TestRunResult.Passed;
                        break;
                    }
                }
            }

            return returnValue;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="commandName"></param>
        /// <param name="logFilePath"></param>
        /// <returns></returns>
        public static DateTime GetTimeStampForCommandInLog(string commandName, string logFilePath, bool isStartCommand)
        {
            // this only works for one command
            DateTime returnValue = new DateTime(0);
            if (logFilePath != null)
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(logFilePath);
                List<String> errorMessages = new List<String>();
                XmlNodeList elements;

                if (isStartCommand == true)
                    elements = xmlDoc.GetElementsByTagName("commandStarted");
                else
                    elements = xmlDoc.GetElementsByTagName("commandFinished");
                foreach (XmlElement e in elements)
                {
                    if (e.GetAttribute("name") == commandName)
                    {
                        string timeStamp = e.GetAttribute("timeStamp");
                        if (timeStamp != "")
                        {
                            try
                            {
                                returnValue = DateTime.Parse(timeStamp);
                            }
                            catch (FormatException)
                            {
                                returnValue = new DateTime(0);
                            }
                        }
                        break; // We found the command, stop looking
                    }
                }
            }

            return returnValue;
        }

        public static string GetBuildVersionAtPath(string path)
        {
            string buildVersion = "latest.tst";
            path = path.ToLower();

            Regex regex = new Regex("([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)");
            Match regexMatch = regex.Match(path);
            if (regexMatch.Success)
            {
                return regexMatch.Value;
            }
            else
            {
                // No build information in path -- lets look on the server

                int indexOfBuildType = path.IndexOf("debug");
                if (indexOfBuildType == -1)
                    indexOfBuildType = path.IndexOf("retail");
                if (indexOfBuildType == -1)
                    return buildVersion;

                DirectoryInfo directoryInfo = new DirectoryInfo(path.Substring(0, indexOfBuildType));
                if (directoryInfo.Exists == true)
                {
                    try
                    {
                        foreach (FileInfo fileInfo in directoryInfo.GetFiles())
                        {
                            regexMatch = regex.Match(fileInfo.Name);
                            if (regexMatch.Success)
                                return regexMatch.Value;
                        }
                    }
                    catch (DirectoryNotFoundException)
                    {
                    }
                }
            }

            return buildVersion;
        }

        public static string GetWikiReportFromResultsWithVersion(string version)
        {
            if (version == null)
                version = "";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.AppendFormat("!Octopus Deployment Status (Xblob): {0}\n", version);
            stringBuilder.Append("Octopus Settings (Copy and Paste to use)\n");
            stringBuilder.AppendFormat("BuildLocation: \\\\edge-svcs\\Release\\XONLINE\\main\\{0}\\retail\\msi\\esp\n", version);
            stringBuilder.Append("Topology: \"Simple Xblob\"\n");
            stringBuilder.AppendFormat(":Build: {0}\n", version);
            stringBuilder.AppendFormat(":Date: {0}\n", DateTime.Now.ToShortDateString());
            stringBuilder.AppendFormat(":Installation Time: {0} hour(s) {1} minute(s)\n", InstallRunTime.Hours.ToString(), InstallRunTime.Minutes.ToString());
            stringBuilder.AppendFormat(":Total Time: {0} hour(s) {1} minute(s)\n", OverallRunTime.Hours.ToString(), OverallRunTime.Minutes.ToString());
            // this intentionally is the enum name - used for programatic parsing.
            stringBuilder.AppendFormat(":OverallStatus: {0}", Enum.GetName(typeof(TestRunResult), Results.OverallResult));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!%{0}%{1}%%\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!!Install, Uninstall, Reinstall: %{0}%{1}%%\n", GetColorStringForResult(Results.DeploymentCycle), GetNameStringForResult(Results.DeploymentCycle));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!!Health \"\"URLs\"\": %{0}%{1}%%\n", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!!\"\"LiveBVT Smoke Testing\"\": %{0}%{1}%%\n", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("\"List of LiveBVT Tests\":ListOfLiveBVTTests\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Passed || Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.PassingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("!!!Passed Health \"\"URLs\"\" ({0}):\n", Results.PassingHealthChecks.Length);
                    stringBuilder.Append("%gray%([Blocked] = a URL that is correctly blocked by XRLScan)%%\n");
                    foreach (string url in Results.PassingHealthChecks)
                        stringBuilder.AppendFormat("\t* {0}\n", url);
                    stringBuilder.AppendLine();
                }

                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("!!!Failed Health \"\"URLs\"\" ({0}):\n", Results.FailingHealthChecks.Length);
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("\t* {0}\n", url);
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("!!Other Information\n");
            //stringBuilder.Append("\t* Xblob Machine Name: \"\"EMZEPHIRXBL001\"\"\n");
            //stringBuilder.Append("\t* Xblob Machine Specs: 2.8 \"\"GHz\"\" Pentium 4, 2 GB RAM, All components installed to C:\n");
            stringBuilder.Append("\t* Logs: \\\\EMZEPHIR-PC\\AutoLogs\n");

            return stringBuilder.ToString();
        }

        [Conditional("XBLOB")]
        public static void GetXblobHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "Xblob";
            String topology = "Simple Xblob";
            String logLocation = "\\\\EMZEPHIR-PC\\AutoLogs";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if (forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", UninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", UninstallRunTime.Hours, UninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Uninstall), GetNameStringForResult(Results.Uninstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Reinstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", ReinstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", ReinstallRunTime.Hours, ReinstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Reinstall), GetNameStringForResult(Results.Reinstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            HtmlReport = stringBuilder.ToString();
        }

        [Conditional("CORENET")]
        public static void GetCoreNetHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "CoreNet";
            String topology = "Expanded - Ops";
            String logLocation = "http://65.52.240.59/";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if (forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", UninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", UninstallRunTime.Hours, UninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Uninstall), GetNameStringForResult(Results.Uninstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Reinstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", ReinstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", ReinstallRunTime.Hours, ReinstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Reinstall), GetNameStringForResult(Results.Reinstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            HtmlReport = stringBuilder.ToString();
        }

        [Conditional("BVTNET")]
        public static void GetBvtNetHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "BvtNet";
            String topology = "Expanded - Ops";
            String logLocation = "http://10.198.103.82/";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if (forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", UninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", UninstallRunTime.Hours, UninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Uninstall), GetNameStringForResult(Results.Uninstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Reinstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", ReinstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", ReinstallRunTime.Hours, ReinstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Reinstall), GetNameStringForResult(Results.Reinstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            HtmlReport = stringBuilder.ToString();
        }

        public static string GetColorStringForResult(TestRunResult result)
        {
            if (result == TestRunResult.Failed)
                return "red";
            else if (result == TestRunResult.NotRun)
                return "gray";
            else if (result == TestRunResult.Passed)
                return "green";
            else
                return "black";
        }

        public static string GetNameStringForResult(TestRunResult result)
        {
            if (result == TestRunResult.Failed)
                return "Failed";
            else if (result == TestRunResult.NotRun)
                return "Not Run";
            else if (result == TestRunResult.Passed)
                return "Passed";
            else
                return Enum.GetName(typeof(TestRunResult), result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OctopusDailyTests\OctopusDailyTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("OctopusDailyTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("OctopusDailyTests")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("67b0c1e8-16e4-464b-b801-852cb21fab58")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OctopusDailyTests\OctopusDailyTests\Web References\Xblwiki\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.1433.
// 
#pragma warning disable 1591

namespace OctopusDailyTests.Xblwiki {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="EditServiceSoap", Namespace="http://www.flexwiki.com/webservices/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(TopicName))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ReflectedValueSource))]
    public partial class EditService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback CanEditOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAllNamespacesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAllTopicsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDefaultNamespaceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetHtmlForTopicOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetHtmlForTopicVersionOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPreviewForTopicOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTextForTopicOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVersionsForTopicOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetWikiVersionOperationCompleted;
        
        private System.Threading.SendOrPostCallback RestoreTopicOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetTextForTopicOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public EditService() {
            this.Url = global::OctopusDailyTests.Properties.Settings.Default.OctopusDailyTests_Xblwiki_EditService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event CanEditCompletedEventHandler CanEditCompleted;
        
        /// <remarks/>
        public event GetAllNamespacesCompletedEventHandler GetAllNamespacesCompleted;
        
        /// <remarks/>
        public event GetAllTopicsCompletedEventHandler GetAllTopicsCompleted;
        
        /// <remarks/>
        public event GetDefaultNamespaceCompletedEventHandler GetDefaultNamespaceCompleted;
        
        /// <remarks/>
        public event GetHtmlForTopicCompletedEventHandler GetHtmlForTopicCompleted;
        
        /// <remarks/>
        public event GetHtmlForTopicVersionCompletedEventHandler GetHtmlForTopicVersionCompleted;
        
        /// <remarks/>
        public event GetPreviewForTopicCompletedEventHandler GetPreviewForTopicCompleted;
        
        /// <remarks/>
        public event GetTextForTopicCompletedEventHandler GetTextForTopicCompleted;
        
        /// <remarks/>
        public event GetVersionsForTopicCompletedEventHandler GetVersionsForTopicCompleted;
        
        /// <remarks/>
        public event GetWikiVersionCompletedEventHandler GetWikiVersionCompleted;
        
        /// <remarks/>
        public event RestoreTopicCompletedEventHandler RestoreTopicCompleted;
        
        /// <remarks/>
        public event SetTextForTopicCompletedEventHandler SetTextForTopicCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/CanEdit", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string CanEdit() {
            object[] results = this.Invoke("CanEdit", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CanEditAsync() {
            this.CanEditAsync(null);
        }
        
        /// <remarks/>
        public void CanEditAsync(object userState) {
            if ((this.CanEditOperationCompleted == null)) {
                this.CanEditOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCanEditOperationCompleted);
            }
            this.InvokeAsync("CanEdit", new object[0], this.CanEditOperationCompleted, userState);
        }
        
        private void OnCanEditOperationCompleted(object arg) {
            if ((this.CanEditCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CanEditCompleted(this, new CanEditCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetAllNamespaces", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ContentBase[] GetAllNamespaces() {
            object[] results = this.Invoke("GetAllNamespaces", new object[0]);
            return ((ContentBase[])(results[0]));
        }
        
        /// <remarks/>
        public void GetAllNamespacesAsync() {
            this.GetAllNamespacesAsync(null);
        }
        
        /// <remarks/>
        public void GetAllNamespacesAsync(object userState) {
            if ((this.GetAllNamespacesOperationCompleted == null)) {
                this.GetAllNamespacesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAllNamespacesOperationCompleted);
            }
            this.InvokeAsync("GetAllNamespaces", new object[0], this.GetAllNamespacesOperationCompleted, userState);
        }
        
        private void OnGetAllNamespacesOperationCompleted(object arg) {
            if ((this.GetAllNamespacesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAllNamespacesCompleted(this, new GetAllNamespacesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetAllTopics", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AbsoluteTopicName[] GetAllTopics(ContentBase cb) {
            object[] results = this.Invoke("GetAllTopics", new object[] {
                        cb});
            return ((AbsoluteTopicName[])(results[0]));
        }
        
        /// <remarks/>
        public void GetAllTopicsAsync(ContentBase cb) {
            this.GetAllTopicsAsync(cb, null);
        }
        
        /// <remarks/>
        public void GetAllTopicsAsync(ContentBase cb, object userState) {
            if ((this.GetAllTopicsOperationCompleted == null)) {
                this.GetAllTopicsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAllTopicsOperationCompleted);
            }
            this.InvokeAsync("GetAllTopics", new object[] {
                        cb}, this.GetAllTopicsOperationCompleted, userState);
        }
        
        private void OnGetAllTopicsOperationCompleted(object arg) {
            if ((this.GetAllTopicsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAllTopicsCompleted(this, new GetAllTopicsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetDefaultNamespace", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ContentBase GetDefaultNamespace() {
            object[] results = this.Invoke("GetDefaultNamespace", new object[0]);
            return ((ContentBase)(results[0]));
        }
        
        /// <remarks/>
        public void GetDefaultNamespaceAsync() {
            this.GetDefaultNamespaceAsync(null);
        }
        
        /// <remarks/>
        public void GetDefaultNamespaceAsync(object userState) {
            if ((this.GetDefaultNamespaceOperationCompleted == null)) {
                this.GetDefaultNamespaceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDefaultNamespaceOperationCompleted);
            }
            this.InvokeAsync("GetDefaultNamespace", new object[0], this.GetDefaultNamespaceOperationCompleted, userState);
        }
        
        private void OnGetDefaultNamespaceOperationCompleted(object arg) {
            if ((this.GetDefaultNamespaceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDefaultNamespaceCompleted(this, new GetDefaultNamespaceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetHtmlForTopic", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetHtmlForTopic(AbsoluteTopicName topicName) {
            object[] results = this.Invoke("GetHtmlForTopic", new object[] {
                        topicName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetHtmlForTopicAsync(AbsoluteTopicName topicName) {
            this.GetHtmlForTopicAsync(topicName, null);
        }
        
        /// <remarks/>
        public void GetHtmlForTopicAsync(AbsoluteTopicName topicName, object userState) {
            if ((this.GetHtmlForTopicOperationCompleted == null)) {
                this.GetHtmlForTopicOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetHtmlForTopicOperationCompleted);
            }
            this.InvokeAsync("GetHtmlForTopic", new object[] {
                        topicName}, this.GetHtmlForTopicOperationCompleted, userState);
        }
        
        private void OnGetHtmlForTopicOperationCompleted(object arg) {
            if ((this.GetHtmlForTopicCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetHtmlForTopicCompleted(this, new GetHtmlForTopicCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetHtmlForTopicVersion", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetHtmlForTopicVersion(AbsoluteTopicName topicName, string version) {
            object[] results = this.Invoke("GetHtmlForTopicVersion", new object[] {
                        topicName,
                        version});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetHtmlForTopicVersionAsync(AbsoluteTopicName topicName, string version) {
            this.GetHtmlForTopicVersionAsync(topicName, version, null);
        }
        
        /// <remarks/>
        public void GetHtmlForTopicVersionAsync(AbsoluteTopicName topicName, string version, object userState) {
            if ((this.GetHtmlForTopicVersionOperationCompleted == null)) {
                this.GetHtmlForTopicVersionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetHtmlForTopicVersionOperationCompleted);
            }
            this.InvokeAsync("GetHtmlForTopicVersion", new object[] {
                        topicName,
                        version}, this.GetHtmlForTopicVersionOperationCompleted, userState);
        }
        
        private void OnGetHtmlForTopicVersionOperationCompleted(object arg) {
            if ((this.GetHtmlForTopicVersionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetHtmlForTopicVersionCompleted(this, new GetHtmlForTopicVersionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetPreviewForTopic", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetPreviewForTopic(AbsoluteTopicName topicName, string textToFormat) {
            object[] results = this.Invoke("GetPreviewForTopic", new object[] {
                        topicName,
                        textToFormat});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetPreviewForTopicAsync(AbsoluteTopicName topicName, string textToFormat) {
            this.GetPreviewForTopicAsync(topicName, textToFormat, null);
        }
        
        /// <remarks/>
        public void GetPreviewForTopicAsync(AbsoluteTopicName topicName, string textToFormat, object userState) {
            if ((this.GetPreviewForTopicOperationCompleted == null)) {
                this.GetPreviewForTopicOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPreviewForTopicOperationCompleted);
            }
            this.InvokeAsync("GetPreviewForTopic", new object[] {
                        topicName,
                        textToFormat}, this.GetPreviewForTopicOperationCompleted, userState);
        }
        
        private void OnGetPreviewForTopicOperationCompleted(object arg) {
            if ((this.GetPreviewForTopicCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPreviewForTopicCompleted(this, new GetPreviewForTopicCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetTextForTopic", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetTextForTopic(AbsoluteTopicName topicName) {
            object[] results = this.Invoke("GetTextForTopic", new object[] {
                        topicName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetTextForTopicAsync(AbsoluteTopicName topicName) {
            this.GetTextForTopicAsync(topicName, null);
        }
        
        /// <remarks/>
        public void GetTextForTopicAsync(AbsoluteTopicName topicName, object userState) {
            if ((this.GetTextForTopicOperationCompleted == null)) {
                this.GetTextForTopicOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTextForTopicOperationCompleted);
            }
            this.InvokeAsync("GetTextForTopic", new object[] {
                        topicName}, this.GetTextForTopicOperationCompleted, userState);
        }
        
        private void OnGetTextForTopicOperationCompleted(object arg) {
            if ((this.GetTextForTopicCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTextForTopicCompleted(this, new GetTextForTopicCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetVersionsForTopic", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] GetVersionsForTopic(AbsoluteTopicName topicName) {
            object[] results = this.Invoke("GetVersionsForTopic", new object[] {
                        topicName});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public void GetVersionsForTopicAsync(AbsoluteTopicName topicName) {
            this.GetVersionsForTopicAsync(topicName, null);
        }
        
        /// <remarks/>
        public void GetVersionsForTopicAsync(AbsoluteTopicName topicName, object userState) {
            if ((this.GetVersionsForTopicOperationCompleted == null)) {
                this.GetVersionsForTopicOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVersionsForTopicOperationCompleted);
            }
            this.InvokeAsync("GetVersionsForTopic", new object[] {
                        topicName}, this.GetVersionsForTopicOperationCompleted, userState);
        }
        
        private void OnGetVersionsForTopicOperationCompleted(object arg) {
            if ((this.GetVersionsForTopicCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVersionsForTopicCompleted(this, new GetVersionsForTopicCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/GetWikiVersion", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public WikiVersion GetWikiVersion() {
            object[] results = this.Invoke("GetWikiVersion", new object[0]);
            return ((WikiVersion)(results[0]));
        }
        
        /// <remarks/>
        public void GetWikiVersionAsync() {
            this.GetWikiVersionAsync(null);
        }
        
        /// <remarks/>
        public void GetWikiVersionAsync(object userState) {
            if ((this.GetWikiVersionOperationCompleted == null)) {
                this.GetWikiVersionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetWikiVersionOperationCompleted);
            }
            this.InvokeAsync("GetWikiVersion", new object[0], this.GetWikiVersionOperationCompleted, userState);
        }
        
        private void OnGetWikiVersionOperationCompleted(object arg) {
            if ((this.GetWikiVersionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetWikiVersionCompleted(this, new GetWikiVersionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/RestoreTopic", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RestoreTopic(AbsoluteTopicName topicName, string visitorIdentityString, string version) {
            this.Invoke("RestoreTopic", new object[] {
                        topicName,
                        visitorIdentityString,
                        version});
        }
        
        /// <remarks/>
        public void RestoreTopicAsync(AbsoluteTopicName topicName, string visitorIdentityString, string version) {
            this.RestoreTopicAsync(topicName, visitorIdentityString, version, null);
        }
        
        /// <remarks/>
        public void RestoreTopicAsync(AbsoluteTopicName topicName, string visitorIdentityString, string version, object userState) {
            if ((this.RestoreTopicOperationCompleted == null)) {
                this.RestoreTopicOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRestoreTopicOperationCompleted);
            }
            this.InvokeAsync("RestoreTopic", new object[] {
                        topicName,
                        visitorIdentityString,
                        version}, this.RestoreTopicOperationCompleted, userState);
        }
        
        private void OnRestoreTopicOperationCompleted(object arg) {
            if ((this.RestoreTopicCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RestoreTopicCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.flexwiki.com/webservices/SetTextForTopic", RequestNamespace="http://www.flexwiki.com/webservices/", ResponseNamespace="http://www.flexwiki.com/webservices/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetTextForTopic(AbsoluteTopicName topicName, string postedTopicText, string visitorIdentityString) {
            this.Invoke("SetTextForTopic", new object[] {
                        topicName,
                        postedTopicText,
                        visitorIdentityString});
        }
        
        /// <remarks/>
        public void SetTextForTopicAsync(AbsoluteTopicName topicName, string postedTopicText, string visitorIdentityString) {
            this.SetTextForTopicAsync(topicName, postedTopicText, visitorIdentityString, null);
        }
        
        /// <remarks/>
        public void SetTextForTopicAsync(AbsoluteTopicName topicName, string postedTopicText, string visitorIdentityString, object userState) {
            if ((this.SetTextForTopicOperationCompleted == null)) {
                this.SetTextForTopicOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetTextForTopicOperationCompleted);
            }
            this.InvokeAsync("SetTextForTopic", new object[] {
                        topicName,
                        postedTopicText,
                        visitorIdentityString}, this.SetTextForTopicOperationCompleted, userState);
        }
        
        private void OnSetTextForTopicOperationCompleted(object arg) {
            if ((this.SetTextForTopicCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetTextForTopicCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1433")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.flexwiki.com/webservices/")]
    public partial class ContentBase : BELObject {
        
        private System.DateTime createdField;
        
        private System.DateTime lastReadField;
        
        private bool secureField;
        
        private string descriptionField;
        
        private string contactField;
        
        private string imageURLField;
        
        private string homePageField;
        
        private bool displaySpacesInWikiLinksField;
        
        private string namespaceField;
        
        private string titleField;
        
        /// <remarks/>
        public System.DateTime Created {
            get {
                return this.createdField;
            }
            set {
                this.createdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastRead {
            get {
                return this.lastReadField;
            }
            set {
                this.lastReadField = value;
            }
        }
        
        /// <remarks/>
        public bool Secure {
            get {
                return this.secureField;
            }
            set {
                this.secureField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public string Contact {
            get {
                return this.contactField;
            }
            set {
                this.contactField = value;
            }
        }
        
        /// <remarks/>
        public string ImageURL {
            get {
                return this.imageURLField;
            }
            set {
                this.imageURLField = value;
            }
        }
        
        /// <remarks/>
        public string HomePage {
            get {
                return this.homePageField;
            }
            set {
                this.homePageField = value;
            }
        }
        
        /// <remarks/>
        public bool DisplaySpacesInWikiLinks {
            get {
                return this.displaySpacesInWikiLinksField;
            }
            set {
                this.displaySpacesInWikiLinksField = value;
            }
        }
        
        /// <remarks/>
        public string Namespace {
            get {
                return this.namespaceField;
            }
            set {
                this.namespaceField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ContentBase))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1433")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.flexwiki.com/webservices/")]
    public abstract partial class BELObject : ReflectedValueSource {
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(BELObject))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ContentBase))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1433")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.flexwiki.com/webservices/")]
    public abstract partial class ReflectedValueSource {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1433")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.flexwiki.com/webservices/")]
    public partial class WikiVersion {
        
        private int majorField;
        
        private int minorField;
        
        private int buildField;
        
        private int revisionField;
        
        /// <remarks/>
        public int Major {
            get {
                return this.majorField;
            }
            set {
                this.majorField = value;
            }
        }
        
        /// <remarks/>
        public int Minor {
            get {
                return this.minorField;
            }
            set {
                this.minorField = value;
            }
        }
        
        /// <remarks/>
        public int Build {
            get {
                return this.buildField;
            }
            set {
                this.buildField = value;
            }
        }
        
        /// <remarks/>
        public int Revision {
            get {
                return this.revisionField;
            }
            set {
                this.revisionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(AbsoluteTopicName))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1433")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.flexwiki.com/webservices/")]
    public abstract partial class TopicName {
        
        private string fullnameWithVersionField;
        
        private string versionField;
        
        private string fullnameField;
        
        private string nameField;
        
        private string namespaceField;
        
        /// <remarks/>
        public string FullnameWithVersion {
            get {
                return this.fullnameWithVersionField;
            }
            set {
                this.fullnameWithVersionField = value;
            }
        }
        
        /// <remarks/>
        public string Version {
            get {
                return this.versionField;
            }
            set {
                this.versionField = value;
            }
        }
        
        /// <remarks/>
        public string Fullname {
            get {
                return this.fullnameField;
            }
            set {
                this.fullnameField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string Namespace {
            get {
                return this.namespaceField;
            }
            set {
                this.namespaceField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1433")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.flexwiki.com/webservices/")]
    public partial class AbsoluteTopicName : TopicName {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void CanEditCompletedEventHandler(object sender, CanEditCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CanEditCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CanEditCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetAllNamespacesCompletedEventHandler(object sender, GetAllNamespacesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAllNamespacesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAllNamespacesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ContentBase[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ContentBase[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetAllTopicsCompletedEventHandler(object sender, GetAllTopicsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAllTopicsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAllTopicsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AbsoluteTopicName[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AbsoluteTopicName[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetDefaultNamespaceCompletedEventHandler(object sender, GetDefaultNamespaceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDefaultNamespaceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetDefaultNamespaceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ContentBase Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ContentBase)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetHtmlForTopicCompletedEventHandler(object sender, GetHtmlForTopicCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetHtmlForTopicCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetHtmlForTopicCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetHtmlForTopicVersionCompletedEventHandler(object sender, GetHtmlForTopicVersionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetHtmlForTopicVersionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetHtmlForTopicVersionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetPreviewForTopicCompletedEventHandler(object sender, GetPreviewForTopicCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPreviewForTopicCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPreviewForTopicCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetTextForTopicCompletedEventHandler(object sender, GetTextForTopicCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTextForTopicCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTextForTopicCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetVersionsForTopicCompletedEventHandler(object sender, GetVersionsForTopicCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVersionsForTopicCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVersionsForTopicCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void GetWikiVersionCompletedEventHandler(object sender, GetWikiVersionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetWikiVersionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetWikiVersionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public WikiVersion Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WikiVersion)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void RestoreTopicCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1433")]
    public delegate void SetTextForTopicCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TitlePropPro\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OutlookHelper\OutlookHelper\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("OutlookHelper")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("OutlookHelper")]
[assembly: AssemblyCopyright("Copyright © MSIT 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("55fd84cf-ef79-4503-992b-16753bb91848")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TitlePropPro\EnvironmentData.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace TPP
{
    internal class EnvironmentData
    {
        private string _envName = "";
        private string _lbSvr = "";
        private string _matchSvr = "";
        private string _titleSource = "";
        private string _logLocation = "";
        private string _manifest = "";

        public EnvironmentData(string envName)
        {
            _envName = envName;
        }

        public string Name
        {
            get { return _envName; }
            set { _envName = value; }
        }

        public string LBSvr
        {
            get { return _lbSvr; }
            set { _lbSvr = value; }
        }

        public string MatchSvr
        {
            get { return _matchSvr; }
            set { _matchSvr = value; }
        }

        public string TitleSource
        {
            get { return _titleSource; }
            set { _titleSource = value; }
        }

        public string Manifest
        {
            get { return _manifest; }
            set { _manifest = value; }
        }

        public string LogLocation
        {
            get { return _logLocation; }
            set { _logLocation = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TitlePropPro\PropThreadState.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.XPath;

namespace TPP
{
    internal class PropThreadState
    {
        public EnvironmentData EnvironmentData;
        public XPathNavigator TitleNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TitlePropPro\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TitlePropPro\ProcessWrapper.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Threading;

namespace TPP
{
    /// <summary>
    /// Provides a way to run a process and capture it's output.
    /// </summary>
    public class ProcessWrapper
    {
        protected string _processName;
        protected string _exePath;
        protected string _workingDirectory;
        protected int _executeTimeout;
        protected string _output;
        protected string _error;
        protected Dictionary<string, string> _environmentVariables;

        public ProcessWrapper()
        {
            _processName = "";
            _exePath = "";
            _workingDirectory = "";
            _executeTimeout = 120;
            _output = "";
            _environmentVariables = null;
        }

        public ProcessWrapper(string name, string path) : this()
        {
            _processName = name;
            _exePath = path;
        }

        public ProcessWrapper(string name, string path, string workingDir, int timeout)
        {
            _processName = name;
            _exePath = path;
            _workingDirectory = workingDir;
            _executeTimeout = timeout;
            _output = "";
        }

        /// <summary>
        /// Gets or sets the friendly name of the process.
        /// </summary>
        public string ProcessName
        {
            get { return _processName; }
            set { _processName = value; }
        }

        /// <summary>
        /// Gets or sets the fully-qualified path to the process executable.
        /// </summary>
        public string ExecutablePath
        {
            get { return _exePath; }
            set { _exePath = value; }
        }

        /// <summary>
        /// Gets or sets the name of the working directory.
        /// </summary>
        public string WorkingDirectory
        {
            get { return _workingDirectory; }
            set { _workingDirectory = value; }
        }

        /// <summary>
        /// Gets or sets the number of seconds to allow the process to run before abandoning it. Default is 120.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _executeTimeout; }
            set { _executeTimeout = value; }
        }

        /// <summary>
        /// Gets the text written by the running process to the Standard Output stream.
        /// </summary>
        public string Output
        {
            get { return _output; }
        }

        /// <summary>
        /// Gets the text written by the running process to the Standard Error stream.
        /// </summary>
        public string Error
        {
            get { return _error; }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append( "ProcessName      = " + _processName + "\r\n" );
            sb.Append( "ExePath          = " + _exePath + "\r\n" );
            sb.Append( "WorkingDirectory = " + _workingDirectory + "\r\n" );
            sb.Append( "ExecuteTimeout   = " + _executeTimeout + "\r\n" );
            return sb.ToString();
        }

        public void SetEnvironmentVariable(string variableName, string value)
        {
            if (variableName == null)
            {
                throw new ArgumentNullException("variableName");
            }

            if (variableName.Length > 0)
            {
                if (_environmentVariables == null)
                {
                    _environmentVariables = new Dictionary<string, string>();
                }

                if (_environmentVariables.ContainsKey(variableName))
                {
                    // Replace the existing value of the environment variable
                    // Zero-length values will cause the variable to be removed later
                    if (value == null)
                    {
                        value = "";
                    }
                    _environmentVariables[variableName] = value;
                }
                else
                {
                    // null or zero-length values are invalid
                    if (value == null || value.Length == 0)
                    {
                        throw new ArgumentException("Cannot set a blank environment variable value.");
                    }
                    _environmentVariables.Add(variableName, value);
                }
            }
        }

        /// <summary>
        /// Method to run the process with the specified arguments.
        /// </summary>
        /// <param name="arguments">The command line arguments to send to the process.</param>
        /// <returns>The return code from the process.</returns>
        /// <remarks>
        /// The following exceptions can be thrown by this method:
        ///        ArgumentNullException        If the arguments string is null.
        ///        ProcessException            If the timeout expired waiting for the process to finish.
        ///        
        /// These exceptions can be thrown from the Process.Start method:
        ///        InvalidOperationException
        ///        Win32Exception
        ///        ObjectDisposedException
        /// </remarks>
        public int Run(string arguments)
        {
            if (arguments == null)
                throw new ArgumentNullException("arguments");

            Process process = new Process();
            ProcessOutputReader por = new ProcessOutputReader(process, false);
            ProcessOutputReader per = new ProcessOutputReader(process, true);
            Thread readThreadOut = new Thread(new ThreadStart(por.ReadOutput));
            Thread readThreadErr = new Thread(new ThreadStart(per.ReadOutput));
            bool processTimedOut = false;

            process.StartInfo.FileName = _exePath;
            process.StartInfo.WorkingDirectory = _workingDirectory;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.Arguments = arguments.Trim();
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.CreateNoWindow = true;

            // Set any defined environment variables
            if (_environmentVariables != null)
            {
                foreach (KeyValuePair<string, string> kvp in _environmentVariables)
                {
                    if (process.StartInfo.EnvironmentVariables.ContainsKey(kvp.Key))
                    {
                        // Replace the existing value. If the value is
                        // zero-length, remove the variable from the list
                        if (kvp.Value.Length > 0)
                        {
                            process.StartInfo.EnvironmentVariables[kvp.Key] = kvp.Value;
                        }
                        else
                        {
                            process.StartInfo.EnvironmentVariables.Remove(kvp.Key);
                        }
                    }
                    else
                    {
                        // Don't bother setting blank variables
                        if (kvp.Value.Length > 0)
                        {
                            process.StartInfo.EnvironmentVariables.Add(kvp.Key, kvp.Value);
                        }
                    }
                }
            }

            try
            {
                process.Start();

                // Start the read output threads
                readThreadOut.Start();
                readThreadErr.Start();

                if (-1 == _executeTimeout)
                {
                    process.WaitForExit();
                }
                else
                {
                    // Wait for the process to end or the timeout to expire
                    processTimedOut = !process.WaitForExit(_executeTimeout * 1000);
                }
            }
            catch (ThreadAbortException) //if we're going down, take our spawned process out too
            {
                process.Kill();
            }
            finally
            {
                // Wait for all the output to be read
                if (readThreadOut.ThreadState == System.Threading.ThreadState.Running)
                    readThreadOut.Join(10000);
                if (readThreadErr.ThreadState == System.Threading.ThreadState.Running)
                    readThreadErr.Join(10000);

                _output = por.Output;
                _error = per.Output;
            }

            if (processTimedOut)
                throw new ProcessException(_processName, "Timeout waiting for the process to finish.", _output);

            return process.ExitCode;
        }
    }

    /// <summary>
    /// Thread procedure wrapper that allows data to be passed in and out of the procedure.
    /// Used to read process output.
    /// </summary>
    internal class ProcessOutputReader
    {
        private Process _runningProcess;
        private string _stdOut;
        private bool readStdErr;

        internal ProcessOutputReader(Process RunningProcess, bool useStdErrInsteadOfStdOut)
        {
            if (RunningProcess == null)
            {
                throw new ArgumentNullException("RunningProcess");
            }

            _runningProcess = RunningProcess;
            _stdOut = String.Empty;
            readStdErr=useStdErrInsteadOfStdOut;
        }

        internal string Output
        {
            get { return _stdOut; }
        }

        internal void ReadOutput()
        {
            // Sit in a loop reading the Standard Output buffer until
            // the process has been marked terminated and the buffer is empty.
            int bufferLength = 4096;
            int outputCharsRead = 0;
            char [] buffer = new char[bufferLength];
            StringBuilder outputData = new StringBuilder(bufferLength);
            StringBuilder echoBuffer = new StringBuilder(bufferLength);
            do
            {
                if (!readStdErr)
                {
                    outputCharsRead = _runningProcess.StandardOutput.Read(buffer, 0, bufferLength);
                }
                else
                {
                    outputCharsRead = _runningProcess.StandardError.Read(buffer, 0, bufferLength);
                }

                if (outputCharsRead > 0)
                {
                    outputData.Append(buffer, 0, outputCharsRead);
                }
            } while (!(outputCharsRead == 0 && _runningProcess.HasExited));

            _stdOut = outputData.ToString();
        }
    }

    public class ProcessException : Exception
    {
        protected string _output = "";
        protected string name = "";

        public ProcessException(string _processName) : base()
        {
            name = _processName;
        }
        public ProcessException(string _processName, string message) : base(message)
        {
            name = _processName;
        }
        public ProcessException(string _processName, string message, Exception innerException) :
            base (message, innerException)
        {
            name = _processName;
        }
        public ProcessException(string _processName, string message, string processOutput) : base(message)
        {
            name = _processName;
            _output = processOutput;
        }
        public ProcessException(string _processName, string message, string processOutput, Exception innerException) :
            base (message, innerException)
        {
            name = _processName;
            _output = processOutput;
        }

        public string ProcessOutput
        {
            get { return _output; }
            set { _output = value; }
        }

        public string ProcessName
        {
            get { return name; }
            set { name = value; }
        }

        public override string Message
        {
            get
            {
                if (name.Length > 0)
                    return name + ": " + base.Message;
                else
                    return base.Message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TPP\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\PacdConfigTest\PacdConfigTest\PacdConfigTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using System.Diagnostics;
using System.Data.Sql;
using System.Data.SqlClient;
using System.Xml;
using System.IO;


namespace PacdConfigTest
{



    [TestGroup]
    public class PacdConfigTests : TestNode
    {
        static Report reportObj = new Report("PacdConfigTests");
        static string INPUTLOCATION = @"C:\Users\josephfo\Documents\TestStuff\PartnerXmlFiles\";

        [TestGroup]
        public class SyncTests : TestNode
        {
            [TestCase]
            public class SyncToProductionFile : TestNode
            {
                public override void Run()
                {
                    string fileName = INPUTLOCATION + "SyncToProductionFile.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Sync " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);

                    if (Partner.ComparePartners(filePartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class SyncToOnePartner : TestNode
            {
                public override void Run()
                {
                    string fileName = INPUTLOCATION + "SyncToOnePartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Sync " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);

                    if (Partner.ComparePartners(filePartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class SyncToZeroPartners : TestNode
            {
                public override void Run()
                {
                    string fileName = INPUTLOCATION + "SyncToZeroPartners.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Sync " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);

                    if (Partner.ComparePartners(filePartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

        }


        [TestGroup]
        public class UpdateTests : TestNode
        {
            [TestCase]
            public class UpdateOneNewPartner : TestNode
            {
                public override void Run()
                {
                    WebDB.DeletePartner(76);
                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }


                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);

                    // originalPartners object will be merged with filePartners with this call
                    Partner.UpdatePartners(originalPartners, filePartners);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateExistingPartnerAddOneNewAPI : TestNode
            {
                public override void Run()
                {
                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("Deleting partner 76 api 'LiveProxy.GetSiteInfo'");
                    WebDB.DeletePartnerAPI(76, "LiveProxy.GetSiteInfo");

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // re-add the partner to re-add the missing API
                    fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);
                    Partner.UpdatePartners(originalPartners, filePartners);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class UpdateExistingPartnerAddOneNewTitle : TestNode
            {
                public override void Run()
                {
                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("Deleting partner 76 title 1161889920");
                    WebDB.DeletePartnerTitle(76, 1161889920);

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // re-add the partner to re-add the missing Title
                    fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);
                    Partner.UpdatePartners(originalPartners, filePartners);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateExistingPartnerNothingNew : TestNode
            {
                public override void Run()
                {
                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // re-add the partner to re-add the missing Title
                    fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    
                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }
            

            [TestCase]
            public class UpdateSinglePartnerWithOneTitleNoAPI : TestNode
            {
                public override void Run()
                {
                    WebDB.DeletePartner(76);
                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateSinglePartnerWithOneTitleNoAPI.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);
                    Partner.UpdatePartners(originalPartners, filePartners);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateSinglePartnerWithNoTitleOneAPI : TestNode
            {
                public override void Run()
                {
                    WebDB.DeletePartner(76);
                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateSinglePartnerWithNoTitleOneAPI.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> filePartners = Partner.GetPartnersFromFile(fileName);
                    Partner.UpdatePartners(originalPartners, filePartners);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateExistingPartnerWithLessPermissions : TestNode
            {
                public override void Run()
                {
                    // 1. delete partner 76
                    // 2. /update partner 76 with full permissions.
                    // 3. /update partner 76 with fewer permissions.
                    // 4. expected: Full permissions on partner 76 should still exist.

                    WebDB.DeletePartner(76);
                    
                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with less API permissions, less title permissions and less IPs.
                    fileName = INPUTLOCATION + "UpdateExistingPartnerWithLessPermissions.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();

                    // before and after this import should be the same.

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }



            [TestCase]
            public class UpdateChangePartnerDescription : TestNode
            {
                public override void Run()
                {
                    // 1. delete partner 76
                    // 2. /update partner 76 to add original partner 76
                    // 3. /update partner 76 with different description
                    // 4. expected: different description should exist.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerDescription.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class UpdateChangePartnerGroup : TestNode
            {
                public override void Run()
                {
                    // 1. delete partner 76
                    // 2. /update partner 76 to add original partner 76
                    // 3. /update partner 76 with different group - from 3 to 2.
                    // 4. expected: different group should exist.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());


                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerGroup.xml";

                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());


                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateChangePartnerCertName : TestNode
            {
                public override void Run()
                {
                    // 1. delete partner 76
                    // 2. /update partner 76 to add original partner 76
                    // 3. /update partner 76 with different group - from 3 to 2.
                    // 4. expected: different group should exist.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";

                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerCertName.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }



            [TestCase]
            public class UpdateChangePartnerCredType : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.
                    
                    WebDB.DeletePartner(76);

                    WebDB.AddCredType(5, "NewCredType");

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerCredType.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateChangePartnerAPIsFewer : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerAPIsFewer.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }



            [TestCase]
            public class UpdateChangePartnerAPIsMore : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerAPIsMore.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }



            [TestCase]
            public class UpdateChangePartnerTitlesFewer : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerTitlesFewer.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }



            [TestCase]
            public class UpdateChangePartnerTitlesMore : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerTitlesMore.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class UpdateChangePartnerIPsFewer : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnerIPsFewer.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdateChangePartnerIPsMore : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdateOneNewPartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // import same partner with different description
                    fileName = INPUTLOCATION + "UpdateChangePartnersIPsMore.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class NegUpdateDuplicatePartner : TestNode
            {
                public override void Run()
                {
                    // 1. Sync with prod partners.
                    // 2. Update with duplicate APIs
                    // 3. Verify PartnerConfig.exe fails.
                    // 4. Verify nothing changes in the WebDB
 
                    string fileName = INPUTLOCATION + "SyncToProductionFile.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Sync " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does pass with 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }
                    

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    // attempt to update with duplicate partner 76
                    fileName = INPUTLOCATION + "UpdateDuplicatePartner.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Import " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("PartnerConfig.exe does not fail with -1 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("WebDB partners did not change after failure. This is good.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("WebDB partners changed even though PartnerConfig.exe failed.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class NegUpdateDuplicateAPI : TestNode
            {
                public override void Run()
                {
                    string fileName = INPUTLOCATION + "SyncToProductionFile.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Sync " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());
                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not pass with 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();

                    fileName = INPUTLOCATION + "NegUpdateDuplicateAPI.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    args = "/Sync " + fileName;
                    returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("PartnerConfig.exe does not fail with -1 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();


                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("WebDB partners did not change after failure. This is good.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("WebDB partners changed even though PartnerConfig.exe failed.");
                        return TEST_RESULTS.FAILED;
                    }

                }
            }

            [TestCase]
            public class NegUpdatePartnerFileDNE : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "FileDoesNotExist.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("PartnerConfig.exe does not fail with -1 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("PartnerConfig.exe fails as expected when bad IP address in XML.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class NegUpdateBadXml : TestNode
            {
                public override void Run()
                {
                    WebDB.DeletePartner(76);

                    string fileName = INPUTLOCATION + "NegUpdateBadXml.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("PartnerConfig.exe does not fail with -1 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("PartnerConfig.exe fails as expected when bad IP address in XML.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase]
            public class NegUpdateParnterAPIDNE : TestNode
            {
                public override void Run()
                {
                    WebDB.DeletePartner(76);

                    string fileName = INPUTLOCATION + "NegUpdateParnterAPIDNE.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    return TEST_RESULTS.PASSED;                    
                }
            }

            [TestCase]
            public class NegUpdatePartnerBadIP : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "NegUpdatePartnerBadIP.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("PartnerConfig.exe does not fail with -1 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("PartnerConfig.exe fails as expected when bad IP address in XML.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase]
            public class NegUpdatePartnerSlightlyBadIP : TestNode
            {
                public override void Run()
                {
                    // This test case is failing - bug 24271
                    // right now, it is adding the bad IP to the database as an INT.
                    // it might be allowed to NOT fail, and just ignore the bad IP.
                    // if so, need to change this test case.

                    WebDB.DeletePartner(76);

                    // first, add the partner.
                    string fileName = INPUTLOCATION + "NegUpdatePartnerSlightlyBadIP.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("PartnerConfig.exe does not fail with -1 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("PartnerConfig.exe fails as expected when bad IP address in XML.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase]
            public class UpdatePartnerMaxIPMask : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();
                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdatePartnerMaxIPMask.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not pass with 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class UpdatePartnerMinIPMask : TestNode
            {
                public override void Run()
                {
                    // Typically there is only one cred type = 1 = passport.
                    // Need to add a fake cred type to allow us to change the value.

                    WebDB.DeletePartner(76);

                    Dictionary<Int32, Partner> originalPartners = Partner.GetPartnersFromDB();
                    // first, add the partner.
                    string fileName = INPUTLOCATION + "UpdatePartnerMinIPMask.xml";
                    reportObj.Info("Starting PartnerConfig.exe...");
                    String args = "/Import " + fileName;
                    Int32 returnCode = StartProcess(@"C:\\ESP\\Webroot\\xbltools", "PartnerConfig.exe", args);
                    reportObj.Info("PartnerConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("PartnerConfig.exe does not pass with 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<Int32, Partner> actualPartners = Partner.GetPartnersFromDB();
                    Dictionary<Int32, Partner> partnersFromFile = Partner.GetPartnersFromFile(fileName);

                    Partner.UpdatePartners(originalPartners, partnersFromFile);

                    if (Partner.ComparePartners(originalPartners, actualPartners))
                    {
                        reportObj.Info("All database and xml partners match.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("DB and Xml partners do not match. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


        }

        public enum EsbrRating
        { 
            UNSPECIFIED=7,
            MATURE=2,
            TEEN=1
        }


        public class Partner
        {
            private Int32 partnerId;
            private Int32 groupId;
            private string description;
            private string certificateName;
            private Int32 credentialType;
            private List<IPAddressAndMask> ipAddressList;
            private List<string> apiList;
            private List<Title> titleList;
            
            static string cnString = "Data Source=Paulramvxb409;Initial Catalog=webdb;Integrated Security=True";

            public Partner()
            {
                this.ipAddressList = new List<IPAddressAndMask>();
                this.apiList = new List<string>();
                this.titleList = new List<Title>();
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("PartnerId: ");
                sb.Append(this.partnerId);
                sb.Append(Environment.NewLine);
                sb.Append("Group Id: ");
                sb.Append(this.GroupId);
                sb.Append(Environment.NewLine);
                sb.Append("Description: ");
                sb.Append(this.Description);
                sb.Append(Environment.NewLine);
                sb.Append("CertificateName: ");
                sb.Append(this.CertificateName);
                sb.Append(Environment.NewLine);
                return sb.ToString();
            }

            public Partner(Int32 PartnerId, Int32 GroupId, string Description, string CertificateName, Int32 CredentialType)
            {
                this.ipAddressList = new List<IPAddressAndMask>();
                this.apiList = new List<string>();
                this.titleList = new List<Title>();
                this.partnerId = PartnerId;
                this.groupId = GroupId;
                this.description = Description;
                this.certificateName = CertificateName;
                this.credentialType = CredentialType;
            }

            public Int32 PartnerId
            {
                get { return this.partnerId; }
                set { this.partnerId = value; }
            }

            public Int32 GroupId
            {
                get { return this.groupId; }
                set { this.groupId = value; }
            }

            public string Description
            {
                get { return this.description; }
                set { this.description = value; }
            }

            public string CertificateName
            {
                get { return this.certificateName; }
                set { this.certificateName = value; }
            }

            public Int32 CredType
            {
                get { return this.credentialType; }
                set { this.credentialType = value; }
            }

            public List<string> APIList
            {
                get { return this.apiList; }
                set { this.apiList = value; }
            }

            public List<Title> TitleList
            {
                get { return this.titleList; }
                set { this.titleList = value; }
            }

            public List<IPAddressAndMask> IPAddressList
            {
                get { return this.ipAddressList; }
                set { this.ipAddressList = value; }
            }

            public static void UpdatePartners(Dictionary<Int32, Partner> PartnersDB, Dictionary<Int32,Partner> PartnersFile)
            {
                foreach (KeyValuePair<Int32, Partner> partner in PartnersFile)
                { 
                    //  first, if this is a new partner, then just add the partner and continue.
                    if (!PartnersDB.ContainsKey(partner.Key))
                    {
                        PartnersDB.Add(partner.Key, partner.Value);
                        continue;
                    }

                    // if we are here, then this partner already exists in the DB.
                    // We need to merge it with existing partner data.
                    
                    // Merge the partner info.
                    PartnersDB[partner.Key].GroupId = partner.Value.GroupId;
                    PartnersDB[partner.Key].Description = partner.Value.Description;
                    PartnersDB[partner.Key].CertificateName = partner.Value.CertificateName;
                    PartnersDB[partner.Key].CredType = partner.Value.CredType;

                    // Merge the APIs.  If api list does not contain the api, then add it.
                    foreach (string api in partner.Value.APIList)
                    {
                        if (!PartnersDB[partner.Key].APIList.Contains(api))
                        {
                            PartnersDB[partner.Key].APIList.Add(api);
                        }
                    }

                    // Merge the Titles
                    foreach (Title title in partner.Value.TitleList)
                    {
                        Int32 index = PartnersDB[partner.Key].TitleList.IndexOf(title);

                        if (index == -1)
                        {
                            // add title if it does not already exist.
                            PartnersDB[partner.Key].TitleList.Add(title);
                        }
                        else
                        {
                            // update title info since this title already exists.
                            PartnersDB[partner.Key].TitleList[index].Privileges = title.Privileges;
                            PartnersDB[partner.Key].TitleList[index].Rating = title.Rating;
                            PartnersDB[partner.Key].TitleList[index].ClusterId = title.ClusterId;                           
                        }                        
                    }

                    // Merge the IPs.
                    foreach (IPAddressAndMask ipmask in partner.Value.IPAddressList)
                    {
                        Int32 index = PartnersDB[partner.Key].IPAddressList.IndexOf(ipmask);

                        if (index == -1)
                        {
                            // add IP/Mask if it does not already exist.
                            PartnersDB[partner.Key].IPAddressList.Add(ipmask);
                        }
                        else
                        {
                            // update the mask since the ip already exists.
                            PartnersDB[partner.Key].IPAddressList[index].uIntMaskAddress = ipmask.uIntMaskAddress;
                        }
                    }
                }
            }


            public static Dictionary<Int32, Partner> GetPartnersFromDB()
            {
                Dictionary<Int32, Partner> partners = new Dictionary<int, Partner>();
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "SELECT i_partner_id FROM t_partners";
                SqlCommand cmd = new SqlCommand(sql, cn);
                SqlDataReader dr = cmd.ExecuteReader();

                while (dr.Read())
                {
                    Int32 partnerId = (Int32)dr["i_partner_id"];
                    Partner p = GetPartnerFromDB(partnerId);
                    partners.Add(p.PartnerId, p);
                }
                return partners;
            }

            public static Partner GetPartnerFromDB(Int32 PartnerId)
            {
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                Partner dbPartner = new Partner();
                string sql = "select i_partner_id, i_partner_group_id, vc_subject_name, i_cred_type, vc_description FROM t_partners WHERE i_partner_id=" + PartnerId.ToString();
                SqlCommand cmd = new SqlCommand(sql, cn);
                SqlDataReader dr = cmd.ExecuteReader();

                // should only be 1 row!
                dr.Read();
                dbPartner.PartnerId = (Int32) dr["i_partner_id"];
                dbPartner.GroupId = (Int32) dr["i_partner_group_id"];
                dbPartner.Description = (string)dr["vc_description"];
                dbPartner.CredType = (Int32)dr["i_cred_type"];
                dbPartner.CertificateName = (string)dr["vc_subject_name"];
                dbPartner.APIList = GetPartnerAPIsFromDB(PartnerId);
                dbPartner.IPAddressList = GetPartnerIpsFromDB(PartnerId);
                dbPartner.TitleList = GetPartnerTitlesFromDB(PartnerId);

                dr.Close();
                cn.Close();

                return dbPartner;                
            }

            public static List<string> GetPartnerAPIsFromDB(Int32 PartnerId)
            {
                List<string> apiList = new List<string>();
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "SELECT vc_api_name FROM t_partner_allowed_apis WHERE i_partner_id=" + PartnerId.ToString();
                SqlCommand cmd = new SqlCommand(sql, cn);
                SqlDataReader dr = cmd.ExecuteReader();
                while (dr.Read())
                {
                    apiList.Add((string)dr["vc_api_name"]);
                }

                dr.Close();
                cn.Close();
                return apiList;
            }


            public static List<Title> GetPartnerTitlesFromDB(Int32 PartnerId)
            {
                List<Title> titleList = new List<Title>();
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();
                
                string sql = "SELECT t.i_title_id, i_title_privilege, t.ti_esrb_rating, i_cluster_id " +
                    "FROM t_partner_allowed_titles a, t_title_info t " +
                    "WHERE a.i_title_id=t.i_title_id " +
                    "AND a.i_partner_id=" + PartnerId;

                SqlCommand cmd = new SqlCommand(sql, cn);
                SqlDataReader dr = cmd.ExecuteReader();
                while (dr.Read())
                {
                    Title newTitle = new Title();
                    newTitle.TitleId = (Int32)dr["i_title_id"];
                    newTitle.Privileges = (Int32)dr["i_title_privilege"];
                    newTitle.Rating = Enum.GetName(typeof(EsbrRating), (Byte)dr["ti_esrb_rating"]);
                    newTitle.ClusterId = (Int32)dr["i_cluster_id"];
                    titleList.Add(newTitle);
                }

                dr.Close();
                cn.Close();
                return titleList;
            }

            public static List<IPAddressAndMask> GetPartnerIpsFromDB(Int32 PartnerId)
            {
                List<IPAddressAndMask> ips = new List<IPAddressAndMask>();

                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "SELECT i_ip, i_mask FROM t_partner_ips WHERE i_partner_id=" + PartnerId.ToString();
                SqlCommand cmd = new SqlCommand(sql, cn);
                SqlDataReader dr = cmd.ExecuteReader();

                while (dr.Read())
                {
                    IPAddressAndMask newIpMask = new IPAddressAndMask();
                    byte[] ipBytes = BitConverter.GetBytes((Int32)dr["i_ip"]);
                    byte[] maskBytes = BitConverter.GetBytes((Int32)dr["i_mask"]);
                    
                    newIpMask.uIntIPAddress = BitConverter.ToUInt32(ipBytes, 0);
                    newIpMask.uIntMaskAddress = BitConverter.ToUInt32(maskBytes, 0);
                    ips.Add(newIpMask);
                }

                dr.Close();
                cn.Close();

                return ips;                
            }



            public static Dictionary<Int32, Partner> GetPartnersFromFile(String FileName)
            {
                Dictionary<Int32, Partner> partners = new Dictionary<int, Partner>();
                XmlDocument xml = new XmlDocument();
                if (File.Exists(FileName))
                {
                    xml.Load(FileName);
                }
                else
                {
                    reportObj.Error("File does not exist: " + FileName);
                }

                XmlNodeList partnerNodes = xml.SelectNodes("//Partner");

                foreach (XmlNode partnerNode in partnerNodes)
                {
                    Partner newPartner = new Partner();
                    newPartner.PartnerId = Int32.Parse(partnerNode.Attributes["ID"].Value);
                    newPartner.Description = partnerNode.Attributes["Description"].Value;
                    newPartner.CertificateName = partnerNode.Attributes["CertificateName"].Value;
                    newPartner.GroupId = Int32.Parse(partnerNode.Attributes["GroupID"].Value);
                    newPartner.CredType = Int32.Parse(partnerNode.Attributes["CredentialType"].Value);


                    XmlNodeList apiNodes = partnerNode.SelectNodes("APIs/API");
                    foreach (XmlNode apiNode in apiNodes)
                    {
                        newPartner.APIList.Add(apiNode.Attributes["Name"].Value);
                    }

                    XmlNodeList titleNodes = partnerNode.SelectNodes("Titles/Title");
                    foreach (XmlNode titleNode in titleNodes)
                    {
                        Title newTitle = new Title();
                        // titleIds are stored in the DB as signed Int32, but stored in the file as uInt32
                        // Need to convert this from uInt32 back to Int32 to prevent overflow.
                        UInt32 tmp = UInt32.Parse(titleNode.Attributes["TitleID"].Value);
                        if (tmp > Int32.MaxValue)
                        {
                            newTitle.TitleId = (Int32) (tmp - 4294967296);
                        }
                        else
                        {
                            newTitle.TitleId = (Int32) tmp;
                        }
                        newTitle.Privileges = Int32.Parse(titleNode.Attributes["Privileges"].Value);
                        newTitle.ClusterId = Int32.Parse(titleNode.Attributes["ClusterID"].Value);
                        newTitle.Rating = titleNode.Attributes["Rating"].Value;
                        newPartner.TitleList.Add(newTitle);
                    }

                    XmlNodeList ipNodes = partnerNode.SelectNodes("IPAddresses/IPAddress");
                    foreach (XmlNode ipNode in ipNodes)
                    {                        
                        String ipMaskString = ipNode.Attributes["address"].Value;
                        String[] ipMaskArray = ipMaskString.Split(':');
                        String ipString = ipMaskArray[0];
                        String maskString = ipMaskArray[1];
                        newPartner.IPAddressList.Add(new IPAddressAndMask(ipString, maskString));
                    }
                    partners.Add(newPartner.partnerId, newPartner);
                }

                return partners;
            }

            public static Boolean ComparePartners(Dictionary<Int32, Partner> source, Dictionary<Int32, Partner> dest)
            {
                foreach (KeyValuePair<Int32, Partner> partner in source)
                {
                    if (dest.ContainsKey(partner.Key))
                    {
                        if (partner.Value.Equals(dest[partner.Key]))
                        {
                            reportObj.Info("Partners are equal.");
                        }
                        else
                        {
                            reportObj.Error("Partners are not equal.");
                            return false;
                        }
                        dest.Remove(partner.Key);
                    }
                    else
                    {
                        reportObj.Error("Missing Partner:");
                        reportObj.Error(partner.Value.ToString());
                        return false;
                    }
                }

                if (dest.Count > 0)
                {
                    reportObj.Error("There are too many partners in the destination list. The extra partners are:");
                    foreach (KeyValuePair<Int32, Partner> partner in dest)
                    {
                        reportObj.Error(partner.Value.ToString());
                    }
                    return false;
                }

                reportObj.Info("ComparePartners returns all partners are equal.");
                return true;
            }

            //public void AddIpAddress(String Address)
            //{
            //    this.ipAddressList.Add(Address);
            //}

            public void AddAPI(String ApiName)
            {
                this.apiList.Add(ApiName);
            }

            public override bool Equals(object obj)
            {
                if (obj == null) return false;

                if (this.GetType() != obj.GetType()) return false;

                Partner partner = (Partner)obj;

                if (Object.Equals(this.partnerId, partner.partnerId))
                {
                    reportObj.Info("Verified partnerId field matches. They are both: " + partner.partnerId);
                }
                else
                {
                    reportObj.Error("partnerId fields to not match.");
                    reportObj.Error("Expected: " + this.partnerId);
                    reportObj.Error("Actual: " + partner.partnerId);
                    return false;
                }

                if (Object.Equals(this.groupId, partner.groupId))
                {
                    reportObj.Info("Verified groupId field matches. They are both: " + partner.groupId);
                }
                else
                {
                    reportObj.Error("groupId fields to not match.");
                    reportObj.Error("Expected: " + this.groupId);
                    reportObj.Error("Actual: " + partner.groupId);
                    return false;
                }

                if (Object.Equals(this.description, partner.description))
                {
                    reportObj.Info("Verified description field matches. They are both: " + partner.description);
                }
                else
                {
                    reportObj.Error("description fields to not match.");
                    reportObj.Error("Expected: " + this.description);
                    reportObj.Error("Actual: " + partner.description);
                    return false;
                }

                if (Object.Equals(this.certificateName, partner.certificateName))
                {
                    reportObj.Info("Verified certificateName field matches. They are both: " + partner.certificateName);
                }
                else
                {
                    reportObj.Error("certificateName fields to not match.");
                    reportObj.Error("Expected: " + this.certificateName);
                    reportObj.Error("Actual: " + partner.certificateName);
                    return false;
                }

                if (Object.Equals(this.credentialType, partner.credentialType))
                {
                    reportObj.Info("Verified credentialType field matches. They are both: " + partner.credentialType);
                }
                else
                {
                    reportObj.Error("credentialType fields to not match.");
                    reportObj.Error("Expected: " + this.credentialType);
                    reportObj.Error("Actual: " + partner.credentialType);
                    return false;
                }

                // check API lists
                foreach (String api in this.apiList)
                {
                    if (partner.apiList.Contains(api))
                    {
                        partner.apiList.Remove(api);
                    }
                    else
                    {
                        reportObj.Error("Missing API in api list: " + api);
                        return false;
                    }
                }
                
                if (partner.apiList.Count != 0)
                {
                    reportObj.Error("Extra apis in the source api list:");
                    foreach (string api in partner.apiList)
                    {
                        reportObj.Error(api);
                    }
                    return false;
                }


                // check Title lists
                foreach (Title this_title in this.titleList)
                {
                    // if the title is not loaded, then skip the check because
                    // partnerconfig.exe should not populate t_partner_allowed_titles for
                    // unloaded titles.

                    if (!Title.IsTitleLoaded(title.TitleId))
                        continue;

                    if (partner.titleList.Contains(title))
                    {
                        // first, if the titleIds do not match, then just go to the next title.
                        if (this_title.TitleId != partner_title.TitleId) continue;
                        titleFound = true;
                        // Since the title is found, check all the other values.

                        // don't care about clusterId because we should not be changing the title clusterid.
                        // even if the file has something different than the t_title_info table.
                        //if (this_title.ClusterId == partner_title.ClusterId)
                        //{
                        //    reportObj.Info("ClusterId values match. They are both: " + this_title.ClusterId.ToString());
                        //}
                        //else
                        //{
                        //    reportObj.Error("ClusterIds do NOT match.");
                        //    reportObj.Error("this_title.ClusterId is " + this_title.ClusterId.ToString());
                        //    reportObj.Error("partner_title.ClusterId is " + partner_title.ClusterId.ToString());
                        //    return false;
                        //}

                        // DO check privileges, because that is specific to the t_partner_allowed_titles table.
                        if (this_title.Privileges == partner_title.Privileges)
                        {
                            reportObj.Info("Privilieges match.  They are both: " + this_title.Privileges.ToString());
                        }
                        else
                        {
                            reportObj.Error("Privileges do NOT match.");
                            reportObj.Error("this_title.Privileges is " + this_title.Privileges.ToString());
                            reportObj.Error("partner_title.Privileges is " + partner_title.Privileges.ToString());
                            return false;
                        }

                        // Don't care about rating because it is specific to the title. (not the partner_allowed_titles.

                        //if (this_title.Rating == partner_title.Rating)
                        //{
                        //    reportObj.Info("Rating match.  They are both: " + this_title.Rating.ToString());
                        //}
                        //else
                        //{
                        //    reportObj.Error("Ratings do NOT match.");
                        //    reportObj.Error("this_title.Rating is " + this_title.Rating.ToString());
                        //    reportObj.Error("partner_title.Rating is " + partner_title.Rating.ToString());
                        //    return false;
                        //}
                    }

                    Boolean titleLoaded = Title.IsTitleLoaded(this_title.TitleId);

                    if (titleFound & titleLoaded)
                    {
                        // this is a valid scenario.  Title is loaded, and partnerConfig.exe added the title
                        reportObj.Info("Title " + this_title.TitleId.ToString() + " found in both DB and file. Good.");
                        //partner.titleList.Remove(this_title);
                    }
                    else if (titleFound & !titleLoaded)
                    {
                        // not good.  Title is not loaded, but partnerconfig.exe still loaded the title.
                        reportObj.Error("Found that partnerConfig.exe loaded title " + this_title.TitleId.ToString() + " but this title is not loaded in this environment.");
                        return false;
                    }
                    else if (!titleFound & !titleLoaded)
                    {
                        // this is a good scenario. Title is not loaded, and partnerConfig.exe did not import title info.
                        reportObj.Info("Title " + this_title.TitleId.ToString() + " is not loaded, and PartnerConfig.exe did not import this title info even though it was in the file.");
                    }
                    else  // the file was in the file, but not in the DB even though the title is loaded.
                    {
                        reportObj.Error("Missing Title in title list.  TitleId: " + this_title.TitleId);
                        return false;
                    }
                }

                //if (partner.titleList.Count != 0)
                //{
                //    reportObj.Error("Extra Titles in the source title list:");
                //    foreach (Title title in partner.titleList)
                //    {
                //        reportObj.Error(title.ToString());
                //    }
                //    return false;
                //}

                // check IP lists
                foreach (IPAddressAndMask ip in this.ipAddressList)
                {
                    if (partner.ipAddressList.Contains(ip))
                    {
                        partner.ipAddressList.Remove(ip);
                    }
                    else
                    {
                        reportObj.Error("Missing ip in ipAddress list: " + ip);
                        return false;
                    }
                }
                if (partner.ipAddressList.Count != 0)
                {
                    reportObj.Error("Extra IP addresses in the source title list:");
                    foreach (IPAddressAndMask ipMask in partner.ipAddressList)
                    {
                        reportObj.Error(ipMask.ToString());
                    }
                    return false;
                }

                reportObj.Info("Partners are equal.");
                return true;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }


        }

        public class IPAddressAndMask
        {
            private UInt32 uIntIP;
            private UInt32 uIntMask;

            public IPAddressAndMask() { }

            public IPAddressAndMask(UInt32 IP, UInt32 Mask)
            {
                this.uIntIP = IP;
                this.uIntMask = Mask;
            }

            public IPAddressAndMask(string IPString, string MaskString)
            {
                this.uIntIPAddress = ConvertIPToInt(IPString);
                this.uIntMask = ConvertIPToInt(MaskString);
            }

            public override bool Equals(object obj)
            {
                if (obj == null) return false;

                if (this.GetType() != obj.GetType()) return false;

                IPAddressAndMask ipMask = (IPAddressAndMask)obj;

                if (!Object.Equals(this.uIntIPAddress, ipMask.uIntIPAddress)) return false;
                if (!Object.Equals(this.uIntMaskAddress, ipMask.uIntMaskAddress)) return false;

                return true;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override string ToString()
            {
                string IPPart = ConvertIntToIPString(this.uIntIP);
                string MaskPart = ConvertIntToIPString(this.uIntMask);
                return IPPart + ":" + MaskPart;
            }

            public UInt32 uIntIPAddress
            {
                get { return this.uIntIP; }
                set { this.uIntIP = value; }
            }

            public UInt32 uIntMaskAddress
            {
                get { return this.uIntMask; }
                set { this.uIntMask = value; }
            }

            private UInt32 ConvertIPToInt(string strIP)
            {
                string strSeparator = ".";
                char[] chSeparator = strSeparator.ToCharArray();
                UInt32 intIP;

                string[] strIPParts = strIP.Split(chSeparator, 4);

                intIP = (UInt32)(Convert.ToByte(strIPParts[3], 10) << 24);
                intIP += (UInt32)(Convert.ToByte(strIPParts[2], 10) << 16);
                intIP += (UInt32)(Convert.ToByte(strIPParts[1], 10) << 8);
                intIP += (UInt32)(Convert.ToByte(strIPParts[0], 10));

                return intIP;
            }

            private string ConvertIntToIPString(UInt32 uintIP)
            {
                string strReturn;
                byte bTemp;

                bTemp = (byte)((0xff000000 & uintIP) >> 24);
                strReturn = "." + bTemp.ToString();
                bTemp = (byte)((0x00ff0000 & uintIP) >> 16);
                strReturn = "." + bTemp.ToString() + strReturn;
                bTemp = (byte)((0x0000ff00 & uintIP) >> 8);
                strReturn = "." + bTemp.ToString() + strReturn;
                bTemp = (byte)(0x000000ff & uintIP);
                strReturn = bTemp.ToString() + strReturn;

                return strReturn;
            }
            





        }

        public class Title
        {
            private Int32 titleId;
            private Int32 privileges;
            private string rating;
            private Int32 clusterId;
            static List<Int32> loadedTitles;
            static string cnString = "Data Source=Paulramvxb409;Initial Catalog=webdb;Integrated Security=True";


            public Title() { }

            static Title()
            {
                if (loadedTitles == null)
                {
                    loadedTitles = new List<Int32>();
                    SqlConnection cn = new SqlConnection(cnString);
                    cn.Open();

                    string sql = "SELECT i_title_id FROM t_title_info";
                    SqlCommand cmd = new SqlCommand(sql, cn);
                    SqlDataReader dr = cmd.ExecuteReader();
                    while (dr.Read())
                    {
                        loadedTitles.Add((Int32)dr["i_title_id"]);
                    }

                    dr.Close();
                    cn.Close();
                }                
            }


            public override bool Equals(object obj)
            {
                if (obj == null) return false;

                if (this.GetType() != obj.GetType()) return false;

                Title title = (Title)obj;

                if (!Object.Equals(this.TitleId, title.TitleId)) return false;
                if (!Object.Equals(this.Privileges, title.Privileges)) return false;
                
                // don't care about rating and clusterId because this data is linked to the title
                // and not the t_partner_allowed_titles table.

                //if (!Object.Equals(this.Rating, title.Rating)) return false;
                //if (!Object.Equals(this.ClusterId, title.ClusterId)) return false;

                return true;
            }

            public static bool IsTitleLoaded(Int32 TitleId)
            {
                if (loadedTitles.Contains(TitleId))
                    return true;
                else
                    return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public Int32 TitleId
            {
                get { return this.titleId; }
                set { this.titleId = value; }
            }

            public Int32 Privileges
            {
                get { return this.privileges; }
                set { this.privileges = value; }
            }

            public string Rating
            {
                get { return this.rating; }
                set { this.rating = value; }
            }

            public Int32 ClusterId
            {
                get { return this.clusterId; }
                set { this.clusterId = value; }
            }

        }

        public class WebDB
        {
            static string cnString = "Data Source=ansxblob;Initial Catalog=webdb;Integrated Security=True";

            private WebDB() { }

            public static void DeletePartner(Int32 PartnerId)
            {
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "DELETE FROM t_partner_allowed_apis WHERE i_partner_id=" + PartnerId;
                SqlCommand cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();

                sql = "DELETE FROM t_partner_allowed_titles WHERE i_partner_id=" + PartnerId;
                cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();

                sql = "DELETE FROM t_partner_ips WHERE i_partner_id=" + PartnerId;
                cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();

                sql = "DELETE FROM t_partners WHERE i_partner_id=" + PartnerId;
                cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();

                cn.Close();
            }

            public static void DeletePartnerTitle(Int32 PartnerId, Int32 TitleId)
            {
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "DELETE FROM t_partner_allowed_titles WHERE i_partner_id=" + PartnerId + " AND i_title_id=" + TitleId.ToString();
                SqlCommand cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();
                cn.Close();
            }

            public static void DeletePartnerAPI(Int32 PartnerId, string ApiName)
            {
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "DELETE FROM t_partner_allowed_apis WHERE i_partner_id=" + PartnerId + " AND vc_api_name='" + ApiName + "'";
                SqlCommand cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();
                cn.Close();
            }

            public static void AddCredType(Int32 CredTypeId, String NewCredTypeDescription)
            {
                SqlConnection cn = new SqlConnection(cnString);
                cn.Open();

                string sql = "DELETE FROM t_credential_types WHERE i_cred_type=" + CredTypeId.ToString();
                SqlCommand cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();

                sql = "INSERT INTO t_credential_types VALUES (" + CredTypeId.ToString() + ",'" + NewCredTypeDescription + "', GETDATE())";
                cmd = new SqlCommand(sql, cn);
                cmd.ExecuteNonQuery();

                cn.Close();
            }

        }


        protected static Int32 StartProcess(String WorkingDir, String FileName, String Arguments)
        {
            Process MyProc = new Process();
            MyProc.StartInfo.WorkingDirectory = Environment.ExpandEnvironmentVariables(WorkingDir);
            MyProc.StartInfo.FileName = Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName;
            MyProc.StartInfo.UseShellExecute = false;
            MyProc.StartInfo.RedirectStandardError = true;
            MyProc.StartInfo.RedirectStandardInput = true;
            MyProc.StartInfo.RedirectStandardOutput = true;
            MyProc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;

            MyProc.StartInfo.Arguments = Arguments;

            reportObj.Info("Working Directory: " + MyProc.StartInfo.WorkingDirectory);
            reportObj.Info("FileName: " + MyProc.StartInfo.FileName);
            reportObj.Info("Args: " + MyProc.StartInfo.Arguments);

            MyProc.Start();
            String stdOut = MyProc.StandardOutput.ReadToEnd();
            String stdErr = MyProc.StandardError.ReadToEnd();
            MyProc.WaitForExit();
            Int32 exitCode = MyProc.ExitCode;
            MyProc.Close();
            reportObj.Info("Command line used:");
            reportObj.Info(Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName + " " + Arguments);
            reportObj.Info("stdOut: " + stdOut);
            reportObj.Info("stdErr: " + stdErr);
            return exitCode;
        }

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\PacdConfigTest\PacdConfigTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PacdConfigTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("PacdConfigTest")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9310e003-c26c-4db5-bc18-76f5e811c43e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TPP\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TPP\ArgParser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace TPP
{
    /// <summary>
    /// Command line parser based on the NamedArgParser class used in all the tools.
    /// </summary>
    public class ArgParser
    {
        private static char[] _defaultDelimiters = { '/', '-' };

        private Dictionary<string, string> _args;
        private char[] _delimiters;
        private string[] _tags;
        private bool _ignoreCase = true;

        public ArgParser() : this(null, _defaultDelimiters) { }
        public ArgParser(string[] tags) : this(tags, _defaultDelimiters) { }
        public ArgParser(string[] tags, char[] delimiters)
        {
            _args = new Dictionary<string, string>();
            _tags = tags;
            _delimiters = delimiters;
        }

        public string[] Tags
        {
            get { return _tags; }
            set { _tags = value; }
        }

        public char[] Delimiters
        {
            get { return _delimiters; }
            set { _delimiters = value; }
        }

        public bool IgnoreCase
        {
            get { return _ignoreCase; }
            set { _ignoreCase = value; }
        }

        public string this[string tag]
        {
            get
            {
                if (_args.ContainsKey(tag))
                    return _args[tag];
                else
                    return null;
            }
            set { _args[tag] = value; }
        }

        public int Count
        {
            get { return _args.Count; }
        }

        public void Parse(string[] commandLine)
        {
            string tag;
            string value;
            int valueSep;

            foreach (string arg in commandLine)
            {
                // Get the tag
                tag = GetTag(arg);
                if (tag.Length == 0)
                {
                    // Invalid argument
                    throw new ArgumentException("Invalid command line argument.", arg);
                }

                // Get the value associated with the tag (if any)
                value = "";
                valueSep = arg.IndexOf(':');
                if (valueSep > 0)
                {
                    value = arg.Substring(valueSep + 1);
                }

                if (_ignoreCase)
                    tag = tag.ToLower();

                // Add the tag/value pair
                _args.Add(tag, value);
            }
        }

        private string GetTag(string arg)
        {
            int i;
            int valueIndex;
            string tag = "";
            bool isValid = false;

            // Look for one of the valid delimiters
            for (i = 0; i < _delimiters.Length; i++)
            {
                if (arg[0] == _delimiters[i]) break;
            }

            if (i >= _delimiters.Length)
                return "";

            valueIndex = arg.IndexOf(':');
            if (valueIndex > 0)
            {
                tag = arg.Substring(1, valueIndex - 1);
            }
            else
            {
                tag = arg.Substring(1);
            }

            // Validate the tag against the list of valid tags
            if (_tags != null)
            {
                foreach (string validTag in _tags)
                {
                    if (String.Compare(validTag, tag, _ignoreCase) == 0)
                    {
                        isValid = true;
                        break;
                    }
                }
            }

            return (isValid ? tag : "");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\OctopusDailyTests\OctopusDailyTests\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Reflection;
using System.IO;
using System.Net.Mail;
using System.Net;
using System.Xml;
using System.Threading;

using HealthCheckVerifier;

namespace OctopusDailyTests
{
    class Program
    {
        static TestResults Results = new TestResults();

        static readonly string PreInstallLogMarker =    "preinstall_loglocation.txt";
        static readonly string InstallLogMarker =       "install_loglocation.txt";
        static readonly string UninstallLogMarker =     "uninstall_loglocation.txt";
        static readonly string ReinstallLogMarker =     "reinstall_loglocation.txt";
        static readonly string BvtLogMarker =           "bvt_loglocation.txt";
        static readonly string BvtResultsFile =         "bvt_results.html";

        static string InstallLogPath;
        static string UninstallLogPath;
        static string ReinstallLogPath;
        static string BvtLogPath;
        static string BvtResultsPath;
        static string HtmlReport = "";
        static string VaultPath = "";

        //Timing variables
        static DateTime OverallStartTime = DateTime.Now;
        static DateTime OverallEndTime = DateTime.Now;
        static TimeSpan OverallRunTime = new TimeSpan(0);
        static DateTime InstallStartTime = DateTime.Now;
        static DateTime InstallEndTime = DateTime.Now;
        static TimeSpan InstallRunTime = new TimeSpan(0);
        static DateTime UninstallStartTime = DateTime.Now;
        static DateTime UninstallEndTime = DateTime.Now;
        static TimeSpan UninstallRunTime = new TimeSpan(0);
        static DateTime ReinstallStartTime = DateTime.Now;
        static DateTime ReinstallEndTime = DateTime.Now;
        static TimeSpan ReinstallRunTime = new TimeSpan(0);
        static DateTime HealthCheckStartTime = DateTime.Now;
        static DateTime HealthCheckEndTime = DateTime.Now;
        static TimeSpan HealthCheckRunTime = new TimeSpan(0);
        static DateTime BvtStartTime = DateTime.Now;
        static DateTime BvtEndTime = DateTime.Now;
        static TimeSpan BvtRunTime = new TimeSpan(0);

        /// <summary>
        /// The main entry point for the program.
        /// </summary>
        /// <param name="args">
        /// Parameter 1: The path to the vault folder
        /// Parameter 2: The e-mail address to provide with results
        /// Parameter 3: The password for the currently logged in user.
        /// </param>
        static void Main(string[] args)
        {
            try
            {
                if (args.Length != 3)
                {
                    PrintUsage();
                    Environment.Exit(1);
                }

                string vaultPath = args[0];
                string emailAddress = args[1];
                string password = args[2];
                VaultPath = vaultPath;

                string containingDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

                string preinstallLogMarkerPath = Path.Combine(containingDirectory, PreInstallLogMarker);
                if (File.Exists(preinstallLogMarkerPath))
                    File.Delete(preinstallLogMarkerPath);

                string installLogMarkerPath = Path.Combine(containingDirectory, InstallLogMarker);
                if (File.Exists(installLogMarkerPath))
                    File.Delete(installLogMarkerPath);

                string uninstallLogMarkerPath = Path.Combine(containingDirectory, UninstallLogMarker);
                if (File.Exists(uninstallLogMarkerPath))
                    File.Delete(uninstallLogMarkerPath);

                string reinstallLogMarkerPath = Path.Combine(containingDirectory, ReinstallLogMarker);
                if (File.Exists(reinstallLogMarkerPath))
                    File.Delete(reinstallLogMarkerPath);

                string bvtLogMarkerPath = Path.Combine(containingDirectory, BvtLogMarker);
                if (File.Exists(bvtLogMarkerPath))
                    File.Delete(bvtLogMarkerPath);

                // Start timing the whole run
                OverallStartTime = DateTime.Now;

                // Set up the Octopus Installer config
                OctopusProcess octopusProcess = new OctopusProcess();
                octopusProcess.UseFakeAgent = false;
                octopusProcess.PendingRebootOperation = OctopusPendingRebootOperation.Reboot;
                octopusProcess.Password = password;
                octopusProcess.UseVerboseMsiLogging = true;

                // Make sure wstagent and sql server agent are running
                Console.WriteLine("\t*** Starting Services ***");
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "servicesxb001.xml");
                octopusProcess.Run();

                // Xblob Prep Install
                Console.WriteLine("\t*** Running Pre-Install ***");
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToLogLocationFile = preinstallLogMarkerPath;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "prexb001.xml");
                octopusProcess.Run();

                // Install the Xbox Live Service
                Console.WriteLine("\t*** Installing Service ***");
                InstallStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "xb001.xml");
                octopusProcess.PathToLogLocationFile = installLogMarkerPath;
                octopusProcess.Run();
                InstallLogPath = GetLogPathFromMarker(installLogMarkerPath);
                InstallEndTime = DateTime.Now;
                InstallRunTime = InstallEndTime - InstallStartTime;

                // Install the Xbox Live Service
                Console.WriteLine("\t*** Uninstalling Service ***");
                UninstallStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Uninstall;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "xb001.xml");
                octopusProcess.PathToLogLocationFile = uninstallLogMarkerPath;
                octopusProcess.Run();
                UninstallLogPath = GetLogPathFromMarker(uninstallLogMarkerPath);
                UninstallEndTime = DateTime.Now;
                UninstallRunTime = UninstallEndTime - UninstallStartTime;

                // Make sure wstagent and sql server agent are running
                Console.WriteLine("\t*** Starting Services ***");
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "servicesxb001.xml");
                octopusProcess.PathToLogLocationFile = null;
                octopusProcess.Run();

                // Reinstall the Xbox Live Service
                Console.WriteLine("\t*** Reinstalling Service ***");
                ReinstallStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "xb001.xml");
                octopusProcess.PathToLogLocationFile = reinstallLogMarkerPath;
                octopusProcess.Run();
                ReinstallLogPath = GetLogPathFromMarker(reinstallLogMarkerPath);
                ReinstallEndTime = DateTime.Now;
                ReinstallRunTime = ReinstallEndTime - ReinstallStartTime;

                // Run the BVT's
                Console.WriteLine("\t*** Running BVTs ***");
                BvtStartTime = DateTime.Now;
                octopusProcess.InstallationType = OctopusInstallationType.Install;
                octopusProcess.PathToConfigurationFile = Path.Combine(vaultPath, "bvt001.xml");
                octopusProcess.PathToLogLocationFile = bvtLogMarkerPath;
                octopusProcess.Run();
                BvtLogPath = GetLogPathFromMarker(bvtLogMarkerPath);
                BvtResultsPath = Path.Combine(GetLogFolderPathFromMarker(bvtLogMarkerPath), BvtResultsFile);
                BvtEndTime = DateTime.Now;
                BvtRunTime = BvtEndTime - BvtStartTime;
                OverallEndTime = DateTime.Now;
                OverallRunTime = OverallEndTime - OverallStartTime;

                //BvtLogPath = "\\\\65.52.240.59\\OctopusLogs\\BVTLogs\\2008-08-05_06-27-57\\deploymentSession.xml";
                // Parse Results
                Console.WriteLine("\t*** Getting Results ***");
                Results.Install = GetDeploymentResultFromLog(InstallLogPath);
                Results.Uninstall = GetDeploymentResultFromLog(UninstallLogPath);
                Results.Reinstall = GetDeploymentResultFromLog(ReinstallLogPath);
                ReviewSystemCheckResultsUsingLog(BvtLogPath);
                Results.LiveBvts = GetResultForCommandInLog("run-live-bvts", BvtLogPath);
                HealthCheckStartTime = GetTimeStampForCommandInLog("health-check", BvtLogPath, true);
                HealthCheckEndTime = GetTimeStampForCommandInLog("health-check", BvtLogPath, false);
                HealthCheckRunTime = HealthCheckEndTime - HealthCheckStartTime;
                BvtStartTime = GetTimeStampForCommandInLog("run-live-bvts", BvtLogPath, true);
                BvtEndTime = GetTimeStampForCommandInLog("run-live-bvts", BvtLogPath, false);
                BvtRunTime = BvtEndTime - BvtStartTime;

                //Log Results to a file in case email fails
                Console.WriteLine("\t*** Logging Results ***");
                string resultsFile = Path.Combine(GetLogFolderPathFromMarker(bvtLogMarkerPath), BvtResultsFile);
                Console.WriteLine("Logging to: {0}", resultsFile);
                string buildNumber = GetBuildVersionAtPath(@"\\edge-svcs\Release\XONLINE\main\Latest.tst\retail\msi\esp");
                Console.WriteLine("Build version = {0}", buildNumber);
                GetXblobHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed Xblob Results");
                GetCoreNetHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed CoreNet Results");
                GetBvtNetHtmlReportFromResultsWithVersion(buildNumber, true);
                Console.WriteLine("Parsed BvtNet Results");
                Console.WriteLine("*** Results: ***\n{0}", HtmlReport);
                if (File.Exists(resultsFile) == true)
                {
                    File.Delete(resultsFile);
                }
                using (StreamWriter rfStream = File.CreateText(resultsFile))
                {
                    rfStream.Write(HtmlReport);
                    rfStream.Close();
                }

                SendResults(emailAddress, buildNumber);
                //Console.ReadKey();
            }
            catch (Exception globalException)
            {
                Console.WriteLine("Caught a Global Exception:\n{0}", globalException.ToString());
            }
        }

        static string GetLogPathFromMarker(string path)
        {
            string returnValue = null;
            string logPath = GetLogFolderPathFromMarker(path);

            if (logPath != null && File.Exists(Path.Combine(logPath, "deploymentSession.xml")))
            {
                returnValue = Path.Combine(logPath, "deploymentSession.xml");
            }

            return returnValue;
        }

        static string GetLogFolderPathFromMarker(string path)
        {
            string returnValue = null;
            if (File.Exists(path))
            {
                string logPath = null;
                using (StreamReader s = new StreamReader(path))
                {
                    logPath = s.ReadLine();
                }
                if (logPath != null)
                {
                    returnValue = logPath;
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Prints the usage string for how to use the program
        /// </summary>
        static void PrintUsage()
        {
            Console.WriteLine("Usage is: OctopusDailyTests <path to vault> <e-mail address> <password>");
        }

        /// <summary>
        /// Gathers all of the results from running tests, updates the build number and results posted on the wiki,
        /// and then sends an e-mail with those results.
        /// </summary>
        /// <param name="emailAddress">The place to send e-mail to.</param>
        /// <param name="buildNumber">The Build number installed.</param>
        [Conditional("XBLOB")]
        static void SendResults(string emailAddress, string buildNumber)
        {
            GetXblobHtmlReportFromResultsWithVersion(buildNumber, false);

            MailMessage mailMessage = new MailMessage("emzephir@microsoft.com", emailAddress);
            mailMessage.Body = HtmlReport;
            mailMessage.IsBodyHtml = true;
            mailMessage.Subject = String.Format("{0}: Xblob Deployment ({1})", GetNameStringForResult(Results.OverallResult), buildNumber);

            SmtpClient smtpClient = new SmtpClient("smtphost");
            smtpClient.UseDefaultCredentials = true;
            //smtpClient.Credentials = new NetworkCredential("espptest", "MSFTstock$", "redmond");
            try
            {
                smtpClient.Send(mailMessage);
            }
            catch (SmtpException smtpException)
            {
                Console.WriteLine("Failed to send email. Trying again.\n{0}", smtpException.ToString());
                try
                {
                    // retry
                    smtpClient.Send(mailMessage);
                }
                catch (SmtpException smtpException2)
                {
                    // give up
                    Console.WriteLine("Failed to send email. Giving up.\n{0}", smtpException2.ToString());
                }
            }

            //Update latest build
            try
            {
                Xblwiki.EditService editService = new OctopusDailyTests.Xblwiki.EditService();
                editService.UseDefaultCredentials = true;

                if (Results.OverallResult == TestRunResult.Passed && buildNumber != null)
                {

                    Xblwiki.AbsoluteTopicName absoluteTopicName = new OctopusDailyTests.Xblwiki.AbsoluteTopicName();
                    absoluteTopicName.Namespace = "Xblob";
                    absoluteTopicName.Name = "OctopusLKGBuild";
                    editService.SetTextForTopic(absoluteTopicName, buildNumber, "");
                }

                string wikitext = GetWikiReportFromResultsWithVersion(buildNumber);
                Xblwiki.AbsoluteTopicName lastDeploymentTopicName = new OctopusDailyTests.Xblwiki.AbsoluteTopicName();
                lastDeploymentTopicName.Namespace = "Xblob";
                lastDeploymentTopicName.Name = "OctopusLKGBuildLastDeployment";
                editService.SetTextForTopic(lastDeploymentTopicName, wikitext, "");

                if (Results.OverallResult == TestRunResult.Passed)
                {
                    lastDeploymentTopicName.Name = "OctopusLKGBuildLastPassedDeployment";
                    editService.SetTextForTopic(lastDeploymentTopicName, wikitext, "");
                }
            }
            catch (Exception wikiException)
            {
                Console.WriteLine("Caught an Exception Updating the Wiki:\n{0}", wikiException.ToString());
            }
        }

        /// <summary>
        /// Goes through a deployment log looking and reports the overall status from that log file as reported by Octopus.
        /// </summary>
        /// <param name="logFilePath">The path to a text file containing the path to the Octopus deployment log folder. This is usually acquired by OctopusCLI's -recordLogFolderIn option</param>
        /// <returns>If logFilePath does not exist, returns a NotRun result. Otherwise it returns the result of the deployment.</returns>
        static TestRunResult GetDeploymentResultFromLog(string logFilePath)
        {
            TestRunResult returnValue = TestRunResult.NotRun;
            if (logFilePath != null)
            {
                string[] errors = GetErrorsFromOctopusLog(logFilePath);
                if (errors.Length == 0)
                {
                    returnValue = TestRunResult.Passed;
                }
                else
                {
                    returnValue = TestRunResult.Failed;
                }
            }

            return returnValue;
        }

        /// <summary>
        /// Looks throught the healthchecks.xml file in an Octopus Log folder to determine whether or not the URLs run by
        /// SystemCheck passed as expected. These results are registered directly with the result object.
        /// </summary>
        /// <param name="logFilePath">The path to a text file containing the path to the folder containing healthchecks.xml. This is usually acquired by OctopusCLI's -recordLogFolderIn option. Although</param>
        static void ReviewSystemCheckResultsUsingLog(string logFilePath)
        {
            if (logFilePath != null && File.Exists(Path.Combine(Path.GetDirectoryName(logFilePath), "healthchecks.xml")))
            {
                CheckResultManager manger = new CheckResultManager();
                string configXml = (@"HealthCheckConfig.xml");

                try
                {
                    manger.LoadXmlAndPopulateData(Path.Combine(Path.GetDirectoryName(logFilePath), "healthchecks.xml"), Path.Combine(VaultPath, configXml));
                }
                catch (Exception hcExcep)
                {
                    Console.WriteLine("Caught an Exception Parsing Healthchecks:\n{0}", hcExcep.ToString());
                }

                List<CheckResult> checkResultList = manger.CheckResults;

                foreach (CheckResult checkResult in checkResultList)
                {
                    if (checkResult.HealthStatus.Equals(HealthStatus.Fail))
                    {
                        //isFail = true;
                        Results.AddFailingUrl(checkResult.Url, checkResult.HealthStatus.ToString());
                    }
                    else
                    {
                        Results.AddPassingUrl(checkResult.Url);
                    }
                }
                //if (isFail)
                //    Results.HealthChecks = TestRunResult.Failed;
                //else
                //    Results.HealthChecks = TestRunResult.Passed;

                using (StreamWriter write = new StreamWriter(Path.Combine(Path.GetDirectoryName(logFilePath), (@"healthCheckVeriferLog.txt"))))
                {
                    write.Write(manger.ErrorsToBeLogged);
                    write.Close();
                }
            }
        }

        private static string[] GetErrorsFromOctopusLog(string logPath)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(logPath);
            List<String> errorMessages = new List<String>();

            XmlNodeList elements = xmlDoc.GetElementsByTagName("msiError");
            foreach (XmlElement e in elements)
            {
                errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
            }

            // Command finished nodes are the only ones that carry errors
            elements = xmlDoc.GetElementsByTagName("commandFinished");
            foreach (XmlElement e in elements)
            {
                if (e.GetAttribute("eventLevel") == "Error")
                {
                    errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
                }
            }

            elements = xmlDoc.GetElementsByTagName("message");
            foreach (XmlElement e in elements)
            {
                if (e.GetAttribute("eventLevel") == "Error")
                {
                    errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
                }
            }

            elements = xmlDoc.GetElementsByTagName("messageError");
            foreach (XmlElement e in elements)
            {
                errorMessages.Add(String.Format("[{0}] {1}", e.GetAttribute("serverName"), e.InnerText));
            }
            return errorMessages.ToArray();

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="commandName"></param>
        /// <param name="logFilePath"></param>
        /// <returns></returns>
        public static TestRunResult GetResultForCommandInLog(string commandName, string logFilePath)
        {
            // this only works for one command
            TestRunResult returnValue = TestRunResult.NotRun;
            if (logFilePath != null)
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(logFilePath);
                List<String> errorMessages = new List<String>();

                XmlNodeList elements = xmlDoc.GetElementsByTagName("commandFinished");
                foreach (XmlElement e in elements)
                {
                    if (e.GetAttribute("name") == commandName)
                    {
                        if (e.GetAttribute("eventLevel") == "Error")
                            returnValue = TestRunResult.Failed;
                        else
                            returnValue = TestRunResult.Passed;
                        break;
                    }
                }
            }

            return returnValue;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="commandName"></param>
        /// <param name="logFilePath"></param>
        /// <returns></returns>
        public static DateTime GetTimeStampForCommandInLog(string commandName, string logFilePath, bool isStartCommand)
        {
            // this only works for one command
            DateTime returnValue = new DateTime(0);
            if (logFilePath != null)
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(logFilePath);
                List<String> errorMessages = new List<String>();
                XmlNodeList elements;

                if(isStartCommand == true)
                    elements = xmlDoc.GetElementsByTagName("commandStarted");
                else
                    elements = xmlDoc.GetElementsByTagName("commandFinished");
                foreach (XmlElement e in elements)
                {
                    if (e.GetAttribute("name") == commandName)
                    {
                        string timeStamp = e.GetAttribute("timeStamp");
                        if (timeStamp != "")
                        {
                            try
                            {
                                returnValue = DateTime.Parse(timeStamp);
                            }
                            catch (FormatException)
                            {
                                returnValue = new DateTime(0);
                            }
                        }
                        break; // We found the command, stop looking
                    }
                }
            }

            return returnValue;
        }

        public static string GetBuildVersionAtPath(string path)
        {
            string buildVersion = "latest.tst";
            path = path.ToLower();

            Regex regex = new Regex("([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)");
            Match regexMatch = regex.Match(path);
            if (regexMatch.Success)
            {
                return regexMatch.Value;
            }
            else
            {
                // No build information in path -- lets look on the server

                int indexOfBuildType = path.IndexOf("debug");
                if (indexOfBuildType == -1)
                    indexOfBuildType = path.IndexOf("retail");
                if (indexOfBuildType == -1)
                    return buildVersion;

                DirectoryInfo directoryInfo = new DirectoryInfo(path.Substring(0, indexOfBuildType));
                if (directoryInfo.Exists == true)
                {
                    try
                    {
                        foreach (FileInfo fileInfo in directoryInfo.GetFiles())
                        {
                            regexMatch = regex.Match(fileInfo.Name);
                            if (regexMatch.Success)
                                return regexMatch.Value;
                        }
                    }
                    catch (DirectoryNotFoundException)
                    {
                    }
                }
            }

            return buildVersion;
        }

        public static string GetWikiReportFromResultsWithVersion(string version)
        {
            if (version == null)
                version = "";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.AppendFormat("!Octopus Deployment Status (Xblob): {0}\n", version);
            stringBuilder.Append("Octopus Settings (Copy and Paste to use)\n");
            stringBuilder.AppendFormat("BuildLocation: \\\\edge-svcs\\Release\\XONLINE\\main\\{0}\\retail\\msi\\esp\n", version);
            stringBuilder.Append("Topology: \"Simple Xblob\"\n");
            stringBuilder.AppendFormat(":Build: {0}\n", version);
            stringBuilder.AppendFormat(":Date: {0}\n", DateTime.Now.ToShortDateString());
            stringBuilder.AppendFormat(":Installation Time: {0} hour(s) {1} minute(s)\n", InstallRunTime.Hours.ToString(), InstallRunTime.Minutes.ToString());
            stringBuilder.AppendFormat(":Total Time: {0} hour(s) {1} minute(s)\n", OverallRunTime.Hours.ToString(), OverallRunTime.Minutes.ToString());
            // this intentionally is the enum name - used for programatic parsing.
            stringBuilder.AppendFormat(":OverallStatus: {0}", Enum.GetName(typeof(TestRunResult), Results.OverallResult));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!%{0}%{1}%%\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!!Install, Uninstall, Reinstall: %{0}%{1}%%\n", GetColorStringForResult(Results.DeploymentCycle), GetNameStringForResult(Results.DeploymentCycle));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!!Health \"\"URLs\"\": %{0}%{1}%%\n", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.AppendLine();

            stringBuilder.AppendFormat("!!!\"\"LiveBVT Smoke Testing\"\": %{0}%{1}%%\n", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("\"List of LiveBVT Tests\":ListOfLiveBVTTests\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Passed || Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.PassingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("!!!Passed Health \"\"URLs\"\" ({0}):\n", Results.PassingHealthChecks.Length);
                    stringBuilder.Append("%gray%([Blocked] = a URL that is correctly blocked by XRLScan)%%\n");
                    foreach (string url in Results.PassingHealthChecks)
                        stringBuilder.AppendFormat("\t* {0}\n", url);
                    stringBuilder.AppendLine();
                }

                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("!!!Failed Health \"\"URLs\"\" ({0}):\n", Results.FailingHealthChecks.Length);
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("\t* {0}\n", url);
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("!!Other Information\n");
            //stringBuilder.Append("\t* Xblob Machine Name: \"\"EMZEPHIRXBL001\"\"\n");
            //stringBuilder.Append("\t* Xblob Machine Specs: 2.8 \"\"GHz\"\" Pentium 4, 2 GB RAM, All components installed to C:\n");
            stringBuilder.Append("\t* Logs: \\\\EMZEPHIR-PC\\AutoLogs\n");

            return stringBuilder.ToString();
        }

        [Conditional("XBLOB")]
        public static void GetXblobHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "Xblob";
            String topology = "Simple Xblob";
            String logLocation = "\\\\EMZEPHIR-PC\\AutoLogs";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if(forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", UninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", UninstallRunTime.Hours, UninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Uninstall), GetNameStringForResult(Results.Uninstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Reinstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", ReinstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", ReinstallRunTime.Hours, ReinstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Reinstall), GetNameStringForResult(Results.Reinstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            HtmlReport = stringBuilder.ToString();
        }

        [Conditional("CORENET")]
        public static void GetCoreNetHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "CoreNet";
            String topology = "Expanded - Ops";
            String logLocation = "http://65.52.240.59/";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if (forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", UninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", UninstallRunTime.Hours, UninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Uninstall), GetNameStringForResult(Results.Uninstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Reinstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", ReinstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", ReinstallRunTime.Hours, ReinstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Reinstall), GetNameStringForResult(Results.Reinstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>TestNet NPDB Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", DateTime.Now.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", 0, 0);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(TestRunResult.NotRun), GetNameStringForResult(TestRunResult.NotRun));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>TestNet NPDB Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", DateTime.Now.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", 0, 0);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(TestRunResult.NotRun), GetNameStringForResult(TestRunResult.NotRun));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            HtmlReport = stringBuilder.ToString();
        }

        [Conditional("BVTNET")]
        public static void GetBvtNetHtmlReportFromResultsWithVersion(string version, bool forLogFile)
        {
            if (version == null)
                version = "";
            String environment = "BvtNet";
            String topology = "Expanded - Ops";
            String logLocation = "http://10.198.103.82/";
            StringBuilder stringBuilder = new StringBuilder();

            stringBuilder.Append("<html><head></head><body>\n");
            stringBuilder.Append("<font face=\"Lucida Console\">\n");
            if (forLogFile == true)
                stringBuilder.AppendFormat("<h3>{0}: {1} Deployment ({2})</h3><br />\n", GetNameStringForResult(Results.OverallResult).ToUpper(), environment, version);

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.AppendFormat("<tr align=left><td>Environment:</td><td>{0}</td></tr>\n", environment);
            stringBuilder.AppendFormat("<tr align=left><td>Topology:</td><td>{0}</td></tr>\n", topology);
            stringBuilder.AppendFormat("<tr align=left><td>Overall Status:</td><td><font color=\"{0}\">{1}</font></td></tr>\n", GetColorStringForResult(Results.OverallResult), GetNameStringForResult(Results.OverallResult).ToUpper());
            stringBuilder.AppendFormat("<tr align=left><td>Build:</td><td>{0}</td></tr>\n", version);
            stringBuilder.AppendFormat("<tr align=left><td>Start Time:</td><td>{0}</td></tr>\n", OverallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>End Time:</td><td>{0}</td></tr>\n", OverallEndTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>Total Time:</td><td>{0}h {1}m</td></tr>\n", OverallRunTime.Hours, OverallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>Log Location:</td><td><a href=\"{0}\">{0}</a></td></tr>\n", logLocation);
            stringBuilder.AppendFormat("</table></p>\n");
            stringBuilder.AppendLine();


            stringBuilder.Append("<p><b>Additional Information</b></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Install</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", InstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", InstallRunTime.Hours, InstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Install), GetNameStringForResult(Results.Install));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Uninstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", UninstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", UninstallRunTime.Hours, UninstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Uninstall), GetNameStringForResult(Results.Uninstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Reinstall</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", ReinstallStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", ReinstallRunTime.Hours, ReinstallRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.Reinstall), GetNameStringForResult(Results.Reinstall));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3>Health URLs</td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", HealthCheckStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", HealthCheckRunTime.Hours, HealthCheckRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.HealthChecks), GetNameStringForResult(Results.HealthChecks));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            stringBuilder.Append("<p><table border=0>\n");
            stringBuilder.Append("<tr align=left><td colspan=3><a href=\"http://xblwiki/default.aspx/Xblob/ListOfLiveBVTTests.html\">LiveBVT Smoke Testing</a></td></tr>\n");
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Start:</td><td>{0}</td></tr>", BvtStartTime.ToString());
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Length:</td><td>{0}h {1}m</td></tr>", BvtRunTime.Hours, BvtRunTime.Minutes);
            stringBuilder.AppendFormat("<tr align=left><td>&nbsp;</td><td>Result:</td><td><font color=\"{0}\">{1}</font></td></tr>", GetColorStringForResult(Results.LiveBvts), GetNameStringForResult(Results.LiveBvts));
            stringBuilder.Append("<tr align=left><td>&nbsp;</td><td>Notes:</td><td>N/A</td></tr>\n");
            stringBuilder.Append("</table></p>\n");
            stringBuilder.AppendLine();

            if (Results.HealthChecks == TestRunResult.Failed)
            {
                if (Results.FailingHealthChecks.Length != 0)
                {
                    stringBuilder.AppendFormat("<p><b>Failed Health URLs ({0})</b></p>", Results.FailingHealthChecks.Length);
                    stringBuilder.Append("<ul>\n");
                    foreach (string url in Results.FailingHealthChecks)
                        stringBuilder.AppendFormat("<li>{0}</li>\n", url);
                    stringBuilder.Append("</ul>\n");
                    stringBuilder.AppendLine();
                }
            }

            stringBuilder.Append("</font>\n");
            stringBuilder.Append("</body></html>");

            HtmlReport = stringBuilder.ToString();
        }

        public static string GetColorStringForResult(TestRunResult result)
        {
            if (result == TestRunResult.Failed)
                return "red";
            else if (result == TestRunResult.NotRun)
                return "gray";
            else if (result == TestRunResult.Passed)
                return "green";
            else
                return "black";
        }

        public static string GetNameStringForResult(TestRunResult result)
        {
            if (result == TestRunResult.Failed)
                return "Failed";
            else if (result == TestRunResult.NotRun)
                return "Not Run";
            else if (result == TestRunResult.Passed)
                return "Passed";
            else
                return Enum.GetName(typeof(TestRunResult), result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\UserConfigCertConfigTests\Client\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GenevaDeploymentTests;


namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            GenevaDeploymentTestSuite.UserConfigTests suite = new GenevaDeploymentTestSuite.UserConfigTests();
            suite.PreRun();
            GenevaDeploymentTestSuite.UserConfigTests.t1a_VerifyPasswordOnLocalComputerAccount test = new GenevaDeploymentTestSuite.UserConfigTests.t1a_VerifyPasswordOnLocalComputerAccount();
            test.Run();
            suite.PostRun();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TPP\TPP.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;

namespace TPP
{
    internal enum LoggingLevel
    {
        None = 0,
        Error = EventLogEntryType.Error,
        Warning = EventLogEntryType.Warning,
        Information = EventLogEntryType.Information,
        Debug = 5
    }

    class Program
    {
        const string EVENT_SOURCE = "TitlePropPro";

        static int Main(string[] args)
        {
            string title = "";
            string configFile = "TPPSettings.xml";
            string env = "";
            ArgParser argParser = null;
            StringBuilder error = new StringBuilder();
            TitlePropPro titleProp = new TitlePropPro();
            titleProp.TppEvent += new TPPEventHandler(titleProp_TppEvent);

            // Output the header
            Console.Write(String.Format("\r\nTPP - Deploys titles to the Xbox Live service.\r\n"));
            Console.Write(String.Format("Version {0}\r\n\r\n", FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).ProductVersion));

            try
            {
                string[] cmdLineTags = {
                                        "?",            // Display usage
                                        "env",          // The name of the current environment
                                        "title",        // The Title Id to prop, or 'Acceptance', 'Extended', or 'All'
                                        "titlesource",  // The base location for the title source files. Overrides the setting from TPPSettings.xml
                                        "manifest",     // The location of the title manifest file.
                                        "threads",      // The number of propping threads to use.
                                        "toolspath",    // The location of the Xbox Live tools.
                                        "loglocation",  // The location where the logs are saved.
                                        "reportonly"    // Flag used to create a report of what's happening without doing anything.
                                       };
                argParser = new ArgParser(cmdLineTags);
                argParser.Parse(args);
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occurred while parsing the command line:\r\n");
                Console.WriteLine(ex.Message);
                Console.WriteLine("\r\nPlease check the usage and try again.");
                return -1;
            }

            // Perform validation on the parameters
            if (argParser.Count == 0 || argParser["?"] != null)
            {
                Usage();
                return 0;
            }

            if (argParser["env"] != null)
            {
                env = argParser["env"].ToLower();
            }
            else
            {
                Console.WriteLine("Error : The environment must be specified.\r\n");
                return -1;
            }

            if (argParser["title"] != null)
            {
                title = argParser["title"].ToLower();
            }
            else
            {
                Console.WriteLine("Error : The title parameter must be specified.\r\n");
                return -1;
            }

            // Initialize the TitlePropPro object
            int retValue = 0;
            try
            {
                if (titleProp.Initialize(configFile))
                {
                    // If there is a TitleSource override, apply it now
                    if (argParser["titlesource"] != null)
                    {
                        titleProp.OverrideTitleSourceLocation(env, argParser["titlesource"]);
                    }

                    // If there is a Manifest override, apply it now
                    if (argParser["manifest"] != null)
                    {
                        titleProp.OverrideTitleManifest(env, Path.GetFullPath(argParser["manifest"]));
                    }

                    // If there is a LogLocation override, apply it now
                    if (argParser["loglocation"] != null)
                    {
                        titleProp.OverrideLogLocation(env, Path.GetFullPath(argParser["loglocation"]));
                    }

                    // Apply the threads override
                    if (argParser["threads"] != null)
                    {
                        try
                        {
                            titleProp.ThreadCount = Int32.Parse(argParser["threads"]);
                        }
                        catch (Exception)
                        {
                            Console.WriteLine("!! Invalid threads parameter: {0}. The default value of {1} will be used.",
                                argParser["threads"], titleProp.ThreadCount);
                        }
                    }

                    // Apply the tools location override
                    if (argParser["toolspath"] != null)
                    {
                        titleProp.LiveToolsLocation = argParser["toolspath"];
                    }

                    titleProp.ReportOnly = (argParser["reportonly"] != null);

                    // Prop the title(s)
                    if ("acceptance" == title ||
                        "extended" == title ||
                        "bvt" == title ||
                        "all" == title)
                    {
                        retValue = titleProp.PropTitleGroup(env, title);
                    }
                    else
                    {
                        // The Title parameter is not one of the title groups,
                        // so it could either be a single title id or a list
                        // of title ids separated by commas or semi-colons.
                        string[] titleIds = title.Split(',', ';');
                        if (titleIds.Length == 0)
                        {
                            Console.WriteLine("Invalid Title parameter. You must specify at least one title id.");
                            return -1;
                        }

                        // Single title log files will be stored in the Logs directory off the current directory.
                        string logLocation = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Logs");
                        titleProp.OverrideLogLocation(env, logLocation);
                        if (!Directory.Exists(logLocation))
                        {
                            try
                            {
                                Directory.CreateDirectory(logLocation);
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine("Unable to create the log location '{0}'.\r\nPlease make sure you have write permissions to this location and try again.\r\n\r\nError: {1}", logLocation, ex.Message);
                                return -1;
                            }
                        }

                        if (titleIds.Length == 1)
                        {
                            retValue = titleProp.PropSingleTitle(env, titleIds[0]);
                        }
                        else
                        {
                            retValue = titleProp.PropMultipleTitles(env, titleIds);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("!! An unhandled exception has occurred :\r\n{0}", ex);
                LogEvent(LoggingLevel.Error, "An unhandled exception occurred :\r\n\r\n{0}", ex);
                retValue = -1;
            }

            Console.WriteLine("\r\nDone.");
            return retValue;
        }

        static void titleProp_TppEvent(object sender, TPPEventArgs args)
        {
            StringBuilder output = new StringBuilder();
            if (args.Type == TPPEventType.Error)
            {
                LogEvent(LoggingLevel.Error, args.Details);
            }
            else if (args.Type == TPPEventType.Debug)
            {
                Trace.WriteLine(args.Details);
                return;
            }
            Console.WriteLine(args.Details);
        }

        static void LogEvent(LoggingLevel level, string msg, params object[] args)
        {
            EventLogEntryType entryType;

            if (LoggingLevel.None == level || LoggingLevel.Debug == level)
                entryType = EventLogEntryType.Information;
            else
                entryType = (EventLogEntryType)(int)level;

            // Embed this call in a try...catch just so we don't crash while writing to the event log
            try
            {
                EventLog.WriteEntry(EVENT_SOURCE, String.Format(msg, args), entryType, (int)level);
            }
            catch (Exception) { }
        }

        static void Usage()
        {
            StringBuilder usage = new StringBuilder();
            usage.AppendLine("Usage :");
            usage.AppendLine("    TPP.exe /env:<environmentName> /title:<[0x]titleId[,[0x]titleId,...] | Acceptance | Extended | All>");
            usage.AppendLine("            [/manifest:<manifestPath>] [/titlesource:<sourcePath>] [/threads:<#ofThreads>]");
            usage.AppendLine("            [/toolsPath:<path>] /logLocation:<path>] [/reportonly]\r\n");
            usage.AppendLine("Required Parameters :");
            usage.AppendLine("    env           The name of the environment. This must match one of the environment names");
            usage.AppendLine("                  found in the TPPSettings.xml file.");
            usage.AppendLine("    title         Specifies either a single Title ID to deploy, a list of Title IDs to deploy,");
            usage.AppendLine("                  or one of the following bulk-propping commands:");
            usage.AppendLine("                      BVT             Prop all titles marked as BVT titles.");
            usage.AppendLine("                      Acceptance      Prop all titles marked as Acceptance titles.");
            usage.AppendLine("                      Extended        Prop all titles marked as Extended titles.");
            usage.AppendLine("                      All             Prop all three title types.");
            usage.AppendLine("                  Title IDs must be specified in hex and may include the leading 0x.");
            usage.AppendLine("                  When specifying a list of Title IDs, separate them with commas and without spaces.");
            usage.AppendLine("Optional Parameters :");
            usage.AppendLine("    manifest      Overrides the location of the manifest file from the TPPSettings.xml file.");
            usage.AppendLine("    titlesource   Overrides the Title Source location from the TPPSettings.xml file.");
            usage.AppendLine("    threads       Overrides the Threads setting in the TPPSettings.xml file. The maximum is 20.");
            usage.AppendLine("    toolspath     Overrides the LiveToolsLocation path in the TPPSettings.xml file.");
            usage.AppendLine("    loglocation   Overrides the LogLocation path in the TPPSettings.xml file.");
            usage.AppendLine("    reportonly    Creates a report of all actions to be taken without actually running anything.");
            usage.AppendLine();
            Console.Write(usage.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\UserConfigCertConfigTests\Client\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Client")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("Client")]
[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("09dc5df0-a5cb-4c03-b7e2-505a6412e8e4")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\UserConfigCertConfigTests\GenevaDeploymentTests\common.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;

namespace GenevaDeploymentTests
{
    public class SiteXml
    {
        private String SiteXmlPathFileName;
        private XmlDocument xml;
        private Dictionary<String, Credentials> creds;
        private Dictionary<String, Certificate> certs;


        public SiteXml() : this("\\\\josephfo\\share\\" + Guid.NewGuid().ToString() + ".xml") { }

        public SiteXml(String UNCPath)
        {
            this.SiteXmlPathFileName = UNCPath;
            xml = new XmlDocument();

            if (File.Exists(UNCPath))
            {
                xml.Load(UNCPath);
            }
            else
            {
                string Domain = Environment.ExpandEnvironmentVariables("%COMPUTERNAME%");
                // Lets create the file if it does not already exist.
                xml.LoadXml("<Site Name=\"XBlob\">" +
                    "<Domain Identifier=\"" + Domain + "\" Name=\"" + Domain + "\"></Domain>" +
                    "<Certificates Identifier=\"\" Name=\"\"></Certificates>" +
                    "</Site>");
                xml.Save(UNCPath);
            }
            FillCreds();
            FillCerts();
        }

        public void AddNonCertNonUserNodes()
        {
            XmlElement newElement = xml.CreateElement("NonUserNonCertElement");
            newElement.InnerText = "Random Data in Site.Xml";
            xml.DocumentElement.AppendChild(newElement);
            xml.Save(this.SiteXmlPathFilename);            
        }

        public Boolean NonCertNonUserNodesExist()
        {
            XmlNode myNode = xml.SelectSingleNode("/Site/NonUserNonCertElement");
            if (myNode == null) return false;
            if (myNode.InnerText != "Random Data in Site.Xml") return false;
            return true;
        }



        private void FillCreds()
        {
            this.creds = new Dictionary<string, Credentials>();

            XmlNodeList credNodes = xml.SelectNodes("//Account");
            foreach (XmlNode cred in credNodes)
            {
                String id = cred.Attributes["Identifier"].Value;
                String name = cred.Attributes["Name"].Value;
                String pw = cred.SelectSingleNode("Password").InnerText;
                Credentials c = new Credentials(name, pw, id);
                this.creds.Add(id, c);
            }
        }

        private void FillCerts()
        {
            this.certs = new Dictionary<string, Certificate>();

            XmlNodeList certNodes = xml.SelectNodes("//SSLCert");
            foreach (XmlNode cert in certNodes)
            {
                String id = cert.Attributes["Identifier"].Value;

                String file = String.Empty;
                String P7BFile = String.Empty;
                String CTLFile = String.Empty;
                String pw = String.Empty;

                if (cert.Attributes["File"] != null)
                    file = cert.Attributes["File"].Value;

                if (cert.Attributes["P7BFile"] != null)
                    P7BFile = cert.Attributes["P7BFile"].Value;

                if (cert.Attributes["CTLFile"] != null)
                    CTLFile = cert.Attributes["CTLFile"].Value;

                if (cert.SelectSingleNode("Password") != null)
                    pw = cert.SelectSingleNode("Password").InnerText;

                Certificate c = new Certificate(id, file, P7BFile, CTLFile, pw);

                this.certs.Add(id, c);
            }
        }

        public String SiteXmlPathFilename
        {
            get { return this.SiteXmlPathFileName; }
        }

        public Dictionary<String, Credentials> CredentialDictionary
        {
            get { return this.creds; }
        }

        public Dictionary<String, Certificate> CertificateDictionary
        {
            get { return this.certs; }
        }

        public void SaveSiteXmlToFile()
        {
            xml.Save(this.SiteXmlPathFileName);
        }



        public void AddCertToSiteXml(Certificate CertToAdd)
        {
            // memory
            this.certs.Add(CertToAdd.CertID, CertToAdd);

            // file
            //  <Certificates>
            //    <SSLCert Identifier="ssl.websg" File="joe.pfx" P7BFile="cert.p7b">
            //        <Password></Password>
            //    </SSLCert>
            //  </Certificates>
            XmlElement newCert = xml.CreateElement("SSLCert");
            XmlAttribute attRole = xml.CreateAttribute("Identifier");
            attRole.Value = CertToAdd.CertID;

            // only add the 'Path' node if it exists.
            if (!String.IsNullOrEmpty(CertToAdd.Path))
            {
                XmlAttribute attPath = xml.CreateAttribute("File");
                attPath.Value = CertToAdd.Path;
                newCert.Attributes.Append(attPath);
            }

            // only add the 'P7B' node if it exists.
            if (!String.IsNullOrEmpty(CertToAdd.P7BFile))
            {
                XmlAttribute attP7BFile = xml.CreateAttribute("P7BFile");
                attP7BFile.Value = CertToAdd.P7BFile;
                newCert.Attributes.Append(attP7BFile);
            }

            // only add the 'CTLFile' attribute if it exists.
            if (!String.IsNullOrEmpty(CertToAdd.CTLFile))
            {
                XmlAttribute attCTLFile = xml.CreateAttribute("CTLFile");
                attCTLFile.Value = CertToAdd.CTLFile;
                newCert.Attributes.Append(attCTLFile);
            }

            XmlElement newPassword = xml.CreateElement("Password");
            newPassword.InnerText = CertToAdd.Password;
            newCert.Attributes.Append(attRole);
            
            newCert.AppendChild(newPassword);

            xml.SelectSingleNode("/Site/Certificates").AppendChild(newCert);
            xml.Save(this.SiteXmlPathFilename);
        }


        public void DeleteCertFromSiteXml(String ID)
        {
            if (this.certs.ContainsKey(ID))
            {
                this.certs.Remove(ID);
            }
            else
            {
                // may want to throw here.
            }
        }

        public Certificate GetCert(String ID)
        {
            if (this.certs.ContainsKey(ID))
            {
                return this.certs[ID];
            }

            return null;
        }

        public void AddCredsToSiteXml(Credentials CredsToAdd)
        {
            // memory
            this.creds.Add(CredsToAdd.Role, CredsToAdd);

            // file
            XmlElement newAccount = xml.CreateElement("Account");
            XmlAttribute attRole = xml.CreateAttribute("Identifier");
            attRole.Value = CredsToAdd.Role;
            XmlAttribute attName = xml.CreateAttribute("Name");
            attName.Value = CredsToAdd.UserName;
            XmlElement newPassword = xml.CreateElement("Password");
            newPassword.InnerText = CredsToAdd.Password;
            newAccount.Attributes.Append(attRole);
            newAccount.Attributes.Append(attName);
            newAccount.AppendChild(newPassword);

            xml.SelectSingleNode("/Site/Domain").AppendChild(newAccount);
            xml.Save(this.SiteXmlPathFilename);
        }

        public void DeleteCredsFromSiteXml(String Role)
        {
            if (this.creds.ContainsKey(Role))
            {
                this.creds.Remove(Role);
            }
            else
            {
                // may want to throw here.
            }
        }

        public Credentials GetCreds(String Role)
        {
            if (this.creds.ContainsKey(Role))
            {
                return this.creds[Role];
            }

            return null;
        }


    }

    public class Certificate
    {
        private String certId;
        private String path;
        private String p7bFile;
        private String ctlFile;
        private String password;

        public Certificate(String CertID, String Path, String P7BFile, String CTLFile, String Password)
        {
            this.certId = CertID;
            this.path = Path;
            this.p7bFile = P7BFile;
            this.ctlFile = CTLFile;
            this.password = Password;
        }

        public String CertID
        {
            get { return this.certId; }
            set { this.certId = value; }
        }

        public String Path
        {
            get { return this.path; }
            set { this.path = value; }
        }

        public String P7BFile
        {
            get { return this.p7bFile; }
            set { this.p7bFile = value; }
        }

        public String CTLFile
        {
            get { return this.ctlFile; }
            set { this.ctlFile = value; }
        }

        public String Password
        {
            get { return this.password; }
            set { this.password = value; }
        }
    }

    public class Credentials
    {
        private String userName;
        private String password;
        private String role;
        public Credentials(String Username, String Password, String Role)
        {
            this.userName = Username;
            this.password = Password;
            this.role = Role;
        }

        public String UserName
        {
            get { return this.userName; }
            set { this.userName = value; }
        }

        public String Password
        {
            get { return this.password; }
            set { this.password = value; }
        }

        public String Role
        {
            get { return this.role; }
            set { this.role = value; }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\UserConfigCertConfigTests\GenevaDeploymentTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GenevaDeploymentTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("GenevaDeploymentTests")]
[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a8b5a6fc-52b4-4d30-86f6-e2e4fac736de")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\TitlePropPro\TitlePropPro\TitlePropPro.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Serialization;

namespace TPP
{
    public enum TitleType
    {
        Manual = 0,
        Acceptance,
        Extended,
        BVT,
        All
    }

    public enum TPPEventType
    {
        Debug,
        Status,
        Error
    }

    public class TPPEventArgs : EventArgs
    {
        public readonly TPPEventType Type;
        public readonly string Details;

        public TPPEventArgs(TPPEventType type, string details)
        {
            Type = type;
            Details = details;
        }
    }

    public delegate void TPPEventHandler (object sender, TPPEventArgs args);

    public class TitlePropPro
    {
        const int MAX_THREADS = 20;
        private static ReaderWriterLock rwl = new ReaderWriterLock();

        private Dictionary<string, EnvironmentData> _environments = null;
        private int _threadCount = 5;
        private string _toolsLocation = null;
        private int _toolsTimeout = 0;
        private bool _reportOnly = false;
        private bool _titlePropFailed = false;

        #region Eventing
        public event TPPEventHandler TppEvent;
        private void RaiseTppEvent(TPPEventArgs args)
        {
            if (TppEvent != null)
            {
                TppEvent(this, args);
            }
        }
        #endregion

        #region Properties
        
        public string LiveToolsLocation
        {
            get { return _toolsLocation; }
            set { _toolsLocation = value; }
        }

        public int ThreadCount
        {
            get { return _threadCount; }
            set
            {
                if (value >= 0 && value <= MAX_THREADS)
                    _threadCount = value;
            }
        }

        public int ToolsTimeout
        {
            get { return _toolsTimeout; }
            set
            {
                if (value <= 0)
                    _toolsTimeout = -1;
            }
        }

        public bool ReportOnly
        {
            get { return _reportOnly; }
            set { _reportOnly = value; }
        }

        #endregion

        public TitlePropPro() { }
        public bool Initialize(string configFilePath)
        {
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("Initializing settings from {0}...", configFilePath)));
            using (StreamReader stream = new StreamReader(configFilePath))
            {
                XPathDocument doc = new XPathDocument(stream);
                XPathNavigator docNav = doc.CreateNavigator();
                XPathNavigator configNode = null;
                docNav.MoveToFirstChild();
                if (docNav.Name != "TitlePropProConfig")
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, "  !! Invalid configuration file - the root element is not 'TitlePropProConfig'."));
                    return false;
                }

                //
                // Process the common configuration data
                //

                // Read the number of threads to use for propping
                configNode = docNav.SelectSingleNode("child::Threads");
                if (null != configNode)
                {
                    if (!Int32.TryParse(configNode.Value, out _threadCount))
                        _threadCount = 5;
                    if (_threadCount <= 0 || _threadCount > MAX_THREADS)
                        _threadCount = 5;
                }
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("  Thread count is set to {0}", _threadCount)));

                // Read the number of seconds to wait before killing a tool process
                configNode = docNav.SelectSingleNode("child::ToolsTimeoutSeconds");
                if (null != configNode)
                {
                    if (!Int32.TryParse(configNode.Value, out _toolsTimeout))
                        _toolsTimeout = 300;

                    if (_toolsTimeout < 0)
                        _toolsTimeout = -1;
                }
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("  Tools timeout is set to {0}", _toolsTimeout < 0 ? "Indefinate" : _toolsTimeout.ToString() + " seconds")));

                // Read the base location of the Live tools
                configNode = docNav.SelectSingleNode("child::LiveToolsLocation");
                if (null == configNode)
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, "  !! Unable to locate the 'LiveToolsLocation' element in the configuration file. The default will be used."));
                    _toolsLocation = @"D:\Webroot\XblTools";
                }
                _toolsLocation = configNode.Value;
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("  Live Tools Location is set to {0}", _toolsLocation)));

                //
                // Process the environment-specific settings
                //

                configNode = docNav.SelectSingleNode("child::Environments");
                if (null == configNode)
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, "  !! Unable to locate the 'Environments' element in the configuration file."));
                    return false;
                }
                XPathNodeIterator envItor = configNode.SelectChildren(XPathNodeType.Element);
                if (null == envItor)
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, "  !! There are no environment settings defined."));
                    return false;
                }
                _environments = new Dictionary<string, EnvironmentData>();
                while (envItor.MoveNext())
                {
                    string envName = envItor.Current.GetAttribute("Name", envItor.Current.NamespaceURI).ToLower();
                    if (!_environments.ContainsKey(envName))
                    {
                        EnvironmentData envData = new EnvironmentData(envName);
                        string machineName = Environment.MachineName;
                        XPathNavigator envNode;

                        // Read the source location for title configuration files
                        envNode = envItor.Current.SelectSingleNode("child::TitleSource");
                        if (null == envNode)
                        {
                            RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                                String.Format("  !! Unable to locate the 'TitleSource' element for the {0} environment.", envName)));
                            return false;
                        }
                        envData.TitleSource = envNode.Value.Replace("##XBLOB##", machineName);

                        // Read the location of the title manifest file
                        envNode = envItor.Current.SelectSingleNode("child::Manifest");
                        if (null == envNode)
                        {
                            RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                                String.Format("  !! Unable to locate the 'Manifest' element for the {0} environment.", envName)));
                            return false;
                        }
                        envData.Manifest = envNode.Value.Replace("##XBLOB##", machineName);

                        // Read the base location for the log files
                        envNode = envItor.Current.SelectSingleNode("child::LogLocation");
                        if (null == envNode)
                        {
                            RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                                String.Format("  !! Unable to locate the 'LogLocation' element for the {0} environment.", envName)));
                            return false;
                        }
                        envData.LogLocation = Path.Combine(envNode.Value.Replace("##XBLOB##", machineName),
                            DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"));

                        // Read the LBSvr name
                        envNode = envItor.Current.SelectSingleNode("child::LBSvr");
                        if (null == envNode)
                        {
                            RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("  !! Unable to locate the 'LBSvr' element for the {0} environment.", envName)));
                            return false;
                        }
                        envData.LBSvr = envNode.Value.Replace("##XBLOB##", machineName);

                        // Read the MatchSvr name
                        envNode = envItor.Current.SelectSingleNode("child::MatchSvr");
                        if (null == envNode)
                        {
                            RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("  !! Unable to locate the 'MatchSvr' element for the {0} environment.", envName)));
                            return false;
                        }
                        envData.MatchSvr = envNode.Value.Replace("##XBLOB##", machineName);

                        // Add the environment to the list of known environments
                        _environments.Add(envName, envData);
                    }
                }
            }
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Finished loading the program settings."));
            return true;
        }

        public void OverrideLogLocation(string environment, string logLocation)
        {
            // Validate the environment
            if (!_environments.ContainsKey(environment.ToLower()))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid environment: '{0}'", environment)));
                return;
            }
            _environments[environment].LogLocation = logLocation;
        }

        public void OverrideTitleManifest(string environment, string manifest)
        {
            // Validate the environment
            if (!_environments.ContainsKey(environment.ToLower()))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid environment: '{0}'", environment)));
                return;
            }
            _environments[environment].Manifest = manifest;
        }

        public void OverrideTitleSourceLocation(string environment, string titleSource)
        {
            // Validate the environment
            if (!_environments.ContainsKey(environment.ToLower()))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid environment: '{0}'", environment)));
                return;
            }
            _environments[environment].TitleSource = titleSource;
        }

        private void CreatePath(string path)
        {
            if (String.IsNullOrEmpty(path))
                throw new ArgumentException("Invalid path - cannot be null or empty.");

            string[] parts = path.Split(Path.DirectorySeparatorChar);
            bool isUNC = path.StartsWith("\\\\");
            int i = 0;
            StringBuilder tmpPath = new StringBuilder();

            if (isUNC)
            {
                tmpPath.Append(@"\\" + parts[2]);
                i = 3;
            }
            else
            {
                tmpPath.Append(parts[0]);
                i = 1;
            }

            try
            {
                for (; i < parts.Length; i++)
                {
                    tmpPath.Append(@"\" + parts[i]);
                    if (!Directory.Exists(tmpPath.ToString()))
                    {
                        Directory.CreateDirectory(tmpPath.ToString());
                    }
                }
            }
            catch (Exception ex)
            {
                throw new ApplicationException(String.Format("Unable to create part of the destination path '{0}'", tmpPath), ex);
            }
        }

        public int PropSingleTitle(string environment, string titleId)
        {
            // Validate the environment
            string envName = environment.ToLower();
            if (!_environments.ContainsKey(envName))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid environment: '{0}'", environment)));
                return -1;
            }

            // Report the current environment settings to be used
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status,
                String.Format("Environment settings:\r\n  Title Source : {0}\r\n  Log Location : {1}\r\n  Manifest     : {2}\r\n  LBSvr        : {3}\r\n  Match Server : {4}",
                _environments[envName].TitleSource, _environments[envName].LogLocation, _environments[envName].Manifest, _environments[envName].LBSvr, _environments[envName].MatchSvr)));

            // Load the manifest
            XPathDocument manifest = LoadManifest(_environments[envName].Manifest);
            if (null == manifest)
            {
                return -1;
            }

            // Validate the title id
            try
            {
                if (titleId.StartsWith("0x"))
                    titleId = titleId.Substring(2);
                UInt32.Parse(titleId, System.Globalization.NumberStyles.HexNumber);
            }
            catch (Exception)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid title id: '{0}'", titleId)));
                return -1;
            }

            // Validate the existance of the various resources
            if (!ValidateResources(environment))
                return -1;

            if (_reportOnly)
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "** Generating prop report **"));

            // Search the manifest for the title id
            XPathNavigator titleNode = manifest.CreateNavigator();
            titleNode.MoveToChild(XPathNodeType.Element);
            titleNode = titleNode.SelectSingleNode(String.Format("Titles/Title[@Id = '{0}']", titleId.ToUpper()));

            // If the manifest doesn't contain this title id, create a dummy node to perform a simple prop
            if (null == titleNode)
            {
                XmlDocument fragment = new XmlDocument();
                XmlElement el = fragment.CreateElement("Title");
                XmlAttribute att = fragment.CreateAttribute("Id");
                att.Value = titleId.ToUpper();
                el.Attributes.Append(att);
                fragment.AppendChild(el);
                titleNode = fragment.CreateNavigator();
                titleNode.MoveToFirstChild();
            }

            // Prop the title
            PropThreadState pts = new PropThreadState();
            pts.EnvironmentData = _environments[envName];
            pts.TitleNode = titleNode;
            PropTitle(pts);

            // One last task : use SystemCheck to reload the front doors
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Reloading front doors.."));
            StringBuilder scOutput = new StringBuilder();
            if (RunSystemCheck("/reloadfd /timeout:240000", scOutput) != 0)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                    String.Format("Reloading the front doors failed :\r\n\r\n{0}", scOutput.ToString())));
                return -1;
            }

            return _titlePropFailed ? 1 : 0;
        }

        public int PropMultipleTitles(string environment, string[] titleIdList)
        {
            // Validate the environment string
            string envName = environment.ToLower();
            if (!_environments.ContainsKey(envName))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid environment: '{0}'", environment)));
                return -1;
            }

            // Report the current environment settings to be used
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status,
                String.Format("Environment settings:\r\n  Title Source : {0}\r\n  Log Location : {1}\r\n  Manifest     : {2}\r\n  LBSvr        : {3}\r\n  Match Server : {4}",
                _environments[envName].TitleSource, _environments[envName].LogLocation, _environments[envName].Manifest, _environments[envName].LBSvr, _environments[envName].MatchSvr)));

            // Load the manifest
            XPathDocument manifest = LoadManifest(_environments[envName].Manifest);
            if (null == manifest)
            {
                return -1;
            }

            // Validate the existance of the various resources
            if (!ValidateResources(environment))
                return -1;

            if (_reportOnly)
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "** Generating prop report **"));

            if (titleIdList != null && titleIdList.Length > 0)
            {
                // Set up the thread pool with the maximum number of threads
                ThreadPool.SetMinThreads(_threadCount, _threadCount);
                ThreadPool.SetMaxThreads(_threadCount, _threadCount);

                // Prop the list of titles
                for (int i = 0; i < titleIdList.Length; i++)
                {
                    // Validate the title id
                    string titleId = "";
                    try
                    {
                        if (titleIdList[i].StartsWith("0x"))
                            titleId = titleIdList[i].Substring(2);
                        else
                            titleId = titleIdList[i];
                        UInt32.Parse(titleId, System.Globalization.NumberStyles.HexNumber);
                    }
                    catch (Exception)
                    {
                        RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid title id: '{0}'", titleId)));
                        continue;
                    }

                    // Search the manifest for the title id
                    XPathNavigator titleNode = manifest.CreateNavigator();
                    titleNode.MoveToChild(XPathNodeType.Element);
                    titleNode = titleNode.SelectSingleNode(String.Format("Titles/Title[@Id = '{0}']", titleId.ToUpper()));

                    // If the manifest doesn't contain this title id, create a dummy node to perform a simple prop
                    if (null == titleNode)
                    {
                        XmlDocument fragment = new XmlDocument();
                        XmlElement el = fragment.CreateElement("Title");
                        XmlAttribute att = fragment.CreateAttribute("Id");
                        att.Value = titleId.ToUpper();
                        el.Attributes.Append(att);
                        fragment.AppendChild(el);
                        titleNode = fragment.CreateNavigator();
                        titleNode.MoveToFirstChild();
                    }

                    // Prop the title
                    PropThreadState pts = new PropThreadState();
                    pts.EnvironmentData = _environments[envName];
                    pts.TitleNode = titleNode;
                    ThreadPool.QueueUserWorkItem(new WaitCallback(PropTitle), pts);
                    Thread.Sleep(5000); // Sleep 5 seconds before kicking off the next thread
                }

                // wait for all the thread pool threads to exit
                int maxThreads, availThreads = 0;
                int maxIOPorts, availIOPorts = 0;
                ThreadPool.GetMaxThreads(out maxThreads, out maxIOPorts);
                while (maxThreads != availThreads)
                {
                    Thread.Sleep(10000);
                    ThreadPool.GetAvailableThreads(out availThreads, out availIOPorts);
                }

                // One last task : use SystemCheck to reload the front doors
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Reloading front doors.."));
                StringBuilder scOutput = new StringBuilder();
                if (RunSystemCheck("/reloadfd /timeout:240000", scOutput) != 0)
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                        String.Format("Reloading the front doors failed :\r\n\r\n{0}", scOutput.ToString())));
                    return -1;
                }
            }
            else
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Empty Title ID list - nothing to do."));
            }

            return _titlePropFailed ? 1 : 0;
        }

        public int PropTitleGroup(string environment, string titleType)
        {
            // Validate the environment string
            string envName = environment.ToLower();
            if (!_environments.ContainsKey(envName))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid environment: '{0}'", environment)));
                return -1;
            }

            // Report the current environment settings to be used
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status,
                String.Format("Environment settings:\r\n  Title Source : {0}\r\n  Log Location : {1}\r\n  Manifest     : {2}\r\n  LBSvr        : {3}\r\n  Match Server : {4}",
                _environments[envName].TitleSource, _environments[envName].LogLocation, _environments[envName].Manifest, _environments[envName].LBSvr, _environments[envName].MatchSvr)));

            // Load the manifest
            XPathDocument manifest = LoadManifest(_environments[envName].Manifest);
            if (null == manifest)
            {
                return -1;
            }

            // Validate the title type by converting it into the appropriate enumeration
            TitleType ttype;
            try
            {
                ttype = (TitleType)Enum.Parse(typeof(TitleType), titleType, true);
            }
            catch (Exception)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Invalid title type: {0}", titleType)));
                return -1;
            }

            // Validate the existance of the various resources
            if (!ValidateResources(environment))
                return -1;

            if (_reportOnly)
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "** Generating prop report **"));

            // Set up the thread pool with the maximum number of threads
            ThreadPool.SetMinThreads(_threadCount, _threadCount);
            ThreadPool.SetMaxThreads(_threadCount, _threadCount);

            // Prop all titles of the given type
            XPathNodeIterator titles;
            XPathNavigator docNav = manifest.CreateNavigator();
            docNav.MoveToChild(XPathNodeType.Element);
            if (String.Compare(TitleType.All.ToString(), titleType, true) == 0)
            {
                titles = docNav.Select(String.Format("Titles/Title[@Type='{0}' or @Type='{1}' or @Type='{2}']",
                    TitleType.BVT, TitleType.Acceptance, TitleType.Extended));
            }
            else
            {
                titles = docNav.Select(String.Format("Titles/Title[@Type = '{0}']", ttype.ToString()));
            }

            if (titles.Count > 0)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("Beginning the propping of {0} titles", titleType)));
                while (titles.MoveNext())
                {
                    PropThreadState pts = new PropThreadState();
                    pts.EnvironmentData = _environments[envName];
                    pts.TitleNode = titles.Current.Clone();
                    ThreadPool.QueueUserWorkItem(new WaitCallback(PropTitle), pts);
                    Thread.Sleep(5000); // Sleep 5 seconds before kicking off the next thread
                }

                // wait for all the thread pool threads to exist
                int maxThreads, availThreads = 0;
                int maxIOPorts, availIOPorts = 0;
                ThreadPool.GetMaxThreads(out maxThreads, out maxIOPorts);
                while (maxThreads != availThreads)
                {
                    Thread.Sleep(10000);
                    ThreadPool.GetAvailableThreads(out availThreads, out availIOPorts);
                }

                // One last task : use SystemCheck to reload the front doors
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Reloading front doors.."));
                StringBuilder scOutput = new StringBuilder();
                if (RunSystemCheck("/reloadfd /timeout:240000", scOutput) != 0)
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                        String.Format("Reloading the front doors failed :\r\n\r\n{0}", scOutput.ToString())));
                    return -1;
                }
            }
            else
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status,
                    String.Format("No titles of type '{0}' were found in the manifest. Nothing to do.", titleType)));
            }

            return _titlePropFailed ? 1 : 0;
        }

        private XPathDocument LoadManifest(string manifest)
        {
            XPathDocument manifestDocument = null;

            if (null == manifest)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, "Invalid title manifest location."));
                return null;
            }

            // Load the manifest, validating it against the xsd file
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("Reading the manifest : {0}...", manifest)));
            try
            {
                using (StreamReader sr = new StreamReader(manifest))
                {
                    string xsdFile = Path.Combine(Path.GetDirectoryName(manifest), "TitleManifest.xsd");
                    XmlReaderSettings xrs = new XmlReaderSettings();
                    xrs.ValidationType = ValidationType.Schema;
                    xrs.Schemas.Add(null, xsdFile);
                    using (XmlReader xr = XmlReader.Create(sr, xrs))
                    {
                        manifestDocument = new XPathDocument(xr);
                    }
                }
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Manifest successfully loaded and validated."));
            }
            catch (Exception ex)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                    String.Format("!! Unable to load the Title Manifest file '{0}':\r\n     {1}", manifest, ex.Message)));
                manifestDocument = null;
            }

            return manifestDocument;
        }

        private bool ValidateResources(string envName)
        {
            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Validating resources..."));

            EnvironmentData env = _environments[envName];
            bool valid = true;

            // Validate the LiveTools location
            if (!Directory.Exists(_toolsLocation))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("  !! Invalid LiveTools location : '{0}'", _toolsLocation)));
                valid = false;
            }

            // Validate the TitleSource location
            if (!Directory.Exists(env.TitleSource))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("  !! Invalid TitleSource location : '{0}'", env.TitleSource)));
                valid = false;
            }

            // Validate the Manifest location
            if (!File.Exists(env.Manifest))
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("  !! Invalid Manifest location : '{0}'", env.Manifest)));
                valid = false;
            }

            // Validate the Log location
            try
            {
                if (!Directory.Exists(Path.GetDirectoryName(env.LogLocation)))
                {
                    CreatePath(env.LogLocation);
                }
            }
            catch (Exception ex)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("  !! Unable to find or create the Log location : '{0}'", ex.Message)));
                valid = false;
            }

            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, "Done."));
            return valid;
        }
        
        private void PropTitle(object stateInfo)
        {
            PropThreadState pts = stateInfo as PropThreadState;
            if (null == pts)
                throw new ArgumentNullException("NULL thread state object passed to the PropTitle thread!");

            bool propResult = false;
            string titleName = pts.TitleNode.GetAttribute("FriendlyName", pts.TitleNode.NamespaceURI);
            string titleId = pts.TitleNode.GetAttribute("Id", pts.TitleNode.NamespaceURI);
            string titleDir = Path.Combine(pts.EnvironmentData.TitleSource, titleId);
            string localLogFileName = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                String.Format("{0}_{1}.log", titleId, DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss")));

            if (!String.IsNullOrEmpty(titleName))
                titleName += " (0x" + titleId + ")";
            else
                titleName = "0x" + titleId;

            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status, String.Format("Starting {0} title prop...", titleName)));
            try
            {
                using (StreamWriter logFile = new StreamWriter(localLogFileName))
                {
                    logFile.AutoFlush = true;

                    if (Directory.Exists(titleDir))
                    {
                        string xlastPath = Path.Combine(titleDir, String.Format("{0}.xlast", titleId));
                        string xboxPath = Path.Combine(titleDir, String.Format("{0}.xbox", titleId));
                        string marketplacePath = Path.Combine(titleDir, String.Format("{0}.marketplace", titleId));
                        if (File.Exists(xlastPath))
                        {
                            // Deploying an Xbox360 title
                            propResult = PropXbox360Title(xlastPath, titleId, pts.TitleNode, pts.EnvironmentData, logFile);
                        }
                        else if (File.Exists(xboxPath))
                        {
                            // Deploying an Xbox1 title
                            propResult = PropXbox1Title(xboxPath, titleId, pts.TitleNode, pts.EnvironmentData, logFile);
                        }
                        else if (File.Exists(marketplacePath))
                        {
                            // Deploying an Xbox360 title
                            propResult = PropMarketplaceTitle(marketplacePath, titleId, pts.TitleNode, pts.EnvironmentData, logFile);
                        }
                        else
                        {
                            logFile.WriteLine(String.Format("There are no Game Configuration files in {0}. Unable to continue.", titleDir));
                        }
                    }
                    else
                    {
                        logFile.WriteLine(String.Format("The directory for the {0} title doesn't exist. Unable to continue", titleName));
                    }
                }
            }
            catch (Exception ex)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error,
                    String.Format("An unhandled exception occurred while propping {0}:\r\n{1}", titleName, ex)));
                propResult = false;
            }

            // Move the local log file to the permanent log file location
            string logFileName = Path.Combine(pts.EnvironmentData.LogLocation, String.Format("{0}_{1}.log",
                Path.GetFileNameWithoutExtension(localLogFileName), propResult ? "Pass" : "Fail"));
            try
            {
                if (!Directory.Exists(pts.EnvironmentData.LogLocation))
                    Directory.CreateDirectory(pts.EnvironmentData.LogLocation);
                File.Move(localLogFileName, logFileName);
            }
            catch (Exception ex)
            {
                RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, String.Format("Unable to move {0} : {1}", localLogFileName, ex.Message)));
            }

            RaiseTppEvent(new TPPEventArgs(TPPEventType.Status,
                String.Format("Finished propping {0}. Result = {1}. Log file = {2}", titleName, propResult ? "Success" : "Failure", logFileName)));

            // Update the global failure flag if this title failed to prop
            if (!propResult)
            {
                try
                {
                    rwl.AcquireWriterLock(300000);
                    _titlePropFailed = true;
                }
                catch (Exception)
                {
                    RaiseTppEvent(new TPPEventArgs(TPPEventType.Error, "Timeout expired waiting to update the global prop fail flag."));
                }
                finally
                {
                    rwl.ReleaseLock();
                }
            }
        }

        internal bool PropXbox1Title(string xboxFile, string titleId, XPathNavigator titleNode, EnvironmentData env, StreamWriter logFile)
        {
            int ret = 0;
            int toolRet = 0;
            string ltcFile = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), String.Format("{0}_ltc.xml", titleId));
            string xscFile = Path.Combine(Path.GetDirectoryName(xboxFile), String.Format("{0}.xsc", titleId));
            string xmsFile = Path.Combine(Path.GetDirectoryName(xboxFile), String.Format("{0}.xms", titleId));
            string xqsFile = Path.Combine(Path.GetDirectoryName(xboxFile), String.Format("{0}.xqs", titleId));
            bool xscFileExists = false;
            bool xmsFileExists = false;
            StringBuilder toolOutput = new StringBuilder();
            StringBuilder args = new StringBuilder();

            logFile.WriteLine("\r\n***** Title Prop Beginning at {0}. *****\r\n", DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"));

            // Delete any existing LTC files for this title
            if (File.Exists(ltcFile) && !_reportOnly)
            {
                try
                {
                    File.Delete(ltcFile);
                }
                catch (Exception) { }
            }

            // If there's an LTC fragment in the source directory, copy it into the temp directory before creating the new LTC file
            string ltcFragment = Path.Combine(Path.GetDirectoryName(xboxFile), String.Format("{0}_ltc.xml", titleId));
            if (File.Exists(ltcFragment))
            {
                logFile.WriteLine("*****\r\n\r\n  Copying the LTC fragment to the working directory.\r\n\r\n*****");
                if (!_reportOnly)
                {
                    try
                    {
                        logFile.WriteLine("{0} -> {1}", ltcFragment, ltcFile);
                        File.Copy(ltcFragment, ltcFile, true);
                    }
                    catch (Exception ex)
                    {
                        logFile.WriteLine("ERROR : The LTC fragment couldn't be copied to the working directory: {0}", ex.Message);
                        return false;
                    }
                }
            }

            // Determine if an XSC and XMS file exists for this title
            xscFileExists = File.Exists(xscFile);
            xmsFileExists = File.Exists(xmsFile);

            // Create the LTC file
            logFile.WriteLine("\r\n*****\r\n\r\n  Creating the LTC file.\r\n\r\n*****");
            args.AppendFormat("/xboxdefault /xboxpath:{0} /lbs:{1} /matchsvr:{2}", xboxFile, env.LBSvr, env.MatchSvr);
            if (xscFileExists)
            args.AppendFormat(" /xscpath:{0}", xscFile);
            ret = RunLiveTitle(args.ToString(), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (ret != 0)
            {
                return false;
            }
            toolOutput.Length = 0;

            // Deploy the title
            logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the title.\r\n\r\n*****");
            args.Length = 0;
            args.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1} /images /noreload", xboxFile, ltcFile);
            if (xscFileExists)
                args.AppendFormat(" /xscpath:{0}", xscFile);
            if (xmsFileExists)
                args.AppendFormat(" /xmspath:{0}", xmsFile);
            ret = RunLiveTitle(args.ToString(), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (ret != 0)
            {
                return false;
            }
            toolOutput.Length = 0;

            // Deploy the leaderboards (but only if we deployed an xsc file)
            if (xscFileExists)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the leaderboards.\r\n\r\n*****");
                toolRet = RunLiveStats(String.Format("/deployxboxlb /titleid:0x{0} /force", titleId), toolOutput);
                logFile.WriteLine(toolOutput.ToString());
                if (0 == ret)
                    ret = toolRet;
                toolOutput.Length = 0;
            }

            // Deploy matchmaking (but only if we deployed an xms file)
            if (xmsFileExists)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Deploying matchmaking.\r\n\r\n*****");
                toolRet = RunLiveMatch(String.Format("/deployxboxmatch /titleid:0x{0} /noreload /overridebuckets", titleId), toolOutput);
                logFile.WriteLine(toolOutput.ToString());
                if (0 == ret)
                    ret = toolRet;
                toolOutput.Length = 0;
            }

            // Deploy any XQS files
            if (File.Exists(xqsFile))
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the XQS file.\r\n\r\n*****");
                toolRet = RunPropXQS(String.Format("/xqs:{0}", xqsFile), toolOutput);
                logFile.WriteLine(toolOutput.ToString());
                if (0 == ret)
                    ret = toolRet;
                toolOutput.Length = 0;
            }

            // The order of execution is:
            //  Execute PreOffer commands
            //  Deploy all Offers
            //  Execute all other commands
            //  Execute EnvironmentSpecific commands

            // Run any PreOffer steps
            XPathNavigator preOffer = titleNode.SelectSingleNode("child::PreOffer");
            if (preOffer != null)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Running the Pre-Offer commands.\r\n\r\n*****");
                toolRet = ExecuteCommands(preOffer, titleId, Path.GetDirectoryName(xboxFile), toolOutput);
                if (0 == ret)
                    ret = toolRet;
                logFile.WriteLine(toolOutput.ToString());
                toolOutput.Length = 0;
            }

            // Deploy all offers
            string[] offers = Directory.GetFiles(Path.GetDirectoryName(xboxFile), "*.offer");
            if (offers.Length > 0)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the offers.\r\n\r\n*****");
                foreach (string offerFile in offers)
                {
                    toolRet = RunLiveOffer(String.Format("-action:propxbox -file:{0} -titleid:0x{1} -noreload -notransaction", offerFile, titleId), toolOutput);
                    if (0 == ret)
                        ret = toolRet;
                    logFile.WriteLine(toolOutput.ToString());
                    toolOutput.Length = 0;
                }
            }

            // Execute all other commands
            logFile.WriteLine("\r\n*****\r\n\r\n  Running other title-specific deployment commands.\r\n\r\n*****");
            toolRet = ExecuteCommands(titleNode, titleId, Path.GetDirectoryName(xboxFile), toolOutput);
            if (0 == ret)
                ret = toolRet;
            logFile.WriteLine(toolOutput.ToString());
            toolOutput.Length = 0;

            // Run any Environment specific commands
            XPathNavigator envSpecific = titleNode.SelectSingleNode("child::EnvironmentSpecific");
            if (envSpecific != null)
            {
                // Verify the current environment is in the list of environments
                string [] envList = envSpecific.GetAttribute("Name", titleNode.NamespaceURI).Split(',');
                foreach (string envName in envList)
                {
                    if (String.Compare(envName.Trim(), env.Name, true) == 0)
                    {
                        logFile.WriteLine("\r\n*****\r\n\r\n  Running the environment specific commands.\r\n\r\n*****");
                        toolRet = ExecuteCommands(envSpecific, titleId, Path.GetDirectoryName(xboxFile), toolOutput);
                        if (0 == ret)
                            ret = toolRet;
                        logFile.WriteLine(toolOutput.ToString());
                    }
                }
            }

            logFile.WriteLine("\r\n***** Title Prop Completed at {0}. *****", DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"));

            return (0 == ret);
        }

        internal bool PropXbox360Title(string xlastFile, string titleId, XPathNavigator titleNode, EnvironmentData env, StreamWriter logFile)
        {
            int toolRet = 0;
            int ret = 0;
            string ltcFile = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), String.Format("{0}_ltc.xml", titleId));
            StringBuilder toolOutput = new StringBuilder();

            logFile.WriteLine("\r\n***** Title Prop Beginning at {0}. *****\r\n", DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"));

            // Delete any existing LTC files for this title
            if (File.Exists(ltcFile) && !_reportOnly)
            {
                try
                {
                    File.Delete(ltcFile);
                }
                catch(Exception){}
            }

            // If there's an LTC fragment in the source directory, copy it into the temp directory before creating the new LTC file
            string ltcFragment = Path.Combine(Path.GetDirectoryName(xlastFile), String.Format("{0}_ltc.xml", titleId));
            if (File.Exists(ltcFragment))
            {
                logFile.WriteLine("*****\r\n\r\n  Copying the LTC fragment to the working directory.\r\n\r\n*****");
                if (!_reportOnly)
                {
                    try
                    {
                        logFile.WriteLine("{0} -> {1}", ltcFragment, ltcFile);
                        File.Copy(ltcFragment, ltcFile, true);
                    }
                    catch (Exception ex)
                    {
                        logFile.WriteLine("ERROR : The LTC fragment couldn't be copied to the working directory: {0}", ex.Message);
                        return false;
                    }
                }
            }


            // Create the LTC file
            logFile.WriteLine("\r\n*****\r\n\r\n  Creating the LTC file.\r\n\r\n*****");
            ret = RunLiveTitle(String.Format("/livetitledefault /xlastpath:{0} /lbs:{1} /matchsvr:{2}", xlastFile, env.LBSvr, env.MatchSvr), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (ret != 0)
            {
                return false;
            }
            toolOutput.Length = 0;

            // Deploy the title
            logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the title.\r\n\r\n*****");
            ret = RunLiveTitle(String.Format("/deploy /xlastpath:{0} /ltcpath:{1} /images /noreload", xlastFile, ltcFile), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (ret != 0)
            {
                return false;
            }
            toolOutput.Length = 0;

            // Deploy the leaderboards
            logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the leaderboards.\r\n\r\n*****");
            toolRet = RunLiveStats(String.Format("/deploylb /titleid:0x{0} /force", titleId), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (0 == ret)
                ret = toolRet;
            toolOutput.Length = 0;

            // Deploy matchmaking
            logFile.WriteLine("\r\n*****\r\n\r\n  Deploying matchmaking.\r\n\r\n*****");
            toolRet = RunLiveMatch(String.Format("/deploymatch /titleid:0x{0} /noreload /overridebuckets /removemode", titleId), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (0 == ret)
                ret = toolRet;
            toolOutput.Length = 0;

            // The order of execution is:
            //  Execute PreOffer commands
            //  Deploy all Offers
            //  Execute all other commands
            //  Execute EnvironmentSpecific commands

            // Run any PreOffer steps
            XPathNavigator preOffer = titleNode.SelectSingleNode("child::PreOffer");
            if (preOffer != null)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Running the Pre-Offer commands.\r\n\r\n*****");
                toolRet = ExecuteCommands(preOffer, titleId, Path.GetDirectoryName(xlastFile), toolOutput);
                if (0 == ret)
                    ret = toolRet;
                logFile.WriteLine(toolOutput.ToString());
                toolOutput.Length = 0;
            }

            // Deploy all offers
            string[] offers = Directory.GetFiles(Path.GetDirectoryName(xlastFile), "*.offer");
            if (offers.Length > 0)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the offers.\r\n\r\n*****");
                foreach (string offerFile in offers)
                {
                    toolRet = RunLiveOffer(String.Format("-action:prop -file:{0} -titleid:0x{1} -noreload -notransaction", offerFile, titleId), toolOutput);
                    if (0 == ret)
                        ret = toolRet;
                    logFile.WriteLine(toolOutput.ToString());
                    toolOutput.Length = 0;
                }
            }

            // Execute all other commands
            logFile.WriteLine("\r\n*****\r\n\r\n  Running other title-specific deployment commands.\r\n\r\n*****");
            toolRet = ExecuteCommands(titleNode, titleId, Path.GetDirectoryName(xlastFile), toolOutput);
            if (0 == ret)
                ret = toolRet;
            logFile.WriteLine(toolOutput.ToString());
            toolOutput.Length = 0;

            // Run any Environment specific commands
            XPathNavigator envSpecific = titleNode.SelectSingleNode("child::EnvironmentSpecific");
            if (envSpecific != null)
            {
                // Verify the current environment is in the list of environments
                string [] envList = envSpecific.GetAttribute("Name", titleNode.NamespaceURI).Split(',');
                foreach (string envName in envList)
                {
                    if (String.Compare(envName.Trim(), env.Name, true) == 0)
                    {
                        logFile.WriteLine("\r\n*****\r\n\r\n  Running the environment specific commands.\r\n\r\n*****");
                        toolRet = ExecuteCommands(envSpecific, titleId, Path.GetDirectoryName(xlastFile), toolOutput);
                        if (0 == ret)
                            ret = toolRet;
                        logFile.WriteLine(toolOutput.ToString());
                    }
                }
            }

            logFile.WriteLine("\r\n***** Title Prop Completed at {0}. *****", DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"));

            return (0 == ret);
        }

        internal bool PropMarketplaceTitle(string marketplaceFile, string titleId, XPathNavigator titleNode, EnvironmentData env, StreamWriter logFile)
        {
            StringBuilder toolOutput = new StringBuilder();
            int toolRet = 0;
            int ret = 0;

            logFile.WriteLine("\r\n***** Title Prop Beginning at {0}. *****\r\n", DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"));

            // Deploy the title
            logFile.WriteLine("*****\r\n\r\n  Deploying the title.\r\n\r\n*****");
            ret = RunLiveTitle(String.Format("/deploy /marketplacepath:{0} /images /noreload", marketplaceFile), toolOutput);
            logFile.WriteLine(toolOutput.ToString());
            if (ret != 0)
            {
                return false;
            }
            toolOutput.Length = 0;

            // Run any PreOffer steps
            XPathNavigator preOffer = titleNode.SelectSingleNode("child::PreOffer");
            if (preOffer != null)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Running the Pre-Offer commands.\r\n\r\n*****");
                toolRet = ExecuteCommands(preOffer, titleId, Path.GetDirectoryName(marketplaceFile), toolOutput);
                if (0 == ret)
                    ret = toolRet;
                logFile.WriteLine(toolOutput.ToString());
                toolOutput.Length = 0;
            }

            // Deploy all offers
            string[] offers = Directory.GetFiles(Path.GetDirectoryName(marketplaceFile), "*.offer");
            if (offers.Length > 0)
            {
                logFile.WriteLine("\r\n*****\r\n\r\n  Deploying the offers.\r\n\r\n*****");
                foreach (string offerFile in offers)
                {
                    toolRet = RunLiveOffer(String.Format("-action:prop -file:{0} -titleid:0x{1} -noreload -notransaction", offerFile, titleId), toolOutput);
                    if (0 == ret)
                        ret = toolRet;
                    logFile.WriteLine(toolOutput.ToString());
                    toolOutput.Length = 0;
                }
            }

            // Execute all other commands
            logFile.WriteLine("\r\n*****\r\n\r\n  Running other title-specific deployment commands.\r\n\r\n*****");
            toolRet = ExecuteCommands(titleNode, titleId, Path.GetDirectoryName(marketplaceFile), toolOutput);
            if (0 == ret)
                ret = toolRet;
            logFile.WriteLine(toolOutput.ToString());
            toolOutput.Length = 0;

            // Run any Environment specific commands
            XPathNavigator envSpecific = titleNode.SelectSingleNode("child::EnvironmentSpecific");
            if (envSpecific != null)
            {
                // Verify the current environment is in the list of environments
                string [] envList = envSpecific.GetAttribute("Name", titleNode.NamespaceURI).Split(',');
                foreach (string envName in envList)
                {
                    if (String.Compare(envName.Trim(), env.Name, true) == 0)
                    {
                        logFile.WriteLine("\r\n*****\r\n\r\n  Running the environment specific commands.\r\n\r\n*****");
                        toolRet = ExecuteCommands(envSpecific, titleId, Path.GetDirectoryName(marketplaceFile), toolOutput);
                        if (0 == ret)
                            ret = toolRet;
                        logFile.WriteLine(toolOutput.ToString());
                    }
                }
            }

            logFile.WriteLine("\r\n***** Title Prop Completed at {0}. *****", DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"));

            return (0 == ret);
        }

        private int ExecuteCommands(XPathNavigator cmdNode, string titleId, string titleSourceDir, StringBuilder output)
        {
            XPathNodeIterator cmdsItor = cmdNode.Select("child::*");
            StringBuilder args = new StringBuilder();
            int result = 0;
            int toolResult = 0;

            while (cmdsItor.MoveNext())
            {
                XPathNavigator cmd = cmdsItor.Current;
                args.Length = 0;
                switch (cmdsItor.Current.Name)
                {
                    case "LiveStats":
                        {
                            string action = cmd.GetAttribute("Action", cmd.NamespaceURI);
                            string force = cmd.GetAttribute("Force", cmd.NamespaceURI);

                            args.AppendFormat("/{0} /titleid:0x{1}", action, titleId);
                            if ((String.Compare(force, Boolean.TrueString, true) == 0) || force == "1")
                                args.Append(" /force");

                            toolResult = RunLiveStats(args.ToString(), output);
                        }
                        break;
                    case "LiveContent":
                        {
                            string offerId = cmd.GetAttribute("OfferId", cmd.NamespaceURI);
                            string offerFile = cmd.GetAttribute("OfferFile", cmd.NamespaceURI);
                            string offerId2 = cmd.GetAttribute("OfferId2", cmd.NamespaceURI);
                            string offerFile2 = cmd.GetAttribute("OfferFile2", cmd.NamespaceURI);
                            string package = cmd.GetAttribute("Package", cmd.NamespaceURI);
                            string overwrite = cmd.GetAttribute("Overwrite", cmd.NamespaceURI);
                            string xrls = cmd.GetAttribute("XRLS", cmd.NamespaceURI);
                            string shares = cmd.GetAttribute("Shares", cmd.NamespaceURI);
                            string isDefaultOffer = cmd.GetAttribute("IsDefaultOffer", cmd.NamespaceURI);
                            string useDefaultOffer = cmd.GetAttribute("UseDefaultOffer", cmd.NamespaceURI);
                            string update = cmd.GetAttribute("Update", cmd.NamespaceURI);
                            string noReload = cmd.GetAttribute("NoReload", cmd.NamespaceURI);

                            args.AppendFormat("/action:{0} /titleid:{1} /site:{2}", cmd.GetAttribute("Action", cmd.NamespaceURI).ToLower(),
                                titleId, cmd.GetAttribute("Site", cmd.NamespaceURI));
                            if (offerId.Length > 0)
                            {
                                if (offerFile.Length == 0)
                                    offerFile = String.Format("{0}.offer", offerId);
                                if (package.Length == 0)
                                    package = String.Format("{0}.cab", offerId);

                                args.AppendFormat(" /offerid:{0} /offerfile:{1}", offerId, Path.Combine(titleSourceDir, offerFile));
                            }
                            args.AppendFormat(" /package:{0}", Path.Combine(titleSourceDir,package));
                            if (offerId2.Length > 0)
                            {
                                if (offerFile2.Length == 0)
                                    offerFile2 = String.Format("{0}.offer", offerId2);
                                args.AppendFormat(" /offerid2:{0} /offerfile2:{1}", offerId2, Path.Combine(titleSourceDir,offerFile2));
                            }
                            if (xrls.Length > 0)
                                args.AppendFormat(" /xrls:{0}", xrls);
                            if (shares.Length > 0)
                                args.AppendFormat(" /shares:{0}", shares);
                            if (isDefaultOffer.Length > 0)
                                args.AppendFormat(" /isdefaultoffer:{0}", isDefaultOffer.ToLower());
                            if ((String.Compare(overwrite, Boolean.TrueString, true) == 0) || overwrite == "1")
                                args.Append(" /overwrite");
                            if ((String.Compare(useDefaultOffer, Boolean.TrueString, true) == 0) || useDefaultOffer == "1")
                                args.Append(" /usedefaultoffer");
                            if (update.Length > 0)
                                args.AppendFormat(" /update:{0}", update);
                            if ((String.Compare(noReload, Boolean.TrueString, true) == 0) || noReload == "1")
                                args.Append(" /noreload");

                            toolResult = RunLiveContent(args.ToString(), output);
                        }
                        break;
                    case "LiveOffer":
                        {
                            string targetDb = cmd.GetAttribute("TargetDb", cmd.NamespaceURI);
                            string noTransaction = cmd.GetAttribute("NoTransaction", cmd.NamespaceURI);
                            string noReload = cmd.GetAttribute("NoReload", cmd.NamespaceURI);

                            args.AppendFormat("-action:{0} -file:{1} -titleid:0x{2}",
                                cmd.GetAttribute("Action", cmd.NamespaceURI).ToLower(),
                                Path.Combine(titleSourceDir, cmd.GetAttribute("File", cmd.NamespaceURI)),
                                titleId);
                            if (targetDb.Length > 0)
                                args.AppendFormat(" -targetdb:{0}", targetDb);
                            if ((String.Compare(noTransaction, Boolean.TrueString, true) == 0) || noTransaction == "1")
                                args.Append(" -notransaction");
                            if ((String.Compare(noReload, Boolean.TrueString, true) == 0) || noReload == "1")
                                args.Append(" -noreload");

                            toolResult = RunLiveOffer(args.ToString(), output);
                        }
                        break;
                    case "LiveLSP":
                        {
                            string action = cmd.GetAttribute("Action", cmd.NamespaceURI);
                            string service = cmd.GetAttribute("Service", cmd.NamespaceURI);
                            string site = cmd.GetAttribute("Site", cmd.NamespaceURI);
                            string serviceDesc = cmd.GetAttribute("ServiceDescription", cmd.NamespaceURI);
                            string siteDesc = cmd.GetAttribute("SiteDescription", cmd.NamespaceURI);
                            string authVer = cmd.GetAttribute("AuthDataVersion", cmd.NamespaceURI);
                            string masterKey = cmd.GetAttribute("MasterKey", cmd.NamespaceURI);
                            string queryDb = cmd.GetAttribute("QueryDb", cmd.NamespaceURI);
                            string noAssoc = cmd.GetAttribute("NoAssociation", cmd.NamespaceURI);
                            string backCompat = cmd.GetAttribute("BackCompat", cmd.NamespaceURI);
                            string noReload = cmd.GetAttribute("NoReload", cmd.NamespaceURI);

                            if (String.Compare(action, "ConfigPartner", true) == 0)
                            {
                                args.AppendFormat("-cp -service:{0}", service);
                                if (serviceDesc.Length > 0)
                                    args.AppendFormat(" -servicedesc:\"{0}\"", serviceDesc);
                                if (siteDesc.Length > 0)
                                    args.AppendFormat(" -sitedesc:\"{0}\"", siteDesc);
                                if (authVer.Length > 0)
                                    args.AppendFormat(" -authdata:{0}", authVer);
                                if (masterKey.Length > 0)
                                    args.AppendFormat(" -masterkey:\"{0}\"", Path.Combine(titleSourceDir, masterKey));
                                if ((String.Compare(noAssoc, Boolean.TrueString, true) == 0) || noAssoc == "1")
                                    args.Append(" -noassociation");
                            }
                            else if (String.Compare(action, "ConfigTitle", true) == 0)
                            {
                                args.AppendFormat("-ct -titleid:0x{0} -service:{1}", titleId, service);
                                if (queryDb.Length > 0)
                                    args.AppendFormat(" -querydb:{0}", queryDb);
                                if ((String.Compare(backCompat, Boolean.TrueString, true) == 0) || backCompat == "1")
                                    args.Append(" -backcompat");
                            }
                            else
                            {
                                output.AppendFormat("Invalid action for LiveLSP : {0}", action);
                                break;
                            }

                            if (site.Length > 0)
                                args.AppendFormat(" -site:{0}", site);
                            if ((String.Compare(noReload, Boolean.TrueString, true) == 0) || noReload == "1")
                                args.Append(" -noreload");

                            toolResult = RunLiveLSP(args.ToString(), output);
                        }
                        break;
                    case "PartnerConfig":
                        {
                            string configFile = Path.Combine(titleSourceDir, cmd.GetAttribute("ConfigFile", cmd.NamespaceURI));
                            args.AppendFormat("/update \"{0}\"", configFile);

                            toolResult = RunPartnerConfig(args.ToString(), output);
                        }
                        break;
                    case "VoucherMgr":
                        {
                            string key = cmd.GetAttribute("Key", cmd.NamespaceURI);
                            string keyFile = cmd.GetAttribute("File", cmd.NamespaceURI);
                            string offerId = cmd.GetAttribute("OfferId", cmd.NamespaceURI);
                            string emsOfferId = cmd.GetAttribute("EmsOfferId", cmd.NamespaceURI);
                            string mediaType = cmd.GetAttribute("MediaType", cmd.NamespaceURI);
                            args.AppendFormat("/import /usecount:{0} /consolever:{1} /scg:{2}",
                                cmd.GetAttribute("UseCount", cmd.NamespaceURI), 
                                cmd.GetAttribute("ConsoleVer", cmd.NamespaceURI), 
                                cmd.GetAttribute("SCG", cmd.NamespaceURI));
                            if (key.Length > 0)
                            {
                                args.AppendFormat(" /key:{0}", key);
                            }
                            else if (keyFile.Length > 0)
                            {
                                args.AppendFormat(" /file:\"{0}\"", Path.Combine(titleSourceDir, keyFile));
                            }

                            if (offerId.Length > 0)
                            {
                                args.AppendFormat(" /offerid:{0}", offerId);
                            }

                            // EmsOfferId and MediaType shold go together
                            if (emsOfferId.Length > 0)
                            {
                                args.AppendFormat(" /emsofferid:{0} /mediatype:{1}", emsOfferId, mediaType);
                            }

                            toolResult = RunVoucherMgr(args.ToString(), output);
                        }
                        break;
                    case "TokenImport":
                        args.AppendFormat("/import /file:{0} /offerid:{1}", Path.Combine(titleSourceDir, cmd.GetAttribute("File", cmd.NamespaceURI)),
                            cmd.GetAttribute("OfferId", cmd.NamespaceURI));
                        toolResult = RunTokenImport(args.ToString(), output);
                        break;
                    case "WstSQL":
                        {
                            string wstQuery = cmd.GetAttribute("Query", cmd.NamespaceURI);
                            string timeout = cmd.GetAttribute("Timeout", cmd.NamespaceURI);

                            args.AppendFormat("-d {0} -p {1}", cmd.GetAttribute("Deployment", cmd.NamespaceURI),
                                    cmd.GetAttribute("Partition", cmd.NamespaceURI));
                            if (wstQuery.Length > 0)
                            {
                                args.AppendFormat(" -q \"{0}\"", wstQuery);
                            }
                            else
                            {
                                args.AppendFormat(" -i {0}", Path.Combine(titleSourceDir, cmd.GetAttribute("InputFile", cmd.NamespaceURI)));
                            }
                            if (timeout.Length > 0)
                                args.AppendFormat(" -mto:{0}", timeout);

                            toolResult = RunWstSQL(args.ToString(), output);
                        }
                        break;
                    case "OSQL":
                            args.AppendFormat("-E -S {0} -d {1}", cmd.GetAttribute("Server", cmd.NamespaceURI),
                                    cmd.GetAttribute("Database", cmd.NamespaceURI));
                            string osqlQuery = cmd.GetAttribute("Query", cmd.NamespaceURI);
                            if (osqlQuery.Length > 0)
                            {
                                args.AppendFormat(" -Q \"{0}\"", osqlQuery);
                            }
                            else
                            {
                                args.AppendFormat(" -i {0}", Path.Combine(titleSourceDir, cmd.GetAttribute("InputFile", cmd.NamespaceURI)));
                            }

                            toolResult = RunOSQL(args.ToString(), output);
                        break;
                    case "StUtil":
                        {
                            string overwrite = cmd.GetAttribute("Overwrite", cmd.NamespaceURI);

                            args.AppendFormat("-a:write -f:{0} -p:{1}", Path.Combine(titleSourceDir, cmd.GetAttribute("File", cmd.NamespaceURI)),
                                cmd.GetAttribute("StoragePath", cmd.NamespaceURI));
                            if ((String.Compare(overwrite, Boolean.TrueString, true) == 0) || overwrite == "1")
                                args.Append(" -y");

                            toolResult = RunStUtil(args.ToString(), output);
                        }
                        break;
                    default:
                        toolResult = 0;
                        break;
                }

                // Keep track of any overall failures
                if (0 == result)
                    result = toolResult;
            }

            return result;
        }

        private int RunTool(string toolName, string executionPath, string args, StringBuilder output)
        {
            int ret = 0;
            if (_reportOnly)
            {
                output.AppendLine(executionPath + " " + args);
            }
            else
            {
                ProcessWrapper tool = new ProcessWrapper(toolName, executionPath);
                tool.ExecutionTimeout = _toolsTimeout;

                RaiseTppEvent(new TPPEventArgs(TPPEventType.Debug, String.Format("Running {0} {1}", executionPath, args)));
                output.AppendFormat("\r\nRunning {0} {1}\r\n", executionPath, args);
                try
                {
                    ret = tool.Run(args);
                    output.AppendFormat("{0}\r\nProcess Return Value : {1}\r\n", tool.Output, ret);
                }
                catch (Exception ex)
                {
                    output.AppendFormat("Exception occurred while running {0}:\r\n{1}\r\n\r\n", toolName, ex);
                    ret = -1;
                }
            }

            return ret;
        }

        private int RunLiveTitle(string args, StringBuilder output)
        {
            string exePath = Path.Combine(_toolsLocation, "LiveTitle.exe");
            int retries = 0;
            int ret = RunTool("LiveTitle", exePath, args, output);
            if (ret != 0)
            {
                while (retries < 5)
                {
                    if (ret != 0 && output.ToString().Contains("There was an issue getting access to TitleVault!"))
                    {
                        retries++;
                        Thread.Sleep(5000);
                        output.Length = 0;
                        output.AppendFormat("LiveTitle could not access the TitleVault. Attempt {0} of 5...\r\n", retries);
                        ret = RunTool("LiveTitle", exePath, args, output);
                    }
                    else
                    {
                        break;
                    }
                }
            }

            return ret;
        }

        private int RunLiveStats(string args, StringBuilder output)
        {
            return RunTool("LiveStats", Path.Combine(_toolsLocation, "LiveStats.exe"), args, output);
        }

        private int RunLiveMatch(string args, StringBuilder output)
        {
            return RunTool("LiveMatch", Path.Combine(_toolsLocation, "LiveMatch.exe"), args, output);
        }

        private int RunLiveContent(string args, StringBuilder output)
        {
            return RunTool("LiveContent", Path.Combine(_toolsLocation, "LiveContent.exe"), args, output);
        }

        private int RunLiveOffer(string args, StringBuilder output)
        {
            return RunTool("LiveOffer", Path.Combine(_toolsLocation, "LiveOffer.exe"), args, output);
        }

        private int RunLiveLSP(string args, StringBuilder output)
        {
            return RunTool("LiveLSP", Path.Combine(_toolsLocation, "LiveLSP.exe"), args, output);
        }

        private int RunPartnerConfig(string args, StringBuilder output)
        {
            return RunTool("PartnerConfig", Path.Combine(_toolsLocation, "PartnerConfig.exe"), args, output);
        }

        private int RunVoucherMgr(string args, StringBuilder output)
        {
            return RunTool("VoucherMgr", Path.Combine(_toolsLocation, "VoucherMgr.exe"), args, output);
        }

        private int RunTokenImport(string args, StringBuilder output)
        {
            return RunTool("TokenImport", Path.Combine(_toolsLocation, "TokenImport.exe"), args, output);
        }

        private int RunStUtil(string args, StringBuilder output)
        {
            return RunTool("StUtil", Path.Combine(_toolsLocation, "StUtil.exe"), args, output);
        }

        private int RunWstSQL(string args, StringBuilder output)
        {
            return RunTool("WstSQL", @"C:\Program Files\Microsoft Webstore\wstsql.exe", args, output);
        }

        private int RunOSQL(string args, StringBuilder output)
        {
            return RunTool("OSQL", @"OSQL.exe", args, output);
        }

        private int RunPropXQS(string args, StringBuilder output)
        {
            return RunTool("PropXQS", Path.Combine(_toolsLocation, "PropXQS.exe"), args, output);
        }

        private int RunSystemCheck(string args, StringBuilder output)
        {
            return RunTool("SystemCheck", Path.Combine(_toolsLocation, "SystemCheck.exe"), args, output);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\UserConfigCertConfigTests\GenevaDeploymentTests\Class1.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Xml;


namespace GenevaDeploymentTests
{
    /// <summary>
    ///     <TestSuite>Geneva Deployment Tests</TestSuite>
    ///     <Tester>josephfo</Tester>
    ///     <Developer>paulram</Developer>
    ///     <PM>rajivma</PM>
    /// </summary>
    /// 

    [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
    public class GenevaDeploymentTestSuite : TestNode
    {
        static Report reportObj = new Report(typeof(GenevaDeploymentTestSuite).Name);

        protected static Int32 StartProcess(String WorkingDir, String FileName, String Arguments)
        {
            Process MyProc = new Process();
            MyProc.StartInfo.WorkingDirectory = Environment.ExpandEnvironmentVariables(WorkingDir);
            MyProc.StartInfo.FileName = Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName;
            MyProc.StartInfo.UseShellExecute = false;
            MyProc.StartInfo.RedirectStandardError = true;
            MyProc.StartInfo.RedirectStandardInput = true;
            MyProc.StartInfo.RedirectStandardOutput = true;
            MyProc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;

            MyProc.StartInfo.Arguments = Arguments;

            MyProc.Start();
            String stdOut = MyProc.StandardOutput.ReadToEnd();
            String stdErr = MyProc.StandardError.ReadToEnd();
            MyProc.WaitForExit();
            Int32 exitCode = MyProc.ExitCode;
            MyProc.Close();
            reportObj.Info("Command line used:");
            reportObj.Info(Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName + " " + Arguments);
            reportObj.Info("stdOut: " + stdOut);
            reportObj.Info("stdErr: " + stdErr);
            return exitCode;
        }

        public override void PreRun()
        {
            reportObj.Info("Creating c:\\Deployment.xml");
            CreateDeploymentXml();

            reportObj.Info("Setting Octopus.Log.CurrentDeployment.ConfigurationFile=c:\\deployment.xml");
            Environment.SetEnvironmentVariable("Octopus.Log.CurrentDeployment.ConfigurationFile", "c:\\deployment.xml");
        }

        private void CreateDeploymentXml()
        {
            String text = "<DeploymentInstance deploymentShareLocation=\"\\\\josephfo5\\deptest\" logsLocation=\"\\\\josephfo5\\deptest\\logs\" topologyName=\"Test Topology\" releaseName=\"Summer 09\" engineVersion=\"4.4.2113.0000\" deploymentAccount=\"REDMOND\\josephfo\" controllerMachine=\"JOSEPHFO5\">" +
                "<Server name=\"ansxblob\">" +
                "<PublishedComponentName name=\"test_component\" />" +
                "</Server>" +
                "<ComponentConfiguration name=\"RealComp\">" +
                "<PropertyValue name=\"RealProp\" source=\"Custom\" value=\"\" />" +
                "</ComponentConfiguration>" +
                "</DeploymentInstance>";
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(text);
            xml.Save("c:\\deployment.xml");
        }

        static void SetDeploymentXmlPasswordValue(String PasswordValue)
        {
            XmlDocument xml = new XmlDocument();
            xml.Load("c:\\deployment.xml");
            xml.SelectSingleNode("/DeploymentInstance/ComponentConfiguration/PropertyValue").Attributes["value"].Value = PasswordValue;
            xml.Save("c:\\deployment.xml");
        }


        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class UserConfigTests : TestNode
        {
            static Report reportObj = new Report(typeof(UserConfigTests).Name);
            static string USERSNAME = "testUser555";
            static string PASSWORD = "#Bugsfor$$";
            static string USERROLE = "someRole";

            static bool bLocalAccountCreated = false;
            static bool bDomainAccountCreated = false;

            public override void PreRun()
            {
                reportObj.Info("Inside PreRun");
                CreateLocalAccount();
                CreateDomainAccount();
                reportObj.Info("Leaving PreRun");
                base.PreRun();
            }



            private void CreateLocalAccount()
            {
                reportObj.Info("Attempting to create a local user.");
                String args = @" user " + UserConfigTests.USERSNAME + " " + UserConfigTests.PASSWORD + " /ADD /ACTIVE:YES /EXPIRES:NEVER /PASSWORDCHG:NO /PASSWORDREQ:YES";
                Int32 returnCode = StartProcess(@"%windir%\SYSTEM32", "net.exe", args);
                reportObj.Info("Create local user process returns: " + returnCode.ToString());
                if (returnCode == 0)
                    UserConfigTests.bLocalAccountCreated = true;
            }

            private void CreateDomainAccount()
            {
                // if we are on the redmond domain, don't even try to create the account.
                if (Environment.ExpandEnvironmentVariables("%USERDOMAIN%").Equals("REDMOND"))
                {
                    reportObj.Info("Unable to create domain account on the Redmond domain. Some tests will be Not Run");
                    return;
                }

                reportObj.Info("Attempting to create a domain user.");
                String args = @" user testUser555 #Bugsfor$$ /ADD /DOMAIN /ACTIVE:YES /EXPIRES:NEVER /PASSWORDCHG:NO /PASSWORDREQ:YES";
                Int32 returnCode = StartProcess(@"%windir%\SYSTEM32", "net.exe", args);
                reportObj.Info("Create domain user process returns: " + returnCode.ToString());
                if (returnCode == 0)
                    UserConfigTests.bDomainAccountCreated = true;
            }

            public override void PostRun()
            {
                // delete the user that was created in PreRun().
                reportObj.Info("Inside PostRun");
                DeleteLocalAccount();
                DeleteDomainAccount();
                reportObj.Info("Leaving PostRun");
                base.PostRun();
            }


            private void DeleteLocalAccount()
            {
                // Delete local user.
                reportObj.Info("Attempting to delete the Local user.");
                String args = @" user testUser555 /DELETE ";
                Int32 returnCode = StartProcess(@"%windir%\SYSTEM32", "net.exe", args);
                reportObj.Info("Delete Local account process returns: " + returnCode.ToString());

                // don't really care about the return code.  If there was a failure, it will show up
                // during the StartProcess output
            }

            private void DeleteDomainAccount()
            {
                // Delete domain user.
                reportObj.Info("Attempting to delete the Domain user.");
                String args = @" user testUser555 /DELETE /DOMAIN";
                Int32 returnCode = StartProcess(@"%windir%\SYSTEM32", "net.exe", args);
                reportObj.Info("Delete Domain account process returns: " + returnCode.ToString());

                // don't really care about the return code.  If there was a failure, it will show up
                // during the StartProcess output

            }




            [TestCase, Description("Validates UserConfig.exe can verify passwords for local computer accounts.")]
            public class t1a_VerifyPasswordOnLocalComputerAccount : TestNode
            {
                public override void Run()
                {
                    if (!UserConfigTests.bLocalAccountCreated)
                    {
                        reportObj.Error("Local user account was not created.  This test is blocked.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate user.");
                    String args =  "/Site=\\\\josephfo\\share\\site.xml Role " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe",args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());
                    if (returnCode != 0)
                    {
                        reportObj.Error("UserConfig.exe process returns non-zero value indicating failure - but success is expected.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Info("UserConfig.exe process correctly handles valid username/password on local account.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Validates UserConfig.exe returns false for valid username incorrect password")]
            public class t1b_VerifyInvalidPasswordReturnsFalseForBadPasswordLocalAccount : TestNode
            {
                public override void Run()
                {
                    if (!UserConfigTests.bLocalAccountCreated)
                    {
                        reportObj.Error("Local user account was not created.  This test is blocked.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate user with incorrect password.");
                    String args = "/Site=\\\\josephfo\\share\\site.xml Role " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD + "BadPW";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("Validate User process returns " + returnCode.ToString());
                    if (returnCode != 2)
                    {
                        reportObj.Error("UserConfig.exe does not return expected value '2'.  Local user with incorrect password fails.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Info("Validate user process correctly handles incorrect password for local accounts.");
                    return TEST_RESULTS.PASSED;
                    
                }
            }

            [TestCase, Description("Validates UserConfig.exe returns false for invalid username")]
            public class t1c_VerifyInvalidPasswordReturnsFalseForInvalidLocalAccount : TestNode
            {
                public override void Run()
                {
                    if (!UserConfigTests.bLocalAccountCreated)
                    {
                        reportObj.Error("Local user account was not created.  This test is blocked.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate local user with incorrect password.");
                    String args = "/Site=\\\\josephfo\\share\\site.xml Role " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " InvalidUsername " + PASSWORD ;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);

                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());
                    if (returnCode != 2)
                    {
                        reportObj.Error("UserConfig.exe expected to return '2' but did not. Invalid username test fails.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Info("UserConfig.exe process correctly handles incorrect username for local accounts.");
                    return TEST_RESULTS.PASSED;                    
                }
            }


            [TestCase, Description("Validates UserConfig.exe can verify valid passwords for domain accounts.")]
            public class t2a_VerifyPasswordOnDomainAccount : TestNode
            {
                public override void Run()
                {
                    if (!UserConfigTests.bDomainAccountCreated)
                    {
                        reportObj.Error("Domain account has not been created.  This test case is blocked.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    //Validating DOMAIN user and password.
                    reportObj.Info("Attempting to validate domain user with correct password.");
                    String args = "/Site=\\\\josephfo\\share\\site.xml Role " + Environment.ExpandEnvironmentVariables("%USERDOMAIN%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe returns: " + returnCode.ToString());
                    if (returnCode != 0)
                    {
                        reportObj.Error("UserConfig.exe did not return expected value of '0' when verifying valid domain account.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Info("UserConfig.exe correctly validates domain user.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("Validates UserConfig.exe fails if domain password is incorrect.")]
            public class t2b_VerifyInvalidPasswordOnDomainAccountReturnsFalse : TestNode
            {
                public override void Run()
                {
                    if (!UserConfigTests.bDomainAccountCreated)
                    {
                        reportObj.Error("Domain account has not been created.  This test case is blocked.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    //Validating DOMAIN user with invalid password
                    reportObj.Info("Attempting to validate domain user with incorrect password.");
                    String args = "/Site=\\\\josephfo\\share\\site.xml Role " + Environment.ExpandEnvironmentVariables("%USERDOMAIN%") + " " + USERSNAME + " " + PASSWORD + "BadPw";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe returns: " + returnCode.ToString());
                    if (returnCode != 2)
                    {
                        reportObj.Info("UserConfig.exe does not return expected value '2' when validating domain user with invalid password.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Error("UserConfig.exe correctly handles domain account with invalid password.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Validates UserConfig.exe fails if domain username is invalid.")]
            public class t2c_VerifyInvalidPasswordReturnsFalseInvalidPasswordDomainAccount : TestNode
            {
                public override void Run()
                {
                    if (!UserConfigTests.bDomainAccountCreated)
                    {
                        reportObj.Error("Domain account has not been created.  This test case is blocked.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    //Validating DOMAIN user and password.
                    reportObj.Info("Attempting to validate domain user with invalid USERNAME.");
                    String args = "/Site=\\\\josephfo\\share\\site.xml Role " + Environment.ExpandEnvironmentVariables("%USERDOMAIN%") + " BadUserName " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe returns: " + returnCode.ToString());
                    if (returnCode != 2)
                    {
                        reportObj.Info("UserConfig.exe does not return expected value '2' when attempting to validate a domain account with invalid username.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Error("UserConfig.exe correctly handles domain account with invalid username.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase, Description("Validates UserConfig.exe Creates Site.xml if it does not already exist.")]
            public class t3_VerifyUserConfigCreatesSiteXml : TestNode
            {
                public override void Run()
                {
                    const string SITEXML_FILE = @"\\josephfo\share\site.xml";

                    // delete the file if it already exists.
                    if (File.Exists(SITEXML_FILE))
                    {
                        File.Delete(SITEXML_FILE);
                    }


                    //Validating local user and password.  This should create the file just deleted.
                    reportObj.Info("Attempting to validate local user - which should create site.xml.");
                    String args = "/Site=" + SITEXML_FILE + " Role " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("UserConfig.exe fails when expected to pass.  Unable to verify file was created.");
                        return TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        reportObj.Info("Validate local user passes.  Site.xml should now exist.");
                    }


                    if (!File.Exists(SITEXML_FILE))
                    {
                        reportObj.Error("File " + SITEXML_FILE + " does not exist, but should.  Verify UserConfig Creates Site.xml test fails.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info(SITEXML_FILE + " found.  Test passes.");
                    return TEST_RESULTS.PASSED;
                }
            }

            /* This test case is not working - and it implicitly passes since the other test cases pass in this suite.
            [TestCase, Description("Validates UserConfig.exe Creates Site.xml if it does not already exist.")]
            public class t4_VerifyUserConfigUsesCommandLineSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create some random xml file.
                    // 2. Pass this file to UserConfig.xml
                    // 3. Verify last file access time is > file creation time.
                    SiteXml sitexml = new SiteXml();
  
                    // force the cleanup of fi to release the handle on the file.
                    //GC.Collect();
                    

                    DateTime firstAccessTime = File.GetLastAccessTime(sitexml.SiteXmlPathFilename);
                    reportObj.Info("first access time: " + firstAccessTime.ToString());
                    System.Threading.Thread.Sleep(1000);
                    //Validating local user and password.  This should create the file just deleted.
                    reportObj.Info("Attempting to validate local user - which should access " + sitexml.SiteXmlPathFilename);
                    String args = "/Site=" + sitexml.SiteXmlPathFilename + " /Component=Hello /Property=Hello Role " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("UserConfig.exe fails when expected to pass.  Unable to verify file " + sitexml.SiteXmlPathFilename + " was used.");
                        return TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        reportObj.Info("Validate local user passes.  Site.xml should now exist.");
                    }


                    // THIS TEST IS BROKEN.  LAST ACCESS TIME IS NOT BEING UPDATED, BUT I'M SURE THE FILE
                    // IS BEING USED CORRECTLY.  THIS CASE IMPLICITLY PASSES ANYWAY IF ALL THE OTHER CASES PASS.
                    DateTime lastAccessTime = File.GetLastAccessTime(sitexml.SiteXmlPathFilename);
                    reportObj.Info("last access time: " + lastAccessTime.ToString());
                    if (lastAccessTime.Ticks > firstAccessTime.Ticks)
                    {
                        reportObj.Info("UserConfig.exe does use command line Site.Xml");
                        return TEST_RESULTS.PASSED;
                    }

                    reportObj.Error("UserConfig.exe did not access the command line Site.xml. Test fails.");
                    return TEST_RESULTS.FAILED;
                }
            }
            */

            [TestCase, Description("Validates UserConfig.exe fails if no command line or site.xml password is provided.")]
            public class t5_VerifyUserConfigFailsIfNoPassword : TestNode
            {
                public override void Run()
                {
                    // 1. Create a site.xml with no passwords
                    // 2. Call UserConfig.exe with no command line password, using the Site.xml just created.
                    // 3. Verify UserConfig.exe returns non-zero.
                                        
                    SiteXml siteXml = new SiteXml();  //no-param constructor creates a new site.xml with no username/passwords

                    reportObj.Info("Attempting to validate local user with no password in command line or site.xml");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + "  Role " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " \"\"";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());
                    // OK - allow UserConfig.exe to return 'Invalid username or password' when no password.
                    if (returnCode != 2)
                    {
                        reportObj.Error("UserConfig.exe not returning expected -1 value when no password in command line or site.xml");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Info("UserConfig.exe correctly fails when no command line password or Site.xml password was provided");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Validates UserConfig.exe users Site.Xml password if no command line password is passed.")]
            public class t6aa_VerifySiteXmlPasswordIsUsed : TestNode
            {
                public override void Run()
                {
                    // 1. Create a site.xml
                    // 2. Add the UserName/password of some account to the site.xml
                    // 3. Call UserConfig.exe with no password, with this account role
                    // 4. Verify UserConfig.exe passes by using the password from site.xml.
                    
                    SiteXml siteXml = new SiteXml();
                    Credentials cred = new Credentials(USERSNAME, PASSWORD, USERROLE);
                    siteXml.AddCredsToSiteXml(cred);  // this method automatically saves changes to file.

                    reportObj.Info("Attempting to validate local user with no password in command line.  UserConfig.exe should retrieve pw from site.xml.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " \"\"";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("UserConfig.exe fails to use Site.Xml password when no command line password is provided.");
                        return TEST_RESULTS.FAILED;
                    }
                   
                    // Check that password in Site.Xml is unchanged.  Need to reload Site.xml in case UserConfig.exe changed it.
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    Credentials newCred = newSiteXml.CredentialDictionary[USERROLE];
                    if (newCred.Password != PASSWORD)
                    { 
                        // password has changed in Site.Xml, which is no good.
                        reportObj.Error("UserConfig.exe changed the password in Site.xml when it should not have.  Test fails.");
                        return TEST_RESULTS.FAILED;
                    }
                    


                    reportObj.Info("UserConfig.exe uses Site.Xml password and passes when no command line parameter is passed.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Validates UserConfig.exe fails when using password provided by Site.Xml")]
            public class t6ab_VerifyFailWhenBadSiteXmlPassword : TestNode
            {
                public override void Run()
                {
                    // 1. Create a site.xml
                    // 2. Add the UserName and bad password of existing account.
                    // 3. Call UserConfig.exe with no password with the account role.
                    // 4. Verify UserConfig.exe fails because it uses the bad password from site.xml.

                    SiteXml siteXml = new SiteXml();
                    Credentials cred = new Credentials(USERSNAME, PASSWORD + "BLA", USERROLE);  // intentional bad password
                    siteXml.AddCredsToSiteXml(cred);

                    reportObj.Info("Attempting to validate local user with no password in command line and bad password in Site.xml.  UserConfig.exe should retrieve pw from site.xml.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " \"\"";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 2)
                    {
                        reportObj.Error("UserConfig.exe does not return expected '2' value.");
                        return TEST_RESULTS.FAILED;
                    }


                    reportObj.Info("UserConfig.exe correctly fails with '2' when using a bad password from Site.Xml");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t7aa - Verify password is added to site.xml if command line password is provided.")]
            public class t7aa_VerifyNewPasswordIsAddedToSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create a new site.xml, but do not add the user.
                    // 2. Validate local user.
                    // 3. Go back to site.xml to see fi the correct username, userrole, password were added in the correct domain.
                    
                    SiteXml siteXml = new SiteXml();  // new site.xml with no existing users.

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate user.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    // user should now exist in that same site.xml
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    Credentials newCreds = newSiteXml.CredentialDictionary[USERROLE];
                    if (newCreds == null)
                    {
                        reportObj.Error("Unable to find account node for new user in siteXml file: " + newSiteXml.SiteXmlPathFilename);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Role != USERROLE)
                    {
                        reportObj.Error("Users role does not match expected value:");
                        reportObj.Error("Expected value: " + USERROLE);
                        reportObj.Error("Actual value: " + newCreds.Role);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.UserName != USERSNAME)
                    {
                        reportObj.Error("Users name does not match expected value:");
                        reportObj.Error("Expected value: " + USERSNAME);
                        reportObj.Error("Actual value: " + newCreds.UserName);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Password != PASSWORD)
                    {
                        reportObj.Error("Users PASSWORD does not match expected value:");
                        reportObj.Error("Expected value: " + PASSWORD);
                        reportObj.Error("Actual value: " + newCreds.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    // all checks pass.  return pass.
                    reportObj.Info("New user found in SiteXml file. Validated username, password and role.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t7ab - Verify password is added to site.xml if command line password is provided.")]
            public class t7ab_VerifyInvalidPasswordIsNotAddedToSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create a new site.xml, but do not add the user.
                    // 2. Validate local user.
                    // 3. Go back to site.xml to see fi the correct username, userrole, password were added in the correct domain.

                    SiteXml siteXml = new SiteXml();  // new site.xml with no existing users.

                    //Validating local user with bad password.
                    reportObj.Info("Attempting to validate user.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " /Component=Hello /Property=Hello " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD + "BadPW";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    // user should NOT exist in that same site.xml because of bad password
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    if (newSiteXml.CredentialDictionary.Count != 0)
                    {
                        reportObj.Error("siteXml file " + newSiteXml.SiteXmlPathFilename + " contains the user that failed validation with bad password.");
                        return TEST_RESULTS.FAILED;                        
                    }

                    reportObj.Info("SiteXml file does not contain account from invalid password validation.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t8aa - Verify password is added to site.xml if command line password is provided.")]
            public class t8aa_VerifyPasswordCheckWorksForExistingSiteXmlUserSamePassword : TestNode
            {
                public override void Run()
                {
                    // 1. Create a new site.xml, and add the user with valid username/password
                    // 2. Validate local user.
                    // 3. Go back to site.xml to see fi the correct username, userrole, password were added in the correct domain.

                    SiteXml siteXml = new SiteXml();  // new site.xml with no existing users.

                    Credentials cred = new Credentials(USERSNAME, PASSWORD, USERROLE);
                    siteXml.AddCredsToSiteXml(cred);

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate user.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " /Component=Hello /Property=Hello " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    // user should still exist in that same site.xml, and password should stay the same.
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    Credentials newCreds = newSiteXml.CredentialDictionary[USERROLE];
                    if (newCreds == null)
                    {
                        reportObj.Error("Unable to find account node for new user in siteXml file: " + newSiteXml.SiteXmlPathFilename);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Role != USERROLE)
                    {
                        reportObj.Error("Users role does not match expected value:");
                        reportObj.Error("Expected value: " + USERROLE);
                        reportObj.Error("Actual value: " + newCreds.Role);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.UserName != USERSNAME)
                    {
                        reportObj.Error("Users name does not match expected value:");
                        reportObj.Error("Expected value: " + USERSNAME);
                        reportObj.Error("Actual value: " + newCreds.UserName);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Password != PASSWORD)
                    {
                        reportObj.Error("Users PASSWORD does not match expected value:");
                        reportObj.Error("Expected value: " + PASSWORD);
                        reportObj.Error("Actual value: " + newCreds.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    // all checks pass.  return pass.
                    reportObj.Info("Existing user found in SiteXml file. Validated username, password and role are expected values.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase, Description("t9aa - Verify password is added to site.xml if command line password is provided.")]
            public class t9aa_VerifyPasswordCheckWorksForExistingSiteXmlUserDifferentPassword : TestNode
            {
                public override void Run()
                {
                    // 1. Create a new site.xml, and add the username with invalid password
                    // 2. Validate local user with correct password
                    // 3. Go back to site.xml to see if the correct username, userrole, password were added in the correct domain.

                    SiteXml siteXml = new SiteXml();  // new site.xml with no existing users.

                    Credentials cred = new Credentials(USERSNAME, PASSWORD + "BadPwd", USERROLE);
                    siteXml.AddCredsToSiteXml(cred);

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate user.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    // user should still exist in that same site.xml, and password should be updated to correct password.
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    Credentials newCreds = newSiteXml.CredentialDictionary[USERROLE];
                    if (newCreds == null)
                    {
                        reportObj.Error("Unable to find account node for new user in siteXml file: " + newSiteXml.SiteXmlPathFilename);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Role != USERROLE)
                    {
                        reportObj.Error("Users role does not match expected value:");
                        reportObj.Error("Expected value: " + USERROLE);
                        reportObj.Error("Actual value: " + newCreds.Role);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.UserName != USERSNAME)
                    {
                        reportObj.Error("Users name does not match expected value:");
                        reportObj.Error("Expected value: " + USERSNAME);
                        reportObj.Error("Actual value: " + newCreds.UserName);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Password != PASSWORD)  // check for correct password.
                    {
                        reportObj.Error("Users PASSWORD does not match expected value:");
                        reportObj.Error("Expected value: " + PASSWORD);
                        reportObj.Error("Actual value: " + newCreds.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    // all checks pass.  return pass.
                    reportObj.Info("Existing user found in SiteXml file. Validated username, password and role are expected values.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t9ab - Verify password is NOT added to site.xml if command line password is invalid with existing account in Site.xml")]
            public class t9ab_VerifyPasswordCheckWorksForExistingSiteXmlUserDifferentPassword : TestNode
            {
                public override void Run()
                {
                    // 1. Create a new site.xml, and add the username with invalid password
                    // 2. Validate local user with different invalid password
                    // 3. Go back to site.xml and verify the new invalid password did not replace old password.

                    SiteXml siteXml = new SiteXml();  // new site.xml with no existing users.

                    Credentials cred = new Credentials(USERSNAME, PASSWORD + "BadPwd1", USERROLE);
                    siteXml.AddCredsToSiteXml(cred);

                    //Validating local user and password.
                    reportObj.Info("Attempting to validate user.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " /Component=Hello /Property=Hello " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD + "BadPwd2";
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString()); // expected failure.

                    // user should still exist in that same site.xml, and password should NOT be updated to incorrect password.
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    Credentials newCreds = newSiteXml.CredentialDictionary[USERROLE];
                    if (newCreds == null)
                    {
                        reportObj.Error("Unable to find account node for new user in siteXml file: " + newSiteXml.SiteXmlPathFilename);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Role != USERROLE)
                    {
                        reportObj.Error("Users role does not match expected value:");
                        reportObj.Error("Expected value: " + USERROLE);
                        reportObj.Error("Actual value: " + newCreds.Role);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.UserName != USERSNAME)
                    {
                        reportObj.Error("Users name does not match expected value:");
                        reportObj.Error("Expected value: " + USERSNAME);
                        reportObj.Error("Actual value: " + newCreds.UserName);
                        return TEST_RESULTS.FAILED;
                    }

                    if (newCreds.Password != PASSWORD + "BadPwd1")  // check that password was not changed to bad password.
                    {
                        reportObj.Error("Users PASSWORD does not match expected value:");
                        reportObj.Error("Expected value: " + PASSWORD);
                        reportObj.Error("Actual value: " + newCreds.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    // all checks pass.  return pass.
                    reportObj.Info("Existing user found in SiteXml file. Validated username, password and role are expected values.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("Verify UserConfig.exe does not wipe out other xml in site.xml.")]
            public class t10_VerifyUserConfigDoesNotWipeOutNonUserNonCertElement : TestNode
            {
                public override void Run()
                {
                    // 1. Create a site.xml
                    // 2. Add the UserName/password of some account to the site.xml
                    // 3. Call UserConfig.exe with no password, with this account role
                    // 4. Verify UserConfig.exe passes by using the password from site.xml.

                    SiteXml siteXml = new SiteXml();
                    Credentials cred = new Credentials(USERSNAME, String.Empty, USERROLE);
                    siteXml.AddCredsToSiteXml(cred);  // this method automatically saves changes to file.
                    siteXml.AddNonCertNonUserNodes();

                    reportObj.Info("Attempting to validate local user with no password in command line.  UserConfig.exe should retrieve pw from site.xml.");
                    String args = "/Site=" + siteXml.SiteXmlPathFilename + " " + USERROLE + " " + Environment.ExpandEnvironmentVariables("%COMPUTERNAME%") + " " + USERSNAME + " " + PASSWORD;
                    Int32 returnCode = StartProcess(@"C:", "UserConfig.exe", args);
                    reportObj.Info("UserConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("UserConfig.exe fails to use Site.Xml password when no command line password is provided.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (siteXml.NonCertNonUserNodesExist())
                    {
                        reportObj.Info("NonUser/NonCert element still exists after UserConfig.exe call.");
                    }
                    else
                    {
                        reportObj.Error("NonUser/NonCert element is wiped out during UserConfig.exe call.");
                        return TEST_RESULTS.FAILED;
                    }

                    // Check that password in Site.Xml is unchanged.  Need to reload Site.xml in case UserConfig.exe changed it.
                    SiteXml newSiteXml = new SiteXml(siteXml.SiteXmlPathFilename);
                    Credentials newCred = newSiteXml.CredentialDictionary[USERROLE];
                    if (newCred.Password != PASSWORD)
                    {
                        // password has changed in Site.Xml, which is no good.
                        reportObj.Error("UserConfig.exe changed the password in Site.xml when it should not have.  Test fails.");
                        return TEST_RESULTS.FAILED;
                    }



                    reportObj.Info("UserConfig.exe uses Site.Xml password and passes when no command line parameter is passed.");
                    return TEST_RESULTS.PASSED;
                }
            }




        }

        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class CertConfigTests : TestNode
        {

            public override void PreRun()
            {
                reportObj.Info("Inside PreRun");
                reportObj.Info("Setting octopus configuration file environment variable.");
                Environment.SetEnvironmentVariable("Octopus.Log.CurrentDeployment.ConfigurationFile", "c:\\deployment.xml");
                reportObj.Info("Leaving PreRun");
            }


            [TestCase, Description("Verify CertConfig.exe creates a site.xml if it does not already exist.")]
            public class t1 : TestNode
            {
                static Report reportObj = new Report(typeof(CertConfigTests).Name);

                public override void Run()
                {
                    // 1. Delete site.xml file
                    // 2. Run CertConfig.exe using site.xml we just deleted.
                    // 3. Verify the site.xml was created.

                    if (File.Exists("\\\\josephfo\\share\\site.xml"))
                        File.Delete("\\\\josephfo\\share\\site.xml");

                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate cert.");
                    // once bug 20849 is fixed, need to change the pfx password to the correct password.
                    String args = "/Site=\\\\josephfo\\share\\site.xml /Component=RealComp /Property=RealProp ssl.websg /FullCheck /PFX \\\\josephfo\\share\\test.pfx pfxPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected success

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe fails.  Unable to check that file was created.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (!File.Exists("\\\\josephfo\\share\\site.xml"))
                    {
                        reportObj.Error("CertConfig.exe did not create a new site.xml.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly created site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Verify CertConfig.exe creates a site.xml if it does not already exist.")]
            public class t2 : TestNode
            {
                public override void Run()
                {
                    // 1. Call CertConfig.exe with no parameters.

                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate cert.");
                    String args = " ";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected failure

                    if (returnCode != -1)
                    {
                        reportObj.Error("CertConfig.exe not failing correctly when no site.xml passed to command line.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe fails correctly when no site.xml is passed.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t4 - Verify CertConfig.exe returns success when validating pfx cert with valid username and valid password.")]
            public class t4_ValidCertValidPasswordPassesValidation : TestNode
            {
                public override void Run()
                {
                    // 1. Call CertConfig.exe with valid cert and correct password.
                    // 2. Verify it returns 0 - pass                    

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate cert.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml /Component=RealComp /Property=RealProp ssl.websg /PFX \\\\josephfo\\share\\test.pfx pfxPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe returns failure for valid cert and valid password.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly returns 0 for valid cert and valid password.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t5 - Verify CertConfig.exe validates that a p7b file exists.")]
            public class t5_ValidateP7BFileExists : TestNode
            {
                public override void Run()
                {
                    // 1. Verify p7b file exists.
                    // 2. Call CertConfig.exe on this p7b file.

                    if (!File.Exists("\\\\josephfo\\share\\Cert.p7b"))
                    {
                        reportObj.Error("\\\\josephfo\\share\\Cert.p7b file does not exist.  Create it before this test can pass.");
                        return TEST_RESULTS.FAILED;
                    }

                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate p7b cert.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml ssl.websg /P7B \\\\josephfo\\share\\Cert.p7b";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not correctly validate cert.p7b file exists.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly validates p7b file exists.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t6 - Verify CertConfig.exe fails if ctl file does not exists.")]
            public class t6_ValidateCTLFileExists : TestNode
            {
                public override void Run()
                {
                    // 1. Verify ctl file does exists.
                    // 2. Call CertConfig.exe on this ctl file.

                    if (!File.Exists("\\\\josephfo\\share\\cert.ctl"))
                    {
                        reportObj.Error("\\\\josephfo\\share\\cert.ctl file does not exist.  Create it before this test can pass.");
                        return TEST_RESULTS.FAILED;
                    }

                    //Simple validation on a ctl file
                    reportObj.Info("Attempting to validate ctl file exists.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml ssl.websg /CTL \\\\josephfo\\share\\cert.ctl";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe unable to validate CTL file.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly validates CTL file exists.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t7 - Verify CertConfig.exe fails with valid pfx cert and invalid password")]
            public class t7_ValidCertInvalidPasswordFailsValidation : TestNode
            {
                public override void Run()
                {
                    // 1. Call CertConfig.exe with a valid cert and incorrect password.
                    // 2. Verify it returns 2 - fail                    

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate cert using bad pw.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml /Component=RealComp /Property=RealProp ssl.websg /PFX \\\\josephfo\\share\\cert.pfx BadPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected failure

                    if (returnCode != 2)
                    {
                        reportObj.Error("CertConfig.exe does not return expecte value of 2 when invalid password.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly returns 2 for invalid password.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t8 - Verify CertConfig.exe fails if PFX file does not exists.")]
            public class t8_ValidateFailIfPFXFileNotExist : TestNode
            {
                public override void Run()
                {
                    // 1. Verify PFX file does not exists.
                    // 2. Call CertConfig.exe on this missing PFX file.

                    if (!File.Exists("\\\\josephfo\\share\\nofile.pfx"))
                    {
                        File.Delete("\\\\josephfo\\share\\nofile.pfx");
                    }

                    //Simple Cert validation on a ctl file
                    reportObj.Info("Attempting to validate non existent pfx cert.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml ssl.websg /Component:bla /Property:bla /PFX \\\\josephfo\\share\\nofile.pfx BadPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 1)
                    {
                        reportObj.Error("CertConfig.exe does not return expected value of 1 when PFX file does not exist.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails when PFX file does not exist.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase, Description("t9 - Verify CertConfig.exe fails if p7b file does not exists.")]
            public class t9_ValidateFailIfP7BFileNotExist : TestNode
            {
                public override void Run()
                {
                    // 1. Verify p7b file does not exists.
                    // 2. Call CertConfig.exe on this p7b file.

                    if (!File.Exists("\\\\josephfo\\share\\nofile.p7b"))
                    {
                        File.Delete("\\\\josephfo\\share\\nofile.p7b");
                    }

                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate non existent p7b cert.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml ssl.websg /P7B \\\\josephfo\\share\\nofile.p7b";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 1)
                    {
                        reportObj.Error("CertConfig.exe does not return expected value of 1 when p7b file does not exist.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails when p7b file does not exist.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase, Description("t10 - Verify CertConfig.exe fails if CTL file does not exists.")]
            public class t10_ValidateFailIfCTLFileNotExist : TestNode
            {
                public override void Run()
                {
                    // 1. Verify CTL file does not exists.
                    // 2. Call CertConfig.exe on this missing CTL file.

                    if (!File.Exists("\\\\josephfo\\share\\nofile.ctl"))
                    {
                        File.Delete("\\\\josephfo\\share\\nofile.ctl");
                    }

                    //Simple Cert validation on a ctl file
                    reportObj.Info("Attempting to validate non existent ctl cert.");
                    String args = " /Site=\\\\josephfo\\share\\site.xml ssl.websg /CTL \\\\josephfo\\share\\nofile.ctl";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 1)
                    {
                        reportObj.Error("CertConfig.exe does not return expected value of 1 when CTL file does not exist.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails when CTL file does not exist.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t11a - P7B Cert file exist and Add it to Site.xml")]
            public class t11a_P7BCertFileExistsAddSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Call certConfig.exe on a valid P7B cert.
                    // 3. Verify CertConfig.exe passes
                    // 4. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();


                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate p7b cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /P7B \\\\josephfo\\share\\cert.p7b";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.p7b file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for P7B cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != "\\\\josephfo\\share\\cert.p7b")
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to P7B file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)
                    {
                        reportObj.Error("Certificate path was set to a value, but none was expected for p7b file.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly adds P7B certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t11b - P7B Cert file exist and Update Site.xml works")]
            public class t11b_P7BCertFileExistsUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a P7B cert to the site.xml with invalid path
                    // 3. Call certConfig.exe on this valid P7B cert.
                    // 4. Verify CertConfig.exe passes
                    // 5. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", String.Empty, "\\\\josephfo\\UpdateMePath\\cert.p7b", String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate p7b cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /P7B \\\\josephfo\\share\\cert.p7b";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.p7b file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for P7B cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml but contained a non-empty 'path' field.");
                        return TEST_RESULTS.FAILED;
                    }

                    
                    if (cert.P7BFile != "\\\\josephfo\\share\\cert.p7b")
                    {
                        reportObj.Error("Certificate added to site.xml but contained an invalid path to p7b cert.");
                        return TEST_RESULTS.FAILED;
                    }
                    reportObj.Info("CertConfig.exe correctly updates P7B certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t11c - P7B Cert file exist and No Update Site.xml")]
            public class t11c_P7BCertFileExistsNoUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a P7B cert to the site.xml with valid path
                    // 3. Call certConfig.exe on this valid P7B cert.
                    // 4. Verify CertConfig.exe passes
                    // 5. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg",String.Empty, "\\\\josephfo\\share\\cert.p7b", String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate p7b cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /P7B \\\\josephfo\\share\\cert.p7b";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.p7b file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for P7B cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)  
                    {
                        reportObj.Error("Path node in site.xml is not empty as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    
                    if (cert.P7BFile != "\\\\josephfo\\share\\cert.p7b")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to P7B file.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly does not update P7B certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t11d - P7B Cert file does not exist and No Update Site.xml")]
            public class t11d_P7BCertFileDoesNotExistNoUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a cert to this site.xml
                    // 2. Call certConfig.exe and intentionally point to a wrong path
                    // 3. Verify CertConfig.exe fails
                    // 4. Verify site.xml was not updated with bad path

                    // delete the cert incase it somehow exists.
                    if (File.Exists("\\\\josephfo\\share\\BADPath.p7b"))
                        File.Delete("\\\\josephfo\\share\\BADPath.p7b");

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", String.Empty, "\\\\josephfo\\share\\cert.p7b", String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a p7b file
                    reportObj.Info("Attempting to validate p7b cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /P7B \\\\josephfo\\share\\BADPath.p7b";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail due to bad path

                    if (returnCode != 1)
                    {
                        reportObj.Error("CertConfig.exe does not fail as expected when p7b file does not exist.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not find certificate node to site.xml.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for P7B cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)  // verify site.xml was NOT updated with incorrect path
                    {
                        reportObj.Error("Certificate in site.xml was updated with a bad path.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != "\\\\josephfo\\share\\cert.p7b")  // verify site.xml was NOT updated with incorrect path
                    {
                        reportObj.Error("P7BFile value in site.xml is not the expected value of: \\\\josephfo\\share\\cert.p7b");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly does not update P7B certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }




            [TestCase, Description("t12a - CTL Cert file exist and Add it to Site.xml")]
            public class t12a_CTLCertFileExistsAddSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Call certConfig.exe on a valid CTL cert.
                    // 3. Verify CertConfig.exe passes
                    // 4. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();


                    //Simple Cert validation on a CTL file
                    reportObj.Info("Attempting to validate CTL cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /CTL \\\\josephfo\\share\\cert.ctl";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.CTL file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for CTL cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain empty 'Path' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != "\\\\josephfo\\share\\cert.ctl")
                    {
                        reportObj.Error("Certificate added to site.xml did not contain correct CTLFile attribute.");
                        reportObj.Error("Expected: \\\\josephfo\\share\\cert.ctl");
                        reportObj.Error("Actual: " + cert.CTLFile);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly adds CTL certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t12b - CTL Cert file exist and Update Site.xml works")]
            public class t12b_CTLCertFileExistsUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a CTL cert to the site.xml with invalid path
                    // 3. Call certConfig.exe on this valid CTL cert.
                    // 4. Verify CertConfig.exe passes
                    // 5. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", String.Empty, String.Empty, "\\\\josephfo\\share\\SomeBadPath.CTL", String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a CTL file
                    reportObj.Info("Attempting to validate CTL cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /CTL \\\\josephfo\\share\\cert.ctl";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.CTL file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for CTL cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)
                    {
                        reportObj.Error("Cert added to site.xml did not contain an empty Path attribute as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Cert added to site.xml did not contain an empty P7BFile attribute as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    
                    if (cert.CTLFile != "\\\\josephfo\\share\\cert.ctl")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to CTL file.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly updates CTL certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t12c - CTL Cert file exist and No Update Site.xml")]
            public class t12c_CTLCertFileExistsNoUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a CTL cert to the site.xml with valid path
                    // 3. Call certConfig.exe on this valid CTL cert.
                    // 4. Verify CertConfig.exe passes
                    // 5. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", String.Empty, String.Empty, "\\\\josephfo\\share\\cert.ctl", String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a CTL file
                    reportObj.Info("Attempting to validate CTL cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /CTL \\\\josephfo\\share\\cert.ctl";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.CTL file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for CTL cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'path' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != "\\\\josephfo\\share\\cert.ctl")
                    {
                        reportObj.Error("Certificate added to site.xml did not contain the correct CTLFile node. Expected CtLFile value should be: \\\\josephfo\\share\\cert.ctl");
                        return TEST_RESULTS.FAILED; 
                    }

                    reportObj.Info("CertConfig.exe correctly does not update CTL certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t12d - CTL Cert file does not exist and No Update Site.xml")]
            public class t12d_CTLCertFileDoesNotExistNoUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a cert to this site.xml with valid path
                    // 2. Call certConfig.exe and intentionally point to a wrong path
                    // 3. Verify CertConfig.exe fails
                    // 4. Verify site.xml was not updated with bad path

                    // delete the cert incase it somehow exists.
                    if (File.Exists("\\\\josephfo\\share\\BADPath.CTL"))
                        File.Delete("\\\\josephfo\\share\\BADPath.CTL");

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", String.Empty, String.Empty, "\\\\josephfo\\share\\cert.ctl", String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a CTL file
                    reportObj.Info("Attempting to validate CTL cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " ssl.websg /CTL \\\\josephfo\\share\\InvalidCertPath.ctl";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail due to bad path

                    if (returnCode != 1)
                    {
                        reportObj.Error("CertConfig.exe does not fail as expected when CTL file does not exist.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not find certificate node to site.xml.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for CTL cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'path' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != "\\\\josephfo\\share\\cert.ctl")  // verify site.xml was NOT updated with incorrect path
                    {
                        reportObj.Error("Certificate in site.xml was updated with a bad path.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly does not update CTL certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t13a - PFX Cert file exist and Add it to Site.xml")]
            public class t13a_PFXCertFileExistsAddSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Call certConfig.exe on a valid PFX cert.
                    // 3. Verify CertConfig.exe passes
                    // 4. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();


                    //Simple Cert validation on a PFX file
                    reportObj.Info("Attempting to validate PFX cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Component:RealComp /Property:RealProp ssl.websg /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.PFX file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "password")
                    {
                        reportObj.Error("Certificate added to site.xml was not expected.");
                        reportObj.Error("Expected pw: PfxPassword");
                        reportObj.Error("Actual pw: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to PFX file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correPFXy adds PFX certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t13b - PFX Cert file exist and Update Site.xml works")]
            public class t13b_PFXCertFileExistsUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a PFX cert to the site.xml with invalid path
                    // 3. Call certConfig.exe on this valid PFX cert.
                    // 4. Verify CertConfig.exe passes
                    // 5. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", "\\\\josephfo\\share\\SomeBadPath.PFX", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a PFX file
                    reportObj.Info("Attempting to validate PFX cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Component:RealComp /Property:RealProp ssl.websg /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.PFX file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "password")
                    {
                        reportObj.Error("Certificate added to site.xml was not expected.");
                        reportObj.Error("Expected pw: PfxPassword");
                        reportObj.Error("Actual pw: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to PFX file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correPFXy updates PFX certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("t13c - PFX Cert file exist and No Update Site.xml")]
            public class t13c_PFXCertFileExistsNoUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a PFX cert to the site.xml with valid path
                    // 3. Call certConfig.exe on this valid PFX cert.
                    // 4. Verify CertConfig.exe passes
                    // 5. Verify Cert was added to site.xml - verify password, path and Id

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a PFX file
                    reportObj.Info("Attempting to validate PFX cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Component:RealComp /Property:RealProp ssl.websg /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not validate valid Cert.PFX file.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "password")
                    {
                        reportObj.Error("Certificate added to site.xml was not expected.");
                        reportObj.Error("Expected pw: PfxPassword");
                        reportObj.Error("Actual pw: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to PFX file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correPFXy does not update PFX certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("t13d - PFX Cert file does not exist and No Update Site.xml")]
            public class t13d_PFXCertFileDoesNotExistNoUpdateSiteXml : TestNode
            {
                public override void Run()
                {
                    // 1. Create empty site.xml
                    // 2. Add a cert to this site.xml
                    // 2. Call certConfig.exe and intentionally point to a wrong path
                    // 3. Verify CertConfig.exe fails
                    // 4. Verify site.xml was not updated with bad path

                    // delete the cert incase it somehow exists.
                    if (File.Exists("\\\\josephfo\\share\\BADPath.PFX"))
                        File.Delete("\\\\josephfo\\share\\BADPath.PFX");

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("ssl.websg", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);


                    //Simple Cert validation on a PFX file
                    reportObj.Info("Attempting to validate PFX cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Component:RealComp /Property:RealProp ssl.websg /PFX \\\\josephfo\\share\\BADPath.PFX PfxPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail due to bad path

                    if (returnCode != 1)
                    {
                        reportObj.Error("CertConfig.exe does not fail as expected when PFX file does not exist.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["ssl.websg"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not find certificate node to site.xml.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml contained a non-blank password for PFX cert file.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was NOT updated with incorrect path
                    {
                        reportObj.Error("Certificate in site.xml was updated with a bad path.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correPFXy does not update PFX certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                }
            }




            [TestCase, Description("PW Defined in Deployment.xml. Valid command line pw is validated even with invalid pw in site.xml.")]
            public class t14a :TestNode
            {
                public override void Run()
                {
                    // 1. Command line to include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain an invalid password for this cert.
                    // 3. Command line password to be valid.
                    // 4. Verify CertConfig.exe returns pass.
                    // 5. Verify Site.xml password for this cert was updated to valid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\badCert.pfx", String.Empty, String.Empty, "BadPassword");
                    sitexml.AddCertToSiteXml(newCert);
                    
                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not return 0 when valid command line password passed.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "password")
                    {
                        reportObj.Error("CertConfig.exe did not update Site.xml with valid command line password.");
                        reportObj.Error("Expected Password: password");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: c:\\cert.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly validates command line password and updates PFX certificate to site.xml");
                    return TEST_RESULTS.PASSED;
                    
                }
            }

            [TestCase, Description("PW Defined in Deployment.xml. Invalid command line pw fails even with valid pw in site.xml.")]
            public class t14b : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a valid password for this cert.
                    // 3. Command line password to be invalid.
                    // 4. Verify CertConfig.exe returns fail 2.
                    // 5. Verify Site.xml password for this cert was NOT updated to invalid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, "PfxPassword");
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX \\\\josephfo\\share\\cert.pfx BadPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 2)
                    {
                        reportObj.Error("CertConfig.exe does not fail with 2 as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "PfxPassword")
                    {
                        reportObj.Error("CertConfig.exe updated site.xml password to some invalid password.");
                        reportObj.Error("Expected Password: PfxPassword");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: c:\\cert.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails with invalid command line password and does not update site.xml.");
                    return TEST_RESULTS.PASSED;

                }
            }

            [TestCase, Description("PW Defined in Deployment.xml. blank command line pw fails for non-blank-password cert.")]
            public class t14c : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a valid password for this cert.
                    // 3. Command line password to be blank (invalid)
                    // 4. Verify CertConfig.exe returns fail 2.
                    // 5. Verify Site.xml password for this cert was NOT updated to invalid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, "PfxPassword");
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX \\\\josephfo\\share\\cert.pfx \"\"";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 2)
                    {
                        reportObj.Error("CertConfig.exe does not fail with 2 as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "PfxPassword")
                    {
                        reportObj.Error("CertConfig.exe updated site.xml password to some invalid password.");
                        reportObj.Error("Expected Password: PfxPassword");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: \\\\josephfo\\share\\cert.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails with invalid blank command line password and does not update site.xml.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("PW Defined in Deployment.xml. blank command line pw passes for blank-password cert.")]
            public class t14d : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a valid password for this cert.
                    // 3. Command line password to be blank (invalid)
                    // 4. Verify CertConfig.exe returns fail 2.
                    // 5. Verify Site.xml password for this cert was NOT updated to invalid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert_BlankPassword.pfx",String.Empty, String.Empty, "PfxPassword");
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX \\\\josephfo\\share\\cert_BlankPassword.pfx \"\"";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not pass as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != String.Empty)
                    {
                        reportObj.Error("CertConfig.exe did not update site.xml with blank password.");
                        reportObj.Error("Expected Password: ");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert_BlankPassword.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: c:\\cert_BlankPassword.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly passes with valid blank command line password and does update site.xml.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("PW NOT Defined in Deployment.xml. Valid Site.xml passes, even with invalid command line pw. Site.xml not updated.")]
            public class t15a : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to NOT include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a valid password for this cert.
                    // 3. Command line password to be invalid
                    // 4. Verify CertConfig.exe returns fail 0 (pass) because CertConfig.exe should use valid Site.xml
                    // 5. Verify Site.xml password for this cert was NOT updated to invalid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, "password");
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:BadProp /Component:BadComp myCertId /PFX \\\\josephfo\\share\\cert.pfx BADPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected pass

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe does not pass as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "password")
                    {
                        reportObj.Error("CertConfig.exe udpated site.xml with an invalid password.");
                        reportObj.Error("Expected Password: password");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: c:\\cert.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly passes with valid password in Site.xml.  Site.xml not updated with bad command line data.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase, Description("PW NOT Defined in Deployment.xml. Invalid Site.xml password fails (even if command line password is valid)")]
            public class t15b : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to NOT include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a invalid password for this cert.
                    // 3. Command line password to be valid
                    // 4. Verify CertConfig.exe returns fail 2 (fail) because CertConfig.exe should use invalid Site.xml password
                    // 5. Verify Site.xml password for this cert was NOT updated to invalid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, "BadPassword");
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:BadProp /Component:BadComp myCertId /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 2)
                    {
                        reportObj.Error("CertConfig.exe does not fail with expected value.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "BadPassword")
                    {
                        reportObj.Error("CertConfig.exe changed site.xml password, but should not have.");
                        reportObj.Error("Expected Password: BadPassword");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: \\\\josephfo\\share\\cert.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails with Invalid password in Site.xml.  Site.xml not changed.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("PW NOT Defined in Deployment.xml. Blank Site.xml password fails on non-blank-password cert (even with non-blank pw command line)")]
            public class t15c : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to NOT include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a invalid password for this cert.
                    // 3. Command line password to be valid
                    // 4. Verify CertConfig.exe returns fail 2 (fail) because CertConfig.exe should use invalid Site.xml password
                    // 5. Verify Site.xml password for this cert was NOT updated to invalid password.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:BadProp /Component:BadComp myCertId /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 2)
                    {
                        reportObj.Error("CertConfig.exe does not fail with expected value.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("CertConfig.exe did not add certificate node to site.xml after successful cert validation.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "")
                    {
                        reportObj.Error("CertConfig.exe changed site.xml password, but should not have.");
                        reportObj.Error("Expected Password: ");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")  // verify site.xml was updated with correct password.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: \\\\josephfo\\share\\cert.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly fails with blank password in Site.xml.  Site.xml not changed.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("PW NOT Defined in Deployment.xml. Blank Site.xml pw passes with blank-pw cert (even with non-blank pw command line). Site.xml Updated to blank pw")]
            public class t15d : TestNode
            {
                public override void Run()
                {
                    // 1. Command line to NOT include Component and Property that actually exists in deployment.xml
                    // 2. Site.xml to contain a valid blank pw for the blank-pw cert.
                    // 3. Command line password to be invalid pw
                    // 4. Verify CertConfig.exe returns pass because CertConfig.exe should use valid blank pw from Site.xml
                    // 5. Verify Site.xml is updated with blank pw.

                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert_BlankPassword.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate blank-password pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:BadProp /Component:BadComp myCertId /PFX \\\\josephfo\\share\\cert_BlankPassword.pfx BadPassword";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe grab blank password from Site.xml when it should have.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];
                    if (cert == null)
                    {
                        reportObj.Error("Cert not found in Site.xml.  Something bad happened!");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "")
                    {
                        reportObj.Error("CertConfig.exe did not changed password to blank password");
                        reportObj.Error("Expected Password: ");
                        reportObj.Error("Actual Password: " + cert.Password);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert_BlankPassword.pfx")  // verify site.xml was updated.
                    {
                        reportObj.Error("Certificate added to site.xml contained an invalid path to pfx file.");
                        reportObj.Error("Expected Path: \\\\josephfo\\share\\cert_BlankPassword.pfx");
                        reportObj.Error("Actual Path: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe correctly grabs blank pw from Site.xml and validates blank-pw cert. Site.xml updated properly.");
                    return TEST_RESULTS.PASSED;
                }
            }



            [TestCase, Description("Verify absolute path to cert is not accepted.")]
            public class t16_AbsolutePathNotAccepted : TestNode
            {
                public override void Run()
                {
                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "c:\\cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate blank-password pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:BadProp /Component:BadComp myCertId /PFX c:\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 5)
                    {
                        reportObj.Error("CertConfig.exe did not fail with 5 as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("CertConfig.exe fails with 5 as expected when absolute path is passed.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Verify relative path to cert is not accepted and works.")]
            public class t17_RelativePathAcceptedAndWorks : TestNode
            {
                public override void Run()
                {
                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "MySubFolder\\cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate blank-password pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX MySubFolder\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString()); // expected fail

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe did not pass as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];

                    if (cert.Password != "password")
                    {
                        reportObj.Error("Cert password not updated to 'password' in site.xml as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "MySubFolder\\cert.pfx")
                    {
                        reportObj.Error("Cert relative path was not updated in site.xml as expected.");
                        reportObj.Error("Expected value: MySubFolder\\cert.pfx");
                        reportObj.Error("Actual value: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }


                    reportObj.Info("CertConfig.exe works with relative path.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Verify No path to cert is accepted and uses secure share for path.")]            
            public class t18_NoCertPathAcceptedAndWorks : TestNode
            {
                public override void Run()
                {
                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate blank-password pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe did not pass as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];

                    if (cert.Password != "password")
                    {
                        reportObj.Error("Cert password not updated to 'password' in site.xml as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "cert.pfx")
                    {
                        reportObj.Error("Cert relative path was not updated in site.xml as expected.");
                        reportObj.Error("Expected value: cert.pfx");
                        reportObj.Error("Actual value: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }


                    reportObj.Info("CertConfig.exe works with no cert path.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, Description("Verify Non-User Non-Cert nodes in site.xml are not deleted during CertConfig.exe")]
            public class t19_NonUserNonCertNodesNotDeletedInSiteXml : TestNode
            {
                public override void Run()
                {
                    SiteXml sitexml = new SiteXml();
                    Certificate newCert = new Certificate("myCertId", "\\\\josephfo\\share\\cert.pfx", String.Empty, String.Empty, String.Empty);
                    sitexml.AddCertToSiteXml(newCert);
                    sitexml.AddNonCertNonUserNodes();

                    //Simple Cert validation on a pfx file
                    reportObj.Info("Attempting to validate pfx cert.");
                    String args = " /Site=" + sitexml.SiteXmlPathFilename + " /Property:RealProp /Component:RealComp myCertId /PFX \\\\josephfo\\share\\cert.pfx password";
                    Int32 returnCode = StartProcess(@"C:", "CertConfig.exe", args);
                    reportObj.Info("CertConfig.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("CertConfig.exe did not pass as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    SiteXml newSitexml = new SiteXml(sitexml.SiteXmlPathFilename);
                    Certificate cert = newSitexml.CertificateDictionary["myCertId"];

                    if (newSitexml.NonCertNonUserNodesExist())
                    {
                        reportObj.Info("Found nonUser nonCert element in site.xml.  CertConfig.exe does not wipe out this 'other' data.");
                    }
                    else
                    {
                        reportObj.Error("nonUser nonCert element in site.xml was wiped out by CertConfig.exe.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Password != "password")
                    {
                        reportObj.Error("Cert password not updated to 'password' in site.xml as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.Path != "\\\\josephfo\\share\\cert.pfx")
                    {
                        reportObj.Error("Cert relative path was not updated in site.xml as expected.");
                        reportObj.Error("Expected value: cert.pfx");
                        reportObj.Error("Actual value: " + cert.Path);
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.P7BFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'P7BFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (cert.CTLFile != String.Empty)
                    {
                        reportObj.Error("Certificate added to site.xml did not contain an empty 'CTLFile' node as expected.");
                        return TEST_RESULTS.FAILED;
                    }


                    reportObj.Info("CertConfig.exe works with no cert path.");
                    return TEST_RESULTS.PASSED;
                }
            }

        }

        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class OctopusTests
        { }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Vault\PropTitles\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_proptitles_none_12.4.56.0_none_39e90c355d82ed94
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=proptitles
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.manifest
XP_MANIFEST_PATH=manifests\x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.cat
XP_CATALOG_PATH=manifests\x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.cat
XP_PAYLOAD_PATH=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=proptitles,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Vault\PropTitles\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_proptitles_none_12.4.56.0_none_39e90c355d82ed94
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=proptitles
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.manifest
XP_MANIFEST_PATH=manifests\x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.cat
XP_CATALOG_PATH=manifests\x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734.cat
XP_PAYLOAD_PATH=x86_proptitles_no-public-key_12.4.56.0_x-ww_43b6e734
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=proptitles,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\XblCfgTest\TestClient\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TestClient")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("TestClient")]
[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("bc9a1f9f-b1ac-452f-9f34-cadac7f6a77c")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\XblCfgTest\TestClient\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xblCfgTest;

namespace TestClient
{
    class Program
    {
        static void Main(string[] args)
        {
            xblCfgTests.ServerAddTests.SimpleAdd test = new xblCfgTests.ServerAddTests.SimpleAdd();            
            test.Run();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\XblCfgTest\xblCfgTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("xblCfgTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("xblCfgTest")]
[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("dedc85cb-fd9c-4392-ab8e-b8972f0b7b8b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\XblCfgTest\xblCfgTest\xblCfgTest.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using System.Data.Sql;
using System.Data.SqlClient;
using System.Net;
using System.Net.NetworkInformation;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;

using xonline.common.config;


namespace xblCfgTest
{
    [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
    public class xblCfgTests : TestNode
    {
        static Report reportObj = new Report(typeof(xblCfgTests).Name);
        static String IPADDRESSOFXBLOB = "65.52.244.58";
        static NetworkInterface[] networks;

        static xblCfgTests()
        {
            networks = GetNetworkInterfaces();
        }

        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class ServerAddTests : TestNode
        {
            
            private static String LOCALSERVERNAME = Environment.ExpandEnvironmentVariables("%ComputerName%");

            [TestCase]
            public class SimpleAdd : TestNode
            {
                public override void Run()
                {
                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 2)
                    {
                        reportObj.Error("More than 2 nics on the local server. Unable to run the test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Verify npdb exists in host file so we can delete the NICS/Servers.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    System.Threading.Thread.Sleep(500);                    

                    // Delete server ane NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);                


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    // validation depends on the number of NICs on this server.
                    // If single NIC, then verify that this test adds the Server and Nic as 'middle_tier' to NPDB
                    // If double NIC, then verify both middle_tier and internet_tier are added for this server.

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }

                    
                }
            }

            [TestCase]
            public class SimpleAddWithBadNPDBArgument : TestNode
            {

                // same as SimpleAdd except with the npdb:BadNPDBServerName
                public override void Run()
                {
                    // NOTE: THIS CASE IS RETURNING A FALSE POSITIVE - but not sure why.  If running the same command outside of stfgui,
                    //       even at the same time, it will fail.  Bug 21853 created.

                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 2)
                    {
                        reportObj.Error("More than 2 nics on the local server. Unable to run the test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Add npdb to host file so the following two calls to NPDB will pass.  Removed right after these calls.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    System.Threading.Thread.Sleep(500);

                    // Delete server ane NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    // remove NPDB from host file to make sure this is the only way to find NPDB server
                    HostFile.DeleteNPDBFromHosts();
                    System.Threading.Thread.Sleep(500);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -npdb:BadNPDBArg";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    // validation depends on the number of NICs on this server.
                    // If single NIC, then verify that this test adds the Server and Nic as 'middle_tier' to NPDB
                    // If double NIC, then verify both middle_tier and internet_tier are added for this server.

                    if (returnCode != -1)
                    {
                        reportObj.Error("xblcfg.exe is expected to fail with -1 here, but does not.");
                        reportObj.Error("See console output above for more info.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("xblcfg.exe failed as expected with -1 when bad NPDB server name argument.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class SimpleAddWithGoodNPDBArgument : TestNode
            {

                // same as SimpleAdd except with the npdb:GoodNPDBServerName
                public override void Run()
                {
                    // NOTE: THIS CASE IS RETURNING A FALSE POSITIVE - but not sure why.  If running the same command outside of stfgui,
                    //       even at the same time, it will fail.  Bug 21853 created.
                    
                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 2)
                    {
                        reportObj.Error("More than 2 nics on the local server. Unable to run the test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Add npdb to host file so the following two calls to NPDB will pass.  Removed right after these calls.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    System.Threading.Thread.Sleep(500);

                    // Delete server ane NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    // remove NPDB from host file to make sure this is the only way to find NPDB server
                    HostFile.DeleteNPDBFromHosts();
                    System.Threading.Thread.Sleep(500);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -npdb:josephfo-xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    // validation depends on the number of NICs on this server.
                    // If single NIC, then verify that this test adds the Server and Nic as 'middle_tier' to NPDB
                    // If double NIC, then verify both middle_tier and internet_tier are added for this server.
                    
                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);
                    

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }



            [TestCase]
            public class SimpleAddWithBadSiteId : TestNode
            {
                public override void PreRun()
                {

                }

                // same as SimpleAdd except with the npdb:GoodNPDBServerName
                public override void Run()
                {
                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 2)
                    {
                        reportObj.Error("More than 2 nics on the local server. Unable to run the test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Add npdb to host file so the following two calls to NPDB will pass.  Removed right after these calls.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    System.Threading.Thread.Sleep(500);

                    // Delete server ane NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -site:15";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    // validation depends on the number of NICs on this server.
                    // If single NIC, then verify that this test adds the Server and Nic as 'middle_tier' to NPDB
                    // If double NIC, then verify both middle_tier and internet_tier are added for this server.

                    if (returnCode != -1)
                    {
                        reportObj.Error("xblcfg.exe should have failed with -1, but did not.  Actual return code was: " + returnCode);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("xblcfg.exe failed when expected.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase]
            public class SimpleAddWithGoodSiteId : TestNode
            {
                public override void PreRun()
                {

                }

                public override void Run()
                {
                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 2)
                    {
                        reportObj.Error("More than 2 nics on the local server. Unable to run the test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Add npdb to host file so the following two calls to NPDB will pass.  Removed right after these calls.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    System.Threading.Thread.Sleep(500);

                    // Delete server ane NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -site:9999";  // 9999 is a valid site id that exists in xblob.
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    // validation depends on the number of NICs on this server.
                    // If single NIC, then verify that this test adds the Server and Nic as 'middle_tier' to NPDB
                    // If double NIC, then verify both middle_tier and internet_tier are added for this server.

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);


                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class ExistingSiteIdOverwrittenByNewSiteId : TestNode
            {
                public override void Run()
                {
                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 2)
                    {
                        reportObj.Error("More than 2 nics on the local server. Unable to run the test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Add npdb to host file so the following two calls to NPDB will pass.  Removed right after these calls.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);                    

                    // Delete server and NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    reportObj.Info("Running xblcfg.exe again with different siteId. Update expected.");
                    args = "-server -add -site:9999";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                     if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                     // grab actual NICRoles from npdb database.
                     Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                     // Build expected Nics list from local network interfaces
                     Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                     if (NicRole.CompareNics(ActualNics, ExpectedNics))
                     {
                         reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                         return TEST_RESULTS.PASSED;
                     }
                     else
                     {
                         reportObj.Error("Error in the NIC validation. See above.");
                         return TEST_RESULTS.FAILED;
                     }
                }
            }

            [TestCase]
            public class ServerAddWithXBlobFlag : TestNode
            {
                public override void Run()
                {
                    Dictionary<String, Boolean> nicFound = new Dictionary<string, bool>();
                    nicFound.Add("internet_tier", false);
                    nicFound.Add("middle_tier", false);

                    // verify there is only 1 or 2 NICs on this local box.
                    if (networks.Length < 1)
                    {
                        reportObj.Error("Less than 1 NIC on the local server.  Unable to run this test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    if (networks.Length > 1)
                    {
                        reportObj.Error("More than 1 nic on the local server. Unable to run the xblob test.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Add npdb to host file so the following two calls to NPDB will pass.  Removed right after these calls.
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);

                    // Delete server and NIC to make sure they are created freshly.
                    reportObj.Info("Deleting local servers NICs if they exist in npdb.");
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);

                    reportObj.Info("Deleting local server if it exists in npdb.");
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class ServerDeleteTests : TestNode
        {
            private static NetworkInterface[] networks;
            private static String LOCALSERVERNAME = Environment.ExpandEnvironmentVariables("%ComputerName%");

            static ServerDeleteTests()
            {
                networks = GetNetworkInterfaces();
            }



            [TestCase]
            public class DeleteAllNics : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }

                    // now delete a single nic role.
                    reportObj.Info("Run xblcfg.exe to delete server nics.");
                    args = "-server -delete";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // re-populate nic list.
                    ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // remove the two nics from expected nic list.
                    ExpectedNics.Remove("internet_tier");
                    ExpectedNics.Remove("middle_tier");

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs were removed from npdb as expected.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class DeleteOneOfTwoNicRoles : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -add -xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }

                    // now delete a single nic role.
                    reportObj.Info("Run xblcfg.exe to delete server nics.");
                    args = "-server -delete -nic:internet_tier";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // re-populate nic list.
                    ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // leave this empty.
                    ExpectedNics.Remove("internet_tier");

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs were removed from npdb as expected.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class DeleteSG : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }

                    // now delete the rows rows using -sg, and make sure they are all gone.
                    reportObj.Info("Run xblcfg.exe to delete server nics.");
                    args = "-server -delete -sg";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // re-populate nic list.
                    ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // leave this empty.
                    Dictionary<string, NicRole> AfterDeleteNicRoles = new Dictionary<string, NicRole>();

                    if (NicRole.CompareNics(ActualNics, AfterDeleteNicRoles))
                    {
                        reportObj.Info("All NICs were removed from npdb as expected.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class ServerAddSGTests : TestNode
        {
            private static NetworkInterface[] networks;
            private static String LOCALSERVERNAME = Environment.ExpandEnvironmentVariables("%ComputerName%");

            static ServerAddSGTests()
            {
                networks = GetNetworkInterfaces();
            }

            [TestCase]
            public class SimpleAddSGWithXBlobFlag : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);

                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class SimpleAddSGWithInvalidNicParam : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -nic:BadNicRole -ip:10.24.10.24 -netmask:255.255.254.0 -gateway:10.24.0.1";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("xblcfg is expected to fail with -1 when bad NIC, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("xblcfg.exe correctly fails with -1 when passing a bad NIC role argument.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class SimpleAddSGWithValidParams : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -nic:internet_tier_sg1 -ip:10.24.10.24 -netmask:255.255.254.0 -gateway:10.24.0.1";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list from local network interfaces
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

            [TestCase]
            public class SimpleAddSGWithMiddleTierSGMissingSGPoolInfo : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -nic:middle_tier_sg -ip:10.24.10.24 -netmask:255.255.254.0 -gateway:10.24.0.1";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("xblcfg is expected to fail with -1 when missing SG Pool info, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("xblcfg.exe correctly fails with -1 when using middle_tier_sg and missing SG Pool Info.");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase]
            public class SimpleAddSGWithMiddleTierSGGoodSGPoolInfoNoMac : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -nic:middle_tier_sg -ip:10.24.10.24 -netmask:255.255.254.0 -gateway:10.24.0.1 -sgipbegin:10.24.10.24 -sgipend:10.24.10.220 -sgportbegin:2000 -sgportend:5000";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }


            [TestCase]
            public class SimpleAddSGWithMiddleTierSGGoodSGPoolInfoInvalidMac : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    String args = "-server -addsg -nic:middle_tier_sg -ip:10.24.10.24 -netmask:255.255.254.0 -gateway:10.24.0.1 -mac:InvalidMac -sgipbegin:10.24.10.24 -sgipend:10.24.10.220 -sgportbegin:2000 -sgportend:5000";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("xblcfg.exe is expected to fail with -1, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("xblcfg.exe fails as expected when invalid MAC address is passed in.");
                    return TEST_RESULTS.PASSED;                    
                }
            }



            [TestCase]
            public class SimpleAddSGWithMiddleTierSGGoodSGPoolInfoValidMac : TestNode
            {
                public override void Run()
                {
                    HostFile.AddNPDBToHosts(IPADDRESSOFXBLOB);
                    NPDBAccess.DeleteServerNIC(LOCALSERVERNAME);
                    NPDBAccess.DeleteServer(LOCALSERVERNAME);


                    reportObj.Info("Run xblcfg.exe to create a new server role.");
                    
                    //valid mac address: The address parameter must contain a string that can only consist of numbers and upper-case letters as hexadecimal digits.
                    String args = "-server -addsg -nic:middle_tier_sg -ip:10.24.10.24 -netmask:255.255.254.0 -gateway:10.24.0.1 -mac:2211334455D2 -sgipbegin:10.24.10.24 -sgipend:10.24.10.220 -sgportbegin:2000 -sgportend:5000";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    // grab actual NICRoles from npdb database.
                    Dictionary<string, NicRole> ActualNics = NPDBAccess.GetNicsFromServername(LOCALSERVERNAME);

                    // Build expected Nics list
                    Dictionary<string, NicRole> ExpectedNics = NicRole.BuildExpectedNics(LOCALSERVERNAME, args);

                    if (NicRole.CompareNics(ActualNics, ExpectedNics))
                    {
                        reportObj.Info("All NICs in NPDB match expected NIC list for this test.");
                        return TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        reportObj.Error("Error in the NIC validation. See above.");
                        return TEST_RESULTS.FAILED;
                    }
                }
            }

        }


        [TestGroup, Owner("josephfo"), TestFrequency("Daily")]
        public class VInterfaceTests : TestNode
        {
            private static String LOCALSERVERNAME = Environment.ExpandEnvironmentVariables("%ComputerName%");

            [TestCase]
            public class NewInterface : TestNode
            {
                public override void Run()
                {

                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");
                    NPDBAccess.DeleteSVI("xblob", "sgsvc");  // just incase another test cases added this.

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExistingInterfaceWithOverwrite : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting all SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes before the update.");


                    reportObj.Info("Calling xblcfg.exe again to overwrite the IP address.");
                    //Now, lets update the IP address with a new one.  Note: the only thing that should be updated is the IP.
                    args = "-vinterface -add:authsg -vip:88.88.88.88 -overwrite";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());
                    
                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    // now do the same verification with the new IP.
                    sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("88.88.88.88");
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes after the update.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExistingInterfaceNoOverwrite : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting all SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes before the update.");


                    reportObj.Info("Calling xblcfg.exe again with NO overwrite flag.");
                    //Now, lets update the IP address with a new one.  Note: the only thing that should be updated is the IP.
                    args = "-vinterface -add:authsg -vip:88.88.88.88";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    // now do the same verification with the original IP.
                    sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    // finally, validate that no site-vi-ip exists for the IP passed to the command line.
                    sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("88.88.88.88");
                    reportObj.Info("Verifying no site-vi-ip rows exist for 88.88.88.88");
                    if (sviList.Count != 0)
                    {
                        reportObj.Error("Found t_site_virtual_interface_ips rows for the 88.88.88.88 IP, but none were expected.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes after the update.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CustomInvalidSiteId : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg -site:24 -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != -1)
                    {
                        reportObj.Error("xblcfg.exe is expected to fail with -1, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("xblcfg.exe fails correctly with -1 when invalid siteId is passed to command line.");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CustomValidSiteId : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg -site:9999 -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 9999)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 9999");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class PassNoVIPToCheckAutoDiscovery : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");

                    // First, make sure t_server_nics row exists for local computer with nic_role 'middle_tier'
                    reportObj.Info("Run xblcfg.exe to make sure server ip exists for nic role 'middle_tier'.");
                    String args = "-server -add -xblob";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // Now, call xblcfg.exe with -vinterface with no IP to force auto IP discovery.
                    // First, make sure t_server_nics row exists for local computer with nic_role 'middle_tier'
                    reportObj.Info("starting xblcfg.exe with -vinterface with no -vip to verify auto ip discovery.");
                    args = "-vinterface -add:authsg";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe does not return 0 as expected.");
                        reportObj.Error("See console output above to debug error.");
                        return TEST_RESULTS.NOT_EXECUTED;
                    }

                    // find out the local IP address so we can pass it to GetSiteVIIPsFromIPAddress.
                    IPAddress npdbIP = NicRole.FindDatacenterIP();


                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress(npdbIP.ToString());
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("authsg"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: authsg");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CheckSGSVCNoUpdatesUODBNoOverwrite : TestNode
            {
                public override void Run()
                {
                    HostFile.AddUODBToHosts(IPADDRESSOFXBLOB);
                    Site OriginalSite = UODBAccess.GetSitesFromUODB(1);

                    const string VIP = "99.99.99.99";
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "sgsvc");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:sgsvc -vip:" + VIP;
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress(VIP);
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("sgsvc"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: sgsvc");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    // now check that sgsvc exists in the uodb also.
                    Site newSite = UODBAccess.GetSitesFromUODB(1);
                    
                    // from the code that does the insert:
                    /*
                        client.AddParameter("@i_site_id", siteId);
                        client.AddParameter("@vc_kerb_service_name", "sg");
                        client.AddParameter("@vc_kerb_domain_name", "site1");
                        client.AddParameter("@vc_description", "Site1");
                        client.AddParameter("@vc_ip", vip);
                        client.AddParameter("@i_key_version", 3);
                        client.AddParameter("@overwriteExistingValue", overwriteExistingValue ? 1 : 0);
                     */

                    // siteId check implicitly done by the way we get the data.

                    if (newSite.KerbServiceName != OriginalSite.KerbServiceName)
                    {
                        reportObj.Error("Kerbose service name changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (newSite.KerbDomainName != OriginalSite.KerbDomainName)
                    {
                        reportObj.Error("Kerbose domain name changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (newSite.IP != OriginalSite.IP)
                    {
                        reportObj.Error("IP name changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (newSite.Description != OriginalSite.Description)
                    {
                        reportObj.Error("Description changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes");
                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase]
            public class CheckSGSVCUpdatesUODBWithOverwrite : TestNode
            {
                public override void Run()
                {
                    HostFile.AddUODBToHosts(IPADDRESSOFXBLOB);
                    Site OriginalSite = UODBAccess.GetSitesFromUODB(1);

                    const string VIP = "99.99.99.99";
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "sgsvc");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:sgsvc -vip:" + VIP + " -overwrite";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress(VIP);
                    if (sviList.Count != 1)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 1 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].Environment.Equals(Config.Environment))
                    {
                        reportObj.Error("Environment field in t_site_virtual_interface_ips does not match expected value of: " + Config.Environment);
                        reportObj.Error("Actual value is: " + sviList[0].Environment);
                        return TEST_RESULTS.FAILED;
                    }

                    if (sviList[0].SiteID != 1)
                    {
                        reportObj.Error("Site field in t_site_virtual_interface_ips does not match expected value of: 1");
                        reportObj.Error("Actual value is: " + sviList[0].SiteID.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    if (!sviList[0].VirtualInterface.Equals("sgsvc"))
                    {
                        reportObj.Error("VirtualInterface field in t_site_virtual_interface_ips does not match expected value of: sgsvc");
                        reportObj.Error("Actual value is: " + sviList[0].VirtualInterface);
                        return TEST_RESULTS.FAILED;
                    }

                    // now check that sgsvc exists in the uodb also.
                    Site newSite = UODBAccess.GetSitesFromUODB(1);

                    // from the code that does the insert:
                    /*
                        client.AddParameter("@i_site_id", siteId);
                        client.AddParameter("@vc_kerb_service_name", "sg");
                        client.AddParameter("@vc_kerb_domain_name", "site1");
                        client.AddParameter("@vc_description", "Site1");
                        client.AddParameter("@vc_ip", vip);
                        client.AddParameter("@i_key_version", 3);
                        client.AddParameter("@overwriteExistingValue", overwriteExistingValue ? 1 : 0);
                     */

                    // siteId check implicitly done by the way we get the data.

                    if (newSite.KerbServiceName != "sg")
                    {
                        reportObj.Error("Kerbose service name changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (newSite.KerbDomainName != "site1")
                    {
                        reportObj.Error("Kerbose domain name changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (newSite.IP != "99.99.99.99")  // this is the important check since other stuff is fairly static.
                    {
                        reportObj.Error("IP name changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    if (newSite.Description != "Site1")
                    {
                        reportObj.Error("Description changed in UODB t_sites, but should not have.");
                        return TEST_RESULTS.FAILED;
                    }

                    reportObj.Info("All validation passes");
                    return TEST_RESULTS.PASSED;
                }
            }




            [TestCase]
            public class VerifyMultipleVIsAreAllAdded : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");
                    NPDBAccess.DeleteSVI("xblob", "sgsvc");  // just incase another test cases added this.
                    NPDBAccess.DeleteSVI("xblob", "lists"); 

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg;lists -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 3)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 3 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<string, bool> viCheck = new Dictionary<string, bool>();
                    viCheck.Add("authsg", false);
                    viCheck.Add("lists", false);

                    foreach (SiteVIIP svi in sviList)
                    {
                        if (!viCheck.ContainsKey(svi.VirtualInterface))
                        {
                            reportObj.Error("Found a virtual interface in the t_site_virtual_interface_ips table that should not exist.");
                            reportObj.Error("Virtual Interface is: " + svi.VirtualInterface);
                            return TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            viCheck[svi.VirtualInterface] = true;
                            reportObj.Info("VirtualInterface check passes for vi: " + svi.VirtualInterface);
                        }
                    }

                    foreach (KeyValuePair<string, bool> vi in viCheck)
                    {
                        if (vi.Value == false)
                        {
                            reportObj.Error("Did not find expected virtual interface in t_site_virtual_interface_ips.");
                            reportObj.Error("Expected missing vi was: " + vi.Key);
                            return TEST_RESULTS.FAILED;
                        }
                    }

                    reportObj.Info("All validation passes");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class VerifyMultipleVIsAreAllUpdated : TestNode
            {
                public override void Run()
                {
                    reportObj.Info("Deleting SVI before adding it clean.");
                    NPDBAccess.DeleteSVI("xblob", "authsg");
                    NPDBAccess.DeleteSVI("xblob", "sgsvc");  // just incase another test cases added this.
                    NPDBAccess.DeleteSVI("xblob", "lists");

                    reportObj.Info("Run xblcfg.exe to add a site-vi-ip");

                    String args = "-vinterface -add:authsg;lists -vip:99.99.99.99";
                    Int32 returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }

                    List<SiteVIIP> sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("99.99.99.99");
                    if (sviList.Count != 3)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 3 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    Dictionary<string, bool> viCheck = new Dictionary<string, bool>();
                    viCheck.Add("authsg", false);
                    viCheck.Add("lists", false);

                    foreach (SiteVIIP svi in sviList)
                    {
                        if (!viCheck.ContainsKey(svi.VirtualInterface))
                        {
                            reportObj.Error("Found a virtual interface in the t_site_virtual_interface_ips table that should not exist.");
                            reportObj.Error("Virtual Interface is: " + svi.VirtualInterface);
                            return TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            viCheck[svi.VirtualInterface] = true;
                            reportObj.Info("VirtualInterface check passes for vi: " + svi.VirtualInterface);
                        }
                    }

                    foreach (KeyValuePair<string, bool> vi in viCheck)
                    {
                        if (vi.Value == false)
                        {
                            reportObj.Error("Did not find expected virtual interface in t_site_virtual_interface_ips.");
                            reportObj.Error("Expected missing vi was: " + vi.Key);
                            return TEST_RESULTS.FAILED;
                        }
                    }

                    reportObj.Info("All pre-update validation passes");
                    reportObj.Info("Call xblcfg.exe again to update the multiple vinterfaces.");

                    args = "-vinterface -add:authsg;lists -vip:88.88.88.88 -overwrite";
                    returnCode = StartProcess(@"C:", "xblcfg.exe", args);
                    reportObj.Info("xblcfg.exe process returns " + returnCode.ToString());

                    if (returnCode != 0)
                    {
                        reportObj.Error("xblcfg.exe is expected to pass and return 0, but does not.");
                        return TEST_RESULTS.FAILED;
                    }


                    sviList = NPDBAccess.GetSiteVIIPsFromIPAddress("88.88.88.88");
                    if (sviList.Count != 3)
                    {
                        reportObj.Error("Incorrect number of rows in the t_site_virtual_interface_ips table.  Expected 3 but found " + sviList.Count.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    viCheck = new Dictionary<string, bool>();
                    viCheck.Add("authsg", false);
                    viCheck.Add("lists", false);

                    foreach (SiteVIIP svi in sviList)
                    {
                        if (!viCheck.ContainsKey(svi.VirtualInterface))
                        {
                            reportObj.Error("Found a virtual interface in the t_site_virtual_interface_ips table that should not exist.");
                            reportObj.Error("Virtual Interface is: " + svi.VirtualInterface);
                            return TEST_RESULTS.FAILED;
                        }
                        else
                        {
                            // verify its pointing to the correct VIP.
                            if (svi.IP != "88.88.88.88")
                            {
                                reportObj.Error("IP address in the t_site_virtual_interface_ips table was not set to 88.88.88.88 as expected.");
                                reportObj.Error("Actual IP address was: " + svi.IP);
                                return TEST_RESULTS.FAILED;
                            }

                            viCheck[svi.VirtualInterface] = true;
                            reportObj.Info("VirtualInterface check passes for vi: " + svi.VirtualInterface);
                        }
                    }

                    foreach (KeyValuePair<string, bool> vi in viCheck)
                    {
                        if (vi.Value == false)
                        {
                            reportObj.Error("Did not find expected virtual interface in t_site_virtual_interface_ips.");
                            reportObj.Error("Expected missing vi was: " + vi.Key);
                            return TEST_RESULTS.FAILED;
                        }
                    }
                    return TEST_RESULTS.PASSED;
                }
            }

        }



        private static NetworkInterface[] GetNetworkInterfaces()
        {
            NetworkInterface[] nets = Array.FindAll(NetworkInterface.GetAllNetworkInterfaces(),
                delegate(NetworkInterface n)
                {
                    return n.NetworkInterfaceType != NetworkInterfaceType.Loopback && n.NetworkInterfaceType != NetworkInterfaceType.Tunnel && n.OperationalStatus == OperationalStatus.Up;
                });

            if (nets.Length > 0)
            {
                reportObj.Info("Active TCP/IP network interfaces discovered:");
                foreach (NetworkInterface n in nets)
                {
                    reportObj.Info("MAC {0}:", n.GetPhysicalAddress());
                    reportObj.Info("InterfaceType {0}:", n.NetworkInterfaceType);
                    foreach (UnicastIPAddressInformation ip in n.GetIPProperties().UnicastAddresses)
                    {
                        reportObj.Info("\tIP: {0}", ip.Address);
                    }
                }
                reportObj.Info("");
            }
            return nets;
        }


        private static NetworkInterface FindDatacenterAddress(NetworkInterface[] networks, IPAddress addr)
        {
            if (networks.Length == 1)
            {
                return networks[0];
            }
            else
            {
                foreach (NetworkInterface network in networks)
                {
                    foreach (UnicastIPAddressInformation ip in network.GetIPProperties().UnicastAddresses)
                    {
                        if (addr.Equals(ip.Address))
                        {
                            return network;
                        }
                    }
                }

                // Shouldn't get here, so return null and let hilarity ensue.
                return null;
            }
        }

        protected static Int32 StartProcess(String WorkingDir, String FileName, String Arguments)
        {
            Process MyProc = new Process();
            MyProc.StartInfo.WorkingDirectory = Environment.ExpandEnvironmentVariables(WorkingDir);
            MyProc.StartInfo.FileName = Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName;
            MyProc.StartInfo.UseShellExecute = false;
            MyProc.StartInfo.RedirectStandardError = true;
            MyProc.StartInfo.RedirectStandardInput = true;
            MyProc.StartInfo.RedirectStandardOutput = true;
            MyProc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;

            MyProc.StartInfo.Arguments = Arguments;

            MyProc.Start();
            String stdOut = MyProc.StandardOutput.ReadToEnd();
            String stdErr = MyProc.StandardError.ReadToEnd();
            MyProc.WaitForExit();
            Int32 exitCode = MyProc.ExitCode;
            MyProc.Close();
            reportObj.Info("Command line used:");
            reportObj.Info(Environment.ExpandEnvironmentVariables(WorkingDir) + "\\" + FileName + " " + Arguments);
            reportObj.Info("stdOut: " + stdOut);
            reportObj.Info("stdErr: " + stdErr);
            return exitCode;
        }

        public class LocalServerInfo
        {
            public static string ServerName;
            public static string IP;
            public static string Netmask;
            public static string DefaultGateway;
            public static string MAC;

            static LocalServerInfo()
            {
                // should not need to hard-code these values when all is working as expected.
                ServerName = "JOSEPHFO5";
                IP = "65.52.244.111";
                Netmask = "255.255.254.0";
                DefaultGateway = "65.52.244.1";
                MAC = "0022190D8511";
            }
        }


        // NicRole class represents a row in the t_server_nics table.
        public class NicRole
        {
            static Report reportObj = new Report(typeof(NicRole).Name);

            private Int32 siteId;
            private string environment;
            private string server;
            private string nic_role;
            private string ip;
            private string ip_netmask;
            private string ip_default_gateway;
            private string ip_mac;
            private string sg_ip_begin;
            private string sg_ip_end;
            private Int32 sg_port_begin;
            private Int32 sg_port_end;

            public NicRole(Int32 SiteId, string Environment, string Server, string NicRoleString, string IP, string IPNetmask,
                string IPDefaultGateway, string IPMac, string SGIPBegin, string SGIPEnd, Int32 SGPortBegin, Int32 SGPortEnd)
            {
                this.siteId = SiteId;
                this.environment = Environment;
                this.server = Server;
                this.nic_role = NicRoleString;
                this.ip = IP;
                this.ip_netmask = IPNetmask;
                this.ip_default_gateway = IPDefaultGateway;
                this.ip_mac = IPMac;
                this.sg_ip_begin = SGIPBegin;
                this.sg_ip_end = SGIPEnd;
                this.sg_port_begin = SGPortBegin;
                this.sg_port_end = SGPortEnd;
            }

            public Int32 SiteID
            {
                get { return this.siteId; }
                set { this.siteId = value; }
            }

            public string Env
            {
                get { return this.environment; }
                set { this.environment = value; }
            }

            public string Server
            {
                get { return this.server; }
                set { this.server = value; }
            }

            public string NicRoleString
            {
                get { return this.nic_role; }
                set { this.nic_role = value; }
            }

            public string IP
            {
                get { return this.ip; }
                set { this.ip = value; }
            }

            public string IPNetmask
            {

                get { return this.ip_netmask; }
                set { this.ip_netmask = value; }
            }

            public string IPDefaultGateway
            {
                get { return this.ip_default_gateway; }
                set { this.ip_default_gateway = value; }
            }

            public string IPMac
            {
                get { return this.ip_mac; }
                set { this.ip_mac = value; }
            }

            public string SGIPBegin
            {
                get { return this.sg_ip_begin; }
                set { this.sg_ip_begin = value; }
            }

            public string SGIPEnd
            {
                get { return this.sg_ip_end; }
                set { this.sg_ip_end = value; }
            }

            public Int32 SGPortBegin
            {
                get { return this.sg_port_begin; }
                set { this.sg_port_begin = value; }
            }

            public Int32 SGPortEnd
            {
                get { return this.sg_port_end; }
                set { this.sg_port_end = value; }
            }

            public override bool Equals(object obj)
            {
                if (obj == null) return false;

                if (this.GetType() != obj.GetType()) return false;

                NicRole nicRole = (NicRole)obj;

                if (Object.Equals(this.siteId, nicRole.siteId))
                {
                    reportObj.Info("Verified siteId field matches. They are both: " + nicRole.siteId);
                }
                else
                {
                    reportObj.Error("siteId fields to not match.");
                    reportObj.Error("Expected: " + this.siteId);
                    reportObj.Error("Actual: " + nicRole.siteId);
                    return false;
                }

                if (Object.Equals(this.environment, nicRole.environment))
                {
                    reportObj.Info("Verified Environment field matches. They are both: " + nicRole.environment);
                }
                else
                {
                    reportObj.Error("Environment fields to not match.");
                    reportObj.Error("Expected: " + this.environment);
                    reportObj.Error("Actual: " + nicRole.environment);
                    return false;
                }

                if (Object.Equals(this.server, nicRole.server))
                {
                    reportObj.Info("Verified server field matches. They are both: " + nicRole.server);
                }
                else
                {
                    reportObj.Error("server fields to not match.");
                    reportObj.Error("Expected: " + this.server);
                    reportObj.Error("Actual: " + nicRole.server);
                    return false;
                }

                if (Object.Equals(this.nic_role, nicRole.nic_role))
                {
                    reportObj.Info("Verified nic_role field matches. They are both: " + nicRole.nic_role);
                }
                else
                {
                    reportObj.Error("nic_role fields to not match.");
                    reportObj.Error("Expected: " + this.nic_role);
                    reportObj.Error("Actual: " + nicRole.nic_role);
                    return false;
                }


                if (Object.Equals(this.ip, nicRole.ip))
                {
                    reportObj.Info("Verified ip field matches. They are both: " + nicRole.ip);
                }
                else
                {
                    reportObj.Error("ip fields to not match.");
                    reportObj.Error("Expected: " + this.ip);
                    reportObj.Error("Actual: " + nicRole.ip);
                    return false;
                }

                if (Object.Equals(this.ip_netmask, nicRole.ip_netmask))
                {
                    reportObj.Info("Verified ip_netmask field matches. They are both: " + nicRole.ip_netmask);
                }
                else
                {
                    reportObj.Error("ip_netmask fields to not match.");
                    reportObj.Error("Expected: " + this.ip_netmask);
                    reportObj.Error("Actual: " + nicRole.ip_netmask);
                    return false;
                }


                if (Object.Equals(this.ip_default_gateway, nicRole.ip_default_gateway))
                {
                    reportObj.Info("Verified ip_default_gateway field matches. They are both: " + nicRole.ip_default_gateway);
                }
                else
                {
                    reportObj.Error("ip_default_gateway fields to not match.");
                    reportObj.Error("Expected: " + this.ip_default_gateway);
                    reportObj.Error("Actual: " + nicRole.ip_default_gateway);
                    return false;
                }


                if (Object.Equals(this.ip_mac, nicRole.ip_mac))
                {
                    reportObj.Info("Verified ip_mac field matches. They are both: " + nicRole.ip_mac);
                }
                else
                {
                    reportObj.Error("ip_mac fields to not match.");
                    reportObj.Error("Expected: " + this.ip_mac);
                    reportObj.Error("Actual: " + nicRole.ip_mac);
                    return false;
                }




                // lets say that null is the same as string.empty.
                if (this.sg_ip_begin == null) this.sg_ip_begin = String.Empty;                
                if (Object.Equals(this.sg_ip_begin, nicRole.sg_ip_begin))
                {
                    reportObj.Info("Verified sg_ip_begin field matches. They are both: " + nicRole.sg_ip_begin);
                }
                else
                {
                    reportObj.Error("sg_ip_begin fields to not match.");
                    reportObj.Error("Expected: " + this.sg_ip_begin);
                    reportObj.Error("Actual: " + nicRole.sg_ip_begin);
                    return false;
                }

                if (this.sg_ip_end == null) this.sg_ip_end = String.Empty;
                if (Object.Equals(this.sg_ip_end, nicRole.sg_ip_end))
                {
                    reportObj.Info("Verified sg_ip_end field matches. They are both: " + nicRole.sg_ip_end);
                }
                else
                {
                    reportObj.Error("sg_ip_end fields to not match.");
                    reportObj.Error("Expected: " + this.sg_ip_end);
                    reportObj.Error("Actual: " + nicRole.sg_ip_end);
                    return false;
                }


                if (Object.Equals(this.sg_port_begin, nicRole.sg_port_begin))
                {
                    reportObj.Info("Verified sg_port_begin field matches. They are both: " + nicRole.sg_port_begin);
                }
                else
                {
                    reportObj.Error("sg_port_begin fields to not match.");
                    reportObj.Error("Expected: " + this.sg_port_begin);
                    reportObj.Error("Actual: " + nicRole.sg_port_begin);
                    return false;
                }


                if (Object.Equals(this.sg_port_end, nicRole.sg_port_end))
                {
                    reportObj.Info("Verified sg_port_end field matches. They are both: " + nicRole.sg_port_end);
                }
                else
                {
                    reportObj.Error("sg_port_end fields to not match.");
                    reportObj.Error("Expected: " + this.sg_port_end);
                    reportObj.Error("Actual: " + nicRole.sg_port_end);
                    return false;
                }

                return true;
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append("SiteId: " + this.siteId.ToString());
                sb.Append(Environment.NewLine);
                sb.Append("environment: " + this.environment);
                sb.Append(Environment.NewLine);
                sb.Append("server: " + this.server);
                sb.Append(Environment.NewLine);
                sb.Append("nic_role: " + this.nic_role);
                sb.Append(Environment.NewLine);
                sb.Append("ip: " + this.ip);
                sb.Append(Environment.NewLine);
                sb.Append("ip_netmask: " + this.ip_netmask);
                sb.Append(Environment.NewLine);
                sb.Append("ip_default_gateway: " + this.ip_default_gateway);
                sb.Append(Environment.NewLine);
                sb.Append("ip_mac: " + this.ip_mac);
                sb.Append(Environment.NewLine);
                sb.Append("sg_ip_begin: " + this.sg_ip_begin);
                sb.Append(Environment.NewLine);
                sb.Append("sg_ip_end: " + this.sg_ip_end);
                sb.Append(Environment.NewLine);
                sb.Append("sg_port_begin: " + this.sg_port_begin);
                sb.Append(Environment.NewLine);
                sb.Append("sg_port_end: " + this.sg_port_end);
                sb.Append(Environment.NewLine);
                return sb.ToString();
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }


            public static bool CompareNics(Dictionary<string, NicRole> Actual, Dictionary<string, NicRole> Expected)
            {
                foreach (KeyValuePair<string, NicRole> nic in Expected)
                {
                    reportObj.Info(String.Empty);
                    reportObj.Info("Checking Network Interface with role: " + nic.Key);
                    if (!Actual.ContainsKey(nic.Key))
                    {
                        reportObj.Error("Expected nic role does not exist in npdb:");
                        reportObj.Error(nic.ToString());
                        return false;
                    }
                    if (!(nic.Value.Equals(Actual[nic.Key])))
                    {
                        reportObj.Error("Expected nic does not match Actual nic:");
                        reportObj.Error("Expected NIC: " + Environment.NewLine + nic.ToString());
                        reportObj.Error("Actual NIC: " + Environment.NewLine + Actual[nic.Key].ToString());
                        return false;
                    }
                    // if we are here, then the expect nic matches the actual nic.  Remote the actual NIC
                    // so we can make sure there are no 'extra' nics defined.
                    Actual.Remove(nic.Key);
                }

                // All nics match.  Now make sure there are no extras in the Actual nic list.
                if (Actual.Count > 0)
                {
                    reportObj.Error("There were extra nics found in npdb.  They are:");
                    foreach (KeyValuePair<String, NicRole> nic in Actual)
                    {
                        reportObj.Error(nic.ToString());
                        reportObj.Error(Environment.NewLine);
                    }
                    return false;
                }

                // if we are here, then all nics match, and there are no extra nics in npdb.

                return true;
            }



            private static IPAddress FindNetworkIPAddress(NetworkInterface n)
            {
                foreach (UnicastIPAddressInformation info in n.GetIPProperties().UnicastAddresses)
                {
                    if (info.Address.AddressFamily == AddressFamily.InterNetwork)
                    {
                        return info.Address;
                    }
                }

                return null;
            }

            public static IPAddress FindDatacenterIP()
            {
                Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                try
                {
                    s.Connect(Config.NpdbServer, 1433);

                    if (s.Connected)
                    {
                        IPAddress addr = ((IPEndPoint)(s.LocalEndPoint)).Address;
                        reportObj.Info("IPAddress used to connect to npdb: {0}\n", addr);

                        return addr;
                    }
                }
                catch (SocketException e)
                {
                    throw new ApplicationException("Unable to connect to npdb to determine datacenter nic, InnerException:\n" + e.ToString());
                }
                finally
                {
                    if (s.Connected)
                    {
                        s.Shutdown(SocketShutdown.Both);
                    }
                }
                throw new ApplicationException("Unable to connect to npdb to determine datacenter nic.");
            }

            private static void GetNetmaskAndGatewayForIP(NetworkInterface n, IPAddress ip, out IPAddress netmask, out IPAddress gateway)
            {
                gateway = n.GetIPProperties().GatewayAddresses.Count > 0 ? n.GetIPProperties().GatewayAddresses[0].Address : null;

                netmask = null;
                foreach (UnicastIPAddressInformation info in n.GetIPProperties().UnicastAddresses)
                {
                    if (ip.Equals(info.Address))
                    {
                        netmask = info.IPv4Mask;
                        break;
                    }
                }
            }

            public static Dictionary<string, NicRole> BuildExpectedNics(String ServerName, String args)
            {                
                Dictionary<string, NicRole> nicList = new Dictionary<string, NicRole>();

                ArgParser ap = new ArgParser(args);
                
                if (args.Contains("-addsg"))
                {
                    if (args.Contains("-xblob"))
                    {
                        if (ap.KeyExists("site"))
                            nicList = BuildExpectedNicsXblobSG(ServerName, Int32.Parse(ap.GetValue("site")));
                        else
                            nicList = BuildExpectedNicsXblobSG(ServerName, 1);
                    }
                    else
                    {
                        if (ap.GetValue("nic") == "middle_tier_sg")
                        {
                            if (ap.KeyExists("site"))
                            {
                                nicList = BuildExpectedNicsMiddleTierSG(ServerName, Int32.Parse(ap.GetValue("site")), ap.GetValue("nic"), ap.GetValue("ip"), ap.GetValue("netmask"), ap.GetValue("gateway"), ap.GetValue("sgipbegin"), ap.GetValue("sgipend"), ap.GetValue("sgportbegin"), ap.GetValue("sgportend"), ap.GetValue("mac"));
                            }
                            else
                            {
                                nicList = BuildExpectedNicsMiddleTierSG(ServerName, 1, ap.GetValue("nic"), ap.GetValue("ip"), ap.GetValue("netmask"), ap.GetValue("gateway"), ap.GetValue("sgipbegin"), ap.GetValue("sgipend"), ap.GetValue("sgportbegin"), ap.GetValue("sgportend"), ap.GetValue("mac"));
                            }
                        }
                        else
                        {
                            if (ap.KeyExists("site"))
                            {
                                nicList = BuildExpectedNicsNoXblobYesSG(ServerName, Int32.Parse(ap.GetValue("site")), ap.GetValue("nic"), ap.GetValue("ip"), ap.GetValue("netmask"), ap.GetValue("gateway"));
                            }
                            else
                            {
                                nicList = BuildExpectedNicsNoXblobYesSG(ServerName, 1, ap.GetValue("nic"), ap.GetValue("ip"), ap.GetValue("netmask"), ap.GetValue("gateway"));
                            }
                        }
                    }
                }
                else
                {
                    if (args.Contains(" -xblob"))
                    {
                        if (ap.KeyExists("site"))
                        {
                            nicList = BuildExpectedNicsXblob(ServerName, Int32.Parse(ap.GetValue("site")));                            
                        }
                        else
                        {
                            nicList = BuildExpectedNicsXblob(ServerName, 1);
                        }
                    }
                    else
                    {
                        if (ap.KeyExists("site"))
                        {
                            nicList = BuildExpectedNicsNoXblob(ServerName, Int32.Parse(ap.GetValue("site")));                            
                        }
                        else
                        {
                            nicList = BuildExpectedNicsNoXblob(ServerName, 1);
                        }
                    }

                }
                return nicList;
            }

            public static Dictionary<string, NicRole> BuildExpectedNicsMiddleTierSG(String ServerName, Int32 SiteId, String nicRole, String IP, String Netmask, String Gateway, String SGIPBegin, String SGIPEnd, String SGPortBegin, String SGPortEnd, String Mac)
            {
                Dictionary<string, NicRole> nicList = new Dictionary<string, NicRole>();
                NicRole newNic;
                if (String.IsNullOrEmpty(Mac))
                {
                    newNic = new NicRole(SiteId, "xblob", ServerName, nicRole, IP, Netmask, Gateway, LocalServerInfo.MAC, SGIPBegin, SGIPEnd, Int32.Parse(SGPortBegin), Int32.Parse(SGPortEnd));
                }
                else
                {
                    newNic = new NicRole(SiteId, "xblob", ServerName, nicRole, IP, Netmask, Gateway, Mac, SGIPBegin, SGIPEnd, Int32.Parse(SGPortBegin), Int32.Parse(SGPortEnd));
                }
                nicList.Add(nicRole, newNic);
                return nicList;
            }

            public static Dictionary<string, NicRole> BuildExpectedNicsNoXblobYesSG(String ServerName, Int32 SiteId, String nicRole, String IP, String Netmask, String Gateway)
            {
                Dictionary<string, NicRole> nicList = new Dictionary<string, NicRole>();
                NicRole newNic = new NicRole(SiteId, "xblob", ServerName, nicRole, IP, Netmask, Gateway, LocalServerInfo.MAC, null, null, 0, 0);
                nicList.Add(nicRole, newNic);
                return nicList;
            }

            public static Dictionary<string, NicRole> BuildExpectedNicsXblobSG(String ServerName, Int32 SiteId)
            {
                Dictionary<string, NicRole> nicList = new Dictionary<string, NicRole>();
                // for xblob, we can fail if there is more than one network interface.
                // might as well do it here.
                if (networks.Length > 1)
                    throw new ApplicationException("Attempting to build an expected xblob nic list, but this box has more than 2 NICs.");

                // add internet_tier and middle_tier for the only nic.
                IPAddress matchingIP = null;
                IPAddress npdbIP = FindDatacenterIP();
                IPAddress netmask;
                IPAddress gateway;

                foreach (UnicastIPAddressInformation ip in networks[0].GetIPProperties().UnicastAddresses)
                {
                    if (npdbIP.Equals(ip.Address))
                    {
                        matchingIP = ip.Address;
                    }
                }

                GetNetmaskAndGatewayForIP(networks[0], matchingIP, out netmask, out gateway);                

                NicRole middleNic = new NicRole(SiteId, "xblob", ServerName, "middle_tier_sg", matchingIP.ToString(), netmask.ToString(), gateway.ToString(), LocalServerInfo.MAC, matchingIP.ToString(), matchingIP.ToString(), 30000, 40000);
                NicRole internetNic = new NicRole(SiteId, "xblob", ServerName, "internet_tier_sg1", matchingIP.ToString(), netmask.ToString(), gateway.ToString(), LocalServerInfo.MAC, null, null, 0, 0);
                nicList.Add("middle_tier_sg", middleNic);
                nicList.Add("internet_tier_sg1", internetNic);
                return nicList;
            }

            public static Dictionary<string, NicRole> BuildExpectedNicsXblob(String ServerName, Int32 SiteId)
            {
                Dictionary<string, NicRole> nicList = new Dictionary<string, NicRole>();
                // for xblob, we can fail if there is more than one network interface.
                // might as well do it here.
                if (networks.Length > 1)
                    throw new ApplicationException("Attempting to build an expected xblob nic list, but this box has more than 2 NICs.");

                // add internet_tier and middle_tier for the only nic.
                IPAddress matchingIP = null;
                IPAddress npdbIP = FindDatacenterIP();
                IPAddress netmask;
                IPAddress gateway;

                foreach (UnicastIPAddressInformation ip in networks[0].GetIPProperties().UnicastAddresses)
                {
                    if (npdbIP.Equals(ip.Address))
                    {
                        matchingIP = ip.Address;
                    }
                }

                GetNetmaskAndGatewayForIP(networks[0], matchingIP, out netmask, out gateway);

                NicRole middleNic = new NicRole(SiteId, "xblob", ServerName, "middle_tier", matchingIP.ToString(), netmask.ToString(), gateway.ToString(), LocalServerInfo.MAC, null, null, 0, 0);
                NicRole internetNic = new NicRole(SiteId, "xblob", ServerName, "internet_tier", matchingIP.ToString(), netmask.ToString(), gateway.ToString(), LocalServerInfo.MAC, null, null, 0, 0);
                nicList.Add("middle_tier", middleNic);
                nicList.Add("internet_tier", internetNic);
                return nicList;
            }

            public static Dictionary<string, NicRole> BuildExpectedNicsNoXblob(String ServerName, Int32 SiteId)
            {
                Dictionary<string, NicRole> nicList = new Dictionary<string, NicRole>();
                IPAddress npdbIP = FindDatacenterIP();
                IPAddress netmask = null;
                IPAddress gateway = null;
                Boolean IsMiddleTier = false;

                foreach (NetworkInterface network in networks)
                {
                    IPAddress matchingIP = null;

                    foreach (UnicastIPAddressInformation ip in network.GetIPProperties().UnicastAddresses)
                    {
                        if (npdbIP.Equals(ip.Address))
                        {
                            IsMiddleTier = true;
                            matchingIP = ip.Address;
                        }
                    }

                    if (IsMiddleTier)
                    {
                        GetNetmaskAndGatewayForIP(network, matchingIP, out netmask, out gateway);

                        NicRole newNicRole = new NicRole(SiteId, "xblob", LocalServerInfo.ServerName, "middle_tier",
                            matchingIP.ToString(), netmask.ToString(), gateway.ToString(),
                            LocalServerInfo.MAC, null, null, 0, 0);
                        nicList.Add("middle_tier", newNicRole);
                    }
                    else
                    {
                        // Add the network interface as an internet tier.
                        NetworkInterface net = FindInternetAddress(networks, npdbIP);
                        if (net != null)
                        {
                            IPAddress intIP = FindNetworkIPAddress(net);
                            GetNetmaskAndGatewayForIP(net, intIP, out netmask, out gateway);
                            NicRole newNicRole = new NicRole(SiteId, "xblob", LocalServerInfo.ServerName, "middle_tier",
                            matchingIP.ToString(), netmask.ToString(), gateway.ToString(),
                            LocalServerInfo.MAC, null, null, 0, 0);
                            nicList.Add("internet_tier", newNicRole);
                        }
                    }
                }
                return nicList;
            }

            // Finds the internet address by virtue of it not being the IP returned in the datacenter query.
            private static NetworkInterface FindInternetAddress(NetworkInterface[] networks, IPAddress addr)
            {
                if (networks.Length > 2)
                {
                    throw new ArgumentException(String.Format("Unable to determine internet nic, {0} TCP/IP bound nics available", networks.Length - 1));
                }

                foreach (NetworkInterface network in networks)
                {
                    bool foundIP = false;
                    foreach (UnicastIPAddressInformation ip in network.GetIPProperties().UnicastAddresses)
                    {
                        if (foundIP = addr.Equals(ip.Address))
                        {
                            // If a match exists, then this is the wrong IP
                            break;
                        }
                    }

                    // The first IP that doesn't match the datacenter IP counts as the internet IP.
                    if (!foundIP)
                    {
                        return network;
                    }
                }

                return null;
            }
        }

        // class for controlling the host file.
        public class HostFile
        {
            const String HOSTFILELOCATION = @"c:\Windows\System32\drivers\etc\hosts";

            public static void DeleteHostFile(Boolean WithBackup)
            {
                if (WithBackup)
                    BackupHostFile();

                File.Delete(HOSTFILELOCATION);
            }

            public static void BackupHostFile()
            {
                if (File.Exists(HOSTFILELOCATION))
                {
                    File.Move(HOSTFILELOCATION, HOSTFILELOCATION + ".backup");
                }
                else
                {
                    throw new Exception("hosts file does not exist.");
                }
            }

            public static void RestoreHostFile()
            {
                if (File.Exists(HOSTFILELOCATION + ".backup"))
                {
                    File.Copy(HOSTFILELOCATION + ".backup", HOSTFILELOCATION);
                }
                else
                {
                    throw new Exception("Host file backup does not exist.");
                }
            }

            public static void DeleteNPDBFromHosts()
            {
                StringBuilder newFile = new StringBuilder();

                string[] file = File.ReadAllLines(HOSTFILELOCATION);

                foreach (string line in file)
                {
                    if (line.ToLower().Contains("npdb"))
                    {
                        continue;
                    }
                    newFile.Append(line);
                }
                File.WriteAllText(HOSTFILELOCATION, newFile.ToString());
            }

            public static void AddUODBToHosts(String ip)
            {
                StringBuilder newFile = new StringBuilder();
                Boolean replaced = false;

                string[] file = File.ReadAllLines(HOSTFILELOCATION);

                foreach (string line in file)
                {
                    if (line.ToLower().Contains("uodb"))
                    {
                        newFile.Append(ip + "      uodb");
                        newFile.Append(Environment.NewLine);
                        replaced = true;
                        continue;
                    }
                    newFile.Append(line);
                    newFile.Append(Environment.NewLine);
                }
                if (!replaced)
                {
                    newFile.Append(ip + "      uodb");
                    newFile.Append(Environment.NewLine);
                }
                File.WriteAllText(HOSTFILELOCATION, newFile.ToString());
            }

            public static void AddNPDBToHosts(String ip)
            {
                StringBuilder newFile = new StringBuilder();
                Boolean replaced = false;

                string[] file = File.ReadAllLines(HOSTFILELOCATION);

                foreach (string line in file)
                {
                    if (line.ToLower().Contains("npdb"))
                    {
                        newFile.Append(ip + "      npdb");
                        newFile.Append(Environment.NewLine);
                        replaced = true;
                        continue;
                    }
                    newFile.Append(line);
                    newFile.Append(Environment.NewLine);
                }
                if (!replaced)
                {
                    newFile.Append(ip + "      npdb");
                    newFile.Append(Environment.NewLine);
                }
                File.WriteAllText(HOSTFILELOCATION, newFile.ToString());
            }
        }

        // represents a row in the t_sites table in UODB
        public class Site
        {
            public Int32 SiteId;
            public string KerbServiceName;
            public string KerbDomainName;
            public string Description;
            public string IP;            
        }

        public class UODBAccess
        {
            // Create a single connection to be used by all connections;
            static SqlConnection cn;
            static Report reportObj = new Report(typeof(NPDBAccess).Name);

            static UODBAccess()
            {
                string cnString = "Data Source=uodb;Initial Catalog=uodb;Integrated Security=True";
                cn = new SqlConnection(cnString);
                cn.Open();
            }

            public static Site GetSitesFromUODB(Int32 SiteId)
            {
                // since siteId is PK, this will only return a single row.
                //String query = "SELECT i_site_id, vc_kerb_service_name, vc_kerb_domain_name, vc_description, vc_ip FROM t_sites WHERE i_site_id=" + SiteId.ToString() ;
                String query = "SELECT * FROM t_sites WHERE i_site_id=" + SiteId.ToString();
                SqlCommand cmd = new SqlCommand(query, cn);
                SqlDataReader dr = cmd.ExecuteReader();
                dr.Read();
                Site newSite = new Site();
                newSite.SiteId = (Int32) dr["i_site_id"];
                newSite.KerbServiceName = (string)dr["vc_kerb_service_name"];
                newSite.KerbDomainName = (string)dr["vc_kerb_domain_name"];
                newSite.Description = (string)dr["vc_description"];
                newSite.IP = (string)dr["vc_ip"];
                return newSite;
            }

        }


        public class NPDBAccess
        {
            // Create a single connection to be used by all connections;
            static SqlConnection cn;
            static Report reportObj = new Report(typeof(NPDBAccess).Name);

            static NPDBAccess()
            {
                string cnString = Config.NpdbConnectionString;
                cn = new SqlConnection(cnString);
                cn.Open();
            }


            public static Boolean IsServerRegistered(String ServerName)
            {
                String query = "SELECT 1 FROM t_servers WHERE vc_server='" + ServerName + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                Boolean found = (Boolean)cmd.ExecuteScalar();
                return found;
            }


            public static Dictionary<string, NicRole> GetNicsFromServername(String ServerName)
            {
                String query = "SELECT s.i_site_id, n.* FROM t_server_nics n, t_servers s WHERE n.vc_server=s.vc_server AND n.vc_server='" + ServerName + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                SqlDataReader dr = cmd.ExecuteReader();

                Dictionary<string, NicRole> nics = new Dictionary<string, NicRole>();

                try
                {
                    while (dr.Read())
                    {
                        Int32 SiteID = (Int32)dr["i_site_id"];
                        string Env = (string)dr["vc_environment"];
                        string Server = (string)dr["vc_server"];
                        string NicRole = (string)dr["vc_nic_role"];
                        string IP = (string)dr["vc_ip"];
                        string IPNetmask = (string)dr["vc_ip_netmask"];
                        string IPDefaultGateway = (string)dr["vc_ip_default_gateway"];
                        string IPMac = (string)dr["vc_mac"];

                        // the last 4 values might be null.  handle it.
                        string SGIPBegin = String.Empty;
                        string SGIPEnd = String.Empty;
                        Int32 SGPortBegin = 0;
                        Int32 SGPortEnd = 0;


                        if (!(dr["vc_sg_ip_begin"] is DBNull))
                        {
                            SGIPBegin = (string)dr["vc_sg_ip_begin"];
                        }

                        if (!(dr["vc_sg_ip_end"] is DBNull))
                        {
                            SGIPEnd = (string)dr["vc_sg_ip_end"];
                        }

                        if (!(dr["i_sg_port_begin"] is DBNull))
                        {
                            SGPortBegin = (Int32)dr["i_sg_port_begin"];
                        }

                        if (!(dr["i_sg_port_end"] is DBNull))
                        {
                            SGPortEnd = (Int32)dr["i_sg_port_end"];
                        }

                        NicRole nic = new NicRole(SiteID, Env, Server, NicRole, IP, IPNetmask, IPDefaultGateway, IPMac, SGIPBegin, SGIPEnd, SGPortBegin, SGPortEnd);
                        nics.Add(NicRole, nic);
                    }
                }
                catch
                {
                    throw;
                }
                finally
                {
                    // always close the data reader.
                    dr.Close();
                }



                
                return nics;
            }

            // Deletes a row from t_site_virtual_interface_ips
            public static void DeleteSVI(string Environment, string VirtualInterface)
            {
                String query = "DELETE FROM t_site_virtual_interface_ips WHERE vc_environment='" + Environment + "' " +
                    "AND vc_virtual_interface='" + VirtualInterface + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                cmd.ExecuteNonQuery();
            }

            // Does this row exist in the t_site_virtual_interface_ips table?
            public static Boolean DoesSVIExist(string Environment, Int32 SiteId, string VirtualInterface, string IP)
            {
                String query = "SELECT 1 FROM t_site_virtual_interface_ips WHERE vc_environment='" + Environment + "' " +
                    "AND i_site_id=" + SiteId + " AND vc_virtual_interface='" + VirtualInterface + "' AND vc_ip='" + IP + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                Boolean found = (Boolean)cmd.ExecuteScalar();
                return found;
            }

            // Get all rows from the t_site_virtual_interface_ips that contains the given IP address.
            public static List<SiteVIIP> GetSiteVIIPsFromIPAddress(string IPAddr)
            {
                List<SiteVIIP> sviList = new List<SiteVIIP>();
                String query = "SELECT * FROM t_site_virtual_interface_ips where vc_ip='" + IPAddr + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                SqlDataReader dr = cmd.ExecuteReader();
                while (dr.Read())
                {
                    SiteVIIP newSVI = new SiteVIIP((string)dr["vc_environment"], (Int32)dr["i_site_id"], (string)dr["vc_virtual_interface"], (string)dr["vc_ip"]);
                    sviList.Add(newSVI);
                }

                dr.Close();
                return sviList;
            }

            

            public static Boolean IsVInterfaceRegistered(String vInterface)
            {
                String query = "SELECT 1 FROM t_virtual_interfaces WHERE vc_virtual_interface='" + vInterface + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                Boolean found = (Boolean)cmd.ExecuteScalar();
                return found;
            }

            public static void DeleteServer(String Server)
            {
                String query = "delete from t_servers where vc_server='" + Server + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                cmd.ExecuteNonQuery();
            }

            public static void DeleteServerNIC(String Server)
            {
                String query = "delete from t_server_nics where vc_server='" + Server + "'";
                SqlCommand cmd = new SqlCommand(query, cn);
                cmd.ExecuteNonQuery();
            }
        }

        // represents a row in the t_site_virtual_interface_ips table
        public class SiteVIIP
        {
            private string environment;
            private Int32 siteId;
            private string virtualInterface;
            private string ip;
            public SiteVIIP(string Environment, Int32 SiteId, string VInterface, string IPAddr)
            {
                this.environment = Environment;
                this.siteId = SiteId;
                this.virtualInterface = VInterface;
                this.ip = IPAddr;
            }

            public string Environment
            {
                get { return this.environment; }
                set { this.environment = value; }
            }

            public Int32 SiteID
            {
                get { return this.siteId; }
                set { this.siteId = value; }
            }

            public string VirtualInterface
            {
                get { return this.virtualInterface; }
                set { this.virtualInterface = value; }
            }

            public string IP
            {
                get { return this.ip; }
                set { this.ip = value; }
            }
        }

    }

    public class ArgParser
    {
        private Dictionary<string, string> args;

        public ArgParser(string Arguments)
        {
            args = new Dictionary<string, string>();
            string[] splitArgs = Arguments.Split(' ');
            foreach (string onearg in splitArgs)
            {
                String cleanArg = String.Empty;
                if (onearg.StartsWith("-"))
                    cleanArg = onearg.Substring(1);

                string[] splitArg = cleanArg.Split(':');
                if (splitArg.Length == 1)
                {
                    args.Add(splitArg[0], String.Empty);
                }
                else
                {
                    args.Add(splitArg[0], splitArg[1]);
                }
            }
        }

        public string GetValue(string key)
        {
            if (args.ContainsKey(key))
            {
                return args[key];
            }
            return null;
        }

        public Boolean KeyExists(string key)
        {
            if (args.ContainsKey(key))
                return true;
            else
                return false;
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\docs\STFHelp\Samples\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\docs\STFHelp\Samples\Messaging.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using live.client;
using live.common;
using live.lfm;
using live.server;
using live.protocol;
using System.Threading;
using live.lfm.xbox360Internal;
using live.lfm.xbox360Internal.HUD;
using live.protocol.Presence;

namespace BVT
{
    [TestGroup]
    public class MessagingSample : TestNode
    {
        [TestCase]
        public class SendMessage : TestNode
        {
            private XblUser _User = null;
            private XblUser _SendTo = null;
            private Xbox360 _XBox = null;

            // create the users needed for the test and set any state required for the test to run
            public override void PreRun()
            {
                _XBox = new Xbox360();

                // create the user using a fake passport
                XblUserSettings userSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _User = _XBox.SignUp.CreateUser(userSettings);
                _XBox.Client.UserLoggingOff(_User);

                // create the user using a fake passport
                XblUserSettings sendToUserSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _SendTo = _XBox.SignUp.CreateUser(sendToUserSettings);
                _XBox.Client.UserLoggingOff(_SendTo);

                _XBox.Live.Logon(_User);
                _XBox.Live.Logon(_SendTo);
            }

            // Run the test
            public override void Run()
            {
                _XBox.Live.Messages.SendPersonalMessage(_User, _SendTo, "Personal Text Message: This Message should be readable anywhere and not restricted by title id");

                PNState sendToState = Presence.GetPresence(_SendTo);
                UserMsgFolder userMsgFolder = new UserMsgFolder(sendToState);
                ushort numberOfMessages = userMsgFolder.Load2();

                foreach (UserMessage msg in userMsgFolder.Inbox)
                {
                    uint hr = msg.GetDetails(sendToState);
                    if (!HResult.Succeeded(hr))
                    {
                        throw new Exception("Failed to load message details with HR=0x" + hr.ToString("x"));
                    }
                    if (msg.SenderID != _User.Puid)
                    {
                        throw new Exception("Message was recieved from an incorrect user");
                    }
                }

                return TEST_RESULTS.PASSED;
            }

            // clean up the users that were created
            public override void PostRun()
            {
                _XBox.Live.Logout(_User);
                _XBox.Live.Logout(_SendTo);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\docs\STFHelp\Samples\UACS.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using live.client;
using live.common;
using live.lfm;
using live.server;
using live.protocol;
using System.Threading;

namespace BVT
{
    [TestGroup]
    public class UACSSample : TestNode
    {
        [TestCase]
        public class AdultSilverFakePassport : TestNode
        {
            public override void Run()
            {
                Xbox360 XBox = new Xbox360();
                XblUserSettings settings = new XblUserSettings(XblUserTier.Silver, PassportType.Fake);
                XblUser user = XBox.SignUp.CreateUser(settings);
                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class AdultGoldFakePassport : TestNode
        {
            public override void Run()
            {
                Xbox360 XBox = new Xbox360();
                XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                XblUser user = XBox.SignUp.CreateUser(settings);
                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class AdultGoldExistingPassport : TestNode
        {
            public override void Run()
            {
                try
                {
                    Xbox360 XBox = new Xbox360();
                    XblUserSettings realSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Existing);
                    realSettings.UserPassportInfo.MemberName = "DocSampleTests" + Global.PassportMemberDomain;
                    realSettings.UserPassportInfo.Password = "supersecret";

                    // Specify a gamertag as follows
                    //realSettings.PersonalInfo.Gamertag = "AdultGold";
                    XblUser user = XBox.SignUp.CreateUser(realSettings);
                }
                catch (Exception)
                {
                    // ignore the passport already linked error for the purpose of the example
                    // however test writers should be aware that this condition does exist

                }
                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class AdultGoldNewPassport : TestNode
        {
            public override void Run()
            {
                Xbox360 XBox = new Xbox360();
                XblUserSettings realSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
                realSettings.UserPassportInfo.MemberName = "DocSampleTests" + Guid.NewGuid().ToString() + "" + Global.PassportMemberDomain;
                realSettings.UserPassportInfo.Password = "supersecret";

                // Specify a gamertag as follows
                //realSettings.PersonalInfo.Gamertag = "AdultGold";
                XblUser user = XBox.SignUp.CreateUser(realSettings);
                return TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\docs\STFHelp\Samples\Presence.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using live.client;
using live.common;
using live.lfm;
using live.server;
using live.protocol;
using System.Threading;
using live.lfm.xbox360Internal;
using live.lfm.xbox360Internal.HUD;
using live.protocol.Presence;

namespace BVT
{
    [TestGroup]
    public class PresenceSample : TestNode
    {
        [TestCase]
        public class Alive : TestNode
        {
            private XblUser _User = null;
            private Xbox360 _XBox = null;

            // create the users needed for the test and set any state required for the test to run
            public override void PreRun()
            {
                _XBox = new Xbox360();

                // create the user using a fake passport
                XblUserSettings userSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _User = _XBox.SignUp.CreateUser(userSettings);
                _XBox.Client.UserLoggingOff(_User);
            }

            // Run the test
            public override void Run()
            {
                // Sign the user into Live
                _XBox.Live.Logon(_User);
                return TEST_RESULTS.PASSED;
            }

            // clean up the users that were created
            public override void PostRun()
            {
                _XBox.Live.Logout(_User);
            }
        }


        [TestCase]
        public class MakeFriend : TestNode
        {
            private XblUser _User = null;
            private XblUser _Friend = null;
            private Xbox360 _XBox = null;

            // create the users needed for the test and set any state required for the test to run
            public override void PreRun()
            {
                _XBox = new Xbox360();

                // create the user using a fake passport
                XblUserSettings userSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _User = _XBox.SignUp.CreateUser(userSettings);
                _XBox.Client.UserLoggingOff(_User);

                // create the friend using a fake passport
                XblUserSettings friendSettings = new XblUserSettings(XblUserTier.Silver, PassportType.Fake);
                _Friend = _XBox.SignUp.CreateUser(friendSettings);
                _XBox.Client.UserLoggingOff(_Friend);

                _XBox.Live.Logon(_User);
                _XBox.Live.Logon(_Friend);
            }

            // Run the test
            public override void Run()
            {
                // _User sends a friend request to _Friend
                _XBox.Live.Friends.AddFriend(_User, _Friend);
                //_Friend Waits for the request to be received from _User
                _XBox.Live.Friends.WaitForFriendStatusRequested(_Friend, _User);
                // _Friend accepts _User friend request
                _XBox.Live.Friends.AcceptFriendRequest(_Friend, _User);
                // _User Waits for the status of the friend to be fully accepted.
                _XBox.Live.Friends.WaitForFriendStatusOK(_User, _Friend);
                // _User and _Friend are now fully friends
                return TEST_RESULTS.PASSED;
            }

            // clean up the users that were created
            public override void PostRun()
            {
                _XBox.Live.Logout(_User);
                _XBox.Live.Logout(_Friend);
            }
        }

        [TestCase]
        public class SetState : TestNode
        {
            public class Pong
            {
                public const uint TitleId = 0xFFFF400A;

                /// Context IDs used for creating contexts
                /// see named enums below for context values.
                public enum Context : uint
                {
                    GameMode = 0x0000800B,
                    GameSize = 1,
                    GameSpeed = 20,
                    WinScore = 30
                }
                public enum GameMode : uint
                {
                    SinglePlayer = 0,
                    MultiPlayer = 1
                }
                public enum GameSize : uint
                {
                    Small = 0,
                    Medium = 1,
                    Large = 2
                }
                public enum GameSpeed : uint
                {
                    Slow = 0,
                    Fast = 1
                }
                public enum WinScore : uint
                {
                    Points15 = 0,
                    Points21 = 1
                }

                // Property type for use with GI property blobs
                public const uint PropertyWins = GITypes.XONLINE_STAT_LONG | 0x22;
                public const uint PropertyLosses = GITypes.XONLINE_STAT_LONG | 0x33;
                public const uint PropertyPoints = GITypes.XONLINE_STAT_LONG | 0x44;
            }

            private XblUser _User = null;
            private XblUser _Watcher = null;
            private Xbox360 _XBox = null;

            // create the users needed for the test and set any state required for the test to run
            public override void PreRun()
            {
                _XBox = new Xbox360();

                // create the user using a fake passport
                XblUserSettings userSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _User = _XBox.SignUp.CreateUser(userSettings);
                _XBox.Client.UserLoggingOff(_User);

                // create the watcher using a fake passport
                XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _Watcher = _XBox.SignUp.CreateUser(settings);
                _XBox.Client.UserLoggingOff(_Watcher);

                // Logon the Users
                _XBox.Live.Logon(_User);
                _XBox.Live.Logon(_Watcher);

                // Have the watcher Peer Subscribe to the User to validate the state
                Presence.PeerSubscribeEx(_XBox.Client, _Watcher, new XblUser[] { _User });
                Notification.WaitForPeerPresence(_XBox.Client, _Watcher, new XblUser[] { _User });
            }

            // Run the test
            public override void Run()
            {
                // Change the Title on the XBox to Pong
                _XBox.Live.Play(Pong.TitleId);
                GIBlob gi = new GIBlob();
                gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.SinglePlayer);
                gi.AddContext((uint)Pong.Context.GameSize, (uint)Pong.GameSize.Medium);
                gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Fast);
                // Set the rich presence data for this user
                Presence.SetTitleData(_XBox.Client, _User, gi.GetBytes());

                // Validate that the state of the user changed and is correct
                Notification.WaitForPeerPresence(_XBox.Client, _Watcher, new XblUser[] { _User });
                PNState watcherState = Presence.GetPresence(_Watcher);
                PNState.PeerInfo userInfo = watcherState.GetPeerInfo(_User.Puid);
                live.protocol.Presence.Presence2Item presence2Item = userInfo.RichPresence;
                if (presence2Item.State != (XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON))
                {
                    throw new Exception("User State Incorrect");
                }
                else if (presence2Item.RichPresence != "Single Player: Medium paddle, Fast ball")
                {
                    throw new Exception("Rich Presence not returned correctly.  Check if the correct XLast is propped.");
                }
                return TEST_RESULTS.PASSED;
            }

            // clean up the users that were created
            public override void PostRun()
            {
                _XBox.Live.Logout(_User);
                _XBox.Live.Logout(_Watcher);
            }
        }


        [TestCase]
        public class AddAffiliate : TestNode
        {
            private XblUser _User = null;
            private XblUser _Affiliate = null;
            private Xbox360 _XBox = null;

            // create the users needed for the test and set any state required for the test to run
            public override void PreRun()
            {
                _XBox = new Xbox360();

                // create the user using a fake passport
                XblUserSettings userSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _User = _XBox.SignUp.CreateUser(userSettings);
                _XBox.Client.UserLoggingOff(_User);

                // create the friend using a fake passport
                XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Fake);
                _Affiliate = _XBox.SignUp.CreateUser(settings);
                _XBox.Client.UserLoggingOff(_Affiliate);

                _XBox.Live.Logon(_User);
                _XBox.Live.Logon(_Affiliate);
            }

            // Run the test
            public override void Run()
            {
                // Add Recent Player
                Presence.AddAffiliate(_XBox.Client, _User, _Affiliate, AffiliateFlags.CompletedGame);

                // Query Affiliates to be sure it was added successfully
                AffiliateState affiliates = Presence.QueryAffiliates(_XBox.Client, _User);
                if (affiliates.GetInstanceCount(0) != 2 || affiliates._Encountered[_Affiliate.Puid] == null || affiliates._CompletedGame[_Affiliate.Puid] == null)
                {
                    throw new Exception("Did not receive the expected affilates");
                }

                return TEST_RESULTS.PASSED;
            }

            // clean up the users that were created
            public override void PostRun()
            {
                _XBox.Live.Logout(_User);
                _XBox.Live.Logout(_Affiliate);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dspfilevalidatortesting_none_12.4.56.0_none_87d4e49e9fcc27aa
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dspfilevalidatortesting
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.manifest
XP_MANIFEST_PATH=manifests\msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.cat
XP_CATALOG_PATH=manifests\msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.cat
XP_PAYLOAD_PATH=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dspfilevalidatortesting,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dspfilevalidatortesting_none_12.4.56.0_none_87d4e49e9fcc27aa
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dspfilevalidatortesting
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.manifest
XP_MANIFEST_PATH=manifests\msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.cat
XP_CATALOG_PATH=manifests\msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede.cat
XP_PAYLOAD_PATH=msil_dspfilevalidatortesting_no-public-key_12.4.56.0_x-ww_783a2ede
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dspfilevalidatortesting,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\ProcessOutput.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="ProcessOutput.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to execute a process and expose its output and return code
// </summary>
//-----------------------------------------------------------------------
using System.Diagnostics;
using System.IO;
using System.Text;

namespace DspFileValidatorTesting
{
    /// <summary>
    /// Provides access to run an executable and get its exit code and standard output
    /// </summary>
    public class ProcessOutput
    {
        private string exePath;
        private string exeName;
        private string arguments;
        private string workingDirectory;
        private StringBuilder stringBuilder;
        private string output;
        private int exitCode;

        /// <summary>
        /// Initializes a new instance of the ProcessOutput class
        /// </summary>
        /// <param name="config">The instance of the Config class exposing all of the configuration</param>
        /// <param name="exeName">The specified executable to run</param>
        /// <param name="arguments">The specified arguments to pass to the process</param>
        /// <param name="workingDirectory">The specified working directory for the process</param>
        public ProcessOutput(string exePath, string exeName, string arguments, string workingDirectory)
        {
            this.exePath = exePath;
            this.exeName = exeName;
            this.arguments = arguments;
            this.workingDirectory = workingDirectory;
        }

        /// <summary>
        /// Gets the exit code of the process
        /// </summary>
        public int ExitCode
        {
            get { return this.exitCode; }
        }

        /// <summary>
        /// Gets the standard output of the process
        /// </summary>
        public string Output
        {
            get { return this.output; }
        }

        /// <summary>
        /// Run the specified executable with the specified arguments and capture the output and exit code
        /// </summary>
        public void Run()
        {
            ProcessStartInfo processStartInfo = new ProcessStartInfo(Path.Combine(this.exePath, this.exeName), this.arguments);
            processStartInfo.CreateNoWindow = true;
            processStartInfo.ErrorDialog = false;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = this.workingDirectory;

            Process process = new Process();
            process.StartInfo = processStartInfo;

            this.stringBuilder = new StringBuilder();
            process.OutputDataReceived += new DataReceivedEventHandler(this.OutputDataReceivedHandler);

            process.Start();
            process.BeginOutputReadLine();
            process.WaitForExit();

            this.exitCode = process.ExitCode;
            this.output = this.stringBuilder.ToString();
        }

        /// <summary>
        /// Handles the OutputDataReceived event of the Process
        /// </summary>
        /// <param name="sender">The source of the event</param>
        /// <param name="e">A DataReceivedEventArgs that contains the event data</param>
        private void OutputDataReceivedHandler(object sender, DataReceivedEventArgs e)
        {
            if (null != e.Data)
            {
                Trace.WriteLine(e.Data);
                this.stringBuilder.AppendLine(e.Data);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DspFileValidator\DspFileValidatorTesting.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="main.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   LiveTools testing - main entry point
// </summary>
//-----------------------------------------------------------------------
using System;
using System.Collections.Specialized;
using System.IO;

using NUnit.Framework;

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace DspFileValidatorTesting
{
    [TestFixture]
    public class DspFileValidatorTest
    {
        private static String SDRoot = "c:/corext/xonline_r2";
        private static String PathToDspFileValidatorExe = "{0}/drop/debug/tools/DspFileValidator";
        private static String ExpandedPathToDspFileValidator;
        private static String PathToDspFiles = "{0}/private/test/DspFileValidator";
        private static String ExpandedPathToDspFiles;
        private static String DspFileValidatorExe = "DspFileValidator.exe";

        public DspFileValidatorTest()
        {
            ExpandedPathToDspFileValidator = String.Format(PathToDspFileValidatorExe, SDRoot);
            ExpandedPathToDspFiles = String.Format(PathToDspFiles, SDRoot);
        }

        [TestFixtureSetUp]
        public void ClassInitialize()
        {

        }

        [TestFixtureTearDown]
        public void ClassCleanup()
        {
        }

        [SetUp]
        public void TestInitialize()
        {
        }

        [TearDown]
        public void TestCleanup()
        {
        }

        [Test]
        public void Invalid_NoParameters()
        {
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, "", ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Invalid_MissingXsdParameter()
        {
            String xmlFile = ExpandedPathToDspFiles + "/StoresListGood.xml";
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, String.Format(" -f={0}", xmlFile), ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Invalid_MissingXmlParameter()
        {
            String xsdFile = ExpandedPathToDspFiles + "/StoresListGood.xsd";
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, String.Format(" -x={0}", xsdFile), ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Valid()
        {
            String xmlFile = ExpandedPathToDspFiles + "/StoresListGood.xml";
            String xsdFile = ExpandedPathToDspFiles + "/StoresListGood.xsd";
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, String.Format( " -f={0} -x={1}", xmlFile, xsdFile ), ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(0, po.ExitCode);
        }

        [Test]
        public void Invalid_NonExistantXmlFile()
        {
            String xmlFile = ExpandedPathToDspFiles + "/NonExistant.xml";
            String xsdFile = ExpandedPathToDspFiles + "/StoresListGood.xsd";
            String args = String.Format(" -f={0} -x={1}", xmlFile, xsdFile);
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, args, ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Invalid_NonExistantXsdFile()
        {
            String xmlFile = ExpandedPathToDspFiles + "/StoresListGood.xml";
            String xsdFile = ExpandedPathToDspFiles + "/NonExistant.xsd";
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, String.Format(" -f={0} -x={1}", xmlFile, xsdFile), ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Invalid_UnicodeXmlFile()
        {
            String xmlFile = ExpandedPathToDspFiles + "/StoresListUnicode.xml";
            String xsdFile = ExpandedPathToDspFiles + "/StoresListGood.xsd";
            String args = String.Format(" -f={0} -x={1}", xmlFile, xsdFile);
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, args, ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Invalid_FileToLarge()
        {
            String xmlFile = ExpandedPathToDspFiles + "/StoresListLarge.xml";
            String xsdFile = ExpandedPathToDspFiles + "/StoresListGood.xsd";
            String args = String.Format(" -f={0} -x={1}", xmlFile, xsdFile);
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, args, ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }

        [Test]
        public void Invalid_InvalidXml()
        {
            String xmlFile = ExpandedPathToDspFiles + "/StoresListInvalidXml.xml";
            String xsdFile = ExpandedPathToDspFiles + "/StoresListGood.xsd";
            String args = String.Format(" -f={0} -x={1}", xmlFile, xsdFile);
            ProcessOutput po = new ProcessOutput(ExpandedPathToDspFileValidator, DspFileValidatorExe, args, ".");
            po.Run();
            Console.WriteLine(po.Output);
            Assert.AreEqual(1, po.ExitCode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\experts\xlexpert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by xlexpert.rc
//
#define IDD_XLEXPERT_CONFIG_DIALOG      110
#define IDM_HELP                        111
#define IDS_EXPERTNAME                  200
#define IDS_COMMENT                     201
#define IDS_AUTHOR                      202
#define IDS_EVENTNAME                   203
#define IDS_SUMMARYEVENTNAME            203
#define IDS_DESCRIPTION                 204
#define IDS_MACHINE                     205
#define IDS_COLZERO                     206
#define IDS_COLONE                      207
#define IDS_JUSTIFICATION_FORMAT        208
#define IDS_INITIALIZING                209
#define IDS_INTERVALTRAFFICEVENTNAME    210
#define IDS_XSPFRAMECOUNT               301
#define IDS_XBOXCOUNT                   302
#define IDS_XBOXIPADDR                  303
#define IDS_SGIPADDR                    304
#define IDS_XBOXNUMBER                  305
#define IDS_SGNUMBER                    306
#define IDS_INQOSREQ                    307
#define IDS_OUTQOSREQ                   308
#define IDS_INQOSREP                    309
#define IDS_OUTQOSREP                   310
#define IDS_INENCRYPT                   311
#define IDS_OUTENCRYPT                  312
#define IDS_INVOICE                     313
#define IDS_OUTVOICE                    314
#define IDS_INENCRYPTONEAVG             315
#define IDS_INENCRYPTFIVEAVG            316
#define IDS_INENCRYPTTENAVG             317
#define IDS_OUTENCRYPTONEAVG            318
#define IDS_OUTENCRYPTFIVEAVG           319
#define IDS_OUTENCRYPTTENAVG            320
#define IDS_INVOICEONEAVG               321
#define IDS_INVOICEFIVEAVG              322
#define IDS_INVOICETENAVG               323
#define IDS_OUTVOICEONEAVG              324
#define IDS_OUTVOICEFIVEAVG             325
#define IDS_OUTVOICETENAVG              326
#define IDS_INTOTALONEAVG               327
#define IDS_INTOTALFIVEAVG              328
#define IDS_INTOTALTENAVG               329
#define IDS_OUTTOTALONEAVG              330
#define IDS_OUTTOTALFIVEAVG             331
#define IDS_OUTTOTALTENAVG              332
#define IDS_INTOTAL                     333
#define IDS_OUTTOTAL                    334
#define IDS_INTERVAL                    335
#define IDS_BITSPERSECOND               400
#define IDS_BYTESPERSECOND              401
#define IDS_CANTALLOCMEM                501
#define IDS_CANTCREATEFILTER            502
#define IDS_CANTADDTOFILTER             503
#define IDS_CANTSUBMITEVENT             504
#define IDS_XSPPARSERNOTPRESENT         505
#define IDS_KERBEROSPARSERNOTPRESENT    506
#define IDC_ENCRYPT                     1001
#define IDC_MOVINGAVERAGEENCRYPT        1001
#define IDC_TOTAL                       1002
#define IDC_MOVINGAVERAGETOTAL          1002
#define IDC_VOICE                       1003
#define IDC_MOVINGAVERAGEVOICE          1003
#define IDC_1SECAVG                     1005
#define IDC_5SECAVG                     1006
#define IDC_10SECAVG                    1007
#define IDC_CUMULATIVEENCRYPT           1007
#define IDC_DATATYPES                   1008
#define IDC_MOVINGAVERAGETYPES          1008
#define IDC_MOVINGAVG                   1009
#define IDC_CUMULATIVEVOICE             1009
#define IDC_QOS                         1010
#define IDC_INTERVALSTATSENCRYPT        1010
#define IDC_CUMULATIVE                  1011
#define IDC_INTERVALSTATSVOICE          1011
#define IDC_INTERVALGEN                 1012
#define IDC_GETINTERVALSTATS            1012
#define IDC_HEARTBEATS                  1013
#define IDC_SECONDS                     1014
#define IDC_INTERVALSIZEVALUE           1014
#define IDC_CUMULATIVETOTAL             1015
#define IDC_XBOXADDRESS                 1016
#define IDC_GETMOVINGAVERAGE            1017
#define IDC_MOVINGAVERAGESIZEVALUE      1018
#define IDC_DATATYPES2                  1019
#define IDC_GETCUMULATIVE               1020
#define IDC_DATATYPES3                  1021
#define IDC_CUMULATIVETOTAL2            1022
#define IDC_INTERVALSTATSTOTAL          1022
#define IDC_DATATYPES4                  1023
#define IDC_BYTESORBITS                 1024

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\experts\xlexpert\xlexpert.h ===
//============================================================================
//  MODULE: XLEXPERT.h
//
//  Description:
//
//  Xbox Live expert module
//
//  Modification History:
//
//  Your Name Here      01/01/70    Created
//============================================================================

#ifndef _XLEXPERT_H_
#define _XLEXPERT_H_

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <netmon.h>
#include <winsockx.h>
#include <xonlinep.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <map>
#include <set>

#pragma warning(disable:4200)

#define DLLEXPORT __declspec( dllexport )

//////////////////////////////////////////////////////////////////////////////
// Global Variables
extern HINSTANCE g_hInstance;
extern char g_StatusString[];

//////////////////////////////////////////////////////////////////////////////
// Data Structures

//  XLEXPERTCONFIG
//  This data is used by the XLExpert's config dialog to gather parameters
//  for what sort of statistics the expert should gather from the capture data
//  This data is filled in by the Configure function and used by the Run function
typedef struct _XLEXPERTCONFIG
{
    DWORD RawConfigLength;   // Overlay of structure

	// Moving average options from config dialog
	BOOL  fGetMovingAverage;
	DWORD dwMovingAverageSizeValue;
	BOOL  fMovingAverageEncrypt;
	BOOL  fMovingAverageVoice;
	BOOL  fMovingAverageTotal;

	// Cumulative options from config dialog
	BOOL  fGetCumulative;
	BOOL  fCumulativeEncrypt;
	BOOL  fCumulativeVoice;
	BOOL  fCumulativeTotal;

	// Interval stats options from config dialog
	BOOL  fGetIntervalStats;
	BOOL  fIntervalStatsEncrypt;
	BOOL  fIntervalStatsVoice;
	BOOL  fIntervalStatsTotal;
	BOOL  dwIntervalSizeValue;
	DWORD dwXboxAddress;

	// Bits vs. bytes per second option from config dialog
	BOOL  fBitsPerSecond;

} XLEXPERTCONFIG, *PXLEXPERTCONFIG;

// The Xbox Live expert uses a number of STL maps to calculate various types of data
// There are basically two modes of operation (both can be calculated concurrently)

// MODE ONE:  General statistics on all Xboxes
// The first mode of operation generates overall statistics on the data observed
// from all Xboxes in the capture.  This mode caculates the moving average of the
// amount of data sent and received from all Xbox source in the capture and finds
// the maximum average over time.

// To do this, two STL maps (one nested inside the other) are used..

// MODE ONE: MAP ONE
// The outermost map links an Xbox IP address to all traffic data for that address.
// This map is called an NMADDRESSMAP

// MODE ONE: MAP TWO
// Inside the traffic data in the NMADDRESMAP, there is another map that links a given
// time stamp with all the incoming and outgoing data that was observed during that
// time period.
// This map is called an NMADDRESSMAP

using namespace std;

// This structure is used so that we can keep a single map
// going from time stamps to all kinds of sent and received
// data for a particular address.  This structure is also
// used by the sum functions to return sum results
typedef struct _DATARECORDEDFORTIMESTAMP
{
	void ClearValues()
	{
		dwIncomingEncrypt = 0;
		dwOutgoingEncrypt = 0;
		dwIncomingVoice = 0;
		dwOutgoingVoice = 0;
		dwIncomingTotal = 0;
		dwOutgoingTotal = 0;
	}

	_DATARECORDEDFORTIMESTAMP()
	{
		ClearValues();
	}

	// Define summation operator
	struct _DATARECORDEDFORTIMESTAMP &operator+=( struct _DATARECORDEDFORTIMESTAMP & TrafficDataRHS)
	{
		dwIncomingEncrypt += TrafficDataRHS.dwIncomingEncrypt;
		dwOutgoingEncrypt += TrafficDataRHS.dwOutgoingEncrypt;
		dwIncomingVoice += TrafficDataRHS.dwIncomingVoice;
		dwOutgoingVoice += TrafficDataRHS.dwOutgoingVoice;
		dwIncomingTotal += TrafficDataRHS.dwIncomingTotal;
		dwOutgoingTotal += TrafficDataRHS.dwOutgoingTotal;

		return *this;
	};

	// Define summation operator
	struct _DATARECORDEDFORTIMESTAMP &operator=( struct _DATARECORDEDFORTIMESTAMP & TrafficDataRHS)
	{
		dwIncomingEncrypt = TrafficDataRHS.dwIncomingEncrypt;
		dwOutgoingEncrypt = TrafficDataRHS.dwOutgoingEncrypt;
		dwIncomingVoice = TrafficDataRHS.dwIncomingVoice;
		dwOutgoingVoice = TrafficDataRHS.dwOutgoingVoice;
		dwIncomingTotal = TrafficDataRHS.dwIncomingTotal;
		dwOutgoingTotal = TrafficDataRHS.dwOutgoingTotal;

		return *this;
	};

	DWORD dwIncomingEncrypt;
	DWORD dwOutgoingEncrypt;
	DWORD dwIncomingVoice;
	DWORD dwOutgoingVoice;
	DWORD dwIncomingTotal;
	DWORD dwOutgoingTotal;
} DATARECORDEDFORTIMESTAMP, *PDATARECORDEDFORTIMESTAMP;

// Define the mapping between frame times and data sizes
typedef map <__int64,DATARECORDEDFORTIMESTAMP> NMDATAHISTORYMAP;

// Define the paring inside the map for access later
typedef pair <__int64, DATARECORDEDFORTIMESTAMP> NMDATAHISTORYENTRY;

// Define the values representing the traffic data
typedef struct _XBOXTRAFFICDATA
{
	_XBOXTRAFFICDATA()
	{
		dwIncomingQosRequests = 0;
		dwOutgoingQosRequests = 0;
		dwIncomingQosReplies = 0;
		dwOutgoingQosReplies = 0;
		dwIncomingEncryptData = 0;
		dwOutgoingEncryptData = 0;
		dwIncomingVoiceData = 0;
		dwOutgoingVoiceData = 0;

		dwMaxIncomingEncryptRate = 0;
		dwMaxOutgoingEncryptRate = 0;
		dwMaxIncomingVoiceRate = 0;
		dwMaxOutgoingVoiceRate = 0;
		dwMaxIncomingTotalRate = 0;
		dwMaxOutgoingTotalRate = 0;
	};

	// These variables hold counters of all data sent and received
	DWORD dwIncomingQosRequests;
	DWORD dwOutgoingQosRequests;
	DWORD dwIncomingQosReplies;
	DWORD dwOutgoingQosReplies;
	DWORD dwIncomingEncryptData;
	DWORD dwOutgoingEncryptData;
	DWORD dwIncomingVoiceData;
	DWORD dwOutgoingVoiceData;
	DWORD dwIncomingTotalData;
	DWORD dwOutgoingTotalData;

	// These variables track the max rates observed across the capture
	DWORD dwMaxIncomingEncryptRate;
	DWORD dwMaxOutgoingEncryptRate;
	DWORD dwMaxIncomingVoiceRate;
	DWORD dwMaxOutgoingVoiceRate;
	DWORD dwMaxIncomingTotalRate;
	DWORD dwMaxOutgoingTotalRate;

	// These maps record the last 10 seconds of data detected for this Xbox
	NMDATAHISTORYMAP DataHistoryMap;
} XBOXTRAFFICDATA, *PXBOXTRAFFICDATA;

// Define the mapping between netmon addresses and the traffic data
typedef map <ADDRESS2,XBOXTRAFFICDATA> NMADDRESSMAP;

// Define the paring inside the map for access later
typedef pair <ADDRESS2, XBOXTRAFFICDATA> NMADDRESSMAPENTRY;

// MODE TWO:  Detailed statistics on a particular Xbox IP
// The second mode of operation generates detailed statistics on the traffic
// observed being sent to and from a particular Xbox IP at regular intervals
// throughout the capture.  This data is stored by the IP address of the other
// endpoint of the traffic.  This is either the IP of another Xbox or
// the address 0.0.0.0 which tracks aggregate traffic during the interval

// MODE TWO: MAP ONE
// This map links an Xbox IP to an interval map for that particular endpoint

// Define the mapping between a source-dest flow and its traffic history
typedef map <ADDRESS2,NMDATAHISTORYMAP> NMINTERVALMAP;

// Define the paring inside the map for access later
typedef pair <ADDRESS2,NMDATAHISTORYMAP> NMINTERVALMAPENTRY;

//////////////////////////////////////////////////////////////////////////////
// Constants
#define NMONESECOND   (1 * 1000000)
#define MAX_ENDPOINTCOLUMN_SIZE 80
#define PARTNERNETSG  0x84E46B83
#define PRODUCTIONSG  0x06F62ECF

//////////////////////////////////////////////////////////////////////////////
// Function Prototypes

// In xlexpert.cpp
// Export functions from the expert DLL
BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved);
extern BOOL WINAPI Register( PEXPERTENUMINFO lpExpertInfo);
extern BOOL WINAPI Configure( HEXPERTKEY hExpertKey, 
                       PEXPERTCONFIG* ppConfig,
                       PEXPERTSTARTUPINFO pStartupInfo,
                       DWORD StartupFlags,
                       HWND hWnd );
extern BOOL WINAPI Run( HEXPERTKEY hExpertKey, PEXPERTCONFIG lpConfig, HWND hwnd);

// Helper functions
void CalcXboxSummaryColumns(DWORD *pdwColumnCount, PXLEXPERTCONFIG pCurrentConfig);
BOOL InitXboxSummaryEvent(HEXPERTKEY hExpertKey, DWORD dwColumnCount, PXLEXPERTCONFIG pCurrentConfig, PNMEVENTDATA *ppXboxSummaryEvent);
BOOL CreateXspOrKerbFilter(HFILTER *phXspOrKerbFilter, HPROTOCOL hXsp, HPROTOCOL hKerberos);
BOOL CalculateCaptureIntervalInfo(HEXPERT hExpertKey, HFILTER hFilter, DWORD dwFramesCount, __int64 *pFirstFrameOffset, __int64 *pCaptureDuration, DWORD dwIntervalSize, __int64 *pIntervalsCount);
__int64 CalculateCurrentInterval(__int64 CurrentFrameTimeStamp, DWORD dwIntervalSize);
BOOL InitIntervalDetailEvent(HEXPERTKEY hExpertKey, PXLEXPERTCONFIG pCurrentConfig, NMINTERVALMAP *pSpecificXboxEndpointTrafficMap, NMADDRESSMAP *pSGIPAddresses, PNMEVENTDATA *ppIntervalDetailEvent);

// In Config.cpp
BOOL ConfigXLEXPERTDlg_Do(HWND hwnd, 
                          PXLEXPERTCONFIG * ppXLEXPERTConfig, 
                          HEXPERTKEY hExpertKey);

#pragma warning(default:4200)

#endif // _XLEXPERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\experts\xlexpert\config.cpp ===
//============================================================================
//  MODULE: Config.cpp
//
//  Description:
//
//  Handles the dialog for configuring the Xbox Live Expert
//
//  Modification History:
//
//  Your Name Here      01/01/70    Created
//============================================================================
#define STRICT 1
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <netmon.h>
#include <commctrl.h>
#include "resource.h"
#include "xlexpert.h"

//////////////////////////////////////////////////////////////////////////////
// Global Variables

TCHAR             g_tszSeconds[3] = TEXT("");
HEXPERTKEY        g_hExpertKey;
PXLEXPERTCONFIG * g_ppXLEXPERTConfig;

//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
INT_PTR CALLBACK ConfigXLEXPERTDlg_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// input handlers
BOOL ConfigXLEXPERTDlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void ConfigXLEXPERTDlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
void ConfigXLEXPERTDlg_OnOKButton( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
void ConfigXLEXPERTDlg_OnCancelButton( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
void ConfigXLEXPERTDlg_OnHelpButton( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_Do
BOOL ConfigXLEXPERTDlg_Do(HWND hwnd, 
                          PXLEXPERTCONFIG * ppXLEXPERTConfig, 
                          HEXPERTKEY hExpertKey)
{
    // save the current struture
    g_hExpertKey = hExpertKey;
    g_ppXLEXPERTConfig = ppXLEXPERTConfig;

    // create the dialog box...
    return (DialogBox( g_hInstance, 
                      MAKEINTRESOURCE(IDD_XLEXPERT_CONFIG_DIALOG), 
                      hwnd, 
                      (DLGPROC)ConfigXLEXPERTDlg_DlgProc) > 0);
}

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_DlgProc
INT_PTR CALLBACK ConfigXLEXPERTDlg_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, ConfigXLEXPERTDlg_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND,    ConfigXLEXPERTDlg_OnCommand);

        // this makes the F1 key act like the Help key
        case WM_HELP:
            ConfigXLEXPERTDlg_OnHelpButton(hwnd, IDM_HELP, NULL, 0);
            break;
    }
    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_OnInitDialog
BOOL ConfigXLEXPERTDlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
	LRESULT lState = 0;
    DWORD BufferSize;
	DWORD rc;

    BufferSize = sizeof(XLEXPERTCONFIG);

    // TODO: Size the buffer -------------------------------------------------
    // do we have a config buffer?
    if( *g_ppXLEXPERTConfig == NULL )
    {
        // no, allocate one
        *g_ppXLEXPERTConfig = (PXLEXPERTCONFIG)ExpertAllocMemory( 
                                    g_hExpertKey,
                                    BufferSize,
                                    &rc);
        if( *g_ppXLEXPERTConfig == NULL )
        {
            return FALSE;
        }

		// fill in the default values
		(*g_ppXLEXPERTConfig)->RawConfigLength = sizeof(XLEXPERTCONFIG);

		(*g_ppXLEXPERTConfig)->fGetMovingAverage = TRUE;
		(*g_ppXLEXPERTConfig)->dwMovingAverageSizeValue = 5;
		(*g_ppXLEXPERTConfig)->fMovingAverageEncrypt = FALSE;
		(*g_ppXLEXPERTConfig)->fMovingAverageVoice = FALSE;
		(*g_ppXLEXPERTConfig)->fMovingAverageTotal = TRUE;

		(*g_ppXLEXPERTConfig)->fGetCumulative = FALSE;
		(*g_ppXLEXPERTConfig)->fCumulativeEncrypt = FALSE;
		(*g_ppXLEXPERTConfig)->fCumulativeVoice = FALSE;
		(*g_ppXLEXPERTConfig)->fCumulativeTotal = FALSE;

		(*g_ppXLEXPERTConfig)->fGetIntervalStats = FALSE;
		(*g_ppXLEXPERTConfig)->dwIntervalSizeValue = 5;
		(*g_ppXLEXPERTConfig)->dwXboxAddress = 0;
		(*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt = FALSE;
		(*g_ppXLEXPERTConfig)->fIntervalStatsVoice = FALSE;
		(*g_ppXLEXPERTConfig)->fIntervalStatsTotal = TRUE;

		(*g_ppXLEXPERTConfig)->fBitsPerSecond = TRUE;
    }
    else
    {
        // is the given buffer big enough
		if( (*g_ppXLEXPERTConfig)->RawConfigLength < BufferSize )
		{
			PXLEXPERTCONFIG TempConfig;

			// no, we must grow it
			TempConfig = (PXLEXPERTCONFIG)ExpertReallocMemory( 
				g_hExpertKey,
				*g_ppXLEXPERTConfig,
				BufferSize,
				&rc);
			if( TempConfig == NULL )
			{
				return FALSE;
			}

			// it worked
			*g_ppXLEXPERTConfig = TempConfig;

			// fill in the default values
			(*g_ppXLEXPERTConfig)->RawConfigLength = sizeof(XLEXPERTCONFIG);

			(*g_ppXLEXPERTConfig)->fGetMovingAverage = TRUE;
			(*g_ppXLEXPERTConfig)->dwMovingAverageSizeValue = 5;
			(*g_ppXLEXPERTConfig)->fMovingAverageEncrypt = FALSE;
			(*g_ppXLEXPERTConfig)->fMovingAverageVoice = FALSE;
			(*g_ppXLEXPERTConfig)->fMovingAverageTotal = TRUE;

			(*g_ppXLEXPERTConfig)->fGetCumulative = FALSE;
			(*g_ppXLEXPERTConfig)->fCumulativeEncrypt = FALSE;
			(*g_ppXLEXPERTConfig)->fCumulativeVoice = FALSE;
			(*g_ppXLEXPERTConfig)->fCumulativeTotal = FALSE;

			(*g_ppXLEXPERTConfig)->fGetIntervalStats = FALSE;
			(*g_ppXLEXPERTConfig)->dwIntervalSizeValue = 5;
			(*g_ppXLEXPERTConfig)->dwXboxAddress = 0;
			(*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt = FALSE;
			(*g_ppXLEXPERTConfig)->fIntervalStatsVoice = FALSE;
			(*g_ppXLEXPERTConfig)->fIntervalStatsTotal = TRUE;

			(*g_ppXLEXPERTConfig)->fBitsPerSecond = TRUE;
		}
    }

	// Make sure we never use a 0 value for an interval size
	if(!((*g_ppXLEXPERTConfig)->dwMovingAverageSizeValue))
		(*g_ppXLEXPERTConfig)->dwMovingAverageSizeValue = 5;

	if(!((*g_ppXLEXPERTConfig)->dwIntervalSizeValue))
		(*g_ppXLEXPERTConfig)->dwIntervalSizeValue = 5;

	// Setup the moving average dialog items based on the config data
	SendDlgItemMessage( hwnd, IDC_GETMOVINGAVERAGE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fGetMovingAverage ? BST_CHECKED : BST_UNCHECKED, 0);
	_itot((INT) ((*g_ppXLEXPERTConfig)->dwMovingAverageSizeValue), g_tszSeconds, 10);
	SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGESIZEVALUE, WM_SETTEXT, FALSE, (LPARAM) g_tszSeconds);
	SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGESIZEVALUE, WM_ENABLE, (*g_ppXLEXPERTConfig)->fGetMovingAverage, 0);
	if(!(*g_ppXLEXPERTConfig)->fGetMovingAverage)
	{
		SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEVOICE, BM_SETCHECK, BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGETOTAL, BM_SETCHECK, BST_UNCHECKED, 0);
	}
	else
	{
		SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageVoice ? BST_CHECKED : BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGETOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageTotal ? BST_CHECKED : BST_UNCHECKED, 0);
	}

	// Setup the cumulative dialog items based on the config data
	SendDlgItemMessage( hwnd, IDC_GETCUMULATIVE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fGetCumulative ? BST_CHECKED : BST_UNCHECKED, 0);
	if(!(*g_ppXLEXPERTConfig)->fGetCumulative)
	{
		SendDlgItemMessage( hwnd, IDC_CUMULATIVEENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_CUMULATIVEVOICE, BM_SETCHECK, BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_CUMULATIVETOTAL, BM_SETCHECK, BST_UNCHECKED, 0);
	}
	else
	{
		SendDlgItemMessage( hwnd, IDC_CUMULATIVEENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_CUMULATIVEVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeVoice ? BST_CHECKED : BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_CUMULATIVETOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeTotal ? BST_CHECKED : BST_UNCHECKED, 0);
	}


	// Setup the interval stats items based on the config data
	SendDlgItemMessage( hwnd, IDC_GETINTERVALSTATS, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fGetIntervalStats ? BST_CHECKED : BST_UNCHECKED, 0);
	_itot((INT) ((*g_ppXLEXPERTConfig)->dwIntervalSizeValue), g_tszSeconds, 10);
	SendDlgItemMessage( hwnd, IDC_INTERVALSIZEVALUE, WM_SETTEXT, FALSE, (LPARAM) g_tszSeconds);
	SendDlgItemMessage( hwnd, IDC_INTERVALSIZEVALUE, WM_ENABLE, (*g_ppXLEXPERTConfig)->fGetIntervalStats, 0);
	SendDlgItemMessage( hwnd, IDC_XBOXADDRESS, IPM_SETADDRESS, FALSE, ntohl((*g_ppXLEXPERTConfig)->dwXboxAddress));
	SendDlgItemMessage( hwnd, IDC_XBOXADDRESS, WM_ENABLE, (*g_ppXLEXPERTConfig)->fGetIntervalStats, 0);
	if(!(*g_ppXLEXPERTConfig)->fGetIntervalStats)
	{
		SendDlgItemMessage( hwnd, IDC_INTERVALSTATSENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_INTERVALSTATSVOICE, BM_SETCHECK, BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_INTERVALSTATSTOTAL, BM_SETCHECK, BST_UNCHECKED, 0);
	}
	else
	{
		SendDlgItemMessage( hwnd, IDC_INTERVALSTATSENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_INTERVALSTATSVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsVoice ? BST_CHECKED : BST_UNCHECKED, 0);
		SendDlgItemMessage( hwnd, IDC_INTERVALSTATSTOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsTotal ? BST_CHECKED : BST_UNCHECKED, 0);
	}


	// Setup the bits or bytes combo box based on the config data
	SendDlgItemMessage( hwnd, IDC_BYTESORBITS, CB_ADDSTRING, 0, (LPARAM) TEXT("bits per second"));
	SendDlgItemMessage( hwnd, IDC_BYTESORBITS, CB_ADDSTRING, 0, (LPARAM) TEXT("bytes per second"));
	SendDlgItemMessage( hwnd, IDC_BYTESORBITS, CB_SETCURSEL, (*g_ppXLEXPERTConfig)->fBitsPerSecond ? 0 : 1, 0);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_OnCommand
void ConfigXLEXPERTDlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch(id)
    {
        // OK Button has been hit...
        case IDOK:
            ConfigXLEXPERTDlg_OnOKButton(hwnd, id, hwndCtl, codeNotify);
            break;

        // Cancel button has been hit
        case IDCANCEL:
            ConfigXLEXPERTDlg_OnCancelButton(hwnd, id, hwndCtl, codeNotify);
            break;

        case IDM_HELP:
            ConfigXLEXPERTDlg_OnHelpButton(hwnd, id, hwndCtl, codeNotify);
            break;

		case IDC_GETMOVINGAVERAGE:
			// If we were previously enabled, then disable the moving average items in the dialog
			(*g_ppXLEXPERTConfig)->fGetMovingAverage = !(*g_ppXLEXPERTConfig)->fGetMovingAverage;

			SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGESIZEVALUE, WM_ENABLE, (*g_ppXLEXPERTConfig)->fGetMovingAverage, 0); 

			if(!(*g_ppXLEXPERTConfig)->fGetMovingAverage)
			{
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEVOICE, BM_SETCHECK, BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGETOTAL, BM_SETCHECK, BST_UNCHECKED, 0);
			}
			else
			{
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageVoice ? BST_CHECKED : BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGETOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageTotal ? BST_CHECKED : BST_UNCHECKED, 0);
			}

			break;

		case IDC_GETCUMULATIVE:
			// If we were previously enabled, then disable the cumulative items in the dialog
			(*g_ppXLEXPERTConfig)->fGetCumulative = !(*g_ppXLEXPERTConfig)->fGetCumulative;

			if(!(*g_ppXLEXPERTConfig)->fGetCumulative)
			{
				SendDlgItemMessage( hwnd, IDC_CUMULATIVEENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVEVOICE, BM_SETCHECK, BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVETOTAL, BM_SETCHECK, BST_UNCHECKED, 0);
			}
			else
			{
				SendDlgItemMessage( hwnd, IDC_CUMULATIVEENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVEVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeVoice ? BST_CHECKED : BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVETOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeTotal ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_GETINTERVALSTATS:
			// If we were previously enabled, then disable the interval items in the dialog
			(*g_ppXLEXPERTConfig)->fGetIntervalStats = !(*g_ppXLEXPERTConfig)->fGetIntervalStats;
			SendDlgItemMessage( hwnd, IDC_INTERVALSIZEVALUE, WM_ENABLE, (*g_ppXLEXPERTConfig)->fGetIntervalStats, 0); 
			SendDlgItemMessage( hwnd, IDC_XBOXADDRESS, WM_ENABLE, (*g_ppXLEXPERTConfig)->fGetIntervalStats, 0); 

			if(!(*g_ppXLEXPERTConfig)->fGetIntervalStats)
			{
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSVOICE, BM_SETCHECK, BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSTOTAL, BM_SETCHECK, BST_UNCHECKED, 0);
			}
			else
			{
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsVoice ? BST_CHECKED : BST_UNCHECKED, 0);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSTOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsTotal ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_MOVINGAVERAGEENCRYPT:
			if((*g_ppXLEXPERTConfig)->fGetMovingAverage)
			{
				(*g_ppXLEXPERTConfig)->fMovingAverageEncrypt = !((*g_ppXLEXPERTConfig)->fMovingAverageEncrypt);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_MOVINGAVERAGEVOICE:
			if((*g_ppXLEXPERTConfig)->fGetMovingAverage)
			{
				(*g_ppXLEXPERTConfig)->fMovingAverageVoice = !((*g_ppXLEXPERTConfig)->fMovingAverageVoice);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageVoice ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_MOVINGAVERAGETOTAL:
			if((*g_ppXLEXPERTConfig)->fGetMovingAverage)
			{
				(*g_ppXLEXPERTConfig)->fMovingAverageTotal = !((*g_ppXLEXPERTConfig)->fMovingAverageTotal);
				SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGETOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fMovingAverageTotal ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_CUMULATIVEENCRYPT:
			if((*g_ppXLEXPERTConfig)->fGetCumulative)
			{
				(*g_ppXLEXPERTConfig)->fCumulativeEncrypt = !((*g_ppXLEXPERTConfig)->fCumulativeEncrypt);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVEENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_CUMULATIVEVOICE:
			if((*g_ppXLEXPERTConfig)->fGetCumulative)
			{
				(*g_ppXLEXPERTConfig)->fCumulativeVoice = !((*g_ppXLEXPERTConfig)->fCumulativeVoice);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVEVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeVoice ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_CUMULATIVETOTAL:
			if((*g_ppXLEXPERTConfig)->fGetCumulative)
			{
				(*g_ppXLEXPERTConfig)->fCumulativeTotal = !((*g_ppXLEXPERTConfig)->fCumulativeTotal);
				SendDlgItemMessage( hwnd, IDC_CUMULATIVETOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fCumulativeTotal ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_INTERVALSTATSENCRYPT:
			if((*g_ppXLEXPERTConfig)->fGetIntervalStats)
			{
				(*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt = !((*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSENCRYPT, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_INTERVALSTATSVOICE:
			if((*g_ppXLEXPERTConfig)->fGetIntervalStats)
			{
				(*g_ppXLEXPERTConfig)->fIntervalStatsVoice = !((*g_ppXLEXPERTConfig)->fIntervalStatsVoice);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSVOICE, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsVoice ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

		case IDC_INTERVALSTATSTOTAL:
			if((*g_ppXLEXPERTConfig)->fGetIntervalStats)
			{
				(*g_ppXLEXPERTConfig)->fIntervalStatsTotal = !((*g_ppXLEXPERTConfig)->fIntervalStatsTotal);
				SendDlgItemMessage( hwnd, IDC_INTERVALSTATSTOTAL, BM_SETCHECK, (*g_ppXLEXPERTConfig)->fIntervalStatsTotal ? BST_CHECKED : BST_UNCHECKED, 0);
			}
			break;

    }
}

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_OnOKButton
void ConfigXLEXPERTDlg_OnOKButton( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	TCHAR tszSeconds[3] = TEXT("");
	INT nMovingAverageSize = 0, nIntervalSize = 0;
	LRESULT lState;
	DWORD dwXboxAddress = 0;

    // Validate dialog contents
	if(!(*g_ppXLEXPERTConfig)->fGetMovingAverage &&
		!(*g_ppXLEXPERTConfig)->fGetCumulative &&
		!(*g_ppXLEXPERTConfig)->fGetIntervalStats)
	{
		MessageBox(hwnd, TEXT("Must request either moving averages, cumulative totals or interval statistics"), TEXT("Invalid Interval"), MB_OK);
		return;		
	}

	if((*g_ppXLEXPERTConfig)->fGetMovingAverage &&
		!(*g_ppXLEXPERTConfig)->fMovingAverageEncrypt &&
		!(*g_ppXLEXPERTConfig)->fMovingAverageVoice &&
		!(*g_ppXLEXPERTConfig)->fMovingAverageTotal)
	{
		MessageBox(hwnd, TEXT("When moving average calculation is enabled, either encrypt, voice or total data must also be selected."), TEXT("Invalid Selection"), MB_OK);
		return;		
	}

	if((*g_ppXLEXPERTConfig)->fGetIntervalStats &&
		!(*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt &&
		!(*g_ppXLEXPERTConfig)->fIntervalStatsVoice &&
		!(*g_ppXLEXPERTConfig)->fIntervalStatsTotal)
	{
		MessageBox(hwnd, TEXT("When interval statistics calculation is enabled, either encrypt, voice or total data must also be selected."), TEXT("Invalid Selection"), MB_OK);
		return;		
	}

	SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGESIZEVALUE, WM_GETTEXT, 3, (LPARAM) tszSeconds);
	nMovingAverageSize = _ttoi(tszSeconds);
	if(nMovingAverageSize <= 0)
	{
		MessageBox(hwnd, TEXT("Moving average size specified must be between 1 and 99"), TEXT("Invalid Interval"), MB_OK);
		return;
	}

	SendDlgItemMessage( hwnd, IDC_INTERVALSIZEVALUE, WM_GETTEXT, 3, (LPARAM) tszSeconds);
	nIntervalSize = _ttoi(tszSeconds);
	if(nIntervalSize <= 0)
	{
		MessageBox(hwnd, TEXT("Interval size specified must be between 1 and 99"), TEXT("Invalid Interval"), MB_OK);
		return;
	}

	// Validate the IP address, if provided
	lState = SendDlgItemMessage( hwnd, IDC_GETINTERVALSTATS, BM_GETCHECK, 0, 0); 
	if(BST_CHECKED == lState)
	{
		SendDlgItemMessage( hwnd, IDC_XBOXADDRESS, IPM_GETADDRESS, 0, (LPARAM) &dwXboxAddress);
		if(!dwXboxAddress)
		{
			MessageBox(hwnd, TEXT("Must specify an IP address other than 0.0.0.0"), TEXT("Invalid Address"), MB_OK);
			return;
		}
		if(0xFFFFFFFF == dwXboxAddress)
		{
			MessageBox(hwnd, TEXT("Must specify an IP address other than 255.255.255.255"), TEXT("Invalid Address"), MB_OK);
			return;
		}
	}

    // Fill in the Config data
	// Start with the values of the check-boxes
	lState = SendDlgItemMessage( hwnd, IDC_GETMOVINGAVERAGE, BM_GETCHECK, 0, 0);
	(*g_ppXLEXPERTConfig)->fGetMovingAverage = (BST_CHECKED == lState);

	lState = SendDlgItemMessage( hwnd, IDC_GETCUMULATIVE, BM_GETCHECK, 0, 0);
	(*g_ppXLEXPERTConfig)->fGetCumulative = (BST_CHECKED == lState);

	lState = SendDlgItemMessage( hwnd, IDC_GETINTERVALSTATS, BM_GETCHECK, 0, 0);
	(*g_ppXLEXPERTConfig)->fGetIntervalStats = (BST_CHECKED == lState);

	// If moving average calculation was enabled, get those values
	if((*g_ppXLEXPERTConfig)->fGetMovingAverage)
	{
		(*g_ppXLEXPERTConfig)->dwMovingAverageSizeValue = (DWORD) nMovingAverageSize;
		lState = SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEENCRYPT, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fMovingAverageEncrypt = (BST_CHECKED == lState);
		lState = SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGEVOICE, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fMovingAverageVoice = (BST_CHECKED == lState);
		lState = SendDlgItemMessage( hwnd, IDC_MOVINGAVERAGETOTAL, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fMovingAverageTotal = (BST_CHECKED == lState);
	}

	// If cumulative calculation was enabled, get those values
	if((*g_ppXLEXPERTConfig)->fGetCumulative)
	{
		lState = SendDlgItemMessage( hwnd, IDC_CUMULATIVEENCRYPT, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fCumulativeEncrypt = (BST_CHECKED == lState);
		lState = SendDlgItemMessage( hwnd, IDC_CUMULATIVEVOICE, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fCumulativeVoice = (BST_CHECKED == lState);
		lState = SendDlgItemMessage( hwnd, IDC_CUMULATIVETOTAL, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fCumulativeTotal = (BST_CHECKED == lState);
	}

	// If interval stats calculation was enabled, get those values
	if((*g_ppXLEXPERTConfig)->fGetIntervalStats)
	{
		(*g_ppXLEXPERTConfig)->dwIntervalSizeValue = (DWORD) nIntervalSize;
		lState = SendDlgItemMessage( hwnd, IDC_XBOXADDRESS, IPM_GETADDRESS, 0, (LPARAM) &((*g_ppXLEXPERTConfig)->dwXboxAddress)); 
		(*g_ppXLEXPERTConfig)->dwXboxAddress = htonl((*g_ppXLEXPERTConfig)->dwXboxAddress);

		lState = SendDlgItemMessage( hwnd, IDC_INTERVALSTATSENCRYPT, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fIntervalStatsEncrypt = (BST_CHECKED == lState);
		lState = SendDlgItemMessage( hwnd, IDC_INTERVALSTATSVOICE, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fIntervalStatsVoice = (BST_CHECKED == lState);
		lState = SendDlgItemMessage( hwnd, IDC_INTERVALSTATSTOTAL, BM_GETCHECK, 0, 0);
		(*g_ppXLEXPERTConfig)->fIntervalStatsTotal = (BST_CHECKED == lState);
	}

	(*g_ppXLEXPERTConfig)->fBitsPerSecond = (SendDlgItemMessage( hwnd, IDC_BYTESORBITS, CB_GETCURSEL, 0, 0) == 0);

    // we are done
    EndDialog(hwnd, TRUE);
}

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_OnCancelButton
void ConfigXLEXPERTDlg_OnCancelButton( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{   
    // TODO: Release any memory that you have allocated

    // we are done
    EndDialog(hwnd, FALSE);
}

//////////////////////////////////////////////////////////////////////////////
// ConfigXLEXPERTDlg_OnHelpButton()
void ConfigXLEXPERTDlg_OnHelpButton( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    // TODO: bring up help
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\experts\xlexpert\xlexpert.cpp ===
//============================================================================
//  MODULE: XLEXPERT.cpp
//
//  Description:
//
//  XLEXPERT expert module
//
//  Modification History:
//
//  Your Name Here      01/01/70    Created
//============================================================================
#define STRICT 1

#include "xlexpert.h"
#include "resource.h"

// -----------------------------------------------------------------------
// Functions for manipulating the data history maps

// Sums all values in the given data history map
void SumSince(NMDATAHISTORYMAP & DataHistoryMap, __int64 CurrentTime, PDATARECORDEDFORTIMESTAMP pSumNSec)
{
	pSumNSec->ClearValues();

	if(!DataHistoryMap.empty())
	{
		NMDATAHISTORYMAP::iterator MapIterator;

		// Note that we can start from the beginning because this function will always
		// be called after RemoveOlderThan so there won't be any entries older than 10 seconds
		for(MapIterator = DataHistoryMap.begin(); MapIterator != DataHistoryMap.end(); ++MapIterator)
		{
			*pSumNSec += MapIterator->second;
		}
	}
}

void RemoveOlderThan(NMDATAHISTORYMAP & DataHistoryMap, __int64 OldTime)
{
	DWORD dwSum = 0;
	if(!DataHistoryMap.empty())
	{
		if(DataHistoryMap.lower_bound(OldTime) != DataHistoryMap.end())
		{
			DataHistoryMap.erase(DataHistoryMap.begin(), DataHistoryMap.lower_bound(OldTime));
		}
	}
}

bool operator< ( ADDRESS2 AddrX, ADDRESS2 AddrY )
{ return (memcmp(AddrX.IPAddress, AddrY.IPAddress, sizeof(AddrX.IPAddress)) < 0); }

bool operator== ( ADDRESS2 AddrX, ADDRESS2 AddrY )
{ return (memcmp(AddrX.IPAddress, AddrY.IPAddress, sizeof(AddrX.IPAddress)) == 0); }

bool operator!= ( ADDRESS2 AddrX, ADDRESS2 AddrY )
{ return (memcmp(AddrX.IPAddress, AddrY.IPAddress, sizeof(AddrX.IPAddress)) != 0); }

//////////////////////////////////////////////////////////////////////////////
// Global Variables
HINSTANCE g_hInstance;
char g_StatusString[MAX_PATH];
char g_XboxIpAddr[MAX_PATH];
char g_XboxNumber[MAX_PATH];
char g_InEncrypt[MAX_PATH];
char g_InVoice[MAX_PATH];
char g_InTotal[MAX_PATH];
char g_OutEncrypt[MAX_PATH];
char g_OutVoice[MAX_PATH];
char g_OutTotal[MAX_PATH];
char g_InEncryptNSecAvg[MAX_PATH];
char g_OutEncryptNSecAvg[MAX_PATH];
char g_InVoiceNSecAvg[MAX_PATH];
char g_OutVoiceNSecAvg[MAX_PATH];
char g_InTotalNSecAvg[MAX_PATH];
char g_OutTotalNSecAvg[MAX_PATH];
char g_BitsOrBytesPerSecond[MAX_PATH];

char g_ExpertName[MAX_PATH];
char g_XboxSummaryEventName[MAX_PATH];
char g_IntervalTrafficEventName[MAX_PATH];
char g_Interval[MAX_PATH];

char *g_pIntervalIPStrings;
// Define the diffent interval stats column types
#define ENCRYPTED_COLUMN_TYPE      0
#define VOICE_COLUMN_TYPE          1
#define TOTAL_COLUMN_TYPE          2
#define MAX_INTERVAL_COLUMN_TYPE   3
CHAR g_szIntervalColumnTypeStrings[MAX_INTERVAL_COLUMN_TYPE][20] =
{
	"Encrypted",
	"Voice",
	"Total"
};

//////////////////////////////////////////////////////////////////////////////
// The DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    switch( ulReason )
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            break;

        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// The Expert Registration entry point
//
BOOL WINAPI Register( PEXPERTENUMINFO lpExpertInfo)
{
    // fill in the expert info data structure
    // TODO: Choose the proper flags
    lpExpertInfo->Flags = EXPERT_ENUM_FLAG_VIEWER_PRIVATE | EXPERT_ENUM_FLAG_CONFIGURABLE;
    lpExpertInfo->Version = 0;
    LoadStringA( g_hInstance, IDS_EXPERTNAME, lpExpertInfo->szName, MAX_PATH);
    LoadStringA( g_hInstance, IDS_COMMENT, lpExpertInfo->szDescription, MAX_PATH);
    LoadStringA( g_hInstance, IDS_AUTHOR, lpExpertInfo->szVendor, MAX_PATH);
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// The Expert Configuration entry point
//
BOOL WINAPI Configure( HEXPERTKEY hExpertKey, 
                       PEXPERTCONFIG* ppConfig,
                       PEXPERTSTARTUPINFO pStartupInfo,
                       DWORD StartupFlags,
                       HWND hWnd )
{
    // is the startup info from a right mouse click?
    if( (pStartupInfo == NULL) &&
        (StartupFlags & EXPERT_STARTUP_FLAG_USE_STARTUP_DATA_OVER_CONFIG_DATA) )
    {
        // The user started this expert by right mouse clicking...

        // TODO: pull the relevant data out of the pStartupInfo
        // and put it in the (possibly resized) ppConfig
    }

    // call the dialog
    return ConfigXLEXPERTDlg_Do(hWnd, 
                                (PXLEXPERTCONFIG *)ppConfig, 
                                hExpertKey);
}


//////////////////////////////////////////////////////////////////////////////
// The Expert Start entry point
//
BOOL WINAPI Run( HEXPERTKEY hExpertKey, 
                 PEXPERTCONFIG lpConfig, 
                 PEXPERTSTARTUPINFO pStartupInfo,
                 DWORD StartupFlags,
                 HWND hwnd)
{
	DWORD                   rc;
    EXPERTSTATUS            Status;
    HFILTER                 hXspOrKerbFilter;
    XLEXPERTCONFIG          *pXLEXPERTConfig = (PXLEXPERTCONFIG)lpConfig, CurrentConfig;
    PNMEVENTDATA            pXboxSummaryEvent = NULL, pIntervalDetailEvent = NULL;
	XBOXTRAFFICDATA         EmptyTrafficData;

    DWORD                   TotalFrames = 0, CurrentFrameNumber = 0, XboxCounter = 0;
	DWORD                   dwColumnCount = 0, dwCurrentColumn = 0;
	DWORD                   dwCurrentOutgoingEncrypt = 0, dwCurrentIncomingEncrypt = 0;
	DWORD                   dwCurrentOutgoingVoice = 0, dwCurrentIncomingVoice = 0;
	DWORD                   dwCurrentOutgoingTotal = 0, dwCurrentIncomingTotal = 0;

    BYTE                    CurrentPercentDone = 0;
    BYTE                    ReportedPercentDone = 0;
	NMADDRESSMAP            XboxIpAddresses, SgIpAddresses;
	NMDATAHISTORYMAP        EmptyAddressMap;
	NMADDRESSMAP::iterator  CurrentAddress, EndAddress;
	NMINTERVALMAP           SpecificXboxEndpointTrafficMap;

	HPROTOCOL               hXsp = NULL, hKerberos = NULL, hIP = NULL;
	HPROPERTY               hKeyExTypeProp = NULL, hEncryptData = NULL, hVoiceData = NULL;
	HPROPERTY               hTotalData = NULL, hSPI = NULL, hProtocol = NULL;

	ADDRESS2                AggregateIPPlaceholder, SpecifiedXboxIPAddress, SourceIPAddr, DestIPAddr;

	BOOL					fFoundXbox = FALSE, fFirstFrame = TRUE;
	__int64					FirstFrameOffset = 0, CaptureDuration = 0;
	__int64                 IntervalsCount = 0, CurrentInterval = 0;

    // -----------------------------------------------------------------------
    // Zero out all of our stack data structures
    memset( &Status, 0, sizeof(EXPERTSTATUS) );

	// Either get params set during configuration, or use defaults
	if(pXLEXPERTConfig)
		memcpy(&CurrentConfig, pXLEXPERTConfig, sizeof(XLEXPERTCONFIG));
	else
	{
		// Default values
		CurrentConfig.fGetMovingAverage = TRUE;
		CurrentConfig.dwMovingAverageSizeValue = 5;
		CurrentConfig.fMovingAverageEncrypt = FALSE;
		CurrentConfig.fMovingAverageVoice = FALSE;
		CurrentConfig.fMovingAverageTotal = TRUE;
		CurrentConfig.fGetCumulative = FALSE;
		CurrentConfig.fCumulativeEncrypt = FALSE;
		CurrentConfig.fCumulativeVoice = FALSE;
		CurrentConfig.fCumulativeTotal = FALSE;
		CurrentConfig.fGetIntervalStats = FALSE;
		CurrentConfig.dwIntervalSizeValue = 5;
		CurrentConfig.dwXboxAddress = 0;
		CurrentConfig.fIntervalStatsEncrypt = FALSE;
		CurrentConfig.fIntervalStatsVoice = FALSE;
		CurrentConfig.fIntervalStatsTotal = TRUE;
		CurrentConfig.fBitsPerSecond = TRUE;
	}

	// If we received invalid data from any of the config fields, correct it
	if(CurrentConfig.fGetMovingAverage && !CurrentConfig.dwMovingAverageSizeValue)
	{
		CurrentConfig.dwMovingAverageSizeValue = 5;
	}

	if(CurrentConfig.fGetIntervalStats && !CurrentConfig.dwIntervalSizeValue)
	{
		CurrentConfig.dwIntervalSizeValue = 5;
	}

	if(CurrentConfig.fGetIntervalStats && !CurrentConfig.dwXboxAddress)
	{
		CurrentConfig.fGetIntervalStats = FALSE;
	}

    LoadStringA(g_hInstance, IDS_EXPERTNAME, g_ExpertName, MAX_PATH);
	LoadStringA(g_hInstance, CurrentConfig.fBitsPerSecond ? IDS_BITSPERSECOND : IDS_BYTESPERSECOND, g_BitsOrBytesPerSecond, MAX_PATH);

    // -----------------------------------------------------------------------
	// Get handles for the protocols we're interested in
	hXsp = GetProtocolFromName( "XSP" );
	if(!hXsp)
	{
		goto XspParserProblem;
	}

	hKerberos = GetProtocolFromName( "KERBEROS" );
	if(!hKerberos)
	{
		goto KerberosParserProblem;
	}

	hIP = GetProtocolFromName( "IP" );
	if(!hIP)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
    // Set up our status structure and tell the world that we are initializing
    Status.Frame       = 0;
    Status.PercentDone = 0;
    Status.Status      = EXPERTSTATUS_STARTING;
    Status.SubStatus   = 0;    
    LoadStringA(g_hInstance, IDS_INITIALIZING, Status.szStatusText, MAX_PATH);
    rc = ExpertIndicateStatus(hExpertKey, 
                              Status.Status,
                              Status.SubStatus,
                              Status.szStatusText,
                              Status.PercentDone);
    if( rc == NMERR_EXPERT_TERMINATE )
    {
        // we have been asked to terminate
        return TRUE;
    }
    else if( rc != NMERR_SUCCESS )
    {
        // something bad happened
        return FALSE;
    }

    // ------------------------------------------------------------------------
    // create a filter which will only find frames XSP frames
    hXspOrKerbFilter = CreateFilter();
    if( hXspOrKerbFilter == NULL )
    {
		goto CantCreateFilter;
    }

	if(!CreateXspOrKerbFilter(&hXspOrKerbFilter, hXsp, hKerberos))
	{
		goto CantAddToFilter;
	}

	SetCurrentFilter(hXspOrKerbFilter);

    // -----------------------------------------------------------------------
    // send the first status message which will indicate that we are now running
    rc = ExpertIndicateStatus( hExpertKey, 
                               EXPERTSTATUS_RUNNING,
                               0,
                               "",
                               0);
    if( rc == NMERR_EXPERT_TERMINATE )
    {
        // we were terminated
        rc = FALSE;
		goto Exit;
    }

    // -----------------------------------------------------------------------
    // Get a property handle for the key exchange type field
	hKeyExTypeProp = GetProperty(hXsp, "Key Ex Type");
	if(!hKeyExTypeProp)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
    // Get a property handle for the encrypted data field
	hEncryptData = GetProperty(hXsp, "Encrypted data");
	if(!hEncryptData)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
    // Get a property handle for the voice data field
	hVoiceData = GetProperty(hXsp, "Voice data");
	if(!hVoiceData)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
    // Get a property handle for the total frame length
	hTotalData = GetProperty(hIP, "Total Length");
	if(!hTotalData)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
    // Get a property handle for the XSP SPI
	hSPI = GetProperty(hXsp, "SPI");
	if(!hSPI)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
    // Get a property handle for the XSP protocol
	hProtocol = GetProperty(hXsp, "Protocol");
	if(!hProtocol)
	{
		goto XspParserProblem;
	}

    // -----------------------------------------------------------------------
	// Find first and last frames and determine the duration of the capture
    TotalFrames = GetCaptureTotalFrames( pStartupInfo->hCapture);
	if(!CalculateCaptureIntervalInfo(hExpertKey, hXspOrKerbFilter, TotalFrames, &FirstFrameOffset, &CaptureDuration, CurrentConfig.dwIntervalSizeValue, &IntervalsCount))
	{
		goto XspParserProblem;
	}

	// If we were given a specific IP address, go ahead and add that address to
	// the list of Xbox IP addresses
	if(CurrentConfig.fGetIntervalStats)
	{
		AggregateIPPlaceholder.Type = 1;
		AggregateIPPlaceholder.Flags = 0xCCCC;
		*((DWORD *) &(AggregateIPPlaceholder.IPAddress[0])) = 0;
		SpecificXboxEndpointTrafficMap[AggregateIPPlaceholder] = EmptyAddressMap;

		SpecifiedXboxIPAddress.Type = 1;
		SpecifiedXboxIPAddress.Flags = 0xCCCC;
		memcpy(SpecifiedXboxIPAddress.IPAddress, &(CurrentConfig.dwXboxAddress), sizeof(DWORD));
		XboxIpAddresses[SpecifiedXboxIPAddress] = EmptyTrafficData;
	}

    // -----------------------------------------------------------------------
	// We'll two two loops through the capture:
	//    LOOP 1 will detect all Xboxes from key exchange and QoS packets
	//    LOOP 2 will calculate traffic statistics from each detected Xbox

    // -----------------------------------------------------------------------
    // LOOP 1 - detect Xboxes
    CurrentFrameNumber = -1;
    do
    {
		LPPROPERTYINST          pCurrentProperty = NULL;
		EXPERTFRAMEDESCRIPTOR   FrameDescriptor;

        // get the next frame which passes both the user's filter and ours
        rc = ExpertGetFrame( hExpertKey,
                             GET_FRAME_NEXT_FORWARD,
                             ( FLAGS_DEFER_TO_UI_FILTER | 
                               FLAGS_ATTACH_PROPERTIES ),
                             CurrentFrameNumber,
                             hXspOrKerbFilter,
                             &FrameDescriptor);
        if( rc == NMERR_EXPERT_TERMINATE )
        {
            // we were terminated
			rc = FALSE;
            goto Exit;
        }
        if( rc != NMERR_SUCCESS )
        {
            // we failed to get a frame, break out of the loop
            break;
        }

        // got a frame, which one?
        CurrentFrameNumber = FrameDescriptor.FrameNumber;

        // update our status if we need to
        CurrentPercentDone = (BYTE)(CurrentFrameNumber * 100 / (TotalFrames * 2));
        if( CurrentPercentDone > ReportedPercentDone )
        {
            // new number
            rc = ExpertIndicateStatus( hExpertKey, 
                                         EXPERTSTATUS_RUNNING,
                                         0,
                                         "",
                                         CurrentPercentDone);
            ReportedPercentDone = CurrentPercentDone;
            if( rc == NMERR_EXPERT_TERMINATE )
            {
                // we were terminated
				rc = FALSE;
				goto Exit;
            }
        }

		GetFrameSourceAddress(FrameDescriptor.hFrame, &SourceIPAddr, ADDRESS_TYPE_IP, 0);
		GetFrameDestAddress(FrameDescriptor.hFrame, &DestIPAddr, ADDRESS_TYPE_IP, 0);


		// Build the set of boxes that are known to have communicated with the
		// specified Xbox
		if(CurrentConfig.fGetIntervalStats)
		{
			if(SourceIPAddr == SpecifiedXboxIPAddress)
				SpecificXboxEndpointTrafficMap[DestIPAddr] = EmptyAddressMap;

			if(DestIPAddr == SpecifiedXboxIPAddress)
				SpecificXboxEndpointTrafficMap[SourceIPAddr] = EmptyAddressMap;
		}

		// Get the protocol type and depending on the type of packet, we can identify
		// whether this indicates an Xbox or an SG
		if(pCurrentProperty = FindPropertyInstance(FrameDescriptor.hFrame, hKeyExTypeProp))
		{
			WORD *pwKeyExType = (WORD *) (pCurrentProperty->lpData);
			BOOL fWellKnownSG = FALSE;

			// If this is a well-known IP for an SG, then mark it as such
			// TODO - Add well-known IP's for other environments
			if((PARTNERNETSG == *((DWORD *) &(DestIPAddr.IPAddress))) ||
				(PRODUCTIONSG == *((DWORD *) &(DestIPAddr.IPAddress))))
			{
				XboxIpAddresses[SourceIPAddr] = EmptyTrafficData;
				SgIpAddresses[DestIPAddr] = EmptyTrafficData;
				fWellKnownSG = TRUE;
			}
			else if((PARTNERNETSG == *((DWORD *) &(SourceIPAddr.IPAddress))) ||
				(PRODUCTIONSG == *((DWORD *) &(SourceIPAddr.IPAddress))))
			{
				SgIpAddresses[SourceIPAddr] = EmptyTrafficData;
				XboxIpAddresses[DestIPAddr] = EmptyTrafficData;
				fWellKnownSG = TRUE;
			}

			// If we don't actually recognize the SG address, then 
			if(!fWellKnownSG)
			{
				switch(*pwKeyExType)
				{
				case KEYEX_TYPE_XBTOXB_INIT:
				case KEYEX_TYPE_XBTOXB_RESP:
				case KEYEX_TYPE_QOS_INIT:
				case KEYEX_TYPE_QOS_RESP:
				case KEYEX_TYPE_NATOPEN_RESP:
					XboxIpAddresses[DestIPAddr] = EmptyTrafficData;
					XboxIpAddresses[SourceIPAddr] = EmptyTrafficData;
					break;

				case KEYEX_TYPE_XBTOSG_INIT:
					XboxIpAddresses[SourceIPAddr] = EmptyTrafficData;
					SgIpAddresses[DestIPAddr] = EmptyTrafficData;
					break;

				case KEYEX_TYPE_SGTOXB_RESP:
					SgIpAddresses[SourceIPAddr] = EmptyTrafficData;
					XboxIpAddresses[DestIPAddr] = EmptyTrafficData;
					break;

				default:
					break;
				}
			}

		}

		// TODO: This is were the expert actually uses the frame 
		// returned by either sending an event or recording information
		// for a summary type event later.
	} while( rc == NMERR_SUCCESS );


    // -----------------------------------------------------------------------
    // LOOP 2 - calcualte traffic statistics
    CurrentFrameNumber = -1;
    do
    {
		LPPROPERTYINST pCurrentProperty = NULL;
		EXPERTFRAMEDESCRIPTOR FrameDescriptor;
		FLOAT   CurrentAverage = 0;
		__int64 CurrentFrameTimeStamp = 0, CurrentFrameInterval = 0;
		DATARECORDEDFORTIMESTAMP   SumNSec;
		DWORD   dwAvgNSec = 0;
		DWORD   dwNewEncrypt = 0, dwNewVoice = 0, dwNewTotal = 0;
		BOOL    fNewData = FALSE, fToFromSG = FALSE;

        // get the next frame which passes both the user's filter and ours
        rc = ExpertGetFrame( hExpertKey,
                             GET_FRAME_NEXT_FORWARD,
                             ( FLAGS_DEFER_TO_UI_FILTER | 
                               FLAGS_ATTACH_PROPERTIES ),
                             CurrentFrameNumber,
                             hXspOrKerbFilter,
                             &FrameDescriptor);
        if( rc == NMERR_EXPERT_TERMINATE )
        {
            // we were terminated
			rc = FALSE;
			goto Exit;
        }
        if( rc != NMERR_SUCCESS )
        {
            // we failed to get a frame, break out of the loop
            break;
        }

		CurrentFrameTimeStamp = GetFrameTimeStamp(FrameDescriptor.hFrame);
		CurrentFrameTimeStamp += FirstFrameOffset;

        // got a frame, which one?
        CurrentFrameNumber = FrameDescriptor.FrameNumber;

        // update our status if we need to
		// TODO - fix this to accurately reflect progress
        CurrentPercentDone = (BYTE)((CurrentFrameNumber + TotalFrames) * 100 / (TotalFrames * 2));
        if( CurrentPercentDone > ReportedPercentDone )
        {
            // new number
            rc = ExpertIndicateStatus( hExpertKey, 
                                         EXPERTSTATUS_RUNNING,
                                         0,
                                         "",
                                         CurrentPercentDone);
            ReportedPercentDone = CurrentPercentDone;
            if( rc == NMERR_EXPERT_TERMINATE )
            {
                // we were terminated
				rc = FALSE;
				goto Exit;
			}
		}

		// Get the source and destination of this frame
		GetFrameSourceAddress(FrameDescriptor.hFrame, &SourceIPAddr, ADDRESS_TYPE_IP, 0);
		GetFrameDestAddress(FrameDescriptor.hFrame, &DestIPAddr, ADDRESS_TYPE_IP, 0);

		// If this packet was sent to or from an SG, then don't calculate averages
		if((SgIpAddresses.find(SourceIPAddr) != SgIpAddresses.end())
			|| (SgIpAddresses.find(DestIPAddr) != SgIpAddresses.end()))
		{
			fToFromSG =TRUE;
		}
		else
		{
			fToFromSG = FALSE;
		}

		// Get the final Xbox address marker so that we can tell if we detect
		// a given Xbox IP address
		EndAddress = XboxIpAddresses.end();

		if(!fToFromSG)
		{
			// First detect QoS packets and update the counters
			if(pCurrentProperty = FindPropertyInstance(FrameDescriptor.hFrame, hKeyExTypeProp))
			{
				WORD *pwKeyExType = (WORD *) (pCurrentProperty->lpData); 

				switch(*pwKeyExType)
				{
				case KEYEX_TYPE_QOS_INIT:
					// Retrieve the entry for the source Xbox and update it
					CurrentAddress = XboxIpAddresses.find(SourceIPAddr);
					if(CurrentAddress != EndAddress)
					{
						++(CurrentAddress->second.dwOutgoingQosRequests);
					}

					// Retrieve the entry for the dest Xbox and update it
					CurrentAddress = XboxIpAddresses.find(DestIPAddr);
					if(CurrentAddress != EndAddress)
					{
						++(CurrentAddress->second.dwIncomingQosRequests);
					}
					break;

				case KEYEX_TYPE_QOS_RESP:
					// Retrieve the entry for the source Xbox and update it
					CurrentAddress = XboxIpAddresses.find(SourceIPAddr);
					if(CurrentAddress != EndAddress)
					{
						++(CurrentAddress->second.dwOutgoingQosReplies);
					}

					// Retrieve the entry for the dest Xbox and update it
					CurrentAddress = XboxIpAddresses.find(DestIPAddr);
					if(CurrentAddress != EndAddress)
					{
						++(CurrentAddress->second.dwIncomingQosReplies);
					}
					break;

				default:
					break;
				}
			}
		}

		dwNewEncrypt = dwNewVoice = dwNewTotal = 0;
		fNewData = FALSE;

		// Next detect encrypted data and update the counters
		if(pCurrentProperty = FindPropertyInstance(FrameDescriptor.hFrame, hEncryptData))
		{
			fNewData = TRUE;
			dwNewEncrypt = (DWORD) pCurrentProperty->DataLength;
		}

		// Next detect voice data and update the counters
		if(pCurrentProperty = FindPropertyInstance(FrameDescriptor.hFrame, hVoiceData))
		{
			fNewData = TRUE;
			dwNewVoice = (DWORD) pCurrentProperty->DataLength;
		}

		// Next if this is an XSP packet, update the counters for total data sent and received
		if(FindPropertyInstance(FrameDescriptor.hFrame, hSPI))
		{
			if(pCurrentProperty = FindPropertyInstance(FrameDescriptor.hFrame, hTotalData))
			{
				fNewData = TRUE;
				dwNewTotal = (DWORD) (htons(*(pCurrentProperty->lpWord)));
			}

		}

		// Now sum if necessary and compute the new averages
		if(fNewData)
		{
			NMADDRESSMAP::iterator  SourceAddress, DestAddress;

			if(!fToFromSG)
			{

				// Find the source
				SourceAddress = XboxIpAddresses.find(SourceIPAddr);
				if(SourceAddress == XboxIpAddresses.end())
				{
					XboxIpAddresses[SourceIPAddr] = EmptyTrafficData;
					SourceAddress = XboxIpAddresses.find(SourceIPAddr);
				}

				// Find the destination
				DestAddress = XboxIpAddresses.find(DestIPAddr);
				if(DestAddress == XboxIpAddresses.end())
				{
					XboxIpAddresses[DestIPAddr] = EmptyTrafficData;
					DestAddress = XboxIpAddresses.find(DestIPAddr);
				}

				// If we're calculating moving averages
				if(CurrentConfig.fGetMovingAverage)
				{
					DATARECORDEDFORTIMESTAMP *pNewSourceSum, *pNewDestSum, TempSum;
					NMDATAHISTORYMAP::iterator CurrentTime;

					// Retrieve the data history for the source and destination
					CurrentTime = SourceAddress->second.DataHistoryMap.find(CurrentFrameTimeStamp);
					if(CurrentTime != SourceAddress->second.DataHistoryMap.end())
					{
						pNewSourceSum = &(CurrentTime->second);
					}
					else
					{
						TempSum.ClearValues();
						SourceAddress->second.DataHistoryMap[CurrentFrameTimeStamp] = TempSum;
						CurrentTime = SourceAddress->second.DataHistoryMap.find(CurrentFrameTimeStamp);
						pNewSourceSum = &(CurrentTime->second);
					}

					CurrentTime = DestAddress->second.DataHistoryMap.find(CurrentFrameTimeStamp);
					if(CurrentTime != DestAddress->second.DataHistoryMap.end())
					{
						pNewDestSum = &(CurrentTime->second);
					}
					else
					{
						TempSum.ClearValues();
						DestAddress->second.DataHistoryMap[CurrentFrameTimeStamp] = TempSum;
						CurrentTime = DestAddress->second.DataHistoryMap.find(CurrentFrameTimeStamp);
						pNewDestSum = &(CurrentTime->second);
					}

					// Add any new encrypt, voice or total data for the source and dest
					if(dwNewEncrypt)
					{
						(pNewSourceSum->dwOutgoingEncrypt) += dwNewEncrypt;
						(pNewDestSum->dwIncomingEncrypt) += dwNewEncrypt;
						SourceAddress->second.dwOutgoingEncryptData += dwNewEncrypt;
						DestAddress->second.dwIncomingEncryptData += dwNewEncrypt;
					}

					if(dwNewVoice)
					{
						(pNewSourceSum->dwOutgoingVoice) += dwNewVoice;
						(pNewDestSum->dwIncomingVoice) += dwNewVoice;
						SourceAddress->second.dwOutgoingVoiceData += dwNewVoice;
						DestAddress->second.dwIncomingVoiceData += dwNewVoice;
					}

					if(dwNewTotal)
					{
						(pNewSourceSum->dwOutgoingTotal) += dwNewTotal;
						(pNewDestSum->dwIncomingTotal) += dwNewTotal;
						SourceAddress->second.dwOutgoingVoiceData += dwNewTotal;
						DestAddress->second.dwIncomingVoiceData += dwNewTotal;
					}

					// Remove old frames if necessary
					if(CurrentFrameTimeStamp > (CurrentConfig.dwMovingAverageSizeValue * NMONESECOND))
					{
						RemoveOlderThan(SourceAddress->second.DataHistoryMap,
							CurrentFrameTimeStamp - (CurrentConfig.dwMovingAverageSizeValue * NMONESECOND));

						RemoveOlderThan(DestAddress->second.DataHistoryMap,
							CurrentFrameTimeStamp - (CurrentConfig.dwMovingAverageSizeValue * NMONESECOND));
					}

					// -----------------------------------------------------------------------
					// Calculate the new sums for the source
					SumSince(SourceAddress->second.DataHistoryMap,
						CurrentFrameTimeStamp, &SumNSec);

					dwAvgNSec = SumNSec.dwOutgoingEncrypt / CurrentConfig.dwMovingAverageSizeValue;

					if(dwAvgNSec > SourceAddress->second.dwMaxOutgoingEncryptRate)
						SourceAddress->second.dwMaxOutgoingEncryptRate = dwAvgNSec;

					dwAvgNSec = SumNSec.dwOutgoingVoice / CurrentConfig.dwMovingAverageSizeValue;

					if(dwAvgNSec > SourceAddress->second.dwMaxOutgoingVoiceRate)
						SourceAddress->second.dwMaxOutgoingVoiceRate = dwAvgNSec;

					dwAvgNSec = SumNSec.dwOutgoingTotal / CurrentConfig.dwMovingAverageSizeValue;

					if(dwAvgNSec > SourceAddress->second.dwMaxOutgoingTotalRate)
						SourceAddress->second.dwMaxOutgoingTotalRate = dwAvgNSec;

					// -----------------------------------------------------------------------
					// Calculate the new sums for the destination
					SumSince(DestAddress->second.DataHistoryMap,
						CurrentFrameTimeStamp, &SumNSec);

					dwAvgNSec = SumNSec.dwIncomingEncrypt / CurrentConfig.dwMovingAverageSizeValue;

					if(dwAvgNSec > DestAddress->second.dwMaxIncomingEncryptRate)
						DestAddress->second.dwMaxIncomingEncryptRate = dwAvgNSec;

					dwAvgNSec = SumNSec.dwIncomingVoice / CurrentConfig.dwMovingAverageSizeValue;

					if(dwAvgNSec > DestAddress->second.dwMaxIncomingVoiceRate)
						DestAddress->second.dwMaxIncomingVoiceRate = dwAvgNSec;

					dwAvgNSec = SumNSec.dwIncomingTotal / CurrentConfig.dwMovingAverageSizeValue;

					if(dwAvgNSec > DestAddress->second.dwMaxIncomingTotalRate)
						DestAddress->second.dwMaxIncomingTotalRate = dwAvgNSec;
				} 
			} //!fToFromSG

			// If we're calculating for a specific Xbox per interval
			if(CurrentConfig.fGetIntervalStats)
			{
				BOOL fSpecifiedXboxIsSource = FALSE;
				NMINTERVALMAP::iterator CurrentEndpoint, AggregateEndpoint;
				NMDATAHISTORYMAP::iterator CurrentTime, AggregateTime;
				DATARECORDEDFORTIMESTAMP *pNewEndpointSum, *pNewAggregateSum, TempSum;
				CurrentInterval = CalculateCurrentInterval(CurrentFrameTimeStamp, CurrentConfig.dwIntervalSizeValue);

				// If the source is the specified Xbox
				if(SourceIPAddr == SpecifiedXboxIPAddress)
				{
					fSpecifiedXboxIsSource = TRUE;
					CurrentEndpoint = SpecificXboxEndpointTrafficMap.find(DestIPAddr);
				}
				// If the dest is the specified Xbox
				else if(DestIPAddr == SpecifiedXboxIPAddress)
				{
					fSpecifiedXboxIsSource = FALSE;
					CurrentEndpoint = SpecificXboxEndpointTrafficMap.find(SourceIPAddr);
				}
				else
					continue;

				if(CurrentEndpoint == SpecificXboxEndpointTrafficMap.end())
					continue;

				AggregateEndpoint = SpecificXboxEndpointTrafficMap.find(AggregateIPPlaceholder);

				// Retrieve the data history for the specific endpoint
				CurrentTime = CurrentEndpoint->second.find(CurrentInterval);
				if(CurrentTime != CurrentEndpoint->second.end())
				{
					pNewEndpointSum = &(CurrentTime->second);
				}
				else
				{
					TempSum.ClearValues();
					CurrentEndpoint->second[CurrentInterval] = TempSum;
					CurrentTime = CurrentEndpoint->second.find(CurrentInterval);
					pNewEndpointSum = &(CurrentTime->second);
				}

				// Retrieve the data history for the specific endpoint
				AggregateTime = AggregateEndpoint->second.find(CurrentInterval);
				if(AggregateTime != AggregateEndpoint->second.end())
				{
					pNewAggregateSum = &(AggregateTime->second);
				}
				else
				{
					TempSum.ClearValues();
					AggregateEndpoint->second[CurrentInterval] = TempSum;
					AggregateTime = AggregateEndpoint->second.find(CurrentInterval);
					pNewAggregateSum = &(AggregateTime->second);
				}

				if(CurrentConfig.fIntervalStatsEncrypt)
				{
					// Add any new encrypt, voice or total data for the source and dest
					if(dwNewEncrypt)
					{
						if(fSpecifiedXboxIsSource)
						{
							(pNewEndpointSum->dwOutgoingEncrypt) += dwNewEncrypt;
							(pNewAggregateSum->dwOutgoingEncrypt) += dwNewEncrypt;
						}
						else
						{
							(pNewEndpointSum->dwIncomingEncrypt) += dwNewEncrypt;
							(pNewAggregateSum->dwIncomingEncrypt) += dwNewEncrypt;
						}
					}
				}

				if(CurrentConfig.fIntervalStatsVoice)
				{
					if(dwNewVoice)
					{
						if(fSpecifiedXboxIsSource)
						{
							(pNewEndpointSum->dwOutgoingVoice) += dwNewVoice;
							(pNewAggregateSum->dwOutgoingVoice) += dwNewVoice;
						}
						else
						{
							(pNewEndpointSum->dwIncomingVoice) += dwNewVoice;
							(pNewAggregateSum->dwIncomingVoice) += dwNewVoice;
						}
					}
				}

				if(CurrentConfig.fIntervalStatsTotal)
				{
					if(dwNewTotal)
					{
						if(fSpecifiedXboxIsSource)
						{
							(pNewEndpointSum->dwOutgoingTotal) += dwNewTotal;
							(pNewAggregateSum->dwOutgoingTotal) += dwNewTotal;
						}
						else
						{
							(pNewEndpointSum->dwIncomingTotal) += dwNewTotal;
							(pNewAggregateSum->dwIncomingTotal) += dwNewTotal;
						}
					}
				}

			}// fNewData
		}

	} while( rc == NMERR_SUCCESS );

	if(CurrentConfig.fGetCumulative || CurrentConfig.fGetMovingAverage)
	{
		// -----------------------------------------------------------------------
		// Calculate the number of columns required for the Xbox summary event
		CalcXboxSummaryColumns(&dwColumnCount, &CurrentConfig);

		// -----------------------------------------------------------------------
		// Allocate and initialize the Xbox summary event
		if(!InitXboxSummaryEvent(hExpertKey, dwColumnCount, &CurrentConfig, &pXboxSummaryEvent))
		{
			goto CantAllocMem;
		}

		// -----------------------------------------------------------------------
		// Loop through the Xbox IP's we found and display events for them
		XboxCounter = (DWORD) XboxIpAddresses.size();
		for(CurrentAddress = XboxIpAddresses.begin(), EndAddress = XboxIpAddresses.end();
			CurrentAddress != EndAddress;
			++CurrentAddress)
		{
			dwCurrentColumn = 0;

			pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val = XboxCounter--;
			pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.IPAddrVal = *((DWORD *) CurrentAddress->first.IPAddress);

			if(CurrentConfig.fGetCumulative)
			{
				if(CurrentConfig.fCumulativeEncrypt)
				{
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwIncomingEncryptData * 8 :
					CurrentAddress->second.dwIncomingEncryptData;
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwOutgoingEncryptData * 8 :
					CurrentAddress->second.dwOutgoingEncryptData;
				}

				if(CurrentConfig.fCumulativeVoice)
				{
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwIncomingVoiceData * 8 :
					CurrentAddress->second.dwIncomingVoiceData;
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwOutgoingVoiceData * 8 :
					CurrentAddress->second.dwOutgoingVoiceData;
				}

				if(CurrentConfig.fCumulativeTotal)
				{
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwIncomingTotalData * 8 :
					CurrentAddress->second.dwIncomingTotalData;
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwOutgoingTotalData * 8 :
					CurrentAddress->second.dwOutgoingTotalData;
				}
			}

			if(CurrentConfig.fGetMovingAverage)
			{
				if(CurrentConfig.fMovingAverageEncrypt)
				{
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwMaxIncomingEncryptRate * 8 :
					CurrentAddress->second.dwMaxIncomingEncryptRate;

					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwMaxOutgoingEncryptRate * 8 :
					CurrentAddress->second.dwMaxOutgoingEncryptRate;
				}

				if(CurrentConfig.fMovingAverageVoice)
				{
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwMaxIncomingVoiceRate * 8 :
					CurrentAddress->second.dwMaxIncomingVoiceRate;

					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val = 
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwMaxOutgoingVoiceRate * 8 :
					CurrentAddress->second.dwMaxOutgoingVoiceRate;
				}

				if(CurrentConfig.fMovingAverageTotal)
				{
					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwMaxIncomingTotalRate * 8 :
					CurrentAddress->second.dwMaxIncomingTotalRate;

					pXboxSummaryEvent->Column[dwCurrentColumn++].VariantData.Value.Uint32Val =
						CurrentConfig.fBitsPerSecond ?
						CurrentAddress->second.dwMaxOutgoingTotalRate * 8 :
					CurrentAddress->second.dwMaxOutgoingTotalRate;
				}
			}

			rc = ExpertSubmitEvent(hExpertKey, pXboxSummaryEvent);
			if( rc != NMERR_SUCCESS )
			{
				goto CantSubmitEvent;
			}
		}
	}

	if(CurrentConfig.fGetIntervalStats)
	{
		// -----------------------------------------------------------------------
		// Allocate and initialize the interval detail event
		if(!InitIntervalDetailEvent(hExpertKey, &CurrentConfig, &SpecificXboxEndpointTrafficMap, &SgIpAddresses, &pIntervalDetailEvent))
		{
			goto CantAllocMem;
		}

		// -----------------------------------------------------------------------
		// Loop through the intervals in reverse order (so they appear from chronologically
		// top to bottom in the expert)
		for(CurrentInterval = IntervalsCount - 1; CurrentInterval >= 0; --CurrentInterval)
		{
			NMINTERVALMAP::iterator CurrentEndpoint;
			dwCurrentColumn = 0;
			// For each interval, loop through all of the endpoints and store the
			// amount of data encountered

			pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) CurrentInterval + 1;

			for(CurrentEndpoint = SpecificXboxEndpointTrafficMap.begin(),
				dwCurrentColumn = 1;
				CurrentEndpoint != SpecificXboxEndpointTrafficMap.end();
				++CurrentEndpoint)
			{
				NMDATAHISTORYMAP::iterator CurrentTime;
				dwCurrentOutgoingEncrypt = dwCurrentIncomingEncrypt = 0;
				dwCurrentOutgoingVoice = dwCurrentIncomingVoice = 0;
				dwCurrentOutgoingTotal = dwCurrentIncomingTotal = 0;

				CurrentTime = CurrentEndpoint->second.find(CurrentInterval);
				if(CurrentTime != CurrentEndpoint->second.end())
				{
					dwCurrentOutgoingEncrypt = CurrentTime->second.dwOutgoingEncrypt;
					dwCurrentIncomingEncrypt = CurrentTime->second.dwIncomingEncrypt;
					dwCurrentOutgoingVoice = CurrentTime->second.dwOutgoingVoice;
					dwCurrentIncomingVoice = CurrentTime->second.dwIncomingVoice;
					dwCurrentOutgoingTotal = CurrentTime->second.dwOutgoingTotal;
					dwCurrentIncomingTotal = CurrentTime->second.dwIncomingTotal;
				}
				else
				{
					dwCurrentOutgoingEncrypt = dwCurrentIncomingEncrypt = 0;
					dwCurrentOutgoingVoice = dwCurrentIncomingVoice = 0;
					dwCurrentOutgoingTotal = dwCurrentIncomingTotal = 0;
				}

				if(CurrentConfig.fIntervalStatsEncrypt)
				{
					pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) (CurrentConfig.fBitsPerSecond ? dwCurrentOutgoingEncrypt * 8 : dwCurrentOutgoingEncrypt);
					dwCurrentColumn++;
				}

				if(CurrentConfig.fIntervalStatsVoice)
				{
					// We want to skip SG voice columns
					if(SgIpAddresses.find(CurrentEndpoint->first) == SgIpAddresses.end())
					{
						pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) (CurrentConfig.fBitsPerSecond ? dwCurrentOutgoingVoice * 8 : dwCurrentOutgoingVoice);
						dwCurrentColumn++;
					}
				}

				if(CurrentConfig.fIntervalStatsTotal)
				{
					pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) (CurrentConfig.fBitsPerSecond ? dwCurrentOutgoingTotal * 8 : dwCurrentOutgoingTotal);
					dwCurrentColumn++;
				}

				if(CurrentConfig.fIntervalStatsEncrypt)
				{
					pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) (CurrentConfig.fBitsPerSecond ? dwCurrentIncomingEncrypt * 8 : dwCurrentIncomingEncrypt);
					dwCurrentColumn++;
				}

				if(CurrentConfig.fIntervalStatsVoice)
				{
					// We want to skip SG voice columns
					if(SgIpAddresses.find(CurrentEndpoint->first) == SgIpAddresses.end())
					{
						pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) (CurrentConfig.fBitsPerSecond ? dwCurrentIncomingVoice * 8 : dwCurrentIncomingVoice);
						dwCurrentColumn++;
					}
				}

				if(CurrentConfig.fIntervalStatsTotal)
				{
					pIntervalDetailEvent->Column[dwCurrentColumn].VariantData.Value.Uint32Val = (DWORD) (CurrentConfig.fBitsPerSecond ? dwCurrentIncomingTotal * 8 : dwCurrentIncomingTotal);
					dwCurrentColumn++;
				}
			}

			if(pIntervalDetailEvent->NumColumns > 26)
			{
				pIntervalDetailEvent->NumColumns = 26;
				MessageBox(hwnd, TEXT("More than 26 columns were generated by this report.  Only the first 26 columns can be displayed by Netmon.  Consider running the expert on a filtered capture that contains fewer Xboxes."), TEXT("Too many columns!"), MB_OK);
			}

			rc = ExpertSubmitEvent(hExpertKey, pIntervalDetailEvent);
			if( rc != NMERR_SUCCESS )
			{
				goto CantSubmitEvent;
			}
		}
	}


Exit:

    // -----------------------------------------------------------------------
    // we are done

	// clean up events
//	if(pXboxSummaryEvent) ExpertFreeMemory(hExpertKey, pXboxSummaryEvent);
//	if(pIntervalDetailEvent) ExpertFreeMemory(hExpertKey, pIntervalDetailEvent);
//	if(g_pIntervalIPStrings) ExpertFreeMemory(hExpertKey, g_pIntervalIPStrings);

	// clean up filters
	if(hXspOrKerbFilter) DestroyFilter( hXspOrKerbFilter );

    return rc;

ReportErrorStatus:
	// -----------------------------------------------------------------------
	// by this point the status string has been loaded, just report the status and exit
	ExpertIndicateStatus( hExpertKey, 
		EXPERTSTATUS_PROBLEM,
		0,
		g_StatusString,
		0);
	rc = FALSE;
	goto Exit;

CantCreateFilter:
	// -----------------------------------------------------------------------
	// we can't make a filter
	LoadStringA(g_hInstance, IDS_CANTCREATEFILTER, g_StatusString, MAX_PATH);
	goto ReportErrorStatus;

CantAddToFilter:
	// -----------------------------------------------------------------------
	// can't add to the filter
	LoadStringA(g_hInstance, IDS_CANTADDTOFILTER, g_StatusString, MAX_PATH);
	goto ReportErrorStatus;

CantAllocMem:
	// -----------------------------------------------------------------------
	// can't allocate memory

	LoadStringA(g_hInstance, IDS_CANTALLOCMEM, g_StatusString, MAX_PATH);
	goto ReportErrorStatus;

CantSubmitEvent:
	// -----------------------------------------------------------------------
	// can't submit event
	LoadStringA(g_hInstance, IDS_CANTSUBMITEVENT, g_StatusString, MAX_PATH);
	goto ReportErrorStatus;

XspParserProblem:
	// -----------------------------------------------------------------------
	// Xsp parser problem, either not installed or an older version
	LoadStringA(g_hInstance, IDS_XSPPARSERNOTPRESENT, g_StatusString, MAX_PATH);
	goto ReportErrorStatus;

KerberosParserProblem:
	// -----------------------------------------------------------------------
	// Kerberos parser problem, either not installed or an older version
	LoadStringA(g_hInstance, IDS_KERBEROSPARSERNOTPRESENT, g_StatusString, MAX_PATH);
	goto ReportErrorStatus;
}

// -----------------------------------------------------------------------
// Helper functions
// -----------------------------------------------------------------------

// -----------------------------------------------------------------------
// Calculate the number of columns required for the Xbox summary event
void CalcXboxSummaryColumns(DWORD *pdwColumnCount, PXLEXPERTCONFIG pCurrentConfig)
{
	(*pdwColumnCount) = 2;

	if(pCurrentConfig->fGetCumulative)
	{
		if(pCurrentConfig->fCumulativeEncrypt)
		{
			(*pdwColumnCount) += 2;
		}

		if(pCurrentConfig->fCumulativeVoice)
		{
			(*pdwColumnCount) += 2;
		}

		if(pCurrentConfig->fCumulativeTotal)
		{
			(*pdwColumnCount) += 2;
		}
	}

	if(pCurrentConfig->fGetMovingAverage)
	{
		if(pCurrentConfig->fMovingAverageEncrypt)
		{
			(*pdwColumnCount) += 2;				
		}

		if(pCurrentConfig->fMovingAverageVoice)
		{
			(*pdwColumnCount) += 2;
		}

		if(pCurrentConfig->fMovingAverageTotal)
		{
			(*pdwColumnCount) += 2;
		}
	}
}

// -----------------------------------------------------------------------
// Initialize the Xbox summary event
BOOL InitXboxSummaryEvent(HEXPERTKEY hExpertKey, DWORD dwColumnCount, PXLEXPERTCONFIG pCurrentConfig, PNMEVENTDATA *ppXboxSummaryEvent)
{
	DWORD rc = 0;

    *ppXboxSummaryEvent = (PNMEVENTDATA)ExpertAllocMemory( hExpertKey,
                                              sizeof(NMEVENTDATA) +
                                              dwColumnCount * sizeof(NMCOLUMNINFO),
                                              &rc);
    if( *ppXboxSummaryEvent == NULL )
    {
		return FALSE;
    }

    // -----------------------------------------------------------------------
    // fill the Xbox summary event data

    (*ppXboxSummaryEvent)->Version      = 0;
    (*ppXboxSummaryEvent)->EventIdent   = 1;
    (*ppXboxSummaryEvent)->Flags        = NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS;
    (*ppXboxSummaryEvent)->Severity     = NMEVENT_SEVERITY_INFORMATIONAL;
    memset( &((*ppXboxSummaryEvent)->SysTime), 0, sizeof(SYSTEMTIME));
    (*ppXboxSummaryEvent)->Justification= NULL;
    (*ppXboxSummaryEvent)->szSourceName = g_ExpertName;
    LoadStringA(g_hInstance, IDS_SUMMARYEVENTNAME, g_XboxSummaryEventName, MAX_PATH);
    (*ppXboxSummaryEvent)->szEventName  = g_XboxSummaryEventName;
    (*ppXboxSummaryEvent)->szDescription= g_BitsOrBytesPerSecond;
    (*ppXboxSummaryEvent)->szMachine    = NULL;

	// We always at least display the Xbox IP address and order of appearance
	// Increment this value as we add new columns
    (*ppXboxSummaryEvent)->NumColumns   = 0;

    LoadStringA(g_hInstance, IDS_XBOXNUMBER, g_XboxNumber, MAX_PATH);
    (*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_XboxNumber;
    (*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

	LoadStringA(g_hInstance, IDS_XBOXIPADDR, g_XboxIpAddr, MAX_PATH);
    (*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_XboxIpAddr;
    (*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_IPADDR;

	if(pCurrentConfig->fGetCumulative)
	{
		if(pCurrentConfig->fCumulativeEncrypt)
		{
			sprintf(g_InEncrypt, "Encrypt inbound (%s)",
				pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_InEncrypt;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

			sprintf(g_OutEncrypt, "Encrypt outbound (%s)",
				pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_OutEncrypt;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;
		}

		if(pCurrentConfig->fCumulativeVoice)
		{
			sprintf(g_InVoice, "Voice inbound (%s)",
				pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_InVoice;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

			sprintf(g_OutVoice, "Voice outbound (%s)",
				pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_OutVoice;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;
		}

		if(pCurrentConfig->fCumulativeTotal)
		{
			sprintf(g_InTotal, "Total data inbound (%s)",
				pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_InTotal;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

			sprintf(g_OutTotal, "Total data outbound (%s)",
				pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_OutTotal;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;
		}
	}

	if(pCurrentConfig->fGetMovingAverage)
	{
		if(pCurrentConfig->fMovingAverageEncrypt)
		{
			sprintf(g_InEncryptNSecAvg, "Max encrypt inbound %u sec avg (%s)",
				pCurrentConfig->dwMovingAverageSizeValue,
				pCurrentConfig->fBitsPerSecond ? "bps" : "byps");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_InEncryptNSecAvg;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

			sprintf(g_OutEncryptNSecAvg, "Max encrypt outbound %u sec avg (%s)", 
				pCurrentConfig->dwMovingAverageSizeValue,
				pCurrentConfig->fBitsPerSecond ? "bps" : "byps");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_OutEncryptNSecAvg;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;
		}

		if(pCurrentConfig->fMovingAverageVoice)
		{
			sprintf(g_InVoiceNSecAvg, "Max voice inbound %u sec avg (%s)",
				pCurrentConfig->dwMovingAverageSizeValue,
				pCurrentConfig->fBitsPerSecond ? "bps" : "byps");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_InVoiceNSecAvg;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

			sprintf(g_OutVoiceNSecAvg, "Max voice outbound %u sec avg (%s)",
				pCurrentConfig->dwMovingAverageSizeValue,
				pCurrentConfig->fBitsPerSecond ? "bps" : "byps");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_OutVoiceNSecAvg;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;
		}

		if(pCurrentConfig->fMovingAverageTotal)
		{
			sprintf(g_InTotalNSecAvg, "Max total inbound %u sec avg (%s)",
				pCurrentConfig->dwMovingAverageSizeValue,
				pCurrentConfig->fBitsPerSecond ? "bps" : "byps");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_InTotalNSecAvg;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;

			sprintf(g_OutTotalNSecAvg, "Max total outbound %u sec avg (%s)",
				pCurrentConfig->dwMovingAverageSizeValue,
				pCurrentConfig->fBitsPerSecond ? "bps" : "byps");
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns].szColumnName = g_OutTotalNSecAvg;
			(*ppXboxSummaryEvent)->Column[(*ppXboxSummaryEvent)->NumColumns++].VariantData.Type = NMCOLUMNTYPE_UINT32;
		}
	}

	return TRUE;
}

// -----------------------------------------------------------------------
// Initialize the Xbox summary event
BOOL InitIntervalDetailEvent(HEXPERTKEY hExpertKey, PXLEXPERTCONFIG pCurrentConfig, NMINTERVALMAP *pSpecificXboxEndpointTrafficMap, NMADDRESSMAP *pSGIPAddresses, PNMEVENTDATA *ppIntervalDetailEvent)
{
	DWORD rc = 0, dwColumnCount = 0, dwCurrentColumn = 0, dwXboxCounter = 0, dwColumnsPerDest = 0;
	NMINTERVALMAP::iterator CurrentEndpoint;
	NMADDRESSMAP::iterator CurrentSG;
	DWORD dwColumnType = 0, dwCurrentXboxIndex = 0, dwCurrentSGIndex = 0;

	// For each of encrypted, voice and total data being recorded per interval, we will need
	// an additional 2 columns per destination
	if(pCurrentConfig->fIntervalStatsEncrypt)
		dwColumnsPerDest += 2;

	if(pCurrentConfig->fIntervalStatsVoice)
		dwColumnsPerDest += 2;

	if(pCurrentConfig->fIntervalStatsTotal)
		dwColumnsPerDest += 2;

	// Calculate the number of columns required
	// The first column will be the interval number itself
	dwColumnCount = (DWORD) (dwColumnsPerDest * pSpecificXboxEndpointTrafficMap->size()) + 1;

	// If we're calculating Voice interval stats, then remove 2 columns for every SG since there's no
	// point in measuring voice data with SG's
	if(pCurrentConfig->fIntervalStatsVoice)
	{
		for(CurrentSG = pSGIPAddresses->begin();
			CurrentSG != pSGIPAddresses->end();
			CurrentSG++)
		{
			if(pSpecificXboxEndpointTrafficMap->find(CurrentSG->first) != pSpecificXboxEndpointTrafficMap->end())
			{
				dwColumnCount -= 2;
			}
		}
	}

	// TODO - popup a message box if there were too many Xboxes detected
	if(dwColumnCount > 255)
		return FALSE;

    *ppIntervalDetailEvent = (PNMEVENTDATA)ExpertAllocMemory( hExpertKey,
                                              sizeof(NMEVENTDATA) +
                                              dwColumnCount * sizeof(NMCOLUMNINFO),
                                              &rc);
    if( *ppIntervalDetailEvent == NULL )
    {
		return FALSE;
    }

    // -----------------------------------------------------------------------
    // fill the Xbox summary event data

    (*ppIntervalDetailEvent)->Version      = 0;
    (*ppIntervalDetailEvent)->EventIdent   = 2;
    (*ppIntervalDetailEvent)->Flags        = NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS;
    (*ppIntervalDetailEvent)->Severity     = NMEVENT_SEVERITY_INFORMATIONAL;
    memset( &((*ppIntervalDetailEvent)->SysTime), 0, sizeof(SYSTEMTIME));
    (*ppIntervalDetailEvent)->Justification= NULL;
    (*ppIntervalDetailEvent)->szSourceName = g_ExpertName;
    LoadStringA(g_hInstance, IDS_INTERVALTRAFFICEVENTNAME, g_IntervalTrafficEventName, MAX_PATH);
    (*ppIntervalDetailEvent)->szEventName  = g_IntervalTrafficEventName;
    (*ppIntervalDetailEvent)->szDescription= g_BitsOrBytesPerSecond;
    (*ppIntervalDetailEvent)->szMachine    = NULL;

	// We always at least display the Xbox IP address and order of appearance
	// Increment this value as we add new columns
    (*ppIntervalDetailEvent)->NumColumns  = (BYTE) dwColumnCount;

	// Allocate space to hold all of the strings
    g_pIntervalIPStrings = (CHAR *)ExpertAllocMemory( hExpertKey,
                                              (dwColumnCount - 1) * MAX_ENDPOINTCOLUMN_SIZE,
                                              &rc);
    if( g_pIntervalIPStrings == NULL )
    {
		return FALSE;
    }

	memset(g_pIntervalIPStrings, 0, (dwColumnCount - 1) * MAX_ENDPOINTCOLUMN_SIZE);

	LoadStringA(g_hInstance, IDS_INTERVAL, g_Interval, MAX_PATH);
	(*ppIntervalDetailEvent)->Column[0].szColumnName = g_Interval;
	(*ppIntervalDetailEvent)->Column[0].VariantData.Type = NMCOLUMNTYPE_UINT32;

	for(CurrentEndpoint = pSpecificXboxEndpointTrafficMap->begin(),
		dwCurrentColumn = 1,
		dwCurrentXboxIndex = 1,
		dwCurrentSGIndex = 1;
		CurrentEndpoint != pSpecificXboxEndpointTrafficMap->end();
		CurrentEndpoint++)
	{
		IN_ADDR TempInAddr;

		TempInAddr.S_un.S_addr = *((DWORD *) &(CurrentEndpoint->first.IPAddress));

		// Loop through all the potential column types and add those entries if they
		// were requested in the config data
		for(dwColumnType = 0; dwColumnType < MAX_INTERVAL_COLUMN_TYPE; ++dwColumnType)
		{
			if(((ENCRYPTED_COLUMN_TYPE == dwColumnType) &&
				!(pCurrentConfig->fIntervalStatsEncrypt)) ||
				((VOICE_COLUMN_TYPE == dwColumnType) &&
				!(pCurrentConfig->fIntervalStatsVoice)) ||
				((TOTAL_COLUMN_TYPE == dwColumnType) &&
				!(pCurrentConfig->fIntervalStatsTotal)))
			{
				// The current column type wasn't requested in the config data
				continue;
			}

			if(!TempInAddr.S_un.S_addr)
			{
				sprintf(g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE),
					"%s Aggregate Out (%s)",
					g_szIntervalColumnTypeStrings[dwColumnType],
					pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			}
			else if(pSGIPAddresses->find(CurrentEndpoint->first) != pSGIPAddresses->end())
			{
				// Don't log SG voice columns
				if(VOICE_COLUMN_TYPE == dwColumnType)
					continue;

				// Add the "To SG<Index>" column for each individual Xbox destination
				sprintf(g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE),
					"%s To SG at %u.%u.%u.%u (%s)",
					g_szIntervalColumnTypeStrings[dwColumnType],
					TempInAddr.S_un.S_un_b.s_b1,
					TempInAddr.S_un.S_un_b.s_b2,
					TempInAddr.S_un.S_un_b.s_b3,
					TempInAddr.S_un.S_un_b.s_b4,
					pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			}
			else
			{
				// Add the "To Xbox<Index>" column for each individual Xbox destination
				sprintf(g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE),
					"%s To Xbox at %u.%u.%u.%u (%s)",
					g_szIntervalColumnTypeStrings[dwColumnType],
					TempInAddr.S_un.S_un_b.s_b1,
					TempInAddr.S_un.S_un_b.s_b2,
					TempInAddr.S_un.S_un_b.s_b3,
					TempInAddr.S_un.S_un_b.s_b4,
					pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			}

			(*ppIntervalDetailEvent)->Column[dwCurrentColumn].szColumnName = g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE);
			(*ppIntervalDetailEvent)->Column[dwCurrentColumn].VariantData.Type = NMCOLUMNTYPE_UINT32;

			++dwCurrentColumn;
		}

		for(dwColumnType = 0; dwColumnType < MAX_INTERVAL_COLUMN_TYPE; ++dwColumnType)
		{
			if(((ENCRYPTED_COLUMN_TYPE == dwColumnType) &&
				!(pCurrentConfig->fIntervalStatsEncrypt)) ||
				((VOICE_COLUMN_TYPE == dwColumnType) &&
				!(pCurrentConfig->fIntervalStatsVoice)) ||
				((TOTAL_COLUMN_TYPE == dwColumnType) &&
				!(pCurrentConfig->fIntervalStatsTotal)))
			{
				// The current column type wasn't requested in the config data
				continue;
			}

			if(!TempInAddr.S_un.S_addr)
			{
				sprintf(g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE),
					"%s Aggregate In (%s)",
					g_szIntervalColumnTypeStrings[dwColumnType],
					pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			}
			else if(pSGIPAddresses->find(CurrentEndpoint->first) != pSGIPAddresses->end())
			{
				// Don't log SG voice columns
				if(VOICE_COLUMN_TYPE == dwColumnType)
					continue;

				// Add the "To SG<Index>" column for each individual Xbox destination
				sprintf(g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE),
					"%s From SG at %u.%u.%u.%u (%s)",
					g_szIntervalColumnTypeStrings[dwColumnType],
					TempInAddr.S_un.S_un_b.s_b1,
					TempInAddr.S_un.S_un_b.s_b2,
					TempInAddr.S_un.S_un_b.s_b3,
					TempInAddr.S_un.S_un_b.s_b4,
					pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");
			}
			else
			{
				// Add the "To Xbox<Index>" column for each individual Xbox destination
				sprintf(g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE),
					"%s From Xbox at %u.%u.%u.%u (%s)",
					g_szIntervalColumnTypeStrings[dwColumnType],
					TempInAddr.S_un.S_un_b.s_b1,
					TempInAddr.S_un.S_un_b.s_b2,
					TempInAddr.S_un.S_un_b.s_b3,
					TempInAddr.S_un.S_un_b.s_b4,
					pCurrentConfig->fBitsPerSecond ? "bits" : "bytes");

			}
			(*ppIntervalDetailEvent)->Column[dwCurrentColumn].szColumnName = g_pIntervalIPStrings + ((dwCurrentColumn - 1) * MAX_ENDPOINTCOLUMN_SIZE);
			(*ppIntervalDetailEvent)->Column[dwCurrentColumn].VariantData.Type = NMCOLUMNTYPE_UINT32;

			++dwCurrentColumn;
		}

		if(TempInAddr.S_un.S_addr)
		{
			if(pSGIPAddresses->find(CurrentEndpoint->first) != pSGIPAddresses->end())
			{
				// Increment the SG counter
				++dwCurrentSGIndex;
			}
			else
			{
				// Increment the Xbox counter
				++dwCurrentXboxIndex;
			}
		}
	}

	return TRUE;
}

// -----------------------------------------------------------------------
// Build the XSP/Kerberos Netmon filter
BOOL CreateXspOrKerbFilter(HFILTER *phXspOrKerbFilter, HPROTOCOL hXsp, HPROTOCOL hKerberos)
{
	FILTEROBJECT2 FilterObj;
	DWORD rc = 0;

    // Add filtering for XSP
    memset( &FilterObj, 0, sizeof(FILTEROBJECT) );
    FilterObj.Action = FILTERACTION_PROTOCOLEXIST;
    FilterObj.hProtocol = hXsp;

    rc = FilterAddObject( *phXspOrKerbFilter, &FilterObj);
    if( rc != NMERR_SUCCESS )
    {
		return FALSE;
    }

    // Add filtering for Kerberos
    memset( &FilterObj, 0, sizeof(FILTEROBJECT) );
    FilterObj.Action = FILTERACTION_PROTOCOLEXIST;
    FilterObj.hProtocol = hKerberos;

    rc = FilterAddObject( *phXspOrKerbFilter, &FilterObj);
    if( rc != NMERR_SUCCESS )
    {
		return FALSE;
    }

    // Link the filters with an OR
    memset( &FilterObj, 0, sizeof(FILTEROBJECT) );
    FilterObj.Action = FILTERACTION_OR;

    rc = FilterAddObject( *phXspOrKerbFilter, &FilterObj);
    if( rc != NMERR_SUCCESS )
    {
		return FALSE;
    }

	return TRUE;
}

// -----------------------------------------------------------------------
// Given a filter, calculate both the offset of the first frame (if it has
// a negative time) and the duration of the capture
BOOL CalculateCaptureIntervalInfo(HEXPERT hExpertKey, HFILTER hFilter, DWORD dwFramesCount, __int64 *pFirstFrameOffset, __int64 *pCaptureDuration, DWORD dwIntervalSize, __int64 *pIntervalsCount){
	__int64 FirstFrameTimeStamp = 0;
	__int64 LastFrameTimeStamp = 0;
	DWORD CurrentFrameNumber = 0, rc = 0;
	EXPERTFRAMEDESCRIPTOR FrameDescriptor;

	*pIntervalsCount = *pFirstFrameOffset = *pCaptureDuration = 0;
	
	// Get the first frame in the capture
	CurrentFrameNumber = 0xFFFFFFFF;
	rc = ExpertGetFrame( hExpertKey, GET_FRAME_NEXT_FORWARD,
		( FLAGS_DEFER_TO_UI_FILTER | FLAGS_ATTACH_PROPERTIES ),
		CurrentFrameNumber, hFilter, &FrameDescriptor);
	if( rc != NMERR_SUCCESS )
	{
		return FALSE;
	}

	FirstFrameTimeStamp = GetFrameTimeStamp(FrameDescriptor.hFrame);
	*pFirstFrameOffset = 0 - FirstFrameTimeStamp;

	// Get the last frame in the capture
	CurrentFrameNumber = dwFramesCount;
	rc = ExpertGetFrame( hExpertKey, GET_FRAME_NEXT_BACKWARD,
		( FLAGS_DEFER_TO_UI_FILTER | FLAGS_ATTACH_PROPERTIES ),
		CurrentFrameNumber, hFilter, &FrameDescriptor);
	if( rc != NMERR_SUCCESS )
	{
		return FALSE;
	}

	LastFrameTimeStamp = GetFrameTimeStamp(FrameDescriptor.hFrame);

	*pCaptureDuration = LastFrameTimeStamp - FirstFrameTimeStamp;
	*pIntervalsCount =  (__int64) (*pCaptureDuration / (dwIntervalSize * NMONESECOND)) + 1;

	return TRUE;
}

__int64 CalculateCurrentInterval(__int64 CurrentFrameTimeStamp, DWORD dwIntervalSize)
{
	return (CurrentFrameTimeStamp / (dwIntervalSize * NMONESECOND));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\EventGrabber\LogGrabber.cs ===
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Runtime;


namespace EventGrabber
{
	/// <summary>
	/// Summary description for LogGrabber.
	/// </summary>
	public class LogGrabber
	{
		public string machineName="127.0.0.1";
		public TextWriter outStream=System.Console.Out;
		public TextWriter infoStream=System.Console.Out;
		public TextWriter progressStream=System.Console.Error;
		EventLog myLog;
		string	[]interestingPhrases={"appdomain",
									   "blacklist",
									   "restarted",
									   "memory",
										"asp.net"};

		void FindLog()
		{
			EventLog []logs=EventLog.GetEventLogs(machineName);
			foreach (EventLog el in logs)
			{
				if (el.LogDisplayName=="Application")
				{
					myLog=el;
					return;
				}
			}
			throw new ApplicationException("Can't find 'Application' log!");
		}

		public LogGrabber()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public void Go()
		{
			const string filter="The log entry contains the following replacement strings:";
			int filterSize=filter.Length;
			FindLog();
			int total=myLog.Entries.Count;
			int counter=0;

			foreach(EventLogEntry ele in myLog.Entries)
			{
				counter++;
				StringBuilder SB=new StringBuilder(2048);
				string shortMessage=ele.Message;
				int filterStart=shortMessage.IndexOf(filter);
				int filterEnd=shortMessage.Length-filterStart-filterSize-1;
				if (filterStart>-1 && filterEnd>0)
				{
					shortMessage=shortMessage.Substring(filterStart+filterSize+1,filterEnd);
				}
					
				shortMessage=shortMessage.Replace('|','');
				shortMessage=shortMessage.Replace("\n","\t");
				shortMessage=shortMessage.Replace("\r","\t");
				
				SB.Append(ele.TimeWritten+" | ");
				SB.Append(ele.Source+" | ");
				SB.Append(ele.CategoryNumber+" | ");
				SB.Append(ele.EventID+" | ");
				SB.Append(shortMessage+"\n");

				bool interestingMessage=false;
				string lowerMessage=shortMessage.ToLower();
				string lowerSource=ele.Source.ToLower();
				foreach (string phrase in interestingPhrases)
				{
					if (lowerMessage.IndexOf(phrase)!=-1 || lowerSource.IndexOf(phrase)!=-1)
					{
						interestingMessage=true;
						break;
					}
				}

				if (interestingMessage)
				{
					infoStream.Write(SB.ToString());
				}
				
				outStream.Write(SB.ToString());

				if (counter%20==0)
				{
					double percentDone=(double)counter/(double)total*100.0;
					progressStream.Write(percentDone.ToString("F2")+"% done\r");
					progressStream.Flush();
					outStream.Flush();
					infoStream.Flush();
				}
			}
			progressStream.Write("100.00% done\n");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\GeneInfo.cpp ===
//#include <xtl.h>
#include <stdio.h>
#include <xapip.h>
#include <winbasep.h>
#include <rc4.h>
#include <sha.h>
#include <xdbg.h>
#include <xboxp.h>
#include <XbDm.h>
#include "hardware.h"
#include <xapip.h>
#include "xboxvideo.h"
#include "constants.h"

#define BREAK_INTO_DEBUGGER     _asm { int 3 }

int   m_xKeypos;
int   m_yKeypos;
Key   m_keyPad[DISPLAY_NUM_COLS][DISPLAY_NUM_ROWS];           // Keypad
CONST PCHAR SZDATAFILE = "t:\\Genealogy.log";
bool g_bLoop = TRUE;
CXBoxVideo g_x;
WCHAR g_szSerialNumber[120]= L"\0";
INT   g_iSerialNumberIndex = 1;


void GenerateKeypad(void);
HRESULT DrawScreen( void );
HRESULT WriteGenelogyLog( void );



void __cdecl main()
{
   //BREAK_INTO_DEBUGGER;
   g_x.Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
   
   
   do {
      DrawScreen();
      ProcessInput();
   } while ( g_bLoop == TRUE );
   g_x.DeInitialize();
   
   WriteGenelogyLog();

   // Reboot this baby!
   DmReboot(DMBOOT_WARM);
	return;
}



void GenerateKeypad(void) 
{
   // First create numberpad
   int xgrid  = 3;
   int ygrid  = 4;
   int xstart = 210;
   int ystart = KEYPAD_TOPROW_Y1; // 234;
   int width  = 32;
   int height = 32;
   int spacer = 2;

   int currentx = xstart;
   int currenty = ystart;

   for (int y = 0; y < ygrid; y++) {
      for (int x = 0; x < xgrid; x++) {
         m_keyPad[x][y].define( currentx, currenty, width, height, COLOR_YELLOW );
         currentx += width + spacer;
      }
      currentx = xstart;
      currenty += height + spacer;
   }


   // Second generate side larger buttons for OK CANCEL etc.
   int xbase  = xgrid;
   xgrid  = 1;
   ygrid  = 4;
   xstart = 323;
   ystart = KEYPAD_TOPROW_Y1; // 234;
   width  = 103;
   height = 32;
   spacer = 2;

   currentx = xstart;
   currenty = ystart;
   for (y = 0; y < ygrid; y++) {
      for (int x = xbase; x < (xbase + xgrid); x++) {
         m_keyPad[x][y].define( currentx, currenty, width, height, COLOR_LIME_GREEN );
         currentx += width + spacer;

         // clear out placeholder
         if (y == 1) m_keyPad[x][y].setRender(false);
         if (y == 2) m_keyPad[x][y].setRender(false);
         if (y == 3) m_keyPad[x][y].setRender(false);
      }
      currentx = xstart;
      currenty += height + spacer;
   }


   // Set the text of the keys
   m_keyPad[0][0].defineText(L"1");  m_keyPad[1][0].defineText(L"2");  m_keyPad[2][0].defineText(L"3");
   m_keyPad[0][1].defineText(L"4");  m_keyPad[1][1].defineText(L"5");  m_keyPad[2][1].defineText(L"6");
   m_keyPad[0][2].defineText(L"7");  m_keyPad[1][2].defineText(L"8");  m_keyPad[2][2].defineText(L"9");
   m_keyPad[0][3].defineText(L".");  m_keyPad[1][3].defineText(L"0");  m_keyPad[2][3].defineText(L"");
   m_keyPad[3][0].defineText(L"ok");
   m_keyPad[3][1].defineText(L"placeholder");
   m_keyPad[3][2].defineText(L"placeholder");
   m_keyPad[3][3].defineText(L"placeholder");
}


// Draw our screen

HRESULT DrawScreen( void )
{

   
   g_x.ClearScreen( SCREEN_DEFAULT_BACKGROUND_COLOR );
   
   // draw the number we are building on screen
   g_x.DrawText( 150, 
                 70, 
                 SCREEN_DEFAULT_TEXT_FG_COLOR, 
                 COLOR_LIME_GREEN, 
                 L"Enter the serial number please");
   g_x.DrawText( 170, 
                 100, 
                 SCREEN_DEFAULT_TEXT_FG_COLOR, 
                 COLOR_WHITE, 
                 L"%s", g_szSerialNumber);


   // Render outlines of keys	
   float x1, x2;
   float y1, y2;
   GenerateKeypad();
   for (int x = 0; x < KEYPAD_NUM_ROWS; x++) {
      for (int y = 0; y < KEYPAD_NUM_COLS; y++) {
         if (m_keyPad[x][y].getRender()){
            
            x1 = (float)m_keyPad[x][y].xorigin;
            x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);

            y1 = (float)m_keyPad[x][y].yorigin;
            y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);

            g_x.DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );


            // hilight key if currently selected
            DWORD dwCharColor;
            if ((m_xKeypos == x) && (m_yKeypos == y)) {
               // Draw the selector box around the currently highlighted number
               g_x.DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );

               dwCharColor = ITEM_SELECTED_TEXT_COLOR;
            } else {
               dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
            }

            unsigned int decent;
            unsigned int fontHeight;
            g_x.GetFontSize( &fontHeight, &decent );

            float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - g_x.GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
            float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
            g_x.DrawText( textX, textY, dwCharColor, COLOR_WHITE, L"%s", m_keyPad[x][y].resultChar);

         }
      }
   }
   g_x.ShowScreen();
   return S_OK;
}

	

HRESULT WriteGenelogyLog( void )
{


	CHAR szBuffer[ 1024 ];
	CHAR szDiskModelNumber[ 60 ];
	CHAR szDiskSerialNumber[ 60 ];
   HANDLE h;
	DWORD dwNumberOfBytesWritten;
	DWORD dwNumberOfBytesToWrite;
   
   ZeroMemory(szDiskModelNumber,60);
   ZeroMemory(szDiskSerialNumber,60);
   
   h = CreateFile ( SZDATAFILE, 
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_WRITE,
					 NULL,
					 CREATE_ALWAYS,
					 FILE_ATTRIBUTE_NORMAL,
					 NULL);


	IntelCPUID CPUID;
   GetIntelCPUID( &CPUID);
   _snprintf( szDiskModelNumber, HalDiskModelNumber->Length, 
              "%s",
              HalDiskModelNumber->Buffer);

   _snprintf( szDiskSerialNumber, HalDiskSerialNumber->Length, 
              "%s",
              HalDiskSerialNumber->Buffer); 
  
   sprintf(szBuffer, // + strlen(szBuffer),
             "Model  %s\r\nSerial %s\r\nCpuId: %lu %lu %lu \r\nS/N: %S\r\n\0",
             szDiskModelNumber,
             szDiskSerialNumber,
             CPUID.high, CPUID.mid ,CPUID.low,
             g_szSerialNumber); 

   dwNumberOfBytesToWrite = strlen(szBuffer);
   WriteFile( h, 
              szBuffer,
              dwNumberOfBytesToWrite,
              &dwNumberOfBytesWritten, 
              NULL );
   CloseHandle(h);

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\EventGrabber\Main.cs ===
// Current owner: reljam
// 7/28/2003

using System;
using System.IO;

namespace EventGrabber
{
	/// <summary>
	/// Summary description for Main.
	/// </summary>
	public class MainClass
	{
		static public void Main(string []args)
		{
			try
			{
				LogGrabber lg=new LogGrabber();
				if (args.Length==0)
				{
					Usage();
					return;
				}
				if (args.Length>=1)
				{
					lg.outStream=new StreamWriter(args[0]);
				}
				else
				{
					MemoryStream ms=new MemoryStream();
					lg.outStream=new StreamWriter(ms);
				}
				if (args.Length>=2)
				{
					lg.machineName=args[1];
				}

				lg.Go();
			}
			catch(Exception e)
			{
				Console.Error.WriteLine(e.ToString());
			}
		}

		static public void Usage()
		{
			Console.WriteLine("EventGrabber [outputFile], [machineName]\n");
			Console.WriteLine("Formats & writes all events from machineName (defaults to localhost) into outputFile.");
			Console.WriteLine("Any interesting events will be dumped to stdout. All messages will be processed so as to fit into one line, and the output file will be | separated (Excel will read that).");
			Console.WriteLine("If no outputFile is specified, only interesting events will be dumped to stdOut.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>

#define KEYPAD_NUM_ROWS    4
#define KEYPAD_NUM_COLS    4
#define DISPLAY_NUM_ROWS    4
#define DISPLAY_NUM_COLS    4

#define APP_TITLE_NAME_A                        "XShell"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Menubox constants
#define MENUBOX_MAINAREA_X1                     102.0f
#define MENUBOX_MAINAREA_Y1                     135.0f
#define MENUBOX_MAINAREA_X2                     536.0f
#define MENUBOX_MAINAREA_Y2                     367.0f

#define MENUBOX_TITLEBAR_TEXT_XPOS              127.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1 + 5.0f
#define MENUBOX_SELECTBAR_X2                    MENUBOX_MAINAREA_X2 - 5.0f

#define MENUBOX_TEXT_TOP_BORDER                   2.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 9.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 4.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER)
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

// Display Settings Menu constants
#define DISPSETMENU_VIDEOHEADER_YPOS            149.0f      // Also in dispset.mnu file -- must be identical

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FONT_ALIAS_LEVEL                        4

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR
#define SCREEN_DEFAULT_TRANS_COLOR              SCREEN_DEFAULT_BACKGROUND_COLOR

// Settings Menu contants - These should match the numbers in 'settings.mnu'
#define SETTINGSMENU_OPTIONHEADER_COLOR          COLOR_DARK_GREEN2 // COLOR_MEDIUM_GREEN
#define SETTINGSMENU_VIDSET_YPOS                 173.0f
#define SETTINGSMENU_VIDSET_TEXT                 L"Video :"
#define SETTINGSMENU_IPADDR_YPOS                 249.0f
#define SETTINGSMENU_IPADDR_TEXT                 L"IP address :"
#define SETTINGSMENU_SUBNET_YPOS                 277.0f
#define SETTINGSMENU_SUBNET_TEXT                 L"Subnet mask :"
#define SETTINGSMENU_GATEWY_YPOS                 305.0f
#define SETTINGSMENU_GATEWY_TEXT                 L"Gateway :"
#define SETTINGSMENU_MANAME_YPOS                 334.0f
#define SETTINGSMENU_MANAME_TEXT                 L"Machine name :"

static float g_fSettingsItemYPos[] = {
    SETTINGSMENU_VIDSET_YPOS,             // Item 0
    SETTINGSMENU_IPADDR_YPOS,             // Item 1
    SETTINGSMENU_SUBNET_YPOS,             // Item 2
    SETTINGSMENU_GATEWY_YPOS,             // Item 3
    SETTINGSMENU_MANAME_YPOS              // Item 4
};

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              MENUBOX_MAINAREA_Y2 + 20.0f // ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 40.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      18
#define MENU_LAUNCH_MACHINENAME_COLOR           SCREEN_DEFAULT_TEXT_FG_COLOR
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  114     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  126     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                114     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                361     // Bitmaps, use int

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_DARK_GREEN2
#define ITEM_SELECTED_HEADER_COLOR              COLOR_YELLOW
#define ITEM_SELECTED_VALUE_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_SELECTED_TEXT_COLOR                SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_XBELIST_FONT_HEIGHT                17
#define ITEM_FORMATMU_FONT_HEIGHT               17

// MU Format Dlg constants
#define MUFORMATDLG_SCREEN_DIM_VALUE            0x8F000000 // MMX way - 0x00707070
#define MUFORMATDLG_UNAVAIL_MU_COLOR            COLOR_DARK_GREEN2
#define MUFORMATDLG_AVAIL_MU_COLOR              SCREEN_DEFAULT_TEXT_FG_COLOR
#define MUFORMATDLG_SELECTED_MU_COLOR           ITEM_SELECTED_TEXT_COLOR
#define MUFORMATDLG_DELETE_MSG_YPOS             164.0f
#define MUFORMATDLG_DELETE_MSG                  L"All data will be erased from"
#define MUFORMATDLG_FORMATTING_MSG              L"Formatting..."
#define MUFORMATDLG_SUCCESS_MSG                 L"Format Successful!"
#define MUFORMATDLG_FAIL_MSG                    L"Format Failed!"
#define MUFORMATDLG_MSG_PAUSE                   1500

// Error Message Menu constants
#define ERRORMSGMENU_BUTTON1_TEXT               L"ok"
#define ERRORMSGMENU_MSG_FG_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ERRORMSGMENU_MSG_BG_COLOR               SCREEN_DEFAULT_TEXT_BG_COLOR
#define ERRORMSGMENU_MSG_YPOS                   189.0f

// Keypad and Keyboard location information
#define KEYBOARD_LINE_WIDTH                     1.0f
#define KEYPAD_LINE_WIDTH                       1.0f
#define KEYBOARD_TOPROW_Y1                      210
#define KEYPAD_TOPROW_Y1                        210
#define MENU_DISPSET_BUTTON_Y1                  186
#define MUFORMATDLG_BUTTON_Y1                   250
#define MUFORMATDLG_BUTTON_X1                   265
#define ERRORMSGMENU_BUTTON_Y1                  270
#define ERRORMSGMENU_BUTTON_X1                  265
#define KEYBOARD_MACHINENAMEHEADER_XPOS         153.0f                  // Must be identical to data in 'machine.mnu'
#define KEYBOARD_MACHINENAMEHEADER_YPOS         159.0f                  // Must be identical to data in 'machine.mnu'
#define KEYPAD_IPADDRHEADER_TEXT                L"IP address :"         // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_XPOS                191.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_YPOS                159.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'


// File path and location constants
#define FILE_EXECUTABLE_DEVICE_PATH_A           "\\Device\\Harddisk0\\Partition1"
#define FILE_EXECUTABLE_DRIVE_A                 "c:"
#define FILE_EXECUTABLE_PATH_A                  "\\devkit"
#define FILE_EXECUTABLE_DIRECTORY_A             FILE_EXECUTABLE_DRIVE_A FILE_EXECUTABLE_PATH_A
#define FILE_EXECUTABLE_ALIAS_A                 "e:"
#define FILE_EXECUTABLE_EXENSION_A              ".XBE"
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

#define FILE_DATA_SETTINGS_FILENAME_A           "c:\\devkit\\xbdm.ini"
#define FILE_DATA_SETTINGS_SECTION_NAME_A       "[xbdm]"
#define FILE_DATA_SETTINGS_IP_TOKEN_A           "staticip addr="
#define FILE_DATA_SETTINGS_SUBNET_TOKEN_A       "subnetmask addr="
#define FILE_DATA_SETTINGS_GATEWAY_TOKEN_A      "defgateway addr="
#define FILE_DATA_SETTINGS_MACHINENAME_TOKEN_A  "dbgname name="
#define FILE_SPLASHSCREEN_LOCATION_A            FILE_DATA_IMAGE_DIRECTORY_A "\\loading.bmp"

// Data value limits
#define DATAVALUE_IPADDRESS_LENGTH              15
#define DATAVALUE_MACHINENAME_LENGTH            20
#define DATAVALUE_DISPLAYSETTING_TEXT_LENGTH    20

// Screen Saver
#define SCREEN_SAVER_TIMEOUT                    600000  // 10 minutes, 1200000 <-- 20 minutes
#define SCREEN_SAVER_UPDATE_INTERVAL            30000   // 30 seconds
#define SCREEN_SAVER_IMAGE                      FILE_DATA_IMAGE_DIRECTORY_A "\\abutton.bmp"
#define SCREEN_SAVER_BACK_COLOR                 COLOR_BLACK

// Controller and XBox Port and Slot Information
#define NUM_XBOX_PORTS                          4
#define NUM_XBOX_MU_SLOTS                       8
#define NUM_DUKE_BUTTONS                        8
#define NUM_DUKE_CONTROLS                       8
#define NUM_DUKE_SLOTS                          2

// Display Settings
enum XBoxDisplaySettings
{
    DISPLAY_SETTING_NONE        = 0,
    DISPLAY_SETTING_MONITOR     = 1,
    DISPLAY_SETTING_NTSC_M      = 2,
    DISPLAY_SETTING_NTSC_J,
    DISPLAY_SETTING_PAL_M       = 4,
    DISPLAY_SETTING_PAL_A,              // PAL B, D, G, H, I
    DISPLAY_SETTING_PAL_N,
    DISPLAY_SETTING_PAL_NC,
    DISPLAY_SETTING_NTSC_M_COMP = 10,
    DISPLAY_SETTING_PAL_M_COMP  = 12
};

// Joystick and Button Dead Zone and Threshold info
#define JOYSTICK_DEAD_ZONE                      20000       // 0 - 32768
#define BUTTON_THRESHOLD                        50          // 0 - 255

enum DisplaySettings
{
    ENUM_DISPSET_TEXT_MONITOR = 0,
    ENUM_DISPSET_TEXT_NTSC_SV,
    ENUM_DISPSET_TEXT_NTSC_C,
    ENUM_DISPSET_TEXT_PAL_SV,
    ENUM_DISPSET_TEXT_PAL_C    
};

// Memory Unit BitMasks used for detection
static DWORD g_dwMUBitMask[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};

static WCHAR* g_wpszMUPortNames[] = {
    L"Controller 1 - Top Slot",
    L"Controller 1 - Bottom Slot",
    L"Controller 2 - Top Slot",
    L"Controller 2 - Bottom Slot",
    L"Controller 3 - Top Slot",
    L"Controller 3 - Bottom Slot",
    L"Controller 4 - Top Slot",
    L"Controller 4 - Bottom Slot"
};

// Display Settings
static WCHAR* g_wpszDISPLAYSETTINGS[] = {
    L"Monitor",
    L"NTSC (S-Video)",
    L"NTSC (Composite)",
    L"PAL (S-Video)",
    L"PAL (Composite)"
};

// XShell Menu Identifiers
enum XShellMenuIds
{
    ENUM_SHELLMENUID_LAUNCH = 0,
    ENUM_SHELLMENUID_SETTINGS,
    ENUM_SHELLMENUID_MEMORY,
    ENUM_SHELLMENUID_SETTINGS_MACHINENAME,
    ENUM_SHELLMENUID_SETTINGS_GATEWAY,
    ENUM_SHELLMENUID_SETTINGS_IPADDRESS,
    ENUM_SHELLMENUID_SETTINGS_DISPLAY
};

// XShell States (bit mask)
#define SHELLSTATE_NORMAL       0
#define SHELLSTATE_ERROR        1
#define SHELLSTATE_NOCONFIG     2

// XShell Errors
// This list should stay in sync with the "g_wpszERRORCODEMSG" list
#define ERRORCODE_NO_ERROR          0
#define ERRORCODE_INVALID_XBE       1
#define ERRORCODE_UNKNOWN_ERROR     2

// This list should stay in sync with the "ERRORCODE" defines
static WCHAR* g_wpszERRORCODEMSG[] = {
    L"No Error Has Occurred",
    L"An Error Occurred Loading an XBox Executable",
    L"An Unknown Error Has Occurred"
};

// Screen item locations
#define ITEM_MACHINENAME_DATA_X                 ( ( ( MENUBOX_SELECTBAR_X2 - MENUBOX_SELECTBAR_X1 ) / 2.0f ) + MENUBOX_SELECTBAR_X1 - 17.0F )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\Hardware.h ===
#ifndef _HARDWARE_H
#define _HARDWARE_H

//
// This structure holds the Intel CPU Serial Number
//
typedef struct _IntelCPUID
{
    DWORD low;
    DWORD mid;
    DWORD high;
} IntelCPUID;


void GetIntelCPUID( IntelCPUID* pCPUID );
HRESULT ProcessInput( void );

// Handle the Joystick Input
void 
HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, bool bFirstYPress, bool bFirstXPress );

// Handles input (of the CONTROLS) for the current menu
void 
HandleInput( enum CONTROLS controlPressed, 
             bool bFirstPress );

// Handles input (of the BUTTONS) for the current menu
void 
HandleInput( enum BUTTONS buttonPressed, 
             bool bFirstPress );



#endif  _HARDWARE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    01-13-2000  Modified   JNH

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "stdafx.h"
#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
   DWORD insertions, insertions2;
   unsigned i, j;
   unsigned port, slot;

   //Initialize core peripheral port support
   XInitDevices(0,NULL);

   pollingParameters.fAutoPoll = 1;
   pollingParameters.fInterruptOut = 0;
   pollingParameters.ReservedMBZ1 = 0;
   pollingParameters.bInputInterval = 8;  
   pollingParameters.bOutputInterval = 8;
   pollingParameters.ReservedMBZ2 = 0;

   // make sure the usb schema has not changed on us
   // ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());
   if ( ARRAYSIZE( XIDMasks ) != XGetPortCount() ) {
      XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager():XIDMasks != XGetPortCount!" );
      XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager():Will break in to debugger in 60 seconds..." );

      Sleep( 60000 );
      BREAK_INTO_DEBUGGER;
   }

   // initialize
   for (i=0; i<XGetPortCount(); i++) {
      for (j=0; j<SLOT_MAX; j++) {
         devices[i][j] = NULL;
         packetNum[i][j] = 1234;
      }
   }

   // look for game pads
   insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
   for (i=0; i<XGetPortCount(); i++) {
      port = i%XGetPortCount();
      if (insertions & XIDMasks[i]) {
         devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
      }
   }
}


USBManager::~USBManager()
{
   unsigned i, j;

   for (i=0; i<XGetPortCount(); i++) {
      for (j=0; j<SLOT_MAX; j++) {
         if (devices[i][j] != NULL) {
            if ( XDEVICE_TYPE_GAMEPAD == devices[i][j]->type ) {
               delete (DeviceDuke*)devices[i][j];
            }

            devices[i][j] = NULL;
         }
      }
   }
}


void USBManager::CheckForHotplugs( void )
{
   DWORD addDuke, removeDuke;
   unsigned slot, port;
   unsigned i, j;

   // check for game controllers (insert & removal)
   XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

   for ( i=0; i < XGetPortCount(); i++ ) {
      port = i % XGetPortCount();

      if ( removeDuke & XIDMasks[i] ) {
         delete (DeviceDuke*)devices[i][0];
         devices[i][0] = NULL;
      }

      if ( addDuke & XIDMasks[i] ) {
         devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );
      }
   }
}

bool USBManager::IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress /*=NULL*/)
{
   // Make sure we have a duke at the current location, otherwise return false
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return false;
      }
   }

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke at the current port, skip over it
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         if ( m_ControllerState.bControlPressed[locPort][control] ) {
            // If the user gave us a valid address let's return
            // whether or not it's the first press of the item
            if ( bFirstPress) {
               // If the previous X value was also greater than the deadZone, return
               // false for bFirstPress
               if ( m_PrevControllerState.bControlPressed[locPort][control] ) {
                  *bFirstPress = false;
               } else { // This must be the first press
                  *bFirstPress = true;
               }
            }

            // Return the value of the control
            // This is always true
            return m_ControllerState.bControlPressed[locPort][control];
         }
      }
   } else { // Only check one port
      if ( m_ControllerState.bControlPressed[port][control] ) {
         // If the user gave us a valid address let's return
         // whether or not it's the first press of the item
         if ( bFirstPress) {
            // If the previous X value was also greater than the deadZone, return
            // false for bFirstPress
            if ( m_PrevControllerState.bControlPressed[port][control] ) {
               *bFirstPress = false;
            } else { // This must be the first press
               *bFirstPress = true;
            }
         }

         // Return the value of the control
         // This is always true
         return m_ControllerState.bControlPressed[port][control];
      }
   }

   // If the button wasn't pressed, let's return false
   return false;
}


// Will return true if any button or thumbstick has changed since last poll
bool USBManager::MovementDetected( int port, int deadZone /*=0*/ )
{
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return false;
      }
   }

   XINPUT_STATE state;
   memset( &state, 0, sizeof( XINPUT_STATE ) );

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x ) {
         if ( devices[x][0] == NULL ) {
            continue;
         }

         // Get the state of the current controller
         XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

         // Check the buttons
         for ( unsigned button = 0; button < BUTTON_MAX; ++button ) {
            if ( IsButtonPressed( x, (enum BUTTONS)button, TRUE_ON_REPEAT ) ) {
               return true;
            }
         }

         // Check the controls
         for ( unsigned control = 0; control < CONTROL_MAX; ++control ) {
            if ( IsControlPressed( x, (enum CONTROLS)control, TRUE_ON_REPEAT ) ) {
               return true;
            }
         }

         // Check the Joysticks
         for ( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick ) {
            if ( 0 != GetJoystickX( x, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
               return true;
            }

            if ( 0 != GetJoystickY( x, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
               return true;
            }
         }
      }
   } else { // Only one port
      // Get the state of the current controller
      XInputGetState( ( (DeviceDuke*)devices[port][0])->duke, &state);

      // Check the buttons
      for ( unsigned button = 0; button < BUTTON_MAX; ++button) {
         if ( IsButtonPressed( port, (enum BUTTONS)button, TRUE_ON_REPEAT ) ) {
            return true;
         }
      }

      // Check the controls
      for ( unsigned control = 0; control < CONTROL_MAX; ++control) {
         if ( IsControlPressed( port, (enum CONTROLS)control, TRUE_ON_REPEAT ) ) {
            return true;
         }
      }

      // Check the Joysticks
      for ( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick ) {
         if ( 0 != GetJoystickX( port, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
            return true;
         }

         if ( 0 != GetJoystickY( port, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) ) {
            return true;
         }
      }
   }

   return false;
}


// Will return the X value of the joystick passed in
int USBManager::GetJoystickX( int port, enum JOYSTICK joystick, int deadZone /*=0*/, bool* bFirstPress /*=NULL*/ )
{
   // Make sure we have a duke at the current location, otherwise return 0
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return 0;
      }
   }

   int nReturnVal = 0;

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke in this port, skip to the next port
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         // If the current stick is moved, process the request and return the value!
         if ( abs( m_ControllerState.sThumbX[locPort][joystick] ) > deadZone ) {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if ( bFirstPress) {
               // If the previous Y value was also greater than the deadZone, return
               // false for bFirstPress
               if ( abs( m_PrevControllerState.sThumbX[locPort][joystick] ) > deadZone ) {
                  *bFirstPress = false;
               } else { // This must be the first press
                  *bFirstPress = true;
               }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbX[locPort][joystick];
         }
      }
   } else {    // Check one port only
      // If the current stick is moved, process the request and return the value!
      if ( abs( m_ControllerState.sThumbX[port][joystick] ) > deadZone ) {
         // Determine if the user wishes to know if this is the first time the joystick
         // pressed, or if it's a repeat press
         if ( bFirstPress) {
            // If the previous X value was also greater than the deadZone, return
            // false for bFirstPress
            if ( abs( m_PrevControllerState.sThumbX[port][joystick] ) > deadZone ) {
               *bFirstPress = false;
            } else { // This must be the first press
               *bFirstPress = true;
            }
         }

         // Return the value we got from the joystick
         return m_ControllerState.sThumbX[port][joystick];
      }
   }

   // Return 0 if the joystick was not pushed past the dead zone
   return 0;
}


// Will return the Y value of the joystick passed in
int USBManager::GetJoystickY( int port, enum JOYSTICK joystick, int deadZone /*=0*/, bool* bFirstPress /*=NULL*/ )
{
   // Make sure we have a duke at the current location, otherwise return 0
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return 0;
      }
   }

   int nReturnVal = 0;

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke in this port, skip to the next port
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         // If the current stick is moved, process the request and return the value!
         if ( abs( m_ControllerState.sThumbY[locPort][joystick] ) > deadZone ) {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if ( bFirstPress) {
               // If the previous Y value was also greater than the deadZone, return
               // false for bFirstPress
               if ( abs( m_PrevControllerState.sThumbY[locPort][joystick] ) > deadZone ) {
                  *bFirstPress = false;
               } else { // This must be the first press
                  *bFirstPress = true;
               }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbY[locPort][joystick];
         }
      }
   } else {    // Check one port only
      // If the current stick is moved, process the request and return the value!
      if ( abs( m_ControllerState.sThumbY[port][joystick] ) > deadZone ) {
         // Determine if the user wishes to know if this is the first time the joystick
         // pressed, or if it's a repeat press
         if ( bFirstPress) {
            // If the previous Y value was also greater than the deadZone, return
            // false for bFirstPress
            if ( abs( m_PrevControllerState.sThumbY[port][joystick] ) > deadZone ) {
               *bFirstPress = false;
            } else { // This must be the first press
               *bFirstPress = true;
            }
         }

         // Return the value we got from the joystick
         return m_ControllerState.sThumbY[port][joystick];
      }
   }

   // Return 0 if the joystick was not pushed past the dead zone
   return 0;
}


// Will return TRUE if a button is depressed, or FALSE if it is not
bool USBManager::IsButtonPressed( int port, enum BUTTONS button, int nThreshold /*=0*/, bool* bFirstPress /*=NULL*/ )
{
   // Make sure we have a duke at the current location, otherwise return false
   if ( port != PORT_ANY ) {
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         return false;
      }
   }

   // Check to see if the user wants to find out for ANY port
   if ( port == PORT_ANY ) {
      for ( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort ) {
         // If there is no Duke in this port, skip to the next port
         if ( devices[locPort][SLOT_CONTROLLER] == NULL ) {
            continue;
         }

         // If the button is depressed, determine if the user wishes to know
         // if it's a repeat press
         if ( m_ControllerState.nButtonPress[locPort][button] > nThreshold ) {
            // If the user gave us the address of a boolean variable, we should return to them
            // whether or not this is the first time the button was pressed, or if it's a repeat
            // press
            if ( bFirstPress ) {
               // If in the previous state the button was pressed, return 'false' for bFirstPress
               if ( m_PrevControllerState.nButtonPress[locPort][button] > nThreshold ) {
                  *bFirstPress = false;
               } else { // Otherwise, if the Prev value was false, we need to notify the user it's the first press
                  *bFirstPress = true;
               }
            }

            // Since a button was pressed, return early out of our loop
            return true;
         }
      }
   } else {    // Check one port only
      if ( m_ControllerState.nButtonPress[port][button] > nThreshold ) {
         // If the user gave us the address of a boolean variable, we should return to them
         // whether or not this is the first time the button was pressed, or if it's a repeat
         // press
         if ( bFirstPress ) {
            // If in the previous state the button was pressed, return 'false' for bFirstPress
            if ( m_PrevControllerState.nButtonPress[port][button] > nThreshold ) {
               *bFirstPress = false;
            } else { // Otherwise, if the Prev value was false, we need to notify the user it's the first press
               *bFirstPress = true;
            }
         }
      }

      // Return the value of the button
      // This can be 'true' or 'false'
      return !!m_ControllerState.nButtonPress[port][button];
   }

   // If no button was pressed, let's return false;
   return false;
}

void USBManager::ProcessInput( void )
{
   XINPUT_STATE state;
   memset( &state, 0, sizeof( XINPUT_STATE ) );

   // Store the previous state
   m_PrevControllerState = m_ControllerState;

   // Check to see if any devices were added or removed
   CheckForHotplugs();

   for ( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port ) {
      // Make sure a duke is plugged in
      if ( devices[port][SLOT_CONTROLLER] == NULL ) {
         continue;
      }

      XInputGetState( ( (DeviceDuke*)devices[port][SLOT_CONTROLLER] )->duke, &state );

      // Packet Number
      m_ControllerState.dwControllerState[port] = state.dwPacketNumber;

      // Check the buttons
      for ( unsigned button = 0; button < BUTTON_MAX; ++button) {
         m_ControllerState.nButtonPress[port][button] = state.Gamepad.bAnalogButtons[button];
      }

      // Check the controls
      for ( unsigned control = 0; control < CONTROL_MAX; ++control) {
         m_ControllerState.bControlPressed[port][control] = !!( state.Gamepad.wButtons & ( 1 << control ) );
      }

      // Check the Joysticks
      for ( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick ) {
         m_ControllerState.sThumbX[port][joystick] = state.Gamepad.sThumbLX;
         m_ControllerState.sThumbY[port][joystick] = state.Gamepad.sThumbLY;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define XFONT_TRUETYPE

#include <ntos.h>
#include <xapip.h>
#include <xtl.h>
#include <xfont.h>
#include <xdbg.h>
#include <stdio.h>

//#include "xboxvideo.h"
//#include "usbmanager.h"
//#include "xitem.h"
//#include "xsettings.h"
//#include "imagefile.h"
#include "constants.h"

// Menus and Commands

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\Hardware.cpp ===
#include <stdio.h>
#include <xapip.h>
#include <winbasep.h>
#include <rc4.h>
#include <sha.h>
#include <xdbg.h>
#include <xboxp.h>
#include "Hardware.h"
#include "xboxvideo.h"
#include "usbmanager.h"
#include "constants.h"

USBManager Controllers;
extern Key m_keyPad[DISPLAY_NUM_COLS][DISPLAY_NUM_ROWS];
extern int m_xKeypos;
extern int m_yKeypos;
extern WCHAR g_szSerialNumber[120];
extern INT   g_iSerialNumberIndex;
extern bool g_bLoop;


bool m_bDropKeyPress;  
DWORD          m_keyPressDelayTimer;                // Used to temper the speed of holding down the d-pad
DWORD          m_keyPressDelayInterval;             // The current interval to delay before processing a keypress
int            m_nJoystickDeadZone;                 // The dead zone for the joysticks




void GetIntelCPUID( IntelCPUID* pCPUID )
{
    DWORD cpuid_low = 0;
    DWORD cpuid_mid = 0;
    DWORD cpuid_high = 0;

    _asm {
        mov eax, 1
        _asm cpuid
        //_asm _emit 0x0f   //CPUID instruction
        //_asm _emit 0xa2

        mov  cpuid_high, eax
        
        mov eax, 3
        _asm cpuid
        //_asm _emit 0x0f   //CPUID instruction
        //_asm _emit 0xa2

        mov  cpuid_mid, edx
        mov  cpuid_low, ecx
    }

    pCPUID->low = cpuid_low;
    pCPUID->mid = cpuid_mid;
    pCPUID->high = cpuid_high;
}



 // Handle input from the user
HRESULT ProcessInput( void )
{

   bool bButtonPressed;
   bool bFirstPress;
   bool bFirstXPress;
   bool bFirstYPress;
   int  nThumbY = 0;
   int  nThumbX = 0;

   // Update the state of all controllers
   Controllers.ProcessInput();

   // A BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_A, bFirstPress );
   }

   // B BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_B, bFirstPress );
   }

   // X BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_X, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_X, bFirstPress );
   }

   // Y BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_Y, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_Y, bFirstPress );
   }

   // BLACK BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_BLACK, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_BLACK, bFirstPress );
   }

   // WHITE BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_WHITE, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_WHITE, bFirstPress );
   }

   // LEFT TRIGGER BUTTON
   if ( bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, BUTTON_THRESHOLD, &bFirstPress ) ) {
      HandleInput( BUTTON_LEFT_TRIGGER, bFirstPress );
   }

   // UP DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_UP, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_UP, bFirstPress );
   }

   // DOWN DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_DOWN, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_DOWN, bFirstPress );
   }

   // LEFT DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_LEFT, bFirstPress );
   }

   // RIGHT DPAD
   if ( bButtonPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, &bFirstPress ) ) {
      HandleInput( CONTROL_DPAD_RIGHT, bFirstPress );
   }

   // LEFT THUMB STICK
   nThumbY = Controllers.GetJoystickY( PORT_ANY, JOYSTICK_LEFT, JOYSTICK_DEAD_ZONE, &bFirstYPress );
   nThumbX = Controllers.GetJoystickX( PORT_ANY, JOYSTICK_LEFT, JOYSTICK_DEAD_ZONE, &bFirstXPress );
   if ( ( nThumbY != 0 ) || ( nThumbX != 0 ) ) {
      HandleInput( JOYSTICK_LEFT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
   }

   // RIGHT THUMB STICK
   nThumbY = Controllers.GetJoystickY( PORT_ANY, JOYSTICK_RIGHT, JOYSTICK_DEAD_ZONE, &bFirstYPress );
   nThumbX = Controllers.GetJoystickX( PORT_ANY, JOYSTICK_RIGHT, JOYSTICK_DEAD_ZONE, &bFirstXPress );
   if ( ( nThumbY != 0 ) || ( nThumbX != 0 ) ) {
      HandleInput( JOYSTICK_RIGHT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
   }
   
   XDBGWRN( APP_TITLE_NAME_A, "Process Input Finished.");

   return S_OK;
}


// Handle the Joystick Input
void 
HandleInput( enum JOYSTICK joystick, 
             int  nThumbY, 
             int  nThumbX, 
             bool bFirstYPress, 
             bool bFirstXPress )
{
   switch ( joystick ) {
   // This is the LEFT Thumb Joystick on the controller
   case JOYSTICK_LEFT:
      {
         // Y
         if ( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) { // Move the left joystick down
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
         } else if ( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) {// Move left joystick up
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_UP, bFirstYPress );
         }

         // X
         if ( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) { // Move the left joystick left
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
         } else if ( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) {// Move the left joystick right
            HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
         }
         break;
      }
      // This is the RIGHT Thumb Joystick on the controller
   case JOYSTICK_RIGHT:
      {
         // Y
         if ( nThumbX < 0 ) { // Move the right joystick to the left
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );

         } else if ( nThumbX > 0 ) { // Move right joystick to the right
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_UP, bFirstYPress );
         }
         // X
         if ( nThumbX < 0 ) { // Move the right joystick left
            // Hand off this to the "DPad" handler
            HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
         } else if ( nThumbX > 0 ) { // Move the right joystick right
            HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
         }
         break;
      }
   }
}


// Handles input (of the CONTROLS) for the current menu
void 
HandleInput( enum CONTROLS controlPressed, 
             bool bFirstPress )
{
   if ( bFirstPress ) {
      
      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
   
   } else { // Check to see if the repeat press is within our timer, otherwise bail
      
      // If the interval is too small, bail
      if ( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval ) {
         return;
      }
      
      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
   }


    // Handle Buttons being pressed
    switch( controlPressed )
    {
	case CONTROL_START:
		{
			break;
		}
	case CONTROL_BACK:
		{
			break;
		}
	case CONTROL_LEFT_THUMB:
		{
			break;
		}
	case CONTROL_RIGHT_THUMB:
		{
			break;
		}
    case CONTROL_DPAD_UP:
        {
			if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos--;
			}
			else if( ( m_yKeypos != 0 ) && ( !m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos = m_yKeypos - 2;
			}
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
         if ( ( m_yKeypos != 3 ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) ) {
            m_yKeypos++;
         } else if ( ( m_yKeypos != 3 ) && ( !m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) ) {
            m_yKeypos = m_yKeypos + 2;
         }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
			if( m_xKeypos != 0 )
			{
				m_xKeypos--;
			}
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
			if( ( m_xKeypos != 9 ) && ( m_keyPad[m_xKeypos + 1][m_yKeypos].getRender())) 
			{
				m_xKeypos++;
			}
			else if((m_xKeypos != 9) && (!m_keyPad[m_xKeypos + 1][m_yKeypos].getRender()))
			{
				m_xKeypos++;
				m_yKeypos--;
			}
            break;
        }
	}
}



// Handles input (of the BUTTONS) for the current menu
void 
HandleInput( enum BUTTONS buttonPressed, 
             bool bFirstPress )
{

   if ( bFirstPress ) {
      m_bDropKeyPress = false;

      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
   } else { // Check to see if the repeat press is within our timer, otherwise bail
      // If the interval is too small, bail
      if ( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval ) {
         return;
      }
      m_keyPressDelayTimer = GetTickCount();
      m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
   }

   if ( m_bDropKeyPress ) {
      return;
   }

   // Handle Buttons being pressed
   g_iSerialNumberIndex = wcslen(g_szSerialNumber) - 1;
   
   switch ( buttonPressed ) {
   case BUTTON_A:
      {
         // Deal with keyboard input
         if (0 == wcscmp(m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"")) {            //backspace
            
            if (4 == g_iSerialNumberIndex ||
                8 == g_iSerialNumberIndex ||
                16 == g_iSerialNumberIndex ) {
               g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
            }
            g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
            XDBGTRC( APP_TITLE_NAME_A, "%s", g_szSerialNumber );
         
         } else if (0 == wcscmp(m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok")) {      //ok
            
            if (22 > g_iSerialNumberIndex) {
               break;
            }
            g_bLoop = FALSE;
            m_xKeypos = m_yKeypos = 0;
            XDBGTRC( APP_TITLE_NAME_A, "CKeyboardMenu::HandleInput():Ok Selected" );
         }else {
            if (4 == g_iSerialNumberIndex ||
                8 == g_iSerialNumberIndex ||
                16 == g_iSerialNumberIndex ) {
               wcscat(g_szSerialNumber, L"-");
            }
            if (21 >= g_iSerialNumberIndex )
               wcscat(g_szSerialNumber, m_keyPad[m_xKeypos][m_yKeypos].resultChar);
         }


         break;
      }
   case BUTTON_B:
      {
         //m_xKeypos = m_yKeypos = 0;
         // erase a character; backup
         if (5 == g_iSerialNumberIndex ||
             9 == g_iSerialNumberIndex ||
             17 == g_iSerialNumberIndex ) {
            g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
         }
         g_szSerialNumber[g_iSerialNumberIndex] = L'\0';
         break;
      }
   case BUTTON_X:
      {
         break;
      }
   case BUTTON_Y:
      {
         break;
      }
   case BUTTON_BLACK:
      {
         break;
      }
   case BUTTON_WHITE:
      {
         break;
      }
   case BUTTON_LEFT_TRIGGER:
      {
         break;
      }
   case BUTTON_RIGHT_TRIGGER:
      {
         break;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_
#include "constants.h"

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Buttons
enum BUTTONS
{
    BUTTON_MIN = 0,
    BUTTON_A = 0,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LEFT_TRIGGER,
    BUTTON_RIGHT_TRIGGER,

    BUTTON_MAX
};

enum CONTROLS
{
    CONTROL_MIN = 0,
    CONTROL_DPAD_UP = 0,
    CONTROL_DPAD_DOWN,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_BACK,
	CONTROL_LEFT_THUMB,
	CONTROL_RIGHT_THUMB,

    CONTROL_MAX
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_MIN = 0,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4,

    PORT_MAX
};

// Joysticks
enum JOYSTICK
{
    JOYSTICK_ANY = -1,
    JOYSTICK_MIN = 0,
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT,

    JOYSTICK_MAX
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER = 0,
    SLOT_TOP,
    SLOT_BOTTOM,
    
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port )
        {
            for( unsigned int button = 0; button < NUM_DUKE_BUTTONS; ++button )
            {
                nButtonPress[port][button] = 0;
            }

            for( unsigned int control = 0; control < NUM_DUKE_CONTROLS; ++control )
            {
                bControlPressed[port][control] = false;
            }

            for( unsigned int joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                sThumbX[port][joystick] = 0;
                sThumbY[port][joystick] = 0;
            }

            dwControllerState[port] = 0;
        }
    };
    
    ~CControllerState(){};


   // Public Properties
   BYTE nButtonPress[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
   bool bControlPressed[NUM_XBOX_PORTS][CONTROL_MAX];
   SHORT sThumbX[NUM_XBOX_PORTS][JOYSTICK_MAX];
   SHORT sThumbY[NUM_XBOX_PORTS][JOYSTICK_MAX];
   DWORD dwControllerState[NUM_XBOX_PORTS];private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        XInputClose( duke );
        duke = 0;
    }
};


class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    // Calling this will update the controller state objects with the latest info
    void ProcessInput( void );

    // Calling this will check to see if controllers we added or removed
    void CheckForHotplugs( void );

    // This will allow you to determine if a button is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    bool IsButtonPressed( int port, enum BUTTONS button, int nThreshold=0, bool* bFirstPress=NULL );
    
    // This will allow you to determine if a control is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the control
    bool IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress=NULL );

    // This will allow you to get the value of the X or Y axis, adjusting for a "dead zone".
    // If a dead zone is passed in, the call will return '0' unless the value of the X or Y axis
    // is greater than the dead zone value.  If an address to a boolean variable is provided, it
    // will return whether or not it's the 'first' press of the joystick
    int  GetJoystickX( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );
    int  GetJoystickY( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );

    // Calling this will determine if there was movement for any item on a controller
    // Will return true if any button or thumbstick has changed since last poll
    bool MovementDetected( int port, int deadZone=0 );

private:
    CControllerState m_ControllerState;
    CControllerState m_PrevControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_
#include <xfont.h>

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader


    HRESULT  BeginScene( VOID );
    HRESULT  EndScene( VOID );

private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};



class Key
{
public:
	int xorigin, yorigin;		// x,y coordinate of the key's upper left pixel
	int width, height;			// width and height of the key
	DWORD selectColor;			// color to hilight the key with upon selection
	WCHAR* resultChar;			// value attached to the key
	bool render;				// should the key be rendered?

	// Constructors and Destructors
	Key();
	~Key();

	void define(int x, int y, int w, int h, DWORD color);
	void defineText(WCHAR* result);
	void setRender(bool value);
	bool getRender(void);
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\o\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>

#define KEYPAD_NUM_ROWS    4
#define KEYPAD_NUM_COLS    4
#define DISPLAY_NUM_ROWS    4
#define DISPLAY_NUM_COLS    4

#define APP_TITLE_NAME_A                        "XShell"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Menubox constants
#define MENUBOX_MAINAREA_X1                     102.0f
#define MENUBOX_MAINAREA_Y1                     135.0f
#define MENUBOX_MAINAREA_X2                     536.0f
#define MENUBOX_MAINAREA_Y2                     367.0f

#define MENUBOX_TITLEBAR_TEXT_XPOS              127.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1 + 5.0f
#define MENUBOX_SELECTBAR_X2                    MENUBOX_MAINAREA_X2 - 5.0f

#define MENUBOX_TEXT_TOP_BORDER                   2.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 9.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 4.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER)
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

// Display Settings Menu constants
#define DISPSETMENU_VIDEOHEADER_YPOS            149.0f      // Also in dispset.mnu file -- must be identical

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FONT_ALIAS_LEVEL                        4

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR
#define SCREEN_DEFAULT_TRANS_COLOR              SCREEN_DEFAULT_BACKGROUND_COLOR

// Settings Menu contants - These should match the numbers in 'settings.mnu'
#define SETTINGSMENU_OPTIONHEADER_COLOR          COLOR_DARK_GREEN2 // COLOR_MEDIUM_GREEN
#define SETTINGSMENU_VIDSET_YPOS                 173.0f
#define SETTINGSMENU_VIDSET_TEXT                 L"Video :"
#define SETTINGSMENU_IPADDR_YPOS                 249.0f
#define SETTINGSMENU_IPADDR_TEXT                 L"IP address :"
#define SETTINGSMENU_SUBNET_YPOS                 277.0f
#define SETTINGSMENU_SUBNET_TEXT                 L"Subnet mask :"
#define SETTINGSMENU_GATEWY_YPOS                 305.0f
#define SETTINGSMENU_GATEWY_TEXT                 L"Gateway :"
#define SETTINGSMENU_MANAME_YPOS                 334.0f
#define SETTINGSMENU_MANAME_TEXT                 L"Machine name :"

static float g_fSettingsItemYPos[] = {
    SETTINGSMENU_VIDSET_YPOS,             // Item 0
    SETTINGSMENU_IPADDR_YPOS,             // Item 1
    SETTINGSMENU_SUBNET_YPOS,             // Item 2
    SETTINGSMENU_GATEWY_YPOS,             // Item 3
    SETTINGSMENU_MANAME_YPOS              // Item 4
};

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              MENUBOX_MAINAREA_Y2 + 20.0f // ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 40.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      18
#define MENU_LAUNCH_MACHINENAME_COLOR           SCREEN_DEFAULT_TEXT_FG_COLOR
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  114     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  126     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                114     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                361     // Bitmaps, use int

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_DARK_GREEN2
#define ITEM_SELECTED_HEADER_COLOR              COLOR_YELLOW
#define ITEM_SELECTED_VALUE_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_SELECTED_TEXT_COLOR                SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_XBELIST_FONT_HEIGHT                17
#define ITEM_FORMATMU_FONT_HEIGHT               17

// MU Format Dlg constants
#define MUFORMATDLG_SCREEN_DIM_VALUE            0x8F000000 // MMX way - 0x00707070
#define MUFORMATDLG_UNAVAIL_MU_COLOR            COLOR_DARK_GREEN2
#define MUFORMATDLG_AVAIL_MU_COLOR              SCREEN_DEFAULT_TEXT_FG_COLOR
#define MUFORMATDLG_SELECTED_MU_COLOR           ITEM_SELECTED_TEXT_COLOR
#define MUFORMATDLG_DELETE_MSG_YPOS             164.0f
#define MUFORMATDLG_DELETE_MSG                  L"All data will be erased from"
#define MUFORMATDLG_FORMATTING_MSG              L"Formatting..."
#define MUFORMATDLG_SUCCESS_MSG                 L"Format Successful!"
#define MUFORMATDLG_FAIL_MSG                    L"Format Failed!"
#define MUFORMATDLG_MSG_PAUSE                   1500

// Error Message Menu constants
#define ERRORMSGMENU_BUTTON1_TEXT               L"ok"
#define ERRORMSGMENU_MSG_FG_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ERRORMSGMENU_MSG_BG_COLOR               SCREEN_DEFAULT_TEXT_BG_COLOR
#define ERRORMSGMENU_MSG_YPOS                   189.0f

// Keypad and Keyboard location information
#define KEYBOARD_LINE_WIDTH                     1.0f
#define KEYPAD_LINE_WIDTH                       1.0f
#define KEYBOARD_TOPROW_Y1                      210
#define KEYPAD_TOPROW_Y1                        210
#define MENU_DISPSET_BUTTON_Y1                  186
#define MUFORMATDLG_BUTTON_Y1                   250
#define MUFORMATDLG_BUTTON_X1                   265
#define ERRORMSGMENU_BUTTON_Y1                  270
#define ERRORMSGMENU_BUTTON_X1                  265
#define KEYBOARD_MACHINENAMEHEADER_XPOS         153.0f                  // Must be identical to data in 'machine.mnu'
#define KEYBOARD_MACHINENAMEHEADER_YPOS         159.0f                  // Must be identical to data in 'machine.mnu'
#define KEYPAD_IPADDRHEADER_TEXT                L"IP address :"         // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_XPOS                191.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'
#define KEYPAD_IPADDRHEADER_YPOS                159.0f                  // Must be identical to text in 'ip.mnu', 'gateway.mnu', and 'subnet.mnu'


// File path and location constants
#define FILE_EXECUTABLE_DEVICE_PATH_A           "\\Device\\Harddisk0\\Partition1"
#define FILE_EXECUTABLE_DRIVE_A                 "c:"
#define FILE_EXECUTABLE_PATH_A                  "\\devkit"
#define FILE_EXECUTABLE_DIRECTORY_A             FILE_EXECUTABLE_DRIVE_A FILE_EXECUTABLE_PATH_A
#define FILE_EXECUTABLE_ALIAS_A                 "e:"
#define FILE_EXECUTABLE_EXENSION_A              ".XBE"
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

#define FILE_DATA_SETTINGS_FILENAME_A           "c:\\devkit\\xbdm.ini"
#define FILE_DATA_SETTINGS_SECTION_NAME_A       "[xbdm]"
#define FILE_DATA_SETTINGS_IP_TOKEN_A           "staticip addr="
#define FILE_DATA_SETTINGS_SUBNET_TOKEN_A       "subnetmask addr="
#define FILE_DATA_SETTI